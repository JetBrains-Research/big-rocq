[{"statement":"Lemma ectrl_ctrl_step (tid : thread_id) \n         s s' (STEP : step tid s s')\n         MOD (ECTRL: exists a, (MOD ∩₁ ectrl s') a)\n        (NCTRL: MOD ∩₁ dom_rel ((ctrl (G s'))) ⊆₁ ∅) :\n         (G s) = (G s').","proof":"destruct STEP; desc.\nred in H; desc.\ndestruct ISTEP0; try done.\nall: exfalso; eapply NCTRL.\nall: revert ECTRL;  unfolder; splits; try edone.\nall: desc; eauto; exists (ThreadEvent tid (eindex s)).\nall: rewrite UG; unfold add; ins; rewrite <- UECTRL; basic_solver.\n"},{"statement":"Lemma TWF_helper tid s1 (TWF : thread_wf tid s1): \n~ acts_set (G s1) (ThreadEvent tid ((eindex s1))).","proof":"red in TWF.\nintro.\nspecialize (TWF (ThreadEvent tid (eindex s1)) H); desf.\nlia.\n"},{"statement":"Lemma TWF_helper_rmw tid s1 (TWF : thread_wf tid s1): \n~ acts_set (G s1) (ThreadEvent tid ((eindex s1) + 1)).","proof":"red in TWF.\nintro.\nspecialize (TWF (ThreadEvent tid (eindex s1 +1)) H); desf.\nlia.\n"},{"statement":"Lemma acts_increasing (tid : thread_id) s s' (STEP : step tid s s') :\n  (acts_set (G s)) ⊆₁ (acts_set (G s')).","proof":"destruct STEP; desc.\nred in H; desc.\ndestruct ISTEP0.\nall: rewrite UG; try done.\nall: unfold add, add_rmw, acts_set; ins.\nall: unfolder; ins; desc; eauto.\n"},{"statement":"Lemma is_r_ex_increasing (tid : thread_id) s s' (STEP : step tid s s') (TWF : thread_wf tid s):\n  (acts_set (G s)) ∩₁ R_ex (lab (G s)) ⊆₁ R_ex (lab (G s')).","proof":"destruct STEP; desc.\nred in H; desc.\ndestruct ISTEP0.\nall: rewrite UG; try done.\nall: unfold add, add_rmw, R_ex; ins.\nall: unfolder; ins; desc; eauto.\nall: rewrite !updo; try done.\nall: try by (intro; subst; eapply TWF_helper; edone).\nall: try by (intro; subst; eapply TWF_helper_rmw; edone).\n"},{"statement":"Lemma is_r_increasing (tid : thread_id) s s' (STEP : step tid s s') (TWF : thread_wf tid s):\n  (acts_set (G s)) ∩₁ is_r (lab (G s)) ⊆₁ is_r (lab (G s')).","proof":"destruct STEP; desc.\nred in H; desc.\ndestruct ISTEP0.\nall: rewrite UG; try done.\nall: unfold add, add_rmw, is_r; ins.\nall: unfolder; ins; desc; eauto.\nall: rewrite !updo; try done.\nall: try by (intro; subst; eapply TWF_helper; edone).\nall: try by (intro; subst; eapply TWF_helper_rmw; edone).\n"},{"statement":"Lemma is_w_increasing (tid : thread_id) s s' (STEP : step tid s s') (TWF : thread_wf tid s):\n  (acts_set (G s)) ∩₁ is_w (lab (G s)) ⊆₁ is_w (lab (G s')).","proof":"destruct STEP; desc.\nred in H; desc.\ndestruct ISTEP0.\nall: rewrite UG; try done.\nall: unfold add, add_rmw, is_w; ins.\nall: unfolder; ins; desc; eauto.\nall: rewrite !updo; try done.\nall: try by (intro; subst; eapply TWF_helper; edone).\nall: try by (intro; subst; eapply TWF_helper_rmw; edone).\n"},{"statement":"Lemma regf_expr_helper regf regf' depf MOD expr\n  (REGF : forall reg, RegFun.find reg regf = RegFun.find reg regf' \\/ \n           (exists a, RegFun.find reg depf a /\\ MOD a))\n  (NDEP: forall a (IN: MOD a), ~ DepsFile.expr_deps depf expr a):\n  RegFile.eval_expr regf expr = RegFile.eval_expr regf' expr.","proof":"unfold DepsFile.expr_deps, DepsFile.val_deps in NDEP.\nunfold RegFile.eval_expr, RegFile.eval_value.\ndestruct expr.\n- destruct val; [by vauto| specialize (REGF reg); desf].\nexfalso; eapply NDEP; edone.\n- destruct op0; [by vauto| specialize (REGF reg); desf].\nrewrite REGF; auto.\nexfalso; eapply NDEP; edone.\n- destruct op1, op2.\n* by vauto.\n* specialize (REGF reg); desf; [rewrite REGF|]; eauto.\nexfalso; eapply NDEP; [edone| basic_solver].\n* specialize (REGF reg); desf; [rewrite REGF|]; eauto.\nexfalso; eapply NDEP; [edone| basic_solver].\n* generalize (REGF reg0); intro REGF0.\nspecialize (REGF reg).\ndesf.\nby rewrite REGF, REGF0; auto.\nall: exfalso; eapply NDEP; [edone| basic_solver].\n"},{"statement":"Lemma regf_lexpr_helper regf regf' depf MOD expr\n  (REGF : forall reg, RegFun.find reg regf = RegFun.find reg regf' \\/ \n            (exists a, RegFun.find reg depf a /\\ MOD a))\n  (NDEP: forall a (IN: MOD a), ~ DepsFile.lexpr_deps depf expr a):\n  RegFile.eval_lexpr regf expr = RegFile.eval_lexpr regf' expr.","proof":"unfold DepsFile.lexpr_deps in NDEP.\nunfold RegFile.eval_lexpr.\ndesf; exfalso; apply n; erewrite regf_expr_helper; eauto.\nins; specialize (REGF reg); desf; eauto.\n"},{"statement":"Lemma sim_execution_same_r G G' MOD (EXEC: sim_execution G G' MOD) :\nis_r (lab G') ≡₁ is_r (lab G).","proof":"red in EXEC; desf.\neby erewrite same_lab_u2v_is_r.\n"},{"statement":"Lemma sim_execution_same_w G G' MOD (EXEC: sim_execution G G' MOD) :\nis_w (lab G') ≡₁ is_w (lab G).","proof":"red in EXEC; desf.\neby erewrite same_lab_u2v_is_w.\n"},{"statement":"Lemma sim_execution_same_acts G G' MOD (EXEC: sim_execution G G' MOD) :\nacts_set G ≡₁ acts_set G'.","proof":"red in EXEC; desf.\nby rewrite ACTS.\n"},{"statement":"Lemma receptiveness_sim_assign (tid : thread_id)\n  s1 s2 (INSTRS0 : instrs s1 = instrs s2)\n  (reg : Reg.t) (expr : Instr.expr)\n  (ISTEP : Some (Instr.assign reg expr) = nth_error (instrs s1) (pc s1))\n  (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1)\n  (UINDEX : eindex s2 = eindex s1)\n  (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr) (regf s1))\n  (UDEPS : depf s2 = RegFun.add reg (DepsFile.expr_deps (depf s1) expr) (depf s1))\n  (UECTRL : ectrl s2 = ectrl s1)\n  MOD (new_rfi : relation actid) new_val\n  s1' (SIM: sim_state s1 s1' MOD new_rfi new_val) :\n exists s2', (step tid) s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","proof":"red in SIM; desc.\ncut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\n* eexists; red; splits; [by ins; eauto|].\neby eexists; splits; [ rewrite <- INSTRS, <- PC| eapply assign; reflexivity].\n* ins; congruence.\n* ins; congruence.\n* ins; congruence.\n* ins; congruence.\n* ins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf.\ndestruct (classic ((exists a : actid, DepsFile.expr_deps (depf s1) expr a /\\ MOD a))) as [A|A].\nby auto.\nby left; apply (regf_expr_helper (regf s1) (regf s1') (depf s1) MOD expr REGF); eauto.\n* ins; congruence.\n* ins; congruence.\n* by ins; apply NEW_VAL1; try done; rewrite <- UG.\n* by ins; apply NEW_VAL2; try done; rewrite <- UG.\n"},{"statement":"Lemma receptiveness_sim_if_else (tid : thread_id)\n  s1 s2 (INSTRS0 : instrs s1 = instrs s2)\n  (expr : Instr.expr) (shift : nat)\n  (e : RegFile.eval_expr (regf s1) expr = 0)\n  (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1))\n  (UPC : pc s2 = pc s1 + 1) (UG : G s2 = G s1)\n  (UINDEX : eindex s2 = eindex s1)\n  (UREGS : regf s2 = regf s1)\n  (UDEPS : depf s2 = depf s1)\n  (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1)\n  MOD (new_rfi : relation actid) new_val\n  (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅)\n  s1' (SIM: sim_state s1 s1' MOD new_rfi new_val) :\n exists s2', (step tid) s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","proof":"red in SIM; desc.\ncut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\neexists.\nexists (if Const.eq_dec (RegFile.eval_expr (regf s1') expr) 0        then pc s1' + 1 else shift).\ndo 5 eexists; splits; red; splits.\n* eexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC|].\neapply if_; try reflexivity; ins; desf.\n* ins; congruence.\n* ins.\nerewrite <- regf_expr_helper with (regf:= regf s1).\ndesf; congruence.\neauto.\nins; intro; eapply NCTRL; rewrite UECTRL; basic_solver.\n* ins; congruence.\n* ins; congruence.\n* ins; rewrite UREGS, UDEPS; eauto.\n* ins; congruence.\n* ins; congruence.\n* by ins; apply NEW_VAL1; try done; rewrite <- UG.\n* by ins; apply NEW_VAL2; try done; rewrite <- UG.\n"},{"statement":"Lemma receptiveness_sim_if_then (tid : thread_id)\n  s1 s2 (INSTRS0 : instrs s1 = instrs s2)\n  (expr : Instr.expr) (shift : nat)\n  (n : RegFile.eval_expr (regf s1) expr <> 0)\n  (ISTEP : Some (Instr.ifgoto expr shift) = nth_error (instrs s1) (pc s1))\n  (UPC : pc s2 = shift) (UG : G s2 = G s1)\n  (UINDEX : eindex s2 = eindex s1)\n  (UREGS : regf s2 = regf s1)\n  (UDEPS : depf s2 = depf s1)\n  (UECTRL : ectrl s2 = DepsFile.expr_deps (depf s1) expr ∪₁ ectrl s1)\n  MOD (new_rfi : relation actid) new_val\n  (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅)\n  s1' (SIM: sim_state s1 s1' MOD new_rfi new_val) :\n exists s2', (step tid) s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","proof":"red in SIM; desc.\ncut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\neexists.\nexists (if Const.eq_dec (RegFile.eval_expr (regf s1') expr) 0        then pc s1' + 1 else shift).\ndo 5 eexists; splits; red; splits.\n* eexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC|].\neapply if_; try reflexivity; ins; desf.\n* ins; congruence.\n* ins.\nerewrite <- regf_expr_helper with (regf:= regf s1).\ndesf; congruence.\neauto.\nins; intro; eapply NCTRL; rewrite UECTRL; basic_solver.\n* ins; congruence.\n* ins; congruence.\n* ins; rewrite UREGS, UDEPS; eauto.\n* ins; congruence.\n* ins; congruence.\n* by ins; apply NEW_VAL1; try done; rewrite <- UG.\n* by ins; apply NEW_VAL2; try done; rewrite <- UG.\n"},{"statement":"Lemma new_rfi_unique (new_rfi : relation actid)\n      (new_rfif : functional new_rfi⁻¹):\nforall r, exists ! w, (new_rfi_ex new_rfi)⁻¹  r w.","proof":"ins.\ndestruct (classic ((codom_rel new_rfi) r)) as [X|X].\n- unfolder in X; desf.\nexists x; red; splits.\nunfold new_rfi_ex; basic_solver 12.\nunfold new_rfi_ex; unfolder; ins; desf.\neapply new_rfif; basic_solver.\nexfalso; eauto.\n- exists r; red; splits.\nunfold new_rfi_ex; basic_solver 12.\nunfold new_rfi_ex; unfolder; ins; desf.\nunfolder in X; exfalso; eauto.\n"},{"statement":"Lemma RFI_index_helper tid s new_rfi (TWF : thread_wf tid s)\n   (RFI_INDEX : new_rfi ⊆ ext_sb)\n   w r (RFI: new_rfi w r) \n  (IN: ThreadEvent tid (eindex s) = r \\/ (acts_set (G s)) r) :\n   w <> ThreadEvent tid ((eindex s)).","proof":"intro; subst; desf.\napply RFI_INDEX in RFI.\neby eapply ext_sb_irr.\nspecialize (TWF r IN); desf.\napply RFI_INDEX in RFI.\nunfold sb, ext_sb in RFI; unfolder in RFI; desf; lia.\n"},{"statement":"Lemma receptiveness_sim_load (tid : thread_id)\n  s1 s2 (INSTRS0 : instrs s1 = instrs s2)\n  (ord : mode) (reg : Reg.t)\n  (lexpr : Instr.lexpr) (ISTEP : Some (Instr.load ord reg lexpr) = nth_error (instrs s1) (pc s1))\n  (val_ : value) (UPC : pc s2 = pc s1 + 1)\n  (UG : G s2 =\n     add (G s1) tid (eindex s1)\n       (Aload false ord (RegFile.eval_lexpr (regf s1) lexpr) val_) \n       ∅ (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) \n       ∅)\n  (UINDEX : eindex s2 = eindex s1 + 1)\n  (UREGS : regf s2 = RegFun.add reg val_ (regf s1))\n  (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1))\n  (UECTRL : ectrl s2 = ectrl s1)\n  MOD (new_rfi : relation actid) new_val\n  (NADDR : MOD ∩₁ dom_rel ((addr (G s2))) ⊆₁ ∅)\n  (RFI_INDEX : new_rfi ⊆ ext_sb)\n  (TWF : thread_wf tid s1)\n  (new_rfif : functional new_rfi⁻¹)\n  s1' (SIM: sim_state s1 s1' MOD new_rfi new_val) :\n exists s2', (step tid) s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","proof":"generalize (@new_write new_rfi new_rfif); intro F; destruct F as [new_w F].\nred in SIM; desc.\nassert (SAME_LOC: RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr).\n{\nins; eapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add; basic_solver.\n}\ncut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\n* eexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply load with (val :=       if excluded_middle_informative (MOD (ThreadEvent tid (eindex s1')))       then if excluded_middle_informative ((codom_rel new_rfi) (ThreadEvent tid (eindex s1')))            then (get_val (val (lab (G s1')) (new_w (ThreadEvent tid (eindex s1')))))           else (new_val (ThreadEvent tid (eindex s1')))      else val_);    reflexivity.\n* ins; congruence.\n* ins; congruence.\n* ins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\n+ by rewrite EINDEX, ACTS.\n+ by rewrite TS.\n+ rewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\n{\nby subst; rewrite !upds.\n}\nins.\nrewrite !updo; auto.\n+ rewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\n+ by rewrite DATA, EINDEX.\n+ by rewrite ADDR, EINDEX, DEPF.\n+ by rewrite CTRL, EINDEX, ECTRL.\n+ by rewrite FRMW, EINDEX.\n* ins; congruence.\n* ins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\n* eby ins; rewrite <- DEPF, <- EINDEX.\n* ins; congruence.\n* simpl; ins.\nunfold add, acts_set in INw; ins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\n+ exfalso; eapply RFI_index_helper.\nedone.\neapply RFI_INDEX.\nedone.\nunfold add, acts_set in INr; ins.\nrewrite EINDEX; destruct INr; [eauto|].\nright; eapply sim_execution_same_acts; eauto.\nby rewrite EINDEX.\n+ destruct INw as [X|INw]; [desf|].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\n-- unfold val in *; rewrite !upds.\nrewrite !updo; try done.\ndestruct (excluded_middle_informative (MOD (ThreadEvent tid (eindex s1')))); [|desf].\ndestruct (excluded_middle_informative (codom_rel new_rfi (ThreadEvent tid (eindex s1')))).\n2: by exfalso; apply n0; basic_solver 12.\nassert (w = new_w (ThreadEvent tid (eindex s1'))).\n{\nassert (U: exists ! w1 : actid, (new_rfi_ex new_rfi)⁻¹ (ThreadEvent tid (eindex s1')) w1).\napply new_rfi_unique, new_rfif.\neapply unique_existence with            (P:= fun x => (@new_rfi_ex new_rfi)⁻¹ (ThreadEvent tid (eindex s1')) x) in U; desc.\neapply U0.\nunfold new_rfi_ex.\nbasic_solver.\napply F.\n}\nunfold is_w in WRITE; rewrite updo in WRITE; desf.\n-- unfold val in *; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\n{\nunfolder in INr.\ndesf.\n}\n{\nby unfold is_r in *; rewrite updo in READ.\n}\nby unfold is_w in *; rewrite updo in WRITE.\n* simpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\n+ destruct (excluded_middle_informative (MOD (ThreadEvent tid (eindex s1')))); [subst|desf].\ndestruct (excluded_middle_informative (codom_rel new_rfi (ThreadEvent tid (eindex s1')))); [desf|].\nby unfold val in *; rewrite !upds.\n+ unfold val in *; rewrite !updo; try done.\napply NEW_VAL2; try done.\n{\nby unfold is_r in *; rewrite updo in READ.\n}\nby unfolder in IN; unfold add in IN; ins; desf.\n"},{"statement":"Lemma receptiveness_sim_store (tid : thread_id)\n  s1 s2 (INSTRS0 : instrs s1 = instrs s2)\n  (ord : mode) (reg : Reg.t)\n  (lexpr : Instr.lexpr) (expr : Instr.expr)\n  (ISTEP : Some (Instr.store ord lexpr expr) = nth_error (instrs s1) (pc s1))\n  (UPC : pc s2 = pc s1 + 1)\n  (UG : G s2 = add (G s1) tid (eindex s1)\n         (Astore Xpln ord (RegFile.eval_lexpr (regf s1) lexpr) (RegFile.eval_expr (regf s1) expr)) \n         (DepsFile.expr_deps (depf s1) expr) (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1) ∅) \n  (UINDEX : eindex s2 = eindex s1 + 1)\n  (UREGS : regf s2 = regf s1)\n  (UDEPS : depf s2 = depf s1)\n  (UECTRL : ectrl s2 = ectrl s1)\n  MOD (new_rfi : relation actid) new_val\n  (NADDR : MOD ∩₁ dom_rel ((addr (G s2))) ⊆₁ ∅)\n  (NDATA: ⦗MOD⦘ ⨾ (data (G s2)) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂)\n   (RFI_INDEX : new_rfi ⊆ ext_sb)\n  (TWF : thread_wf tid s1)\n  s1' (SIM: sim_state s1 s1' MOD new_rfi new_val) :\n exists s2', (step tid) s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","proof":"red in SIM; desc.\nassert (SAME_LOC: RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr).\n{\nins; eapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add; basic_solver.\n}\ncut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\n* eexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply store; reflexivity.\n* ins; congruence.\n* ins; congruence.\n* ins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\n+ by rewrite EINDEX, ACTS.\n+ by rewrite TS.\n+ rewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\n{\nby subst; rewrite !upds.\n}\nrewrite !updo; auto.\n+ rewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))); subst.\n-- desf; unfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\n-- unfold val;  rewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\n+ by rewrite DATA, EINDEX, DEPF.\n+ by rewrite ADDR, EINDEX, DEPF.\n+ by rewrite CTRL, EINDEX, ECTRL.\n+ by rewrite FRMW, EINDEX.\n* ins; congruence.\n* ins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\n* by ins; rewrite <- DEPF, <- UDEPS.\n* ins; congruence.\n* simpl; ins.\nunfold add, acts_set in INw; ins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\n+ exfalso; eapply RFI_index_helper.\nedone.\neapply RFI_INDEX.\nedone.\nunfold add, acts_set in INr; ins.\nrewrite EINDEX; destruct INr; [eauto|].\nright; eapply sim_execution_same_acts; eauto.\nby rewrite EINDEX.\n+ destruct INw as [X|INw]; [desf|].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite !upds in READ; desf.\nunfold val in *; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\n{\nunfolder in INr; desf.\n}\n{\nby unfold is_r in *; rewrite updo in READ.\n}\nby unfold is_w in *; rewrite updo in WRITE.\n* simpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite upds in READ; desf.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf.\n"},{"statement":"Lemma receptiveness_sim_fence (tid : thread_id)\n  s1 s2 (INSTRS0 : instrs s1 = instrs s2)\n  (ord : mode) \n  (ISTEP : Some (Instr.fence ord) = nth_error (instrs s1) (pc s1))\n  (UPC : pc s2 = pc s1 + 1)\n  (UG : G s2 = add (G s1) tid (eindex s1) (Afence ord) ∅ ∅ (ectrl s1) ∅)\n  (UINDEX : eindex s2 = eindex s1 + 1)\n  (UREGS : regf s2 = regf s1)\n  (UDEPS : depf s2 = depf s1)\n  (UECTRL : ectrl s2 = ectrl s1)\n  MOD (new_rfi : relation actid) new_val\n  s1' (SIM: sim_state s1 s1' MOD new_rfi new_val) :\n exists s2', (step tid) s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","proof":"red in SIM; desc.\ncut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\n* eexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply fence; reflexivity.\n* ins; congruence.\n* ins; congruence.\n* ins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\n+ by rewrite EINDEX, ACTS.\n+ by rewrite TS.\n+ rewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\n{\nby subst; rewrite !upds.\n}\nrewrite !updo; auto.\n+ rewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\n+ by rewrite DATA, EINDEX.\n+ by rewrite ADDR, EINDEX.\n+ by rewrite CTRL, EINDEX, ECTRL.\n+ by rewrite FRMW, EINDEX.\n* ins; congruence.\n* ins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\n* by ins; rewrite <- DEPF, <- UDEPS.\n* ins; congruence.\n* ins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_w in WRITE; rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in READ; rewrite upds in READ; desf.\nunfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\n{\nunfolder in INr; desf.\n}\n{\nunfolder in INw; desf.\n}\n{\nunfold is_r in *; rewrite updo in READ; try edone.\n}\nunfold is_w in *; rewrite updo in WRITE; try edone.\n* simpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_r in *; rewrite upds in READ; desf.\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN; desf.\n"},{"statement":"Lemma receptiveness_sim_cas_fail (tid : thread_id)\n  s1 s2 (INSTRS0 : instrs s1 = instrs s2)\n  (CASREX : cas_produces_R_ex_instrs (instrs s1))\n  (expr_old expr_new : Instr.expr)\n  rexmod\n  xmod\n  (ordr ordw : mode)\n  (reg : Reg.t)\n  (lexpr : Instr.lexpr)\n  (ISTEP : Some (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\n           nth_error (instrs s1) (pc s1))\n  (val_ : value)\n  (NEXPECTED : val_ <> RegFile.eval_expr (regf s1) expr_old)\n  (UPC : pc s2 = pc s1 + 1)\n  (UG : G s2 =\n        add (G s1) tid (eindex s1)\n            (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr) val_) \n            ∅ (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n            (DepsFile.expr_deps (depf s1) expr_old))\n  (UINDEX : eindex s2 = eindex s1 + 1)\n  (UREGS : regf s2 = RegFun.add reg val_ (regf s1))\n  (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1))\n  (UECTRL : ectrl s2 = ectrl s1)\n  MOD (new_rfi : relation actid) new_val\n  (NFRMW: MOD ∩₁ dom_rel ((rmw_dep (G s2))) ⊆₁ ∅)\n  (NADDR : MOD ∩₁ dom_rel ((addr (G s2))) ⊆₁ ∅)\n  (NREX:  MOD ∩₁ (acts_set (G s2)) ∩₁ (R_ex (lab (G s2))) ⊆₁ ∅) \n  s1' (SIM: sim_state s1 s1' MOD new_rfi new_val) :\n  exists s2', (step tid) s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","proof":"red in SIM; desc.\nassert (rexmod = true); subst.\n{\nclear -ISTEP CASREX.\nred in CASREX.\nset (AA:=ISTEP).\nsymmetry in AA.\napply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf.\n}\nassert (SAME_LOC: RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr).\n{\neapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add; basic_solver.\n}\ncut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\n* eexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply cas_un with (val := val_); try reflexivity.\nerewrite <- regf_expr_helper with (regf := (regf s1)); try edone.\nins; intro;  eapply NFRMW; rewrite UG; unfold add; ins; basic_solver.\n* ins; congruence.\n* ins; congruence.\n* ins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\n+ by rewrite EINDEX, ACTS.\n+ by rewrite TS.\n+ rewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\n{\nby subst; rewrite !upds; rewrite SAME_LOC.\n}\nrewrite !updo; auto.\n+ rewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\nrewrite SAME_LOC.\nby desf; unfold val; rewrite !upds.\nunfold val; rewrite !updo; [|intro; desf|intro; desf].\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\n+ by rewrite DATA, EINDEX.\n+ by rewrite ADDR, EINDEX, DEPF.\n+ by rewrite CTRL, EINDEX, ECTRL.\n+ by rewrite FRMW, EINDEX, DEPF.\n* ins; congruence.\n* ins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\n* eby ins; rewrite <- DEPF, <- EINDEX.\n* ins; congruence.\n* ins.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nby unfold is_w in WRITE; rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\n+ exfalso.\neapply NREX; split; [eauto|].\n{\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\n}\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds.\n+ unfold val; rewrite !updo; try done.\neapply NEW_VAL1; try edone.\n{\nunfolder in INr.\ndesf.\n}\n{\nunfolder in INw.\ndesf.\n}\n{\nunfold is_r in *; rewrite updo in READ; try edone.\n}\nunfold is_w in *; rewrite updo in WRITE; try edone.\n* simpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\n+ exfalso.\neapply NREX; split; [eauto|].\n{\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\n}\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite EINDEX, upds.\n+ unfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite updo in READ; try done.\nunfolder in IN.\ndesf.\n"},{"statement":"Lemma receptiveness_sim_cas_suc (tid : thread_id)\n  s1 s2 (INSTRS0 : instrs s1 = instrs s2)\n  (CASREX : cas_produces_R_ex_instrs (instrs s1))\n  (expr_old expr_new : Instr.expr)\n  rexmod xmod\n  (ordr ordw : mode)\n  (reg : Reg.t)\n  (lexpr : Instr.lexpr)\n  (ISTEP : Some (Instr.update (Instr.cas expr_old expr_new) rexmod xmod ordr ordw reg lexpr) =\n           nth_error (instrs s1) (pc s1))\n  (UPC : pc s2 = pc s1 + 1)\n  (UG : G s2 =\n        add_rmw (G s1) tid (eindex s1)\n                (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr)\n                       (RegFile.eval_expr (regf s1) expr_old))\n                (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n                        (RegFile.eval_expr (regf s1) expr_new))\n                (DepsFile.expr_deps (depf s1) expr_new)\n                (DepsFile.lexpr_deps (depf s1) lexpr) (ectrl s1)\n                (DepsFile.expr_deps (depf s1) expr_old))\n  (UINDEX : eindex s2 = eindex s1 + 2)\n  (UREGS : regf s2 = RegFun.add reg (RegFile.eval_expr (regf s1) expr_old) (regf s1))\n  (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1))\n  (UECTRL : ectrl s2 = ectrl s1)\n  MOD (new_rfi : relation actid) new_val\n  (NFRMW: MOD ∩₁ dom_rel ((rmw_dep (G s2))) ⊆₁ ∅)\n  (NADDR : MOD ∩₁ dom_rel ((addr (G s2))) ⊆₁ ∅)\n  (NREX:  MOD ∩₁ (acts_set (G s2)) ∩₁ (R_ex (lab (G s2))) ⊆₁ ∅) \n  (NDATA: ⦗MOD⦘ ⨾ (data (G s2)) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂)\n  (RFI_INDEX : new_rfi ⊆ ext_sb)\n  (TWF : thread_wf tid s1)\n  s1' (SIM: sim_state s1 s1' MOD new_rfi new_val) :\n  exists s2', (step tid) s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","proof":"red in SIM; desc.\nassert (rexmod = true); subst.\n{\nclear -ISTEP CASREX.\nred in CASREX.\nset (AA:=ISTEP).\nsymmetry in AA.\napply nth_error_In in AA.\napply CASREX in AA.\nred in AA.\ndesf.\n}\nassert (SAME_LOC: RegFile.eval_lexpr (regf s1) lexpr = RegFile.eval_lexpr (regf s1') lexpr).\n{\nins; eapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add_rmw; basic_solver.\n}\ncut (exists instrs pc G_ eindex regf depf ectrl,   step tid s1' {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |} /\\   (sim_state s2 {| instrs := instrs; pc := pc; G := G_; eindex := eindex; regf := regf; depf := depf; ectrl := ectrl |}  MOD new_rfi new_val)).\nby ins; desc; eauto.\ndo 7 eexists; splits; red; splits.\n* eexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply cas_suc; try reflexivity.\n* ins; congruence.\n* ins; congruence.\n* ins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG; ins.\nunfold acts_set, R_ex in NREX; ins.\nred in EXEC; desc.\nred; splits; ins.\n+ by rewrite EINDEX, ACTS.\n+ by rewrite TS.\n+ rewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\nby subst; rewrite !upds; rewrite SAME_LOC.\nrewrite updo; try done.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\nby subst; rewrite !upds; rewrite updo; [| by desf]; rewrite upds; rewrite SAME_LOC.\nrewrite !updo; auto.\n+ rewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\n-- subst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\n-- unfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\n** subst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NFRMW; unfolder; splits; eauto.\n** rewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\n+ by rewrite RMW, EINDEX.\n+ by rewrite DATA, EINDEX, DEPF.\n+ by rewrite ADDR, EINDEX, DEPF.\n+ by rewrite CTRL, EINDEX, ECTRL.\n+ by rewrite FRMW, EINDEX, DEPF.\n* ins; congruence.\n* ins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\nerewrite regf_expr_helper; eauto.\nins; intro; eapply NFRMW.\nrewrite UG; ins; basic_solver.\n* eby ins; rewrite <- DEPF, <- EINDEX.\n* ins; congruence.\n* ins; unfold acts_set, is_r, is_w in INr, INw, READ, WRITE; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\nby rewrite upds in READ; desf.\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nrewrite updo in WRITE; [| intro; desf; lia].\nby rewrite upds in WRITE; desf.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\n+ exfalso.\neapply NREX; split; [eauto|].\n{\nrewrite UG; unfold add; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\n}\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\n+ unfold val; rewrite updo; [|done].\nrewrite updo; [|done].\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'+1))); subst.\n-- exfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct r; [eauto|]; desc.\ndestruct INr as [[X|X]|INr]; try by desf.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ndesf; lia.\n-- rewrite !updo; try done.\neapply NEW_VAL1; try edone.\n{\nunfolder in INr; desf.\n}\n{\nunfolder in INw; desf.\n}\n{\nby rewrite !updo in READ; try edone.\n}\nby rewrite !updo in WRITE; try edone.\n* simpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\nby unfold is_r in READ; rewrite upds in READ; desf.\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\n+ exfalso.\neapply NREX; split; [eauto|].\n{\nrewrite UG; unfold add; unfold acts_set; ins.\nsplit; eauto.\nrewrite EINDEX; basic_solver.\n}\nrewrite UG; unfold add; unfold R_ex; ins.\nby rewrite updo; [| intro; desf; lia]; rewrite EINDEX, upds.\n+ unfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite !updo in READ; try done.\nunfolder in IN; desf.\n"},{"statement":"Lemma receptiveness_sim_inc (tid : thread_id)\n      s1 s2 (INSTRS0 : instrs s1 = instrs s2)\n      (expr_add : Instr.expr)\n      rexmod xmod\n      (ordr ordw : mode)\n      (reg : Reg.t)\n      (lexpr : Instr.lexpr)\n      (ISTEP : Some (Instr.update\n                       (Instr.fetch_add expr_add) rexmod xmod ordr ordw reg lexpr) =\n               nth_error (instrs s1) (pc s1))\n      (val_ : nat)\n      (UPC : pc s2 = pc s1 + 1)\n      (UG : G s2 =\n            add_rmw (G s1) tid (eindex s1)\n                    (Aload rexmod ordr\n                           (RegFile.eval_lexpr (regf s1) lexpr) val_)\n                    (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n                            (val_ + RegFile.eval_expr (regf s1) expr_add))\n                    ((eq (ThreadEvent tid (eindex s1))) ∪₁\n                     (DepsFile.expr_deps (depf s1) expr_add))\n                    (DepsFile.lexpr_deps (depf s1) lexpr)\n                    (ectrl s1) ∅)\n      (UINDEX : eindex s2 = eindex s1 + 2)\n      (UREGS : regf s2 = RegFun.add reg val_ (regf s1))\n      (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1))) (depf s1))\n      (UECTRL : ectrl s2 = ectrl s1)\n      MOD (new_rfi : relation actid) new_val\n      (NFRMW: MOD ∩₁ dom_rel ((rmw_dep (G s2))) ⊆₁ ∅)\n      (NADDR : MOD ∩₁ dom_rel ((addr (G s2))) ⊆₁ ∅)\n      (NREX:  MOD ∩₁ (acts_set (G s2)) ∩₁ (R_ex (lab (G s2))) ⊆₁ ∅) \n      (NDATA: ⦗MOD⦘ ⨾ (data (G s2)) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂)\n      (TWF : thread_wf tid s1)\n      (RFI_INDEX : new_rfi ⊆ ext_sb)\n      (new_rfif : functional new_rfi⁻¹)\n      s1' (SIM: sim_state s1 s1' MOD new_rfi new_val) :\n exists s2', (step tid) s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","proof":"generalize (@new_write new_rfi new_rfif); intro F; destruct F as [new_w F].\nred in SIM; desc.\nassert (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr =                     RegFile.eval_lexpr (regf s1') lexpr).\n{\nins; eapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add_rmw; basic_solver.\n}\ncut (exists instrs pc G_ eindex regf depf ectrl,           step tid s1' (Build_state instrs pc G_ eindex regf depf ectrl) /\\           (sim_state s2 (Build_state instrs pc G_ eindex regf depf ectrl)                     MOD new_rfi new_val)).\n{\nins; desc; eauto.\n}\ndo 7 eexists; splits; red; splits.\n{\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply inc with (val :=       if excluded_middle_informative (MOD (ThreadEvent tid (eindex s1')))       then if excluded_middle_informative ((codom_rel new_rfi) (ThreadEvent tid (eindex s1')))            then (get_val (val (lab (G s1')) (new_w (ThreadEvent tid (eindex s1')))))           else (new_val (ThreadEvent tid (eindex s1')))      else val_);    reflexivity.\n}\n1,2,4,7: ins; congruence.\n{\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\n{\nby rewrite EINDEX, ACTS.\n}\n{\nby rewrite TS.\n}\n{\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\n{\nsubst.\nrewrite updo; [|intros HH; clear -HH; inv HH; lia].\nrewrite !upds.\nunfold same_label_u2v.\nrewrite updo; [|intros HH; clear -HH; inv HH; lia].\nrewrite upds; auto.\n}\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\n{\nsubst.\nrewrite !upds.\nunfold same_label_u2v; auto.\n}\nins.\nrewrite !updo; auto.\n}\n{\nrewrite EINDEX.\nunfold val.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\n{\nsubst.\ndestruct (excluded_middle_informative (MOD (ThreadEvent tid (eindex s1')))) as [MN|NMN].\n{\nexfalso.\neapply NDATA.\napply seq_eqv_lr.\nsplits; eauto.\nbasic_solver 10.\n}\nassert (SAME_VAL : RegFile.eval_expr (regf s1 ) expr_add =                           RegFile.eval_expr (regf s1') expr_add).\n{\nins; eapply regf_expr_helper; eauto.\nins; intro; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\n}\nrewrite !upds.\nby rewrite SAME_VAL.\n}\nrewrite updo; auto.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\n{\nsubst.\nrewrite !upds.\ndestruct (excluded_middle_informative (MOD (ThreadEvent tid (eindex s1')))) as [MN|NMN].\n{\nexfalso.\neauto.\n}\nrewrite updo; [|intros HH; clear -HH; inv HH; lia].\nby rewrite upds.\n}\nrewrite !updo; auto.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\n}\n{\nby rewrite RMW, EINDEX.\n}\n{\nby rewrite DATA, EINDEX, DEPF.\n}\n{\nby rewrite ADDR, EINDEX, DEPF.\n}\n{\nby rewrite CTRL, EINDEX, ECTRL.\n}\nby rewrite FRMW, EINDEX.\n}\n{\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\n}\n{\neby ins; rewrite <- DEPF, <- EINDEX.\n}\n{\nins; unfold acts_set, is_r, is_w in INr, INw, READ, WRITE; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\n{\nby rewrite upds in READ; desf.\n}\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nrewrite updo in WRITE; [| intro; desf; lia].\n{\nby rewrite upds in WRITE; desf.\n}\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1' + 1))); subst.\n{\nexfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct INr as [[INr|INr]|INr]; subst.\n1,2: clear -RF; lia.\ndestruct r; [eauto|]; desc.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ninv EE.\nclear -RF0 LT.\nlia.\n}\nassert (is_w (lab (G s1')) w) as WW'.\n{\nrewrite !updo in WRITE; edone.\n}\nunfold val.\nrewrite updo; auto.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\n{\nrewrite !upds.\ndestruct (excluded_middle_informative (MOD (ThreadEvent tid (eindex s1')))) as [MN|NMN].\n2: eby exfalso.\nrewrite !updo; auto.\ndestruct (excluded_middle_informative                  (codom_rel new_rfi (ThreadEvent tid (eindex s1')))) as [|XX].\n2: {\nexfalso.\napply XX.\ngeneralize RF.\nclear.\nbasic_solver.\n}\nassert (w = new_w (ThreadEvent tid (eindex s1'))); subst.\n{\nedestruct new_rfi_unique with            (r:=ThreadEvent tid (eindex s1')) as [wu [_ HH]]; eauto.\ntransitivity wu.\n2: by apply HH.\nsymmetry.\napply HH.\ndo 2 red.\ngeneralize RF.\nclear.\nbasic_solver.\n}\nunfold get_val.\nclear -WW'.\nunfold is_w in WW'.\ndesf.\n}\nrewrite !updo; auto.\neapply NEW_VAL1; try edone.\n{\nunfolder in INr; desf.\n}\n{\nunfolder in INw; desf.\n}\nby rewrite !updo in READ; try edone.\n}\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\n{\nby unfold is_r in READ; rewrite upds in READ; desf.\n}\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\n{\nrewrite upds.\ndesf.\n}\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\nunfold is_r in *; rewrite !updo in READ; try done.\nunfolder in IN; desf.\n"},{"statement":"Lemma receptiveness_sim_exchange\n      (tid : thread_id)\n      s1 s2 (INSTRS0 : instrs s1 = instrs s2)\n      (new_expr : Instr.expr)\n      rexmod xmod\n      (ordr ordw : mode)\n      (reg : Reg.t)\n      (lexpr : Instr.lexpr)\n      (ISTEP : Some (Instr.update\n                       (Instr.exchange new_expr)\n                       rexmod xmod ordr ordw reg lexpr) = nth_error (instrs s1) (pc s1))\n      (val_ : nat)\n      (UPC : pc s2 = pc s1 + 1)\n      (UG : G s2 = add_rmw (G s1) tid (eindex s1)\n                           (Aload rexmod ordr (RegFile.eval_lexpr (regf s1) lexpr)\n                                  val_)\n                           (Astore xmod ordw (RegFile.eval_lexpr (regf s1) lexpr)\n                                   (RegFile.eval_expr (regf s1) new_expr))\n                           (DepsFile.expr_deps (depf s1) new_expr)\n                           (DepsFile.lexpr_deps (depf s1) lexpr)\n                           (ectrl s1) ∅)\n      (UINDEX : eindex s2 = eindex s1 + 2)\n      (UREGS : regf s2 = RegFun.add reg val_ (regf s1))\n      (UDEPS : depf s2 = RegFun.add reg (eq (ThreadEvent tid (eindex s1)))\n                                    (depf s1))\n      (UECTRL : ectrl s2 = ectrl s1)\n      MOD (new_rfi : relation actid) new_val\n      (NFRMW: MOD ∩₁ dom_rel ((rmw_dep (G s2))) ⊆₁ ∅)\n      (NADDR : MOD ∩₁ dom_rel ((addr (G s2))) ⊆₁ ∅)\n      (NREX:  MOD ∩₁ (acts_set (G s2)) ∩₁ (R_ex (lab (G s2))) ⊆₁ ∅) \n      (NDATA: ⦗MOD⦘ ⨾ (data (G s2)) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂)\n      (TWF : thread_wf tid s1)\n      (RFI_INDEX : new_rfi ⊆ ext_sb)\n      (new_rfif : functional new_rfi⁻¹)\n      s1' (SIM: sim_state s1 s1' MOD new_rfi new_val) :\n  exists s2', (step tid) s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","proof":"generalize (@new_write new_rfi new_rfif); intro F; destruct F as [new_w F].\nred in SIM; desc.\nassert (SAME_LOC : RegFile.eval_lexpr (regf s1) lexpr =                     RegFile.eval_lexpr (regf s1') lexpr).\n{\nins; eapply regf_lexpr_helper; eauto.\nins; intro; eapply NADDR; unfolder; splits; eauto.\nexists (ThreadEvent tid (eindex s1)).\nrewrite UG; unfold add_rmw; basic_solver.\n}\ncut (exists instrs pc G_ eindex regf depf ectrl,           step tid s1' (Build_state instrs pc G_ eindex regf depf ectrl) /\\           (sim_state s2 (Build_state instrs pc G_ eindex regf depf ectrl)                     MOD new_rfi new_val)).\n{\nins; desc; eauto.\n}\ndo 7 eexists; splits; red; splits.\n{\neexists; red; splits; [by ins; eauto|].\neexists; splits; [eby rewrite <- INSTRS, <- PC |].\neapply exchange with (val :=      if excluded_middle_informative (MOD (ThreadEvent tid (eindex s1')))      then if excluded_middle_informative ((codom_rel new_rfi) (ThreadEvent tid (eindex s1')))           then (get_val (val (lab (G s1')) (new_w (ThreadEvent tid (eindex s1')))))           else (new_val (ThreadEvent tid (eindex s1')))      else val_);    reflexivity.\n}\n1,2,4,7: ins; congruence.\n{\nins.\ndestruct (G s2) as [acts2 lab2 rmw2 data2 addr2 ctrl2 rf2 co2].\ninversion UG; subst; clear UG.\nred in EXEC; desc.\nred; splits; ins.\n{\nby rewrite EINDEX, ACTS.\n}\n{\nby rewrite TS.\n}\n{\nrewrite EINDEX.\nunfold same_lab_u2v in *; intro e.\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1'))).\n{\nsubst.\nrewrite updo; [|intros HH; clear -HH; inv HH; lia].\nrewrite !upds.\nunfold same_label_u2v.\nrewrite updo; [|intros HH; clear -HH; inv HH; lia].\nrewrite upds; auto.\n}\ndestruct (eq_dec_actid e (ThreadEvent tid (eindex s1' + 1))).\n{\nsubst.\nrewrite !upds.\nunfold same_label_u2v; auto.\n}\nins.\nrewrite !updo; auto.\n}\n{\nrewrite EINDEX.\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1' + 1))).\n{\nsubst; rewrite SAME_LOC.\nunfold val; rewrite !upds.\nerewrite regf_expr_helper; try edone.\nintro reg0; specialize (REGF reg0); desf; eauto.\nins; intro DEPS; eapply NDATA; unfolder; splits; eauto.\nby rewrite EINDEX.\n}\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid a (ThreadEvent tid (eindex s1'))).\n{\nsubst; rewrite SAME_LOC.\nrewrite !upds.\nrewrite updo; [|intro; desf; lia].\nrewrite !upds.\ndesf.\n}\nrewrite !updo; try done.\nby apply OLD_VAL in NIN; unfold val in NIN; rewrite NIN.\n}\n{\nby rewrite RMW, EINDEX.\n}\n{\nby rewrite DATA, EINDEX, DEPF.\n}\n{\nby rewrite ADDR, EINDEX, DEPF.\n}\n{\nby rewrite CTRL, EINDEX, ECTRL.\n}\nby rewrite FRMW, EINDEX.\n}\n{\nins; rewrite UREGS, UDEPS.\nunfold RegFun.add, RegFun.find in *; desf; eauto.\n}\n{\neby ins; rewrite <- DEPF, <- EINDEX.\n}\n{\nins; unfold acts_set, is_r, is_w in INr, INw, READ, WRITE; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\n{\nby rewrite upds in READ; desf.\n}\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1'))); subst.\nrewrite updo in WRITE; [| intro; desf; lia].\n{\nby rewrite upds in WRITE; desf.\n}\ndestruct (eq_dec_actid w (ThreadEvent tid (eindex s1' + 1))); subst.\n{\nexfalso.\napply RFI_INDEX in RF; unfold ext_sb in RF.\ndestruct INr as [[INr|INr]|INr]; subst.\n1,2: clear -RF; lia.\ndestruct r; [eauto|]; desc.\napply sim_execution_same_acts in EXEC.\napply EXEC in INr.\napply TWF in INr; desc.\nrewrite <- EINDEX in RF0.\ninv EE.\nclear -RF0 LT.\nlia.\n}\nassert (is_w (lab (G s1')) w) as WW'.\n{\nrewrite !updo in WRITE; edone.\n}\nunfold val.\nrewrite updo; auto.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\n{\nrewrite !upds.\ndestruct (excluded_middle_informative (MOD (ThreadEvent tid (eindex s1')))) as [MN|NMN].\n2: eby exfalso.\nrewrite !updo; auto.\ndestruct (excluded_middle_informative                  (codom_rel new_rfi (ThreadEvent tid (eindex s1')))) as [|XX].\n2: {\nexfalso.\napply XX.\ngeneralize RF.\nclear.\nbasic_solver.\n}\nassert (w = new_w (ThreadEvent tid (eindex s1'))); subst.\n{\nedestruct new_rfi_unique with            (r:=ThreadEvent tid (eindex s1')) as [wu [_ HH]]; eauto.\ntransitivity wu.\n2: by apply HH.\nsymmetry.\napply HH.\ndo 2 red.\ngeneralize RF.\nclear.\nbasic_solver.\n}\nunfold get_val.\nclear -WW'.\nunfold is_w in WW'.\ndesf.\n}\nrewrite !updo; auto.\neapply NEW_VAL1; try edone.\n{\nunfolder in INr; desf.\n}\n{\nunfolder in INw; desf.\n}\nby rewrite !updo in READ; try edone.\n}\nsimpl; ins.\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'+1))); subst.\n{\nby unfold is_r in READ; rewrite upds in READ; desf.\n}\nunfold val; rewrite updo; [|done].\ndestruct (eq_dec_actid r (ThreadEvent tid (eindex s1'))); subst.\n{\nrewrite upds.\ndesf.\n}\nunfold val; rewrite updo; try done.\napply NEW_VAL2; try done.\n{\nunfold is_r in *; rewrite !updo in READ; done.\n}\nunfolder in IN; desf.\n"},{"statement":"Lemma receptiveness_sim_step (tid : thread_id)\n  s1 s2\n  (STEP : (step tid) s1 s2) \n  (CASREX : cas_produces_R_ex_instrs (instrs s1))\n  MOD (new_rfi : relation actid) new_val\n  (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅)\n  (NFRMW: MOD ∩₁ dom_rel ((rmw_dep (G s2))) ⊆₁ ∅)\n  (NADDR : MOD ∩₁ dom_rel ((addr (G s2))) ⊆₁ ∅)\n  (NREX:  MOD ∩₁ (acts_set (G s2)) ∩₁ (R_ex (lab (G s2))) ⊆₁ ∅) \n  (NDATA: ⦗MOD⦘ ⨾ (data (G s2)) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂)\n  (new_rfif : functional new_rfi⁻¹)\n   (RFI_INDEX : new_rfi ⊆ ext_sb)\n  (TWF : thread_wf tid s1)\n  s1' (SIM: sim_state s1 s1' MOD new_rfi new_val) :\n exists s2', (step tid) s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","proof":"destruct STEP; red in H; desf.\ndestruct ISTEP0; desf.\n- eby eapply receptiveness_sim_assign.\n- eby eapply receptiveness_sim_if_else.\n- eby eapply receptiveness_sim_if_then.\n- eby eapply receptiveness_sim_load.\n- eby eapply receptiveness_sim_store.\n- eby eapply receptiveness_sim_fence.\n- eby eapply receptiveness_sim_cas_fail.\n- eby eapply receptiveness_sim_cas_suc.\n- eby eapply receptiveness_sim_inc.\n- eby eapply receptiveness_sim_exchange.\n"},{"statement":"Lemma receptiveness_sim (tid : thread_id)\n  s1 s2\n  (STEPS : (step tid)＊ s1 s2)\n  (CASREX : cas_produces_R_ex_instrs (instrs s1))\n  MOD (new_rfi : relation actid) new_val\n  (NCTRL : MOD ∩₁ ectrl s2 ⊆₁ ∅)\n  (NFRMW: MOD ∩₁ dom_rel ((rmw_dep (G s2))) ⊆₁ ∅)\n  (NADDR : MOD ∩₁ dom_rel ((addr (G s2))) ⊆₁ ∅)\n  (NREX:  MOD ∩₁ (acts_set (G s2)) ∩₁ (R_ex (lab (G s2))) ⊆₁ ∅) \n  (NDATA: ⦗MOD⦘ ⨾ (data (G s2)) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂)\n  (new_rfif : functional new_rfi⁻¹)\n   (RFI_INDEX : new_rfi ⊆ ext_sb)\n  (TWF : thread_wf tid s1)\n  s1' (SIM: sim_state s1 s1' MOD new_rfi new_val) :\n exists s2', (step tid)＊ s1' s2' /\\ sim_state s2 s2' MOD new_rfi new_val.","proof":"apply clos_rt_rtn1 in STEPS.\ninduction STEPS.\n{\nby eexists; vauto.\n}\nexploit IHSTEPS.\n{\nunfolder; splits; ins; eauto; desf.\neapply ectrl_increasing in H1; eauto.\neapply NCTRL; basic_solver.\n}\n{\nunfolder; splits; ins; eauto; desf.\neapply rmw_dep_increasing in H1; eauto.\neapply NFRMW; basic_solver.\n}\n{\nunfolder; splits; ins; eauto; desf.\neapply addr_increasing in H1; eauto.\neapply NADDR; basic_solver.\n}\n{\nunfolder; splits; ins; eauto; desf.\neapply NREX; split; [split; [eauto |] |].\neapply acts_increasing; edone.\neapply is_r_ex_increasing; eauto.\neapply thread_wf_steps; try edone.\n{\nby apply clos_rtn1_rt.\n}\nbasic_solver.\n}\n{\nunfolder; splits; ins; eauto; desf.\neapply data_increasing in H1; eauto.\neapply NDATA; basic_solver.\n}\nintro; desc.\neapply receptiveness_sim_step in x0; eauto; desf.\n{\nexists s2'0; splits; eauto.\nby eapply rt_trans; [eauto | econs].\n}\n{\narewrite (instrs y = instrs s1); auto.\napply clos_rtn1_rt in STEPS.\neapply steps_preserve_instrs; eauto.\n}\neapply thread_wf_steps; try edone.\nby apply clos_rtn1_rt.\n"},{"statement":"Lemma receptiveness_helper (tid : thread_id)\n      s_init s\n      (CASREX : cas_produces_R_ex_instrs (instrs s_init))\n      (GPC : wf_thread_state tid s_init)\n      (new_val : actid -> value)\n      (new_rfi : relation actid)\n      (MOD: actid -> Prop)\n      (STEPS : (step tid)＊ s_init s)\n      (new_rfiE : new_rfi ≡ ⦗(acts_set (G s))⦘ ⨾ new_rfi ⨾ ⦗(acts_set (G s))⦘)\n      (new_rfiD : new_rfi ≡ ⦗is_w (lab (G s))⦘ ⨾ new_rfi ⨾ ⦗is_r (lab (G s))⦘)\n      (new_rfif : functional new_rfi⁻¹)\n      (RFI_INDEX : new_rfi ⊆ ext_sb)\n      (NCTRL : MOD ∩₁ ectrl s ⊆₁ ∅) \n      (NFRMW: MOD ∩₁ dom_rel ((rmw_dep (G s))) ⊆₁ ∅)\n      (NADDR : MOD ∩₁ dom_rel ((addr (G s))) ⊆₁ ∅)\n      (NREX:  MOD ∩₁ (acts_set (G s)) ∩₁ (R_ex (lab (G s))) ⊆₁ ∅) \n      (NDATA: ⦗MOD⦘ ⨾ (data (G s)) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) \n      (new_rfiMOD : codom_rel new_rfi ⊆₁ MOD)\n      (NMODINIT: MOD ∩₁ (acts_set (ProgToExecution.G s_init)) ⊆₁ ∅)\n      (EMOD : MOD ⊆₁ (acts_set (ProgToExecution.G s))) :\n    exists s',\n      ⟪ STEPS' : (step tid)＊ s_init s' ⟫ /\\\n      ⟪ EXEC : sim_execution (G s) (G s') MOD ⟫ /\\\n      ⟪ NEW_VAL1 : forall r w (RF: new_rfi w r), val ((lab (G s'))) r = val ((lab (G s'))) w ⟫ /\\\n      ⟪ NEW_VAL2 : forall r (RR : is_r (lab (G s')) r) (IN: MOD r) (NIN: ~ (codom_rel new_rfi) r),\n          val ((lab (G s'))) r = Some (new_val r) ⟫ /\\\n      ⟪ OLD_VAL : forall a (NIN: ~ MOD a), val ((lab (G s'))) a = val ((lab (G s))) a ⟫.","proof":"apply receptiveness_sim with (s1':= s_init) (MOD:=MOD) (new_rfi:=new_rfi) (new_val:=new_val) in STEPS.\nall: try done.\n- desc.\nred in STEPS0; desc.\nexists s2'; splits; eauto.\n* ins; eapply NEW_VAL1; try done.\n+ hahn_rewrite new_rfiE in RF; unfolder in RF; desf.\napply sim_execution_same_acts in EXEC.\nrevert EXEC; basic_solver.\n+ hahn_rewrite new_rfiE in RF; unfolder in RF; desf.\napply sim_execution_same_acts in EXEC.\nrevert EXEC; basic_solver.\n+ hahn_rewrite new_rfiD in RF; unfolder in RF; desf.\napply sim_execution_same_r in EXEC.\nrevert EXEC; basic_solver.\n+ hahn_rewrite new_rfiD in RF; unfolder in RF; desf.\napply sim_execution_same_w in EXEC.\nrevert EXEC; basic_solver.\n+ revert new_rfiMOD; basic_solver.\n* ins; eapply NEW_VAL2; try done.\napply sim_execution_same_acts in EXEC.\nrevert EXEC; basic_solver.\n* ins; red in EXEC; desc.\nby eapply OLD_VAL.\n- red; apply (acts_rep GPC).\n- red; splits; eauto.\n{\nred; splits; eauto; red; red; ins; red; eauto; desf.\n}\nins; exfalso; revert NMODINIT; basic_solver.\nins; exfalso; unfolder in *; basic_solver.\n"},{"statement":"Lemma receptiveness_ectrl_helper (tid : thread_id) \n      s_init s \n      (GPC : wf_thread_state tid s_init)\n      (STEPS : (step tid)＊ s_init s)\n      MOD (NCTRL: MOD ∩₁ dom_rel ((ctrl (G s))) ⊆₁ ∅) \n      (NMODINIT: MOD ∩₁ (acts_set (G s_init)) ⊆₁ ∅):\n      exists s', (step tid)＊ s_init s' /\\\n                 (MOD ∩₁ ectrl s' ⊆₁ ∅) /\\ (G s') = (G s).","proof":"apply clos_rt_rtn1 in STEPS.\ninduction STEPS.\n- exists s_init; splits; vauto.\nby rewrite (wft_ectrlE GPC).\n- assert (A: MOD ∩₁ dom_rel (ctrl (G y)) ⊆₁ ∅).\ngeneralize (ctrl_increasing H).\nrevert NCTRL; basic_solver 12.\napply IHSTEPS in A.\ndesc.\ndestruct  (classic (MOD ∩₁ ectrl z ⊆₁ ∅)).\n* exists z; splits; eauto.\neapply rt_trans.\neby apply clos_rtn1_rt.\nby apply rt_step.\n* exists s'; splits; eauto.\ntransitivity (G y); [done|].\neapply ectrl_ctrl_step; try edone.\ndestruct (classic (exists a : actid, (MOD ∩₁ ectrl z) a)); auto.\nexfalso; apply H0; unfolder; ins; eapply H1; basic_solver.\n"},{"statement":"Lemma receptiveness_full (tid : thread_id)\n      s_init s\n      (new_val : actid -> value)\n      (new_rfi : relation actid)\n      (MOD: actid -> Prop)\n      (GPC : wf_thread_state tid s_init)\n      (CASREX : cas_produces_R_ex_instrs (instrs s_init))\n      (STEPS : (step tid)＊ s_init s)\n      (new_rfiE : new_rfi ≡ ⦗(acts_set (G s))⦘ ⨾ new_rfi ⨾ ⦗(acts_set (G s))⦘)\n      (new_rfiD : new_rfi ≡ ⦗is_w (lab (G s))⦘ ⨾ new_rfi ⨾ ⦗is_r (lab (G s))⦘)\n      (new_rfif : functional new_rfi⁻¹)\n      (RFI_INDEX : new_rfi ⊆ ext_sb)\n      (new_rfiMOD : codom_rel new_rfi ⊆₁ MOD)\n      (EMOD : MOD ⊆₁ (acts_set (ProgToExecution.G s)))\n      (NMODINIT: MOD ∩₁ (acts_set (ProgToExecution.G s_init)) ⊆₁ ∅)\n      (NFRMW: MOD ∩₁ dom_rel ((rmw_dep (G s))) ⊆₁ ∅)\n      (NADDR : MOD ∩₁ dom_rel ((addr (G s))) ⊆₁ ∅)\n      (NREX:  MOD ∩₁ (acts_set (G s)) ∩₁(R_ex (lab (G s))) ⊆₁ ∅) \n      (NCTRL: MOD ∩₁ dom_rel ((ctrl (G s))) ⊆₁ ∅)\n      (NDATA: ⦗MOD⦘ ⨾ (data (G s)) ⨾ ⦗set_compl MOD⦘ ⊆ ∅₂) :\n    exists s',\n      ⟪ STEPS' : (step tid)＊ s_init s' ⟫ /\\\n      ⟪ RACTS : (acts_set (G s)) = (acts_set (G s')) ⟫ /\\\n      ⟪ RTS: threads_set (G s) ≡₁ threads_set (G s')⟫ /\\\n      ⟪ RRMW  : (rmw (G s))  ≡ (rmw (G s'))  ⟫ /\\\n      ⟪ RDATA : (data (G s)) ≡ (data (G s')) ⟫ /\\\n      ⟪ RADDR : (addr (G s)) ≡ (addr (G s')) ⟫ /\\\n      ⟪ RCTRL : (ctrl (G s)) ≡ (ctrl (G s')) ⟫  /\\\n      ⟪ RFAILRMW : (rmw_dep (G s)) ≡ (rmw_dep (G s')) ⟫  /\\\n      ⟪ SAME : same_lab_u2v ((lab (G s'))) ((lab (G s)))⟫ /\\\n      ⟪ NEW_VAL1 : forall r w (RF: new_rfi w r), val ((lab (G s'))) r = val ((lab (G s'))) w ⟫ /\\\n      ⟪ NEW_VAL2 : forall r (RR : is_r (lab (G s')) r) (IN: MOD r) (NIN: ~ (codom_rel new_rfi) r),\n          val ((lab (G s'))) r = Some (new_val r) ⟫ /\\\n      ⟪ OLD_VAL : forall a (NIN: ~ MOD a), val ((lab (G s'))) a = val ((lab (G s))) a ⟫.","proof":"forward (apply receptiveness_ectrl_helper); try edone.\nins; desc.\nrewrite <- H1 in *.\nclear STEPS H1 s.\nforward (eapply receptiveness_helper with (new_rfi:=new_rfi)); ins; eauto.\ndesc.\nred in EXEC; desc.\neexists; splits; eauto.\n"}]