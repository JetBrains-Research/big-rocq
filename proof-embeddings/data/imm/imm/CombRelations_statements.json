{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/imm/CombRelations.v","fileSamples":[{"statement":"(l : location) : urr l ⊆ ⦗W_ l⦘ ⨾ urr l.","proofString":"unfold urr; rels."},{"statement":"(i : BinNums.positive) (l l' : location) (codom : actid -> Prop) : c_rel i l l' codom\n⊆ ⦗W_ l⦘\n  ⨾ c_rel i l l' codom ⨾ ⦗Rel ∩₁ (W_ l' ∪₁ F) ∩₁ (Tid_ i ∪₁ Init) ∩₁ codom⦘.","proofString":"unfold c_rel.\nrewrite wf_urrD.\nbasic_solver 21."},{"statement":"(i : BinNums.positive) (l l' : location) (codom : actid -> Prop) : urr l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘\n  ⨾ (urr l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘)\n    ⨾ ⦗Rel ∩₁ (W_ l' ∪₁ F) ∩₁ (Tid_ i ∪₁ Init) ∩₁ codom⦘.","proofString":"rewrite wf_urrD.\nbasic_solver 21."},{"statement":"(i : BinNums.positive) (l l' : location) (codom : actid -> Prop) : (⦗W_ l⦘ ⨾ urr l) ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘\n  ⨾ ((⦗W_ l⦘ ⨾ urr l) ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘)\n    ⨾ ⦗Rel ∩₁ (W_ l' ∪₁ F) ∩₁ (Tid_ i ∪₁ Init) ∩₁ codom⦘.","proofString":"basic_solver 21."},{"statement":"(i : BinNums.positive) (l : location) (codom : actid -> Prop) : c_cur i l codom ⊆ ⦗W_ l⦘ ⨾ c_cur i l codom ⨾ ⦗(Tid_ i ∪₁ Init) ∩₁ codom⦘.","proofString":"unfold c_cur.\nrewrite wf_urrD.\nbasic_solver 21."},{"statement":"(i : BinNums.positive) (l : location) (codom : actid -> Prop) : urr l ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘ ⨾ (urr l ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘) ⨾ ⦗(Tid_ i ∪₁ Init) ∩₁ codom⦘.","proofString":"rewrite wf_urrD.\nbasic_solver 21."},{"statement":"(i : BinNums.positive) (l : location) (codom : actid -> Prop) : (⦗W_ l⦘ ⨾ urr l) ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘\n  ⨾ ((⦗W_ l⦘ ⨾ urr l) ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘)\n    ⨾ ⦗(Tid_ i ∪₁ Init) ∩₁ codom⦘.","proofString":"basic_solver 21."},{"statement":"(i : BinNums.positive) (l : location) (codom : actid -> Prop) : c_acq i l codom ⊆ ⦗W_ l⦘ ⨾ c_acq i l codom ⨾ ⦗(Tid_ i ∪₁ Init) ∩₁ codom⦘.","proofString":"unfold c_acq.\nrewrite wf_urrD.\nbasic_solver 21."},{"statement":"(i : BinNums.positive) (l : location) (codom : actid -> Prop) : urr l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘\n  ⨾ (urr l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘)\n    ⨾ ⦗(Tid_ i ∪₁ Init) ∩₁ codom⦘.","proofString":"rewrite wf_urrD.\nbasic_solver 21."},{"statement":"(i : BinNums.positive) (l : location) (codom : actid -> Prop) : (⦗W_ l⦘ ⨾ urr l) ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘\n  ⨾ ((⦗W_ l⦘ ⨾ urr l) ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘)\n    ⨾ ⦗(Tid_ i ∪₁ Init) ∩₁ codom⦘.","proofString":"basic_solver 21."},{"statement":"(l : location) (codom : actid -> Prop) : S_tmr l codom ⊆ ⦗W_ l⦘ ⨾ S_tmr l codom ⨾ ⦗F ∩₁ Sc ∩₁ codom⦘.","proofString":"unfold S_tmr.\nbasic_solver 21."},{"statement":"(l : location) (codom : actid -> Prop) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘ ⨾ (⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘) ⨾ ⦗F ∩₁ Sc ∩₁ codom⦘.","proofString":"basic_solver 21."},{"statement":"(i : BinNums.positive) (l l' : location) (codom : actid -> Prop) : dom_rel (c_rel i l l' codom) ⊆₁ W_ l.","proofString":"rewrite (wf_c_relD i l l' codom).\nbasic_solver 21."},{"statement":"(i : BinNums.positive) (l l' : location) (codom : actid -> Prop) : dom_rel\n  (⦗W_ l⦘\n   ⨾ c_rel i l l' codom ⨾ ⦗Rel ∩₁ (W_ l' ∪₁ F) ∩₁ (Tid_ i ∪₁ Init) ∩₁ codom⦘)\n⊆₁ W_ l.","proofString":"basic_solver 21."},{"statement":"(i : BinNums.positive) (l : location) (codom : actid -> Prop) : dom_rel (c_cur i l codom) ⊆₁ W_ l.","proofString":"rewrite (wf_c_curD i l codom).\nbasic_solver 21."},{"statement":"(i : BinNums.positive) (l : location) (codom : actid -> Prop) : dom_rel (⦗W_ l⦘ ⨾ c_cur i l codom ⨾ ⦗(Tid_ i ∪₁ Init) ∩₁ codom⦘) ⊆₁ W_ l.","proofString":"basic_solver 21."},{"statement":"(i : BinNums.positive) (l : location) (codom : actid -> Prop) : dom_rel (c_acq i l codom) ⊆₁ W_ l.","proofString":"rewrite (wf_c_acqD i l codom).\nbasic_solver 21."},{"statement":"(i : BinNums.positive) (l : location) (codom : actid -> Prop) : dom_rel (⦗W_ l⦘ ⨾ c_acq i l codom ⨾ ⦗(Tid_ i ∪₁ Init) ∩₁ codom⦘) ⊆₁ W_ l.","proofString":"basic_solver 21."},{"statement":"(l' l : location) (a : actid) (i : BinNums.positive) (C : actid -> Prop) (T : W_ l a) : W_ l a.","proofString":"revert T; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) : (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) ⨾ ⦗Init⦘ ⊆ ⦗Init⦘.","proofString":"rewrite (no_hb_to_init WF), (no_sc_to_init WF WF_SC), (no_rf_to_init WF).\nunfolder; ins; desf; eauto."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) : (⦗W_ l⦘\n ⨾ (rf ⨾ ⦗fun x : actid => ~ is_init x⦘)^?\n   ⨾ ((hb ⨾ ⦗fun x : actid => ~ is_init x⦘) ⨾ ⦗F ∩₁ Sc⦘)^?\n     ⨾ (sc ⨾ ⦗fun x : actid => ~ is_init x⦘)^?\n       ⨾ (hb ⨾ ⦗fun x : actid => ~ is_init x⦘)^?) ⨾ ⦗Init⦘ ⊆ ⦗Init⦘.","proofString":"unfolder; ins; desf; eauto."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ ⦗F ∩₁ Sc⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^?.","proofString":"do 2 hahn_frame_l.\nrewrite (crE sc) at 1; relsf; unionL.\nby generalize (@hb_trans G); basic_solver 21.\nrewrite (crE hb); relsf; unionL; [basic_solver 12|].\nrewrite (dom_r (wf_scD WF_SC)), !seqA.\nrewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ngeneralize (sc_trans WF_SC).\nrewrite (dom_r (wf_scD WF_SC)) at 3.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (l : location) : (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ ⦗F ∩₁ Sc⦘ ⊆ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^?.","proofString":"rewrite (crE sc) at 1; relsf; unionL.\nby generalize (@hb_trans G); basic_solver 21.\nrewrite (crE hb); relsf; unionL; [basic_solver 12|].\nrewrite (dom_r (wf_scD WF_SC)), !seqA.\nrewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ngeneralize (sc_trans WF_SC).\nrewrite (dom_r (wf_scD WF_SC)) at 3.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (l : location) : (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^? ⨾ ⦗F ∩₁ Sc⦘ ⊆ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^?.","proofString":"by generalize (@hb_trans G); basic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (l : location) : (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⨾ hb^? ⨾ ⦗F ∩₁ Sc⦘ ⊆ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^?.","proofString":"rewrite (crE hb); relsf; unionL; [basic_solver 12|].\nrewrite (dom_r (wf_scD WF_SC)), !seqA.\nrewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ngeneralize (sc_trans WF_SC).\nrewrite (dom_r (wf_scD WF_SC)) at 3.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (l : location) : (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⊆ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^?.","proofString":"rewrite (dom_r (wf_scD WF_SC)), !seqA.\nrewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ngeneralize (sc_trans WF_SC).\nrewrite (dom_r (wf_scD WF_SC)) at 3.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (l : location) : (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⨾ ⦗F ∩₁ Sc⦘ ⨾ hb ⨾ ⦗F ∩₁ Sc⦘\n⊆ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^?.","proofString":"rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ngeneralize (sc_trans WF_SC).\nrewrite (dom_r (wf_scD WF_SC)) at 3.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (l : location) : (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⨾ sc ⊆ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^?.","proofString":"generalize (sc_trans WF_SC).\nrewrite (dom_r (wf_scD WF_SC)) at 3.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (l : location) : transitive sc ->\n(hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⨾ sc ⊆ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^?.","proofString":"rewrite (dom_r (wf_scD WF_SC)) at 3.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (l : location) : transitive sc ->\n(hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⨾ sc ⨾ ⦗F ∩₁ Sc⦘\n⊆ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^?.","proofString":"basic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ ⦗F ∩₁ set_compl Sc⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb.","proofString":"case_refl hb.\nrewrite (dom_r (wf_scD WF_SC)).\nrewrite (dom_r (wf_rfD WF)).\ntype_solver 16.\ndo 4 (hahn_frame_l).\nunfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver 16.\nunfold imm_s_hb.sw at 2.\nrewrite !seqA.\nhahn_frame_l.\nrewrite (dom_r (wf_rfD WF)) at 1.\ntype_solver 36."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ ⦗F ∩₁ set_compl Sc⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb.","proofString":"rewrite (dom_r (wf_scD WF_SC)).\nrewrite (dom_r (wf_rfD WF)).\ntype_solver 16."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ ⦗F ∩₁ set_compl Sc⦘\n⊆ ⦗W_ l⦘\n  ⨾ rf^?\n    ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb.","proofString":"rewrite (dom_r (wf_rfD WF)).\ntype_solver 16."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘\n⨾ (rf ⨾ ⦗R⦘)^?\n  ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ ⦗F ∩₁ set_compl Sc⦘\n⊆ ⦗W_ l⦘\n  ⨾ (rf ⨾ ⦗R⦘)^?\n    ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^?\n      ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^? ⨾ (release ⨾ rf ⨾ ⦗R⦘)^? ⨾ sb.","proofString":"type_solver 16."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb ⨾ ⦗F ∩₁ set_compl Sc⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb.","proofString":"do 4 (hahn_frame_l).\nunfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver 16.\nunfold imm_s_hb.sw at 2.\nrewrite !seqA.\nhahn_frame_l.\nrewrite (dom_r (wf_rfD WF)) at 1.\ntype_solver 36."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : hb ⨾ ⦗F ∩₁ set_compl Sc⦘ ⊆ hb^? ⨾ (release ⨾ rf)^? ⨾ sb.","proofString":"unfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver 16.\nunfold imm_s_hb.sw at 2.\nrewrite !seqA.\nhahn_frame_l.\nrewrite (dom_r (wf_rfD WF)) at 1.\ntype_solver 36."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : (sb ∪ sw)⁺ ⨾ ⦗F ∩₁ set_compl Sc⦘ ⊆ ((sb ∪ sw)⁺)^? ⨾ (release ⨾ rf)^? ⨾ sb.","proofString":"rewrite ct_end at 1; relsf; unionL.\nbasic_solver 16.\nunfold imm_s_hb.sw at 2.\nrewrite !seqA.\nhahn_frame_l.\nrewrite (dom_r (wf_rfD WF)) at 1.\ntype_solver 36."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ((sb ∪ sw)＊ ⨾ sb) ⨾ ⦗F ∩₁ set_compl Sc⦘ ⊆ (sb ∪ sw)＊ ⨾ (release ⨾ rf)^? ⨾ sb.","proofString":"basic_solver 16."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ((sb ∪ sw)＊ ⨾ sw) ⨾ ⦗F ∩₁ set_compl Sc⦘ ⊆ (sb ∪ sw)＊ ⨾ (release ⨾ rf)^? ⨾ sb.","proofString":"unfold imm_s_hb.sw at 2.\nrewrite !seqA.\nhahn_frame_l.\nrewrite (dom_r (wf_rfD WF)) at 1.\ntype_solver 36."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ((sb ∪ sw)＊ ⨾ release ⨾ rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘) ⨾ ⦗F ∩₁ set_compl Sc⦘\n⊆ (sb ∪ sw)＊ ⨾ (release ⨾ rf)^? ⨾ sb.","proofString":"rewrite !seqA.\nhahn_frame_l.\nrewrite (dom_r (wf_rfD WF)) at 1.\ntype_solver 36."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : (sb ∪ sw)＊ ⨾ release ⨾ rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ set_compl Sc⦘\n⊆ (sb ∪ sw)＊ ⨾ (release ⨾ rf)^? ⨾ sb.","proofString":"hahn_frame_l.\nrewrite (dom_r (wf_rfD WF)) at 1.\ntype_solver 36."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : release ⨾ rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ set_compl Sc⦘\n⊆ (release ⨾ rf)^? ⨾ sb.","proofString":"rewrite (dom_r (wf_rfD WF)) at 1.\ntype_solver 36."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : release ⨾ (rf ⨾ ⦗R⦘) ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ set_compl Sc⦘\n⊆ (release ⨾ rf)^? ⨾ sb.","proofString":"type_solver 36."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ ⦗F ∩₁ set_compl Acq⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb.","proofString":"case_refl hb.\nrewrite (dom_r (wf_scD WF_SC)).\nrewrite (dom_r (wf_rfD WF)).\nmode_solver 16.\ndo 4 (hahn_frame_l).\nunfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver 16.\nrewrite (dom_r (wf_swD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ ⦗F ∩₁ set_compl Acq⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb.","proofString":"rewrite (dom_r (wf_scD WF_SC)).\nrewrite (dom_r (wf_rfD WF)).\nmode_solver 16."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘\n⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ ⦗F ∩₁ set_compl Acq⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^? ⨾ sb.","proofString":"rewrite (dom_r (wf_rfD WF)).\nmode_solver 16."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘\n⨾ (rf ⨾ ⦗R⦘)^?\n  ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ ⦗F ∩₁ set_compl Acq⦘\n⊆ ⦗W_ l⦘ ⨾ (rf ⨾ ⦗R⦘)^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^? ⨾ sb.","proofString":"mode_solver 16."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb ⨾ ⦗F ∩₁ set_compl Acq⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb.","proofString":"do 4 (hahn_frame_l).\nunfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver 16.\nrewrite (dom_r (wf_swD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : hb ⨾ ⦗F ∩₁ set_compl Acq⦘ ⊆ hb^? ⨾ sb.","proofString":"unfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver 16.\nrewrite (dom_r (wf_swD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : (sb ∪ sw)⁺ ⨾ ⦗F ∩₁ set_compl Acq⦘ ⊆ ((sb ∪ sw)⁺)^? ⨾ sb.","proofString":"rewrite ct_end at 1; relsf; unionL.\nbasic_solver 16.\nrewrite (dom_r (wf_swD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ((sb ∪ sw)＊ ⨾ sb) ⨾ ⦗F ∩₁ set_compl Acq⦘ ⊆ (sb ∪ sw)＊ ⨾ sb.","proofString":"basic_solver 16."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ((sb ∪ sw)＊ ⨾ sw) ⨾ ⦗F ∩₁ set_compl Acq⦘ ⊆ (sb ∪ sw)＊ ⨾ sb.","proofString":"rewrite (dom_r (wf_swD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ((sb ∪ sw ⨾ ⦗FR ∩₁ Acq⦘)＊ ⨾ sw ⨾ ⦗FR ∩₁ Acq⦘) ⨾ ⦗F ∩₁ set_compl Acq⦘\n⊆ (sb ∪ sw ⨾ ⦗FR ∩₁ Acq⦘)＊ ⨾ sb.","proofString":"type_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ ⦗W⦘\n≡ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ l⦘.","proofString":"split.\ncase_refl hb.\nunionR right.\nrewrite (dom_r (wf_scD WF_SC)).\nrewrite (dom_r (wf_rfD WF)).\ntype_solver.\nunionR left.\ndo 4 (hahn_frame_l).\nunfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver.\nrewrite (dom_r (wf_swD WF)).\ntype_solver.\nrewrite sb_in_hb.\ngeneralize (@hb_trans G); ins; relsf.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ ⦗W⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ l⦘.","proofString":"case_refl hb.\nunionR right.\nrewrite (dom_r (wf_scD WF_SC)).\nrewrite (dom_r (wf_rfD WF)).\ntype_solver.\nunionR left.\ndo 4 (hahn_frame_l).\nunfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver.\nrewrite (dom_r (wf_swD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ ⦗W⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ l⦘.","proofString":"unionR right.\nrewrite (dom_r (wf_scD WF_SC)).\nrewrite (dom_r (wf_rfD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ ⦗W⦘ ⊆ ⦗W_ l⦘.","proofString":"rewrite (dom_r (wf_scD WF_SC)).\nrewrite (dom_r (wf_rfD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ ⦗W⦘ ⊆ ⦗W_ l⦘.","proofString":"rewrite (dom_r (wf_rfD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ (rf ⨾ ⦗R⦘)^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ (sc ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ ⦗W⦘\n⊆ ⦗W_ l⦘.","proofString":"type_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb ⨾ ⦗W⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ l⦘.","proofString":"unionR left.\ndo 4 (hahn_frame_l).\nunfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver.\nrewrite (dom_r (wf_swD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb ⨾ ⦗W⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb ⨾ ⦗W⦘.","proofString":"do 4 (hahn_frame_l).\nunfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver.\nrewrite (dom_r (wf_swD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : hb ⨾ ⦗W⦘ ⊆ hb^? ⨾ sb ⨾ ⦗W⦘.","proofString":"unfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf; unionL.\nbasic_solver.\nrewrite (dom_r (wf_swD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : (sb ∪ sw)⁺ ⨾ ⦗W⦘ ⊆ ((sb ∪ sw)⁺)^? ⨾ sb ⨾ ⦗W⦘.","proofString":"rewrite ct_end at 1; relsf; unionL.\nbasic_solver.\nrewrite (dom_r (wf_swD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ((sb ∪ sw)＊ ⨾ sb) ⨾ ⦗W⦘ ⊆ (sb ∪ sw)＊ ⨾ sb ⨾ ⦗W⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ((sb ∪ sw)＊ ⨾ sw) ⨾ ⦗W⦘ ⊆ (sb ∪ sw)＊ ⨾ sb ⨾ ⦗W⦘.","proofString":"rewrite (dom_r (wf_swD WF)).\ntype_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ((sb ∪ sw ⨾ ⦗FR ∩₁ Acq⦘)＊ ⨾ sw ⨾ ⦗FR ∩₁ Acq⦘) ⨾ ⦗W⦘\n⊆ (sb ∪ sw ⨾ ⦗FR ∩₁ Acq⦘)＊ ⨾ sb ⨾ ⦗W⦘.","proofString":"type_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb ⨾ ⦗W⦘ ∪ ⦗W_ l⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ ⦗W⦘.","proofString":"rewrite sb_in_hb.\ngeneralize (@hb_trans G); ins; relsf.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ hb ⨾ ⦗W⦘ ∪ ⦗W_ l⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ ⦗W⦘.","proofString":"generalize (@hb_trans G); ins; relsf.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) (H : transitive hb) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb ⨾ ⦗W⦘ ∪ ⦗W_ l⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ ⦗W⦘.","proofString":"basic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ ⦗set_compl F⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb ∪ ⦗W_ l⦘ ⨾ rf^?\n  ∪ msg_rel l ⨾ rf ⨾ ⦗Acq⦘.","proofString":"case_refl hb.\narewrite (sc^? ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘).\nby rewrite (dom_r (wf_scD WF_SC)); basic_solver.\narewrite ((hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘).\nby basic_solver.\nbasic_solver 12.\nunfold imm_s_hb.hb.\nrewrite ct_end at 2; relsf.\nunionL.\nbasic_solver 21.\nunfold imm_s_hb.sw at 3; rewrite !seqA.\narewrite ((sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗Acq⦘).\nbasic_solver.\nunfold msg_rel, urr.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ ⦗set_compl F⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb ∪ ⦗W_ l⦘ ⨾ rf^?\n  ∪ msg_rel l ⨾ rf ⨾ ⦗Acq⦘.","proofString":"arewrite (sc^? ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘).\nby rewrite (dom_r (wf_scD WF_SC)); basic_solver.\narewrite ((hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘).\nby basic_solver.\nbasic_solver 12."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : sc^? ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘.","proofString":"by rewrite (dom_r (wf_scD WF_SC)); basic_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ ⦗set_compl F⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb ∪ ⦗W_ l⦘ ⨾ rf^?\n  ∪ msg_rel l ⨾ rf ⨾ ⦗Acq⦘.","proofString":"arewrite ((hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘).\nby basic_solver.\nbasic_solver 12."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ ⦗set_compl F⦘ ⊆ ⦗set_compl F⦘.","proofString":"by basic_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ ⦗set_compl F⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb ∪ ⦗W_ l⦘ ⨾ rf^?\n  ∪ msg_rel l ⨾ rf ⨾ ⦗Acq⦘.","proofString":"basic_solver 12."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb ⨾ ⦗set_compl F⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ sb ∪ ⦗W_ l⦘ ⨾ rf^?\n  ∪ msg_rel l ⨾ rf ⨾ ⦗Acq⦘.","proofString":"unfold imm_s_hb.hb.\nrewrite ct_end at 2; relsf.\nunionL.\nbasic_solver 21.\nunfold imm_s_hb.sw at 3; rewrite !seqA.\narewrite ((sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗Acq⦘).\nbasic_solver.\nunfold msg_rel, urr.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘\n⨾ rf^? ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ (sb ∪ sw)⁺ ⨾ ⦗set_compl F⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ ((sb ∪ sw)⁺)^? ⨾ sb\n  ∪ ⦗W_ l⦘ ⨾ rf^? ∪ msg_rel l ⨾ rf ⨾ ⦗Acq⦘.","proofString":"rewrite ct_end at 2; relsf.\nunionL.\nbasic_solver 21.\nunfold imm_s_hb.sw at 3; rewrite !seqA.\narewrite ((sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗Acq⦘).\nbasic_solver.\nunfold msg_rel, urr.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘\n⨾ rf^?\n  ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ ((sb ∪ sw)＊ ⨾ sb) ⨾ ⦗set_compl F⦘\n∪ ⦗W_ l⦘\n  ⨾ rf^?\n    ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ ((sb ∪ sw)＊ ⨾ sw) ⨾ ⦗set_compl F⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ (sb ∪ sw)＊ ⨾ sb\n  ∪ ⦗W_ l⦘ ⨾ rf^? ∪ msg_rel l ⨾ rf ⨾ ⦗Acq⦘.","proofString":"unionL.\nbasic_solver 21.\nunfold imm_s_hb.sw at 3; rewrite !seqA.\narewrite ((sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗Acq⦘).\nbasic_solver.\nunfold msg_rel, urr.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘\n⨾ rf^?\n  ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ ((sb ∪ sw)＊ ⨾ sb) ⨾ ⦗set_compl F⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ (sb ∪ sw)＊ ⨾ sb\n  ∪ ⦗W_ l⦘ ⨾ rf^? ∪ msg_rel l ⨾ rf ⨾ ⦗Acq⦘.","proofString":"basic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘\n⨾ rf^?\n  ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ ((sb ∪ sw)＊ ⨾ sw) ⨾ ⦗set_compl F⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ (sb ∪ sw)＊ ⨾ sb\n  ∪ ⦗W_ l⦘ ⨾ rf^? ∪ msg_rel l ⨾ rf ⨾ ⦗Acq⦘.","proofString":"unfold imm_s_hb.sw at 3; rewrite !seqA.\narewrite ((sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗Acq⦘).\nbasic_solver.\nunfold msg_rel, urr.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘\n⨾ rf^?\n  ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^?\n    ⨾ sc^? ⨾ (sb ∪ sw)＊ ⨾ release ⨾ rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗set_compl F⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ (sb ∪ sw)＊ ⨾ sb\n  ∪ ⦗W_ l⦘ ⨾ rf^? ∪ msg_rel l ⨾ rf ⨾ ⦗Acq⦘.","proofString":"arewrite ((sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗Acq⦘).\nbasic_solver.\nunfold msg_rel, urr.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗set_compl F⦘ ⊆ ⦗Acq⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘\n⨾ rf^?\n  ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ (sb ∪ sw)＊ ⨾ release ⨾ rf ⨾ ⦗Acq⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ (sb ∪ sw)＊ ⨾ sb\n  ∪ ⦗W_ l⦘ ⨾ rf^? ∪ msg_rel l ⨾ rf ⨾ ⦗Acq⦘.","proofString":"unfold msg_rel, urr.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘\n⨾ rf^?\n  ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ (sb ∪ sw)＊ ⨾ release ⨾ rf ⨾ ⦗Acq⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ (sb ∪ sw)＊ ⨾ sb\n  ∪ ⦗W_ l⦘ ⨾ rf^?\n  ∪ ((⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) ⨾ release)\n    ⨾ rf ⨾ ⦗Acq⦘.","proofString":"basic_solver 21."},{"statement":"(WF : Wf G) (l : location) : (urr l ⨾ release) ⨾ rf ⨾ ⦗Acq⦘ ⊆ urr l.","proofString":"rewrite seqA, (release_rf_in_sw WF), sw_in_hb.\narewrite (hb ⊆ hb^?); apply urr_hb."},{"statement":"(WF : Wf G) (l : location) : urr l ⨾ hb ⊆ urr l.","proofString":"arewrite (hb ⊆ hb^?); apply urr_hb."},{"statement":"(i : BinNums.positive) (l : location) (codom : actid -> Prop) : dom_rel (urr l ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘)\n⊆₁ dom_rel (urr l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘).","proofString":"basic_solver 21."},{"statement":"(i : BinNums.positive) (l l' : location) (codom : actid -> Prop) : dom_rel (urr l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘)\n⊆₁ dom_rel (urr l ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘).","proofString":"basic_solver 21."},{"statement":"(i : BinNums.positive) (l l' : location) (codom : actid -> Prop) : dom_rel (urr l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘)\n⊆₁ dom_rel (urr l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘).","proofString":"basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) : irreflexive (eco ⨾ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?).","proofString":"arewrite_id ⦗W_ l⦘.\narewrite_id ⦗F ∩₁ Sc⦘.\nrels.\narewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\nrewrite (crE sc).\nrelsf; repeat (splits; try apply irreflexive_union).\ngeneralize (@hb_trans G); ins; relsf.\nrewrite (crE hb); relsf; apply irreflexive_union; splits.\nby apply (eco_irr WF).\nred in COH; revert COH; basic_solver 20.\nrewrite (wf_scD WF_SC).\nrotate 3.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_l (wf_ecoD WF)); type_solver|].\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) : irreflexive\n  (eco ⨾ ⦗fun _ : actid => True⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?).","proofString":"arewrite_id ⦗F ∩₁ Sc⦘.\nrels.\narewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\nrewrite (crE sc).\nrelsf; repeat (splits; try apply irreflexive_union).\ngeneralize (@hb_trans G); ins; relsf.\nrewrite (crE hb); relsf; apply irreflexive_union; splits.\nby apply (eco_irr WF).\nred in COH; revert COH; basic_solver 20.\nrewrite (wf_scD WF_SC).\nrotate 3.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_l (wf_ecoD WF)); type_solver|].\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) : irreflexive\n  (eco\n   ⨾ ⦗fun _ : actid => True⦘\n     ⨾ rf^? ⨾ (hb ⨾ ⦗fun _ : actid => True⦘)^? ⨾ sc^? ⨾ hb^?).","proofString":"rels.\narewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\nrewrite (crE sc).\nrelsf; repeat (splits; try apply irreflexive_union).\ngeneralize (@hb_trans G); ins; relsf.\nrewrite (crE hb); relsf; apply irreflexive_union; splits.\nby apply (eco_irr WF).\nred in COH; revert COH; basic_solver 20.\nrewrite (wf_scD WF_SC).\nrotate 3.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_l (wf_ecoD WF)); type_solver|].\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) : irreflexive (eco ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?).","proofString":"arewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\nrewrite (crE sc).\nrelsf; repeat (splits; try apply irreflexive_union).\ngeneralize (@hb_trans G); ins; relsf.\nrewrite (crE hb); relsf; apply irreflexive_union; splits.\nby apply (eco_irr WF).\nred in COH; revert COH; basic_solver 20.\nrewrite (wf_scD WF_SC).\nrotate 3.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_l (wf_ecoD WF)); type_solver|].\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) : irreflexive (eco ⨾ eco^? ⨾ hb^? ⨾ sc^? ⨾ hb^?).","proofString":"generalize (eco_trans WF); ins; relsf.\nrewrite (crE sc).\nrelsf; repeat (splits; try apply irreflexive_union).\ngeneralize (@hb_trans G); ins; relsf.\nrewrite (crE hb); relsf; apply irreflexive_union; splits.\nby apply (eco_irr WF).\nred in COH; revert COH; basic_solver 20.\nrewrite (wf_scD WF_SC).\nrotate 3.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_l (wf_ecoD WF)); type_solver|].\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (H : transitive eco) : irreflexive (eco ⨾ hb^? ⨾ sc^? ⨾ hb^?).","proofString":"rewrite (crE sc).\nrelsf; repeat (splits; try apply irreflexive_union).\ngeneralize (@hb_trans G); ins; relsf.\nrewrite (crE hb); relsf; apply irreflexive_union; splits.\nby apply (eco_irr WF).\nred in COH; revert COH; basic_solver 20.\nrewrite (wf_scD WF_SC).\nrotate 3.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_l (wf_ecoD WF)); type_solver|].\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (H : transitive eco) : irreflexive (eco ⨾ hb^? ⨾ (⦗fun _ : actid => True⦘ ∪ sc) ⨾ hb^?).","proofString":"relsf; repeat (splits; try apply irreflexive_union).\ngeneralize (@hb_trans G); ins; relsf.\nrewrite (crE hb); relsf; apply irreflexive_union; splits.\nby apply (eco_irr WF).\nred in COH; revert COH; basic_solver 20.\nrewrite (wf_scD WF_SC).\nrotate 3.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_l (wf_ecoD WF)); type_solver|].\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (H : transitive eco) : irreflexive (eco ⨾ hb^? ⨾ hb^?).","proofString":"generalize (@hb_trans G); ins; relsf.\nrewrite (crE hb); relsf; apply irreflexive_union; splits.\nby apply (eco_irr WF).\nred in COH; revert COH; basic_solver 20."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (H : transitive eco) (H0 : transitive hb) : irreflexive (eco ⨾ hb^?).","proofString":"rewrite (crE hb); relsf; apply irreflexive_union; splits.\nby apply (eco_irr WF).\nred in COH; revert COH; basic_solver 20."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (H : transitive eco) (H0 : transitive hb) : irreflexive eco.","proofString":"by apply (eco_irr WF)."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (H : transitive eco) (H0 : transitive hb) : irreflexive (eco ⨾ hb).","proofString":"red in COH; revert COH; basic_solver 20."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (H : transitive eco) : irreflexive (eco ⨾ hb^? ⨾ sc ⨾ hb^?).","proofString":"rewrite (wf_scD WF_SC).\nrotate 3.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_l (wf_ecoD WF)); type_solver|].\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (H : transitive eco) : irreflexive (eco ⨾ hb^? ⨾ (⦗F ∩₁ Sc⦘ ⨾ sc ⨾ ⦗F ∩₁ Sc⦘) ⨾ hb^?).","proofString":"rotate 3.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_l (wf_ecoD WF)); type_solver|].\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (H : transitive eco) : irreflexive (sc ⨾ ⦗F ∩₁ Sc⦘ ⨾ hb^? ⨾ eco ⨾ hb^? ⨾ ⦗F ∩₁ Sc⦘).","proofString":"rewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_l (wf_ecoD WF)); type_solver|].\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (H : transitive eco) : irreflexive (sc ⨾ ⦗F ∩₁ Sc⦘ ⨾ hb ⨾ eco ⨾ hb^? ⨾ ⦗F ∩₁ Sc⦘).","proofString":"rewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union); [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (H : transitive eco) : irreflexive (sc ⨾ ⦗F ∩₁ Sc⦘ ⨾ hb ⨾ eco ⨾ hb ⨾ ⦗F ∩₁ Sc⦘).","proofString":"revert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) : (rf⁻¹)^? ⨾ co ⊆ eco.","proofString":"by unfold Execution_eco.eco, Execution.fr; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) : irreflexive (eco ⨾ urr l).","proofString":"eby apply eco_urr_irr."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) : irreflexive (urr l ⨾ sb ⨾ (rf⁻¹)^? ⨾ co).","proofString":"rewrite sb_in_hb.\narewrite (hb ⊆ hb^?).\nsin_rewrite urr_hb.\nby rotate 2; apply transp_rf_co_urr_irr."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) : irreflexive (urr l ⨾ hb ⨾ (rf⁻¹)^? ⨾ co).","proofString":"arewrite (hb ⊆ hb^?).\nsin_rewrite urr_hb.\nby rotate 2; apply transp_rf_co_urr_irr."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) : irreflexive (urr l ⨾ hb^? ⨾ (rf⁻¹)^? ⨾ co).","proofString":"sin_rewrite urr_hb.\nby rotate 2; apply transp_rf_co_urr_irr."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) : irreflexive (urr l ⨾ (rf⁻¹)^? ⨾ co).","proofString":"by rotate 2; apply transp_rf_co_urr_irr."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) : irreflexive ((⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) ⨾ hb).","proofString":"arewrite_id ⦗W_ l⦘.\narewrite_id ⦗F ∩₁ Sc⦘.\nrels.\narewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\nrewrite (crE sc).\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply COH.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union).\nrotate 1; relsf.\nrewrite (wf_scD WF_SC).\nrotate 1.\nsin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf.\nrewrite (wf_scD WF_SC), !seqA.\nrewrite crE; relsf; apply irreflexive_union; splits; [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) : irreflexive\n  (⦗fun _ : actid => True⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^? ⨾ hb).","proofString":"arewrite_id ⦗F ∩₁ Sc⦘.\nrels.\narewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\nrewrite (crE sc).\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply COH.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union).\nrotate 1; relsf.\nrewrite (wf_scD WF_SC).\nrotate 1.\nsin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf.\nrewrite (wf_scD WF_SC), !seqA.\nrewrite crE; relsf; apply irreflexive_union; splits; [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) : irreflexive\n  (⦗fun _ : actid => True⦘\n   ⨾ rf^? ⨾ (hb ⨾ ⦗fun _ : actid => True⦘)^? ⨾ sc^? ⨾ hb^? ⨾ hb).","proofString":"rels.\narewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\nrewrite (crE sc).\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply COH.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union).\nrotate 1; relsf.\nrewrite (wf_scD WF_SC).\nrotate 1.\nsin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf.\nrewrite (wf_scD WF_SC), !seqA.\nrewrite crE; relsf; apply irreflexive_union; splits; [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) : irreflexive (rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^? ⨾ hb).","proofString":"arewrite (rf^? ⊆ eco^?).\ngeneralize (eco_trans WF); ins; relsf.\nrewrite (crE sc).\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply COH.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union).\nrotate 1; relsf.\nrewrite (wf_scD WF_SC).\nrotate 1.\nsin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf.\nrewrite (wf_scD WF_SC), !seqA.\nrewrite crE; relsf; apply irreflexive_union; splits; [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) : irreflexive (eco^? ⨾ hb^? ⨾ sc^? ⨾ hb^? ⨾ hb).","proofString":"generalize (eco_trans WF); ins; relsf.\nrewrite (crE sc).\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply COH.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union).\nrotate 1; relsf.\nrewrite (wf_scD WF_SC).\nrotate 1.\nsin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf.\nrewrite (wf_scD WF_SC), !seqA.\nrewrite crE; relsf; apply irreflexive_union; splits; [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (H : transitive eco) : irreflexive (eco^? ⨾ hb^? ⨾ sc^? ⨾ hb^? ⨾ hb).","proofString":"rewrite (crE sc).\ngeneralize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply COH.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union).\nrotate 1; relsf.\nrewrite (wf_scD WF_SC).\nrotate 1.\nsin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf.\nrewrite (wf_scD WF_SC), !seqA.\nrewrite crE; relsf; apply irreflexive_union; splits; [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (H : transitive eco) : irreflexive (eco^? ⨾ hb^? ⨾ (⦗fun _ : actid => True⦘ ∪ sc) ⨾ hb^? ⨾ hb).","proofString":"generalize (@hb_trans G); ins; relsf.\nrelsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply COH.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union).\nrotate 1; relsf.\nrewrite (wf_scD WF_SC).\nrotate 1.\nsin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf.\nrewrite (wf_scD WF_SC), !seqA.\nrewrite crE; relsf; apply irreflexive_union; splits; [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (H : transitive eco) (H0 : transitive hb) : irreflexive (eco^? ⨾ hb ∪ eco^? ⨾ hb^? ⨾ sc ⨾ hb).","proofString":"relsf; repeat (splits; try apply irreflexive_union).\nby rotate 1; apply COH.\nrewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union).\nrotate 1; relsf.\nrewrite (wf_scD WF_SC).\nrotate 1.\nsin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf.\nrewrite (wf_scD WF_SC), !seqA.\nrewrite crE; relsf; apply irreflexive_union; splits; [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (H : transitive eco) (H0 : transitive hb) : irreflexive (eco^? ⨾ hb).","proofString":"by rotate 1; apply COH."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (H : transitive eco) (H0 : transitive hb) : irreflexive (eco^? ⨾ hb^? ⨾ sc ⨾ hb).","proofString":"rewrite crE at 1; relsf; repeat (splits; try apply irreflexive_union).\nrotate 1; relsf.\nrewrite (wf_scD WF_SC).\nrotate 1.\nsin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf.\nrewrite (wf_scD WF_SC), !seqA.\nrewrite crE; relsf; apply irreflexive_union; splits; [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (H : transitive eco) (H0 : transitive hb) : irreflexive (hb^? ⨾ sc ⨾ hb).","proofString":"rotate 1; relsf.\nrewrite (wf_scD WF_SC).\nrotate 1.\nsin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (H : transitive eco) (H0 : transitive hb) : irreflexive (hb ⨾ sc).","proofString":"rewrite (wf_scD WF_SC).\nrotate 1.\nsin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (H : transitive eco) (H0 : transitive hb) : irreflexive (hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc ⨾ ⦗F ∩₁ Sc⦘).","proofString":"rotate 1.\nsin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (H : transitive eco) (H0 : transitive hb) : irreflexive (⦗F ∩₁ Sc⦘ ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc).","proofString":"sin_rewrite (f_sc_hb_f_sc_in_sc WF WF_SC ACYC_EXT).\ndestruct WF_SC; relsf."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (H : transitive eco) (H0 : transitive hb) : irreflexive (sc ⨾ sc).","proofString":"destruct WF_SC; relsf."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (H : transitive eco) (H0 : transitive hb) : irreflexive (eco ⨾ hb^? ⨾ sc ⨾ hb).","proofString":"rewrite (wf_scD WF_SC), !seqA.\nrewrite crE; relsf; apply irreflexive_union; splits; [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (H : transitive eco) (H0 : transitive hb) : irreflexive (eco ⨾ hb^? ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc ⨾ ⦗F ∩₁ Sc⦘ ⨾ hb).","proofString":"rewrite crE; relsf; apply irreflexive_union; splits; [rewrite (dom_r (wf_ecoD WF)); type_solver|].\nrevert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (H : transitive eco) (H0 : transitive hb) : irreflexive (eco ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc ⨾ ⦗F ∩₁ Sc⦘ ⨾ hb).","proofString":"revert CSC; unfold coh_sc; basic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : urr l ⊆ ⦗W_ l⦘ ∪ ⦗E⦘ ⨾ urr l ⨾ ⦗E⦘.","proofString":"unfold urr.\nrewrite (wf_rfE WF) at 1.\nrewrite (wf_hbE WF) at 1 2.\nrewrite (wf_scE WF_SC) at 1.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?\n⊆ ⦗W_ l⦘ ∪ ⦗E⦘ ⨾ (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) ⨾ ⦗E⦘.","proofString":"rewrite (wf_rfE WF) at 1.\nrewrite (wf_hbE WF) at 1 2.\nrewrite (wf_scE WF_SC) at 1.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⨾ (⦗E⦘ ⨾ rf ⨾ ⦗E⦘)^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?\n⊆ ⦗W_ l⦘ ∪ ⦗E⦘ ⨾ (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) ⨾ ⦗E⦘.","proofString":"rewrite (wf_hbE WF) at 1 2.\nrewrite (wf_scE WF_SC) at 1.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘\n⨾ (⦗E⦘ ⨾ rf ⨾ ⦗E⦘)^?\n  ⨾ ((⦗E⦘ ⨾ hb ⨾ ⦗E⦘) ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ (⦗E⦘ ⨾ hb ⨾ ⦗E⦘)^?\n⊆ ⦗W_ l⦘ ∪ ⦗E⦘ ⨾ (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) ⨾ ⦗E⦘.","proofString":"rewrite (wf_scE WF_SC) at 1.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘\n⨾ (⦗E⦘ ⨾ rf ⨾ ⦗E⦘)^?\n  ⨾ ((⦗E⦘ ⨾ hb ⨾ ⦗E⦘) ⨾ ⦗F ∩₁ Sc⦘)^?\n    ⨾ (⦗E⦘ ⨾ sc ⨾ ⦗E⦘)^? ⨾ (⦗E⦘ ⨾ hb ⨾ ⦗E⦘)^?\n⊆ ⦗W_ l⦘ ∪ ⦗E⦘ ⨾ (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) ⨾ ⦗E⦘.","proofString":"basic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ∪ ⦗E⦘ ⨾ urr l ⨾ ⦗E⦘ ⊆ urr l.","proofString":"unionL; [|basic_solver].\nunfold urr; basic_solver 12."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : ⦗W_ l⦘ ⊆ urr l.","proofString":"unfold urr; basic_solver 12."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (i : BinNums.positive) (l : location) (codom : actid -> Prop) (IN : codom ⊆₁ E) : c_cur i l codom ⊆ ⦗E⦘ ⨾ c_cur i l codom ⨾ ⦗E⦘.","proofString":"unfold c_cur.\nrewrite (wf_urrE WF WF_SC l).\ngeneralize IN.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (i : BinNums.positive) (l : location) (codom : actid -> Prop) (IN : codom ⊆₁ E) : urr l ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘\n⊆ ⦗E⦘ ⨾ (urr l ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘) ⨾ ⦗E⦘.","proofString":"rewrite (wf_urrE WF WF_SC l).\ngeneralize IN.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (i : BinNums.positive) (l : location) (codom : actid -> Prop) (IN : codom ⊆₁ E) : (⦗W_ l⦘ ∪ ⦗E⦘ ⨾ urr l ⨾ ⦗E⦘) ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘\n⊆ ⦗E⦘ ⨾ ((⦗W_ l⦘ ∪ ⦗E⦘ ⨾ urr l ⨾ ⦗E⦘) ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘) ⨾ ⦗E⦘.","proofString":"generalize IN.\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (i : BinNums.positive) (l : location) (codom : actid -> Prop) (IN : codom ⊆₁ E) : codom ⊆₁ E ->\n(⦗W_ l⦘ ∪ ⦗E⦘ ⨾ urr l ⨾ ⦗E⦘) ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘\n⊆ ⦗E⦘ ⨾ ((⦗W_ l⦘ ∪ ⦗E⦘ ⨾ urr l ⨾ ⦗E⦘) ⨾ ⦗Tid_ i ∪₁ Init⦘ ⨾ ⦗codom⦘) ⨾ ⦗E⦘.","proofString":"basic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (i : BinNums.positive) (l : location) (codom : actid -> Prop) (IN : codom ⊆₁ E) : dom_rel (c_cur i l codom) ⊆₁ E.","proofString":"rewrite (wf_c_curE WF WF_SC i l IN).\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (i : BinNums.positive) (l : location) (codom : actid -> Prop) (IN : codom ⊆₁ E) : dom_rel (⦗E⦘ ⨾ c_cur i l codom ⨾ ⦗E⦘) ⊆₁ E.","proofString":"basic_solver 21."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : dom_rel (urr l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗C'⦘)\n≡₁ dom_rel (urr l ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗C⦘).","proofString":"rewrite <- !id_inter.\nrewrite !set_inter_union_l.\narewrite (Init ∩₁ C ≡₁ Init ∩₁ C').\nsplit; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver.\nbasic_solver 21."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : dom_rel (urr l ⨾ ⦗(Tid_ thread ∪₁ Init) ∩₁ C'⦘)\n≡₁ dom_rel (urr l ⨾ ⦗(Tid_ thread ∪₁ Init) ∩₁ C⦘).","proofString":"rewrite !set_inter_union_l.\narewrite (Init ∩₁ C ≡₁ Init ∩₁ C').\nsplit; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver.\nbasic_solver 21."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : dom_rel (urr l ⨾ ⦗Tid_ thread ∩₁ C' ∪₁ Init ∩₁ C'⦘)\n≡₁ dom_rel (urr l ⨾ ⦗Tid_ thread ∩₁ C ∪₁ Init ∩₁ C⦘).","proofString":"arewrite (Init ∩₁ C ≡₁ Init ∩₁ C').\nsplit; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver.\nbasic_solver 21."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : Init ∩₁ C ≡₁ Init ∩₁ C'.","proofString":"split; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : Init ∩₁ C' ⊆₁ Init ∩₁ C.","proofString":"rewrite CE.\ngeneralize CINIT.\nbasic_solver."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : Init ∩₁ E ⊆₁ Init ∩₁ C.","proofString":"generalize CINIT.\nbasic_solver."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : Init ∩₁ E ⊆₁ C -> Init ∩₁ E ⊆₁ Init ∩₁ C.","proofString":"basic_solver."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : dom_rel (urr l ⨾ ⦗Tid_ thread ∩₁ C' ∪₁ Init ∩₁ C'⦘)\n≡₁ dom_rel (urr l ⨾ ⦗Tid_ thread ∩₁ C ∪₁ Init ∩₁ C'⦘).","proofString":"basic_solver 21."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : dom_rel (urr l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗C'⦘)\n≡₁ dom_rel (urr l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗C⦘).","proofString":"rewrite <- !id_inter.\nrewrite !set_inter_union_l.\narewrite (Init ∩₁ C ≡₁ Init ∩₁ C').\nsplit; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver.\nbasic_solver 21."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : dom_rel (urr l ⨾ (release ⨾ rf)^? ⨾ ⦗(Tid_ thread ∪₁ Init) ∩₁ C'⦘)\n≡₁ dom_rel (urr l ⨾ (release ⨾ rf)^? ⨾ ⦗(Tid_ thread ∪₁ Init) ∩₁ C⦘).","proofString":"rewrite !set_inter_union_l.\narewrite (Init ∩₁ C ≡₁ Init ∩₁ C').\nsplit; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver.\nbasic_solver 21."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : dom_rel (urr l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∩₁ C' ∪₁ Init ∩₁ C'⦘)\n≡₁ dom_rel (urr l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∩₁ C ∪₁ Init ∩₁ C⦘).","proofString":"arewrite (Init ∩₁ C ≡₁ Init ∩₁ C').\nsplit; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver.\nbasic_solver 21."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : Init ∩₁ C ≡₁ Init ∩₁ C'.","proofString":"split; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : Init ∩₁ C' ⊆₁ Init ∩₁ C.","proofString":"rewrite CE.\ngeneralize CINIT.\nbasic_solver."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : Init ∩₁ E ⊆₁ Init ∩₁ C.","proofString":"generalize CINIT.\nbasic_solver."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : Init ∩₁ E ⊆₁ C -> Init ∩₁ E ⊆₁ Init ∩₁ C.","proofString":"basic_solver."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : dom_rel (urr l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∩₁ C' ∪₁ Init ∩₁ C'⦘)\n≡₁ dom_rel (urr l ⨾ (release ⨾ rf)^? ⨾ ⦗Tid_ thread ∩₁ C ∪₁ Init ∩₁ C'⦘).","proofString":"basic_solver 21."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l l' : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : dom_rel (urr l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗C⦘)\n≡₁ dom_rel (urr l ⨾ ⦗Rel⦘ ⨾ ⦗W_ l' ∪₁ F⦘ ⨾ ⦗Tid_ thread ∪₁ Init⦘ ⨾ ⦗C'⦘).","proofString":"rewrite <- !id_inter.\nrewrite !set_inter_union_l.\narewrite (Init ∩₁ C ≡₁ Init ∩₁ C').\nsplit; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver.\nbasic_solver 21."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l l' : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : dom_rel (urr l ⨾ ⦗Rel ∩₁ ((W_ l' ∪₁ F) ∩₁ ((Tid_ thread ∪₁ Init) ∩₁ C))⦘)\n≡₁ dom_rel (urr l ⨾ ⦗Rel ∩₁ ((W_ l' ∪₁ F) ∩₁ ((Tid_ thread ∪₁ Init) ∩₁ C'))⦘).","proofString":"rewrite !set_inter_union_l.\narewrite (Init ∩₁ C ≡₁ Init ∩₁ C').\nsplit; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver.\nbasic_solver 21."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l l' : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : dom_rel\n  (urr l\n   ⨾ ⦗Rel\n      ∩₁ (W_ l' ∩₁ (Tid_ thread ∩₁ C ∪₁ Init ∩₁ C)\n          ∪₁ F ∩₁ (Tid_ thread ∩₁ C ∪₁ Init ∩₁ C))⦘)\n≡₁ dom_rel\n     (urr l\n      ⨾ ⦗Rel\n         ∩₁ (W_ l' ∩₁ (Tid_ thread ∩₁ C' ∪₁ Init ∩₁ C')\n             ∪₁ F ∩₁ (Tid_ thread ∩₁ C' ∪₁ Init ∩₁ C'))⦘).","proofString":"arewrite (Init ∩₁ C ≡₁ Init ∩₁ C').\nsplit; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver.\nbasic_solver 21."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l l' : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : Init ∩₁ C ≡₁ Init ∩₁ C'.","proofString":"split; [basic_solver|].\nrewrite CE.\ngeneralize CINIT.\nbasic_solver."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l l' : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : Init ∩₁ C' ⊆₁ Init ∩₁ C.","proofString":"rewrite CE.\ngeneralize CINIT.\nbasic_solver."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l l' : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : Init ∩₁ E ⊆₁ Init ∩₁ C.","proofString":"generalize CINIT.\nbasic_solver."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l l' : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : Init ∩₁ E ⊆₁ C -> Init ∩₁ E ⊆₁ Init ∩₁ C.","proofString":"basic_solver."},{"statement":"(C C' : actid -> Prop) (thread : BinNums.positive) (l l' : location) (CINIT : Init ∩₁ E ⊆₁ C) (CINCL : C ⊆₁ C') (CE : C' ⊆₁ E) (COVSTEP : forall a : actid, tid a = thread -> C' a -> C a) : dom_rel\n  (urr l\n   ⨾ ⦗Rel\n      ∩₁ (W_ l' ∩₁ (Tid_ thread ∩₁ C ∪₁ Init ∩₁ C')\n          ∪₁ F ∩₁ (Tid_ thread ∩₁ C ∪₁ Init ∩₁ C'))⦘)\n≡₁ dom_rel\n     (urr l\n      ⨾ ⦗Rel\n         ∩₁ (W_ l' ∩₁ (Tid_ thread ∩₁ C' ∪₁ Init ∩₁ C')\n             ∪₁ F ∩₁ (Tid_ thread ∩₁ C' ∪₁ Init ∩₁ C'))⦘).","proofString":"basic_solver 21."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n≡ ⦗W_ l⦘\n  ⨾ rf^?\n    ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"split.\nunfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf.\nunionL; [basic_solver 21|].\nunfold imm_s_hb.sw at 2; rewrite !seqA.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) at 1.\nby basic_solver.\narewrite (rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ Sc⦘ ⊆ rf ⨾ sb).\nby rewrite (dom_r (wf_rfD WF)) at 1; type_solver 22.\nbasic_solver 42.\narewrite_id ⦗F ∩₁ Sc⦘ at 1.\ngeneralize (@hb_trans G); ins; relsf.\ncase_refl (release ⨾ rf).\nrewrite (sb_in_hb); relsf.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) at 1.\nby basic_solver.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Acq⦘) at 1 by mode_solver.\narewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nby unfold imm_s_hb.sw; basic_solver 12.\nrewrite (sw_in_hb); relsf."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘\n  ⨾ rf^?\n    ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"unfold imm_s_hb.hb.\nrewrite ct_end at 1; relsf.\nunionL; [basic_solver 21|].\nunfold imm_s_hb.sw at 2; rewrite !seqA.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) at 1.\nby basic_solver.\narewrite (rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ Sc⦘ ⊆ rf ⨾ sb).\nby rewrite (dom_r (wf_rfD WF)) at 1; type_solver 22.\nbasic_solver 42."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) : ⦗W_ l⦘ ⨾ rf^? ⨾ (sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘\n  ⨾ rf^?\n    ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^?\n      ⨾ ((sb ∪ sw)⁺)^? ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"rewrite ct_end at 1; relsf.\nunionL; [basic_solver 21|].\nunfold imm_s_hb.sw at 2; rewrite !seqA.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) at 1.\nby basic_solver.\narewrite (rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ Sc⦘ ⊆ rf ⨾ sb).\nby rewrite (dom_r (wf_rfD WF)) at 1; type_solver 22.\nbasic_solver 42."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) : ⦗W_ l⦘ ⨾ rf^? ⨾ ((sb ∪ sw)＊ ⨾ sb) ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n∪ ⦗W_ l⦘ ⨾ rf^? ⨾ ((sb ∪ sw)＊ ⨾ sw) ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘\n  ⨾ rf^?\n    ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^?\n      ⨾ (sb ∪ sw)＊ ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"unionL; [basic_solver 21|].\nunfold imm_s_hb.sw at 2; rewrite !seqA.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) at 1.\nby basic_solver.\narewrite (rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ Sc⦘ ⊆ rf ⨾ sb).\nby rewrite (dom_r (wf_rfD WF)) at 1; type_solver 22.\nbasic_solver 42."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) : ⦗W_ l⦘ ⨾ rf^? ⨾ ((sb ∪ sw)＊ ⨾ sw) ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘\n  ⨾ rf^?\n    ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^?\n      ⨾ (sb ∪ sw)＊ ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"unfold imm_s_hb.sw at 2; rewrite !seqA.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) at 1.\nby basic_solver.\narewrite (rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ Sc⦘ ⊆ rf ⨾ sb).\nby rewrite (dom_r (wf_rfD WF)) at 1; type_solver 22.\nbasic_solver 42."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) : ⦗W_ l⦘\n⨾ rf^?\n  ⨾ (sb ∪ sw)＊ ⨾ release ⨾ rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘\n  ⨾ rf^?\n    ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^?\n      ⨾ (sb ∪ sw)＊ ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"arewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) at 1.\nby basic_solver.\narewrite (rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ Sc⦘ ⊆ rf ⨾ sb).\nby rewrite (dom_r (wf_rfD WF)) at 1; type_solver 22.\nbasic_solver 42."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) : ⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘.","proofString":"by basic_solver."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) : ⦗W_ l⦘\n⨾ rf^?\n  ⨾ (sb ∪ sw)＊\n    ⨾ release ⨾ rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘\n  ⨾ rf^?\n    ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^?\n      ⨾ (sb ∪ sw)＊ ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"arewrite (rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ Sc⦘ ⊆ rf ⨾ sb).\nby rewrite (dom_r (wf_rfD WF)) at 1; type_solver 22.\nbasic_solver 42."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) : rf ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⨾ ⦗F ∩₁ Sc⦘ ⊆ rf ⨾ sb.","proofString":"by rewrite (dom_r (wf_rfD WF)) at 1; type_solver 22."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) : ⦗W_ l⦘ ⨾ rf^? ⨾ (sb ∪ sw)＊ ⨾ release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘\n  ⨾ rf^?\n    ⨾ ((sb ∪ sw)⁺ ⨾ ⦗F ∩₁ Sc⦘)^?\n      ⨾ (sb ∪ sw)＊ ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"basic_solver 42."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) : ⦗W_ l⦘\n⨾ rf^?\n  ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"arewrite_id ⦗F ∩₁ Sc⦘ at 1.\ngeneralize (@hb_trans G); ins; relsf.\ncase_refl (release ⨾ rf).\nrewrite (sb_in_hb); relsf.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) at 1.\nby basic_solver.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Acq⦘) at 1 by mode_solver.\narewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nby unfold imm_s_hb.sw; basic_solver 12.\nrewrite (sw_in_hb); relsf."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) : ⦗W_ l⦘\n⨾ rf^?\n  ⨾ (hb ⨾ ⦗fun _ : actid => True⦘)^?\n    ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"generalize (@hb_trans G); ins; relsf.\ncase_refl (release ⨾ rf).\nrewrite (sb_in_hb); relsf.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) at 1.\nby basic_solver.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Acq⦘) at 1 by mode_solver.\narewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nby unfold imm_s_hb.sw; basic_solver 12.\nrewrite (sw_in_hb); relsf."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) (H : transitive hb) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ (release ⨾ rf)^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"case_refl (release ⨾ rf).\nrewrite (sb_in_hb); relsf.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) at 1.\nby basic_solver.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Acq⦘) at 1 by mode_solver.\narewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nby unfold imm_s_hb.sw; basic_solver 12.\nrewrite (sw_in_hb); relsf."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) (H : transitive hb) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"rewrite (sb_in_hb); relsf."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) (H : transitive hb) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ (release ⨾ rf) ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"arewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘) at 1.\nby basic_solver.\narewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Acq⦘) at 1 by mode_solver.\narewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nby unfold imm_s_hb.sw; basic_solver 12.\nrewrite (sw_in_hb); relsf."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) (H : transitive hb) : ⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘.","proofString":"by basic_solver."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) (H : transitive hb) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"arewrite (⦗F ∩₁ Sc⦘ ⊆ ⦗F ∩₁ Acq⦘) at 1 by mode_solver.\narewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nby unfold imm_s_hb.sw; basic_solver 12.\nrewrite (sw_in_hb); relsf."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) (H : transitive hb) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"arewrite (release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw).\nby unfold imm_s_hb.sw; basic_solver 12.\nrewrite (sw_in_hb); relsf."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) (H : transitive hb) : release ⨾ rf ⨾ sb ⨾ ⦗F ∩₁ Acq⦘ ⊆ sw.","proofString":"by unfold imm_s_hb.sw; basic_solver 12."},{"statement":"(l : location) (codom : actid -> Prop) (WF : Wf G) (H : transitive hb) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sw ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⨾ ⦗codom⦘.","proofString":"rewrite (sw_in_hb); relsf."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) : urr l ⨾ ⦗fun _ : actid => True⦘ ≡ urr l ⨾ ⦗set_compl Init⦘ ∪ ⦗Loc_ l ∩₁ Init⦘.","proofString":"rewrite set_split_complete with (s' := set_full) (s := is_init), !set_inter_full_l.\nrewrite id_union, seq_union_r.\nrewrite unionC.\napply union_more; [done| ].\nunfold urr.\nassert (is_init ≡₁ is_init ∩₁ W) as I' by (generalize init_w; basic_solver).\nrewrite I' at 2.\nrewrite no_sc_to_init with (sc := sc), no_hb_to_init, no_rf_to_init; eauto.\nbasic_solver 20."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) : urr l ⨾ ⦗Init ∪₁ set_compl Init⦘\n≡ urr l ⨾ ⦗set_compl Init⦘ ∪ ⦗Loc_ l ∩₁ Init⦘.","proofString":"rewrite id_union, seq_union_r.\nrewrite unionC.\napply union_more; [done| ].\nunfold urr.\nassert (is_init ≡₁ is_init ∩₁ W) as I' by (generalize init_w; basic_solver).\nrewrite I' at 2.\nrewrite no_sc_to_init with (sc := sc), no_hb_to_init, no_rf_to_init; eauto.\nbasic_solver 20."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) : urr l ⨾ ⦗Init⦘ ∪ urr l ⨾ ⦗set_compl Init⦘\n≡ urr l ⨾ ⦗set_compl Init⦘ ∪ ⦗Loc_ l ∩₁ Init⦘.","proofString":"rewrite unionC.\napply union_more; [done| ].\nunfold urr.\nassert (is_init ≡₁ is_init ∩₁ W) as I' by (generalize init_w; basic_solver).\nrewrite I' at 2.\nrewrite no_sc_to_init with (sc := sc), no_hb_to_init, no_rf_to_init; eauto.\nbasic_solver 20."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) : urr l ⨾ ⦗set_compl Init⦘ ∪ urr l ⨾ ⦗Init⦘\n≡ urr l ⨾ ⦗set_compl Init⦘ ∪ ⦗Loc_ l ∩₁ Init⦘.","proofString":"apply union_more; [done| ].\nunfold urr.\nassert (is_init ≡₁ is_init ∩₁ W) as I' by (generalize init_w; basic_solver).\nrewrite I' at 2.\nrewrite no_sc_to_init with (sc := sc), no_hb_to_init, no_rf_to_init; eauto.\nbasic_solver 20."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) : urr l ⨾ ⦗Init⦘ ≡ ⦗Loc_ l ∩₁ Init⦘.","proofString":"unfold urr.\nassert (is_init ≡₁ is_init ∩₁ W) as I' by (generalize init_w; basic_solver).\nrewrite I' at 2.\nrewrite no_sc_to_init with (sc := sc), no_hb_to_init, no_rf_to_init; eauto.\nbasic_solver 20."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) : (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) ⨾ ⦗Init⦘\n≡ ⦗Loc_ l ∩₁ Init⦘.","proofString":"assert (is_init ≡₁ is_init ∩₁ W) as I' by (generalize init_w; basic_solver).\nrewrite I' at 2.\nrewrite no_sc_to_init with (sc := sc), no_hb_to_init, no_rf_to_init; eauto.\nbasic_solver 20."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (I' : Init ≡₁ Init ∩₁ W) : (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) ⨾ ⦗Init⦘\n≡ ⦗Loc_ l ∩₁ Init⦘.","proofString":"rewrite I' at 2.\nrewrite no_sc_to_init with (sc := sc), no_hb_to_init, no_rf_to_init; eauto.\nbasic_solver 20."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (I' : Init ≡₁ Init ∩₁ W) : (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) ⨾ ⦗Init⦘\n≡ ⦗Loc_ l ∩₁ (Init ∩₁ W)⦘.","proofString":"rewrite no_sc_to_init with (sc := sc), no_hb_to_init, no_rf_to_init; eauto.\nbasic_solver 20."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (I' : Init ≡₁ Init ∩₁ W) : (⦗W_ l⦘\n ⨾ (rf ⨾ ⦗fun x : actid => ~ is_init x⦘)^?\n   ⨾ ((hb ⨾ ⦗fun x : actid => ~ is_init x⦘) ⨾ ⦗F ∩₁ Sc⦘)^?\n     ⨾ (sc ⨾ ⦗fun x : actid => ~ is_init x⦘)^?\n       ⨾ (hb ⨾ ⦗fun x : actid => ~ is_init x⦘)^?) ⨾ ⦗Init⦘\n≡ ⦗Loc_ l ∩₁ (Init ∩₁ W)⦘.","proofString":"basic_solver 20."},{"statement":"(fun x y : actid => exists l : location, urr l x y) ≡ (⋃l, urr l).","proofString":"basic_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) : (fun _ : option location => True) ≡₁ (⋃₁l, eq (Some l)) ∪₁ eq None.","proofString":"unfolder.\nsplit; ins; destruct x; vauto."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) : (forall x : option location,\n True -> (exists y : location, True /\\ Some y = x) \\/ None = x) /\\\n(forall x : option location,\n (exists y : location, True /\\ Some y = x) \\/ None = x -> True).","proofString":"split; ins; destruct x; vauto."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) : (⋃₁b ∈ eq None, Init ∩₁ (fun a : actid => loc a = b)) ≡₁ ∅.","proofString":"split; [| basic_solver].\nunfolder.\nins.\ndesc.\nsubst.\nedestruct is_w_loc; eauto.\neapply init_w; eauto.\nvauto."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) : (⋃₁b ∈ eq None, Init ∩₁ (fun a : actid => loc a = b)) ⊆₁ ∅.","proofString":"unfolder.\nins.\ndesc.\nsubst.\nedestruct is_w_loc; eauto.\neapply init_w; eauto.\nvauto."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) : forall x : actid,\n(exists y : option location, None = y /\\ is_init x /\\ loc x = y) -> False.","proofString":"ins.\ndesc.\nsubst.\nedestruct is_w_loc; eauto.\neapply init_w; eauto.\nvauto."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (x : actid) (H : exists y : option location, None = y /\\ is_init x /\\ loc x = y) : False.","proofString":"desc.\nsubst.\nedestruct is_w_loc; eauto.\neapply init_w; eauto.\nvauto."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (x : actid) (y : option location) (H : None = y) (H0 : is_init x) (H1 : loc x = y) : False.","proofString":"subst.\nedestruct is_w_loc; eauto.\neapply init_w; eauto.\nvauto."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (x : actid) (H0 : is_init x) (H1 : loc x = None) : False.","proofString":"edestruct is_w_loc; eauto.\neapply init_w; eauto.\nvauto."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) : (⋃l, urr l)\n≡ (⋃l, urr l) ⨾ ⦗set_compl Init⦘\n  ∪ ⦗⋃₁y, ⋃₁x ∈ eq (Some y), Init ∩₁ (fun a : actid => loc a = x)⦘.","proofString":"rewrite <- bunion_set_bunion, seq_bunion_l.\nrewrite <- bunion_union_r.\napply bunion_more_equiv; [done| ].\nintros l _.\nrewrite set_bunion_eq.\nrewrite urr_to_ninit at 1; auto.\nbasic_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) : (⋃l, urr l)\n≡ (⋃n, urr n ⨾ ⦗set_compl Init⦘)\n  ∪ (⋃x, ⦗⋃₁x0 ∈ eq (Some x), Init ∩₁ (fun a : actid => loc a = x0)⦘).","proofString":"rewrite <- bunion_union_r.\napply bunion_more_equiv; [done| ].\nintros l _.\nrewrite set_bunion_eq.\nrewrite urr_to_ninit at 1; auto.\nbasic_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) : (⋃l, urr l)\n≡ (⋃x,\n    urr x ⨾ ⦗set_compl Init⦘\n    ∪ ⦗⋃₁x0 ∈ eq (Some x), Init ∩₁ (fun a : actid => loc a = x0)⦘).","proofString":"apply bunion_more_equiv; [done| ].\nintros l _.\nrewrite set_bunion_eq.\nrewrite urr_to_ninit at 1; auto.\nbasic_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) : forall a : location,\nTrue ->\nurr a\n≡ urr a ⨾ ⦗set_compl Init⦘\n  ∪ ⦗⋃₁x ∈ eq (Some a), Init ∩₁ (fun a0 : actid => loc a0 = x)⦘.","proofString":"intros l _.\nrewrite set_bunion_eq.\nrewrite urr_to_ninit at 1; auto.\nbasic_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : urr l\n≡ urr l ⨾ ⦗set_compl Init⦘\n  ∪ ⦗⋃₁x ∈ eq (Some l), Init ∩₁ (fun a : actid => loc a = x)⦘.","proofString":"rewrite set_bunion_eq.\nrewrite urr_to_ninit at 1; auto.\nbasic_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : urr l ≡ urr l ⨾ ⦗set_compl Init⦘ ∪ ⦗Init ∩₁ Loc_ l⦘.","proofString":"rewrite urr_to_ninit at 1; auto.\nbasic_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (l : location) : urr l ⨾ ⦗set_compl Init⦘ ∪ ⦗Loc_ l ∩₁ Init⦘\n≡ urr l ⨾ ⦗set_compl Init⦘ ∪ ⦗Init ∩₁ Loc_ l⦘.","proofString":"basic_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) : (forall x y : actid,\n (exists l : location, urr l x y) ->\n x = y /\\ is_w lab x \\/ E x /\\ (exists l : location, urr l x y) /\\ E y) /\\\n(forall x y : actid,\n x = y /\\ is_w lab x \\/ E x /\\ (exists l : location, urr l x y) /\\ E y ->\n exists l : location, urr l x y).","proofString":"split; ins; desf; eauto.\napply (wf_urrE WF WF_SC) in H.\nunfolder in H; desf; splits; eauto.\nforward (apply is_w_loc); ins; desf; eauto.\nunfold urr; basic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (x y : actid) (l : location) (H : urr l x y) : x = y /\\ is_w lab x \\/ E x /\\ (exists l0 : location, urr l0 x y) /\\ E y.","proofString":"apply (wf_urrE WF WF_SC) in H.\nunfolder in H; desf; splits; eauto."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (x y : actid) (l : location) (H : (⦗W_ l⦘ ∪ ⦗E⦘ ⨾ urr l ⨾ ⦗E⦘) x y) : x = y /\\ is_w lab x \\/ E x /\\ (exists l0 : location, urr l0 x y) /\\ E y.","proofString":"unfolder in H; desf; splits; eauto."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (y : actid) (H0 : is_w lab y) : exists l : location, urr l y y.","proofString":"forward (apply is_w_loc); ins; desf; eauto.\nunfold urr; basic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (y : actid) (H0 : is_w lab y) (l : location) (H : loc y = Some l) : exists l0 : location, urr l0 y y.","proofString":"unfold urr; basic_solver 21."},{"statement":"(WF : Wf G) : rf\n⊆ (fun x y : actid =>\n   exists l : location,\n     (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) x y).","proofString":"do 2 rewrite (dom_l (wf_rfD WF)).\nunfolder; ins; desc.\napply is_w_loc in H1; desf.\nbasic_solver 21."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ ⦗W⦘ ⨾ rf\n⊆ (fun x y : actid =>\n   exists l : location,\n     (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?) x y).","proofString":"unfolder; ins; desc.\napply is_w_loc in H1; desf.\nbasic_solver 21."},{"statement":"(WF : Wf G) (x y : actid) (H H1 : is_w lab x) (H0 : rf x y) : exists (l : location) (z : actid),\n  (x = z /\\ is_w lab x /\\ loc x = Some l) /\\\n  (exists z0 : actid,\n     (z = z0 \\/ rf z z0) /\\\n     (exists z1 : actid,\n        (z0 = z1 \\/\n         (exists z2 : actid,\n            hb z0 z2 /\\ z2 = z1 /\\ is_f lab z2 /\\ is_sc lab z2)) /\\\n        (exists z2 : actid, (z1 = z2 \\/ sc z1 z2) /\\ (z2 = y \\/ hb z2 y)))).","proofString":"apply is_w_loc in H1; desf.\nbasic_solver 21."},{"statement":"(WF : Wf G) (x y : actid) (H : is_w lab x) (l : location) (H1 : loc x = Some l) (H0 : rf x y) : exists (l0 : location) (z : actid),\n  (x = z /\\ true /\\ loc x = Some l0) /\\\n  (exists z0 : actid,\n     (z = z0 \\/ rf z z0) /\\\n     (exists z1 : actid,\n        (z0 = z1 \\/\n         (exists z2 : actid,\n            hb z0 z2 /\\ z2 = z1 /\\ is_f lab z2 /\\ is_sc lab z2)) /\\\n        (exists z2 : actid, (z1 = z2 \\/ sc z1 z2) /\\ (z2 = y \\/ hb z2 y)))).","proofString":"basic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) : irreflexive (eco ⨾ (fun x y : actid => exists l : location, urr l x y)).","proofString":"unfolder; ins; desf.\neapply eco_urr_irr; basic_solver."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (x z : actid) (H : eco x z) (l : location) (H0 : urr l z x) : False.","proofString":"eapply eco_urr_irr; basic_solver."},{"statement":"(l : location) (WF_SC : wf_sc G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?\n≡ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proofString":"split.\narewrite_id ⦗F ∩₁ Sc⦘; rels.\ncase_refl sc.\ngeneralize (@hb_trans G); basic_solver 21.\nrewrite (dom_l (wf_scD WF_SC)); basic_solver 21."},{"statement":"(l : location) (WF_SC : wf_sc G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proofString":"arewrite_id ⦗F ∩₁ Sc⦘; rels."},{"statement":"(l : location) (WF_SC : wf_sc G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?.","proofString":"case_refl sc.\ngeneralize (@hb_trans G); basic_solver 21.\nrewrite (dom_l (wf_scD WF_SC)); basic_solver 21."},{"statement":"(l : location) (WF_SC : wf_sc G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ hb^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?.","proofString":"generalize (@hb_trans G); basic_solver 21."},{"statement":"(l : location) (WF_SC : wf_sc G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc ⨾ hb^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ hb^?.","proofString":"rewrite (dom_l (wf_scD WF_SC)); basic_solver 21."},{"statement":"(WF_SC : wf_sc G sc) (x y : actid) (l : location) (H : urr l x y) : (⦗W⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?) x y.","proofString":"apply (urr_alt l WF_SC) in H; unfolder in *; basic_solver 21."},{"statement":"(WF_SC : wf_sc G sc) (x y : actid) (H : (⦗W⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?) x y) : exists l : location, urr l x y.","proofString":"unfolder in H; desc.\nforward (apply is_w_loc); try edone.\nins; desc.\nexists l.\napply (urr_alt l WF_SC).\nbasic_solver 21."},{"statement":"(WF_SC : wf_sc G sc) (x y : actid) (H : is_w lab x) (z : actid) (H0 : x = z \\/ rf x z) (z0 : actid) (H1 : z = z0 \\/ hb z z0) (z1 : actid) (H2 : z0 = z1 \\/ sc z0 z1) (H3 : z1 = y \\/ hb z1 y) : exists l : location, urr l x y.","proofString":"forward (apply is_w_loc); try edone.\nins; desc.\nexists l.\napply (urr_alt l WF_SC).\nbasic_solver 21."},{"statement":"(WF_SC : wf_sc G sc) (x y : actid) (H : is_w lab x) (z : actid) (H0 : x = z \\/ rf x z) (z0 : actid) (H1 : z = z0 \\/ hb z z0) (z1 : actid) (H2 : z0 = z1 \\/ sc z0 z1) (H3 : z1 = y \\/ hb z1 y) : (exists l : location, loc x = Some l) -> exists l : location, urr l x y.","proofString":"ins; desc.\nexists l.\napply (urr_alt l WF_SC).\nbasic_solver 21."},{"statement":"(WF_SC : wf_sc G sc) (x y : actid) (H : is_w lab x) (z : actid) (H0 : x = z \\/ rf x z) (z0 : actid) (H1 : z = z0 \\/ hb z z0) (z1 : actid) (H2 : z0 = z1 \\/ sc z0 z1) (H3 : z1 = y \\/ hb z1 y) (l : location) (H4 : loc x = Some l) : exists l0 : location, urr l0 x y.","proofString":"exists l.\napply (urr_alt l WF_SC).\nbasic_solver 21."},{"statement":"(WF_SC : wf_sc G sc) (x y : actid) (H : is_w lab x) (z : actid) (H0 : x = z \\/ rf x z) (z0 : actid) (H1 : z = z0 \\/ hb z z0) (z1 : actid) (H2 : z0 = z1 \\/ sc z0 z1) (H3 : z1 = y \\/ hb z1 y) (l : location) (H4 : loc x = Some l) : urr l x y.","proofString":"apply (urr_alt l WF_SC).\nbasic_solver 21."},{"statement":"(WF_SC : wf_sc G sc) (x y : actid) (H : is_w lab x) (z : actid) (H0 : x = z \\/ rf x z) (z0 : actid) (H1 : z = z0 \\/ hb z z0) (z1 : actid) (H2 : z0 = z1 \\/ sc z0 z1) (H3 : z1 = y \\/ hb z1 y) (l : location) (H4 : loc x = Some l) : (⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?) x y.","proofString":"basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^? ⨾ hb ⨾ sc^? ⨾ hb^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proofString":"case_refl sc.\ngeneralize (@hb_trans G); basic_solver 21.\ncase_refl (sc).\ngeneralize (@hb_trans G); basic_solver 21.\nrewrite (dom_l (wf_scD WF_SC)) at 2.\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc ⨾ hb^? ⨾ hb ⊆ urr l).\nrewrite (urr_alt l WF_SC).\ngeneralize (@hb_trans G); basic_solver 21.\nsin_rewrite (urr_f_sc WF WF_SC ACYC_EXT).\nrewrite !seqA.\ngeneralize (sc_trans WF_SC); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ hb^? ⨾ hb ⨾ sc^? ⨾ hb^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proofString":"generalize (@hb_trans G); basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc ⨾ hb^? ⨾ hb ⨾ sc^? ⨾ hb^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proofString":"case_refl (sc).\ngeneralize (@hb_trans G); basic_solver 21.\nrewrite (dom_l (wf_scD WF_SC)) at 2.\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc ⨾ hb^? ⨾ hb ⊆ urr l).\nrewrite (urr_alt l WF_SC).\ngeneralize (@hb_trans G); basic_solver 21.\nsin_rewrite (urr_f_sc WF WF_SC ACYC_EXT).\nrewrite !seqA.\ngeneralize (sc_trans WF_SC); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc ⨾ hb^? ⨾ hb ⨾ hb^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proofString":"generalize (@hb_trans G); basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc ⨾ hb^? ⨾ hb ⨾ sc ⨾ hb^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proofString":"rewrite (dom_l (wf_scD WF_SC)) at 2.\narewrite (⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc ⨾ hb^? ⨾ hb ⊆ urr l).\nrewrite (urr_alt l WF_SC).\ngeneralize (@hb_trans G); basic_solver 21.\nsin_rewrite (urr_f_sc WF WF_SC ACYC_EXT).\nrewrite !seqA.\ngeneralize (sc_trans WF_SC); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc ⨾ hb^? ⨾ hb ⨾ (⦗F ∩₁ Sc⦘ ⨾ sc) ⨾ hb^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proofString":"arewrite (⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc ⨾ hb^? ⨾ hb ⊆ urr l).\nrewrite (urr_alt l WF_SC).\ngeneralize (@hb_trans G); basic_solver 21.\nsin_rewrite (urr_f_sc WF WF_SC ACYC_EXT).\nrewrite !seqA.\ngeneralize (sc_trans WF_SC); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc ⨾ hb^? ⨾ hb ⊆ urr l.","proofString":"rewrite (urr_alt l WF_SC).\ngeneralize (@hb_trans G); basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc ⨾ hb^? ⨾ hb ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proofString":"generalize (@hb_trans G); basic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) : urr l ⨾ ⦗F ∩₁ Sc⦘ ⨾ sc ⨾ hb^? ⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proofString":"sin_rewrite (urr_f_sc WF WF_SC ACYC_EXT).\nrewrite !seqA.\ngeneralize (sc_trans WF_SC); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) : (⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^?) ⨾ sc ⨾ hb^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proofString":"rewrite !seqA.\ngeneralize (sc_trans WF_SC); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc^? ⨾ sc ⨾ hb^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proofString":"generalize (sc_trans WF_SC); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) (WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (H : transitive sc) : ⦗W_ l⦘ ⨾ rf^? ⨾ (hb ⨾ ⦗F ∩₁ Sc⦘)^? ⨾ sc ⨾ hb^?\n⊆ ⦗W_ l⦘ ⨾ rf^? ⨾ hb^? ⨾ sc^? ⨾ hb^?.","proofString":"basic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (x y : actid) (H : ((fun x0 y0 : actid => exists l : location, urr l x0 y0) ⨾ hb ⨾ sc^? ⨾ hb^?)\n  x y) : exists l : location, urr l x y.","proofString":"unfolder in *; desc.\nexists l.\napply (urr_hb_sc_hb WF WF_SC ACYC_EXT).\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (x y z : actid) (l : location) (H : urr l x z) (z0 : actid) (H0 : hb z z0) (z1 : actid) (H1 : z0 = z1 \\/ sc z0 z1) (H2 : z1 = y \\/ hb z1 y) : exists l0 : location, urr l0 x y.","proofString":"exists l.\napply (urr_hb_sc_hb WF WF_SC ACYC_EXT).\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (x y z : actid) (l : location) (H : urr l x z) (z0 : actid) (H0 : hb z z0) (z1 : actid) (H1 : z0 = z1 \\/ sc z0 z1) (H2 : z1 = y \\/ hb z1 y) : urr l x y.","proofString":"apply (urr_hb_sc_hb WF WF_SC ACYC_EXT).\nbasic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (ACYC_EXT : acyc_ext G sc) (x y z : actid) (l : location) (H : urr l x z) (z0 : actid) (H0 : hb z z0) (z1 : actid) (H1 : z0 = z1 \\/ sc z0 z1) (H2 : z1 = y \\/ hb z1 y) : (urr l ⨾ hb ⨾ sc^? ⨾ hb^?) x y.","proofString":"basic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (l : location) : irreflexive (urr l ⨾ hb).","proofString":"apply (urr_hb_irr WF WF_SC CSC COH ACYC_EXT)."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (l : location) : irreflexive (urr l ⨾ hb ⨾ sc ⨾ hb).","proofString":"arewrite (urr l ⨾ hb ⨾ sc ⊆ urr l).\ngeneralize (@urr_hb_sc_hb l WF WF_SC ACYC_EXT); basic_solver 21.\napply (urr_hb_irr WF WF_SC CSC COH ACYC_EXT)."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (l : location) : urr l ⨾ hb ⨾ sc ⊆ urr l.","proofString":"generalize (@urr_hb_sc_hb l WF WF_SC ACYC_EXT); basic_solver 21."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (l : location) : irreflexive (urr l ⨾ hb).","proofString":"apply (urr_hb_irr WF WF_SC CSC COH ACYC_EXT)."},{"statement":"(WF : Wf G) (WF_SC : wf_sc G sc) (CSC : coh_sc G sc) (COH : coherence G) (ACYC_EXT : acyc_ext G sc) (x z : actid) (l : location) (H : urr l x z) (z0 : actid) (H0 : hb z z0) (H1 : z0 = x \\/ (exists z1 : actid, sc z0 z1 /\\ hb z1 x)) : False.","proofString":"eapply urr_hb_sc_hb_irr; eauto.\nbasic_solver 21."}]}