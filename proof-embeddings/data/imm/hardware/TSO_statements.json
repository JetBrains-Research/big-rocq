{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/hardware/TSO.v","fileSamples":[{"statement":"(WF : Wf G) : ppo ⊆ ⦗E⦘ ⨾ ppo ⨾ ⦗E⦘.","proofString":"unfold ppo.\nrewrite (@wf_sbE G) at 1.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n⊆ ⦗E⦘\n  ⨾ (⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)) ⨾ ⦗E⦘.","proofString":"rewrite (@wf_sbE G) at 1.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗RW⦘ \\\n(fun x y : actid => is_w lab x /\\ is_r lab y)\n⊆ ⦗E⦘\n  ⨾ (⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)) ⨾ ⦗E⦘.","proofString":"basic_solver 42."},{"statement":"(WF : Wf G) : fence ⊆ ⦗E⦘ ⨾ fence ⨾ ⦗E⦘.","proofString":"unfold fence.\nrewrite (@wf_sbE G) at 1 2.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n⊆ ⦗E⦘ ⨾ (⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘) ⨾ ⦗E⦘.","proofString":"rewrite (@wf_sbE G) at 1 2.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗MFENCE⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗RW⦘\n⊆ ⦗E⦘ ⨾ (⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘) ⨾ ⦗E⦘.","proofString":"basic_solver 42."},{"statement":"(WF : Wf G) : implied_fence ⊆ ⦗E⦘ ⨾ implied_fence ⨾ ⦗E⦘.","proofString":"unfold implied_fence.\nrewrite (@wf_sbE G) at 1 2.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ sb ⨾ ⦗dom_rel rmw⦘ ∪ ⦗codom_rel rmw⦘ ⨾ sb ⨾ ⦗R⦘\n⊆ ⦗E⦘ ⨾ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel rmw⦘ ∪ ⦗codom_rel rmw⦘ ⨾ sb ⨾ ⦗R⦘) ⨾ ⦗E⦘.","proofString":"rewrite (@wf_sbE G) at 1 2.\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗W⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗dom_rel rmw⦘\n∪ ⦗codom_rel rmw⦘ ⨾ (⦗E⦘ ⨾ sb ⨾ ⦗E⦘) ⨾ ⦗R⦘\n⊆ ⦗E⦘ ⨾ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel rmw⦘ ∪ ⦗codom_rel rmw⦘ ⨾ sb ⨾ ⦗R⦘) ⨾ ⦗E⦘.","proofString":"basic_solver 42."},{"statement":"(WF : Wf G) : hb ⊆ ⦗RW⦘ ⨾ hb ⨾ ⦗RW⦘.","proofString":"apply dom_helper_3.\nunfold hb.\nunfold ppo, fence, implied_fence.\nrewrite (wf_rmwD WF) at 1 2.\nrewrite (wf_rfeD WF) at 1.\nrewrite (wf_coD WF) at 1.\nrewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : hb ⊆ RW × RW.","proofString":"unfold hb.\nunfold ppo, fence, implied_fence.\nrewrite (wf_rmwD WF) at 1 2.\nrewrite (wf_rfeD WF) at 1.\nrewrite (wf_coD WF) at 1.\nrewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : ppo ∪ fence ∪ implied_fence ∪ rfe ∪ co ∪ fr ⊆ RW × RW.","proofString":"unfold ppo, fence, implied_fence.\nrewrite (wf_rmwD WF) at 1 2.\nrewrite (wf_rfeD WF) at 1.\nrewrite (wf_coD WF) at 1.\nrewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel rmw⦘ ∪ ⦗codom_rel rmw⦘ ⨾ sb ⨾ ⦗R⦘) ∪ rfe ∪ co ∪ fr\n⊆ RW × RW.","proofString":"rewrite (wf_rmwD WF) at 1 2.\nrewrite (wf_rfeD WF) at 1.\nrewrite (wf_coD WF) at 1.\nrewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ rfe ∪ co ∪ fr ⊆ \nRW × RW.","proofString":"rewrite (wf_rfeD WF) at 1.\nrewrite (wf_coD WF) at 1.\nrewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘ ∪ co ∪ fr\n⊆ RW × RW.","proofString":"rewrite (wf_coD WF) at 1.\nrewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘\n∪ ⦗W⦘ ⨾ co ⨾ ⦗W⦘ ∪ fr ⊆ RW × RW.","proofString":"rewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘\n∪ ⦗W⦘ ⨾ co ⨾ ⦗W⦘ ∪ ⦗R⦘ ⨾ fr ⨾ ⦗W⦘ ⊆ RW × RW.","proofString":"generalize (R_ex_in_R lab).\nbasic_solver 42."},{"statement":"(WF : Wf G) : (fun a : actid => R_ex lab a) ⊆₁ R ->\n⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n∪ ⦗RW⦘ ⨾ sb ⨾ ⦗MFENCE⦘ ⨾ sb ⨾ ⦗RW⦘\n∪ (⦗W⦘ ⨾ sb ⨾ ⦗dom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘\n   ∪ ⦗codom_rel (⦗R⦘ ⨾ rmw ⨾ ⦗W⦘)⦘ ⨾ sb ⨾ ⦗R⦘) ∪ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘\n∪ ⦗W⦘ ⨾ co ⨾ ⦗W⦘ ∪ ⦗R⦘ ⨾ fr ⨾ ⦗W⦘ ⊆ RW × RW.","proofString":"basic_solver 42."},{"statement":"(WF : Wf G) : hb⁺ ⊆ ⦗RW⦘ ⨾ hb⁺ ⨾ ⦗RW⦘.","proofString":"apply dom_helper_3.\nrewrite (wf_hbD WF).\nrewrite inclusion_ct_seq_eqv_l.\nrewrite inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(WF : Wf G) : hb⁺ ⊆ RW × RW.","proofString":"rewrite (wf_hbD WF).\nrewrite inclusion_ct_seq_eqv_l.\nrewrite inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(WF : Wf G) : (⦗RW⦘ ⨾ hb ⨾ ⦗RW⦘)⁺ ⊆ RW × RW.","proofString":"rewrite inclusion_ct_seq_eqv_l.\nrewrite inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ (hb ⨾ ⦗RW⦘)⁺ ⊆ RW × RW.","proofString":"rewrite inclusion_ct_seq_eqv_r.\nbasic_solver."},{"statement":"(WF : Wf G) : ⦗RW⦘ ⨾ hb⁺ ⨾ ⦗RW⦘ ⊆ RW × RW.","proofString":"basic_solver."},{"statement":"⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n≡ ⦗R⦘ ⨾ sb ⨾ ⦗RW⦘ ∪ ⦗W⦘ ⨾ sb ⨾ ⦗W⦘.","proofString":"split.\nby apply inclusion_minus_l; basic_solver 12.\nby unfolder; ins; desf; splits; eauto 10; intro; type_solver."},{"statement":"⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y)\n⊆ ⦗R⦘ ⨾ sb ⨾ ⦗RW⦘ ∪ ⦗W⦘ ⨾ sb ⨾ ⦗W⦘.","proofString":"by apply inclusion_minus_l; basic_solver 12."},{"statement":"⦗R⦘ ⨾ sb ⨾ ⦗RW⦘ ∪ ⦗W⦘ ⨾ sb ⨾ ⦗W⦘\n⊆ ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y).","proofString":"by unfolder; ins; desf; splits; eauto 10; intro; type_solver."},{"statement":"(A : Type) (r r' : relation A) : r ⊆ r ∩ r' ∪ r \\ r'.","proofString":"red.\nintros x y Rxy.\ndestruct (classic (r' x y)); basic_solver."},{"statement":"(A : Type) (r r' : relation A) : forall x y : A, r x y -> (r ∩ r' ∪ r \\ r') x y.","proofString":"intros x y Rxy.\ndestruct (classic (r' x y)); basic_solver."},{"statement":"(A : Type) (r r' : relation A) (x y : A) (Rxy : r x y) : (r ∩ r' ∪ r \\ r') x y.","proofString":"destruct (classic (r' x y)); basic_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : acyclic (sb ∪ rfi ∪ rfe).","proofString":"rewrite union_absorb_r with (r := rfi); [| unfold \"rfi\"; basic_solver].\napply acyclic_utt.\nby apply sb_trans.\napply transitiveI.\nrewrite wf_rfeD; auto.\ntype_solver.\nsplits.\nby apply sb_irr.\nrewrite rfe_in_rf.\nby apply rf_irr.\nrewrite wf_rfeD; [| done].\ndo 2 rewrite <- seqA.\nrewrite acyclic_rotl.\ncdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : acyclic (sb ∪ rfe).","proofString":"apply acyclic_utt.\nby apply sb_trans.\napply transitiveI.\nrewrite wf_rfeD; auto.\ntype_solver.\nsplits.\nby apply sb_irr.\nrewrite rfe_in_rf.\nby apply rf_irr.\nrewrite wf_rfeD; [| done].\ndo 2 rewrite <- seqA.\nrewrite acyclic_rotl.\ncdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : transitive sb.","proofString":"by apply sb_trans."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : transitive rfe.","proofString":"apply transitiveI.\nrewrite wf_rfeD; auto.\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : rfe ⨾ rfe ⊆ rfe.","proofString":"rewrite wf_rfeD; auto.\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : (⦗W⦘ ⨾ rfe ⨾ ⦗R⦘) ⨾ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘ ⊆ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘.","proofString":"type_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : irreflexive sb /\\ irreflexive rfe /\\ acyclic (sb ⨾ rfe).","proofString":"splits.\nby apply sb_irr.\nrewrite rfe_in_rf.\nby apply rf_irr.\nrewrite wf_rfeD; [| done].\ndo 2 rewrite <- seqA.\nrewrite acyclic_rotl.\ncdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : irreflexive sb.","proofString":"by apply sb_irr."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : irreflexive rfe.","proofString":"rewrite rfe_in_rf.\nby apply rf_irr."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : irreflexive rf.","proofString":"by apply rf_irr."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : acyclic (sb ⨾ rfe).","proofString":"rewrite wf_rfeD; [| done].\ndo 2 rewrite <- seqA.\nrewrite acyclic_rotl.\ncdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : acyclic (sb ⨾ ⦗W⦘ ⨾ rfe ⨾ ⦗R⦘).","proofString":"do 2 rewrite <- seqA.\nrewrite acyclic_rotl.\ncdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : acyclic (((sb ⨾ ⦗W⦘) ⨾ rfe) ⨾ ⦗R⦘).","proofString":"rewrite acyclic_rotl.\ncdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) : acyclic (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe).","proofString":"cdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : acyclic hb) : acyclic (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe).","proofString":"red.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : acyclic hb) : irreflexive (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺.","proofString":"red in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : irreflexive (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺.","proofString":"eapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : Basics.flip inclusion hb⁺ (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺.","proofString":"red.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺ ⊆ hb⁺.","proofString":"rewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : (⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe)⁺ ⊆ (hb⁺)⁺.","proofString":"apply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : ⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe ⊆ hb⁺.","proofString":"rewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : ⦗R⦘ ⨾ (sb ⨾ ⦗W⦘) ⨾ rfe ⊆ hb⁺ ⨾ hb.","proofString":"rewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : (⦗R⦘ ⨾ sb ⨾ ⦗W⦘) ⨾ rfe ⊆ hb⁺ ⨾ hb.","proofString":"apply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : ⦗R⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ hb⁺.","proofString":"rewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : ⦗R⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ hb.","proofString":"repeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : ⦗R⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ ppo.","proofString":"unfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : ⦗R⦘ ⨾ sb ⨾ ⦗W⦘\n⊆ ⦗RW⦘ ⨾ sb ⨾ ⦗RW⦘ \\ (fun x y : actid => is_w lab x /\\ is_r lab y).","proofString":"unfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) : forall x y : actid,\nis_r lab x /\\ sb x y /\\ is_w lab y ->\n((is_r lab x \\/ is_w lab x) /\\ sb x y /\\ (is_r lab y \\/ is_w lab y)) /\\\n~ (is_w lab x /\\ is_r lab y).","proofString":"ins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) (x y : actid) (H : is_r lab x /\\ sb x y /\\ is_w lab y) : ((is_r lab x \\/ is_w lab x) /\\ sb x y /\\ (is_r lab y \\/ is_w lab y)) /\\\n~ (is_w lab x /\\ is_r lab y).","proofString":"desc.\nsplits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) (x y : actid) (H : is_r lab x) (H0 : sb x y) (H1 : is_w lab y) : ((is_r lab x \\/ is_w lab x) /\\ sb x y /\\ (is_r lab y \\/ is_w lab y)) /\\\n~ (is_w lab x /\\ is_r lab y).","proofString":"splits; vauto.\nintros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) (x y : actid) (H : is_r lab x) (H0 : sb x y) (H1 : is_w lab y) : ~ (is_w lab x /\\ is_r lab y).","proofString":"intros [? ?].\ntype_solver."},{"statement":"(WF : Wf G) (TSO : TSOConsistent) (WF0 : Wf G) (COMP : complete G) (SC_PER_LOC : sc_per_loc G) (ATOMICITY : rmw_atomicity G) (GHB : irreflexive hb⁺) (x y : actid) (H : is_r lab x) (H0 : sb x y) (H1 : is_w lab y) (H2 : is_w lab x) (H3 : is_r lab y) : False.","proofString":"type_solver."}]}