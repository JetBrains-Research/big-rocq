[{"statement":"Lemma sub_Acq : Acq' ≡₁ Acq.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_Rel : Rel' ≡₁ Rel.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_AcqRel : Acq/Rel' ≡₁ Acq/Rel.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_Sc : Sc' ≡₁ Sc.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_W : W' ≡₁ W.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_R : R' ≡₁ R.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_F : F' ≡₁ F.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_W_ l : W'_ l ≡₁ W_ l.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_R_ex : R_ex' ≡₁ R_ex.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_xacq : is_xacq lab' ≡₁ is_xacq lab.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_same_loc : same_loc' ≡ same_loc.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_loc : loc' = loc.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_val : val' = val.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_E_in : E' ⊆₁ E.","proof":"rewrite (sub_E SUB); basic_solver.\n"},{"statement":"Lemma sub_data_in : data' ⊆ data.","proof":"rewrite sub_data; basic_solver.\n"},{"statement":"Lemma sub_addr_in : addr' ⊆ addr.","proof":"rewrite sub_addr; basic_solver.\n"},{"statement":"Lemma sub_ctrl_in : ctrl' ⊆ ctrl.","proof":"rewrite sub_ctrl; basic_solver.\n"},{"statement":"Lemma sub_frmw_in : rmw_dep' ⊆ rmw_dep.","proof":"rewrite sub_frmw; basic_solver.\n"},{"statement":"Lemma sub_rmw_in : rmw' ⊆ rmw.","proof":"rewrite sub_rmw; basic_solver.\n"},{"statement":"Lemma sub_rf_in : rf' ⊆ rf.","proof":"rewrite sub_rf; basic_solver.\n"},{"statement":"Lemma sub_co_in : co' ⊆ co.","proof":"rewrite sub_co; basic_solver.\n"},{"statement":"Lemma sub_sc_in : sc' ⊆ sc.","proof":"rewrite sub_sc; basic_solver.\n"},{"statement":"Lemma sub_W_ex_in : W_ex' ⊆₁ W_ex.","proof":"unfold Execution.W_ex; rewrite sub_rmw_in; basic_solver.\n"},{"statement":"Lemma sub_W_ex_acq_in : W_ex_acq' ⊆₁ W_ex_acq.","proof":"by rewrite sub_W_ex_in, sub_xacq.\n"},{"statement":"Lemma sub_sb : sb' ≡ ⦗E'⦘ ⨾  sb ⨾ ⦗E'⦘.","proof":"unfold Execution.sb; generalize sub_E_in; basic_solver 12.\n"},{"statement":"Lemma sub_sb_in : sb' ⊆ sb.","proof":"rewrite sub_sb; basic_solver.\n"},{"statement":"Lemma sub_WF : Wf G'.","proof":"constructor.\n- by ins; desf; apply (wf_index WF); splits; eauto; apply sub_E_in.\n- by rewrite (sub_data SUB), data_in_sb, sub_sb.\n- apply dom_helper_3; rewrite (sub_data SUB), wf_dataD, sub_R, sub_W; basic_solver.\n- by rewrite (sub_addr SUB), addr_in_sb, sub_sb.\n- apply dom_helper_3; rewrite (sub_addr SUB), wf_addrD, sub_R, sub_W; basic_solver 12.\n- by rewrite (sub_ctrl SUB), ctrl_in_sb, sub_sb.\n- rewrite (sub_ctrl SUB), wf_ctrlD, sub_R; basic_solver 12.\n- rewrite (sub_ctrl SUB), sub_sb.\ngeneralize (ctrl_sb WF); basic_solver 12.\n- apply dom_helper_3; rewrite (sub_rmw SUB), wf_rmwD, sub_R, sub_W; basic_solver 12.\n- rewrite sub_rmw_in, sub_same_loc; apply WF.\n- rewrite (sub_rmw SUB).\nunfolder; ins; desf; splits.\napply sub_sb; generalize (rmw_in_sb WF); basic_solver 12.\nins; eapply  (wf_rmwi WF); eauto; apply (sub_sb_in); edone.\n- apply dom_helper_3; rewrite (sub_rf SUB); basic_solver.\n- apply dom_helper_3; rewrite (sub_rf SUB), wf_rfD, sub_R, sub_W; basic_solver 12.\n- rewrite sub_rf_in, sub_same_loc; apply WF.\n- rewrite sub_val, sub_rf_in; apply WF.\n- rewrite sub_rf_in; apply WF.\n- apply dom_helper_3; rewrite (sub_co SUB); basic_solver 12.\n- apply dom_helper_3; rewrite (sub_co SUB), wf_coD, sub_W; basic_solver 12.\n- rewrite sub_co_in, sub_same_loc; apply WF.\n- rewrite (sub_co SUB), <- restr_relE; apply transitive_restr, WF.\n- intro ol.\nrewrite (sub_co SUB), sub_W.\nunfolder; ins; eapply (wf_co_total WF) in NEQ.\nby desf; eauto.\nby unfolder; desf; splits; auto; apply sub_E_in.\nby unfolder; desf; splits; auto; [apply sub_E_in| rewrite <- sub_loc].\n- rewrite sub_co_in; apply WF.\n- ins; desf.\napply INIT; unfolder; splits; eauto.\napply (wf_init WF); splits; exists b; splits; eauto.\nby apply sub_E_in.\ngeneralize sub_loc; congruence.\n- ins; rewrite (sub_lab SUB); apply WF.\n- by rewrite (sub_frmw SUB), rmw_dep_in_sb, sub_sb.\n- apply dom_helper_3; rewrite (sub_frmw SUB), wf_rmw_depD, sub_R, sub_R_ex; basic_solver 12.\n- ins.\napply sub_threads; auto.\napply WF.\napply sub_E; auto.\n"},{"statement":"Lemma sub_fwbob : fwbob' ≡ ⦗E'⦘ ⨾ fwbob ⨾ ⦗E'⦘.","proof":"unfold imm_bob.fwbob; rewrite sub_Rel, sub_AcqRel, sub_W, sub_F, sub_sb, sub_same_loc.\nbasic_solver 21.\n"},{"statement":"Lemma sub_fwbob_in : fwbob' ⊆ fwbob .","proof":"rewrite sub_fwbob; basic_solver.\n"},{"statement":"Lemma sub_bob : bob' ≡ ⦗E'⦘ ⨾ bob ⨾ ⦗E'⦘.","proof":"unfold imm_bob.bob; rewrite sub_Acq, sub_fwbob, sub_R, sub_sb.\nbasic_solver 21.\n"},{"statement":"Lemma sub_bob_in : bob' ⊆ bob .","proof":"rewrite sub_bob; basic_solver.\n"},{"statement":"Lemma sub_rfi : rfi' ≡ ⦗E'⦘ ⨾ rfi ⨾ ⦗E'⦘.","proof":"unfold Execution.rfi; rewrite sub_sb, sub_rf; basic_solver.\n"},{"statement":"Lemma sub_rfi_in : rfi' ⊆ rfi.","proof":"rewrite sub_rfi; basic_solver.\n"},{"statement":"Lemma sub_rfe : rfe' ≡ ⦗E'⦘ ⨾ rfe ⨾ ⦗E'⦘.","proof":"unfold Execution.rfe; rewrite sub_sb, (sub_rf SUB).\nsplit; [basic_solver 15 | unfolder; ins; desf; splits; eauto; intro; desf].\n"},{"statement":"Lemma sub_rfe_in : rfe' ⊆ rfe.","proof":"rewrite sub_rfe; basic_solver.\n"},{"statement":"Lemma sub_coe : coe' ≡ ⦗E'⦘ ⨾ coe ⨾ ⦗E'⦘.","proof":"unfold Execution.coe; rewrite sub_sb, (sub_co SUB).\nsplit; [basic_solver 15 | unfolder; ins; desf; splits; eauto; intro; desf].\n"},{"statement":"Lemma sub_coe_in : coe' ⊆ coe.","proof":"rewrite sub_coe; basic_solver.\n"},{"statement":"Lemma sub_detour_in : detour' ⊆ detour.","proof":"unfold Execution.detour.\nrewrite sub_sb, sub_coe, sub_rfe_in.\nbasic_solver 21.\n"},{"statement":"Lemma sub_same_loc_in : same_loc' ⊆ same_loc.","proof":"by rewrite (sub_lab SUB).\n"},{"statement":"Lemma sub_ppo_in : ppo' ⊆ ppo.","proof":"unfold imm_s_ppo.ppo.\nrewrite sub_W, sub_R.\nhahn_frame; apply inclusion_t_t.\napply union_mori.\n{\nrewrite sub_sb_in, sub_rfi_in.\nrewrite sub_data_in, sub_ctrl_in, sub_addr_in, sub_frmw_in.\nrewrite sub_rmw_in at 1.\nbasic_solver 12.\n}\nrewrite (dom_l (@wf_sbE G')).\nrewrite sub_R_ex, sub_sb_in.\nunfolder.\nins.\ndesf.\n"},{"statement":"Lemma sub_fr_in : fr' ⊆ fr.","proof":"unfold Execution.fr.\nby rewrite sub_rf_in, sub_co_in.\n"},{"statement":"Lemma sub_fre_in : fre' ⊆ fre.","proof":"rewrite (wf_freE sub_WF).\nie_unfolder.\nrewrite sub_fr_in, sub_sb.\nbasic_solver 21.\n"},{"statement":"Lemma sub_eco_in : eco' ⊆ eco.","proof":"unfold Execution_eco.eco.\nrewrite sub_rf_in, sub_co_in, sub_fr_in.\nbasic_solver 21.\n"},{"statement":"Lemma sub_rs_in : rs' ⊆ rs.","proof":"unfold imm_s_hb.rs.\nby rewrite sub_rf_in, sub_rmw_in, sub_sb_in, sub_same_loc, sub_W.\n"},{"statement":"Lemma sub_release_in : release' ⊆ release.","proof":"unfold imm_s_hb.release.\nby rewrite sub_sb_in, sub_rs_in, sub_F, sub_Rel.\n"},{"statement":"Lemma sub_sw_in : sw' ⊆ sw.","proof":"unfold imm_s_hb.sw.\nby rewrite sub_sb_in, sub_release_in, sub_rf_in, sub_F, sub_Acq.\n"},{"statement":"Lemma sub_hb_in : hb' ⊆ hb.","proof":"unfold imm_s_hb.hb.\nby rewrite sub_sb_in, sub_sw_in.\n"},{"statement":"Lemma sub_ar_int_in : ar_int' ⊆ ar_int.","proof":"unfold imm_s_ppo.ar_int.\nrewrite sub_bob_in, sub_ppo_in, sub_detour_in, sub_sb_in.\nrewrite sub_W_ex_acq_in, sub_W.\nrewrite sub_W_ex_in, sub_rfi_in.\nrewrite sub_R, sub_Acq.\ndone.\n"},{"statement":"Lemma sub_ar_in : ar' sc' ⊆ ar sc.","proof":"unfold imm_s.ar.\nby rewrite sub_sc_in, sub_rfe_in, sub_ar_int_in.\n"},{"statement":"Lemma sub_urr_in l : urr' l ⊆ urr l.","proof":"unfold CombRelations.urr.\nby rewrite sub_rf_in, sub_hb_in, (sub_W_ l), sub_F, sub_Sc, sub_sc_in.\n"},{"statement":"Lemma sub_furr_in : furr' ⊆ furr.","proof":"unfold CombRelations.furr.\nunfolder; ins; desf; eexists; apply sub_urr_in; eauto.\n"},{"statement":"Lemma sub_is_ta_propagate_to_G :\n  is_ta_propagate_to_G G' ≡₁ is_ta_propagate_to_G G.","proof":"unfold is_ta_propagate_to_G.\nnow rewrite sub_threads.\n"},{"statement":"Lemma sub_SB : SB G' sc' ⊆ SB G sc.","proof":"unfold SB, RF, sb; ins.\nhahn_frame; apply map_rel_mori; auto.\ntry apply clos_trans_mori.\nrewrite sub_sc, sub_E; auto using SUB.\nclear; basic_solver.\n"},{"statement":"Lemma sub_RF : RF G' ⊆ RF G.","proof":"unfold SB, RF, sb; ins.\nhahn_frame; apply map_rel_mori; auto.\ntry apply clos_trans_mori.\nrewrite sub_rf, sub_W; auto using SUB.\nclear; basic_solver.\n"},{"statement":"Lemma sub_FWBOB : FWBOB G' ⊆ FWBOB G.","proof":"unfold FWBOB; ins.\nrewrite sub_fwbob; eauto using SUB; ins.\nrewrite sub_W; eauto using SUB; ins.\nclear; basic_solver 20.\n"},{"statement":"Lemma sub_AR : AR G' sc' ⊆ AR G sc.","proof":"unfold AR; ins.\nrewrite sub_ar_in, sub_ppo_in, sub_rf, sub_W; eauto using SUB.\nrewrite sub_same_loc; eauto using SUB.\nrepeat (apply seq_mori; try easy).\napply map_rel_mori; auto.\nrepeat (apply seq_mori; try easy).\napply clos_trans_mori.\nclear; basic_solver 10.\n"},{"statement":"Lemma sub_IPROP : IPROP G' ⊆ IPROP G.","proof":"unfold IPROP.\nrewrite sub_is_ta_propagate_to_G.\nnow rewrite sub_W; eauto using SUB.\n"},{"statement":"Lemma sub_PROP : PROP G' sc' ⊆ PROP G sc.","proof":"unfold PROP.\nrewrite sub_is_ta_propagate_to_G.\nrepeat (apply seq_mori; try easy).\napply inter_rel_mori; try easy.\napply map_rel_mori; auto.\nby rewrite sub_furr_in, sub_co_in, sub_fr_in, sub_W.\n"},{"statement":"Lemma sub_iord : iord G' sc' ⊆ iord G sc.","proof":"unfold iord.\napply restr_rel_mori.\n{\nrewrite sub_E; eauto using SUB.\n}\nrewrite sub_SB, sub_RF, sub_FWBOB, sub_AR, sub_IPROP, sub_PROP.\neasy.\n"},{"statement":"Lemma sub_WF_SC : wf_sc G' sc'.","proof":"constructor.\n- apply dom_helper_3; rewrite (sub_sc SUB); basic_solver.\n- apply dom_helper_3; rewrite (sub_sc SUB), (wf_scD WF_SC).\nrewrite sub_F, sub_Sc; basic_solver 12.\n- rewrite (sub_sc SUB), <- restr_relE; apply transitive_restr, WF_SC.\n- rewrite (sub_sc SUB), sub_F, sub_Sc.\nunfolder; ins; eapply (wf_sc_total WF_SC) in NEQ.\nby desf; eauto.\nby unfolder; desf; splits; auto; apply sub_E_in.\nby unfolder; desf; splits; auto; apply sub_E_in.\n- rewrite sub_sc_in; apply WF_SC.\n"},{"statement":"Lemma sub_coherence (COH: coherence G) : coherence G'.","proof":"red; rewrite sub_hb_in, sub_eco_in; apply COH.\n"},{"statement":"Lemma sub_coh_sc (CSC: coh_sc G sc) : coh_sc G' sc'.","proof":"red; rewrite sub_hb_in, sub_eco_in, sub_sc_in; apply CSC.\n"},{"statement":"Lemma sub_acyc_ext (ACYC: acyc_ext G sc) : acyc_ext G' sc'.","proof":"red; rewrite sub_ar_in; apply ACYC.\n"},{"statement":"Lemma sub_rmw_atomicity (AT: rmw_atomicity G) : rmw_atomicity G'.","proof":"red; rewrite sub_rmw_in, sub_coe_in, sub_fre_in; apply AT.\n"},{"statement":"Lemma sub_detour (RF_A : dom_rel (rf ⨾ ⦗ E' ⦘) ⊆₁ E') : detour' ≡ ⦗E'⦘ ⨾ detour ⨾ ⦗E'⦘.","proof":"unfold Execution.detour, Execution.rfe.\nrewrite sub_sb, sub_coe, (sub_rf SUB).\nunfolder in RF_A; unfolder; splits; ins; desf; eauto 20.\nsplits; eauto 20.\nexists z; splits; eauto 20.\nexists z; splits; eauto 20.\nintro; desf.\n"},{"statement":"Lemma sub_fr (RF_A : dom_rel (rf ⨾ ⦗ E' ⦘) ⊆₁ E') : fr' ≡ ⦗E'⦘ ⨾ fr ⨾ ⦗E'⦘.","proof":"unfold Execution.fr.\nrewrite (sub_rf SUB), (sub_co SUB).\nunfolder in RF_A; basic_solver 21.\n"},{"statement":"Lemma sub_eco (RF_A : dom_rel (rf ⨾ ⦗ E' ⦘) ⊆₁ E')  : eco' ≡ ⦗E'⦘ ⨾ eco ⨾ ⦗E'⦘.","proof":"unfold Execution_eco.eco.\nrewrite (sub_rf SUB), (sub_co SUB), (sub_fr RF_A).\nunfolder in RF_A; basic_solver 21.\n"},{"statement":"Lemma sub_comp (RF_A : dom_rel (rf ⨾ ⦗ E' ⦘) ⊆₁ E') (COMP: complete G) : complete G'.","proof":"red; rewrite sub_R, (sub_rf SUB).\nunfolder; ins.\nedestruct (COMP x); eauto.\n{\ngeneralize sub_E_in; basic_solver.\n}\nunfolder; ins; desf.\ngeneralize (sub_E SUB).\nrevert RF_A.\nbasic_solver 21.\n"},{"statement":"Lemma sub_imm_consistent (RF_A : dom_rel (rf ⨾ ⦗ E' ⦘) ⊆₁ E')\n  (IMMCON: imm_consistent G sc) : imm_consistent G' sc'.","proof":"cdes IMMCON; red.\nsplits; eauto using sub_comp, sub_WF_SC, sub_coh_sc, sub_coherence, sub_acyc_ext, sub_rmw_atomicity.\n"},{"statement":"Lemma restrict_E G D (IN: D ⊆₁ (acts_set G)) :\n (acts_set (restrict G D)) ≡₁ D.","proof":"unfolder in *; split; ins; desf; splits; eauto.\n{\napply H.\n}\nsplit; auto.\n"},{"statement":"Lemma restrict_sub G sc sc' D (SC: sc' ≡ ⦗D⦘ ⨾ sc ⨾ ⦗D⦘) (IN: D ⊆₁ (acts_set G)) : \n sub_execution G (restrict G D) sc sc'.","proof":"by constructor; ins; rewrite (@restrict_E G D IN).\n"},{"statement":"Lemma events_separation G:\n  acts_set G ≡₁ ⋃₁ t, acts_set (restrict G (Tid_ t)).","proof":"unfold restrict.\nsimpl.\nrewrite set_bunion_inter_compat_r, set_interC, <- set_bunion_inter_compat_l.\napply set_bunion_separation.\n"},{"statement":"Lemma fin_exec_bounded_threads G b\n      (TB: threads_bound G b)\n      (FIN_B: forall t (LTB: BinPos.Pos.lt t b), fin_exec (restrict G (Tid_ t))):\n  fin_exec G.","proof":"red.\nrewrite events_separation, <- set_bunion_minus_compat_r.\nrewrite set_full_split with (S := fun t => BinPos.Pos.lt t b).\nrewrite set_bunion_union_l.\napply set_finite_union.\nsplit.\n2: {\nexists nil.\nunfold restrict.\nsimpl.\nunfolder.\nins.\ndesc.\nred in TB.\napply TB in IN2.\ncongruence.\n}\napply set_finite_bunion; [by apply BinPos_lt_fin| done].\n"},{"statement":"Lemma fin_exec_fin_threads_restrict G\n      (ACTS : forall e : actid, acts_set G e -> threads_set G (tid e))\n      (FIN_THREADS: fin_threads G)\n      (FIN_B: forall t (LTB: threads_set G t), fin_exec (restrict G (Tid_ t))):\n  fin_exec G.","proof":"apply fin_threads_bound in FIN_THREADS; auto.\ndesf.\neapply fin_exec_bounded_threads; eauto.\nins.\ndestruct (classic (threads_set G t)) as [|NTS]; intuition.\nred.\nexists nil.\nins.\nexfalso.\napply NTS.\nunfolder in IN.\ndesf.\nnow apply ACTS.\n"},{"statement":"Lemma restrict_fair G (S: actid -> Prop) (FAIR: mem_fair G):\n  mem_fair (restrict G S).","proof":"unfold restrict, mem_fair, fr.\nsimpl.\ndestruct FAIR as [FSco FSfr].\nsplit.\n{\neapply fsupp_mori; [| by apply FSco].\nred.\nbasic_solver.\n}\neapply fsupp_mori; [| by apply FSfr].\nred.\nunfold fr.\nbasic_solver.\n"},{"statement":"Lemma restrict_threads_bound (G: execution) (b: thread_id) (S: actid -> Prop)\n      (BOUND: threads_bound G b):\n  threads_bound (restrict G S) b.","proof":"unfold restrict, threads_bound.\nsimpl.\nins.\napply BOUND, Ge.\n"}]