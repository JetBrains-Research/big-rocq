{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/Prop/Relative.v","fileSamples":[{"statement":"(x b eps : R) (Beps : (Rabs eps <= b)%R) (Heps : round beta fexp rnd x = (x * (1 + eps))%R) : (Rabs (round beta fexp rnd x - x) <= b * Rabs x)%R.","proofString":"assert (Pb : (0 <= b)%R); [now revert Beps; apply Rle_trans, Rabs_pos|].\nrewrite Heps; replace (_ - _)%R with (eps * x)%R; [|ring].\nnow rewrite Rabs_mult; apply Rmult_le_compat_r; [apply Rabs_pos|]."},{"statement":"(x b eps : R) (Beps : (Rabs eps <= b)%R) (Heps : round beta fexp rnd x = (x * (1 + eps))%R) (Pb : (0 <= b)%R) : (Rabs (round beta fexp rnd x - x) <= b * Rabs x)%R.","proofString":"rewrite Heps; replace (_ - _)%R with (eps * x)%R; [|ring].\nnow rewrite Rabs_mult; apply Rmult_le_compat_r; [apply Rabs_pos|]."},{"statement":"(x b eps : R) (Beps : (Rabs eps <= b)%R) (Heps : round beta fexp rnd x = (x * (1 + eps))%R) (Pb : (0 <= b)%R) : (Rabs (eps * x) <= b * Rabs x)%R.","proofString":"now rewrite Rabs_mult; apply Rmult_le_compat_r; [apply Rabs_pos|]."},{"statement":"(x b : R) : (exists eps : R,\n   (Rabs eps <= b)%R /\\ x = (round beta fexp rnd x * (1 + eps))%R) ->\n(Rabs (round beta fexp rnd x - x) <= b * Rabs (round beta fexp rnd x))%R.","proofString":"set (rx := round _ _ _ _).\nintros (eps, (Beps, Heps)).\nassert (Pb : (0 <= b)%R); [now revert Beps; apply Rle_trans, Rabs_pos|].\nrewrite Heps; replace (_ - _)%R with (- (eps * rx))%R; [|ring].\nnow rewrite Rabs_Ropp, Rabs_mult; apply Rmult_le_compat_r; [apply Rabs_pos|]."},{"statement":"(x b : R) (rx : R) : (exists eps : R, (Rabs eps <= b)%R /\\ x = (rx * (1 + eps))%R) ->\n(Rabs (rx - x) <= b * Rabs rx)%R.","proofString":"intros (eps, (Beps, Heps)).\nassert (Pb : (0 <= b)%R); [now revert Beps; apply Rle_trans, Rabs_pos|].\nrewrite Heps; replace (_ - _)%R with (- (eps * rx))%R; [|ring].\nnow rewrite Rabs_Ropp, Rabs_mult; apply Rmult_le_compat_r; [apply Rabs_pos|]."},{"statement":"(x b : R) (rx : R) (eps : R) (Beps : (Rabs eps <= b)%R) (Heps : x = (rx * (1 + eps))%R) : (Rabs (rx - x) <= b * Rabs rx)%R.","proofString":"assert (Pb : (0 <= b)%R); [now revert Beps; apply Rle_trans, Rabs_pos|].\nrewrite Heps; replace (_ - _)%R with (- (eps * rx))%R; [|ring].\nnow rewrite Rabs_Ropp, Rabs_mult; apply Rmult_le_compat_r; [apply Rabs_pos|]."},{"statement":"(x b : R) (rx : R) (eps : R) (Beps : (Rabs eps <= b)%R) (Heps : x = (rx * (1 + eps))%R) (Pb : (0 <= b)%R) : (Rabs (rx - x) <= b * Rabs rx)%R.","proofString":"rewrite Heps; replace (_ - _)%R with (- (eps * rx))%R; [|ring].\nnow rewrite Rabs_Ropp, Rabs_mult; apply Rmult_le_compat_r; [apply Rabs_pos|]."},{"statement":"(x b : R) (rx : R) (eps : R) (Beps : (Rabs eps <= b)%R) (Heps : x = (rx * (1 + eps))%R) (Pb : (0 <= b)%R) : (Rabs (- (eps * rx)) <= b * Rabs rx)%R.","proofString":"now rewrite Rabs_Ropp, Rabs_mult; apply Rmult_le_compat_r; [apply Rabs_pos|]."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (Rabs (round beta fexp rnd x - x) < bpow (- p + 1) * Rabs x)%R.","proofString":"assert (Hx': (x <> 0)%R).\nintros T; contradict Hx; rewrite T, Rabs_R0.\napply Rlt_not_le, bpow_gt_0.\napply Rlt_le_trans with (ulp beta fexp x)%R.\nnow apply error_lt_ulp...\nrewrite ulp_neq_0; trivial.\nunfold cexp.\ndestruct (mag beta x) as (ex, He).\nsimpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : x <> 0%R.","proofString":"intros T; contradict Hx; rewrite T, Rabs_R0.\napply Rlt_not_le, bpow_gt_0."},{"statement":"(x : R) (T : x = 0%R) : ~ (bpow emin <= 0)%R.","proofString":"apply Rlt_not_le, bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) : (Rabs (round beta fexp rnd x - x) < bpow (- p + 1) * Rabs x)%R.","proofString":"apply Rlt_le_trans with (ulp beta fexp x)%R.\nnow apply error_lt_ulp...\nrewrite ulp_neq_0; trivial.\nunfold cexp.\ndestruct (mag beta x) as (ex, He).\nsimpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) : (Rabs (round beta fexp rnd x - x) < ulp beta fexp x)%R.","proofString":"now apply error_lt_ulp..."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) : (ulp beta fexp x <= bpow (- p + 1) * Rabs x)%R.","proofString":"rewrite ulp_neq_0; trivial.\nunfold cexp.\ndestruct (mag beta x) as (ex, He).\nsimpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) : (bpow (cexp beta fexp x) <= bpow (- p + 1) * Rabs x)%R.","proofString":"unfold cexp.\ndestruct (mag beta x) as (ex, He).\nsimpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) : (bpow (fexp (mag beta x)) <= bpow (- p + 1) * Rabs x)%R.","proofString":"destruct (mag beta x) as (ex, He).\nsimpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (fexp (Build_mag_prop beta x ex He)) <= bpow (- p + 1) * Rabs x)%R.","proofString":"simpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (fexp ex) <= bpow (- p + 1) * Rabs x)%R.","proofString":"specialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (fexp ex) <= bpow (- p + 1) * Rabs x)%R.","proofString":"apply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (fexp ex) <= bpow (- p + 1) * bpow (ex - 1))%R.","proofString":"rewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (fexp ex) <= bpow (- p + 1 + (ex - 1)))%R.","proofString":"apply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (fexp ex <= - p + 1 + (ex - 1))%Z.","proofString":"assert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (emin < ex)%Z.","proofString":"apply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow emin < bpow ex)%R.","proofString":"apply Rle_lt_trans with (2 := proj2 He).\nexact Hx."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow emin <= Rabs x)%R.","proofString":"exact Hx."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : (emin < ex)%Z) : (fexp ex <= - p + 1 + (ex - 1))%Z.","proofString":"generalize (Hmin ex).\nlia."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : (emin < ex)%Z) : ((emin < ex)%Z -> (p <= ex - fexp ex)%Z) -> (fexp ex <= - p + 1 + (ex - 1))%Z.","proofString":"lia."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (- p + 1) * bpow (ex - 1) <= bpow (- p + 1) * Rabs x)%R.","proofString":"apply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 <= bpow (- p + 1))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1) <= Rabs x)%R.","proofString":"apply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (0 < bpow (- p + 1))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : x <> 0%R -> (Rabs (round beta fexp rnd x - x) < bpow (- p + 1) * Rabs x)%R.","proofString":"intros _.\nnow apply relative_error."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (Rabs (round beta fexp rnd x - x) < bpow (- p + 1) * Rabs x)%R.","proofString":"now apply relative_error."},{"statement":"(m : Z) (x : R) : (0 < bpow (- p + 1))%R.","proofString":"apply bpow_gt_0."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) : x <> 0%R.","proofString":"intros T; contradict Hx; rewrite T, Rabs_R0.\napply Rlt_not_le, bpow_gt_0."},{"statement":"(Hp : (0 < p)%Z) (x : R) (T : x = 0%R) : ~ (bpow emin <= 0)%R.","proofString":"apply Rlt_not_le, bpow_gt_0."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) : (Rabs (round beta fexp rnd x - x) < ulp beta fexp x)%R.","proofString":"now apply error_lt_ulp."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (emin < ex)%Z.","proofString":"apply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow emin < bpow ex)%R.","proofString":"apply Rle_lt_trans with (2 := proj2 He).\nexact Hx."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow emin <= Rabs x)%R.","proofString":"exact Hx."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He' : (emin < ex)%Z) : (bpow (fexp ex) <= bpow (- p + 1) * bpow (ex - 1))%R.","proofString":"rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He' : (emin < ex)%Z) : (bpow (fexp ex) <= bpow (- p + 1 + (ex - 1)))%R.","proofString":"apply bpow_le.\ngeneralize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He' : (emin < ex)%Z) : (fexp ex <= - p + 1 + (ex - 1))%Z.","proofString":"generalize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He' : (emin < ex)%Z) : ((emin < ex)%Z -> (p <= ex - fexp ex)%Z) -> (fexp ex <= - p + 1 + (ex - 1))%Z.","proofString":"lia."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He' : (emin < ex)%Z) : (0 <= bpow (- p + 1))%R.","proofString":"apply bpow_ge_0."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He' : (emin < ex)%Z) : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 <= x0)%R ->\n(bpow (ex - 1) <= x0 < bpow ex)%R ->\n(bpow (ex - 1) <= round beta fexp rnd0 x0)%R.","proofString":"clear rnd valid_rnd x Hx Hx' He.\nintros rnd valid_rnd x _ Hx.\nrewrite <- (round_generic beta fexp rnd (bpow (ex - 1))).\nnow apply round_le.\napply generic_format_bpow.\nring_simplify (ex - 1 + 1)%Z.\ngeneralize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (ex : Z) (He' : (emin < ex)%Z) (x : R) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (bpow (ex - 1) <= round beta fexp rnd x)%R.","proofString":"rewrite <- (round_generic beta fexp rnd (bpow (ex - 1))).\nnow apply round_le.\napply generic_format_bpow.\nring_simplify (ex - 1 + 1)%Z.\ngeneralize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (ex : Z) (He' : (emin < ex)%Z) (x : R) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (round beta fexp rnd (bpow (ex - 1)) <= round beta fexp rnd x)%R.","proofString":"now apply round_le."},{"statement":"(Hp : (0 < p)%Z) (ex : Z) (He' : (emin < ex)%Z) (x : R) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : generic_format beta fexp (bpow (ex - 1)).","proofString":"apply generic_format_bpow.\nring_simplify (ex - 1 + 1)%Z.\ngeneralize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (ex : Z) (He' : (emin < ex)%Z) (x : R) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (fexp (ex - 1 + 1) <= ex - 1)%Z.","proofString":"ring_simplify (ex - 1 + 1)%Z.\ngeneralize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (ex : Z) (He' : (emin < ex)%Z) (x : R) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (fexp ex <= ex - 1)%Z.","proofString":"generalize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (ex : Z) (He' : (emin < ex)%Z) (x : R) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : ((emin < ex)%Z -> (p <= ex - fexp ex)%Z) -> (fexp ex <= ex - 1)%Z.","proofString":"lia."},{"statement":"(Hp : (0 < p)%Z) (m : Z) (x : R) (Hx : x <> 0%R) : (0 < p)%Z.","proofString":"exact Hp."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (Rabs (round beta fexp (Znearest choice) x - x) <=\n / 2 * bpow (- p + 1) * Rabs x)%R.","proofString":"apply Rle_trans with (/2 * ulp beta fexp x)%R.\nnow apply error_le_half_ulp.\nrewrite Rmult_assoc.\napply Rmult_le_compat_l.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\nassert (Hx': (x <> 0)%R).\nintros H.\napply Rlt_not_le with (2 := Hx).\nrewrite H, Rabs_R0.\napply bpow_gt_0.\nrewrite ulp_neq_0; trivial.\nunfold cexp.\ndestruct (mag beta x) as (ex, He).\nsimpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (Rabs (round beta fexp (Znearest choice) x - x) <= / 2 * ulp beta fexp x)%R.","proofString":"now apply error_le_half_ulp."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (/ 2 * ulp beta fexp x <= / 2 * bpow (- p + 1) * Rabs x)%R.","proofString":"rewrite Rmult_assoc.\napply Rmult_le_compat_l.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\nassert (Hx': (x <> 0)%R).\nintros H.\napply Rlt_not_le with (2 := Hx).\nrewrite H, Rabs_R0.\napply bpow_gt_0.\nrewrite ulp_neq_0; trivial.\nunfold cexp.\ndestruct (mag beta x) as (ex, He).\nsimpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (/ 2 * ulp beta fexp x <= / 2 * (bpow (- p + 1) * Rabs x))%R.","proofString":"apply Rmult_le_compat_l.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\nassert (Hx': (x <> 0)%R).\nintros H.\napply Rlt_not_le with (2 := Hx).\nrewrite H, Rabs_R0.\napply bpow_gt_0.\nrewrite ulp_neq_0; trivial.\nunfold cexp.\ndestruct (mag beta x) as (ex, He).\nsimpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (0 <= / 2)%R.","proofString":"apply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (0 < / 2)%R.","proofString":"apply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (0 < 2)%R.","proofString":"now apply IZR_lt."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (ulp beta fexp x <= bpow (- p + 1) * Rabs x)%R.","proofString":"assert (Hx': (x <> 0)%R).\nintros H.\napply Rlt_not_le with (2 := Hx).\nrewrite H, Rabs_R0.\napply bpow_gt_0.\nrewrite ulp_neq_0; trivial.\nunfold cexp.\ndestruct (mag beta x) as (ex, He).\nsimpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : x <> 0%R.","proofString":"intros H.\napply Rlt_not_le with (2 := Hx).\nrewrite H, Rabs_R0.\napply bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (H : x = 0%R) : False.","proofString":"apply Rlt_not_le with (2 := Hx).\nrewrite H, Rabs_R0.\napply bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (H : x = 0%R) : (Rabs x < bpow emin)%R.","proofString":"rewrite H, Rabs_R0.\napply bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (H : x = 0%R) : (0 < bpow emin)%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) : (ulp beta fexp x <= bpow (- p + 1) * Rabs x)%R.","proofString":"rewrite ulp_neq_0; trivial.\nunfold cexp.\ndestruct (mag beta x) as (ex, He).\nsimpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) : (bpow (cexp beta fexp x) <= bpow (- p + 1) * Rabs x)%R.","proofString":"unfold cexp.\ndestruct (mag beta x) as (ex, He).\nsimpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) : (bpow (fexp (mag beta x)) <= bpow (- p + 1) * Rabs x)%R.","proofString":"destruct (mag beta x) as (ex, He).\nsimpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (fexp (Build_mag_prop beta x ex He)) <= bpow (- p + 1) * Rabs x)%R.","proofString":"simpl.\nspecialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (fexp ex) <= bpow (- p + 1) * Rabs x)%R.","proofString":"specialize (He Hx').\napply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (fexp ex) <= bpow (- p + 1) * Rabs x)%R.","proofString":"apply Rle_trans with (bpow (-p + 1) * bpow (ex - 1))%R.\nrewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia.\napply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (fexp ex) <= bpow (- p + 1) * bpow (ex - 1))%R.","proofString":"rewrite <- bpow_plus.\napply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (fexp ex) <= bpow (- p + 1 + (ex - 1)))%R.","proofString":"apply bpow_le.\nassert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (fexp ex <= - p + 1 + (ex - 1))%Z.","proofString":"assert (emin < ex)%Z.\napply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx.\ngeneralize (Hmin ex).\nlia."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (emin < ex)%Z.","proofString":"apply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow emin < bpow ex)%R.","proofString":"apply Rle_lt_trans with (2 := proj2 He).\nexact Hx."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow emin <= Rabs x)%R.","proofString":"exact Hx."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : (emin < ex)%Z) : (fexp ex <= - p + 1 + (ex - 1))%Z.","proofString":"generalize (Hmin ex).\nlia."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : (emin < ex)%Z) : ((emin < ex)%Z -> (p <= ex - fexp ex)%Z) -> (fexp ex <= - p + 1 + (ex - 1))%Z.","proofString":"lia."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (- p + 1) * bpow (ex - 1) <= bpow (- p + 1) * Rabs x)%R.","proofString":"apply Rmult_le_compat_l.\napply bpow_ge_0.\napply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 <= bpow (- p + 1))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1) <= Rabs x)%R.","proofString":"apply He."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (0 <= / 2 * bpow (- p + 1))%R.","proofString":"apply Rlt_le.\napply Rmult_lt_0_compat.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (0 < / 2 * bpow (- p + 1))%R.","proofString":"apply Rmult_lt_0_compat.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (0 < / 2)%R.","proofString":"apply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (0 < 2)%R.","proofString":"now apply IZR_lt."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (0 < bpow (- p + 1))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow emin <= Rabs x)%R) : (Rabs (round beta fexp (Znearest choice) x - x) <=\n / 2 * bpow (- p + 1) * Rabs x)%R.","proofString":"now apply relative_error_N."},{"statement":"(m : Z) (x : R) (Hx : x = 0%R) : (Rabs (0 - 0) <= / 2 * bpow (- p + 1) * Rabs 0)%R.","proofString":"unfold Rminus.\nrewrite Rplus_0_l, Rabs_Ropp, Rabs_R0.\nrewrite Rmult_0_r.\napply Rle_refl."},{"statement":"(m : Z) (x : R) (Hx : x = 0%R) : (Rabs (0 + - 0) <= / 2 * bpow (- p + 1) * Rabs 0)%R.","proofString":"rewrite Rplus_0_l, Rabs_Ropp, Rabs_R0.\nrewrite Rmult_0_r.\napply Rle_refl."},{"statement":"(m : Z) (x : R) (Hx : x = 0%R) : (0 <= / 2 * bpow (- p + 1) * 0)%R.","proofString":"rewrite Rmult_0_r.\napply Rle_refl."},{"statement":"(m : Z) (x : R) (Hx : x = 0%R) : (0 <= 0)%R.","proofString":"apply Rle_refl."},{"statement":"(m : Z) (x : R) : (0 <= / 2 * bpow (- p + 1))%R.","proofString":"apply Rlt_le.\napply Rmult_lt_0_compat.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply bpow_gt_0."},{"statement":"(m : Z) (x : R) : (0 < / 2 * bpow (- p + 1))%R.","proofString":"apply Rmult_lt_0_compat.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply bpow_gt_0."},{"statement":"(m : Z) (x : R) : (0 < / 2)%R.","proofString":"apply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(m : Z) (x : R) : (0 < 2)%R.","proofString":"now apply IZR_lt."},{"statement":"(m : Z) (x : R) : (0 < bpow (- p + 1))%R.","proofString":"apply bpow_gt_0."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) : (Rabs (round beta fexp (Znearest choice) x - x) <= / 2 * ulp beta fexp x)%R.","proofString":"now apply error_le_half_ulp."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) : (0 <= / 2)%R.","proofString":"apply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) : (0 < / 2)%R.","proofString":"apply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) : (0 < 2)%R.","proofString":"now apply IZR_lt."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) : x <> 0%R.","proofString":"intros H.\napply Rlt_not_le with (2 := Hx).\nrewrite H, Rabs_R0.\napply bpow_gt_0."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (H : x = 0%R) : False.","proofString":"apply Rlt_not_le with (2 := Hx).\nrewrite H, Rabs_R0.\napply bpow_gt_0."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (H : x = 0%R) : (Rabs x < bpow emin)%R.","proofString":"rewrite H, Rabs_R0.\napply bpow_gt_0."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (H : x = 0%R) : (0 < bpow emin)%R.","proofString":"apply bpow_gt_0."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (emin < ex)%Z.","proofString":"apply (lt_bpow beta).\napply Rle_lt_trans with (2 := proj2 He).\nexact Hx."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow emin < bpow ex)%R.","proofString":"apply Rle_lt_trans with (2 := proj2 He).\nexact Hx."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow emin <= Rabs x)%R.","proofString":"exact Hx."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He' : (emin < ex)%Z) : (bpow (fexp ex) <= bpow (- p + 1) * bpow (ex - 1))%R.","proofString":"rewrite <- bpow_plus.\napply bpow_le.\ngeneralize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He' : (emin < ex)%Z) : (bpow (fexp ex) <= bpow (- p + 1 + (ex - 1)))%R.","proofString":"apply bpow_le.\ngeneralize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He' : (emin < ex)%Z) : (fexp ex <= - p + 1 + (ex - 1))%Z.","proofString":"generalize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He' : (emin < ex)%Z) : ((emin < ex)%Z -> (p <= ex - fexp ex)%Z) -> (fexp ex <= - p + 1 + (ex - 1))%Z.","proofString":"lia."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He' : (emin < ex)%Z) : (0 <= bpow (- p + 1))%R.","proofString":"apply bpow_ge_0."},{"statement":"(Hp : (0 < p)%Z) (x : R) (Hx : (bpow emin <= Rabs x)%R) (Hx' : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (He' : (emin < ex)%Z) : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 <= x0)%R ->\n(bpow (ex - 1) <= x0 < bpow ex)%R ->\n(bpow (ex - 1) <= round beta fexp rnd0 x0)%R.","proofString":"clear rnd valid_rnd x Hx Hx' He.\nintros rnd valid_rnd x _ Hx.\nrewrite <- (round_generic beta fexp rnd (bpow (ex - 1))).\nnow apply round_le.\napply generic_format_bpow.\nring_simplify (ex - 1 + 1)%Z.\ngeneralize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (ex : Z) (He' : (emin < ex)%Z) (x : R) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (bpow (ex - 1) <= round beta fexp rnd x)%R.","proofString":"rewrite <- (round_generic beta fexp rnd (bpow (ex - 1))).\nnow apply round_le.\napply generic_format_bpow.\nring_simplify (ex - 1 + 1)%Z.\ngeneralize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (ex : Z) (He' : (emin < ex)%Z) (x : R) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (round beta fexp rnd (bpow (ex - 1)) <= round beta fexp rnd x)%R.","proofString":"now apply round_le."},{"statement":"(Hp : (0 < p)%Z) (ex : Z) (He' : (emin < ex)%Z) (x : R) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : generic_format beta fexp (bpow (ex - 1)).","proofString":"apply generic_format_bpow.\nring_simplify (ex - 1 + 1)%Z.\ngeneralize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (ex : Z) (He' : (emin < ex)%Z) (x : R) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (fexp (ex - 1 + 1) <= ex - 1)%Z.","proofString":"ring_simplify (ex - 1 + 1)%Z.\ngeneralize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (ex : Z) (He' : (emin < ex)%Z) (x : R) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : (fexp ex <= ex - 1)%Z.","proofString":"generalize (Hmin ex).\nlia."},{"statement":"(Hp : (0 < p)%Z) (ex : Z) (He' : (emin < ex)%Z) (x : R) (Hx : (bpow (ex - 1) <= x < bpow ex)%R) : ((emin < ex)%Z -> (p <= ex - fexp ex)%Z) -> (fexp ex <= ex - 1)%Z.","proofString":"lia."},{"statement":"(Hp : (0 < p)%Z) (m : Z) (x : R) (Hx : x = 0%R) : (Rabs (0 - 0) <= / 2 * bpow (- p + 1) * Rabs 0)%R.","proofString":"unfold Rminus.\nrewrite Rplus_0_l, Rabs_Ropp, Rabs_R0.\nrewrite Rmult_0_r.\napply Rle_refl."},{"statement":"(Hp : (0 < p)%Z) (m : Z) (x : R) (Hx : x = 0%R) : (Rabs (0 + - 0) <= / 2 * bpow (- p + 1) * Rabs 0)%R.","proofString":"rewrite Rplus_0_l, Rabs_Ropp, Rabs_R0.\nrewrite Rmult_0_r.\napply Rle_refl."},{"statement":"(Hp : (0 < p)%Z) (m : Z) (x : R) (Hx : x = 0%R) : (0 <= / 2 * bpow (- p + 1) * 0)%R.","proofString":"rewrite Rmult_0_r.\napply Rle_refl."},{"statement":"(Hp : (0 < p)%Z) (m : Z) (x : R) (Hx : x = 0%R) : (0 <= 0)%R.","proofString":"apply Rle_refl."},{"statement":"(k : Z) : (prec <= k - FLX_exp prec k)%Z.","proofString":"unfold FLX_exp.\nlia."},{"statement":"(k : Z) : (prec <= k - (k - prec))%Z.","proofString":"lia."},{"statement":"(x : R) (Hx : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : forall k : Z, (ex - 1 < k)%Z -> (prec <= k - FLX_exp prec k)%Z.","proofString":"intros k _.\napply relative_error_FLX_aux."},{"statement":"(x : R) (Hx : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (k : Z) : (prec <= k - FLX_exp prec k)%Z.","proofString":"apply relative_error_FLX_aux."},{"statement":"(x : R) (Hx : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1) <= Rabs x)%R.","proofString":"apply He."},{"statement":"(x : R) : (0 < bpow (- prec + 1))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) : x <> 0%R ->\n(Rabs (round beta (FLX_exp prec) rnd x - x) < bpow (- prec + 1) * Rabs x)%R.","proofString":"now apply relative_error_FLX."},{"statement":"(x : R) (Hx : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : forall k : Z, (ex - 1 < k)%Z -> (prec <= k - FLX_exp prec k)%Z.","proofString":"intros k _.\napply relative_error_FLX_aux."},{"statement":"(x : R) (Hx : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (k : Z) : (prec <= k - FLX_exp prec k)%Z.","proofString":"apply relative_error_FLX_aux."},{"statement":"(x : R) (Hx : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1) <= Rabs x)%R.","proofString":"apply He."},{"statement":"(x : R) (Hx : x = 0%R) : (Rabs (0 - 0) <= / 2 * bpow (- prec + 1) * Rabs 0)%R.","proofString":"unfold Rminus.\nrewrite Rplus_0_l, Rabs_Ropp, Rabs_R0.\nrewrite Rmult_0_r.\napply Rle_refl."},{"statement":"(x : R) (Hx : x = 0%R) : (Rabs (0 + - 0) <= / 2 * bpow (- prec + 1) * Rabs 0)%R.","proofString":"rewrite Rplus_0_l, Rabs_Ropp, Rabs_R0.\nrewrite Rmult_0_r.\napply Rle_refl."},{"statement":"(x : R) (Hx : x = 0%R) : (0 <= / 2 * bpow (- prec + 1) * 0)%R.","proofString":"rewrite Rmult_0_r.\napply Rle_refl."},{"statement":"(x : R) (Hx : x = 0%R) : (0 <= 0)%R.","proofString":"apply Rle_refl."},{"statement":"(x : R) (Hx : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : forall k : Z, (ex - 1 < k)%Z -> (prec <= k - FLX_exp prec k)%Z.","proofString":"intros k _.\napply relative_error_FLX_aux."},{"statement":"(x : R) (Hx : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (k : Z) : (prec <= k - FLX_exp prec k)%Z.","proofString":"apply relative_error_FLX_aux."},{"statement":"(x : R) (Hx : x <> 0%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1) <= Rabs x)%R.","proofString":"apply He."},{"statement":"(2 * (/ 2 * bpow (- prec + 1)) < 2 * 1)%R.","proofString":"rewrite <-Rmult_assoc, Rinv_r, Rmult_1_l, Rmult_1_r; [|lra].\napply (Rle_lt_trans _ (bpow 0));  [apply bpow_le; lia|simpl; lra]."},{"statement":"(bpow (- prec + 1) < 2)%R.","proofString":"apply (Rle_lt_trans _ (bpow 0));  [apply bpow_le; lia|simpl; lra]."},{"statement":"(Pu_ro : (0 <= u_ro)%R) : (u_ro / (1 + u_ro) <= u_ro)%R.","proofString":"apply (Rmult_le_reg_r (1 + u_ro)); [lra|].\nunfold Rdiv; rewrite Rmult_assoc, Rinv_l; [|lra].\nassert (0 <= u_ro * u_ro)%R; [apply Rmult_le_pos|]; lra."},{"statement":"(Pu_ro : (0 <= u_ro)%R) : (u_ro / (1 + u_ro) * (1 + u_ro) <= u_ro * (1 + u_ro))%R.","proofString":"unfold Rdiv; rewrite Rmult_assoc, Rinv_l; [|lra].\nassert (0 <= u_ro * u_ro)%R; [apply Rmult_le_pos|]; lra."},{"statement":"(Pu_ro : (0 <= u_ro)%R) : (u_ro * 1 <= u_ro * (1 + u_ro))%R.","proofString":"assert (0 <= u_ro * u_ro)%R; [apply Rmult_le_pos|]; lra."},{"statement":"(x : R) : (0 <= u_ro)%R.","proofString":"apply Rmult_le_pos; [lra|apply bpow_ge_0]."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Zx : x = 0%R) : (Rabs (0 - 0) <= 0)%R.","proofString":"now unfold Rminus; rewrite Rplus_0_l, Rabs_Ropp, Rabs_R0; right."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Nzx : x <> 0%R) : (Rabs (round beta (FLX_exp prec) (Znearest choice) x - x) <=\n u_ro / (1 + u_ro) * Rabs x)%R.","proofString":"set (ufpx := bpow (mag beta x - 1)%Z).\nset (rx := round _ _ _ _).\nassert (Pufpx : (0 <= ufpx)%R); [now apply bpow_ge_0|].\nassert (H_2_1 : (Rabs (rx - x) <= u_ro * ufpx)%R).\nrefine (Rle_trans _ _ _ (error_le_half_ulp _ _ _ _) _);    [now apply FLX_exp_valid|right].\nunfold ulp, cexp, FLX_exp, u_ro, ufpx; rewrite (Req_bool_false _ _ Nzx).\nrewrite Rmult_assoc, <-bpow_plus; do 2 f_equal; ring.\nassert (H_2_3 : (ufpx + Rabs (rx - x) <= Rabs x)%R).\napply (Rplus_le_reg_r (- ufpx)); ring_simplify.\ndestruct (Rle_or_lt 0 x) as [Sx|Sx].\napply (Rle_trans _ (Rabs (ufpx - x))).\napply round_N_pt; [now apply FLX_exp_valid|].\napply generic_format_bpow; unfold FLX_exp; lia.\nrewrite Rabs_minus_sym, Rabs_pos_eq.\nnow rewrite Rabs_pos_eq; [right; ring|].\napply (Rplus_le_reg_r ufpx); ring_simplify.\nnow rewrite <-(Rabs_pos_eq _ Sx); apply bpow_mag_le.\napply (Rle_trans _ (Rabs (- ufpx - x))).\napply round_N_pt; [now apply FLX_exp_valid|].\napply generic_format_opp, generic_format_bpow; unfold FLX_exp; lia.\nrewrite Rabs_pos_eq; [now rewrite Rabs_left; [right|]|].\napply (Rplus_le_reg_r x); ring_simplify.\nrewrite <-(Ropp_involutive x); apply Ropp_le_contravar; unfold ufpx.\nrewrite <-mag_opp, <-Rabs_pos_eq; [apply bpow_mag_le|]; lra.\nassert (H : (Rabs ((rx - x) / x) <= u_ro / (1 + u_ro))%R).\nassert (H : (0 < ufpx + Rabs (rx - x))%R).\napply Rplus_lt_le_0_compat; [apply bpow_gt_0|apply Rabs_pos].\napply (Rle_trans _ (Rabs (rx - x) / (ufpx + Rabs (rx - x)))).\nunfold Rdiv; rewrite Rabs_mult; apply Rmult_le_compat_l; [apply Rabs_pos|].\nnow rewrite (Rabs_Rinv _ Nzx); apply Rinv_le.\napply (Rmult_le_reg_r ((ufpx + Rabs (rx - x)) * (1 + u_ro))).\napply Rmult_lt_0_compat; lra.\nfield_simplify; [try unfold Rdiv; rewrite ?Rinv_1, ?Rmult_1_r| |]; lra.\nrevert H; unfold Rdiv; rewrite Rabs_mult, (Rabs_Rinv _ Nzx); intro H.\napply (Rmult_le_reg_r (/ Rabs x)); [now apply Rinv_0_lt_compat, Rabs_pos_lt|].\nnow apply (Rle_trans _ _ _ H); right; field; split; [apply Rabs_no_R0|lra]."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Nzx : x <> 0%R) (ufpx : R) (rx : R) (Pufpx : (0 <= ufpx)%R) : (/ 2 * bpow (mag beta x - prec))%R =\n(/ 2 * bpow (- prec + 1) * bpow (mag beta x - 1))%R.","proofString":"rewrite Rmult_assoc, <-bpow_plus; do 2 f_equal; ring."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Nzx : x <> 0%R) (ufpx : R) (rx : R) (Pufpx : (0 <= ufpx)%R) (H_2_1 : (Rabs (rx - x) <= u_ro * ufpx)%R) (Sx : (0 <= x)%R) : (x - ufpx <= - ufpx + Rabs x)%R.","proofString":"now rewrite Rabs_pos_eq; [right; ring|]."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Nzx : x <> 0%R) (ufpx : R) (rx : R) (Pufpx : (0 <= ufpx)%R) (H_2_1 : (Rabs (rx - x) <= u_ro * ufpx)%R) (Sx : (x < 0)%R) : (bpow (mag beta x - 1) <= - x)%R.","proofString":"rewrite <-mag_opp, <-Rabs_pos_eq; [apply bpow_mag_le|]; lra."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Nzx : x <> 0%R) (ufpx : R) (rx : R) (Pufpx : (0 <= ufpx)%R) (H_2_1 : (Rabs (rx - x) <= u_ro * ufpx)%R) (H_2_3 : (ufpx + Rabs (rx - x) <= Rabs x)%R) (H : (0 < ufpx + Rabs (rx - x))%R) : (Rabs ((rx - x) / x) <= u_ro / (1 + u_ro))%R.","proofString":"apply (Rle_trans _ (Rabs (rx - x) / (ufpx + Rabs (rx - x)))).\nunfold Rdiv; rewrite Rabs_mult; apply Rmult_le_compat_l; [apply Rabs_pos|].\nnow rewrite (Rabs_Rinv _ Nzx); apply Rinv_le.\napply (Rmult_le_reg_r ((ufpx + Rabs (rx - x)) * (1 + u_ro))).\napply Rmult_lt_0_compat; lra.\nfield_simplify; [try unfold Rdiv; rewrite ?Rinv_1, ?Rmult_1_r| |]; lra."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Nzx : x <> 0%R) (ufpx : R) (rx : R) (Pufpx : (0 <= ufpx)%R) (H_2_1 : (Rabs (rx - x) <= u_ro * ufpx)%R) (H_2_3 : (ufpx + Rabs (rx - x) <= Rabs x)%R) (H : (0 < ufpx + Rabs (rx - x))%R) : (Rabs ((rx - x) / x) <= Rabs (rx - x) / (ufpx + Rabs (rx - x)))%R.","proofString":"unfold Rdiv; rewrite Rabs_mult; apply Rmult_le_compat_l; [apply Rabs_pos|].\nnow rewrite (Rabs_Rinv _ Nzx); apply Rinv_le."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Nzx : x <> 0%R) (ufpx : R) (rx : R) (Pufpx : (0 <= ufpx)%R) (H_2_1 : (Rabs (rx - x) <= u_ro * ufpx)%R) (H_2_3 : (ufpx + Rabs (rx - x) <= Rabs x)%R) (H : (0 < ufpx + Rabs (rx - x))%R) : (Rabs (/ x) <= / (ufpx + Rabs (rx - x)))%R.","proofString":"now rewrite (Rabs_Rinv _ Nzx); apply Rinv_le."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Nzx : x <> 0%R) (ufpx : R) (rx : R) (Pufpx : (0 <= ufpx)%R) (H_2_1 : (Rabs (rx - x) <= u_ro * ufpx)%R) (H_2_3 : (ufpx + Rabs (rx - x) <= Rabs x)%R) (H : (0 < ufpx + Rabs (rx - x))%R) : (Rabs (rx - x) / (ufpx + Rabs (rx - x)) <= u_ro / (1 + u_ro))%R.","proofString":"apply (Rmult_le_reg_r ((ufpx + Rabs (rx - x)) * (1 + u_ro))).\napply Rmult_lt_0_compat; lra.\nfield_simplify; [try unfold Rdiv; rewrite ?Rinv_1, ?Rmult_1_r| |]; lra."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Nzx : x <> 0%R) (ufpx : R) (rx : R) (Pufpx : (0 <= ufpx)%R) (H_2_1 : (Rabs (rx - x) <= u_ro * ufpx)%R) (H_2_3 : (ufpx + Rabs (rx - x) <= Rabs x)%R) (H : (0 < ufpx + Rabs (rx - x))%R) : (0 < (ufpx + Rabs (rx - x)) * (1 + u_ro))%R.","proofString":"apply Rmult_lt_0_compat; lra."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Nzx : x <> 0%R) (ufpx : R) (rx : R) (Pufpx : (0 <= ufpx)%R) (H_2_1 : (Rabs (rx - x) <= u_ro * ufpx)%R) (H_2_3 : (ufpx + Rabs (rx - x) <= Rabs x)%R) (H : (0 < ufpx + Rabs (rx - x))%R) : (Rabs (rx - x) / (ufpx + Rabs (rx - x)) *\n ((ufpx + Rabs (rx - x)) * (1 + u_ro)) <=\n u_ro / (1 + u_ro) * ((ufpx + Rabs (rx - x)) * (1 + u_ro)))%R.","proofString":"field_simplify; [try unfold Rdiv; rewrite ?Rinv_1, ?Rmult_1_r| |]; lra."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Nzx : x <> 0%R) (ufpx : R) (rx : R) (Pufpx : (0 <= ufpx)%R) (H_2_1 : (Rabs (rx - x) <= u_ro * ufpx)%R) (H_2_3 : (ufpx + Rabs (rx - x) <= Rabs x)%R) (H : (Rabs ((rx - x) / x) <= u_ro / (1 + u_ro))%R) : (Rabs (rx - x) <= u_ro / (1 + u_ro) * Rabs x)%R.","proofString":"revert H; unfold Rdiv; rewrite Rabs_mult, (Rabs_Rinv _ Nzx); intro H.\napply (Rmult_le_reg_r (/ Rabs x)); [now apply Rinv_0_lt_compat, Rabs_pos_lt|].\nnow apply (Rle_trans _ _ _ H); right; field; split; [apply Rabs_no_R0|lra]."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Nzx : x <> 0%R) (ufpx : R) (rx : R) (Pufpx : (0 <= ufpx)%R) (H_2_1 : (Rabs (rx - x) <= u_ro * ufpx)%R) (H_2_3 : (ufpx + Rabs (rx - x) <= Rabs x)%R) (H : (Rabs (rx - x) * / Rabs x <= u_ro * / (1 + u_ro))%R) : (Rabs (rx - x) <= u_ro * / (1 + u_ro) * Rabs x)%R.","proofString":"apply (Rmult_le_reg_r (/ Rabs x)); [now apply Rinv_0_lt_compat, Rabs_pos_lt|].\nnow apply (Rle_trans _ _ _ H); right; field; split; [apply Rabs_no_R0|lra]."},{"statement":"(x : R) (Pu_ro : (0 <= u_ro)%R) (Nzx : x <> 0%R) (ufpx : R) (rx : R) (Pufpx : (0 <= ufpx)%R) (H_2_1 : (Rabs (rx - x) <= u_ro * ufpx)%R) (H_2_3 : (ufpx + Rabs (rx - x) <= Rabs x)%R) (H : (Rabs (rx - x) * / Rabs x <= u_ro * / (1 + u_ro))%R) : (Rabs (rx - x) * / Rabs x <= u_ro * / (1 + u_ro) * Rabs x * / Rabs x)%R.","proofString":"now apply (Rle_trans _ _ _ H); right; field; split; [apply Rabs_no_R0|lra]."},{"statement":"(x : R) : (0 <= / 2 * bpow (- prec + 1))%R.","proofString":"apply Rlt_le.\napply Rmult_lt_0_compat.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply bpow_gt_0."},{"statement":"(x : R) : (0 < / 2 * bpow (- prec + 1))%R.","proofString":"apply Rmult_lt_0_compat.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply bpow_gt_0."},{"statement":"(x : R) : (0 < / 2)%R.","proofString":"apply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) : (0 < 2)%R.","proofString":"now apply IZR_lt."},{"statement":"(x : R) : (0 < bpow (- prec + 1))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) : (Rabs (round beta (FLX_exp prec) (Znearest choice) x - x) <=\n / 2 * bpow (- prec + 1) * Rabs x)%R.","proofString":"now apply relative_error_N_FLX."},{"statement":"(x : R) : (0 <= u_ro / (1 + u_ro))%R.","proofString":"apply u_rod1pu_ro_pos."},{"statement":"(x : R) : (Rabs (round beta (FLX_exp prec) (Znearest choice) x - x) <=\n u_ro / (1 + u_ro) * Rabs x)%R.","proofString":"now apply relative_error_N_FLX'."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) : exists eps : R, (Rabs eps <= u_ro)%R /\\ x = (rx * (1 + eps))%R.","proofString":"assert (Pu_ro := u_ro_pos).\nassert (H := Rabs_le_inv _ _ Bd).\nassert (H' := u_rod1pu_ro_le_u_ro); assert (H'' := u_ro_lt_1).\ndestruct (Req_dec rx 0) as [Zfx|Nzfx].\nexists 0%R; split; [now rewrite Rabs_R0|].\nrewrite Rplus_0_r, Rmult_1_r, Zfx.\nnow rewrite Zfx in Hd; destruct (Rmult_integral _ _ (sym_eq Hd)); [|lra].\ndestruct (Req_dec x 0) as [Zx|Nzx].\nnow exfalso; revert Hd; rewrite Zx, Rmult_0_l.\nset (d' := ((x - rx) / rx)%R).\nassert (Hd' : (Rabs d' <= u_ro)%R).\nunfold d'; rewrite Hd.\nreplace (_ / _)%R with (- d / (1 + d))%R; [|now field; split; lra].\nunfold Rdiv; rewrite Rabs_mult, Rabs_Ropp.\nrewrite (Rabs_pos_eq (/ _)); [|apply Rlt_le, Rinv_0_lt_compat; lra].\napply (Rmult_le_reg_r (1 + d)); [lra|].\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra].\napply (Rle_trans _ _ _ Bd).\nunfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|].\napply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra.\nnow exists d'; split; [|unfold d'; field]."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) : exists eps : R, (Rabs eps <= u_ro)%R /\\ x = (rx * (1 + eps))%R.","proofString":"assert (H := Rabs_le_inv _ _ Bd).\nassert (H' := u_rod1pu_ro_le_u_ro); assert (H'' := u_ro_lt_1).\ndestruct (Req_dec rx 0) as [Zfx|Nzfx].\nexists 0%R; split; [now rewrite Rabs_R0|].\nrewrite Rplus_0_r, Rmult_1_r, Zfx.\nnow rewrite Zfx in Hd; destruct (Rmult_integral _ _ (sym_eq Hd)); [|lra].\ndestruct (Req_dec x 0) as [Zx|Nzx].\nnow exfalso; revert Hd; rewrite Zx, Rmult_0_l.\nset (d' := ((x - rx) / rx)%R).\nassert (Hd' : (Rabs d' <= u_ro)%R).\nunfold d'; rewrite Hd.\nreplace (_ / _)%R with (- d / (1 + d))%R; [|now field; split; lra].\nunfold Rdiv; rewrite Rabs_mult, Rabs_Ropp.\nrewrite (Rabs_pos_eq (/ _)); [|apply Rlt_le, Rinv_0_lt_compat; lra].\napply (Rmult_le_reg_r (1 + d)); [lra|].\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra].\napply (Rle_trans _ _ _ Bd).\nunfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|].\napply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra.\nnow exists d'; split; [|unfold d'; field]."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) : exists eps : R, (Rabs eps <= u_ro)%R /\\ x = (rx * (1 + eps))%R.","proofString":"assert (H' := u_rod1pu_ro_le_u_ro); assert (H'' := u_ro_lt_1).\ndestruct (Req_dec rx 0) as [Zfx|Nzfx].\nexists 0%R; split; [now rewrite Rabs_R0|].\nrewrite Rplus_0_r, Rmult_1_r, Zfx.\nnow rewrite Zfx in Hd; destruct (Rmult_integral _ _ (sym_eq Hd)); [|lra].\ndestruct (Req_dec x 0) as [Zx|Nzx].\nnow exfalso; revert Hd; rewrite Zx, Rmult_0_l.\nset (d' := ((x - rx) / rx)%R).\nassert (Hd' : (Rabs d' <= u_ro)%R).\nunfold d'; rewrite Hd.\nreplace (_ / _)%R with (- d / (1 + d))%R; [|now field; split; lra].\nunfold Rdiv; rewrite Rabs_mult, Rabs_Ropp.\nrewrite (Rabs_pos_eq (/ _)); [|apply Rlt_le, Rinv_0_lt_compat; lra].\napply (Rmult_le_reg_r (1 + d)); [lra|].\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra].\napply (Rle_trans _ _ _ Bd).\nunfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|].\napply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra.\nnow exists d'; split; [|unfold d'; field]."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) : exists eps : R, (Rabs eps <= u_ro)%R /\\ x = (rx * (1 + eps))%R.","proofString":"destruct (Req_dec rx 0) as [Zfx|Nzfx].\nexists 0%R; split; [now rewrite Rabs_R0|].\nrewrite Rplus_0_r, Rmult_1_r, Zfx.\nnow rewrite Zfx in Hd; destruct (Rmult_integral _ _ (sym_eq Hd)); [|lra].\ndestruct (Req_dec x 0) as [Zx|Nzx].\nnow exfalso; revert Hd; rewrite Zx, Rmult_0_l.\nset (d' := ((x - rx) / rx)%R).\nassert (Hd' : (Rabs d' <= u_ro)%R).\nunfold d'; rewrite Hd.\nreplace (_ / _)%R with (- d / (1 + d))%R; [|now field; split; lra].\nunfold Rdiv; rewrite Rabs_mult, Rabs_Ropp.\nrewrite (Rabs_pos_eq (/ _)); [|apply Rlt_le, Rinv_0_lt_compat; lra].\napply (Rmult_le_reg_r (1 + d)); [lra|].\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra].\napply (Rle_trans _ _ _ Bd).\nunfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|].\napply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra.\nnow exists d'; split; [|unfold d'; field]."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Zfx : rx = 0%R) : exists eps : R, (Rabs eps <= u_ro)%R /\\ x = (rx * (1 + eps))%R.","proofString":"exists 0%R; split; [now rewrite Rabs_R0|].\nrewrite Rplus_0_r, Rmult_1_r, Zfx.\nnow rewrite Zfx in Hd; destruct (Rmult_integral _ _ (sym_eq Hd)); [|lra]."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Zfx : rx = 0%R) : x = (rx * (1 + 0))%R.","proofString":"rewrite Rplus_0_r, Rmult_1_r, Zfx.\nnow rewrite Zfx in Hd; destruct (Rmult_integral _ _ (sym_eq Hd)); [|lra]."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Zfx : rx = 0%R) : x = 0%R.","proofString":"now rewrite Zfx in Hd; destruct (Rmult_integral _ _ (sym_eq Hd)); [|lra]."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Nzfx : rx <> 0%R) : exists eps : R, (Rabs eps <= u_ro)%R /\\ x = (rx * (1 + eps))%R.","proofString":"destruct (Req_dec x 0) as [Zx|Nzx].\nnow exfalso; revert Hd; rewrite Zx, Rmult_0_l.\nset (d' := ((x - rx) / rx)%R).\nassert (Hd' : (Rabs d' <= u_ro)%R).\nunfold d'; rewrite Hd.\nreplace (_ / _)%R with (- d / (1 + d))%R; [|now field; split; lra].\nunfold Rdiv; rewrite Rabs_mult, Rabs_Ropp.\nrewrite (Rabs_pos_eq (/ _)); [|apply Rlt_le, Rinv_0_lt_compat; lra].\napply (Rmult_le_reg_r (1 + d)); [lra|].\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra].\napply (Rle_trans _ _ _ Bd).\nunfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|].\napply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra.\nnow exists d'; split; [|unfold d'; field]."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Nzfx : rx <> 0%R) (Zx : x = 0%R) : exists eps : R, (Rabs eps <= u_ro)%R /\\ x = (rx * (1 + eps))%R.","proofString":"now exfalso; revert Hd; rewrite Zx, Rmult_0_l."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Nzfx : rx <> 0%R) (Nzx : x <> 0%R) : exists eps : R, (Rabs eps <= u_ro)%R /\\ x = (rx * (1 + eps))%R.","proofString":"set (d' := ((x - rx) / rx)%R).\nassert (Hd' : (Rabs d' <= u_ro)%R).\nunfold d'; rewrite Hd.\nreplace (_ / _)%R with (- d / (1 + d))%R; [|now field; split; lra].\nunfold Rdiv; rewrite Rabs_mult, Rabs_Ropp.\nrewrite (Rabs_pos_eq (/ _)); [|apply Rlt_le, Rinv_0_lt_compat; lra].\napply (Rmult_le_reg_r (1 + d)); [lra|].\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra].\napply (Rle_trans _ _ _ Bd).\nunfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|].\napply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra.\nnow exists d'; split; [|unfold d'; field]."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Nzfx : rx <> 0%R) (Nzx : x <> 0%R) (d' : R) : (Rabs ((x - x * (1 + d)) / (x * (1 + d))) <= u_ro)%R.","proofString":"replace (_ / _)%R with (- d / (1 + d))%R; [|now field; split; lra].\nunfold Rdiv; rewrite Rabs_mult, Rabs_Ropp.\nrewrite (Rabs_pos_eq (/ _)); [|apply Rlt_le, Rinv_0_lt_compat; lra].\napply (Rmult_le_reg_r (1 + d)); [lra|].\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra].\napply (Rle_trans _ _ _ Bd).\nunfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|].\napply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Nzfx : rx <> 0%R) (Nzx : x <> 0%R) (d' : R) : (Rabs (- d / (1 + d)) <= u_ro)%R.","proofString":"unfold Rdiv; rewrite Rabs_mult, Rabs_Ropp.\nrewrite (Rabs_pos_eq (/ _)); [|apply Rlt_le, Rinv_0_lt_compat; lra].\napply (Rmult_le_reg_r (1 + d)); [lra|].\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra].\napply (Rle_trans _ _ _ Bd).\nunfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|].\napply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Nzfx : rx <> 0%R) (Nzx : x <> 0%R) (d' : R) : (Rabs d * Rabs (/ (1 + d)) <= u_ro)%R.","proofString":"rewrite (Rabs_pos_eq (/ _)); [|apply Rlt_le, Rinv_0_lt_compat; lra].\napply (Rmult_le_reg_r (1 + d)); [lra|].\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra].\napply (Rle_trans _ _ _ Bd).\nunfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|].\napply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Nzfx : rx <> 0%R) (Nzx : x <> 0%R) (d' : R) : (Rabs d * / (1 + d) <= u_ro)%R.","proofString":"apply (Rmult_le_reg_r (1 + d)); [lra|].\nrewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra].\napply (Rle_trans _ _ _ Bd).\nunfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|].\napply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Nzfx : rx <> 0%R) (Nzx : x <> 0%R) (d' : R) : (Rabs d * / (1 + d) * (1 + d) <= u_ro * (1 + d))%R.","proofString":"rewrite Rmult_assoc, Rinv_l, Rmult_1_r; [|lra].\napply (Rle_trans _ _ _ Bd).\nunfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|].\napply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Nzfx : rx <> 0%R) (Nzx : x <> 0%R) (d' : R) : (Rabs d <= u_ro * (1 + d))%R.","proofString":"apply (Rle_trans _ _ _ Bd).\nunfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|].\napply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Nzfx : rx <> 0%R) (Nzx : x <> 0%R) (d' : R) : (u_ro / (1 + u_ro) <= u_ro * (1 + d))%R.","proofString":"unfold Rdiv; apply Rmult_le_compat_l; [now apply u_ro_pos|].\napply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra."},{"statement":"(x rx d : R) (Bd : (Rabs d <= u_ro / (1 + u_ro))%R) (Hd : rx = (x * (1 + d))%R) (Pu_ro : (0 <= u_ro)%R) (H : (- (u_ro / (1 + u_ro)) <= d <= u_ro / (1 + u_ro))%R) (H' : (u_ro / (1 + u_ro) <= u_ro)%R) (H'' : (u_ro < 1)%R) (Nzfx : rx <> 0%R) (Nzx : x <> 0%R) (d' : R) : (/ (1 + u_ro) <= 1 + d)%R.","proofString":"apply (Rle_trans _ (1 - u_ro / (1 + u_ro))); [right; field|]; lra."},{"statement":"(x : R) : (Rabs (round beta (FLX_exp prec) (Znearest choice) x - x) <=\n / 2 * bpow (- prec + 1) *\n Rabs (round beta (FLX_exp prec) (Znearest choice) x))%R.","proofString":"apply relative_error_le_conversion_round_inv, relative_error_N_FLX_round_ex."},{"statement":"(k : Z) (Hk : (emin + prec - 1 < k)%Z) : (prec <= k - FLT_exp emin prec k)%Z.","proofString":"unfold FLT_exp.\ngeneralize (Zmax_spec (k - prec) emin).\nlia."},{"statement":"(k : Z) (Hk : (emin + prec - 1 < k)%Z) : (prec <= k - Z.max (k - prec) emin)%Z.","proofString":"generalize (Zmax_spec (k - prec) emin).\nlia."},{"statement":"(k : Z) (Hk : (emin + prec - 1 < k)%Z) : (k - prec >= emin)%Z /\\ Z.max (k - prec) emin = (k - prec)%Z \\/\n(k - prec < emin)%Z /\\ Z.max (k - prec) emin = emin ->\n(prec <= k - Z.max (k - prec) emin)%Z.","proofString":"lia."},{"statement":"(x : R) (Hx : (bpow (emin + prec - 1) <= Rabs x)%R) : forall k : Z, (emin + prec - 1 < k)%Z -> (prec <= k - FLT_exp emin prec k)%Z.","proofString":"apply relative_error_FLT_aux."},{"statement":"(m : Z) (x : R) (Zx : x <> 0%R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (Rabs (x - x) < bpow (- prec + 1) * Rabs x)%R.","proofString":"unfold Rminus.\nrewrite Rplus_opp_r, Rabs_R0.\napply Rmult_lt_0_compat.\napply bpow_gt_0.\nnow apply Rabs_pos_lt."},{"statement":"(m : Z) (x : R) (Zx : x <> 0%R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (Rabs (x + - x) < bpow (- prec + 1) * Rabs x)%R.","proofString":"rewrite Rplus_opp_r, Rabs_R0.\napply Rmult_lt_0_compat.\napply bpow_gt_0.\nnow apply Rabs_pos_lt."},{"statement":"(m : Z) (x : R) (Zx : x <> 0%R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 < bpow (- prec + 1) * Rabs x)%R.","proofString":"apply Rmult_lt_0_compat.\napply bpow_gt_0.\nnow apply Rabs_pos_lt."},{"statement":"(m : Z) (x : R) (Zx : x <> 0%R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 < bpow (- prec + 1))%R.","proofString":"apply bpow_gt_0."},{"statement":"(m : Z) (x : R) (Zx : x <> 0%R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 < Rabs x)%R.","proofString":"now apply Rabs_pos_lt."},{"statement":"(m : Z) (x : R) (Zx : x <> 0%R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (Rabs x <= bpow (emin + prec))%R.","proofString":"apply Rlt_le.\napply Rlt_le_trans with (1 := Hx).\napply bpow_le.\napply Zle_pred."},{"statement":"(m : Z) (x : R) (Zx : x <> 0%R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (Rabs x < bpow (emin + prec))%R.","proofString":"apply Rlt_le_trans with (1 := Hx).\napply bpow_le.\napply Zle_pred."},{"statement":"(m : Z) (x : R) (Zx : x <> 0%R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (bpow (emin + prec - 1) <= bpow (emin + prec))%R.","proofString":"apply bpow_le.\napply Zle_pred."},{"statement":"(m : Z) (x : R) (Zx : x <> 0%R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (emin + prec - 1 <= emin + prec)%Z.","proofString":"apply Zle_pred."},{"statement":"(m : Z) (x : R) (Zx : x <> 0%R) (Hx : (bpow (emin + prec - 1) <= Rabs x)%R) : (Rabs (round beta (FLT_exp emin prec) rnd x - x) < bpow (- prec + 1) * Rabs x)%R.","proofString":"now apply relative_error_FLT."},{"statement":"(m : Z) (x : R) : (0 < bpow (- prec + 1))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow (emin + prec - 1) <= Rabs x)%R) : (0 < bpow (- prec + 1))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow (emin + prec - 1) <= Rabs x)%R) : x <> 0%R ->\n(Rabs (round beta (FLT_exp emin prec) rnd x - x) < bpow (- prec + 1) * Rabs x)%R.","proofString":"intros _; now apply relative_error_FLT."},{"statement":"(x : R) (Hx : (bpow (emin + prec - 1) <= Rabs x)%R) : forall k : Z, (emin + prec - 1 < k)%Z -> (prec <= k - FLT_exp emin prec k)%Z.","proofString":"apply relative_error_FLT_aux."},{"statement":"(x : R) (Hx : (bpow (emin + prec - 1) <= Rabs x)%R) : (0 <= / 2 * bpow (- prec + 1))%R.","proofString":"apply Rlt_le.\napply Rmult_lt_0_compat.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow (emin + prec - 1) <= Rabs x)%R) : (0 < / 2 * bpow (- prec + 1))%R.","proofString":"apply Rmult_lt_0_compat.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow (emin + prec - 1) <= Rabs x)%R) : (0 < / 2)%R.","proofString":"apply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(x : R) (Hx : (bpow (emin + prec - 1) <= Rabs x)%R) : (0 < 2)%R.","proofString":"now apply IZR_lt."},{"statement":"(x : R) (Hx : (bpow (emin + prec - 1) <= Rabs x)%R) : (0 < bpow (- prec + 1))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Hx : (bpow (emin + prec - 1) <= Rabs x)%R) : (Rabs (round beta (FLT_exp emin prec) (Znearest choice) x - x) <=\n / 2 * bpow (- prec + 1) * Rabs x)%R.","proofString":"now apply relative_error_N_FLT."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (Rabs (x - x) <= / 2 * bpow (- prec + 1) * Rabs x)%R.","proofString":"unfold Rminus.\nrewrite Rplus_opp_r, Rabs_R0.\napply Rmult_le_pos.\napply Rmult_le_pos.\napply Rlt_le.\napply (RinvN_pos 1).\napply bpow_ge_0.\napply Rabs_pos."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (Rabs (x + - x) <= / 2 * bpow (- prec + 1) * Rabs x)%R.","proofString":"rewrite Rplus_opp_r, Rabs_R0.\napply Rmult_le_pos.\napply Rmult_le_pos.\napply Rlt_le.\napply (RinvN_pos 1).\napply bpow_ge_0.\napply Rabs_pos."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 <= / 2 * bpow (- prec + 1) * Rabs x)%R.","proofString":"apply Rmult_le_pos.\napply Rmult_le_pos.\napply Rlt_le.\napply (RinvN_pos 1).\napply bpow_ge_0.\napply Rabs_pos."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 <= / 2 * bpow (- prec + 1))%R.","proofString":"apply Rmult_le_pos.\napply Rlt_le.\napply (RinvN_pos 1).\napply bpow_ge_0."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 <= / 2)%R.","proofString":"apply Rlt_le.\napply (RinvN_pos 1)."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 < / 2)%R.","proofString":"apply (RinvN_pos 1)."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 <= bpow (- prec + 1))%R.","proofString":"apply bpow_ge_0."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 <= Rabs x)%R.","proofString":"apply Rabs_pos."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (Rabs x <= bpow (emin + prec))%R.","proofString":"apply Rlt_le.\napply Rlt_le_trans with (1 := Hx).\napply bpow_le.\napply Zle_pred."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (Rabs x < bpow (emin + prec))%R.","proofString":"apply Rlt_le_trans with (1 := Hx).\napply bpow_le.\napply Zle_pred."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (bpow (emin + prec - 1) <= bpow (emin + prec))%R.","proofString":"apply bpow_le.\napply Zle_pred."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (emin + prec - 1 <= emin + prec)%Z.","proofString":"apply Zle_pred."},{"statement":"(m : Z) (x : R) (Hx : (bpow (emin + prec - 1) <= Rabs x)%R) : (Rabs (round beta (FLT_exp emin prec) (Znearest choice) x - x) <=\n / 2 * bpow (- prec + 1) * Rabs x)%R.","proofString":"now apply relative_error_N_FLT."},{"statement":"(m : Z) (x : R) : (0 <= / 2 * bpow (- prec + 1))%R.","proofString":"apply Rmult_le_pos.\napply Rlt_le.\napply (RinvN_pos 1).\napply bpow_ge_0."},{"statement":"(m : Z) (x : R) : (0 <= / 2)%R.","proofString":"apply Rlt_le.\napply (RinvN_pos 1)."},{"statement":"(m : Z) (x : R) : (0 < / 2)%R.","proofString":"apply (RinvN_pos 1)."},{"statement":"(m : Z) (x : R) : (0 <= bpow (- prec + 1))%R.","proofString":"apply bpow_ge_0."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (Rabs (x - x) <= / 2 * bpow (- prec + 1) * Rabs x)%R.","proofString":"unfold Rminus.\nrewrite Rplus_opp_r, Rabs_R0.\napply Rmult_le_pos.\napply Rmult_le_pos.\napply Rlt_le.\napply (RinvN_pos 1).\napply bpow_ge_0.\napply Rabs_pos."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (Rabs (x + - x) <= / 2 * bpow (- prec + 1) * Rabs x)%R.","proofString":"rewrite Rplus_opp_r, Rabs_R0.\napply Rmult_le_pos.\napply Rmult_le_pos.\napply Rlt_le.\napply (RinvN_pos 1).\napply bpow_ge_0.\napply Rabs_pos."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 <= / 2 * bpow (- prec + 1) * Rabs x)%R.","proofString":"apply Rmult_le_pos.\napply Rmult_le_pos.\napply Rlt_le.\napply (RinvN_pos 1).\napply bpow_ge_0.\napply Rabs_pos."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 <= / 2 * bpow (- prec + 1))%R.","proofString":"apply Rmult_le_pos.\napply Rlt_le.\napply (RinvN_pos 1).\napply bpow_ge_0."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 <= / 2)%R.","proofString":"apply Rlt_le.\napply (RinvN_pos 1)."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 < / 2)%R.","proofString":"apply (RinvN_pos 1)."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 <= bpow (- prec + 1))%R.","proofString":"apply bpow_ge_0."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (0 <= Rabs x)%R.","proofString":"apply Rabs_pos."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (Rabs x <= bpow (emin + prec))%R.","proofString":"apply Rlt_le.\napply Rlt_le_trans with (1 := Hx).\napply bpow_le.\napply Zle_pred."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (Rabs x < bpow (emin + prec))%R.","proofString":"apply Rlt_le_trans with (1 := Hx).\napply bpow_le.\napply Zle_pred."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (bpow (emin + prec - 1) <= bpow (emin + prec))%R.","proofString":"apply bpow_le.\napply Zle_pred."},{"statement":"(m : Z) (x : R) (Hx : (Rabs x < bpow (emin + prec - 1))%R) : (emin + prec - 1 <= emin + prec)%Z.","proofString":"apply Zle_pred."},{"statement":"(x : R) : exists eps eta : R,\n  (Rabs eps <= u_ro prec / (1 + u_ro prec))%R /\\\n  (Rabs eta <= / 2 * bpow emin)%R /\\\n  (eps * eta)%R = 0%R /\\\n  round beta (FLT_exp emin prec) (Znearest choice) x =\n  (x * (1 + eps) + eta)%R.","proofString":"set (rx := round _ _ _ x).\nassert (Pb := u_rod1pu_ro_pos prec).\ndestruct (Rle_or_lt (bpow (emin + prec - 1)) (Rabs x)) as [MX|Mx].\ndestruct (relative_error_N_FLX'_ex prec Hp choice x) as (d, (Bd, Hd)).\nexists d, 0%R; split; [exact Bd|]; split.\nrewrite Rabs_R0; apply Rmult_le_pos; [lra|apply bpow_ge_0].\nrewrite Rplus_0_r, Rmult_0_r; split; [reflexivity|].\nnow rewrite <- Hd; apply round_FLT_FLX.\nassert (H : (Rabs (rx - x) <= /2 * bpow emin)%R).\nrefine (Rle_trans _ _ _ (error_le_half_ulp _ _ _ _) _);    [now apply FLT_exp_valid|].\nrewrite ulp_FLT_small; [now right|now simpl|].\napply (Rlt_le_trans _ _ _ Mx), bpow_le; lia.\nexists 0%R, (rx - x)%R; split; [now rewrite Rabs_R0|]; split; [exact H|].\nnow rewrite Rmult_0_l, Rplus_0_r, Rmult_1_r; split; [|ring]."},{"statement":"(x : R) (rx : R) (Pb : (0 <= u_ro prec / (1 + u_ro prec))%R) (MX : (bpow (emin + prec - 1) <= Rabs x)%R) (d : R) (Bd : (Rabs d <= u_ro prec / (1 + u_ro prec))%R) (Hd : round beta (FLX_exp prec) (Znearest choice) x = (x * (1 + d))%R) : (Rabs 0 <= / 2 * bpow emin)%R.","proofString":"rewrite Rabs_R0; apply Rmult_le_pos; [lra|apply bpow_ge_0]."},{"statement":"(x : R) (rx : R) (Pb : (0 <= u_ro prec / (1 + u_ro prec))%R) (Mx : (Rabs x < bpow (emin + prec - 1))%R) : (/ 2 * ulp beta (FLT_exp emin prec) x <= / 2 * bpow emin)%R.","proofString":"rewrite ulp_FLT_small; [now right|now simpl|].\napply (Rlt_le_trans _ _ _ Mx), bpow_le; lia."},{"statement":"(x : R) (rx : R) (Pb : (0 <= u_ro prec / (1 + u_ro prec))%R) (Mx : (Rabs x < bpow (emin + prec - 1))%R) : (Rabs x < bpow (emin + prec))%R.","proofString":"apply (Rlt_le_trans _ _ _ Mx), bpow_le; lia."},{"statement":"(x : R) (rx : R) (Pb : (0 <= u_ro prec / (1 + u_ro prec))%R) (Mx : (Rabs x < bpow (emin + prec - 1))%R) (H : (Rabs (rx - x) <= / 2 * bpow emin)%R) : exists eps eta : R,\n  (Rabs eps <= u_ro prec / (1 + u_ro prec))%R /\\\n  (Rabs eta <= / 2 * bpow emin)%R /\\\n  (eps * eta)%R = 0%R /\\ rx = (x * (1 + eps) + eta)%R.","proofString":"exists 0%R, (rx - x)%R; split; [now rewrite Rabs_R0|]; split; [exact H|].\nnow rewrite Rmult_0_l, Rplus_0_r, Rmult_1_r; split; [|ring]."},{"statement":"(x : R) (rx : R) (Pb : (0 <= u_ro prec / (1 + u_ro prec))%R) (Mx : (Rabs x < bpow (emin + prec - 1))%R) (H : (Rabs (rx - x) <= / 2 * bpow emin)%R) : (0 * (rx - x))%R = 0%R /\\ rx = (x * (1 + 0) + (rx - x))%R.","proofString":"now rewrite Rmult_0_l, Rplus_0_r, Rmult_1_r; split; [|ring]."},{"statement":"(x : R) : exists x' : R,\n  round beta (FLT_exp emin prec) (Znearest choice) x' =\n  round beta (FLT_exp emin prec) (Znearest choice) x /\\\n  (exists eta : R, (Rabs eta <= / 2 * bpow emin)%R /\\ x' = (x + eta)%R) /\\\n  (exists eps : R,\n     (Rabs eps <= u_ro prec / (1 + u_ro prec))%R /\\\n     round beta (FLT_exp emin prec) (Znearest choice) x' = (x' * (1 + eps))%R).","proofString":"set (rx := round _ _ _ x).\ndestruct (relative_error_N_FLT'_ex x) as (d, (e, (Bd, (Be, (Hde0, Hde))))).\ndestruct (Rlt_or_le (Rabs (d * x)) (Rabs e)) as [HdxLte|HeLedx].\nexists rx; split; [|split].\napply round_generic; [now apply valid_rnd_N|].\nnow apply generic_format_round; [apply FLT_exp_valid|apply valid_rnd_N].\nexists e; split; [exact Be|].\nunfold rx; rewrite Hde; destruct (Rmult_integral _ _ Hde0) as [Zd|Ze].\nnow rewrite Zd, Rplus_0_r, Rmult_1_r.\nexfalso; revert HdxLte; rewrite Ze, Rabs_R0; apply Rle_not_lt, Rabs_pos.\nexists 0%R; split; [now rewrite Rabs_R0; apply u_rod1pu_ro_pos|].\nrewrite Rplus_0_r, Rmult_1_r; apply round_generic; [now apply valid_rnd_N|].\nnow apply generic_format_round; [apply FLT_exp_valid|apply valid_rnd_N].\nexists x; split; [now simpl|split].\nexists 0%R; split;    [rewrite Rabs_R0; apply Rmult_le_pos; [lra|apply bpow_ge_0]|ring].\nexists d; rewrite Hde; destruct (Rmult_integral _ _ Hde0) as [Zd|Ze].\nsplit; [exact Bd|].\nassert (Ze : e = 0%R); [|now rewrite Ze, Rplus_0_r].\napply Rabs_eq_R0, Rle_antisym; [|now apply Rabs_pos].\nnow revert HeLedx; rewrite Zd, Rmult_0_l, Rabs_R0.\nnow rewrite Ze, Rplus_0_r."},{"statement":"(x : R) (rx : R) (d e : R) (Bd : (Rabs d <= u_ro prec / (1 + u_ro prec))%R) (Be : (Rabs e <= / 2 * bpow emin)%R) (Hde0 : (d * e)%R = 0%R) (Hde : round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + d) + e)%R) (HdxLte : (Rabs (d * x) < Rabs e)%R) (Zd : d = 0%R) : (x * (1 + d) + e)%R = (x + e)%R.","proofString":"now rewrite Zd, Rplus_0_r, Rmult_1_r."},{"statement":"(x : R) (rx : R) (d e : R) (Bd : (Rabs d <= u_ro prec / (1 + u_ro prec))%R) (Be : (Rabs e <= / 2 * bpow emin)%R) (Hde0 : (d * e)%R = 0%R) (Hde : round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + d) + e)%R) (HdxLte : (Rabs (d * x) < Rabs e)%R) (Ze : e = 0%R) : (x * (1 + d) + e)%R = (x + e)%R.","proofString":"exfalso; revert HdxLte; rewrite Ze, Rabs_R0; apply Rle_not_lt, Rabs_pos."},{"statement":"(x : R) (rx : R) (d e : R) (Bd : (Rabs d <= u_ro prec / (1 + u_ro prec))%R) (Be : (Rabs e <= / 2 * bpow emin)%R) (Hde0 : (d * e)%R = 0%R) (Hde : round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + d) + e)%R) (HeLedx : (Rabs e <= Rabs (d * x))%R) : exists eta : R, (Rabs eta <= / 2 * bpow emin)%R /\\ x = (x + eta)%R.","proofString":"exists 0%R; split;    [rewrite Rabs_R0; apply Rmult_le_pos; [lra|apply bpow_ge_0]|ring]."},{"statement":"(x : R) (rx : R) (d e : R) (Bd : (Rabs d <= u_ro prec / (1 + u_ro prec))%R) (Be : (Rabs e <= / 2 * bpow emin)%R) (Hde0 : (d * e)%R = 0%R) (Hde : round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + d) + e)%R) (HeLedx : (Rabs e <= Rabs (d * x))%R) : exists eps : R,\n  (Rabs eps <= u_ro prec / (1 + u_ro prec))%R /\\\n  round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + eps))%R.","proofString":"exists d; rewrite Hde; destruct (Rmult_integral _ _ Hde0) as [Zd|Ze].\nsplit; [exact Bd|].\nassert (Ze : e = 0%R); [|now rewrite Ze, Rplus_0_r].\napply Rabs_eq_R0, Rle_antisym; [|now apply Rabs_pos].\nnow revert HeLedx; rewrite Zd, Rmult_0_l, Rabs_R0.\nnow rewrite Ze, Rplus_0_r."},{"statement":"(x : R) (rx : R) (d e : R) (Bd : (Rabs d <= u_ro prec / (1 + u_ro prec))%R) (Be : (Rabs e <= / 2 * bpow emin)%R) (Hde0 : (d * e)%R = 0%R) (Hde : round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + d) + e)%R) (HeLedx : (Rabs e <= Rabs (d * x))%R) (Zd : d = 0%R) : (Rabs d <= u_ro prec / (1 + u_ro prec))%R /\\\n(x * (1 + d) + e)%R = (x * (1 + d))%R.","proofString":"split; [exact Bd|].\nassert (Ze : e = 0%R); [|now rewrite Ze, Rplus_0_r].\napply Rabs_eq_R0, Rle_antisym; [|now apply Rabs_pos].\nnow revert HeLedx; rewrite Zd, Rmult_0_l, Rabs_R0."},{"statement":"(x : R) (rx : R) (d e : R) (Bd : (Rabs d <= u_ro prec / (1 + u_ro prec))%R) (Be : (Rabs e <= / 2 * bpow emin)%R) (Hde0 : (d * e)%R = 0%R) (Hde : round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + d) + e)%R) (HeLedx : (Rabs e <= Rabs (d * x))%R) (Zd : d = 0%R) : (x * (1 + d) + e)%R = (x * (1 + d))%R.","proofString":"assert (Ze : e = 0%R); [|now rewrite Ze, Rplus_0_r].\napply Rabs_eq_R0, Rle_antisym; [|now apply Rabs_pos].\nnow revert HeLedx; rewrite Zd, Rmult_0_l, Rabs_R0."},{"statement":"(x : R) (rx : R) (d e : R) (Bd : (Rabs d <= u_ro prec / (1 + u_ro prec))%R) (Be : (Rabs e <= / 2 * bpow emin)%R) (Hde0 : (d * e)%R = 0%R) (Hde : round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + d) + e)%R) (HeLedx : (Rabs e <= Rabs (d * x))%R) (Zd : d = 0%R) : e = 0%R.","proofString":"apply Rabs_eq_R0, Rle_antisym; [|now apply Rabs_pos].\nnow revert HeLedx; rewrite Zd, Rmult_0_l, Rabs_R0."},{"statement":"(x : R) (rx : R) (d e : R) (Bd : (Rabs d <= u_ro prec / (1 + u_ro prec))%R) (Be : (Rabs e <= / 2 * bpow emin)%R) (Hde0 : (d * e)%R = 0%R) (Hde : round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + d) + e)%R) (HeLedx : (Rabs e <= Rabs (d * x))%R) (Zd : d = 0%R) : (Rabs e <= 0)%R.","proofString":"now revert HeLedx; rewrite Zd, Rmult_0_l, Rabs_R0."},{"statement":"(x : R) (rx : R) (d e : R) (Bd : (Rabs d <= u_ro prec / (1 + u_ro prec))%R) (Be : (Rabs e <= / 2 * bpow emin)%R) (Hde0 : (d * e)%R = 0%R) (Hde : round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + d) + e)%R) (HeLedx : (Rabs e <= Rabs (d * x))%R) (Ze : e = 0%R) : (Rabs d <= u_ro prec / (1 + u_ro prec))%R /\\\n(x * (1 + d) + e)%R = (x * (1 + d))%R.","proofString":"now rewrite Ze, Rplus_0_r."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) : exists eps eta : R,\n  (Rabs eps <= / 2 * bpow (- prec + 1))%R /\\\n  (Rabs eta <= / 2 * bpow emin)%R /\\\n  (eps * eta)%R = 0%R /\\\n  round beta (FLT_exp emin prec) (Znearest choice) x =\n  (x * (1 + eps) + eta)%R.","proofString":"destruct (Rtotal_order x 0) as [Nx|[Zx|Px]].\nassert (Pmx : (0 < - x)%R).\nnow rewrite <- Ropp_0; apply Ropp_lt_contravar.\ndestruct (@error_N_FLT_aux emin prec Pprec                             (fun t : Z => negb (choice (- (t + 1))%Z))                             (- x)%R Pmx)    as (d,(e,(Hd,(He,(Hde,Hr))))).\nexists d; exists (- e)%R; split; [exact Hd|split; [|split]].\nnow rewrite Rabs_Ropp.\nnow rewrite Ropp_mult_distr_r_reverse, <- Ropp_0; apply f_equal.\nrewrite <- (Ropp_involutive x), round_N_opp.\nnow rewrite Ropp_mult_distr_l_reverse, <- Ropp_plus_distr; apply f_equal.\nassert (Ph2 : (0 <= / 2)%R).\napply (Rmult_le_reg_l 2 _ _ Rlt_0_2).\nrewrite Rmult_0_r, Rinv_r; [exact Rle_0_1|].\napply Rgt_not_eq, Rlt_gt, Rlt_0_2.\nexists 0%R; exists 0%R; rewrite Zx; split; [|split; [|split]].\nnow rewrite Rabs_R0; apply Rmult_le_pos; [|apply bpow_ge_0].\nnow rewrite Rabs_R0; apply Rmult_le_pos; [|apply bpow_ge_0].\nnow rewrite Rmult_0_l.\nnow rewrite Rmult_0_l, Rplus_0_l, round_0; [|apply valid_rnd_N].\nnow apply error_N_FLT_aux."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Nx : (x < 0)%R) : exists eps eta : R,\n  (Rabs eps <= / 2 * bpow (- prec + 1))%R /\\\n  (Rabs eta <= / 2 * bpow emin)%R /\\\n  (eps * eta)%R = 0%R /\\\n  round beta (FLT_exp emin prec) (Znearest choice) x =\n  (x * (1 + eps) + eta)%R.","proofString":"assert (Pmx : (0 < - x)%R).\nnow rewrite <- Ropp_0; apply Ropp_lt_contravar.\ndestruct (@error_N_FLT_aux emin prec Pprec                             (fun t : Z => negb (choice (- (t + 1))%Z))                             (- x)%R Pmx)    as (d,(e,(Hd,(He,(Hde,Hr))))).\nexists d; exists (- e)%R; split; [exact Hd|split; [|split]].\nnow rewrite Rabs_Ropp.\nnow rewrite Ropp_mult_distr_r_reverse, <- Ropp_0; apply f_equal.\nrewrite <- (Ropp_involutive x), round_N_opp.\nnow rewrite Ropp_mult_distr_l_reverse, <- Ropp_plus_distr; apply f_equal."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Nx : (x < 0)%R) : (0 < - x)%R.","proofString":"now rewrite <- Ropp_0; apply Ropp_lt_contravar."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Nx : (x < 0)%R) (Pmx : (0 < - x)%R) : exists eps eta : R,\n  (Rabs eps <= / 2 * bpow (- prec + 1))%R /\\\n  (Rabs eta <= / 2 * bpow emin)%R /\\\n  (eps * eta)%R = 0%R /\\\n  round beta (FLT_exp emin prec) (Znearest choice) x =\n  (x * (1 + eps) + eta)%R.","proofString":"destruct (@error_N_FLT_aux emin prec Pprec                             (fun t : Z => negb (choice (- (t + 1))%Z))                             (- x)%R Pmx)    as (d,(e,(Hd,(He,(Hde,Hr))))).\nexists d; exists (- e)%R; split; [exact Hd|split; [|split]].\nnow rewrite Rabs_Ropp.\nnow rewrite Ropp_mult_distr_r_reverse, <- Ropp_0; apply f_equal.\nrewrite <- (Ropp_involutive x), round_N_opp.\nnow rewrite Ropp_mult_distr_l_reverse, <- Ropp_plus_distr; apply f_equal."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Nx : (x < 0)%R) (Pmx : (0 < - x)%R) (d e : R) (Hd : (Rabs d <= / 2 * bpow (- prec + 1))%R) (He : (Rabs e <= / 2 * bpow emin)%R) (Hde : (d * e)%R = 0%R) (Hr : round beta (FLT_exp emin prec)\n  (Znearest (fun t : Z => negb (choice (- (t + 1))%Z))) \n  (- x) = (- x * (1 + d) + e)%R) : exists eps eta : R,\n  (Rabs eps <= / 2 * bpow (- prec + 1))%R /\\\n  (Rabs eta <= / 2 * bpow emin)%R /\\\n  (eps * eta)%R = 0%R /\\\n  round beta (FLT_exp emin prec) (Znearest choice) x =\n  (x * (1 + eps) + eta)%R.","proofString":"exists d; exists (- e)%R; split; [exact Hd|split; [|split]].\nnow rewrite Rabs_Ropp.\nnow rewrite Ropp_mult_distr_r_reverse, <- Ropp_0; apply f_equal.\nrewrite <- (Ropp_involutive x), round_N_opp.\nnow rewrite Ropp_mult_distr_l_reverse, <- Ropp_plus_distr; apply f_equal."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Nx : (x < 0)%R) (Pmx : (0 < - x)%R) (d e : R) (Hd : (Rabs d <= / 2 * bpow (- prec + 1))%R) (He : (Rabs e <= / 2 * bpow emin)%R) (Hde : (d * e)%R = 0%R) (Hr : round beta (FLT_exp emin prec)\n  (Znearest (fun t : Z => negb (choice (- (t + 1))%Z))) \n  (- x) = (- x * (1 + d) + e)%R) : (Rabs (- e) <= / 2 * bpow emin)%R.","proofString":"now rewrite Rabs_Ropp."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Nx : (x < 0)%R) (Pmx : (0 < - x)%R) (d e : R) (Hd : (Rabs d <= / 2 * bpow (- prec + 1))%R) (He : (Rabs e <= / 2 * bpow emin)%R) (Hde : (d * e)%R = 0%R) (Hr : round beta (FLT_exp emin prec)\n  (Znearest (fun t : Z => negb (choice (- (t + 1))%Z))) \n  (- x) = (- x * (1 + d) + e)%R) : (d * - e)%R = 0%R.","proofString":"now rewrite Ropp_mult_distr_r_reverse, <- Ropp_0; apply f_equal."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Nx : (x < 0)%R) (Pmx : (0 < - x)%R) (d e : R) (Hd : (Rabs d <= / 2 * bpow (- prec + 1))%R) (He : (Rabs e <= / 2 * bpow emin)%R) (Hde : (d * e)%R = 0%R) (Hr : round beta (FLT_exp emin prec)\n  (Znearest (fun t : Z => negb (choice (- (t + 1))%Z))) \n  (- x) = (- x * (1 + d) + e)%R) : round beta (FLT_exp emin prec) (Znearest choice) x = (x * (1 + d) + - e)%R.","proofString":"rewrite <- (Ropp_involutive x), round_N_opp.\nnow rewrite Ropp_mult_distr_l_reverse, <- Ropp_plus_distr; apply f_equal."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Nx : (x < 0)%R) (Pmx : (0 < - x)%R) (d e : R) (Hd : (Rabs d <= / 2 * bpow (- prec + 1))%R) (He : (Rabs e <= / 2 * bpow emin)%R) (Hde : (d * e)%R = 0%R) (Hr : round beta (FLT_exp emin prec)\n  (Znearest (fun t : Z => negb (choice (- (t + 1))%Z))) \n  (- x) = (- x * (1 + d) + e)%R) : (-\n round beta (FLT_exp emin prec)\n   (Znearest (fun t : Z => negb (choice (- (t + 1))%Z))) \n   (- x))%R = (- - x * (1 + d) + - e)%R.","proofString":"now rewrite Ropp_mult_distr_l_reverse, <- Ropp_plus_distr; apply f_equal."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Zx : x = 0%R) : exists eps eta : R,\n  (Rabs eps <= / 2 * bpow (- prec + 1))%R /\\\n  (Rabs eta <= / 2 * bpow emin)%R /\\\n  (eps * eta)%R = 0%R /\\\n  round beta (FLT_exp emin prec) (Znearest choice) x =\n  (x * (1 + eps) + eta)%R.","proofString":"assert (Ph2 : (0 <= / 2)%R).\napply (Rmult_le_reg_l 2 _ _ Rlt_0_2).\nrewrite Rmult_0_r, Rinv_r; [exact Rle_0_1|].\napply Rgt_not_eq, Rlt_gt, Rlt_0_2.\nexists 0%R; exists 0%R; rewrite Zx; split; [|split; [|split]].\nnow rewrite Rabs_R0; apply Rmult_le_pos; [|apply bpow_ge_0].\nnow rewrite Rabs_R0; apply Rmult_le_pos; [|apply bpow_ge_0].\nnow rewrite Rmult_0_l.\nnow rewrite Rmult_0_l, Rplus_0_l, round_0; [|apply valid_rnd_N]."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Zx : x = 0%R) : (0 <= / 2)%R.","proofString":"apply (Rmult_le_reg_l 2 _ _ Rlt_0_2).\nrewrite Rmult_0_r, Rinv_r; [exact Rle_0_1|].\napply Rgt_not_eq, Rlt_gt, Rlt_0_2."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Zx : x = 0%R) : (2 * 0 <= 2 * / 2)%R.","proofString":"rewrite Rmult_0_r, Rinv_r; [exact Rle_0_1|].\napply Rgt_not_eq, Rlt_gt, Rlt_0_2."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Zx : x = 0%R) : 2%R <> 0%R.","proofString":"apply Rgt_not_eq, Rlt_gt, Rlt_0_2."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Zx : x = 0%R) (Ph2 : (0 <= / 2)%R) : exists eps eta : R,\n  (Rabs eps <= / 2 * bpow (- prec + 1))%R /\\\n  (Rabs eta <= / 2 * bpow emin)%R /\\\n  (eps * eta)%R = 0%R /\\\n  round beta (FLT_exp emin prec) (Znearest choice) x =\n  (x * (1 + eps) + eta)%R.","proofString":"exists 0%R; exists 0%R; rewrite Zx; split; [|split; [|split]].\nnow rewrite Rabs_R0; apply Rmult_le_pos; [|apply bpow_ge_0].\nnow rewrite Rabs_R0; apply Rmult_le_pos; [|apply bpow_ge_0].\nnow rewrite Rmult_0_l.\nnow rewrite Rmult_0_l, Rplus_0_l, round_0; [|apply valid_rnd_N]."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Zx : x = 0%R) (Ph2 : (0 <= / 2)%R) : (Rabs 0 <= / 2 * bpow (- prec + 1))%R.","proofString":"now rewrite Rabs_R0; apply Rmult_le_pos; [|apply bpow_ge_0]."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Zx : x = 0%R) (Ph2 : (0 <= / 2)%R) : (Rabs 0 <= / 2 * bpow emin)%R.","proofString":"now rewrite Rabs_R0; apply Rmult_le_pos; [|apply bpow_ge_0]."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Zx : x = 0%R) (Ph2 : (0 <= / 2)%R) : (0 * 0)%R = 0%R.","proofString":"now rewrite Rmult_0_l."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Zx : x = 0%R) (Ph2 : (0 <= / 2)%R) : round beta (FLT_exp emin prec) (Znearest choice) 0 = (0 * (1 + 0) + 0)%R.","proofString":"now rewrite Rmult_0_l, Rplus_0_l, round_0; [|apply valid_rnd_N]."},{"statement":"(emin prec : Z) (Pprec : (0 < prec)%Z) (choice : Z -> bool) (x : R) (Px : (x > 0)%R) : exists eps eta : R,\n  (Rabs eps <= / 2 * bpow (- prec + 1))%R /\\\n  (Rabs eta <= / 2 * bpow emin)%R /\\\n  (eps * eta)%R = 0%R /\\\n  round beta (FLT_exp emin prec) (Znearest choice) x =\n  (x * (1 + eps) + eta)%R.","proofString":"now apply error_N_FLT_aux."}]}