{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/imm/Rel_opt.v","fileSamples":[{"statement":"(x y : actid) (H : sb x y) (H2 : ~ rmw x y) (H0 : is_w lab y) (H1 : is_rel lab y) : exists z : actid, (x = z \\/ sb x z) /\\ (is_f lab z /\\ is_rel lab z) /\\ sb z y.","proofString":"assert( (sb^? ⨾ ⦗F∩₁Rel⦘ ⨾ sb ∪ rmw) x y).\napply W_REL; basic_solver.\nclear W_REL.\nunfolder in *; desf; eauto 10."},{"statement":"(x y : actid) (H : sb x y) (H2 : ~ rmw x y) (H0 : is_w lab y) (H1 : is_rel lab y) : (sb^? ⨾ ⦗F ∩₁ Rel⦘ ⨾ sb ∪ rmw) x y.","proofString":"apply W_REL; basic_solver."},{"statement":"(x y : actid) (H : sb x y) (H2 : ~ rmw x y) (H0 : is_w lab y) (H1 : is_rel lab y) (H3 : (sb^? ⨾ ⦗F ∩₁ Rel⦘ ⨾ sb ∪ rmw) x y) : exists z : actid, (x = z \\/ sb x z) /\\ (is_f lab z /\\ is_rel lab z) /\\ sb z y.","proofString":"clear W_REL.\nunfolder in *; desf; eauto 10."},{"statement":"(x y : actid) (H : sb x y) (H2 : ~ rmw x y) (H0 : is_w lab y) (H1 : is_rel lab y) (H3 : (sb^? ⨾ ⦗F ∩₁ Rel⦘ ⨾ sb ∪ rmw) x y) : exists z : actid, (x = z \\/ sb x z) /\\ (is_f lab z /\\ is_rel lab z) /\\ sb z y.","proofString":"unfolder in *; desf; eauto 10."},{"statement":"(fun a : actid => match lab a with\n                  | Afence _ => true\n                  | _ => false\n                  end)\n∩₁ (fun a : actid =>\n    match\n      match\n        match lab a with\n        | Astore xm Opln _ _ | Astore xm Orlx _ _ | Astore xm Oacq _ _ =>\n            lab a\n        | Astore xm Orel x v | Astore xm Oacqrel x v | Astore xm Osc x v =>\n            Astore xm Orlx x v\n        | _ => lab a\n        end\n      with\n      | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n      end\n    with\n    | Opln | Orlx | Orel => false\n    | _ => true\n    end\n    || match\n         match\n           match lab a with\n           | Astore xm Opln _ _ | Astore xm Orlx _ _ | Astore xm Oacq _ _ =>\n               lab a\n           | Astore xm Orel x v | Astore xm Oacqrel x v |\n             Astore xm Osc x v => Astore xm Orlx x v\n           | _ => lab a\n           end\n         with\n         | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n         end\n       with\n       | Opln | Orlx | Oacq => false\n       | _ => true\n       end)\n≡₁ (fun a : actid => match lab a with\n                     | Afence _ => true\n                     | _ => false\n                     end)\n   ∩₁ (fun a : actid =>\n       match\n         match lab a with\n         | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n         end\n       with\n       | Opln | Orlx | Orel => false\n       | _ => true\n       end\n       || match\n            match lab a with\n            | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n            end\n          with\n          | Opln | Orlx | Oacq => false\n          | _ => true\n          end).","proofString":"unfolder; ins; split; ins; desf; splits; eauto."},{"statement":"F' ∩₁ (Rel \\₁ W ∩₁ Rel) ≡₁ F ∩₁ Rel.","proofString":"rewrite F_eq.\nsplit; [basic_solver|].\nunfolder.\nins.\ndesf.\nsplits; auto.\nintros HH.\ntype_solver."},{"statement":"F ∩₁ (Rel \\₁ W ∩₁ Rel) ≡₁ F ∩₁ Rel.","proofString":"split; [basic_solver|].\nunfolder.\nins.\ndesf.\nsplits; auto.\nintros HH.\ntype_solver."},{"statement":"F ∩₁ Rel ⊆₁ F ∩₁ (Rel \\₁ W ∩₁ Rel).","proofString":"unfolder.\nins.\ndesf.\nsplits; auto.\nintros HH.\ntype_solver."},{"statement":"forall x : actid,\nis_f lab x /\\ is_rel lab x ->\nis_f lab x /\\ is_rel lab x /\\ ~ (is_w lab x /\\ is_rel lab x).","proofString":"ins.\ndesf.\nsplits; auto.\nintros HH.\ntype_solver."},{"statement":"(x : actid) (H : is_f lab x /\\ is_rel lab x) : is_f lab x /\\ is_rel lab x /\\ ~ (is_w lab x /\\ is_rel lab x).","proofString":"desf.\nsplits; auto.\nintros HH.\ntype_solver."},{"statement":"(x : actid) (H : is_f lab x) (H0 : is_rel lab x) : true /\\ true /\\ ~ (is_w lab x /\\ true).","proofString":"splits; auto.\nintros HH.\ntype_solver."},{"statement":"(x : actid) (H : is_f lab x) (H0 : is_rel lab x) : ~ (is_w lab x /\\ true).","proofString":"intros HH.\ntype_solver."},{"statement":"(x : actid) (H : is_f lab x) (H0 : is_rel lab x) (HH : is_w lab x /\\ true) : False.","proofString":"type_solver."},{"statement":"(fun a : actid =>\n match\n   match lab a with\n   | Astore xm Opln _ _ | Astore xm Orlx _ _ | Astore xm Oacq _ _ => lab a\n   | Astore xm Orel x v | Astore xm Oacqrel x v | Astore xm Osc x v =>\n       Astore xm Orlx x v\n   | _ => lab a\n   end\n with\n | Afence _ => true\n | _ => false\n end)\n∩₁ (fun a : actid =>\n    match\n      match\n        match lab a with\n        | Astore xm Opln _ _ | Astore xm Orlx _ _ | Astore xm Oacq _ _ =>\n            lab a\n        | Astore xm Orel x v | Astore xm Oacqrel x v | Astore xm Osc x v =>\n            Astore xm Orlx x v\n        | _ => lab a\n        end\n      with\n      | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n      end\n    with\n    | Osc => true\n    | _ => false\n    end)\n≡₁ (fun a : actid => match lab a with\n                     | Afence _ => true\n                     | _ => false\n                     end)\n   ∩₁ (fun a : actid =>\n       match\n         match lab a with\n         | Aload _ o _ _ | Astore _ o _ _ | Afence o => o\n         end\n       with\n       | Osc => true\n       | _ => false\n       end).","proofString":"unfolder; ins; split; ins; desf; splits; eauto."},{"statement":"Acq' ∪₁ W' ≡₁ FR' ∩₁ Acq' ∪₁ W'.","proofString":"split; [|basic_solver].\nunionL; [|eauto with hahn].\ntype_solver 10."},{"statement":"Acq' ∪₁ W' ⊆₁ FR' ∩₁ Acq' ∪₁ W'.","proofString":"unionL; [|eauto with hahn].\ntype_solver 10."},{"statement":"Acq' ⊆₁ FR' ∩₁ Acq' ∪₁ W'.","proofString":"type_solver 10."},{"statement":"FR' ∩₁ Acq' ∪₁ W' ≡₁ Acq ∪₁ W.","proofString":"arewrite (Acq∪₁W ≡₁ (FR∩₁Acq)∪₁W).\nsplit; [|basic_solver].\nunionL; [|eauto with hahn].\ntype_solver 10.\nrewrite <- FR_Acq_eq, <- R_eq, <- F_eq, <- W_eq.\ndone."},{"statement":"Acq ∪₁ W ≡₁ FR ∩₁ Acq ∪₁ W.","proofString":"split; [|basic_solver].\nunionL; [|eauto with hahn].\ntype_solver 10."},{"statement":"Acq ∪₁ W ⊆₁ FR ∩₁ Acq ∪₁ W.","proofString":"unionL; [|eauto with hahn].\ntype_solver 10."},{"statement":"Acq ⊆₁ FR ∩₁ Acq ∪₁ W.","proofString":"type_solver 10."},{"statement":"FR' ∩₁ Acq' ∪₁ W' ≡₁ FR ∩₁ Acq ∪₁ W.","proofString":"rewrite <- FR_Acq_eq, <- R_eq, <- F_eq, <- W_eq.\ndone."},{"statement":"FR' ∩₁ Acq' ∪₁ W' ≡₁ FR' ∩₁ Acq' ∪₁ W'.","proofString":"done."},{"statement":"(fun x y : actid =>\n match\n   match lab x with\n   | Astore xm Opln _ _ | Astore xm Orlx _ _ | Astore xm Oacq _ _ => lab x\n   | Astore xm Orel x0 v | Astore xm Oacqrel x0 v | Astore xm Osc x0 v =>\n       Astore xm Orlx x0 v\n   | _ => lab x\n   end\n with\n | Aload _ _ l _ | Astore _ _ l _ => Some l\n | Afence _ => None\n end =\n match\n   match lab y with\n   | Astore xm Opln _ _ | Astore xm Orlx _ _ | Astore xm Oacq _ _ => lab y\n   | Astore xm Orel x0 v | Astore xm Oacqrel x0 v | Astore xm Osc x0 v =>\n       Astore xm Orlx x0 v\n   | _ => lab y\n   end\n with\n | Aload _ _ l _ | Astore _ _ l _ => Some l\n | Afence _ => None\n end)\n≡ (fun x y : actid =>\n   match lab x with\n   | Aload _ _ l _ | Astore _ _ l _ => Some l\n   | Afence _ => None\n   end =\n   match lab y with\n   | Aload _ _ l _ | Astore _ _ l _ => Some l\n   | Afence _ => None\n   end).","proofString":"type_solver 22."},{"statement":"sb ⨾ ⦗W ∩₁ Rel⦘ ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ sb ⨾ ⦗F ∩₁ Acq/Rel⦘\n∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb\n⊆ (sb' ⨾ ⦗W' ∩₁ Rel'⦘ ∪ ⦗W' ∩₁ Rel'⦘ ⨾ sb' ∩ same_loc' ⨾ ⦗W'⦘\n   ∪ sb' ⨾ ⦗F' ∩₁ Acq/Rel'⦘ ∪ ⦗F' ∩₁ Acq/Rel'⦘ ⨾ sb' ∪ \n   ⦗R' ∩₁ Acq'⦘ ⨾ sb')⁺ ∪ rmw' ∪ ⦗W ∩₁ Rel⦘ ⨾ sb' ∩ same_loc' ⨾ ⦗W'⦘.","proofString":"rewrite F_eq, R_eq, W_eq, Rel_eq, sb_eq, F_AcqRel_eq, R_Acq_eq, same_loc_eq.\nunionL.\nrewrite W_REL; unionL.\narewrite (⦗F ∩₁ Rel⦘ ⊆ ⦗F ∩₁ Acq/Rel⦘) by mode_solver.\ncase_refl _.\nby unionR left -> left; unfolder; econs; eauto.\nunionR left -> left.\nunfolder; ins; desf; eapply t_trans; eapply t_step; eauto 20.\nrewrite rmw_eq; basic_solver.\nbasic_solver 12.\nunionR left -> left; unfolder; ins; eapply t_step; basic_solver 12.\nunionR left -> left; unfolder; ins; eapply t_step; basic_solver 12.\nunionR left -> left; unfolder; ins; eapply t_step; basic_solver 12."},{"statement":"sb ⨾ ⦗W ∩₁ Rel⦘ ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ sb ⨾ ⦗F ∩₁ Acq/Rel⦘\n∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb\n⊆ (sb ⨾ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘\n   ∪ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ \n   sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb)⁺ ∪ rmw'\n  ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘.","proofString":"unionL.\nrewrite W_REL; unionL.\narewrite (⦗F ∩₁ Rel⦘ ⊆ ⦗F ∩₁ Acq/Rel⦘) by mode_solver.\ncase_refl _.\nby unionR left -> left; unfolder; econs; eauto.\nunionR left -> left.\nunfolder; ins; desf; eapply t_trans; eapply t_step; eauto 20.\nrewrite rmw_eq; basic_solver.\nbasic_solver 12.\nunionR left -> left; unfolder; ins; eapply t_step; basic_solver 12.\nunionR left -> left; unfolder; ins; eapply t_step; basic_solver 12.\nunionR left -> left; unfolder; ins; eapply t_step; basic_solver 12."},{"statement":"sb ⨾ ⦗W ∩₁ Rel⦘\n⊆ (sb ⨾ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘\n   ∪ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ \n   sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb)⁺ ∪ rmw'\n  ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘.","proofString":"rewrite W_REL; unionL.\narewrite (⦗F ∩₁ Rel⦘ ⊆ ⦗F ∩₁ Acq/Rel⦘) by mode_solver.\ncase_refl _.\nby unionR left -> left; unfolder; econs; eauto.\nunionR left -> left.\nunfolder; ins; desf; eapply t_trans; eapply t_step; eauto 20.\nrewrite rmw_eq; basic_solver."},{"statement":"sb^? ⨾ ⦗F ∩₁ Rel⦘ ⨾ sb\n⊆ (sb ⨾ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘\n   ∪ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ \n   sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb)⁺ ∪ rmw'\n  ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘.","proofString":"arewrite (⦗F ∩₁ Rel⦘ ⊆ ⦗F ∩₁ Acq/Rel⦘) by mode_solver.\ncase_refl _.\nby unionR left -> left; unfolder; econs; eauto.\nunionR left -> left.\nunfolder; ins; desf; eapply t_trans; eapply t_step; eauto 20."},{"statement":"sb^? ⨾ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb\n⊆ (sb ⨾ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘\n   ∪ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ \n   sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb)⁺ ∪ rmw'\n  ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘.","proofString":"case_refl _.\nby unionR left -> left; unfolder; econs; eauto.\nunionR left -> left.\nunfolder; ins; desf; eapply t_trans; eapply t_step; eauto 20."},{"statement":"⦗F ∩₁ Acq/Rel⦘ ⨾ sb\n⊆ (sb ⨾ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘\n   ∪ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ \n   sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb)⁺ ∪ rmw'\n  ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘.","proofString":"by unionR left -> left; unfolder; econs; eauto."},{"statement":"sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb\n⊆ (sb ⨾ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘\n   ∪ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ \n   sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb)⁺ ∪ rmw'\n  ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘.","proofString":"unionR left -> left.\nunfolder; ins; desf; eapply t_trans; eapply t_step; eauto 20."},{"statement":"sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb\n⊆ (sb ⨾ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘\n   ∪ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ \n   sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb)⁺.","proofString":"unfolder; ins; desf; eapply t_trans; eapply t_step; eauto 20."},{"statement":"rmw\n⊆ (sb ⨾ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘\n   ∪ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ \n   sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb)⁺ ∪ rmw'\n  ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘.","proofString":"rewrite rmw_eq; basic_solver."},{"statement":"⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘\n⊆ (sb ⨾ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘\n   ∪ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ \n   sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb)⁺ ∪ rmw'\n  ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘.","proofString":"basic_solver 12."},{"statement":"sb ⨾ ⦗F ∩₁ Acq/Rel⦘\n⊆ (sb ⨾ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘\n   ∪ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ \n   sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb)⁺ ∪ rmw'\n  ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘.","proofString":"unionR left -> left; unfolder; ins; eapply t_step; basic_solver 12."},{"statement":"⦗F ∩₁ Acq/Rel⦘ ⨾ sb\n⊆ (sb ⨾ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘\n   ∪ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ \n   sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb)⁺ ∪ rmw'\n  ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘.","proofString":"unionR left -> left; unfolder; ins; eapply t_step; basic_solver 12."},{"statement":"⦗R ∩₁ Acq⦘ ⨾ sb\n⊆ (sb ⨾ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘\n   ∪ ⦗W ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘ ∪ \n   sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ∪ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ∪ ⦗R ∩₁ Acq⦘ ⨾ sb)⁺ ∪ rmw'\n  ∪ ⦗W ∩₁ Rel⦘ ⨾ sb ∩ same_loc ⨾ ⦗W⦘.","proofString":"unionR left -> left; unfolder; ins; eapply t_step; basic_solver 12."},{"statement":"⦗R'⦘\n⨾ (data' ∪ ctrl' ∪ addr' ⨾ sb'^? ∪ rf' ∩ sb' ∪ rmw' ⨾ sb'^? ∪ ⦗R_ex'⦘ ⨾ sb'\n   ∪ rmw_dep')⁺ ⨾ ⦗W'⦘\n≡ ⦗R⦘\n  ⨾ (data ∪ ctrl ∪ addr ⨾ sb^? ∪ rf ∩ sb ∪ rmw ⨾ sb^? ∪ ⦗R_ex⦘ ⨾ sb ∪ rmw_dep)⁺\n    ⨾ ⦗W⦘.","proofString":"by rewrite W_eq, R_eq, sb_eq, data_eq, addr_eq, ctrl_eq, rf_eq, R_ex_eq."},{"statement":"((co' \\ sb') ⨾ (rf' \\ sb')) ∩ sb' ≡ ((co \\ sb) ⨾ (rf \\ sb)) ∩ sb.","proofString":"by rewrite sb_eq, rf_eq, co_eq."},{"statement":"(WF : Wf G) (WFp : Wf G') : rmw ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs ⊆ rmw' ⨾ rs'.","proofString":"rewrite (dom_r (wf_rmwD WF)), !seqA.\narewrite_id (⦗W⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\nby type_solver.\nrewrite rmw_eq.\nrewrite rs_eq.\nbasic_solver."},{"statement":"(WF : Wf G) (WFp : Wf G') : rmw ⨾ ⦗W⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs ⊆ rmw' ⨾ rs'.","proofString":"arewrite_id (⦗W⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^?).\nby type_solver.\nrewrite rmw_eq.\nrewrite rs_eq.\nbasic_solver."},{"statement":"(WF : Wf G) (WFp : Wf G') : ⦗W⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⊆ ⦗fun _ : actid => True⦘.","proofString":"by type_solver."},{"statement":"(WF : Wf G) (WFp : Wf G') : rmw ⨾ ⦗fun _ : actid => True⦘ ⨾ rs ⊆ rmw' ⨾ rs'.","proofString":"rewrite rmw_eq.\nrewrite rs_eq.\nbasic_solver."},{"statement":"(WF : Wf G) (WFp : Wf G') : rmw ⨾ ⦗fun _ : actid => True⦘ ⨾ rs ⊆ rmw ⨾ rs'.","proofString":"rewrite rs_eq.\nbasic_solver."},{"statement":"(WF : Wf G) (WFp : Wf G') : rmw ⨾ ⦗fun _ : actid => True⦘ ⨾ rs ⊆ rmw ⨾ rs.","proofString":"basic_solver."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb \\ rmw) ⨾ ⦗FW ∩₁ Rel⦘ ⨾ release ⊆ sb'^? ⨾ release'.","proofString":"rewrite (dom_l (wf_releaseD WFp)).\nunfold imm_hb.release; rewrite sb_eq, rs_eq, F_eq, Rel_eq, W_eq.\narewrite (⦗FW ∩₁ Rel⦘ ⨾ ⦗Rel⦘ ≡ ⦗F ∩₁ Rel⦘ ∪ ⦗W ∩₁ Rel⦘) by basic_solver 12.\narewrite (⦗FW ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ ⦗Rel \\₁ W ∩₁ Rel⦘ ≡ ⦗F ∩₁ Rel⦘).\nunfolder; split; ins; desf; splits; eauto.\ntauto.\nintro; unfold is_w, is_f in *; desf.\nintro; unfold is_w, is_f in *; desf.\nrelsf.\narewrite (⦗W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⊆ ⦗W ∩₁ Rel⦘) by type_solver 12.\nsin_rewrite non_rmw_w_rel; basic_solver 22."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb \\ rmw) ⨾ ⦗FW ∩₁ Rel⦘ ⨾ release ⊆ sb'^? ⨾ ⦗FW' ∩₁ Rel'⦘ ⨾ release'.","proofString":"unfold imm_hb.release; rewrite sb_eq, rs_eq, F_eq, Rel_eq, W_eq.\narewrite (⦗FW ∩₁ Rel⦘ ⨾ ⦗Rel⦘ ≡ ⦗F ∩₁ Rel⦘ ∪ ⦗W ∩₁ Rel⦘) by basic_solver 12.\narewrite (⦗FW ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ ⦗Rel \\₁ W ∩₁ Rel⦘ ≡ ⦗F ∩₁ Rel⦘).\nunfolder; split; ins; desf; splits; eauto.\ntauto.\nintro; unfold is_w, is_f in *; desf.\nintro; unfold is_w, is_f in *; desf.\nrelsf.\narewrite (⦗W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⊆ ⦗W ∩₁ Rel⦘) by type_solver 12.\nsin_rewrite non_rmw_w_rel; basic_solver 22."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb \\ rmw) ⨾ ⦗FW ∩₁ Rel⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs\n⊆ sb^? ⨾ ⦗FW ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ ⦗Rel \\₁ W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs.","proofString":"arewrite (⦗FW ∩₁ Rel⦘ ⨾ ⦗Rel⦘ ≡ ⦗F ∩₁ Rel⦘ ∪ ⦗W ∩₁ Rel⦘) by basic_solver 12.\narewrite (⦗FW ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ ⦗Rel \\₁ W ∩₁ Rel⦘ ≡ ⦗F ∩₁ Rel⦘).\nunfolder; split; ins; desf; splits; eauto.\ntauto.\nintro; unfold is_w, is_f in *; desf.\nintro; unfold is_w, is_f in *; desf.\nrelsf.\narewrite (⦗W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⊆ ⦗W ∩₁ Rel⦘) by type_solver 12.\nsin_rewrite non_rmw_w_rel; basic_solver 22."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb \\ rmw) ⨾ (⦗F ∩₁ Rel⦘ ∪ ⦗W ∩₁ Rel⦘) ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs\n⊆ sb^? ⨾ ⦗FW ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ ⦗Rel \\₁ W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs.","proofString":"arewrite (⦗FW ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ ⦗Rel \\₁ W ∩₁ Rel⦘ ≡ ⦗F ∩₁ Rel⦘).\nunfolder; split; ins; desf; splits; eauto.\ntauto.\nintro; unfold is_w, is_f in *; desf.\nintro; unfold is_w, is_f in *; desf.\nrelsf.\narewrite (⦗W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⊆ ⦗W ∩₁ Rel⦘) by type_solver 12.\nsin_rewrite non_rmw_w_rel; basic_solver 22."},{"statement":"(WF : Wf G) (WFp : Wf G') : ⦗FW ∩₁ (Rel \\₁ W ∩₁ Rel)⦘ ⨾ ⦗Rel \\₁ W ∩₁ Rel⦘ ≡ ⦗F ∩₁ Rel⦘.","proofString":"unfolder; split; ins; desf; splits; eauto.\ntauto.\nintro; unfold is_w, is_f in *; desf.\nintro; unfold is_w, is_f in *; desf."},{"statement":"(WF : Wf G) (WFp : Wf G') (y : actid) (H2 : ~ (true /\\ true)) (H1 : true) (H4 : ~ (true /\\ true)) (H3 : is_rel lab y) (H0 : is_w lab y) : is_f lab y.","proofString":"tauto."},{"statement":"(WF : Wf G) (WFp : Wf G') (y : actid) (H1 : is_rel lab y) (H0 : is_f lab y) : ~ (is_w lab y /\\ true).","proofString":"intro; unfold is_w, is_f in *; desf."},{"statement":"(WF : Wf G) (WFp : Wf G') (y : actid) (H1 : is_rel lab y) (H0 : is_f lab y) : ~ (is_w lab y /\\ true).","proofString":"intro; unfold is_w, is_f in *; desf."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb \\ rmw) ⨾ (⦗F ∩₁ Rel⦘ ∪ ⦗W ∩₁ Rel⦘) ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs\n⊆ sb^? ⨾ ⦗F ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs.","proofString":"relsf.\narewrite (⦗W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⊆ ⦗W ∩₁ Rel⦘) by type_solver 12.\nsin_rewrite non_rmw_w_rel; basic_solver 22."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb \\ rmw) ⨾ ⦗F ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs\n∪ (sb \\ rmw) ⨾ ⦗W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs\n⊆ sb^? ⨾ ⦗F ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs.","proofString":"arewrite (⦗W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⊆ ⦗W ∩₁ Rel⦘) by type_solver 12.\nsin_rewrite non_rmw_w_rel; basic_solver 22."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb \\ rmw) ⨾ ⦗F ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs ∪ (sb \\ rmw) ⨾ ⦗W ∩₁ Rel⦘ ⨾ rs\n⊆ sb^? ⨾ ⦗F ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs.","proofString":"sin_rewrite non_rmw_w_rel; basic_solver 22."},{"statement":"(WF : Wf G) : ⦗F⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs ⊆ ⦗Rel \\₁ W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ rs.","proofString":"rewrite (dom_l (wf_rsD WF)).\ncase_refl _; [type_solver 12|].\narewrite (⦗F⦘ ⨾ ⦗Rel⦘ ⊆ ⦗Rel \\₁ W ∩₁ Rel⦘).\nby unfolder; ins; desf; splits; eauto; intro; desf; type_solver.\nbasic_solver 12."},{"statement":"(WF : Wf G) : ⦗F⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ ⦗W⦘ ⨾ rs\n⊆ ⦗Rel \\₁ W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ ⦗W⦘ ⨾ rs.","proofString":"case_refl _; [type_solver 12|].\narewrite (⦗F⦘ ⨾ ⦗Rel⦘ ⊆ ⦗Rel \\₁ W ∩₁ Rel⦘).\nby unfolder; ins; desf; splits; eauto; intro; desf; type_solver.\nbasic_solver 12."},{"statement":"(WF : Wf G) : ⦗F⦘ ⨾ ⦗Rel⦘ ⨾ (⦗F⦘ ⨾ sb) ⨾ ⦗W⦘ ⨾ rs\n⊆ ⦗Rel \\₁ W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ ⦗W⦘ ⨾ rs.","proofString":"arewrite (⦗F⦘ ⨾ ⦗Rel⦘ ⊆ ⦗Rel \\₁ W ∩₁ Rel⦘).\nby unfolder; ins; desf; splits; eauto; intro; desf; type_solver.\nbasic_solver 12."},{"statement":"(WF : Wf G) : ⦗F⦘ ⨾ ⦗Rel⦘ ⊆ ⦗Rel \\₁ W ∩₁ Rel⦘.","proofString":"by unfolder; ins; desf; splits; eauto; intro; desf; type_solver."},{"statement":"(WF : Wf G) : ⦗Rel \\₁ W ∩₁ Rel⦘ ⨾ ⦗F⦘ ⨾ sb ⨾ ⦗W⦘ ⨾ rs\n⊆ ⦗Rel \\₁ W ∩₁ Rel⦘ ⨾ (⦗F⦘ ⨾ sb)^? ⨾ ⦗W⦘ ⨾ rs.","proofString":"basic_solver 12."},{"statement":"(WF : Wf G) : (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘\n⊆ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq'⦘.","proofString":"arewrite ((rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⊆ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ ⦗R⦘).\nrewrite (dom_r (wf_rfeD WF)) at 1.\nrewrite (dom_r (wf_rfiD WF)) at 1.\nbasic_solver 12.\narewrite (⦗R⦘ ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⊆ ⦗R⦘ ⨾ (sb ⨾ ⦗F⦘)^? ⨾  ⦗FR∩₁Acq⦘) by basic_solver 21.\nrewrite <- FR_Acq_eq; basic_solver 42."},{"statement":"(WF : Wf G) : rfi ∪ (sb ∩ same_loc)^? ⨾ rfe ⊆ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ ⦗R⦘.","proofString":"rewrite (dom_r (wf_rfeD WF)) at 1.\nrewrite (dom_r (wf_rfiD WF)) at 1.\nbasic_solver 12."},{"statement":"(WF : Wf G) : rfi ∪ (sb ∩ same_loc)^? ⨾ rfe ⨾ ⦗R⦘ ⊆ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ ⦗R⦘.","proofString":"rewrite (dom_r (wf_rfiD WF)) at 1.\nbasic_solver 12."},{"statement":"(WF : Wf G) : rfi ⨾ ⦗R⦘ ∪ (sb ∩ same_loc)^? ⨾ rfe ⨾ ⦗R⦘\n⊆ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ ⦗R⦘.","proofString":"basic_solver 12."},{"statement":"(WF : Wf G) : (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ ⦗R⦘ ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘\n⊆ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq'⦘.","proofString":"arewrite (⦗R⦘ ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘ ⊆ ⦗R⦘ ⨾ (sb ⨾ ⦗F⦘)^? ⨾  ⦗FR∩₁Acq⦘) by basic_solver 21.\nrewrite <- FR_Acq_eq; basic_solver 42."},{"statement":"(WF : Wf G) : (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ ⦗R⦘ ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗FR ∩₁ Acq⦘\n⊆ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq'⦘.","proofString":"rewrite <- FR_Acq_eq; basic_solver 42."},{"statement":"(WF : Wf G) : ⦗F⦘ ⨾ release ⨾ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘\n⊆ release' ⨾ (rfi' ∪ (sb' ∩ same_loc')^? ⨾ rfe') ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘.","proofString":"sin_rewrite (F_release_eq WF).\nby sin_rewrite (sw_eq_helper WF)."},{"statement":"(WF : Wf G) : release' ⨾ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘\n⊆ release' ⨾ (rfi' ∪ (sb' ∩ same_loc')^? ⨾ rfe') ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘.","proofString":"by sin_rewrite (sw_eq_helper WF)."},{"statement":"(WF : Wf G) (WFp : Wf G') : rmw ⨾ release ⨾ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘\n⊆ rmw' ⨾ rs' ⨾ (rfi' ∪ (sb' ∩ same_loc')^? ⨾ rfe') ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘.","proofString":"sin_rewrite !(rmw_release_eq WF WFp).\nsin_rewrite (sw_eq_helper WF).\nby relsf; rewrite !seqA."},{"statement":"(WF : Wf G) (WFp : Wf G') : (rmw' ⨾ rs') ⨾ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘\n⊆ rmw' ⨾ rs' ⨾ (rfi' ∪ (sb' ∩ same_loc')^? ⨾ rfe') ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘.","proofString":"sin_rewrite (sw_eq_helper WF).\nby relsf; rewrite !seqA."},{"statement":"(WF : Wf G) (WFp : Wf G') : (rmw' ⨾ rs') ⨾ (rfi' ∪ (sb' ∩ same_loc')^? ⨾ rfe') ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘\n⊆ rmw' ⨾ rs' ⨾ (rfi' ∪ (sb' ∩ same_loc')^? ⨾ rfe') ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘.","proofString":"by relsf; rewrite !seqA."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb \\ rmw) ⨾ release ⨾ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘\n⊆ sb'^?\n  ⨾ release' ⨾ (rfi' ∪ (sb' ∩ same_loc')^? ⨾ rfe') ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘.","proofString":"sin_rewrite !(non_rmw_release_eq WF WFp).\nsin_rewrite (sw_eq_helper WF).\nby relsf; rewrite !seqA."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb'^? ⨾ release') ⨾ (rfi ∪ (sb ∩ same_loc)^? ⨾ rfe) ⨾ (sb ⨾ ⦗F⦘)^? ⨾ ⦗Acq⦘\n⊆ sb'^?\n  ⨾ release' ⨾ (rfi' ∪ (sb' ∩ same_loc')^? ⨾ rfe') ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘.","proofString":"sin_rewrite (sw_eq_helper WF).\nby relsf; rewrite !seqA."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb'^? ⨾ release')\n⨾ (rfi' ∪ (sb' ∩ same_loc')^? ⨾ rfe') ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘\n⊆ sb'^?\n  ⨾ release' ⨾ (rfi' ∪ (sb' ∩ same_loc')^? ⨾ rfe') ⨾ (sb' ⨾ ⦗F'⦘)^? ⨾ ⦗Acq'⦘.","proofString":"by relsf; rewrite !seqA."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb ∪ sw)⁺ ⊆ hb' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ hb'^?.","proofString":"apply inclusion_t_ind_left.\nunionL.\nrewrite <- sb_eq.\nunfold imm_hb.hb.\nrewrite <- ct_step.\nbasic_solver.\nrewrite (dom_l (wf_swD WF)) at 1.\nunfold imm_hb.hb.\nrewrite <- ct_step.\ngeneralize (F_sw_eq WF).\nbasic_solver 21.\nrelsf; unionL.\nrewrite <- sb_eq, sb_in_hb; generalize (@hb_trans G'); basic_solver 12.\nrewrite (dom_l (wf_swD WF)) at 1.\ngeneralize (F_sw_eq WF), (@sw_in_hb G'), (@hb_trans G'); basic_solver 12.\narewrite (sb ⊆ rmw ∪ (sb \\ rmw)) by unfolder; ins; tauto.\nrelsf; unionL.\nbasic_solver 12.\narewrite_id ⦗W⦘; rels.\nsin_rewrite (non_rmw_sw_eq WF WFp).\nrewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12.\narewrite (sb ⨾ rmw ⊆ (sb \\ rmw)).\nrewrite (rmw_in_sb WF) at 1.\nunfolder; ins; desc; splits.\neapply (@sb_trans G); eauto.\nintro A; apply (wf_rmwi WF) in A.\nby red in A; desc; eapply (A0 z).\nsin_rewrite (non_rmw_sw_eq WF WFp).\nrewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12.\nby rewrite (dom_r (wf_swD WF)) at 1; type_solver 12.\nsin_rewrite (sw_rmw_sw WF).\nrewrite <- sb_eq, sb_in_hb.\nrewrite (dom_l (wf_swD WF)) at 1.\ngeneralize (F_sw_eq WF), (@sw_in_hb G'), (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : sb ∪ sw ⊆ hb' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ hb'^?.","proofString":"unionL.\nrewrite <- sb_eq.\nunfold imm_hb.hb.\nrewrite <- ct_step.\nbasic_solver.\nrewrite (dom_l (wf_swD WF)) at 1.\nunfold imm_hb.hb.\nrewrite <- ct_step.\ngeneralize (F_sw_eq WF).\nbasic_solver 21."},{"statement":"(WF : Wf G) (WFp : Wf G') : sb ⊆ hb' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ hb'^?.","proofString":"rewrite <- sb_eq.\nunfold imm_hb.hb.\nrewrite <- ct_step.\nbasic_solver."},{"statement":"(WF : Wf G) (WFp : Wf G') : sb' ⊆ hb' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ hb'^?.","proofString":"unfold imm_hb.hb.\nrewrite <- ct_step.\nbasic_solver."},{"statement":"(WF : Wf G) (WFp : Wf G') : sb' ⊆ (sb' ∪ sw')⁺ ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ ((sb' ∪ sw')⁺)^?.","proofString":"rewrite <- ct_step.\nbasic_solver."},{"statement":"(WF : Wf G) (WFp : Wf G') : sb' ⊆ sb' ∪ sw' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ (sb' ∪ sw')^?.","proofString":"basic_solver."},{"statement":"(WF : Wf G) (WFp : Wf G') : sw ⊆ hb' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ hb'^?.","proofString":"rewrite (dom_l (wf_swD WF)) at 1.\nunfold imm_hb.hb.\nrewrite <- ct_step.\ngeneralize (F_sw_eq WF).\nbasic_solver 21."},{"statement":"(WF : Wf G) (WFp : Wf G') : ⦗FW ∩₁ Rel⦘ ⨾ sw ⊆ hb' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ hb'^?.","proofString":"unfold imm_hb.hb.\nrewrite <- ct_step.\ngeneralize (F_sw_eq WF).\nbasic_solver 21."},{"statement":"(WF : Wf G) (WFp : Wf G') : ⦗FW ∩₁ Rel⦘ ⨾ sw ⊆ (sb' ∪ sw')⁺ ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ ((sb' ∪ sw')⁺)^?.","proofString":"rewrite <- ct_step.\ngeneralize (F_sw_eq WF).\nbasic_solver 21."},{"statement":"(WF : Wf G) (WFp : Wf G') : ⦗FW ∩₁ Rel⦘ ⨾ sw ⊆ sb' ∪ sw' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ (sb' ∪ sw')^?.","proofString":"generalize (F_sw_eq WF).\nbasic_solver 21."},{"statement":"(WF : Wf G) (WFp : Wf G') : ⦗F⦘ ⨾ sw ⊆ sw' ->\n⦗FW ∩₁ Rel⦘ ⨾ sw ⊆ sb' ∪ sw' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ (sb' ∪ sw')^?.","proofString":"basic_solver 21."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb ∪ sw) ⨾ (hb' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ hb'^?) ⊆ hb' ∪ (⦗W⦘ ∪ rmw) ⨾ sw ⨾ hb'^?.","proofString":"relsf; unionL.\nrewrite <- sb_eq, sb_in_hb; generalize (@hb_trans G'); basic_solver 12.\nrewrite (dom_l (wf_swD WF)) at 1.\ngeneralize (F_sw_eq WF), (@sw_in_hb G'), (@hb_trans G'); basic_solver 12.\narewrite (sb ⊆ rmw ∪ (sb \\ rmw)) by unfolder; ins; tauto.\nrelsf; unionL.\nbasic_solver 12.\narewrite_id ⦗W⦘; rels.\nsin_rewrite (non_rmw_sw_eq WF WFp).\nrewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12.\narewrite (sb ⨾ rmw ⊆ (sb \\ rmw)).\nrewrite (rmw_in_sb WF) at 1.\nunfolder; ins; desc; splits.\neapply (@sb_trans G); eauto.\nintro A; apply (wf_rmwi WF) in A.\nby red in A; desc; eapply (A0 z).\nsin_rewrite (non_rmw_sw_eq WF WFp).\nrewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12.\nby rewrite (dom_r (wf_swD WF)) at 1; type_solver 12.\nsin_rewrite (sw_rmw_sw WF).\nrewrite <- sb_eq, sb_in_hb.\nrewrite (dom_l (wf_swD WF)) at 1.\ngeneralize (F_sw_eq WF), (@sw_in_hb G'), (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : sb ⨾ hb' ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"rewrite <- sb_eq, sb_in_hb; generalize (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : sw ⨾ hb' ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"rewrite (dom_l (wf_swD WF)) at 1.\ngeneralize (F_sw_eq WF), (@sw_in_hb G'), (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : (⦗FW ∩₁ Rel⦘ ⨾ sw) ⨾ hb' ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"generalize (F_sw_eq WF), (@sw_in_hb G'), (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : sb ⨾ ⦗W⦘ ⨾ sw ⨾ hb'^? ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"arewrite (sb ⊆ rmw ∪ (sb \\ rmw)) by unfolder; ins; tauto.\nrelsf; unionL.\nbasic_solver 12.\narewrite_id ⦗W⦘; rels.\nsin_rewrite (non_rmw_sw_eq WF WFp).\nrewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : (rmw ∪ sb \\ rmw) ⨾ ⦗W⦘ ⨾ sw ⨾ hb'^?\n⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"relsf; unionL.\nbasic_solver 12.\narewrite_id ⦗W⦘; rels.\nsin_rewrite (non_rmw_sw_eq WF WFp).\nrewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : rmw ⨾ ⦗W⦘ ⨾ sw ⨾ hb'^? ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb \\ rmw) ⨾ ⦗W⦘ ⨾ sw ⨾ hb'^? ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"arewrite_id ⦗W⦘; rels.\nsin_rewrite (non_rmw_sw_eq WF WFp).\nrewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb \\ rmw) ⨾ sw ⨾ hb'^? ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"sin_rewrite (non_rmw_sw_eq WF WFp).\nrewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb'^? ⨾ sw') ⨾ hb'^? ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"rewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : sb ⨾ rmw ⨾ sw ⨾ hb'^? ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"arewrite (sb ⨾ rmw ⊆ (sb \\ rmw)).\nrewrite (rmw_in_sb WF) at 1.\nunfolder; ins; desc; splits.\neapply (@sb_trans G); eauto.\nintro A; apply (wf_rmwi WF) in A.\nby red in A; desc; eapply (A0 z).\nsin_rewrite (non_rmw_sw_eq WF WFp).\nrewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : sb ⨾ rmw ⊆ sb \\ rmw.","proofString":"rewrite (rmw_in_sb WF) at 1.\nunfolder; ins; desc; splits.\neapply (@sb_trans G); eauto.\nintro A; apply (wf_rmwi WF) in A.\nby red in A; desc; eapply (A0 z)."},{"statement":"(WF : Wf G) (WFp : Wf G') : sb ⨾ sb ⊆ sb \\ rmw.","proofString":"unfolder; ins; desc; splits.\neapply (@sb_trans G); eauto.\nintro A; apply (wf_rmwi WF) in A.\nby red in A; desc; eapply (A0 z)."},{"statement":"(WF : Wf G) (WFp : Wf G') (x y z : actid) (H : sb x z) (H0 : sb z y) : sb x y.","proofString":"eapply (@sb_trans G); eauto."},{"statement":"(WF : Wf G) (WFp : Wf G') (x y z : actid) (H : sb x z) (H0 : sb z y) : ~ rmw x y.","proofString":"intro A; apply (wf_rmwi WF) in A.\nby red in A; desc; eapply (A0 z)."},{"statement":"(WF : Wf G) (WFp : Wf G') (x y z : actid) (H : sb x z) (H0 : sb z y) (A : immediate sb x y) : False.","proofString":"by red in A; desc; eapply (A0 z)."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb \\ rmw) ⨾ sw ⨾ hb'^? ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"sin_rewrite (non_rmw_sw_eq WF WFp).\nrewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sb'^? ⨾ sw') ⨾ hb'^? ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"rewrite sb_in_hb, sw_in_hb; generalize (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : sw ⨾ ⦗W⦘ ⨾ sw ⨾ hb'^? ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"by rewrite (dom_r (wf_swD WF)) at 1; type_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : sw ⨾ rmw ⨾ sw ⨾ hb'^? ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"sin_rewrite (sw_rmw_sw WF).\nrewrite <- sb_eq, sb_in_hb.\nrewrite (dom_l (wf_swD WF)) at 1.\ngeneralize (F_sw_eq WF), (@sw_in_hb G'), (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sw ⨾ sb^?) ⨾ hb'^? ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"rewrite <- sb_eq, sb_in_hb.\nrewrite (dom_l (wf_swD WF)) at 1.\ngeneralize (F_sw_eq WF), (@sw_in_hb G'), (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : (sw ⨾ hb'^?) ⨾ hb'^? ⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"rewrite (dom_l (wf_swD WF)) at 1.\ngeneralize (F_sw_eq WF), (@sw_in_hb G'), (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (WFp : Wf G') : ((⦗FW ∩₁ Rel⦘ ⨾ sw) ⨾ hb'^?) ⨾ hb'^?\n⊆ hb' ∪ (⦗W⦘ ⨾ sw ⨾ hb'^? ∪ rmw ⨾ sw ⨾ hb'^?).","proofString":"generalize (F_sw_eq WF), (@sw_in_hb G'), (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G') : Wf G.","proofString":"destruct WF.\neexists; rewrite <- ?sb_eq, <- ?W_eq, <- ?R_eq, <- ?same_loc_eq, <- ?R_ex_eq; try done.\nclear -wf_rfv.\nunfold G', relax_release_labels, Events.val, funeq in *; intros a b H.\napply wf_rfv in H; destruct a,b; ins; desf.\nins.\nrewrite <- W_eq, <- E_eq.\narewrite ((fun x : actid => loc x = ol) ⊆₁ (fun x : actid => loc' x = ol)).\nunfolder; ins.\nunfold relax_release_labels, Events.loc in *; ins; destruct x; desf.\ndone.\nclear -wf_init.\nintros l B; specialize (wf_init l); desc.\napply wf_init; eexists; splits; eauto.\nunfold G', relax_release_labels, Events.loc in *; ins; destruct b; ins; desf.\nclear -wf_init_lab.\nintros l; specialize (wf_init_lab l).\nunfold G', relax_release_labels in *; ins; desf."},{"statement":"(wf_index : forall a b : actid,\nE' a /\\ E' b /\\ a <> b /\\ tid a = tid b /\\ ~ is_init a -> index a <> index b) (data_in_sb : data' ⊆ sb') (wf_dataD : data' ≡ ⦗R'⦘ ⨾ data' ⨾ ⦗W'⦘) (addr_in_sb : addr' ⊆ sb') (wf_addrD : addr' ≡ ⦗R'⦘ ⨾ addr' ⨾ ⦗RW'⦘) (ctrl_in_sb : ctrl' ⊆ sb') (wf_ctrlD : ctrl' ≡ ⦗R'⦘ ⨾ ctrl') (ctrl_sb : ctrl' ⨾ sb' ⊆ ctrl') (wf_rmwD : rmw' ≡ ⦗R'⦘ ⨾ rmw' ⨾ ⦗W'⦘) (wf_rmwl : rmw' ⊆ same_loc') (wf_rmwi : rmw' ⊆ immediate sb') (wf_rfE : rf' ≡ ⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) (wf_rfD : rf' ≡ ⦗W'⦘ ⨾ rf' ⨾ ⦗R'⦘) (wf_rfl : rf' ⊆ same_loc') (wf_rfv : funeq val' rf') (wf_rff : functional rf'⁻¹) (wf_coE : co' ≡ ⦗E'⦘ ⨾ co' ⨾ ⦗E'⦘) (wf_coD : co' ≡ ⦗W'⦘ ⨾ co' ⨾ ⦗W'⦘) (wf_col : co' ⊆ same_loc') (co_trans : transitive co') (wf_co_total : forall ol : option location,\nis_total (E' ∩₁ W' ∩₁ (fun x : actid => loc' x = ol)) co') (co_irr : irreflexive co') (wf_init : forall l : location,\n(exists b : actid, E' b /\\ loc' b = Some l) -> E' (InitEvent l)) (wf_init_lab : forall l : location, lab' (InitEvent l) = Astore Xpln Opln l 0) (rmw_dep_in_sb : rmw_dep' ⊆ sb') (wf_rmw_depD : rmw_dep' ≡ ⦗R'⦘ ⨾ rmw_dep' ⨾ ⦗R_ex'⦘) (wf_threads : forall e : actid, E' e -> threads_set G' (tid e)) : Wf G.","proofString":"eexists; rewrite <- ?sb_eq, <- ?W_eq, <- ?R_eq, <- ?same_loc_eq, <- ?R_ex_eq; try done.\nclear -wf_rfv.\nunfold G', relax_release_labels, Events.val, funeq in *; intros a b H.\napply wf_rfv in H; destruct a,b; ins; desf.\nins.\nrewrite <- W_eq, <- E_eq.\narewrite ((fun x : actid => loc x = ol) ⊆₁ (fun x : actid => loc' x = ol)).\nunfolder; ins.\nunfold relax_release_labels, Events.loc in *; ins; destruct x; desf.\ndone.\nclear -wf_init.\nintros l B; specialize (wf_init l); desc.\napply wf_init; eexists; splits; eauto.\nunfold G', relax_release_labels, Events.loc in *; ins; destruct b; ins; desf.\nclear -wf_init_lab.\nintros l; specialize (wf_init_lab l).\nunfold G', relax_release_labels in *; ins; desf."},{"statement":"(wf_index : forall a b : actid,\nE' a /\\ E' b /\\ a <> b /\\ tid a = tid b /\\ ~ is_init a -> index a <> index b) (data_in_sb : data' ⊆ sb') (wf_dataD : data' ≡ ⦗R'⦘ ⨾ data' ⨾ ⦗W'⦘) (addr_in_sb : addr' ⊆ sb') (wf_addrD : addr' ≡ ⦗R'⦘ ⨾ addr' ⨾ ⦗RW'⦘) (ctrl_in_sb : ctrl' ⊆ sb') (wf_ctrlD : ctrl' ≡ ⦗R'⦘ ⨾ ctrl') (ctrl_sb : ctrl' ⨾ sb' ⊆ ctrl') (wf_rmwD : rmw' ≡ ⦗R'⦘ ⨾ rmw' ⨾ ⦗W'⦘) (wf_rmwl : rmw' ⊆ same_loc') (wf_rmwi : rmw' ⊆ immediate sb') (wf_rfE : rf' ≡ ⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) (wf_rfD : rf' ≡ ⦗W'⦘ ⨾ rf' ⨾ ⦗R'⦘) (wf_rfl : rf' ⊆ same_loc') (wf_rfv : funeq val' rf') (wf_rff : functional rf'⁻¹) (wf_coE : co' ≡ ⦗E'⦘ ⨾ co' ⨾ ⦗E'⦘) (wf_coD : co' ≡ ⦗W'⦘ ⨾ co' ⨾ ⦗W'⦘) (wf_col : co' ⊆ same_loc') (co_trans : transitive co') (wf_co_total : forall ol : option location,\nis_total (E' ∩₁ W' ∩₁ (fun x : actid => loc' x = ol)) co') (co_irr : irreflexive co') (wf_init : forall l : location,\n(exists b : actid, E' b /\\ loc' b = Some l) -> E' (InitEvent l)) (wf_init_lab : forall l : location, lab' (InitEvent l) = Astore Xpln Opln l 0) (rmw_dep_in_sb : rmw_dep' ⊆ sb') (wf_rmw_depD : rmw_dep' ≡ ⦗R'⦘ ⨾ rmw_dep' ⨾ ⦗R_ex'⦘) (wf_threads : forall e : actid, E' e -> threads_set G' (tid e)) : funeq val rf.","proofString":"clear -wf_rfv.\nunfold G', relax_release_labels, Events.val, funeq in *; intros a b H.\napply wf_rfv in H; destruct a,b; ins; desf."},{"statement":"(wf_rfv : funeq val' rf') : funeq val rf.","proofString":"unfold G', relax_release_labels, Events.val, funeq in *; intros a b H.\napply wf_rfv in H; destruct a,b; ins; desf."},{"statement":"(wf_index : forall a b : actid,\nE' a /\\ E' b /\\ a <> b /\\ tid a = tid b /\\ ~ is_init a -> index a <> index b) (data_in_sb : data' ⊆ sb') (wf_dataD : data' ≡ ⦗R'⦘ ⨾ data' ⨾ ⦗W'⦘) (addr_in_sb : addr' ⊆ sb') (wf_addrD : addr' ≡ ⦗R'⦘ ⨾ addr' ⨾ ⦗RW'⦘) (ctrl_in_sb : ctrl' ⊆ sb') (wf_ctrlD : ctrl' ≡ ⦗R'⦘ ⨾ ctrl') (ctrl_sb : ctrl' ⨾ sb' ⊆ ctrl') (wf_rmwD : rmw' ≡ ⦗R'⦘ ⨾ rmw' ⨾ ⦗W'⦘) (wf_rmwl : rmw' ⊆ same_loc') (wf_rmwi : rmw' ⊆ immediate sb') (wf_rfE : rf' ≡ ⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) (wf_rfD : rf' ≡ ⦗W'⦘ ⨾ rf' ⨾ ⦗R'⦘) (wf_rfl : rf' ⊆ same_loc') (wf_rfv : funeq val' rf') (wf_rff : functional rf'⁻¹) (wf_coE : co' ≡ ⦗E'⦘ ⨾ co' ⨾ ⦗E'⦘) (wf_coD : co' ≡ ⦗W'⦘ ⨾ co' ⨾ ⦗W'⦘) (wf_col : co' ⊆ same_loc') (co_trans : transitive co') (wf_co_total : forall ol : option location,\nis_total (E' ∩₁ W' ∩₁ (fun x : actid => loc' x = ol)) co') (co_irr : irreflexive co') (wf_init : forall l : location,\n(exists b : actid, E' b /\\ loc' b = Some l) -> E' (InitEvent l)) (wf_init_lab : forall l : location, lab' (InitEvent l) = Astore Xpln Opln l 0) (rmw_dep_in_sb : rmw_dep' ⊆ sb') (wf_rmw_depD : rmw_dep' ≡ ⦗R'⦘ ⨾ rmw_dep' ⨾ ⦗R_ex'⦘) (wf_threads : forall e : actid, E' e -> threads_set G' (tid e)) : forall ol : option location,\nis_total (E ∩₁ W ∩₁ (fun x : actid => loc x = ol)) co.","proofString":"ins.\nrewrite <- W_eq, <- E_eq.\narewrite ((fun x : actid => loc x = ol) ⊆₁ (fun x : actid => loc' x = ol)).\nunfolder; ins.\nunfold relax_release_labels, Events.loc in *; ins; destruct x; desf.\ndone."},{"statement":"(wf_index : forall a b : actid,\nE' a /\\ E' b /\\ a <> b /\\ tid a = tid b /\\ ~ is_init a -> index a <> index b) (data_in_sb : data' ⊆ sb') (wf_dataD : data' ≡ ⦗R'⦘ ⨾ data' ⨾ ⦗W'⦘) (addr_in_sb : addr' ⊆ sb') (wf_addrD : addr' ≡ ⦗R'⦘ ⨾ addr' ⨾ ⦗RW'⦘) (ctrl_in_sb : ctrl' ⊆ sb') (wf_ctrlD : ctrl' ≡ ⦗R'⦘ ⨾ ctrl') (ctrl_sb : ctrl' ⨾ sb' ⊆ ctrl') (wf_rmwD : rmw' ≡ ⦗R'⦘ ⨾ rmw' ⨾ ⦗W'⦘) (wf_rmwl : rmw' ⊆ same_loc') (wf_rmwi : rmw' ⊆ immediate sb') (wf_rfE : rf' ≡ ⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) (wf_rfD : rf' ≡ ⦗W'⦘ ⨾ rf' ⨾ ⦗R'⦘) (wf_rfl : rf' ⊆ same_loc') (wf_rfv : funeq val' rf') (wf_rff : functional rf'⁻¹) (wf_coE : co' ≡ ⦗E'⦘ ⨾ co' ⨾ ⦗E'⦘) (wf_coD : co' ≡ ⦗W'⦘ ⨾ co' ⨾ ⦗W'⦘) (wf_col : co' ⊆ same_loc') (co_trans : transitive co') (wf_co_total : forall ol : option location,\nis_total (E' ∩₁ W' ∩₁ (fun x : actid => loc' x = ol)) co') (co_irr : irreflexive co') (wf_init : forall l : location,\n(exists b : actid, E' b /\\ loc' b = Some l) -> E' (InitEvent l)) (wf_init_lab : forall l : location, lab' (InitEvent l) = Astore Xpln Opln l 0) (rmw_dep_in_sb : rmw_dep' ⊆ sb') (wf_rmw_depD : rmw_dep' ≡ ⦗R'⦘ ⨾ rmw_dep' ⨾ ⦗R_ex'⦘) (wf_threads : forall e : actid, E' e -> threads_set G' (tid e)) : forall l : location,\n(exists b : actid, E b /\\ loc b = Some l) -> E (InitEvent l).","proofString":"clear -wf_init.\nintros l B; specialize (wf_init l); desc.\napply wf_init; eexists; splits; eauto.\nunfold G', relax_release_labels, Events.loc in *; ins; destruct b; ins; desf."},{"statement":"(wf_init : forall l : location,\n(exists b : actid, E' b /\\ loc' b = Some l) -> E' (InitEvent l)) : forall l : location,\n(exists b : actid, E b /\\ loc b = Some l) -> E (InitEvent l).","proofString":"intros l B; specialize (wf_init l); desc.\napply wf_init; eexists; splits; eauto.\nunfold G', relax_release_labels, Events.loc in *; ins; destruct b; ins; desf."},{"statement":"(l : location) (wf_init : (exists b0 : actid, E' b0 /\\ loc' b0 = Some l) -> E' (InitEvent l)) (b : actid) (B : E b) (B0 : loc b = Some l) : E (InitEvent l).","proofString":"apply wf_init; eexists; splits; eauto.\nunfold G', relax_release_labels, Events.loc in *; ins; destruct b; ins; desf."},{"statement":"(l : location) (wf_init : (exists b0 : actid, E' b0 /\\ loc' b0 = Some l) -> E' (InitEvent l)) (b : actid) (B : E b) (B0 : loc b = Some l) : loc' b = Some l.","proofString":"unfold G', relax_release_labels, Events.loc in *; ins; destruct b; ins; desf."},{"statement":"(wf_index : forall a b : actid,\nE' a /\\ E' b /\\ a <> b /\\ tid a = tid b /\\ ~ is_init a -> index a <> index b) (data_in_sb : data' ⊆ sb') (wf_dataD : data' ≡ ⦗R'⦘ ⨾ data' ⨾ ⦗W'⦘) (addr_in_sb : addr' ⊆ sb') (wf_addrD : addr' ≡ ⦗R'⦘ ⨾ addr' ⨾ ⦗RW'⦘) (ctrl_in_sb : ctrl' ⊆ sb') (wf_ctrlD : ctrl' ≡ ⦗R'⦘ ⨾ ctrl') (ctrl_sb : ctrl' ⨾ sb' ⊆ ctrl') (wf_rmwD : rmw' ≡ ⦗R'⦘ ⨾ rmw' ⨾ ⦗W'⦘) (wf_rmwl : rmw' ⊆ same_loc') (wf_rmwi : rmw' ⊆ immediate sb') (wf_rfE : rf' ≡ ⦗E'⦘ ⨾ rf' ⨾ ⦗E'⦘) (wf_rfD : rf' ≡ ⦗W'⦘ ⨾ rf' ⨾ ⦗R'⦘) (wf_rfl : rf' ⊆ same_loc') (wf_rfv : funeq val' rf') (wf_rff : functional rf'⁻¹) (wf_coE : co' ≡ ⦗E'⦘ ⨾ co' ⨾ ⦗E'⦘) (wf_coD : co' ≡ ⦗W'⦘ ⨾ co' ⨾ ⦗W'⦘) (wf_col : co' ⊆ same_loc') (co_trans : transitive co') (wf_co_total : forall ol : option location,\nis_total (E' ∩₁ W' ∩₁ (fun x : actid => loc' x = ol)) co') (co_irr : irreflexive co') (wf_init : forall l : location,\n(exists b : actid, E' b /\\ loc' b = Some l) -> E' (InitEvent l)) (wf_init_lab : forall l : location, lab' (InitEvent l) = Astore Xpln Opln l 0) (rmw_dep_in_sb : rmw_dep' ⊆ sb') (wf_rmw_depD : rmw_dep' ≡ ⦗R'⦘ ⨾ rmw_dep' ⨾ ⦗R_ex'⦘) (wf_threads : forall e : actid, E' e -> threads_set G' (tid e)) : forall l : location, lab (InitEvent l) = Astore Xpln Opln l 0.","proofString":"clear -wf_init_lab.\nintros l; specialize (wf_init_lab l).\nunfold G', relax_release_labels in *; ins; desf."},{"statement":"(wf_init_lab : forall l : location, lab' (InitEvent l) = Astore Xpln Opln l 0) : forall l : location, lab (InitEvent l) = Astore Xpln Opln l 0.","proofString":"intros l; specialize (wf_init_lab l).\nunfold G', relax_release_labels in *; ins; desf."},{"statement":"(l : location) (wf_init_lab : lab' (InitEvent l) = Astore Xpln Opln l 0) : lab (InitEvent l) = Astore Xpln Opln l 0.","proofString":"unfold G', relax_release_labels in *; ins; desf."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) : irreflexive (hb ⨾ eco).","proofString":"rewrite <- eco_eq.\nrewrite (hb_eq1 WF WFp), (rmw_in_fr WFp (coherence_sc_per_loc COHp) COMPp).\nsin_rewrite !(sw_in_sb_eco_sb WF SC_PER_LOC).\nrewrite fr_in_eco.\nrewrite !seqA.\narewrite ((sb ⨾ ⦗F ∩₁ Acq⦘)^? ⨾ hb'^? ⊆ hb'^?).\nrewrite <- sb_eq, sb_in_hb; generalize (@hb_trans G'); basic_solver 12.\narewrite (((⦗W⦘ ∪ eco') ⨾ (⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ hb'^?) ⊆ (⦗W⦘ ∪ eco') ⨾ eco ⨾ hb'^?).\nby rewrite (dom_r (wf_ecoD WFp)) at 1; type_solver 12.\ngeneralize (eco_trans WFp); intro.\nrelsf; unionL; try done.\nrewrite <- !eco_eq.\nrewrite !seqA.\narewrite_id ⦗W⦘.\nrotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr.\nrewrite !seqA.\nrotate 1.\nrelsf.\nrotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) : irreflexive (hb ⨾ eco').","proofString":"rewrite (hb_eq1 WF WFp), (rmw_in_fr WFp (coherence_sc_per_loc COHp) COMPp).\nsin_rewrite !(sw_in_sb_eco_sb WF SC_PER_LOC).\nrewrite fr_in_eco.\nrewrite !seqA.\narewrite ((sb ⨾ ⦗F ∩₁ Acq⦘)^? ⨾ hb'^? ⊆ hb'^?).\nrewrite <- sb_eq, sb_in_hb; generalize (@hb_trans G'); basic_solver 12.\narewrite (((⦗W⦘ ∪ eco') ⨾ (⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ hb'^?) ⊆ (⦗W⦘ ∪ eco') ⨾ eco ⨾ hb'^?).\nby rewrite (dom_r (wf_ecoD WFp)) at 1; type_solver 12.\ngeneralize (eco_trans WFp); intro.\nrelsf; unionL; try done.\nrewrite <- !eco_eq.\nrewrite !seqA.\narewrite_id ⦗W⦘.\nrotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr.\nrewrite !seqA.\nrotate 1.\nrelsf.\nrotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) : irreflexive ((hb' ∪ (⦗W⦘ ∪ fr') ⨾ sw ⨾ hb'^?) ⨾ eco').","proofString":"sin_rewrite !(sw_in_sb_eco_sb WF SC_PER_LOC).\nrewrite fr_in_eco.\nrewrite !seqA.\narewrite ((sb ⨾ ⦗F ∩₁ Acq⦘)^? ⨾ hb'^? ⊆ hb'^?).\nrewrite <- sb_eq, sb_in_hb; generalize (@hb_trans G'); basic_solver 12.\narewrite (((⦗W⦘ ∪ eco') ⨾ (⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ hb'^?) ⊆ (⦗W⦘ ∪ eco') ⨾ eco ⨾ hb'^?).\nby rewrite (dom_r (wf_ecoD WFp)) at 1; type_solver 12.\ngeneralize (eco_trans WFp); intro.\nrelsf; unionL; try done.\nrewrite <- !eco_eq.\nrewrite !seqA.\narewrite_id ⦗W⦘.\nrotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr.\nrewrite !seqA.\nrotate 1.\nrelsf.\nrotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) : irreflexive\n  ((hb'\n    ∪ (⦗W⦘ ∪ fr') ⨾ ((⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ (sb ⨾ ⦗F ∩₁ Acq⦘)^?) ⨾ hb'^?)\n   ⨾ eco').","proofString":"rewrite fr_in_eco.\nrewrite !seqA.\narewrite ((sb ⨾ ⦗F ∩₁ Acq⦘)^? ⨾ hb'^? ⊆ hb'^?).\nrewrite <- sb_eq, sb_in_hb; generalize (@hb_trans G'); basic_solver 12.\narewrite (((⦗W⦘ ∪ eco') ⨾ (⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ hb'^?) ⊆ (⦗W⦘ ∪ eco') ⨾ eco ⨾ hb'^?).\nby rewrite (dom_r (wf_ecoD WFp)) at 1; type_solver 12.\ngeneralize (eco_trans WFp); intro.\nrelsf; unionL; try done.\nrewrite <- !eco_eq.\nrewrite !seqA.\narewrite_id ⦗W⦘.\nrotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr.\nrewrite !seqA.\nrotate 1.\nrelsf.\nrotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) : irreflexive\n  ((hb'\n    ∪ (⦗W⦘ ∪ eco')\n      ⨾ ((⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ (sb ⨾ ⦗F ∩₁ Acq⦘)^?) ⨾ hb'^?) ⨾ eco').","proofString":"rewrite !seqA.\narewrite ((sb ⨾ ⦗F ∩₁ Acq⦘)^? ⨾ hb'^? ⊆ hb'^?).\nrewrite <- sb_eq, sb_in_hb; generalize (@hb_trans G'); basic_solver 12.\narewrite (((⦗W⦘ ∪ eco') ⨾ (⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ hb'^?) ⊆ (⦗W⦘ ∪ eco') ⨾ eco ⨾ hb'^?).\nby rewrite (dom_r (wf_ecoD WFp)) at 1; type_solver 12.\ngeneralize (eco_trans WFp); intro.\nrelsf; unionL; try done.\nrewrite <- !eco_eq.\nrewrite !seqA.\narewrite_id ⦗W⦘.\nrotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr.\nrewrite !seqA.\nrotate 1.\nrelsf.\nrotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) : irreflexive\n  ((hb'\n    ∪ (⦗W⦘ ∪ eco') ⨾ (⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ (sb ⨾ ⦗F ∩₁ Acq⦘)^? ⨾ hb'^?)\n   ⨾ eco').","proofString":"arewrite ((sb ⨾ ⦗F ∩₁ Acq⦘)^? ⨾ hb'^? ⊆ hb'^?).\nrewrite <- sb_eq, sb_in_hb; generalize (@hb_trans G'); basic_solver 12.\narewrite (((⦗W⦘ ∪ eco') ⨾ (⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ hb'^?) ⊆ (⦗W⦘ ∪ eco') ⨾ eco ⨾ hb'^?).\nby rewrite (dom_r (wf_ecoD WFp)) at 1; type_solver 12.\ngeneralize (eco_trans WFp); intro.\nrelsf; unionL; try done.\nrewrite <- !eco_eq.\nrewrite !seqA.\narewrite_id ⦗W⦘.\nrotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr.\nrewrite !seqA.\nrotate 1.\nrelsf.\nrotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) : (sb ⨾ ⦗F ∩₁ Acq⦘)^? ⨾ hb'^? ⊆ hb'^?.","proofString":"rewrite <- sb_eq, sb_in_hb; generalize (@hb_trans G'); basic_solver 12."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) : irreflexive ((hb' ∪ (⦗W⦘ ∪ eco') ⨾ (⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ hb'^?) ⨾ eco').","proofString":"arewrite (((⦗W⦘ ∪ eco') ⨾ (⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ hb'^?) ⊆ (⦗W⦘ ∪ eco') ⨾ eco ⨾ hb'^?).\nby rewrite (dom_r (wf_ecoD WFp)) at 1; type_solver 12.\ngeneralize (eco_trans WFp); intro.\nrelsf; unionL; try done.\nrewrite <- !eco_eq.\nrewrite !seqA.\narewrite_id ⦗W⦘.\nrotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr.\nrewrite !seqA.\nrotate 1.\nrelsf.\nrotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) : (⦗W⦘ ∪ eco') ⨾ (⦗F ∩₁ Rel⦘ ⨾ sb)^? ⨾ eco ⨾ hb'^? ⊆ (⦗W⦘ ∪ eco') ⨾ eco ⨾ hb'^?.","proofString":"by rewrite (dom_r (wf_ecoD WFp)) at 1; type_solver 12."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) : irreflexive ((hb' ∪ (⦗W⦘ ∪ eco') ⨾ eco ⨾ hb'^?) ⨾ eco').","proofString":"generalize (eco_trans WFp); intro.\nrelsf; unionL; try done.\nrewrite <- !eco_eq.\nrewrite !seqA.\narewrite_id ⦗W⦘.\nrotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr.\nrewrite !seqA.\nrotate 1.\nrelsf.\nrotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive ((hb' ∪ (⦗W⦘ ∪ eco') ⨾ eco ⨾ hb'^?) ⨾ eco').","proofString":"relsf; unionL; try done.\nrewrite <- !eco_eq.\nrewrite !seqA.\narewrite_id ⦗W⦘.\nrotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr.\nrewrite !seqA.\nrotate 1.\nrelsf.\nrotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive ((⦗W⦘ ⨾ eco ⨾ hb'^?) ⨾ eco').","proofString":"rewrite <- !eco_eq.\nrewrite !seqA.\narewrite_id ⦗W⦘.\nrotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive ((⦗W⦘ ⨾ eco' ⨾ hb'^?) ⨾ eco').","proofString":"rewrite !seqA.\narewrite_id ⦗W⦘.\nrotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive (⦗W⦘ ⨾ eco' ⨾ hb'^? ⨾ eco').","proofString":"arewrite_id ⦗W⦘.\nrotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive (⦗fun _ : actid => True⦘ ⨾ eco' ⨾ hb'^? ⨾ eco').","proofString":"rotate 2.\nrelsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive (hb'^? ⨾ eco' ⨾ ⦗fun _ : actid => True⦘ ⨾ eco').","proofString":"relsf.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive (hb'^? ⨾ eco').","proofString":"rewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive eco' /\\ irreflexive (hb' ⨾ eco').","proofString":"eauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive ((eco' ⨾ hb'^?) ⨾ eco').","proofString":"rewrite !seqA.\nrotate 1.\nrelsf.\nrotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive (eco' ⨾ hb'^? ⨾ eco').","proofString":"rotate 1.\nrelsf.\nrotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive (eco' ⨾ eco' ⨾ hb'^?).","proofString":"relsf.\nrotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive (eco' ⨾ hb'^?).","proofString":"rotate 1.\nrewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive (hb'^? ⨾ eco').","proofString":"rewrite crE at 1; relsf; apply irreflexive_union.\neauto using eco_irr."},{"statement":"(WF : Wf G) (SC_PER_LOC : sc_per_loc G) (COMP : complete G) (WFp : Wf G') (COMPp : complete G') (COHp : irreflexive (hb' ⨾ eco')) (H : transitive eco') : irreflexive eco' /\\ irreflexive (hb' ⨾ eco').","proofString":"eauto using eco_irr."},{"statement":"(WFp : Wf G') (COMPp : complete G') (CONSp : imm_consistent G') (Comp : complete G') (Cint : coherence G') (Cext : acyc_ext G') (Cpsc : acyclic (psc_f' ∪ psc_base')) (Cat : rmw_atomicity G') : imm_consistent G.","proofString":"assert (Wf G) as WF by (by apply wf_eq).\nassert (complete G) as COM by (by apply complete_eq).\nassert (sc_per_loc G) as SPL.\napply sc_per_loc_eq.\nby apply coherence_sc_per_loc.\nassert (coherence G) as COH by (by apply coherence_eq).\nassert (acyc_ext G) as CextG by (by apply acyc_ext_eq).\nred.\nsplits; auto.\nrewrite psc_base_in_psc_f; auto.\nrewrite unionK.\nrewrite psc_f_eq; auto.\narewrite (psc_f' ⊆ psc_f' ∪ psc_base').\ndone."},{"statement":"(WFp : Wf G') (COMPp : complete G') (CONSp : imm_consistent G') (Comp : complete G') (Cint : coherence G') (Cext : acyc_ext G') (Cpsc : acyclic (psc_f' ∪ psc_base')) (Cat : rmw_atomicity G') (WF : Wf G) : imm_consistent G.","proofString":"assert (complete G) as COM by (by apply complete_eq).\nassert (sc_per_loc G) as SPL.\napply sc_per_loc_eq.\nby apply coherence_sc_per_loc.\nassert (coherence G) as COH by (by apply coherence_eq).\nassert (acyc_ext G) as CextG by (by apply acyc_ext_eq).\nred.\nsplits; auto.\nrewrite psc_base_in_psc_f; auto.\nrewrite unionK.\nrewrite psc_f_eq; auto.\narewrite (psc_f' ⊆ psc_f' ∪ psc_base').\ndone."},{"statement":"(WFp : Wf G') (COMPp : complete G') (CONSp : imm_consistent G') (Comp : complete G') (Cint : coherence G') (Cext : acyc_ext G') (Cpsc : acyclic (psc_f' ∪ psc_base')) (Cat : rmw_atomicity G') (WF : Wf G) (COM : complete G) : imm_consistent G.","proofString":"assert (sc_per_loc G) as SPL.\napply sc_per_loc_eq.\nby apply coherence_sc_per_loc.\nassert (coherence G) as COH by (by apply coherence_eq).\nassert (acyc_ext G) as CextG by (by apply acyc_ext_eq).\nred.\nsplits; auto.\nrewrite psc_base_in_psc_f; auto.\nrewrite unionK.\nrewrite psc_f_eq; auto.\narewrite (psc_f' ⊆ psc_f' ∪ psc_base').\ndone."},{"statement":"(WFp : Wf G') (COMPp : complete G') (CONSp : imm_consistent G') (Comp : complete G') (Cint : coherence G') (Cext : acyc_ext G') (Cpsc : acyclic (psc_f' ∪ psc_base')) (Cat : rmw_atomicity G') (WF : Wf G) (COM : complete G) : sc_per_loc G.","proofString":"apply sc_per_loc_eq.\nby apply coherence_sc_per_loc."},{"statement":"(WFp : Wf G') (COMPp : complete G') (CONSp : imm_consistent G') (Comp : complete G') (Cint : coherence G') (Cext : acyc_ext G') (Cpsc : acyclic (psc_f' ∪ psc_base')) (Cat : rmw_atomicity G') (WF : Wf G) (COM : complete G) : sc_per_loc G'.","proofString":"by apply coherence_sc_per_loc."},{"statement":"(WFp : Wf G') (COMPp : complete G') (CONSp : imm_consistent G') (Comp : complete G') (Cint : coherence G') (Cext : acyc_ext G') (Cpsc : acyclic (psc_f' ∪ psc_base')) (Cat : rmw_atomicity G') (WF : Wf G) (COM : complete G) (SPL : sc_per_loc G) : imm_consistent G.","proofString":"assert (coherence G) as COH by (by apply coherence_eq).\nassert (acyc_ext G) as CextG by (by apply acyc_ext_eq).\nred.\nsplits; auto.\nrewrite psc_base_in_psc_f; auto.\nrewrite unionK.\nrewrite psc_f_eq; auto.\narewrite (psc_f' ⊆ psc_f' ∪ psc_base').\ndone."},{"statement":"(WFp : Wf G') (COMPp : complete G') (CONSp : imm_consistent G') (Comp : complete G') (Cint : coherence G') (Cext : acyc_ext G') (Cpsc : acyclic (psc_f' ∪ psc_base')) (Cat : rmw_atomicity G') (WF : Wf G) (COM : complete G) (SPL : sc_per_loc G) (COH : coherence G) : imm_consistent G.","proofString":"assert (acyc_ext G) as CextG by (by apply acyc_ext_eq).\nred.\nsplits; auto.\nrewrite psc_base_in_psc_f; auto.\nrewrite unionK.\nrewrite psc_f_eq; auto.\narewrite (psc_f' ⊆ psc_f' ∪ psc_base').\ndone."},{"statement":"(WFp : Wf G') (COMPp : complete G') (CONSp : imm_consistent G') (Comp : complete G') (Cint : coherence G') (Cext : acyc_ext G') (Cpsc : acyclic (psc_f' ∪ psc_base')) (Cat : rmw_atomicity G') (WF : Wf G) (COM : complete G) (SPL : sc_per_loc G) (COH : coherence G) (CextG : acyc_ext G) : imm_consistent G.","proofString":"red.\nsplits; auto.\nrewrite psc_base_in_psc_f; auto.\nrewrite unionK.\nrewrite psc_f_eq; auto.\narewrite (psc_f' ⊆ psc_f' ∪ psc_base').\ndone."},{"statement":"(WFp : Wf G') (COMPp : complete G') (CONSp : imm_consistent G') (Comp : complete G') (Cint : coherence G') (Cext : acyc_ext G') (Cpsc : acyclic (psc_f' ∪ psc_base')) (Cat : rmw_atomicity G') (WF : Wf G) (COM : complete G) (SPL : sc_per_loc G) (COH : coherence G) (CextG : acyc_ext G) : acyclic (psc_f ∪ psc_base).","proofString":"rewrite psc_base_in_psc_f; auto.\nrewrite unionK.\nrewrite psc_f_eq; auto.\narewrite (psc_f' ⊆ psc_f' ∪ psc_base').\ndone."},{"statement":"(WFp : Wf G') (COMPp : complete G') (CONSp : imm_consistent G') (Comp : complete G') (Cint : coherence G') (Cext : acyc_ext G') (Cpsc : acyclic (psc_f' ∪ psc_base')) (Cat : rmw_atomicity G') (WF : Wf G) (COM : complete G) (SPL : sc_per_loc G) (COH : coherence G) (CextG : acyc_ext G) : acyclic (psc_f ∪ psc_f).","proofString":"rewrite unionK.\nrewrite psc_f_eq; auto.\narewrite (psc_f' ⊆ psc_f' ∪ psc_base').\ndone."},{"statement":"(WFp : Wf G') (COMPp : complete G') (CONSp : imm_consistent G') (Comp : complete G') (Cint : coherence G') (Cext : acyc_ext G') (Cpsc : acyclic (psc_f' ∪ psc_base')) (Cat : rmw_atomicity G') (WF : Wf G) (COM : complete G) (SPL : sc_per_loc G) (COH : coherence G) (CextG : acyc_ext G) : acyclic psc_f.","proofString":"rewrite psc_f_eq; auto.\narewrite (psc_f' ⊆ psc_f' ∪ psc_base').\ndone."},{"statement":"(WFp : Wf G') (COMPp : complete G') (CONSp : imm_consistent G') (Comp : complete G') (Cint : coherence G') (Cext : acyc_ext G') (Cpsc : acyclic (psc_f' ∪ psc_base')) (Cat : rmw_atomicity G') (WF : Wf G) (COM : complete G) (SPL : sc_per_loc G) (COH : coherence G) (CextG : acyc_ext G) : acyclic psc_f'.","proofString":"arewrite (psc_f' ⊆ psc_f' ∪ psc_base').\ndone."},{"statement":"(WFp : Wf G') (COMPp : complete G') (CONSp : imm_consistent G') (Comp : complete G') (Cint : coherence G') (Cext : acyc_ext G') (Cpsc : acyclic (psc_f' ∪ psc_base')) (Cat : rmw_atomicity G') (WF : Wf G) (COM : complete G) (SPL : sc_per_loc G) (COH : coherence G) (CextG : acyc_ext G) : acyclic (psc_f' ∪ psc_base').","proofString":"done."}]}