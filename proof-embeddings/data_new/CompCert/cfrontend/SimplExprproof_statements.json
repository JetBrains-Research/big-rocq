{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/cfrontend/SimplExprproof.v","fileSamples":[{"statement":"(p : Csyntax.program) (tp : program) (H : Errors.bind (transform_partial_program (transl_fundef (prog_comp_env p)) p)\n  (fun p1 : AST.program fundef type =>\n   OK\n     {|\n       prog_defs := AST.prog_defs p1;\n       prog_public := AST.prog_public p1;\n       prog_main := AST.prog_main p1;\n       prog_types := prog_types p;\n       prog_comp_env := prog_comp_env p;\n       prog_comp_env_eq := prog_comp_env_eq p\n     |}) = OK tp) : match_prog p tp.","conclusion":"match_prog p tp","hypotheses":"(p : Csyntax.program) (tp : program) (H : Errors.bind (transform_partial_program (transl_fundef (prog_comp_env p)) p)\n  (fun p1 : AST.program fundef type =>\n   OK\n     {|\n       prog_defs := AST.prog_defs p1;\n       prog_public := AST.prog_public p1;\n       prog_main := AST.prog_main p1;\n       prog_types := prog_types p;\n       prog_comp_env := prog_comp_env p;\n       prog_comp_env_eq := prog_comp_env_eq p\n     |}) = OK tp)","proofString":"monadInv H.\nsplit; auto.\nunfold program_of_program; simpl.\ndestruct x; simpl.\neapply match_transform_partial_program2; eauto.\nintros.\napply transl_fundef_spec; auto.\nintros.\ninv H.\nauto."},{"statement":"(p : Csyntax.program) (x : AST.program fundef type) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p = OK x) : match_prog p\n  {|\n    prog_defs := AST.prog_defs x;\n    prog_public := AST.prog_public x;\n    prog_main := AST.prog_main x;\n    prog_types := prog_types p;\n    prog_comp_env := prog_comp_env p;\n    prog_comp_env_eq := prog_comp_env_eq p\n  |}.","conclusion":"match_prog p\n  {|\n    prog_defs := AST.prog_defs x;\n    prog_public := AST.prog_public x;\n    prog_main := AST.prog_main x;\n    prog_types := prog_types p;\n    prog_comp_env := prog_comp_env p;\n    prog_comp_env_eq := prog_comp_env_eq p\n  |}","hypotheses":"(p : Csyntax.program) (x : AST.program fundef type) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p = OK x)","proofString":"split; auto.\nunfold program_of_program; simpl.\ndestruct x; simpl.\neapply match_transform_partial_program2; eauto.\nintros.\napply transl_fundef_spec; auto.\nintros.\ninv H.\nauto."},{"statement":"(p : Csyntax.program) (x : AST.program fundef type) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p = OK x) : match_program_gen tr_fundef eq p p\n  {|\n    prog_defs := AST.prog_defs x;\n    prog_public := AST.prog_public x;\n    prog_main := AST.prog_main x;\n    prog_types := prog_types p;\n    prog_comp_env := prog_comp_env p;\n    prog_comp_env_eq := prog_comp_env_eq p\n  |}.","conclusion":"match_program_gen tr_fundef eq p p\n  {|\n    prog_defs := AST.prog_defs x;\n    prog_public := AST.prog_public x;\n    prog_main := AST.prog_main x;\n    prog_types := prog_types p;\n    prog_comp_env := prog_comp_env p;\n    prog_comp_env_eq := prog_comp_env_eq p\n  |}","hypotheses":"(p : Csyntax.program) (x : AST.program fundef type) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p = OK x)","proofString":"unfold program_of_program; simpl.\ndestruct x; simpl.\neapply match_transform_partial_program2; eauto.\nintros.\napply transl_fundef_spec; auto.\nintros.\ninv H.\nauto."},{"statement":"(p : Csyntax.program) (x : AST.program fundef type) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p = OK x) : match_program_gen tr_fundef eq p\n  {|\n    AST.prog_defs := prog_defs p;\n    AST.prog_public := prog_public p;\n    AST.prog_main := prog_main p\n  |}\n  {|\n    AST.prog_defs := AST.prog_defs x;\n    AST.prog_public := AST.prog_public x;\n    AST.prog_main := AST.prog_main x\n  |}.","conclusion":"match_program_gen tr_fundef eq p\n  {|\n    AST.prog_defs := prog_defs p;\n    AST.prog_public := prog_public p;\n    AST.prog_main := prog_main p\n  |}\n  {|\n    AST.prog_defs := AST.prog_defs x;\n    AST.prog_public := AST.prog_public x;\n    AST.prog_main := AST.prog_main x\n  |}","hypotheses":"(p : Csyntax.program) (x : AST.program fundef type) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p = OK x)","proofString":"destruct x; simpl.\neapply match_transform_partial_program2; eauto.\nintros.\napply transl_fundef_spec; auto.\nintros.\ninv H.\nauto."},{"statement":"(p : Csyntax.program) (prog_defs : list (ident * globdef fundef type)) (prog_public : list ident) (prog_main : ident) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p =\nOK\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |}) : match_program_gen tr_fundef eq p\n  {|\n    AST.prog_defs := Ctypes.prog_defs p;\n    AST.prog_public := Ctypes.prog_public p;\n    AST.prog_main := Ctypes.prog_main p\n  |}\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |}.","conclusion":"match_program_gen tr_fundef eq p\n  {|\n    AST.prog_defs := Ctypes.prog_defs p;\n    AST.prog_public := Ctypes.prog_public p;\n    AST.prog_main := Ctypes.prog_main p\n  |}\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |}","hypotheses":"(p : Csyntax.program) (prog_defs : list (ident * globdef fundef type)) (prog_public : list ident) (prog_main : ident) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p =\nOK\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |})","proofString":"eapply match_transform_partial_program2; eauto.\nintros.\napply transl_fundef_spec; auto.\nintros.\ninv H.\nauto."},{"statement":"(p : Csyntax.program) (prog_defs : list (ident * globdef fundef type)) (prog_public : list ident) (prog_main : ident) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p =\nOK\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |}) : forall (i : ident) (f : Csyntax.fundef) (tf : fundef),\n(fun (_ : ident) (f0 : Csyntax.fundef) => transl_fundef (prog_comp_env p) f0)\n  i f = OK tf -> tr_fundef p f tf.","conclusion":"forall (i : ident) (f : Csyntax.fundef) (tf : fundef),\n(fun (_ : ident) (f0 : Csyntax.fundef) => transl_fundef (prog_comp_env p) f0)\n  i f = OK tf -> tr_fundef p f tf","hypotheses":"(p : Csyntax.program) (prog_defs : list (ident * globdef fundef type)) (prog_public : list ident) (prog_main : ident) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p =\nOK\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |})","proofString":"intros.\napply transl_fundef_spec; auto."},{"statement":"(p : Csyntax.program) (prog_defs : list (ident * globdef fundef type)) (prog_public : list ident) (prog_main : ident) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p =\nOK\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |}) (i : ident) (f : Csyntax.fundef) (tf : fundef) (H : (fun (_ : ident) (f0 : Csyntax.fundef) => transl_fundef (prog_comp_env p) f0)\n  i f = OK tf) : tr_fundef p f tf.","conclusion":"tr_fundef p f tf","hypotheses":"(p : Csyntax.program) (prog_defs : list (ident * globdef fundef type)) (prog_public : list ident) (prog_main : ident) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p =\nOK\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |}) (i : ident) (f : Csyntax.fundef) (tf : fundef) (H : (fun (_ : ident) (f0 : Csyntax.fundef) => transl_fundef (prog_comp_env p) f0)\n  i f = OK tf)","proofString":"apply transl_fundef_spec; auto."},{"statement":"(p : Csyntax.program) (prog_defs : list (ident * globdef fundef type)) (prog_public : list ident) (prog_main : ident) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p =\nOK\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |}) : forall (i : ident) (v tv : type),\n(fun (_ : ident) (v0 : type) => OK v0) i v = OK tv -> v = tv.","conclusion":"forall (i : ident) (v tv : type),\n(fun (_ : ident) (v0 : type) => OK v0) i v = OK tv -> v = tv","hypotheses":"(p : Csyntax.program) (prog_defs : list (ident * globdef fundef type)) (prog_public : list ident) (prog_main : ident) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p =\nOK\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |})","proofString":"intros.\ninv H.\nauto."},{"statement":"(p : Csyntax.program) (prog_defs : list (ident * globdef fundef type)) (prog_public : list ident) (prog_main : ident) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p =\nOK\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |}) (i : ident) (v tv : type) (H : (fun (_ : ident) (v0 : type) => OK v0) i v = OK tv) : v = tv.","conclusion":"v = tv","hypotheses":"(p : Csyntax.program) (prog_defs : list (ident * globdef fundef type)) (prog_public : list ident) (prog_main : ident) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p =\nOK\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |}) (i : ident) (v tv : type) (H : (fun (_ : ident) (v0 : type) => OK v0) i v = OK tv)","proofString":"inv H.\nauto."},{"statement":"(p : Csyntax.program) (prog_defs : list (ident * globdef fundef type)) (prog_public : list ident) (prog_main : ident) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p =\nOK\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |}) (i : ident) (tv : type) : tv = tv.","conclusion":"tv = tv","hypotheses":"(p : Csyntax.program) (prog_defs : list (ident * globdef fundef type)) (prog_public : list ident) (prog_main : ident) (EQ : transform_partial_program (transl_fundef (prog_comp_env p)) p =\nOK\n  {|\n    AST.prog_defs := prog_defs;\n    AST.prog_public := prog_public;\n    AST.prog_main := prog_main\n  |}) (i : ident) (tv : type)","proofString":"auto."},{"statement":"prog_comp_env tprog = prog_comp_env prog.","conclusion":"prog_comp_env tprog = prog_comp_env prog","hypotheses":"","proofString":"destruct TRANSL.\ngeneralize (prog_comp_env_eq tprog) (prog_comp_env_eq prog).\ncongruence."},{"statement":"(H : match_program_gen tr_fundef eq prog prog tprog) (H0 : prog_types tprog = prog_types prog) : prog_comp_env tprog = prog_comp_env prog.","conclusion":"prog_comp_env tprog = prog_comp_env prog","hypotheses":"(H : match_program_gen tr_fundef eq prog prog tprog) (H0 : prog_types tprog = prog_types prog)","proofString":"generalize (prog_comp_env_eq tprog) (prog_comp_env_eq prog).\ncongruence."},{"statement":"(H : match_program_gen tr_fundef eq prog prog tprog) (H0 : prog_types tprog = prog_types prog) : build_composite_env (prog_types tprog) = OK (prog_comp_env tprog) ->\nbuild_composite_env (prog_types prog) = OK (prog_comp_env prog) ->\nprog_comp_env tprog = prog_comp_env prog.","conclusion":"build_composite_env (prog_types tprog) = OK (prog_comp_env tprog) ->\nbuild_composite_env (prog_types prog) = OK (prog_comp_env prog) ->\nprog_comp_env tprog = prog_comp_env prog","hypotheses":"(H : match_program_gen tr_fundef eq prog prog tprog) (H0 : prog_types tprog = prog_types prog)","proofString":"congruence."},{"statement":"(cu : Csyntax.program) (f : Csyntax.fundef) (tf : fundef) (H : tr_fundef cu f tf) : type_of_fundef tf = Csyntax.type_of_fundef f.","conclusion":"type_of_fundef tf = Csyntax.type_of_fundef f","hypotheses":"(cu : Csyntax.program) (f : Csyntax.fundef) (tf : fundef) (H : tr_fundef cu f tf)","proofString":"inv H.\ninv H0; simpl.\nunfold type_of_function, Csyntax.type_of_function.\ncongruence.\nauto."},{"statement":"(cu : Csyntax.program) (f0 : Csyntax.function) (tf0 : function) (H0 : tr_function (prog_comp_env cu) f0 tf0) : type_of_fundef (Internal tf0) = Csyntax.type_of_fundef (Internal f0).","conclusion":"type_of_fundef (Internal tf0) = Csyntax.type_of_fundef (Internal f0)","hypotheses":"(cu : Csyntax.program) (f0 : Csyntax.function) (tf0 : function) (H0 : tr_function (prog_comp_env cu) f0 tf0)","proofString":"inv H0; simpl.\nunfold type_of_function, Csyntax.type_of_function.\ncongruence."},{"statement":"(cu : Csyntax.program) (f0 : Csyntax.function) (tf0 : function) (H : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f0) (fn_body tf0)) (H1 : fn_return tf0 = Csyntax.fn_return f0) (H2 : fn_callconv tf0 = Csyntax.fn_callconv f0) (H3 : fn_params tf0 = Csyntax.fn_params f0) (H4 : fn_vars tf0 = Csyntax.fn_vars f0) : type_of_function tf0 = Csyntax.type_of_function f0.","conclusion":"type_of_function tf0 = Csyntax.type_of_function f0","hypotheses":"(cu : Csyntax.program) (f0 : Csyntax.function) (tf0 : function) (H : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f0) (fn_body tf0)) (H1 : fn_return tf0 = Csyntax.fn_return f0) (H2 : fn_callconv tf0 = Csyntax.fn_callconv f0) (H3 : fn_params tf0 = Csyntax.fn_params f0) (H4 : fn_vars tf0 = Csyntax.fn_vars f0)","proofString":"unfold type_of_function, Csyntax.type_of_function.\ncongruence."},{"statement":"(cu : Csyntax.program) (f0 : Csyntax.function) (tf0 : function) (H : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f0) (fn_body tf0)) (H1 : fn_return tf0 = Csyntax.fn_return f0) (H2 : fn_callconv tf0 = Csyntax.fn_callconv f0) (H3 : fn_params tf0 = Csyntax.fn_params f0) (H4 : fn_vars tf0 = Csyntax.fn_vars f0) : Tfunction (type_of_params (fn_params tf0)) (fn_return tf0) (fn_callconv tf0) =\nTfunction (type_of_params (Csyntax.fn_params f0)) \n  (Csyntax.fn_return f0) (Csyntax.fn_callconv f0).","conclusion":"Tfunction (type_of_params (fn_params tf0)) (fn_return tf0) (fn_callconv tf0) =\nTfunction (type_of_params (Csyntax.fn_params f0)) \n  (Csyntax.fn_return f0) (Csyntax.fn_callconv f0)","hypotheses":"(cu : Csyntax.program) (f0 : Csyntax.function) (tf0 : function) (H : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f0) (fn_body tf0)) (H1 : fn_return tf0 = Csyntax.fn_return f0) (H2 : fn_callconv tf0 = Csyntax.fn_callconv f0) (H3 : fn_params tf0 = Csyntax.fn_params f0) (H4 : fn_vars tf0 = Csyntax.fn_vars f0)","proofString":"congruence."},{"statement":"(cu : Csyntax.program) (ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention) : type_of_fundef (External ef targs tres cconv) =\nCsyntax.type_of_fundef (External ef targs tres cconv).","conclusion":"type_of_fundef (External ef targs tres cconv) =\nCsyntax.type_of_fundef (External ef targs tres cconv)","hypotheses":"(cu : Csyntax.program) (ef : external_function) (targs : list type) (tres : type) (cconv : calling_convention)","proofString":"auto."},{"statement":"(ce : composite_env) (f : Csyntax.function) (tf : function) (H : tr_function ce f tf) : fn_return tf = Csyntax.fn_return f.","conclusion":"fn_return tf = Csyntax.fn_return f","hypotheses":"(ce : composite_env) (f : Csyntax.function) (tf : function) (H : tr_function ce f tf)","proofString":"inv H; auto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t : type) (l : block) (ofs : ptrofs) (H : eval_expr ge0 e le m a (Vptr l ofs)) : eval_lvalue ge0 e le m (Ederef' a t) l ofs Full.","conclusion":"eval_lvalue ge0 e le m (Ederef' a t) l ofs Full","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t : type) (l : block) (ofs : ptrofs) (H : eval_expr ge0 e le m a (Vptr l ofs))","proofString":"unfold Ederef'; destruct a; auto using eval_Ederef.\ndestruct (type_eq t (typeof a)); auto using eval_Ederef.\ninv H.\nauto.\ninv H0."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t0 t : type) (l : block) (ofs : ptrofs) (H : eval_expr ge0 e le m (Eaddrof a t0) (Vptr l ofs)) : eval_lvalue ge0 e le m\n  (if type_eq t (typeof a) then a else Ederef (Eaddrof a t0) t) l ofs Full.","conclusion":"eval_lvalue ge0 e le m\n  (if type_eq t (typeof a) then a else Ederef (Eaddrof a t0) t) l ofs Full","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t0 t : type) (l : block) (ofs : ptrofs) (H : eval_expr ge0 e le m (Eaddrof a t0) (Vptr l ofs))","proofString":"destruct (type_eq t (typeof a)); auto using eval_Ederef.\ninv H.\nauto.\ninv H0."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t0 t : type) (l : block) (ofs : ptrofs) (H : eval_expr ge0 e le m (Eaddrof a t0) (Vptr l ofs)) (e0 : t = typeof a) : eval_lvalue ge0 e le m a l ofs Full.","conclusion":"eval_lvalue ge0 e le m a l ofs Full","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t0 t : type) (l : block) (ofs : ptrofs) (H : eval_expr ge0 e le m (Eaddrof a t0) (Vptr l ofs)) (e0 : t = typeof a)","proofString":"inv H.\nauto.\ninv H0."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t0 : type) (l : block) (ofs : ptrofs) (H1 : eval_lvalue ge0 e le m a l ofs Full) : eval_lvalue ge0 e le m a l ofs Full.","conclusion":"eval_lvalue ge0 e le m a l ofs Full","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t0 : type) (l : block) (ofs : ptrofs) (H1 : eval_lvalue ge0 e le m a l ofs Full)","proofString":"auto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t0 : type) (l : block) (ofs : ptrofs) (loc : block) (ofs0 : ptrofs) (bf : bitfield) (H0 : eval_lvalue ge0 e le m (Eaddrof a t0) loc ofs0 bf) (H1 : deref_loc (typeof (Eaddrof a t0)) m loc ofs0 bf (Vptr l ofs)) : eval_lvalue ge0 e le m a l ofs Full.","conclusion":"eval_lvalue ge0 e le m a l ofs Full","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t0 : type) (l : block) (ofs : ptrofs) (loc : block) (ofs0 : ptrofs) (bf : bitfield) (H0 : eval_lvalue ge0 e le m (Eaddrof a t0) loc ofs0 bf) (H1 : deref_loc (typeof (Eaddrof a t0)) m loc ofs0 bf (Vptr l ofs))","proofString":"inv H0."},{"statement":"(a : expr) (t0 t : type) : typeof (if type_eq t (typeof a) then a else Ederef (Eaddrof a t0) t) = t.","conclusion":"typeof (if type_eq t (typeof a) then a else Ederef (Eaddrof a t0) t) = t","hypotheses":"(a : expr) (t0 t : type)","proofString":"destruct (type_eq t (typeof a)); auto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t : type) (l : block) (ofs : ptrofs) (H : eval_lvalue ge0 e le m a l ofs Full) : eval_expr ge0 e le m (Eaddrof' a t) (Vptr l ofs).","conclusion":"eval_expr ge0 e le m (Eaddrof' a t) (Vptr l ofs)","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t : type) (l : block) (ofs : ptrofs) (H : eval_lvalue ge0 e le m a l ofs Full)","proofString":"unfold Eaddrof'; destruct a; auto using eval_Eaddrof.\ndestruct (type_eq t (typeof a)); auto using eval_Eaddrof.\ninv H; auto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t0 t : type) (l : block) (ofs : ptrofs) (H : eval_lvalue ge0 e le m (Ederef a t0) l ofs Full) : eval_expr ge0 e le m\n  (if type_eq t (typeof a) then a else Eaddrof (Ederef a t0) t) \n  (Vptr l ofs).","conclusion":"eval_expr ge0 e le m\n  (if type_eq t (typeof a) then a else Eaddrof (Ederef a t0) t) \n  (Vptr l ofs)","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t0 t : type) (l : block) (ofs : ptrofs) (H : eval_lvalue ge0 e le m (Ederef a t0) l ofs Full)","proofString":"destruct (type_eq t (typeof a)); auto using eval_Eaddrof.\ninv H; auto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t0 t : type) (l : block) (ofs : ptrofs) (H : eval_lvalue ge0 e le m (Ederef a t0) l ofs Full) (e0 : t = typeof a) : eval_expr ge0 e le m a (Vptr l ofs).","conclusion":"eval_expr ge0 e le m a (Vptr l ofs)","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (t0 t : type) (l : block) (ofs : ptrofs) (H : eval_lvalue ge0 e le m (Ederef a t0) l ofs Full) (e0 : t = typeof a)","proofString":"inv H; auto."},{"statement":"(a : expr) (t0 t : type) : typeof (if type_eq t (typeof a) then a else Eaddrof (Ederef a t0) t) = t.","conclusion":"typeof (if type_eq t (typeof a) then a else Eaddrof (Ederef a t0) t) = t","hypotheses":"(a : expr) (t0 t : type)","proofString":"destruct (type_eq t (typeof a)); auto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) : eval_expr ge0 e le m (make_normalize sz sg width a)\n  (Vint (bitfield_normalize sz sg width n)).","conclusion":"eval_expr ge0 e le m (make_normalize sz sg width a)\n  (Vint (bitfield_normalize sz sg width n))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n))","proofString":"unfold make_normalize, bitfield_normalize.\nassert (bitsize_intsize sz <= Int.zwordsize) by (destruct sz; compute; congruence).\ndestruct (intsize_eq sz IBool || signedness_eq sg Unsigned).\nrewrite Int.zero_ext_and by lia.\neconstructor.\neauto.\neconstructor.\nrewrite H1; simpl.\nunfold sem_and, sem_binarith.\nassert (A: exists sg2, classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2).\nunfold classify_binarith.\nunfold type_int32s.\ndestruct sz, sg1; econstructor; eauto.\ndestruct A as (sg2 & A); rewrite A.\nunfold binarith_type.\nassert (B: forall i sz0 sg0 attr0,             sem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m = Some (Vint i)).\nintros.\nunfold sem_cast, classify_cast.\ndestruct Archi.ptr64; reflexivity.\nunfold type_int32s; rewrite ! B.\nauto.\nrewrite Int.sign_ext_shr_shl by lia.\nset (amount := Int.repr (Int.zwordsize - width)).\nassert (LT: Int.ltu amount Int.iwordsize = true).\nunfold Int.ltu.\nrewrite Int.unsigned_repr_wordsize.\napply zlt_true.\nunfold amount; rewrite Int.unsigned_repr.\nlia.\nassert (Int.zwordsize < Int.max_unsigned) by reflexivity.\nlia.\neconstructor.\neconstructor.\neauto.\neconstructor.\nrewrite H1.\nunfold sem_binary_operation, sem_shl, sem_shift.\nrewrite LT.\ndestruct sz, sg1; reflexivity.\neconstructor.\nunfold sem_binary_operation, sem_shr, sem_shift.\nrewrite LT.\nreflexivity."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) : eval_expr ge0 e le m\n  (if intsize_eq sz IBool || signedness_eq sg Unsigned\n   then\n    Ebinop Oand a (Econst_int (Int.repr (two_p width - 1)) type_int32s)\n      (typeof a)\n   else\n    Ebinop Oshr\n      (Ebinop Oshl a\n         (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s)\n         type_int32s)\n      (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s) \n      (typeof a))\n  (Vint\n     (if intsize_eq sz IBool || signedness_eq sg Unsigned\n      then Int.zero_ext width n\n      else Int.sign_ext width n)).","conclusion":"eval_expr ge0 e le m\n  (if intsize_eq sz IBool || signedness_eq sg Unsigned\n   then\n    Ebinop Oand a (Econst_int (Int.repr (two_p width - 1)) type_int32s)\n      (typeof a)\n   else\n    Ebinop Oshr\n      (Ebinop Oshl a\n         (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s)\n         type_int32s)\n      (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s) \n      (typeof a))\n  (Vint\n     (if intsize_eq sz IBool || signedness_eq sg Unsigned\n      then Int.zero_ext width n\n      else Int.sign_ext width n))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n))","proofString":"assert (bitsize_intsize sz <= Int.zwordsize) by (destruct sz; compute; congruence).\ndestruct (intsize_eq sz IBool || signedness_eq sg Unsigned).\nrewrite Int.zero_ext_and by lia.\neconstructor.\neauto.\neconstructor.\nrewrite H1; simpl.\nunfold sem_and, sem_binarith.\nassert (A: exists sg2, classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2).\nunfold classify_binarith.\nunfold type_int32s.\ndestruct sz, sg1; econstructor; eauto.\ndestruct A as (sg2 & A); rewrite A.\nunfold binarith_type.\nassert (B: forall i sz0 sg0 attr0,             sem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m = Some (Vint i)).\nintros.\nunfold sem_cast, classify_cast.\ndestruct Archi.ptr64; reflexivity.\nunfold type_int32s; rewrite ! B.\nauto.\nrewrite Int.sign_ext_shr_shl by lia.\nset (amount := Int.repr (Int.zwordsize - width)).\nassert (LT: Int.ltu amount Int.iwordsize = true).\nunfold Int.ltu.\nrewrite Int.unsigned_repr_wordsize.\napply zlt_true.\nunfold amount; rewrite Int.unsigned_repr.\nlia.\nassert (Int.zwordsize < Int.max_unsigned) by reflexivity.\nlia.\neconstructor.\neconstructor.\neauto.\neconstructor.\nrewrite H1.\nunfold sem_binary_operation, sem_shl, sem_shift.\nrewrite LT.\ndestruct sz, sg1; reflexivity.\neconstructor.\nunfold sem_binary_operation, sem_shr, sem_shift.\nrewrite LT.\nreflexivity."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) : eval_expr ge0 e le m\n  (if intsize_eq sz IBool || signedness_eq sg Unsigned\n   then\n    Ebinop Oand a (Econst_int (Int.repr (two_p width - 1)) type_int32s)\n      (typeof a)\n   else\n    Ebinop Oshr\n      (Ebinop Oshl a\n         (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s)\n         type_int32s)\n      (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s) \n      (typeof a))\n  (Vint\n     (if intsize_eq sz IBool || signedness_eq sg Unsigned\n      then Int.zero_ext width n\n      else Int.sign_ext width n)).","conclusion":"eval_expr ge0 e le m\n  (if intsize_eq sz IBool || signedness_eq sg Unsigned\n   then\n    Ebinop Oand a (Econst_int (Int.repr (two_p width - 1)) type_int32s)\n      (typeof a)\n   else\n    Ebinop Oshr\n      (Ebinop Oshl a\n         (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s)\n         type_int32s)\n      (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s) \n      (typeof a))\n  (Vint\n     (if intsize_eq sz IBool || signedness_eq sg Unsigned\n      then Int.zero_ext width n\n      else Int.sign_ext width n))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize)","proofString":"destruct (intsize_eq sz IBool || signedness_eq sg Unsigned).\nrewrite Int.zero_ext_and by lia.\neconstructor.\neauto.\neconstructor.\nrewrite H1; simpl.\nunfold sem_and, sem_binarith.\nassert (A: exists sg2, classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2).\nunfold classify_binarith.\nunfold type_int32s.\ndestruct sz, sg1; econstructor; eauto.\ndestruct A as (sg2 & A); rewrite A.\nunfold binarith_type.\nassert (B: forall i sz0 sg0 attr0,             sem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m = Some (Vint i)).\nintros.\nunfold sem_cast, classify_cast.\ndestruct Archi.ptr64; reflexivity.\nunfold type_int32s; rewrite ! B.\nauto.\nrewrite Int.sign_ext_shr_shl by lia.\nset (amount := Int.repr (Int.zwordsize - width)).\nassert (LT: Int.ltu amount Int.iwordsize = true).\nunfold Int.ltu.\nrewrite Int.unsigned_repr_wordsize.\napply zlt_true.\nunfold amount; rewrite Int.unsigned_repr.\nlia.\nassert (Int.zwordsize < Int.max_unsigned) by reflexivity.\nlia.\neconstructor.\neconstructor.\neauto.\neconstructor.\nrewrite H1.\nunfold sem_binary_operation, sem_shl, sem_shift.\nrewrite LT.\ndestruct sz, sg1; reflexivity.\neconstructor.\nunfold sem_binary_operation, sem_shr, sem_shift.\nrewrite LT.\nreflexivity."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) : eval_expr ge0 e le m\n  (Ebinop Oand a (Econst_int (Int.repr (two_p width - 1)) type_int32s)\n     (typeof a)) (Vint (Int.zero_ext width n)).","conclusion":"eval_expr ge0 e le m\n  (Ebinop Oand a (Econst_int (Int.repr (two_p width - 1)) type_int32s)\n     (typeof a)) (Vint (Int.zero_ext width n))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize)","proofString":"rewrite Int.zero_ext_and by lia.\neconstructor.\neauto.\neconstructor.\nrewrite H1; simpl.\nunfold sem_and, sem_binarith.\nassert (A: exists sg2, classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2).\nunfold classify_binarith.\nunfold type_int32s.\ndestruct sz, sg1; econstructor; eauto.\ndestruct A as (sg2 & A); rewrite A.\nunfold binarith_type.\nassert (B: forall i sz0 sg0 attr0,             sem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m = Some (Vint i)).\nintros.\nunfold sem_cast, classify_cast.\ndestruct Archi.ptr64; reflexivity.\nunfold type_int32s; rewrite ! B.\nauto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) : eval_expr ge0 e le m\n  (Ebinop Oand a (Econst_int (Int.repr (two_p width - 1)) type_int32s)\n     (typeof a)) (Vint (Int.and n (Int.repr (two_p width - 1)))).","conclusion":"eval_expr ge0 e le m\n  (Ebinop Oand a (Econst_int (Int.repr (two_p width - 1)) type_int32s)\n     (typeof a)) (Vint (Int.and n (Int.repr (two_p width - 1))))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize)","proofString":"econstructor.\neauto.\neconstructor.\nrewrite H1; simpl.\nunfold sem_and, sem_binarith.\nassert (A: exists sg2, classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2).\nunfold classify_binarith.\nunfold type_int32s.\ndestruct sz, sg1; econstructor; eauto.\ndestruct A as (sg2 & A); rewrite A.\nunfold binarith_type.\nassert (B: forall i sz0 sg0 attr0,             sem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m = Some (Vint i)).\nintros.\nunfold sem_cast, classify_cast.\ndestruct Archi.ptr64; reflexivity.\nunfold type_int32s; rewrite ! B.\nauto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) : sem_and (Vint n) (Tint sz sg1 attr) (Vint (Int.repr (two_p width - 1)))\n  type_int32s m = Some (Vint (Int.and n (Int.repr (two_p width - 1)))).","conclusion":"sem_and (Vint n) (Tint sz sg1 attr) (Vint (Int.repr (two_p width - 1)))\n  type_int32s m = Some (Vint (Int.and n (Int.repr (two_p width - 1))))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize)","proofString":"unfold sem_and, sem_binarith.\nassert (A: exists sg2, classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2).\nunfold classify_binarith.\nunfold type_int32s.\ndestruct sz, sg1; econstructor; eauto.\ndestruct A as (sg2 & A); rewrite A.\nunfold binarith_type.\nassert (B: forall i sz0 sg0 attr0,             sem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m = Some (Vint i)).\nintros.\nunfold sem_cast, classify_cast.\ndestruct Archi.ptr64; reflexivity.\nunfold type_int32s; rewrite ! B.\nauto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) : match\n  sem_cast (Vint n) (Tint sz sg1 attr)\n    (binarith_type (classify_binarith (Tint sz sg1 attr) type_int32s)) m\nwith\n| Some v1' =>\n    match\n      sem_cast (Vint (Int.repr (two_p width - 1))) type_int32s\n        (binarith_type (classify_binarith (Tint sz sg1 attr) type_int32s)) m\n    with\n    | Some v2' =>\n        match classify_binarith (Tint sz sg1 attr) type_int32s with\n        | bin_case_i _ =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => Some (Vint (Int.and n1 n2))\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l _ =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => Some (Vlong (Int64.and n1 n2))\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat _ => match v2' with\n                          | Vundef | _ => None\n                          end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle _ => match v2' with\n                           | Vundef | _ => None\n                           end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some (Vint (Int.and n (Int.repr (two_p width - 1)))).","conclusion":"match\n  sem_cast (Vint n) (Tint sz sg1 attr)\n    (binarith_type (classify_binarith (Tint sz sg1 attr) type_int32s)) m\nwith\n| Some v1' =>\n    match\n      sem_cast (Vint (Int.repr (two_p width - 1))) type_int32s\n        (binarith_type (classify_binarith (Tint sz sg1 attr) type_int32s)) m\n    with\n    | Some v2' =>\n        match classify_binarith (Tint sz sg1 attr) type_int32s with\n        | bin_case_i _ =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => Some (Vint (Int.and n1 n2))\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l _ =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => Some (Vlong (Int64.and n1 n2))\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat _ => match v2' with\n                          | Vundef | _ => None\n                          end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle _ => match v2' with\n                           | Vundef | _ => None\n                           end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some (Vint (Int.and n (Int.repr (two_p width - 1))))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize)","proofString":"assert (A: exists sg2, classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2).\nunfold classify_binarith.\nunfold type_int32s.\ndestruct sz, sg1; econstructor; eauto.\ndestruct A as (sg2 & A); rewrite A.\nunfold binarith_type.\nassert (B: forall i sz0 sg0 attr0,             sem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m = Some (Vint i)).\nintros.\nunfold sem_cast, classify_cast.\ndestruct Archi.ptr64; reflexivity.\nunfold type_int32s; rewrite ! B.\nauto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) : exists sg2 : signedness,\n  classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2.","conclusion":"exists sg2 : signedness,\n  classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize)","proofString":"unfold classify_binarith.\nunfold type_int32s.\ndestruct sz, sg1; econstructor; eauto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) : exists sg2 : signedness,\n  match sz with\n  | I32 =>\n      match sg1 with\n      | Signed =>\n          match type_int32s with\n          | Tint I32 Unsigned _ => bin_case_i Unsigned\n          | Tint I8 _ _ | Tint I16 _ _ | Tint I32 Signed _ |\n            Tint IBool _ _ => bin_case_i Signed\n          | Tlong sg0 _ => bin_case_l sg0\n          | Tfloat F32 _ => bin_case_s\n          | Tfloat F64 _ => bin_case_f\n          | _ => bin_default\n          end\n      | Unsigned =>\n          match type_int32s with\n          | Tint _ _ _ => bin_case_i Unsigned\n          | Tlong sg0 _ => bin_case_l sg0\n          | Tfloat F32 _ => bin_case_s\n          | Tfloat F64 _ => bin_case_f\n          | _ => bin_default\n          end\n      end\n  | _ =>\n      match type_int32s with\n      | Tint I32 Unsigned _ => bin_case_i Unsigned\n      | Tint I8 _ _ | Tint I16 _ _ | Tint I32 Signed _ | Tint IBool _ _ =>\n          bin_case_i Signed\n      | Tlong sg0 _ => bin_case_l sg0\n      | Tfloat F32 _ => bin_case_s\n      | Tfloat F64 _ => bin_case_f\n      | _ => bin_default\n      end\n  end = bin_case_i sg2.","conclusion":"exists sg2 : signedness,\n  match sz with\n  | I32 =>\n      match sg1 with\n      | Signed =>\n          match type_int32s with\n          | Tint I32 Unsigned _ => bin_case_i Unsigned\n          | Tint I8 _ _ | Tint I16 _ _ | Tint I32 Signed _ |\n            Tint IBool _ _ => bin_case_i Signed\n          | Tlong sg0 _ => bin_case_l sg0\n          | Tfloat F32 _ => bin_case_s\n          | Tfloat F64 _ => bin_case_f\n          | _ => bin_default\n          end\n      | Unsigned =>\n          match type_int32s with\n          | Tint _ _ _ => bin_case_i Unsigned\n          | Tlong sg0 _ => bin_case_l sg0\n          | Tfloat F32 _ => bin_case_s\n          | Tfloat F64 _ => bin_case_f\n          | _ => bin_default\n          end\n      end\n  | _ =>\n      match type_int32s with\n      | Tint I32 Unsigned _ => bin_case_i Unsigned\n      | Tint I8 _ _ | Tint I16 _ _ | Tint I32 Signed _ | Tint IBool _ _ =>\n          bin_case_i Signed\n      | Tlong sg0 _ => bin_case_l sg0\n      | Tfloat F32 _ => bin_case_s\n      | Tfloat F64 _ => bin_case_f\n      | _ => bin_default\n      end\n  end = bin_case_i sg2","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize)","proofString":"unfold type_int32s.\ndestruct sz, sg1; econstructor; eauto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) : exists sg2 : signedness,\n  match sz with\n  | I32 =>\n      match sg1 with\n      | Signed => bin_case_i Signed\n      | Unsigned => bin_case_i Unsigned\n      end\n  | _ => bin_case_i Signed\n  end = bin_case_i sg2.","conclusion":"exists sg2 : signedness,\n  match sz with\n  | I32 =>\n      match sg1 with\n      | Signed => bin_case_i Signed\n      | Unsigned => bin_case_i Unsigned\n      end\n  | _ => bin_case_i Signed\n  end = bin_case_i sg2","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize)","proofString":"destruct sz, sg1; econstructor; eauto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (A : exists sg2 : signedness,\n  classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2) : match\n  sem_cast (Vint n) (Tint sz sg1 attr)\n    (binarith_type (classify_binarith (Tint sz sg1 attr) type_int32s)) m\nwith\n| Some v1' =>\n    match\n      sem_cast (Vint (Int.repr (two_p width - 1))) type_int32s\n        (binarith_type (classify_binarith (Tint sz sg1 attr) type_int32s)) m\n    with\n    | Some v2' =>\n        match classify_binarith (Tint sz sg1 attr) type_int32s with\n        | bin_case_i _ =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => Some (Vint (Int.and n1 n2))\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l _ =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => Some (Vlong (Int64.and n1 n2))\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat _ => match v2' with\n                          | Vundef | _ => None\n                          end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle _ => match v2' with\n                           | Vundef | _ => None\n                           end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some (Vint (Int.and n (Int.repr (two_p width - 1)))).","conclusion":"match\n  sem_cast (Vint n) (Tint sz sg1 attr)\n    (binarith_type (classify_binarith (Tint sz sg1 attr) type_int32s)) m\nwith\n| Some v1' =>\n    match\n      sem_cast (Vint (Int.repr (two_p width - 1))) type_int32s\n        (binarith_type (classify_binarith (Tint sz sg1 attr) type_int32s)) m\n    with\n    | Some v2' =>\n        match classify_binarith (Tint sz sg1 attr) type_int32s with\n        | bin_case_i _ =>\n            match v1' with\n            | Vint n1 =>\n                match v2' with\n                | Vint n2 => Some (Vint (Int.and n1 n2))\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_l _ =>\n            match v1' with\n            | Vlong n1 =>\n                match v2' with\n                | Vlong n2 => Some (Vlong (Int64.and n1 n2))\n                | _ => None\n                end\n            | _ => None\n            end\n        | bin_case_f =>\n            match v1' with\n            | Vfloat _ => match v2' with\n                          | Vundef | _ => None\n                          end\n            | _ => None\n            end\n        | bin_case_s =>\n            match v1' with\n            | Vsingle _ => match v2' with\n                           | Vundef | _ => None\n                           end\n            | _ => None\n            end\n        | bin_default => None\n        end\n    | None => None\n    end\n| None => None\nend = Some (Vint (Int.and n (Int.repr (two_p width - 1))))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (A : exists sg2 : signedness,\n  classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2)","proofString":"destruct A as (sg2 & A); rewrite A.\nunfold binarith_type.\nassert (B: forall i sz0 sg0 attr0,             sem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m = Some (Vint i)).\nintros.\nunfold sem_cast, classify_cast.\ndestruct Archi.ptr64; reflexivity.\nunfold type_int32s; rewrite ! B.\nauto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2) : match\n  sem_cast (Vint n) (Tint sz sg1 attr) (binarith_type (bin_case_i sg2)) m\nwith\n| Some v1' =>\n    match\n      sem_cast (Vint (Int.repr (two_p width - 1))) type_int32s\n        (binarith_type (bin_case_i sg2)) m\n    with\n    | Some v2' =>\n        match v1' with\n        | Vint n1 =>\n            match v2' with\n            | Vint n2 => Some (Vint (Int.and n1 n2))\n            | _ => None\n            end\n        | _ => None\n        end\n    | None => None\n    end\n| None => None\nend = Some (Vint (Int.and n (Int.repr (two_p width - 1)))).","conclusion":"match\n  sem_cast (Vint n) (Tint sz sg1 attr) (binarith_type (bin_case_i sg2)) m\nwith\n| Some v1' =>\n    match\n      sem_cast (Vint (Int.repr (two_p width - 1))) type_int32s\n        (binarith_type (bin_case_i sg2)) m\n    with\n    | Some v2' =>\n        match v1' with\n        | Vint n1 =>\n            match v2' with\n            | Vint n2 => Some (Vint (Int.and n1 n2))\n            | _ => None\n            end\n        | _ => None\n        end\n    | None => None\n    end\n| None => None\nend = Some (Vint (Int.and n (Int.repr (two_p width - 1))))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2)","proofString":"unfold binarith_type.\nassert (B: forall i sz0 sg0 attr0,             sem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m = Some (Vint i)).\nintros.\nunfold sem_cast, classify_cast.\ndestruct Archi.ptr64; reflexivity.\nunfold type_int32s; rewrite ! B.\nauto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2) : match sem_cast (Vint n) (Tint sz sg1 attr) (Tint I32 sg2 noattr) m with\n| Some v1' =>\n    match\n      sem_cast (Vint (Int.repr (two_p width - 1))) type_int32s\n        (Tint I32 sg2 noattr) m\n    with\n    | Some v2' =>\n        match v1' with\n        | Vint n1 =>\n            match v2' with\n            | Vint n2 => Some (Vint (Int.and n1 n2))\n            | _ => None\n            end\n        | _ => None\n        end\n    | None => None\n    end\n| None => None\nend = Some (Vint (Int.and n (Int.repr (two_p width - 1)))).","conclusion":"match sem_cast (Vint n) (Tint sz sg1 attr) (Tint I32 sg2 noattr) m with\n| Some v1' =>\n    match\n      sem_cast (Vint (Int.repr (two_p width - 1))) type_int32s\n        (Tint I32 sg2 noattr) m\n    with\n    | Some v2' =>\n        match v1' with\n        | Vint n1 =>\n            match v2' with\n            | Vint n2 => Some (Vint (Int.and n1 n2))\n            | _ => None\n            end\n        | _ => None\n        end\n    | None => None\n    end\n| None => None\nend = Some (Vint (Int.and n (Int.repr (two_p width - 1))))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2)","proofString":"assert (B: forall i sz0 sg0 attr0,             sem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m = Some (Vint i)).\nintros.\nunfold sem_cast, classify_cast.\ndestruct Archi.ptr64; reflexivity.\nunfold type_int32s; rewrite ! B.\nauto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2) : forall (i : int) (sz0 : intsize) (sg0 : signedness) (attr0 : Ctypes.attr),\nsem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m =\nSome (Vint i).","conclusion":"forall (i : int) (sz0 : intsize) (sg0 : signedness) (attr0 : Ctypes.attr),\nsem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m =\nSome (Vint i)","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2)","proofString":"intros.\nunfold sem_cast, classify_cast.\ndestruct Archi.ptr64; reflexivity."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2) (i : int) (sz0 : intsize) (sg0 : signedness) (attr0 : Ctypes.attr) : sem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m =\nSome (Vint i).","conclusion":"sem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m =\nSome (Vint i)","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2) (i : int) (sz0 : intsize) (sg0 : signedness) (attr0 : Ctypes.attr)","proofString":"unfold sem_cast, classify_cast.\ndestruct Archi.ptr64; reflexivity."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2) (i : int) (sz0 : intsize) (sg0 : signedness) (attr0 : Ctypes.attr) : match (if Archi.ptr64 then cast_case_i2i I32 sg2 else cast_case_pointer) with\n| cast_case_pointer => if Archi.ptr64 then None else Some (Vint i)\n| cast_case_i2i sz2 si2 => Some (Vint (cast_int_int sz2 si2 i))\n| cast_case_i2f si1 => Some (Vfloat (cast_int_float si1 i))\n| cast_case_i2s si1 => Some (Vsingle (cast_int_single si1 i))\n| cast_case_i2l si => Some (Vlong (cast_int_long si i))\n| cast_case_i2bool =>\n    Some (Vint (if Int.eq i Int.zero then Int.zero else Int.one))\n| cast_case_void => Some (Vint i)\n| _ => None\nend = Some (Vint i).","conclusion":"match (if Archi.ptr64 then cast_case_i2i I32 sg2 else cast_case_pointer) with\n| cast_case_pointer => if Archi.ptr64 then None else Some (Vint i)\n| cast_case_i2i sz2 si2 => Some (Vint (cast_int_int sz2 si2 i))\n| cast_case_i2f si1 => Some (Vfloat (cast_int_float si1 i))\n| cast_case_i2s si1 => Some (Vsingle (cast_int_single si1 i))\n| cast_case_i2l si => Some (Vlong (cast_int_long si i))\n| cast_case_i2bool =>\n    Some (Vint (if Int.eq i Int.zero then Int.zero else Int.one))\n| cast_case_void => Some (Vint i)\n| _ => None\nend = Some (Vint i)","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2) (i : int) (sz0 : intsize) (sg0 : signedness) (attr0 : Ctypes.attr)","proofString":"destruct Archi.ptr64; reflexivity."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2) (B : forall (i : int) (sz0 : intsize) (sg0 : signedness) (attr0 : Ctypes.attr),\nsem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m =\nSome (Vint i)) : match sem_cast (Vint n) (Tint sz sg1 attr) (Tint I32 sg2 noattr) m with\n| Some v1' =>\n    match\n      sem_cast (Vint (Int.repr (two_p width - 1))) type_int32s\n        (Tint I32 sg2 noattr) m\n    with\n    | Some v2' =>\n        match v1' with\n        | Vint n1 =>\n            match v2' with\n            | Vint n2 => Some (Vint (Int.and n1 n2))\n            | _ => None\n            end\n        | _ => None\n        end\n    | None => None\n    end\n| None => None\nend = Some (Vint (Int.and n (Int.repr (two_p width - 1)))).","conclusion":"match sem_cast (Vint n) (Tint sz sg1 attr) (Tint I32 sg2 noattr) m with\n| Some v1' =>\n    match\n      sem_cast (Vint (Int.repr (two_p width - 1))) type_int32s\n        (Tint I32 sg2 noattr) m\n    with\n    | Some v2' =>\n        match v1' with\n        | Vint n1 =>\n            match v2' with\n            | Vint n2 => Some (Vint (Int.and n1 n2))\n            | _ => None\n            end\n        | _ => None\n        end\n    | None => None\n    end\n| None => None\nend = Some (Vint (Int.and n (Int.repr (two_p width - 1))))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2) (B : forall (i : int) (sz0 : intsize) (sg0 : signedness) (attr0 : Ctypes.attr),\nsem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m =\nSome (Vint i))","proofString":"unfold type_int32s; rewrite ! B.\nauto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2) (B : forall (i : int) (sz0 : intsize) (sg0 : signedness) (attr0 : Ctypes.attr),\nsem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m =\nSome (Vint i)) : Some (Vint (Int.and n (Int.repr (two_p width - 1)))) =\nSome (Vint (Int.and n (Int.repr (two_p width - 1)))).","conclusion":"Some (Vint (Int.and n (Int.repr (two_p width - 1)))) =\nSome (Vint (Int.and n (Int.repr (two_p width - 1))))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (sg2 : signedness) (A : classify_binarith (Tint sz sg1 attr) type_int32s = bin_case_i sg2) (B : forall (i : int) (sz0 : intsize) (sg0 : signedness) (attr0 : Ctypes.attr),\nsem_cast (Vint i) (Tint sz0 sg0 attr0) (Tint I32 sg2 noattr) m =\nSome (Vint i))","proofString":"auto."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) : eval_expr ge0 e le m\n  (Ebinop Oshr\n     (Ebinop Oshl a\n        (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s)\n        type_int32s)\n     (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s) \n     (typeof a)) (Vint (Int.sign_ext width n)).","conclusion":"eval_expr ge0 e le m\n  (Ebinop Oshr\n     (Ebinop Oshl a\n        (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s)\n        type_int32s)\n     (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s) \n     (typeof a)) (Vint (Int.sign_ext width n))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize)","proofString":"rewrite Int.sign_ext_shr_shl by lia.\nset (amount := Int.repr (Int.zwordsize - width)).\nassert (LT: Int.ltu amount Int.iwordsize = true).\nunfold Int.ltu.\nrewrite Int.unsigned_repr_wordsize.\napply zlt_true.\nunfold amount; rewrite Int.unsigned_repr.\nlia.\nassert (Int.zwordsize < Int.max_unsigned) by reflexivity.\nlia.\neconstructor.\neconstructor.\neauto.\neconstructor.\nrewrite H1.\nunfold sem_binary_operation, sem_shl, sem_shift.\nrewrite LT.\ndestruct sz, sg1; reflexivity.\neconstructor.\nunfold sem_binary_operation, sem_shr, sem_shift.\nrewrite LT.\nreflexivity."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) : eval_expr ge0 e le m\n  (Ebinop Oshr\n     (Ebinop Oshl a\n        (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s)\n        type_int32s)\n     (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s) \n     (typeof a))\n  (Vint\n     (Int.shr (Int.shl n (Int.repr (Int.zwordsize - width)))\n        (Int.repr (Int.zwordsize - width)))).","conclusion":"eval_expr ge0 e le m\n  (Ebinop Oshr\n     (Ebinop Oshl a\n        (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s)\n        type_int32s)\n     (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s) \n     (typeof a))\n  (Vint\n     (Int.shr (Int.shl n (Int.repr (Int.zwordsize - width)))\n        (Int.repr (Int.zwordsize - width))))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize)","proofString":"set (amount := Int.repr (Int.zwordsize - width)).\nassert (LT: Int.ltu amount Int.iwordsize = true).\nunfold Int.ltu.\nrewrite Int.unsigned_repr_wordsize.\napply zlt_true.\nunfold amount; rewrite Int.unsigned_repr.\nlia.\nassert (Int.zwordsize < Int.max_unsigned) by reflexivity.\nlia.\neconstructor.\neconstructor.\neauto.\neconstructor.\nrewrite H1.\nunfold sem_binary_operation, sem_shl, sem_shift.\nrewrite LT.\ndestruct sz, sg1; reflexivity.\neconstructor.\nunfold sem_binary_operation, sem_shr, sem_shift.\nrewrite LT.\nreflexivity."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (amount : int) : Int.zwordsize - width < Int.zwordsize.","conclusion":"Int.zwordsize - width < Int.zwordsize","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (amount : int)","proofString":"lia."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (amount : int) : 0 <= Int.zwordsize - width <= Int.max_unsigned.","conclusion":"0 <= Int.zwordsize - width <= Int.max_unsigned","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (amount : int)","proofString":"assert (Int.zwordsize < Int.max_unsigned) by reflexivity.\nlia."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (amount : int) (H4 : Int.zwordsize < Int.max_unsigned) : 0 <= Int.zwordsize - width <= Int.max_unsigned.","conclusion":"0 <= Int.zwordsize - width <= Int.max_unsigned","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (amount : int) (H4 : Int.zwordsize < Int.max_unsigned)","proofString":"lia."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (amount : int) (LT : Int.ltu amount Int.iwordsize = true) : eval_expr ge0 e le m\n  (Ebinop Oshr (Ebinop Oshl a (Econst_int amount type_int32s) type_int32s)\n     (Econst_int amount type_int32s) (typeof a))\n  (Vint (Int.shr (Int.shl n amount) amount)).","conclusion":"eval_expr ge0 e le m\n  (Ebinop Oshr (Ebinop Oshl a (Econst_int amount type_int32s) type_int32s)\n     (Econst_int amount type_int32s) (typeof a))\n  (Vint (Int.shr (Int.shl n amount) amount))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (amount : int) (LT : Int.ltu amount Int.iwordsize = true)","proofString":"econstructor.\neconstructor.\neauto.\neconstructor.\nrewrite H1.\nunfold sem_binary_operation, sem_shl, sem_shift.\nrewrite LT.\ndestruct sz, sg1; reflexivity.\neconstructor.\nunfold sem_binary_operation, sem_shr, sem_shift.\nrewrite LT.\nreflexivity."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (amount : int) (LT : Int.ltu amount Int.iwordsize = true) : match\n  classify_shift\n    (typeof (Ebinop Oshl a (Econst_int amount type_int32s) type_int32s))\n    (typeof (Econst_int amount type_int32s))\nwith\n| shift_case_ii sg0 =>\n    if Int.ltu amount Int.iwordsize\n    then\n     Some\n       (Vint\n          match sg0 with\n          | Signed => Int.shr (Int.shl n amount) amount\n          | Unsigned => Int.shru (Int.shl n amount) amount\n          end)\n    else None\n| _ => None\nend = Some (Vint (Int.shr (Int.shl n amount) amount)).","conclusion":"match\n  classify_shift\n    (typeof (Ebinop Oshl a (Econst_int amount type_int32s) type_int32s))\n    (typeof (Econst_int amount type_int32s))\nwith\n| shift_case_ii sg0 =>\n    if Int.ltu amount Int.iwordsize\n    then\n     Some\n       (Vint\n          match sg0 with\n          | Signed => Int.shr (Int.shl n amount) amount\n          | Unsigned => Int.shru (Int.shl n amount) amount\n          end)\n    else None\n| _ => None\nend = Some (Vint (Int.shr (Int.shl n amount) amount))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (amount : int) (LT : Int.ltu amount Int.iwordsize = true)","proofString":"rewrite LT.\nreflexivity."},{"statement":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (amount : int) (LT : Int.ltu amount Int.iwordsize = true) : match\n  classify_shift\n    (typeof (Ebinop Oshl a (Econst_int amount type_int32s) type_int32s))\n    (typeof (Econst_int amount type_int32s))\nwith\n| shift_case_ii sg0 =>\n    Some\n      (Vint\n         match sg0 with\n         | Signed => Int.shr (Int.shl n amount) amount\n         | Unsigned => Int.shru (Int.shl n amount) amount\n         end)\n| _ => None\nend = Some (Vint (Int.shr (Int.shl n amount) amount)).","conclusion":"match\n  classify_shift\n    (typeof (Ebinop Oshl a (Econst_int amount type_int32s) type_int32s))\n    (typeof (Econst_int amount type_int32s))\nwith\n| shift_case_ii sg0 =>\n    Some\n      (Vint\n         match sg0 with\n         | Signed => Int.shr (Int.shl n amount) amount\n         | Unsigned => Int.shru (Int.shl n amount) amount\n         end)\n| _ => None\nend = Some (Vint (Int.shr (Int.shl n amount) amount))","hypotheses":"(ge0 : genv) (e : env) (le : temp_env) (m : mem) (a : expr) (n : int) (sz : intsize) (sg sg1 : signedness) (attr : Ctypes.attr) (width : Z) (H : 0 < width) (H0 : width <= bitsize_intsize sz) (H1 : typeof a = Tint sz sg1 attr) (H2 : eval_expr ge0 e le m a (Vint n)) (H3 : bitsize_intsize sz <= Int.zwordsize) (amount : int) (LT : Int.ltu amount Int.iwordsize = true)","proofString":"reflexivity."},{"statement":"forall (dst : destination) (a : expr),\ndst = For_val \\/ dst = For_effects -> final dst a = nil.","conclusion":"forall (dst : destination) (a : expr),\ndst = For_val \\/ dst = For_effects -> final dst a = nil","hypotheses":"","proofString":"intros.\ndestruct H; subst dst; auto."},{"statement":"(dst : destination) (a : expr) (H : dst = For_val \\/ dst = For_effects) : final dst a = nil.","conclusion":"final dst a = nil","hypotheses":"(dst : destination) (a : expr) (H : dst = For_val \\/ dst = For_effects)","proofString":"destruct H; subst dst; auto."},{"statement":"(A : forall (dst : destination) (a : expr),\ndst = For_val \\/ dst = For_effects -> final dst a = nil) : (forall (le : temp_env) (dst : destination) (r : Csyntax.expr)\n   (sl : list statement) (a : expr) (tmps : list ident),\n tr_expr ce le dst r sl a tmps ->\n dst = For_val \\/ dst = For_effects -> simple r = true -> sl = nil) /\\\n(forall (le : temp_env) (rl : exprlist) (sl : list statement)\n   (al : list expr) (tmps : list ident),\n tr_exprlist ce le rl sl al tmps -> simplelist rl = true -> sl = nil).","conclusion":"(forall (le : temp_env) (dst : destination) (r : Csyntax.expr)\n   (sl : list statement) (a : expr) (tmps : list ident),\n tr_expr ce le dst r sl a tmps ->\n dst = For_val \\/ dst = For_effects -> simple r = true -> sl = nil) /\\\n(forall (le : temp_env) (rl : exprlist) (sl : list statement)\n   (al : list expr) (tmps : list ident),\n tr_exprlist ce le rl sl al tmps -> simplelist rl = true -> sl = nil)","hypotheses":"(A : forall (dst : destination) (a : expr),\ndst = For_val \\/ dst = For_effects -> final dst a = nil)","proofString":"apply tr_expr_exprlist; intros; simpl in *; try discriminate; auto.\nrewrite H0; auto.\nsimpl; auto.\nrewrite H0; auto.\nsimpl; auto.\ndestruct H1; congruence.\ndestruct (andb_prop _ _ H6).\ninv H1.\nrewrite H0; eauto.\nsimpl; auto.\nunfold chunk_for_volatile_type in H9.\ndestruct (type_is_volatile (Csyntax.typeof e1)); simpl in H8; congruence.\nrewrite H0; auto.\nsimpl; auto.\nrewrite H0; auto.\nsimpl; auto.\ndestruct (andb_prop _ _ H7).\nrewrite H0; auto.\nrewrite H2; auto.\nsimpl; auto.\nrewrite H0; auto.\nsimpl; auto.\ndestruct (andb_prop _ _ H6).\nrewrite H0; auto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true) : sl1 ++ final dst (Ederef' a1 ty) = nil.","conclusion":"sl1 ++ final dst (Ederef' a1 ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true)","proofString":"rewrite H0; auto.\nsimpl; auto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true) : nil ++ final dst (Ederef' a1 ty) = nil.","conclusion":"nil ++ final dst (Ederef' a1 ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true)","proofString":"simpl; auto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (f : ident) (ty : type) (sl1 : list statement) (a1 : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true) : sl1 ++ final dst (Efield a1 f ty) = nil.","conclusion":"sl1 ++ final dst (Efield a1 f ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (f : ident) (ty : type) (sl1 : list statement) (a1 : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true)","proofString":"rewrite H0; auto.\nsimpl; auto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (f : ident) (ty : type) (sl1 : list statement) (a1 : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true) : nil ++ final dst (Efield a1 f ty) = nil.","conclusion":"nil ++ final dst (Efield a1 f ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (f : ident) (ty : type) (sl1 : list statement) (a1 : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true)","proofString":"simpl; auto."},{"statement":"(A : forall (dst : destination) (a0 : expr),\ndst = For_val \\/ dst = For_effects -> final dst a0 = nil) (le : PTree.tree val) (sd : set_destination) (v : val) (ty : type) (a any : expr) (tmp : list positive) (H : typeof a = ty) (H0 : forall (tge0 : genv) (e : env) (le' : PTree.tree val) (m : mem),\n(forall id : positive, In id tmp -> le' ! id = le ! id) ->\neval_expr tge0 e le' m a v) (H1 : For_set sd = For_val \\/ For_set sd = For_effects) (H2 : true = true) : do_set sd a = nil.","conclusion":"do_set sd a = nil","hypotheses":"(A : forall (dst : destination) (a0 : expr),\ndst = For_val \\/ dst = For_effects -> final dst a0 = nil) (le : PTree.tree val) (sd : set_destination) (v : val) (ty : type) (a any : expr) (tmp : list positive) (H : typeof a = ty) (H0 : forall (tge0 : genv) (e : env) (le' : PTree.tree val) (m : mem),\n(forall id : positive, In id tmp -> le' ! id = le ! id) ->\neval_expr tge0 e le' m a v) (H1 : For_set sd = For_val \\/ For_set sd = For_effects) (H2 : true = true)","proofString":"destruct H1; congruence."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_rvalof ce (Csyntax.typeof e1) a1 sl2 a2 tmp2) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : dst = For_val \\/ dst = For_effects) (H6 : simple e1 && negb (type_is_volatile (Csyntax.typeof e1)) = true) : sl1 ++ sl2 ++ final dst a2 = nil.","conclusion":"sl1 ++ sl2 ++ final dst a2 = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_rvalof ce (Csyntax.typeof e1) a1 sl2 a2 tmp2) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : dst = For_val \\/ dst = For_effects) (H6 : simple e1 && negb (type_is_volatile (Csyntax.typeof e1)) = true)","proofString":"destruct (andb_prop _ _ H6).\ninv H1.\nrewrite H0; eauto.\nsimpl; auto.\nunfold chunk_for_volatile_type in H9.\ndestruct (type_is_volatile (Csyntax.typeof e1)); simpl in H8; congruence."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_rvalof ce (Csyntax.typeof e1) a1 sl2 a2 tmp2) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : dst = For_val \\/ dst = For_effects) (H6 : simple e1 && negb (type_is_volatile (Csyntax.typeof e1)) = true) (H7 : simple e1 = true) (H8 : negb (type_is_volatile (Csyntax.typeof e1)) = true) : sl1 ++ sl2 ++ final dst a2 = nil.","conclusion":"sl1 ++ sl2 ++ final dst a2 = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_rvalof ce (Csyntax.typeof e1) a1 sl2 a2 tmp2) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : dst = For_val \\/ dst = For_effects) (H6 : simple e1 && negb (type_is_volatile (Csyntax.typeof e1)) = true) (H7 : simple e1 = true) (H8 : negb (type_is_volatile (Csyntax.typeof e1)) = true)","proofString":"inv H1.\nrewrite H0; eauto.\nsimpl; auto.\nunfold chunk_for_volatile_type in H9.\ndestruct (type_is_volatile (Csyntax.typeof e1)); simpl in H8; congruence."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a2 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : dst = For_val \\/ dst = For_effects) (H6 : simple e1 && negb (type_is_volatile (Csyntax.typeof e1)) = true) (H7 : simple e1 = true) (H8 : negb (type_is_volatile (Csyntax.typeof e1)) = true) (H9 : type_is_volatile (Csyntax.typeof e1) = false) : sl1 ++ nil ++ final dst a2 = nil.","conclusion":"sl1 ++ nil ++ final dst a2 = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a2 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : dst = For_val \\/ dst = For_effects) (H6 : simple e1 && negb (type_is_volatile (Csyntax.typeof e1)) = true) (H7 : simple e1 = true) (H8 : negb (type_is_volatile (Csyntax.typeof e1)) = true) (H9 : type_is_volatile (Csyntax.typeof e1) = false)","proofString":"rewrite H0; eauto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (tmp1 tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : dst = For_val \\/ dst = For_effects) (H6 : simple e1 && negb (type_is_volatile (Csyntax.typeof e1)) = true) (H7 : simple e1 = true) (H8 : negb (type_is_volatile (Csyntax.typeof e1)) = true) (t : ident) (bf : bitfield) (H9 : type_is_volatile (Csyntax.typeof e1) = true) (H10 : In t tmp2) (H11 : tr_is_bitfield_access ce a1 bf) : sl1 ++\n(make_set bf t a1 :: nil) ++ final dst (Etempvar t (Csyntax.typeof e1)) = nil.","conclusion":"sl1 ++\n(make_set bf t a1 :: nil) ++ final dst (Etempvar t (Csyntax.typeof e1)) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (tmp1 tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : dst = For_val \\/ dst = For_effects) (H6 : simple e1 && negb (type_is_volatile (Csyntax.typeof e1)) = true) (H7 : simple e1 = true) (H8 : negb (type_is_volatile (Csyntax.typeof e1)) = true) (t : ident) (bf : bitfield) (H9 : type_is_volatile (Csyntax.typeof e1) = true) (H10 : In t tmp2) (H11 : tr_is_bitfield_access ce a1 bf)","proofString":"simpl; auto.\nunfold chunk_for_volatile_type in H9.\ndestruct (type_is_volatile (Csyntax.typeof e1)); simpl in H8; congruence."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (tmp1 tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : dst = For_val \\/ dst = For_effects) (H6 : simple e1 && negb (type_is_volatile (Csyntax.typeof e1)) = true) (H7 : simple e1 = true) (H8 : negb (type_is_volatile (Csyntax.typeof e1)) = true) (t : ident) (bf : bitfield) (H9 : type_is_volatile (Csyntax.typeof e1) = true) (H10 : In t tmp2) (H11 : tr_is_bitfield_access ce a1 bf) : sl1 ++ make_set bf t a1 :: final dst (Etempvar t (Csyntax.typeof e1)) = nil.","conclusion":"sl1 ++ make_set bf t a1 :: final dst (Etempvar t (Csyntax.typeof e1)) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (tmp1 tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : dst = For_val \\/ dst = For_effects) (H6 : simple e1 && negb (type_is_volatile (Csyntax.typeof e1)) = true) (H7 : simple e1 = true) (H8 : negb (type_is_volatile (Csyntax.typeof e1)) = true) (t : ident) (bf : bitfield) (H9 : type_is_volatile (Csyntax.typeof e1) = true) (H10 : In t tmp2) (H11 : tr_is_bitfield_access ce a1 bf)","proofString":"unfold chunk_for_volatile_type in H9.\ndestruct (type_is_volatile (Csyntax.typeof e1)); simpl in H8; congruence."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (tmp1 tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : dst = For_val \\/ dst = For_effects) (H6 : simple e1 && negb (type_is_volatile (Csyntax.typeof e1)) = true) (H7 : simple e1 = true) (H8 : negb (type_is_volatile (Csyntax.typeof e1)) = true) (t : ident) (bf : bitfield) (H9 : type_is_volatile (Csyntax.typeof e1) = true) (H10 : In t tmp2) (H11 : tr_is_bitfield_access ce a1 bf) : sl1 ++ make_set bf t a1 :: final dst (Etempvar t (Csyntax.typeof e1)) = nil.","conclusion":"sl1 ++ make_set bf t a1 :: final dst (Etempvar t (Csyntax.typeof e1)) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (tmp1 tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : dst = For_val \\/ dst = For_effects) (H6 : simple e1 && negb (type_is_volatile (Csyntax.typeof e1)) = true) (H7 : simple e1 = true) (H8 : negb (type_is_volatile (Csyntax.typeof e1)) = true) (t : ident) (bf : bitfield) (H9 : type_is_volatile (Csyntax.typeof e1) = true) (H10 : In t tmp2) (H11 : tr_is_bitfield_access ce a1 bf)","proofString":"destruct (type_is_volatile (Csyntax.typeof e1)); simpl in H8; congruence."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true) : sl1 ++ final dst (Eaddrof' a1 ty) = nil.","conclusion":"sl1 ++ final dst (Eaddrof' a1 ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true)","proofString":"rewrite H0; auto.\nsimpl; auto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true) : nil ++ final dst (Eaddrof' a1 ty) = nil.","conclusion":"nil ++ final dst (Eaddrof' a1 ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true)","proofString":"simpl; auto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (op : unary_operation) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true) : sl1 ++ final dst (Eunop op a1 ty) = nil.","conclusion":"sl1 ++ final dst (Eunop op a1 ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (op : unary_operation) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true)","proofString":"rewrite H0; auto.\nsimpl; auto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (op : unary_operation) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true) : nil ++ final dst (Eunop op a1 ty) = nil.","conclusion":"nil ++ final dst (Eunop op a1 ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (op : unary_operation) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true)","proofString":"simpl; auto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (op : binary_operation) (e1 e2 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H2 : For_val = For_val \\/ For_val = For_effects -> simple e2 = true -> sl2 = nil) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : dst = For_val \\/ dst = For_effects) (H7 : simple e1 && simple e2 = true) : sl1 ++ sl2 ++ final dst (Ebinop op a1 a2 ty) = nil.","conclusion":"sl1 ++ sl2 ++ final dst (Ebinop op a1 a2 ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (op : binary_operation) (e1 e2 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H2 : For_val = For_val \\/ For_val = For_effects -> simple e2 = true -> sl2 = nil) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : dst = For_val \\/ dst = For_effects) (H7 : simple e1 && simple e2 = true)","proofString":"destruct (andb_prop _ _ H7).\nrewrite H0; auto.\nrewrite H2; auto.\nsimpl; auto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (op : binary_operation) (e1 e2 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H2 : For_val = For_val \\/ For_val = For_effects -> simple e2 = true -> sl2 = nil) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : dst = For_val \\/ dst = For_effects) (H7 : simple e1 && simple e2 = true) (H8 : simple e1 = true) (H9 : simple e2 = true) : sl1 ++ sl2 ++ final dst (Ebinop op a1 a2 ty) = nil.","conclusion":"sl1 ++ sl2 ++ final dst (Ebinop op a1 a2 ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (op : binary_operation) (e1 e2 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H2 : For_val = For_val \\/ For_val = For_effects -> simple e2 = true -> sl2 = nil) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : dst = For_val \\/ dst = For_effects) (H7 : simple e1 && simple e2 = true) (H8 : simple e1 = true) (H9 : simple e2 = true)","proofString":"rewrite H0; auto.\nrewrite H2; auto.\nsimpl; auto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (op : binary_operation) (e1 e2 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H2 : For_val = For_val \\/ For_val = For_effects -> simple e2 = true -> sl2 = nil) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : dst = For_val \\/ dst = For_effects) (H7 : simple e1 && simple e2 = true) (H8 : simple e1 = true) (H9 : simple e2 = true) : nil ++ sl2 ++ final dst (Ebinop op a1 a2 ty) = nil.","conclusion":"nil ++ sl2 ++ final dst (Ebinop op a1 a2 ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (op : binary_operation) (e1 e2 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H2 : For_val = For_val \\/ For_val = For_effects -> simple e2 = true -> sl2 = nil) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : dst = For_val \\/ dst = For_effects) (H7 : simple e1 && simple e2 = true) (H8 : simple e1 = true) (H9 : simple e2 = true)","proofString":"rewrite H2; auto.\nsimpl; auto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (op : binary_operation) (e1 e2 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H2 : For_val = For_val \\/ For_val = For_effects -> simple e2 = true -> sl2 = nil) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : dst = For_val \\/ dst = For_effects) (H7 : simple e1 && simple e2 = true) (H8 : simple e1 = true) (H9 : simple e2 = true) : nil ++ nil ++ final dst (Ebinop op a1 a2 ty) = nil.","conclusion":"nil ++ nil ++ final dst (Ebinop op a1 a2 ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (op : binary_operation) (e1 e2 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H2 : For_val = For_val \\/ For_val = For_effects -> simple e2 = true -> sl2 = nil) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : dst = For_val \\/ dst = For_effects) (H7 : simple e1 && simple e2 = true) (H8 : simple e1 = true) (H9 : simple e2 = true)","proofString":"simpl; auto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true) : sl1 ++ final dst (Ecast a1 ty) = nil.","conclusion":"sl1 ++ final dst (Ecast a1 ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true)","proofString":"rewrite H0; auto.\nsimpl; auto."},{"statement":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true) : nil ++ final dst (Ecast a1 ty) = nil.","conclusion":"nil ++ final dst (Ecast a1 ty) = nil","hypotheses":"(A : forall (dst0 : destination) (a : expr),\ndst0 = For_val \\/ dst0 = For_effects -> final dst0 a = nil) (le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : dst = For_val \\/ dst = For_effects) (H2 : simple e1 = true)","proofString":"simpl; auto."},{"statement":"(A : forall (dst : destination) (a : expr),\ndst = For_val \\/ dst = For_effects -> final dst a = nil) (le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_exprlist ce le el2 sl2 al2 tmp2) (H2 : simplelist el2 = true -> sl2 = nil) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : simple e1 && simplelist el2 = true) : sl1 ++ sl2 = nil.","conclusion":"sl1 ++ sl2 = nil","hypotheses":"(A : forall (dst : destination) (a : expr),\ndst = For_val \\/ dst = For_effects -> final dst a = nil) (le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_exprlist ce le el2 sl2 al2 tmp2) (H2 : simplelist el2 = true -> sl2 = nil) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : simple e1 && simplelist el2 = true)","proofString":"destruct (andb_prop _ _ H6).\nrewrite H0; auto."},{"statement":"(A : forall (dst : destination) (a : expr),\ndst = For_val \\/ dst = For_effects -> final dst a = nil) (le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_exprlist ce le el2 sl2 al2 tmp2) (H2 : simplelist el2 = true -> sl2 = nil) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : simple e1 && simplelist el2 = true) (H7 : simple e1 = true) (H8 : simplelist el2 = true) : sl1 ++ sl2 = nil.","conclusion":"sl1 ++ sl2 = nil","hypotheses":"(A : forall (dst : destination) (a : expr),\ndst = For_val \\/ dst = For_effects -> final dst a = nil) (le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : For_val = For_val \\/ For_val = For_effects -> simple e1 = true -> sl1 = nil) (H1 : tr_exprlist ce le el2 sl2 al2 tmp2) (H2 : simplelist el2 = true -> sl2 = nil) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : simple e1 && simplelist el2 = true) (H7 : simple e1 = true) (H8 : simplelist el2 = true)","proofString":"rewrite H0; auto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : Csem.deref_loc ge ty m b ofs bf t v) : match chunk_for_volatile_type ty bf with\n| Some chunk => bf = Full /\\ volatile_load tge chunk m b ofs t v\n| None => t = E0 /\\ deref_loc ty m b ofs bf v\nend.","conclusion":"match chunk_for_volatile_type ty bf with\n| Some chunk => bf = Full /\\ volatile_load tge chunk m b ofs t v\n| None => t = E0 /\\ deref_loc ty m b ofs bf v\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : Csem.deref_loc ge ty m b ofs bf t v)","proofString":"unfold chunk_for_volatile_type.\ninv H.\nrewrite H1.\nsplit; auto.\neapply deref_loc_value; eauto.\nrewrite H0, H1.\nsplit; auto.\neapply volatile_load_preserved with (ge1 := ge); auto.\napply senv_preserved.\nrewrite H0.\ndestruct (type_is_volatile ty); split; auto; eapply deref_loc_reference; eauto.\nrewrite H0.\ndestruct (type_is_volatile ty); split; auto; eapply deref_loc_copy; eauto.\ndestruct (type_is_volatile ty); [destruct (access_mode ty)|]; auto using deref_loc_bitfield."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : Csem.deref_loc ge ty m b ofs bf t v) : match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk =>\n        match bf with\n        | Full => Some chunk\n        | Bits _ _ _ _ => None\n        end\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk => bf = Full /\\ volatile_load tge chunk m b ofs t v\n| None => t = E0 /\\ deref_loc ty m b ofs bf v\nend.","conclusion":"match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk =>\n        match bf with\n        | Full => Some chunk\n        | Bits _ _ _ _ => None\n        end\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk => bf = Full /\\ volatile_load tge chunk m b ofs t v\n| None => t = E0 /\\ deref_loc ty m b ofs bf v\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : Csem.deref_loc ge ty m b ofs bf t v)","proofString":"inv H.\nrewrite H1.\nsplit; auto.\neapply deref_loc_value; eauto.\nrewrite H0, H1.\nsplit; auto.\neapply volatile_load_preserved with (ge1 := ge); auto.\napply senv_preserved.\nrewrite H0.\ndestruct (type_is_volatile ty); split; auto; eapply deref_loc_reference; eauto.\nrewrite H0.\ndestruct (type_is_volatile ty); split; auto; eapply deref_loc_copy; eauto.\ndestruct (type_is_volatile ty); [destruct (access_mode ty)|]; auto using deref_loc_bitfield."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = false) (H2 : Mem.loadv chunk m (Vptr b ofs) = Some v) : match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk0 => Some chunk0\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk0 => Full = Full /\\ volatile_load tge chunk0 m b ofs E0 v\n| None => E0 = E0 /\\ deref_loc ty m b ofs Full v\nend.","conclusion":"match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk0 => Some chunk0\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk0 => Full = Full /\\ volatile_load tge chunk0 m b ofs E0 v\n| None => E0 = E0 /\\ deref_loc ty m b ofs Full v\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = false) (H2 : Mem.loadv chunk m (Vptr b ofs) = Some v)","proofString":"rewrite H1.\nsplit; auto.\neapply deref_loc_value; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = false) (H2 : Mem.loadv chunk m (Vptr b ofs) = Some v) : E0 = E0 /\\ deref_loc ty m b ofs Full v.","conclusion":"E0 = E0 /\\ deref_loc ty m b ofs Full v","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = false) (H2 : Mem.loadv chunk m (Vptr b ofs) = Some v)","proofString":"split; auto.\neapply deref_loc_value; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = false) (H2 : Mem.loadv chunk m (Vptr b ofs) = Some v) : deref_loc ty m b ofs Full v.","conclusion":"deref_loc ty m b ofs Full v","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = false) (H2 : Mem.loadv chunk m (Vptr b ofs) = Some v)","proofString":"eapply deref_loc_value; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_load ge chunk m b ofs t v) : match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk0 => Some chunk0\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk0 => Full = Full /\\ volatile_load tge chunk0 m b ofs t v\n| None => t = E0 /\\ deref_loc ty m b ofs Full v\nend.","conclusion":"match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk0 => Some chunk0\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk0 => Full = Full /\\ volatile_load tge chunk0 m b ofs t v\n| None => t = E0 /\\ deref_loc ty m b ofs Full v\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_load ge chunk m b ofs t v)","proofString":"rewrite H0, H1.\nsplit; auto.\neapply volatile_load_preserved with (ge1 := ge); auto.\napply senv_preserved."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_load ge chunk m b ofs t v) : Full = Full /\\ volatile_load tge chunk m b ofs t v.","conclusion":"Full = Full /\\ volatile_load tge chunk m b ofs t v","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_load ge chunk m b ofs t v)","proofString":"split; auto.\neapply volatile_load_preserved with (ge1 := ge); auto.\napply senv_preserved."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_load ge chunk m b ofs t v) : volatile_load tge chunk m b ofs t v.","conclusion":"volatile_load tge chunk m b ofs t v","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_load ge chunk m b ofs t v)","proofString":"eapply volatile_load_preserved with (ge1 := ge); auto.\napply senv_preserved."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_load ge chunk m b ofs t v) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_load ge chunk m b ofs t v)","proofString":"apply senv_preserved."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (H0 : access_mode ty = By_reference) : match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk => Some chunk\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk =>\n    Full = Full /\\ volatile_load tge chunk m b ofs E0 (Vptr b ofs)\n| None => E0 = E0 /\\ deref_loc ty m b ofs Full (Vptr b ofs)\nend.","conclusion":"match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk => Some chunk\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk =>\n    Full = Full /\\ volatile_load tge chunk m b ofs E0 (Vptr b ofs)\n| None => E0 = E0 /\\ deref_loc ty m b ofs Full (Vptr b ofs)\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (H0 : access_mode ty = By_reference)","proofString":"rewrite H0.\ndestruct (type_is_volatile ty); split; auto; eapply deref_loc_reference; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (H0 : access_mode ty = By_reference) : match (if type_is_volatile ty then None else None) with\n| Some chunk =>\n    Full = Full /\\ volatile_load tge chunk m b ofs E0 (Vptr b ofs)\n| None => E0 = E0 /\\ deref_loc ty m b ofs Full (Vptr b ofs)\nend.","conclusion":"match (if type_is_volatile ty then None else None) with\n| Some chunk =>\n    Full = Full /\\ volatile_load tge chunk m b ofs E0 (Vptr b ofs)\n| None => E0 = E0 /\\ deref_loc ty m b ofs Full (Vptr b ofs)\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (H0 : access_mode ty = By_reference)","proofString":"destruct (type_is_volatile ty); split; auto; eapply deref_loc_reference; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (H0 : access_mode ty = By_copy) : match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk => Some chunk\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk =>\n    Full = Full /\\ volatile_load tge chunk m b ofs E0 (Vptr b ofs)\n| None => E0 = E0 /\\ deref_loc ty m b ofs Full (Vptr b ofs)\nend.","conclusion":"match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk => Some chunk\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk =>\n    Full = Full /\\ volatile_load tge chunk m b ofs E0 (Vptr b ofs)\n| None => E0 = E0 /\\ deref_loc ty m b ofs Full (Vptr b ofs)\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (H0 : access_mode ty = By_copy)","proofString":"rewrite H0.\ndestruct (type_is_volatile ty); split; auto; eapply deref_loc_copy; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (H0 : access_mode ty = By_copy) : match (if type_is_volatile ty then None else None) with\n| Some chunk =>\n    Full = Full /\\ volatile_load tge chunk m b ofs E0 (Vptr b ofs)\n| None => E0 = E0 /\\ deref_loc ty m b ofs Full (Vptr b ofs)\nend.","conclusion":"match (if type_is_volatile ty then None else None) with\n| Some chunk =>\n    Full = Full /\\ volatile_load tge chunk m b ofs E0 (Vptr b ofs)\n| None => E0 = E0 /\\ deref_loc ty m b ofs Full (Vptr b ofs)\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (H0 : access_mode ty = By_copy)","proofString":"destruct (type_is_volatile ty); split; auto; eapply deref_loc_copy; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (sz : intsize) (sg : signedness) (pos width : Z) (H0 : load_bitfield ty sz sg pos width m (Vptr b ofs) v) : match\n  (if type_is_volatile ty\n   then match access_mode ty with\n        | By_value _ | _ => None\n        end\n   else None)\nwith\n| Some chunk =>\n    Bits sz sg pos width = Full /\\ volatile_load tge chunk m b ofs E0 v\n| None => E0 = E0 /\\ deref_loc ty m b ofs (Bits sz sg pos width) v\nend.","conclusion":"match\n  (if type_is_volatile ty\n   then match access_mode ty with\n        | By_value _ | _ => None\n        end\n   else None)\nwith\n| Some chunk =>\n    Bits sz sg pos width = Full /\\ volatile_load tge chunk m b ofs E0 v\n| None => E0 = E0 /\\ deref_loc ty m b ofs (Bits sz sg pos width) v\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (sz : intsize) (sg : signedness) (pos width : Z) (H0 : load_bitfield ty sz sg pos width m (Vptr b ofs) v)","proofString":"destruct (type_is_volatile ty); [destruct (access_mode ty)|]; auto using deref_loc_bitfield."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (t : trace) (m' : mem) (v' : val) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') : match chunk_for_volatile_type ty bf with\n| Some chunk => bf = Full /\\ volatile_store tge chunk m b ofs v t m'\n| None => t = E0 /\\ assign_loc tge ty m b ofs bf v m'\nend.","conclusion":"match chunk_for_volatile_type ty bf with\n| Some chunk => bf = Full /\\ volatile_store tge chunk m b ofs v t m'\n| None => t = E0 /\\ assign_loc tge ty m b ofs bf v m'\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (t : trace) (m' : mem) (v' : val) (H : Csem.assign_loc ge ty m b ofs bf v t m' v')","proofString":"unfold chunk_for_volatile_type.\ninv H.\nrewrite H1.\nsplit; auto.\neapply assign_loc_value; eauto.\nrewrite H0, H1.\nsplit; auto.\neapply volatile_store_preserved with (ge1 := ge); auto.\napply senv_preserved.\nrewrite H0.\nrewrite <- comp_env_preserved in *.\ndestruct (type_is_volatile ty); split; auto; eapply assign_loc_copy; eauto.\ndestruct (type_is_volatile ty); [destruct (access_mode ty)|]; eauto using assign_loc_bitfield."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (t : trace) (m' : mem) (v' : val) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') : match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk =>\n        match bf with\n        | Full => Some chunk\n        | Bits _ _ _ _ => None\n        end\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk => bf = Full /\\ volatile_store tge chunk m b ofs v t m'\n| None => t = E0 /\\ assign_loc tge ty m b ofs bf v m'\nend.","conclusion":"match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk =>\n        match bf with\n        | Full => Some chunk\n        | Bits _ _ _ _ => None\n        end\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk => bf = Full /\\ volatile_store tge chunk m b ofs v t m'\n| None => t = E0 /\\ assign_loc tge ty m b ofs bf v m'\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (t : trace) (m' : mem) (v' : val) (H : Csem.assign_loc ge ty m b ofs bf v t m' v')","proofString":"inv H.\nrewrite H1.\nsplit; auto.\neapply assign_loc_value; eauto.\nrewrite H0, H1.\nsplit; auto.\neapply volatile_store_preserved with (ge1 := ge); auto.\napply senv_preserved.\nrewrite H0.\nrewrite <- comp_env_preserved in *.\ndestruct (type_is_volatile ty); split; auto; eapply assign_loc_copy; eauto.\ndestruct (type_is_volatile ty); [destruct (access_mode ty)|]; eauto using assign_loc_bitfield."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = false) (H2 : Mem.storev chunk m (Vptr b ofs) v' = Some m') : match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk0 => Some chunk0\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk0 => Full = Full /\\ volatile_store tge chunk0 m b ofs v' E0 m'\n| None => E0 = E0 /\\ assign_loc tge ty m b ofs Full v' m'\nend.","conclusion":"match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk0 => Some chunk0\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk0 => Full = Full /\\ volatile_store tge chunk0 m b ofs v' E0 m'\n| None => E0 = E0 /\\ assign_loc tge ty m b ofs Full v' m'\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = false) (H2 : Mem.storev chunk m (Vptr b ofs) v' = Some m')","proofString":"rewrite H1.\nsplit; auto.\neapply assign_loc_value; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = false) (H2 : Mem.storev chunk m (Vptr b ofs) v' = Some m') : E0 = E0 /\\ assign_loc tge ty m b ofs Full v' m'.","conclusion":"E0 = E0 /\\ assign_loc tge ty m b ofs Full v' m'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = false) (H2 : Mem.storev chunk m (Vptr b ofs) v' = Some m')","proofString":"split; auto.\neapply assign_loc_value; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = false) (H2 : Mem.storev chunk m (Vptr b ofs) v' = Some m') : assign_loc tge ty m b ofs Full v' m'.","conclusion":"assign_loc tge ty m b ofs Full v' m'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = false) (H2 : Mem.storev chunk m (Vptr b ofs) v' = Some m')","proofString":"eapply assign_loc_value; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_store ge chunk m b ofs v' t m') : match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk0 => Some chunk0\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk0 => Full = Full /\\ volatile_store tge chunk0 m b ofs v' t m'\n| None => t = E0 /\\ assign_loc tge ty m b ofs Full v' m'\nend.","conclusion":"match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk0 => Some chunk0\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk0 => Full = Full /\\ volatile_store tge chunk0 m b ofs v' t m'\n| None => t = E0 /\\ assign_loc tge ty m b ofs Full v' m'\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_store ge chunk m b ofs v' t m')","proofString":"rewrite H0, H1.\nsplit; auto.\neapply volatile_store_preserved with (ge1 := ge); auto.\napply senv_preserved."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_store ge chunk m b ofs v' t m') : Full = Full /\\ volatile_store tge chunk m b ofs v' t m'.","conclusion":"Full = Full /\\ volatile_store tge chunk m b ofs v' t m'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_store ge chunk m b ofs v' t m')","proofString":"split; auto.\neapply volatile_store_preserved with (ge1 := ge); auto.\napply senv_preserved."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_store ge chunk m b ofs v' t m') : volatile_store tge chunk m b ofs v' t m'.","conclusion":"volatile_store tge chunk m b ofs v' t m'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_store ge chunk m b ofs v' t m')","proofString":"eapply volatile_store_preserved with (ge1 := ge); auto.\napply senv_preserved."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_store ge chunk m b ofs v' t m') : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (m' : mem) (v' : val) (chunk : memory_chunk) (H0 : access_mode ty = By_value chunk) (H1 : type_is_volatile ty = true) (H2 : volatile_store ge chunk m b ofs v' t m')","proofString":"apply senv_preserved."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H0 : access_mode ty = By_copy) (H1 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H3 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H4 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H5 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') : match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk => Some chunk\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk =>\n    Full = Full /\\ volatile_store tge chunk m b ofs (Vptr b' ofs') E0 m'\n| None => E0 = E0 /\\ assign_loc tge ty m b ofs Full (Vptr b' ofs') m'\nend.","conclusion":"match\n  (if type_is_volatile ty\n   then\n    match access_mode ty with\n    | By_value chunk => Some chunk\n    | _ => None\n    end\n   else None)\nwith\n| Some chunk =>\n    Full = Full /\\ volatile_store tge chunk m b ofs (Vptr b' ofs') E0 m'\n| None => E0 = E0 /\\ assign_loc tge ty m b ofs Full (Vptr b' ofs') m'\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H0 : access_mode ty = By_copy) (H1 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H3 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H4 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H5 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m')","proofString":"rewrite H0.\nrewrite <- comp_env_preserved in *.\ndestruct (type_is_volatile ty); split; auto; eapply assign_loc_copy; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H0 : access_mode ty = By_copy) (H1 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H3 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H4 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H5 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') : match (if type_is_volatile ty then None else None) with\n| Some chunk =>\n    Full = Full /\\ volatile_store tge chunk m b ofs (Vptr b' ofs') E0 m'\n| None => E0 = E0 /\\ assign_loc tge ty m b ofs Full (Vptr b' ofs') m'\nend.","conclusion":"match (if type_is_volatile ty then None else None) with\n| Some chunk =>\n    Full = Full /\\ volatile_store tge chunk m b ofs (Vptr b' ofs') E0 m'\n| None => E0 = E0 /\\ assign_loc tge ty m b ofs Full (Vptr b' ofs') m'\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H0 : access_mode ty = By_copy) (H1 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H2 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs)) (H3 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof ge ty <= Ptrofs.unsigned ofs') (H4 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H5 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m')","proofString":"rewrite <- comp_env_preserved in *.\ndestruct (type_is_volatile ty); split; auto; eapply assign_loc_copy; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H0 : access_mode ty = By_copy) (H1 : (alignof_blockcopy tge ty | Ptrofs.unsigned ofs')) (H2 : (alignof_blockcopy tge ty | Ptrofs.unsigned ofs)) (H3 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof tge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof tge ty <= Ptrofs.unsigned ofs') (H4 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof tge ty) = Some bytes) (H5 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m') : match (if type_is_volatile ty then None else None) with\n| Some chunk =>\n    Full = Full /\\ volatile_store tge chunk m b ofs (Vptr b' ofs') E0 m'\n| None => E0 = E0 /\\ assign_loc tge ty m b ofs Full (Vptr b' ofs') m'\nend.","conclusion":"match (if type_is_volatile ty then None else None) with\n| Some chunk =>\n    Full = Full /\\ volatile_store tge chunk m b ofs (Vptr b' ofs') E0 m'\n| None => E0 = E0 /\\ assign_loc tge ty m b ofs Full (Vptr b' ofs') m'\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H0 : access_mode ty = By_copy) (H1 : (alignof_blockcopy tge ty | Ptrofs.unsigned ofs')) (H2 : (alignof_blockcopy tge ty | Ptrofs.unsigned ofs)) (H3 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs' + sizeof tge ty <= Ptrofs.unsigned ofs \\/\nPtrofs.unsigned ofs + sizeof tge ty <= Ptrofs.unsigned ofs') (H4 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof tge ty) = Some bytes) (H5 : Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m')","proofString":"destruct (type_is_volatile ty); split; auto; eapply assign_loc_copy; eauto."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (v' : val) (sz : intsize) (sg : signedness) (pos width : Z) (H0 : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v') : match\n  (if type_is_volatile ty\n   then match access_mode ty with\n        | By_value _ | _ => None\n        end\n   else None)\nwith\n| Some chunk =>\n    Bits sz sg pos width = Full /\\ volatile_store tge chunk m b ofs v E0 m'\n| None => E0 = E0 /\\ assign_loc tge ty m b ofs (Bits sz sg pos width) v m'\nend.","conclusion":"match\n  (if type_is_volatile ty\n   then match access_mode ty with\n        | By_value _ | _ => None\n        end\n   else None)\nwith\n| Some chunk =>\n    Bits sz sg pos width = Full /\\ volatile_store tge chunk m b ofs v E0 m'\n| None => E0 = E0 /\\ assign_loc tge ty m b ofs (Bits sz sg pos width) v m'\nend","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (v' : val) (sz : intsize) (sg : signedness) (pos width : Z) (H0 : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v')","proofString":"destruct (type_is_volatile ty); [destruct (access_mode ty)|]; eauto using assign_loc_bitfield."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (m' : mem) (v' : val) (H : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v') (tge0 : genv) (e : env) (le : temp_env) (m'' : mem) (r : expr) (H0 : typeof r = ty) (H1 : eval_expr tge0 e le m'' r v) : eval_expr tge0 e le m'' (make_normalize sz sg width r) v'.","conclusion":"eval_expr tge0 e le m'' (make_normalize sz sg width r) v'","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (v : val) (m' : mem) (v' : val) (H : store_bitfield ty sz sg pos width m (Vptr b ofs) v m' v') (tge0 : genv) (e : env) (le : temp_env) (m'' : mem) (r : expr) (H0 : typeof r = ty) (H1 : eval_expr tge0 e le m'' r v)","proofString":"inv H.\neapply eval_make_normalize; eauto; lia."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (m' : mem) (tge0 : genv) (e : env) (le : temp_env) (m'' : mem) (r : expr) (n : int) (H1 : eval_expr tge0 e le m'' r (Vint n)) (attr : Ctypes.attr) (c : int) (H2 : 0 <= pos) (H3 : 0 < width <= bitsize_intsize sz) (H4 : pos + width <= bitsize_carrier sz) (H6 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H7 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (H8 : Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr =\ntypeof r) : eval_expr tge0 e le m'' (make_normalize sz sg width r)\n  (Vint (bitfield_normalize sz sg width n)).","conclusion":"eval_expr tge0 e le m'' (make_normalize sz sg width r)\n  (Vint (bitfield_normalize sz sg width n))","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (sz : intsize) (sg : signedness) (pos width : Z) (m' : mem) (tge0 : genv) (e : env) (le : temp_env) (m'' : mem) (r : expr) (n : int) (H1 : eval_expr tge0 e le m'' r (Vint n)) (attr : Ctypes.attr) (c : int) (H2 : 0 <= pos) (H3 : 0 < width <= bitsize_intsize sz) (H4 : pos + width <= bitsize_carrier sz) (H6 : Mem.loadv (chunk_for_carrier sz) m (Vptr b ofs) = Some (Vint c)) (H7 : Mem.storev (chunk_for_carrier sz) m (Vptr b ofs)\n  (Vint (Int.bitfield_insert (first_bit sz pos width) width c n)) = \nSome m') (H8 : Tint sz (if zlt width (bitsize_intsize sz) then Signed else sg) attr =\ntypeof r)","proofString":"eapply eval_make_normalize; eauto; lia."},{"statement":"(bf : bitfield) (r : expr) : typeof (make_assign_value bf r) = typeof r.","conclusion":"typeof (make_assign_value bf r) = typeof r","hypotheses":"(bf : bitfield) (r : expr)","proofString":"destruct bf; simpl; auto.\nunfold make_normalize.\ndestruct (intsize_eq sz IBool || signedness_eq sg Unsigned); auto."},{"statement":"(sz : intsize) (sg : signedness) (pos width : Z) (r : expr) : typeof (make_normalize sz sg width r) = typeof r.","conclusion":"typeof (make_normalize sz sg width r) = typeof r","hypotheses":"(sz : intsize) (sg : signedness) (pos width : Z) (r : expr)","proofString":"unfold make_normalize.\ndestruct (intsize_eq sz IBool || signedness_eq sg Unsigned); auto."},{"statement":"(sz : intsize) (sg : signedness) (pos width : Z) (r : expr) : typeof\n  (if intsize_eq sz IBool || signedness_eq sg Unsigned\n   then\n    Ebinop Oand r (Econst_int (Int.repr (two_p width - 1)) type_int32s)\n      (typeof r)\n   else\n    Ebinop Oshr\n      (Ebinop Oshl r\n         (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s)\n         type_int32s)\n      (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s) \n      (typeof r)) = typeof r.","conclusion":"typeof\n  (if intsize_eq sz IBool || signedness_eq sg Unsigned\n   then\n    Ebinop Oand r (Econst_int (Int.repr (two_p width - 1)) type_int32s)\n      (typeof r)\n   else\n    Ebinop Oshr\n      (Ebinop Oshl r\n         (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s)\n         type_int32s)\n      (Econst_int (Int.repr (Int.zwordsize - width)) type_int32s) \n      (typeof r)) = typeof r","hypotheses":"(sz : intsize) (sg : signedness) (pos width : Z) (r : expr)","proofString":"destruct (intsize_eq sz IBool || signedness_eq sg Unsigned); auto."},{"statement":"(e : Csem.env) (m : mem) : forall (r : Csyntax.expr) (v : val),\neval_simple_rvalue ge e m r v ->\nforall (le : temp_env) (dst : destination) (sl : list statement) \n  (a : expr) (tmps : list ident),\ntr_expr ce le dst r sl a tmps ->\nmatch dst with\n| For_val =>\n    sl = nil /\\ Csyntax.typeof r = typeof a /\\ eval_expr tge e le m a v\n| For_effects => sl = nil\n| For_set sd =>\n    exists b : expr,\n      sl = do_set sd b /\\\n      Csyntax.typeof r = typeof b /\\ eval_expr tge e le m b v\nend.","conclusion":"forall (r : Csyntax.expr) (v : val),\neval_simple_rvalue ge e m r v ->\nforall (le : temp_env) (dst : destination) (sl : list statement) \n  (a : expr) (tmps : list ident),\ntr_expr ce le dst r sl a tmps ->\nmatch dst with\n| For_val =>\n    sl = nil /\\ Csyntax.typeof r = typeof a /\\ eval_expr tge e le m a v\n| For_effects => sl = nil\n| For_set sd =>\n    exists b : expr,\n      sl = do_set sd b /\\\n      Csyntax.typeof r = typeof b /\\ eval_expr tge e le m b v\nend","hypotheses":"(e : Csem.env) (m : mem)","proofString":"exact (proj1 (tr_simple e m))."},{"statement":"(e : Csem.env) (m : mem) : forall (l : Csyntax.expr) (b : block) (ofs : ptrofs) (bf : bitfield),\neval_simple_lvalue ge e m l b ofs bf ->\nforall (le : temp_env) (sl : list statement) (a : expr) (tmps : list ident),\ntr_expr ce le For_val l sl a tmps ->\nsl = nil /\\ Csyntax.typeof l = typeof a /\\ eval_lvalue tge e le m a b ofs bf.","conclusion":"forall (l : Csyntax.expr) (b : block) (ofs : ptrofs) (bf : bitfield),\neval_simple_lvalue ge e m l b ofs bf ->\nforall (le : temp_env) (sl : list statement) (a : expr) (tmps : list ident),\ntr_expr ce le For_val l sl a tmps ->\nsl = nil /\\ Csyntax.typeof l = typeof a /\\ eval_lvalue tge e le m a b ofs bf","hypotheses":"(e : Csem.env) (m : mem)","proofString":"exact (proj2 (tr_simple e m))."},{"statement":"(le : temp_env) (tmp : list ident) (e : Csem.env) (m : mem) : eval_exprlist tge e le m nil nil nil.","conclusion":"eval_exprlist tge e le m nil nil nil","hypotheses":"(le : temp_env) (tmp : list ident) (e : Csem.env) (m : mem)","proofString":"constructor."},{"statement":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl0 : list type) (vl0 : list val),\neval_simple_list ge e0 m0 el2 tyl0 vl0 ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl0 vl0) (e : Csem.env) (m : mem) (tyl : list type) (vl : list val) (H4 : eval_simple_list ge e m (Econs e1 el2) tyl vl) : sl1 ++ sl2 = nil /\\ eval_exprlist tge e le m (a1 :: al2) tyl vl.","conclusion":"sl1 ++ sl2 = nil /\\ eval_exprlist tge e le m (a1 :: al2) tyl vl","hypotheses":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl0 : list type) (vl0 : list val),\neval_simple_list ge e0 m0 el2 tyl0 vl0 ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl0 vl0) (e : Csem.env) (m : mem) (tyl : list type) (vl : list val) (H4 : eval_simple_list ge e m (Econs e1 el2) tyl vl)","proofString":"inv H4.\nexploit tr_simple_rvalue; eauto.\nintros [A [B C]].\nexploit IHtr_exprlist; eauto.\nintros [D E].\nsplit.\nsubst; auto.\neconstructor; eauto.\ncongruence."},{"statement":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) : sl1 ++ sl2 = nil /\\\neval_exprlist tge e le m (a1 :: al2) (ty :: tyl0) (v :: vl0).","conclusion":"sl1 ++ sl2 = nil /\\\neval_exprlist tge e le m (a1 :: al2) (ty :: tyl0) (v :: vl0)","hypotheses":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0)","proofString":"exploit tr_simple_rvalue; eauto.\nintros [A [B C]].\nexploit IHtr_exprlist; eauto.\nintros [D E].\nsplit.\nsubst; auto.\neconstructor; eauto.\ncongruence."},{"statement":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) : match For_val with\n| For_val =>\n    sl1 = nil /\\ Csyntax.typeof e1 = typeof a1 /\\ eval_expr tge e le m a1 v'\n| For_effects => sl1 = nil\n| For_set sd =>\n    exists b : expr,\n      sl1 = do_set sd b /\\\n      Csyntax.typeof e1 = typeof b /\\ eval_expr tge e le m b v'\nend ->\nsl1 ++ sl2 = nil /\\\neval_exprlist tge e le m (a1 :: al2) (ty :: tyl0) (v :: vl0).","conclusion":"match For_val with\n| For_val =>\n    sl1 = nil /\\ Csyntax.typeof e1 = typeof a1 /\\ eval_expr tge e le m a1 v'\n| For_effects => sl1 = nil\n| For_set sd =>\n    exists b : expr,\n      sl1 = do_set sd b /\\\n      Csyntax.typeof e1 = typeof b /\\ eval_expr tge e le m b v'\nend ->\nsl1 ++ sl2 = nil /\\\neval_exprlist tge e le m (a1 :: al2) (ty :: tyl0) (v :: vl0)","hypotheses":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0)","proofString":"intros [A [B C]].\nexploit IHtr_exprlist; eauto.\nintros [D E].\nsplit.\nsubst; auto.\neconstructor; eauto.\ncongruence."},{"statement":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) (A : sl1 = nil) (B : Csyntax.typeof e1 = typeof a1) (C : eval_expr tge e le m a1 v') : sl1 ++ sl2 = nil /\\\neval_exprlist tge e le m (a1 :: al2) (ty :: tyl0) (v :: vl0).","conclusion":"sl1 ++ sl2 = nil /\\\neval_exprlist tge e le m (a1 :: al2) (ty :: tyl0) (v :: vl0)","hypotheses":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) (A : sl1 = nil) (B : Csyntax.typeof e1 = typeof a1) (C : eval_expr tge e le m a1 v')","proofString":"exploit IHtr_exprlist; eauto.\nintros [D E].\nsplit.\nsubst; auto.\neconstructor; eauto.\ncongruence."},{"statement":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) (A : sl1 = nil) (B : Csyntax.typeof e1 = typeof a1) (C : eval_expr tge e le m a1 v') : sl2 = nil /\\ eval_exprlist tge e le m al2 tyl0 vl0 ->\nsl1 ++ sl2 = nil /\\\neval_exprlist tge e le m (a1 :: al2) (ty :: tyl0) (v :: vl0).","conclusion":"sl2 = nil /\\ eval_exprlist tge e le m al2 tyl0 vl0 ->\nsl1 ++ sl2 = nil /\\\neval_exprlist tge e le m (a1 :: al2) (ty :: tyl0) (v :: vl0)","hypotheses":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) (A : sl1 = nil) (B : Csyntax.typeof e1 = typeof a1) (C : eval_expr tge e le m a1 v')","proofString":"intros [D E].\nsplit.\nsubst; auto.\neconstructor; eauto.\ncongruence."},{"statement":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) (A : sl1 = nil) (B : Csyntax.typeof e1 = typeof a1) (C : eval_expr tge e le m a1 v') (D : sl2 = nil) (E : eval_exprlist tge e le m al2 tyl0 vl0) : sl1 ++ sl2 = nil /\\\neval_exprlist tge e le m (a1 :: al2) (ty :: tyl0) (v :: vl0).","conclusion":"sl1 ++ sl2 = nil /\\\neval_exprlist tge e le m (a1 :: al2) (ty :: tyl0) (v :: vl0)","hypotheses":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) (A : sl1 = nil) (B : Csyntax.typeof e1 = typeof a1) (C : eval_expr tge e le m a1 v') (D : sl2 = nil) (E : eval_exprlist tge e le m al2 tyl0 vl0)","proofString":"split.\nsubst; auto.\neconstructor; eauto.\ncongruence."},{"statement":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) (A : sl1 = nil) (B : Csyntax.typeof e1 = typeof a1) (C : eval_expr tge e le m a1 v') (D : sl2 = nil) (E : eval_exprlist tge e le m al2 tyl0 vl0) : sl1 ++ sl2 = nil.","conclusion":"sl1 ++ sl2 = nil","hypotheses":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) (A : sl1 = nil) (B : Csyntax.typeof e1 = typeof a1) (C : eval_expr tge e le m a1 v') (D : sl2 = nil) (E : eval_exprlist tge e le m al2 tyl0 vl0)","proofString":"subst; auto."},{"statement":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) (A : sl1 = nil) (B : Csyntax.typeof e1 = typeof a1) (C : eval_expr tge e le m a1 v') (D : sl2 = nil) (E : eval_exprlist tge e le m al2 tyl0 vl0) : eval_exprlist tge e le m (a1 :: al2) (ty :: tyl0) (v :: vl0).","conclusion":"eval_exprlist tge e le m (a1 :: al2) (ty :: tyl0) (v :: vl0)","hypotheses":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) (A : sl1 = nil) (B : Csyntax.typeof e1 = typeof a1) (C : eval_expr tge e le m a1 v') (D : sl2 = nil) (E : eval_exprlist tge e le m al2 tyl0 vl0)","proofString":"econstructor; eauto.\ncongruence."},{"statement":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) (A : sl1 = nil) (B : Csyntax.typeof e1 = typeof a1) (C : eval_expr tge e le m a1 v') (D : sl2 = nil) (E : eval_exprlist tge e le m al2 tyl0 vl0) : sem_cast v' (typeof a1) ty m = Some v.","conclusion":"sem_cast v' (typeof a1) ty m = Some v","hypotheses":"(le : temp_env) (e1 : Csyntax.expr) (el2 : exprlist) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : tr_exprlist ce le el2 sl2 al2 tmp2) (H1 : list_disjoint tmp1 tmp2) (H2 : incl tmp1 tmp) (H3 : incl tmp2 tmp) (IHtr_exprlist : forall (e0 : Csem.env) (m0 : mem) (tyl : list type) (vl : list val),\neval_simple_list ge e0 m0 el2 tyl vl ->\nsl2 = nil /\\ eval_exprlist tge e0 le m0 al2 tyl vl) (e : Csem.env) (m : mem) (ty : type) (tyl0 : list type) (v : val) (vl0 : list val) (v' : val) (H7 : eval_simple_rvalue ge e m e1 v') (H8 : sem_cast v' (Csyntax.typeof e1) ty m = Some v) (H11 : eval_simple_list ge e m el2 tyl0 vl0) (A : sl1 = nil) (B : Csyntax.typeof e1 = typeof a1) (C : eval_expr tge e le m a1 v') (D : sl2 = nil) (E : eval_exprlist tge e le m al2 tyl0 vl0)","proofString":"congruence."},{"statement":"(k : kind) (le : temp_env) (e : Csyntax.expr) (dst : destination) (sl : list statement) (a : expr) (tmps : list ident) (H : tr_expr ce le dst e sl a tmps) : incl tmps tmps.","conclusion":"incl tmps tmps","hypotheses":"(k : kind) (le : temp_env) (e : Csyntax.expr) (dst : destination) (sl : list statement) (a : expr) (tmps : list ident) (H : tr_expr ce le dst e sl a tmps)","proofString":"red; auto."},{"statement":"(k : kind) (le : temp_env) (e : Csyntax.expr) (dst : destination) (sl : list statement) (a : expr) (tmps : list ident) (H : tr_expr ce le dst e sl a tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H0 : tr_expr ce le' dst e' sl3 a tmps) (H1 : forall id : ident, ~ In id tmps -> le' ! id = le ! id) (H2 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst e' (sl3 ++ nil) a tmps.","conclusion":"tr_expr ce le' dst e' (sl3 ++ nil) a tmps","hypotheses":"(k : kind) (le : temp_env) (e : Csyntax.expr) (dst : destination) (sl : list statement) (a : expr) (tmps : list ident) (H : tr_expr ce le dst e sl a tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H0 : tr_expr ce le' dst e' sl3 a tmps) (H1 : forall id : ident, ~ In id tmps -> le' ! id = le ! id) (H2 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"rewrite app_nil_r; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmps) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmps)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Csyntax.Ederef (C e') ty)\n  (sl3 ++ sl2' ++ final dst (Ederef' a1 ty)) (Ederef' a1 ty) tmps.","conclusion":"tr_expr ce le' dst (Csyntax.Ederef (C e') ty)\n  (sl3 ++ sl2' ++ final dst (Ederef' a1 ty)) (Ederef' a1 ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"rewrite <- app_ass.\neconstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Csyntax.Ederef (C e') ty)\n  ((sl3 ++ sl2') ++ final dst (Ederef' a1 ty)) (Ederef' a1 ty) tmps.","conclusion":"tr_expr ce le' dst (Csyntax.Ederef (C e') ty)\n  ((sl3 ++ sl2') ++ final dst (Ederef' a1 ty)) (Ederef' a1 ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"econstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (f : ident) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H10 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmps) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (f : ident) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H10 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmps)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (f : ident) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H10 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Csyntax.Efield (C e') f ty)\n  (sl3 ++ sl2' ++ final dst (Efield a1 f ty)) (Efield a1 f ty) tmps.","conclusion":"tr_expr ce le' dst (Csyntax.Efield (C e') f ty)\n  (sl3 ++ sl2' ++ final dst (Efield a1 f ty)) (Efield a1 f ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (f : ident) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H10 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"rewrite <- app_ass.\neconstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (f : ident) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H10 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Csyntax.Efield (C e') f ty)\n  ((sl3 ++ sl2') ++ final dst (Efield a1 f ty)) (Efield a1 f ty) tmps.","conclusion":"tr_expr ce le' dst (Csyntax.Efield (C e') f ty)\n  ((sl3 ++ sl2') ++ final dst (Efield a1 f ty)) (Efield a1 f ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (f : ident) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H10 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"econstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (tmp2 : list ident) (H4 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H5 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a tmp2) (H6 : list_disjoint tmp1 tmp2) (H9 : incl tmp1 tmps) (H13 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (tmp2 : list ident) (H4 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H5 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a tmp2) (H6 : list_disjoint tmp1 tmp2) (H9 : incl tmp1 tmps) (H13 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (tmp2 : list ident) (H4 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H5 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a tmp2) (H6 : list_disjoint tmp1 tmp2) (H9 : incl tmp1 tmps) (H13 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Evalof (C e') ty) (sl3 ++ sl2' ++ sl2 ++ final dst a) a\n  tmps.","conclusion":"tr_expr ce le' dst (Evalof (C e') ty) (sl3 ++ sl2' ++ sl2 ++ final dst a) a\n  tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (tmp2 : list ident) (H4 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H5 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a tmp2) (H6 : list_disjoint tmp1 tmp2) (H9 : incl tmp1 tmps) (H13 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"rewrite <- app_ass; econstructor; eauto.\nexploit typeof_context; eauto.\ncongruence."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (tmp2 : list ident) (H4 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H5 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a tmp2) (H6 : list_disjoint tmp1 tmp2) (H9 : incl tmp1 tmps) (H13 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_rvalof ce (Csyntax.typeof (C e')) a1 sl2 a tmp2.","conclusion":"tr_rvalof ce (Csyntax.typeof (C e')) a1 sl2 a tmp2","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (tmp2 : list ident) (H4 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H5 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a tmp2) (H6 : list_disjoint tmp1 tmp2) (H9 : incl tmp1 tmps) (H13 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"exploit typeof_context; eauto.\ncongruence."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (tmp2 : list ident) (H4 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H5 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a tmp2) (H6 : list_disjoint tmp1 tmp2) (H9 : incl tmp1 tmps) (H13 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : Csyntax.typeof (C e') = Csyntax.typeof (C e) ->\ntr_rvalof ce (Csyntax.typeof (C e')) a1 sl2 a tmp2.","conclusion":"Csyntax.typeof (C e') = Csyntax.typeof (C e) ->\ntr_rvalof ce (Csyntax.typeof (C e')) a1 sl2 a tmp2","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (tmp2 : list ident) (H4 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H5 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a tmp2) (H6 : list_disjoint tmp1 tmp2) (H9 : incl tmp1 tmps) (H13 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"congruence."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmps) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmps)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Csyntax.Eaddrof (C e') ty)\n  (sl3 ++ sl2' ++ final dst (Eaddrof' a1 ty)) (Eaddrof' a1 ty) tmps.","conclusion":"tr_expr ce le' dst (Csyntax.Eaddrof (C e') ty)\n  (sl3 ++ sl2' ++ final dst (Eaddrof' a1 ty)) (Eaddrof' a1 ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"rewrite <- app_ass.\neconstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Csyntax.Eaddrof (C e') ty)\n  ((sl3 ++ sl2') ++ final dst (Eaddrof' a1 ty)) (Eaddrof' a1 ty) tmps.","conclusion":"tr_expr ce le' dst (Csyntax.Eaddrof (C e') ty)\n  ((sl3 ++ sl2') ++ final dst (Eaddrof' a1 ty)) (Eaddrof' a1 ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"econstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : unary_operation) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H10 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmps) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : unary_operation) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H10 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmps)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : unary_operation) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H10 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Csyntax.Eunop op (C e') ty)\n  (sl3 ++ sl2' ++ final dst (Eunop op a1 ty)) (Eunop op a1 ty) tmps.","conclusion":"tr_expr ce le' dst (Csyntax.Eunop op (C e') ty)\n  (sl3 ++ sl2' ++ final dst (Eunop op a1 ty)) (Eunop op a1 ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : unary_operation) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H10 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"rewrite <- app_ass.\neconstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : unary_operation) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H10 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Csyntax.Eunop op (C e') ty)\n  ((sl3 ++ sl2') ++ final dst (Eunop op a1 ty)) (Eunop op a1 ty) tmps.","conclusion":"tr_expr ce le' dst (Csyntax.Eunop op (C e') ty)\n  ((sl3 ++ sl2') ++ final dst (Eunop op a1 ty)) (Eunop op a1 ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : unary_operation) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H10 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"econstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl4 ++ sl3) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H9 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl4 ++ sl3) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H9 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H7 : tr_expr ce le For_val e1 nil a1 tmp1) (H10 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H14 : list_disjoint tmp1 tmp2) (H15 : incl tmp1 tmps) (H16 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a2 tmp2) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H7 : tr_expr ce le For_val e1 nil a1 tmp1) (H10 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H14 : list_disjoint tmp1 tmp2) (H15 : incl tmp1 tmps) (H16 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a2 tmp2)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl3 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (a1 : expr) (H9 : tr_expr ce le For_effects (C e) sl a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_effects (C e') (sl3 ++ sl2') a1 tmps) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl3 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (a1 : expr) (H9 : tr_expr ce le For_effects (C e) sl a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_effects (C e') (sl3 ++ sl2') a1 tmps)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (a1 : expr) (H9 : tr_expr ce le For_effects (C e) sl a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_effects (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' For_effects (Csyntax.Ecast (C e') ty) (sl3 ++ sl2') a tmps.","conclusion":"tr_expr ce le' For_effects (Csyntax.Ecast (C e') ty) (sl3 ++ sl2') a tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (a1 : expr) (H9 : tr_expr ce le For_effects (C e) sl a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_effects (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"econstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmps) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmps)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Csyntax.Ecast (C e') ty)\n  (sl3 ++ sl2' ++ final dst (Ecast a1 ty)) (Ecast a1 ty) tmps.","conclusion":"tr_expr ce le' dst (Csyntax.Ecast (C e') ty)\n  (sl3 ++ sl2' ++ final dst (Ecast a1 ty)) (Ecast a1 ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"rewrite <- app_ass.\neconstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Csyntax.Ecast (C e') ty)\n  ((sl3 ++ sl2') ++ final dst (Ecast a1 ty)) (Ecast a1 ty) tmps.","conclusion":"tr_expr ce le' dst (Csyntax.Ecast (C e') ty)\n  ((sl3 ++ sl2') ++ final dst (Ecast a1 ty)) (Ecast a1 ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (H9 : tr_expr ce le For_val (C e) sl1 a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"econstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le (For_set (SDbase type_bool ty t)) r2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le (For_set (SDbase type_bool ty t)) r2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le (For_set (SDbase type_bool ty t)) r2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : In t tmps.","conclusion":"In t tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le (For_set (SDbase type_bool ty t)) r2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_effects r2 sl2 a2 tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_effects r2 sl2 a2 tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sd : set_destination) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le (For_set (SDcons type_bool ty t sd)) r2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sd : set_destination) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le (For_set (SDcons type_bool ty t sd)) r2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le (For_set (SDbase type_bool ty t)) r2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le (For_set (SDbase type_bool ty t)) r2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le (For_set (SDbase type_bool ty t)) r2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : In t tmps.","conclusion":"In t tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le (For_set (SDbase type_bool ty t)) r2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_effects r2 sl2 a2 tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_effects r2 sl2 a2 tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sd : set_destination) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le (For_set (SDcons type_bool ty t sd)) r2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sd : set_destination) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le (For_set (SDcons type_bool ty t sd)) r2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 r3 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le' dst'0 e' sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_expr ce le (For_set (SDbase ty ty t)) r2 sl2 a2 tmp2) (H8 : tr_expr ce le (For_set (SDbase ty ty t)) r3 sl3 a3 tmp3) (H9 : list_disjoint tmp1 tmp2) (H10 : list_disjoint tmp1 tmp3) (H13 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (H18 : incl tmp3 tmps) (H19 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 r3 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le' dst'0 e' sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_expr ce le (For_set (SDbase ty ty t)) r2 sl2 a2 tmp2) (H8 : tr_expr ce le (For_set (SDbase ty ty t)) r3 sl3 a3 tmp3) (H9 : list_disjoint tmp1 tmp2) (H10 : list_disjoint tmp1 tmp3) (H13 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (H18 : incl tmp3 tmps) (H19 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 r3 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl4 sl5 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl4 a'0 tmp'0 /\\\n  sl = sl4 ++ sl5 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl6 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl6 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl6 ++ sl5) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_expr ce le (For_set (SDbase ty ty t)) r2 sl2 a2 tmp2) (H8 : tr_expr ce le (For_set (SDbase ty ty t)) r3 sl3 a3 tmp3) (H9 : list_disjoint tmp1 tmp2) (H10 : list_disjoint tmp1 tmp3) (H13 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (H18 : incl tmp3 tmps) (H19 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\ntr_expr ce le'0 dst' e'0 sl4 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl4 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H1 : tr_expr ce le' dst' e' sl0 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : In t tmps.","conclusion":"In t tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 r3 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl4 sl5 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl4 a'0 tmp'0 /\\\n  sl = sl4 ++ sl5 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl6 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl6 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl6 ++ sl5) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_expr ce le (For_set (SDbase ty ty t)) r2 sl2 a2 tmp2) (H8 : tr_expr ce le (For_set (SDbase ty ty t)) r3 sl3 a3 tmp3) (H9 : list_disjoint tmp1 tmp2) (H10 : list_disjoint tmp1 tmp3) (H13 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (H18 : incl tmp3 tmps) (H19 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\ntr_expr ce le'0 dst' e'0 sl4 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl4 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H1 : tr_expr ce le' dst' e' sl0 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 r3 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le' dst'0 e' sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_expr ce le For_effects r2 sl2 a2 tmp2) (H8 : tr_expr ce le For_effects r3 sl3 a3 tmp3) (H9 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H16 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (H18 : incl tmp3 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 r3 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le' dst'0 e' sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_expr ce le For_effects r2 sl2 a2 tmp2) (H8 : tr_expr ce le For_effects r3 sl3 a3 tmp3) (H9 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H16 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (H18 : incl tmp3 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 r3 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le' dst'0 e' sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sd : set_destination) (t : ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_expr ce le (For_set (SDcons ty ty t sd)) r2 sl2 a2 tmp2) (H8 : tr_expr ce le (For_set (SDcons ty ty t sd)) r3 sl3 a3 tmp3) (H9 : list_disjoint tmp1 tmp2) (H10 : list_disjoint tmp1 tmp3) (H13 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (H18 : incl tmp3 tmps) (H19 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (r2 r3 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le' dst'0 e' sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sd : set_destination) (t : ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_expr ce le (For_set (SDcons ty ty t sd)) r2 sl2 a2 tmp2) (H8 : tr_expr ce le (For_set (SDcons ty ty t sd)) r3 sl3 a3 tmp3) (H9 : list_disjoint tmp1 tmp2) (H10 : list_disjoint tmp1 tmp3) (H13 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (H18 : incl tmp3 tmps) (H19 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_is_bitfield_access ce a1 bf.","conclusion":"tr_is_bitfield_access ce a1 bf","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H10 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl4 ++ sl3) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : incl tmp1 tmps) (H8 : incl tmp2 tmps) (H9 : list_disjoint tmp1 tmp2) (H10 : In t tmps) (H11 : ~ In t tmp1) (H12 : ~ In t tmp2) (H20 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl4 ++ sl3) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : incl tmp1 tmps) (H8 : incl tmp2 tmps) (H9 : list_disjoint tmp1 tmp2) (H10 : In t tmps) (H11 : ~ In t tmp1) (H12 : ~ In t tmp2) (H20 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : incl tmp1 tmps) (H8 : incl tmp2 tmps) (H9 : list_disjoint tmp1 tmp2) (H10 : In t tmps) (H11 : ~ In t tmp1) (H12 : ~ In t tmp2) (H20 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : In t tmps.","conclusion":"In t tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : incl tmp1 tmps) (H8 : incl tmp2 tmps) (H9 : list_disjoint tmp1 tmp2) (H10 : In t tmps) (H11 : ~ In t tmp1) (H12 : ~ In t tmp2) (H20 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : incl tmp1 tmps) (H8 : incl tmp2 tmps) (H9 : list_disjoint tmp1 tmp2) (H10 : In t tmps) (H11 : ~ In t tmp1) (H12 : ~ In t tmp2) (H20 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : Csyntax.typeof (C e) = Csyntax.typeof (C e').","conclusion":"Csyntax.typeof (C e) = Csyntax.typeof (C e')","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : incl tmp1 tmps) (H8 : incl tmp2 tmps) (H9 : list_disjoint tmp1 tmp2) (H10 : In t tmps) (H11 : ~ In t tmp1) (H12 : ~ In t tmp2) (H20 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"eapply typeof_context.\neauto.\nauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : incl tmp1 tmps) (H8 : incl tmp2 tmps) (H9 : list_disjoint tmp1 tmp2) (H10 : In t tmps) (H11 : ~ In t tmp1) (H12 : ~ In t tmp2) (H20 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : Csyntax.typeof e = Csyntax.typeof e'.","conclusion":"Csyntax.typeof e = Csyntax.typeof e'","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : incl tmp1 tmps) (H8 : incl tmp2 tmps) (H9 : list_disjoint tmp1 tmp2) (H10 : In t tmps) (H11 : ~ In t tmp1) (H12 : ~ In t tmp2) (H20 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : incl tmp1 tmps) (H8 : incl tmp2 tmps) (H9 : list_disjoint tmp1 tmp2) (H10 : In t tmps) (H11 : ~ In t tmp1) (H12 : ~ In t tmp2) (H20 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_is_bitfield_access ce a1 bf.","conclusion":"tr_is_bitfield_access ce a1 bf","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H7 : incl tmp1 tmps) (H8 : incl tmp2 tmps) (H9 : list_disjoint tmp1 tmp2) (H10 : In t tmps) (H11 : ~ In t tmp1) (H12 : ~ In t tmp2) (H20 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl3 ++ sl0) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (H16 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a2 tmp2) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl3 ++ sl0) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (H16 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a2 tmp2)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl4 ++ sl0) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (H16 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H2 : tr_expr ce le' dst' e' sl3 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e) : tr_is_bitfield_access ce a1 bf.","conclusion":"tr_is_bitfield_access ce a1 bf","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl4 ++ sl0) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (H16 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H2 : tr_expr ce le' dst' e' sl3 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H9 : incl tmp2 tmps) (H10 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H12 : ~ In t tmp1) (H13 : ~ In t tmp2) (H21 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a2 tmp2) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H9 : incl tmp2 tmps) (H10 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H12 : ~ In t tmp1) (H13 : ~ In t tmp2) (H21 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a2 tmp2)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H9 : incl tmp2 tmps) (H10 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H12 : ~ In t tmp1) (H13 : ~ In t tmp2) (H21 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H2 : tr_expr ce le' dst' e' sl3 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e) : In t tmps.","conclusion":"In t tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H9 : incl tmp2 tmps) (H10 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H12 : ~ In t tmp1) (H13 : ~ In t tmp2) (H21 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H2 : tr_expr ce le' dst' e' sl3 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H9 : incl tmp2 tmps) (H10 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H12 : ~ In t tmp1) (H13 : ~ In t tmp2) (H21 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H2 : tr_expr ce le' dst' e' sl3 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e) : Csyntax.typeof e1 = Csyntax.typeof e1.","conclusion":"Csyntax.typeof e1 = Csyntax.typeof e1","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H9 : incl tmp2 tmps) (H10 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H12 : ~ In t tmp1) (H13 : ~ In t tmp2) (H21 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H2 : tr_expr ce le' dst' e' sl3 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H9 : incl tmp2 tmps) (H10 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H12 : ~ In t tmp1) (H13 : ~ In t tmp2) (H21 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H2 : tr_expr ce le' dst' e' sl3 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e) : tr_is_bitfield_access ce a1 bf.","conclusion":"tr_is_bitfield_access ce a1 bf","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (t : ident) (bf : bitfield) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H9 : incl tmp2 tmps) (H10 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H12 : ~ In t tmp1) (H13 : ~ In t tmp2) (H21 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H2 : tr_expr ce le' dst' e' sl3 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (tyres ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le' dst'0 e' sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H8 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H10 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl3 a3 tmp3) (H11 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H19 : incl tmp1 tmps) (H20 : incl tmp2 tmps) (H21 : incl tmp3 tmps) (H22 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (tyres ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le' dst'0 e' sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H8 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H10 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl3 a3 tmp3) (H11 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H19 : incl tmp1 tmps) (H20 : incl tmp2 tmps) (H21 : incl tmp3 tmps) (H22 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (tyres ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl4 sl5 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl4 a'0 tmp'0 /\\\n  sl = sl4 ++ sl5 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl6 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl6 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl6 ++ sl5) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H8 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H10 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl3 a3 tmp3) (H11 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H19 : incl tmp1 tmps) (H20 : incl tmp2 tmps) (H21 : incl tmp3 tmps) (H22 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\ntr_expr ce le'0 dst' e'0 sl4 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl4 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H1 : tr_expr ce le' dst' e' sl0 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_is_bitfield_access ce a1 bf.","conclusion":"tr_is_bitfield_access ce a1 bf","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (tyres ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl4 sl5 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl4 a'0 tmp'0 /\\\n  sl = sl4 ++ sl5 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl6 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl6 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl6 ++ sl5) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H8 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H10 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl3 a3 tmp3) (H11 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H19 : incl tmp1 tmps) (H20 : incl tmp2 tmps) (H21 : incl tmp3 tmps) (H22 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\ntr_expr ce le'0 dst' e'0 sl4 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl4 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H1 : tr_expr ce le' dst' e' sl0 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (tyres ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le' dst'0 e' sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H7 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H8 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H9 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl3 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H12 : list_disjoint tmp2 tmp3) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : incl tmp3 tmps) (H16 : In t tmps) (H19 : ~ In t tmp1) (H23 : ~ In t tmp2) (H24 : ~ In t tmp3) (H26 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (tyres ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le' dst'0 e' sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H7 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H8 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H9 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl3 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H12 : list_disjoint tmp2 tmp3) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : incl tmp3 tmps) (H16 : In t tmps) (H19 : ~ In t tmp1) (H23 : ~ In t tmp2) (H24 : ~ In t tmp3) (H26 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (tyres ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl4 sl5 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl4 a'0 tmp'0 /\\\n  sl = sl4 ++ sl5 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl6 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl6 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl6 ++ sl5) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H7 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H8 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H9 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl3 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H12 : list_disjoint tmp2 tmp3) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : incl tmp3 tmps) (H16 : In t tmps) (H19 : ~ In t tmp1) (H23 : ~ In t tmp2) (H24 : ~ In t tmp3) (H26 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\ntr_expr ce le'0 dst' e'0 sl4 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl4 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H1 : tr_expr ce le' dst' e' sl0 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : In t tmps.","conclusion":"In t tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (tyres ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl4 sl5 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl4 a'0 tmp'0 /\\\n  sl = sl4 ++ sl5 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl6 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl6 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl6 ++ sl5) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H7 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H8 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H9 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl3 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H12 : list_disjoint tmp2 tmp3) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : incl tmp3 tmps) (H16 : In t tmps) (H19 : ~ In t tmp1) (H23 : ~ In t tmp2) (H24 : ~ In t tmp3) (H26 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\ntr_expr ce le'0 dst' e'0 sl4 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl4 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H1 : tr_expr ce le' dst' e' sl0 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (tyres ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl4 sl5 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl4 a'0 tmp'0 /\\\n  sl = sl4 ++ sl5 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl6 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl6 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl6 ++ sl5) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H7 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H8 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H9 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl3 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H12 : list_disjoint tmp2 tmp3) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : incl tmp3 tmps) (H16 : In t tmps) (H19 : ~ In t tmp1) (H23 : ~ In t tmp2) (H24 : ~ In t tmp3) (H26 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\ntr_expr ce le'0 dst' e'0 sl4 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl4 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H1 : tr_expr ce le' dst' e' sl0 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : Csyntax.typeof (C e) = Csyntax.typeof (C e').","conclusion":"Csyntax.typeof (C e) = Csyntax.typeof (C e')","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (tyres ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl4 sl5 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl4 a'0 tmp'0 /\\\n  sl = sl4 ++ sl5 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl6 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl6 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl6 ++ sl5) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H7 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H8 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H9 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl3 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H12 : list_disjoint tmp2 tmp3) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : incl tmp3 tmps) (H16 : In t tmps) (H19 : ~ In t tmp1) (H23 : ~ In t tmp2) (H24 : ~ In t tmp3) (H26 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\ntr_expr ce le'0 dst' e'0 sl4 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl4 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H1 : tr_expr ce le' dst' e' sl0 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"eapply typeof_context; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (tyres ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl4 sl5 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl4 a'0 tmp'0 /\\\n  sl = sl4 ++ sl5 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl6 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl6 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl6 ++ sl5) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H7 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H8 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H9 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl3 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H12 : list_disjoint tmp2 tmp3) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : incl tmp3 tmps) (H16 : In t tmps) (H19 : ~ In t tmp1) (H23 : ~ In t tmp2) (H24 : ~ In t tmp3) (H26 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\ntr_expr ce le'0 dst' e'0 sl4 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl4 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H1 : tr_expr ce le' dst' e' sl0 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_is_bitfield_access ce a1 bf.","conclusion":"tr_is_bitfield_access ce a1 bf","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e2 : Csyntax.expr) (tyres ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl4 sl5 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl4 a'0 tmp'0 /\\\n  sl = sl4 ++ sl5 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl6 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl6 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl6 ++ sl5) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H7 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H8 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H9 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl3 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H12 : list_disjoint tmp2 tmp3) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (H15 : incl tmp3 tmps) (H16 : In t tmps) (H19 : ~ In t tmp1) (H23 : ~ In t tmp2) (H24 : ~ In t tmp3) (H26 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\ntr_expr ce le'0 dst' e'0 sl4 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl4 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H1 : tr_expr ce le' dst' e' sl0 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (tyres ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl0) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (H8 : tr_expr ce le For_val e1 nil a1 tmp1) (H9 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H11 : tr_rvalof ce (Csyntax.typeof e1) a1 sl3 a3 tmp3) (H12 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H16 : list_disjoint tmp2 tmp3) (H20 : incl tmp1 tmps) (H21 : incl tmp2 tmps) (H22 : incl tmp3 tmps) (H23 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a2 tmp2) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (tyres ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl0) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (H8 : tr_expr ce le For_val e1 nil a1 tmp1) (H9 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H11 : tr_rvalof ce (Csyntax.typeof e1) a1 sl3 a3 tmp3) (H12 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H16 : list_disjoint tmp2 tmp3) (H20 : incl tmp1 tmps) (H21 : incl tmp2 tmps) (H22 : incl tmp3 tmps) (H23 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a2 tmp2)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (tyres ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (H8 : tr_expr ce le For_val e1 nil a1 tmp1) (H9 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H11 : tr_rvalof ce (Csyntax.typeof e1) a1 sl3 a3 tmp3) (H12 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H16 : list_disjoint tmp2 tmp3) (H20 : incl tmp1 tmps) (H21 : incl tmp2 tmps) (H22 : incl tmp3 tmps) (H23 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl1 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H2 : tr_expr ce le' dst' e' sl0 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e) : tr_is_bitfield_access ce a1 bf.","conclusion":"tr_is_bitfield_access ce a1 bf","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (tyres ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (H8 : tr_expr ce le For_val e1 nil a1 tmp1) (H9 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H11 : tr_rvalof ce (Csyntax.typeof e1) a1 sl3 a3 tmp3) (H12 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H16 : list_disjoint tmp2 tmp3) (H20 : incl tmp1 tmps) (H21 : incl tmp2 tmps) (H22 : incl tmp3 tmps) (H23 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl1 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H2 : tr_expr ce le' dst' e' sl0 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (tyres ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl4 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H8 : tr_expr ce le For_val e1 nil a1 tmp1) (H9 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H10 : tr_rvalof ce (Csyntax.typeof e1) a1 sl3 a3 tmp3) (H11 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H13 : list_disjoint tmp2 tmp3) (H14 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (H16 : incl tmp3 tmps) (H17 : In t tmps) (H20 : ~ In t tmp1) (H24 : ~ In t tmp2) (H25 : ~ In t tmp3) (H27 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a2 tmp2) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (tyres ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl4 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H8 : tr_expr ce le For_val e1 nil a1 tmp1) (H9 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H10 : tr_rvalof ce (Csyntax.typeof e1) a1 sl3 a3 tmp3) (H11 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H13 : list_disjoint tmp2 tmp3) (H14 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (H16 : incl tmp3 tmps) (H17 : In t tmps) (H20 : ~ In t tmp1) (H24 : ~ In t tmp2) (H25 : ~ In t tmp3) (H27 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le' dst' e' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl0 ++ sl2') a2 tmp2)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (tyres ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H8 : tr_expr ce le For_val e1 nil a1 tmp1) (H9 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H10 : tr_rvalof ce (Csyntax.typeof e1) a1 sl3 a3 tmp3) (H11 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H13 : list_disjoint tmp2 tmp3) (H14 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (H16 : incl tmp3 tmps) (H17 : In t tmps) (H20 : ~ In t tmp1) (H24 : ~ In t tmp2) (H25 : ~ In t tmp3) (H27 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl1 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H2 : tr_expr ce le' dst' e' sl0 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e) : In t tmps.","conclusion":"In t tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (tyres ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H8 : tr_expr ce le For_val e1 nil a1 tmp1) (H9 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H10 : tr_rvalof ce (Csyntax.typeof e1) a1 sl3 a3 tmp3) (H11 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H13 : list_disjoint tmp2 tmp3) (H14 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (H16 : incl tmp3 tmps) (H17 : In t tmps) (H20 : ~ In t tmp1) (H24 : ~ In t tmp2) (H25 : ~ In t tmp3) (H27 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl1 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H2 : tr_expr ce le' dst' e' sl0 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (tyres ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H8 : tr_expr ce le For_val e1 nil a1 tmp1) (H9 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H10 : tr_rvalof ce (Csyntax.typeof e1) a1 sl3 a3 tmp3) (H11 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H13 : list_disjoint tmp2 tmp3) (H14 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (H16 : incl tmp3 tmps) (H17 : In t tmps) (H20 : ~ In t tmp1) (H24 : ~ In t tmp2) (H25 : ~ In t tmp3) (H27 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl1 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H2 : tr_expr ce le' dst' e' sl0 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e) : Csyntax.typeof e1 = Csyntax.typeof e1.","conclusion":"Csyntax.typeof e1 = Csyntax.typeof e1","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (tyres ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H8 : tr_expr ce le For_val e1 nil a1 tmp1) (H9 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H10 : tr_rvalof ce (Csyntax.typeof e1) a1 sl3 a3 tmp3) (H11 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H13 : list_disjoint tmp2 tmp3) (H14 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (H16 : incl tmp3 tmps) (H17 : In t tmps) (H20 : ~ In t tmp1) (H24 : ~ In t tmp2) (H25 : ~ In t tmp3) (H27 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl1 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H2 : tr_expr ce le' dst' e' sl0 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (tyres ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H8 : tr_expr ce le For_val e1 nil a1 tmp1) (H9 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H10 : tr_rvalof ce (Csyntax.typeof e1) a1 sl3 a3 tmp3) (H11 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H13 : list_disjoint tmp2 tmp3) (H14 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (H16 : incl tmp3 tmps) (H17 : In t tmps) (H20 : ~ In t tmp1) (H24 : ~ In t tmp2) (H25 : ~ In t tmp3) (H27 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl1 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H2 : tr_expr ce le' dst' e' sl0 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e) : tr_is_bitfield_access ce a1 bf.","conclusion":"tr_is_bitfield_access ce a1 bf","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (e1 : Csyntax.expr) (tyres ty : type) (H : simple e1 = true) (H0 : leftcontext k RV C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (H8 : tr_expr ce le For_val e1 nil a1 tmp1) (H9 : tr_expr ce le For_val (C e) sl2 a2 tmp2) (H10 : tr_rvalof ce (Csyntax.typeof e1) a1 sl3 a3 tmp3) (H11 : list_disjoint tmp1 tmp2) (H12 : list_disjoint tmp1 tmp3) (H13 : list_disjoint tmp2 tmp3) (H14 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (H16 : incl tmp3 tmps) (H17 : In t tmps) (H20 : ~ In t tmp1) (H24 : ~ In t tmp2) (H25 : ~ In t tmp3) (H27 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl1 ++ sl2') a2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl0 : list statement) (H2 : tr_expr ce le' dst' e' sl0 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le' ! id0 = le0 ! id0) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H11 : incl tmp2 tmps) (H15 : list_disjoint tmp1 tmp2) (H16 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le' ! id0 = le0 ! id0) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H11 : incl tmp2 tmps) (H15 : list_disjoint tmp1 tmp2) (H16 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le'0 ! id0 = le0 ! id0) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H11 : incl tmp2 tmps) (H15 : list_disjoint tmp1 tmp2) (H16 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le'0 ! id0 = le ! id0) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' For_effects (Epostincr id (C e') ty)\n  (sl3 ++\n   sl2' ++\n   sl2 ++\n   make_assign bf a1 (transl_incrdecr id a2 (Csyntax.typeof (C e))) :: nil) a\n  tmps.","conclusion":"tr_expr ce le' For_effects (Epostincr id (C e') ty)\n  (sl3 ++\n   sl2' ++\n   sl2 ++\n   make_assign bf a1 (transl_incrdecr id a2 (Csyntax.typeof (C e))) :: nil) a\n  tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le'0 ! id0 = le0 ! id0) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H11 : incl tmp2 tmps) (H15 : list_disjoint tmp1 tmp2) (H16 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le'0 ! id0 = le ! id0) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"rewrite <- app_ass.\neconstructor; eauto.\nsymmetry; eapply typeof_context; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le'0 ! id0 = le0 ! id0) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H11 : incl tmp2 tmps) (H15 : list_disjoint tmp1 tmp2) (H16 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le'0 ! id0 = le ! id0) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' For_effects (Epostincr id (C e') ty)\n  ((sl3 ++ sl2') ++\n   sl2 ++\n   make_assign bf a1 (transl_incrdecr id a2 (Csyntax.typeof (C e))) :: nil) a\n  tmps.","conclusion":"tr_expr ce le' For_effects (Epostincr id (C e') ty)\n  ((sl3 ++ sl2') ++\n   sl2 ++\n   make_assign bf a1 (transl_incrdecr id a2 (Csyntax.typeof (C e))) :: nil) a\n  tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le'0 ! id0 = le0 ! id0) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H11 : incl tmp2 tmps) (H15 : list_disjoint tmp1 tmp2) (H16 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le'0 ! id0 = le ! id0) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"econstructor; eauto.\nsymmetry; eapply typeof_context; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le'0 ! id0 = le0 ! id0) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H11 : incl tmp2 tmps) (H15 : list_disjoint tmp1 tmp2) (H16 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le'0 ! id0 = le ! id0) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : Csyntax.typeof (C e) = Csyntax.typeof (C e').","conclusion":"Csyntax.typeof (C e) = Csyntax.typeof (C e')","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le'0 ! id0 = le0 ! id0) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl5 ++ sl4) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_rvalof ce (Csyntax.typeof (C e)) a1 sl2 a2 tmp2) (H8 : incl tmp1 tmps) (H11 : incl tmp2 tmps) (H15 : list_disjoint tmp1 tmp2) (H16 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le'0 ! id0 = le ! id0) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"symmetry; eapply typeof_context; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le' ! id0 = le0 ! id0) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (bf : bitfield) (t : ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : incl tmp1 tmps) (H7 : In t tmps) (H10 : ~ In t tmp1) (H15 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le' ! id0 = le0 ! id0) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (bf : bitfield) (t : ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : incl tmp1 tmps) (H7 : In t tmps) (H10 : ~ In t tmp1) (H15 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le'0 ! id0 = le0 ! id0) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (bf : bitfield) (t : ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : incl tmp1 tmps) (H7 : In t tmps) (H10 : ~ In t tmp1) (H15 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le'0 ! id0 = le ! id0) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Epostincr id (C e') ty)\n  (sl3 ++\n   sl2' ++\n   make_set bf t a1\n   :: make_assign bf a1\n        (transl_incrdecr id (Etempvar t (Csyntax.typeof (C e)))\n           (Csyntax.typeof (C e)))\n      :: final dst (Etempvar t (Csyntax.typeof (C e))))\n  (Etempvar t (Csyntax.typeof (C e))) tmps.","conclusion":"tr_expr ce le' dst (Epostincr id (C e') ty)\n  (sl3 ++\n   sl2' ++\n   make_set bf t a1\n   :: make_assign bf a1\n        (transl_incrdecr id (Etempvar t (Csyntax.typeof (C e)))\n           (Csyntax.typeof (C e)))\n      :: final dst (Etempvar t (Csyntax.typeof (C e))))\n  (Etempvar t (Csyntax.typeof (C e))) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le'0 ! id0 = le0 ! id0) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (bf : bitfield) (t : ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : incl tmp1 tmps) (H7 : In t tmps) (H10 : ~ In t tmp1) (H15 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le'0 ! id0 = le ! id0) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"rewrite <- app_ass.\neconstructor; eauto.\neapply typeof_context; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le'0 ! id0 = le0 ! id0) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (bf : bitfield) (t : ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : incl tmp1 tmps) (H7 : In t tmps) (H10 : ~ In t tmp1) (H15 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le'0 ! id0 = le ! id0) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Epostincr id (C e') ty)\n  ((sl3 ++ sl2') ++\n   make_set bf t a1\n   :: make_assign bf a1\n        (transl_incrdecr id (Etempvar t (Csyntax.typeof (C e)))\n           (Csyntax.typeof (C e)))\n      :: final dst (Etempvar t (Csyntax.typeof (C e))))\n  (Etempvar t (Csyntax.typeof (C e))) tmps.","conclusion":"tr_expr ce le' dst (Epostincr id (C e') ty)\n  ((sl3 ++ sl2') ++\n   make_set bf t a1\n   :: make_assign bf a1\n        (transl_incrdecr id (Etempvar t (Csyntax.typeof (C e)))\n           (Csyntax.typeof (C e)))\n      :: final dst (Etempvar t (Csyntax.typeof (C e))))\n  (Etempvar t (Csyntax.typeof (C e))) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le'0 ! id0 = le0 ! id0) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (bf : bitfield) (t : ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : incl tmp1 tmps) (H7 : In t tmps) (H10 : ~ In t tmp1) (H15 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le'0 ! id0 = le ! id0) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"econstructor; eauto.\neapply typeof_context; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le'0 ! id0 = le0 ! id0) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (bf : bitfield) (t : ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : incl tmp1 tmps) (H7 : In t tmps) (H10 : ~ In t tmp1) (H15 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le'0 ! id0 = le ! id0) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : Csyntax.typeof (C e) = Csyntax.typeof (C e').","conclusion":"Csyntax.typeof (C e) = Csyntax.typeof (C e')","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (ty : type) (H : leftcontext k LV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id0 : ident, ~ In id0 tmp'0 -> le'0 ! id0 = le0 ! id0) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (bf : bitfield) (t : ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : incl tmp1 tmps) (H7 : In t tmps) (H10 : ~ In t tmp1) (H15 : tr_is_bitfield_access ce a1 bf) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le'0 ! id0 = le ! id0) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"eapply typeof_context; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (el : exprlist) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_exprlist ce le el sl2 al2 tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (el : exprlist) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H6 : tr_exprlist ce le el sl2 al2 tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (el : exprlist) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl4 ++ sl3) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (t : ident) (H5 : dst <> For_effects) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_exprlist ce le el sl2 al2 tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H15 : incl tmp1 tmps) (H16 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (el : exprlist) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl4 ++ sl3) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (t : ident) (H5 : dst <> For_effects) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_exprlist ce le el sl2 al2 tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H15 : incl tmp1 tmps) (H16 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (el : exprlist) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (t : ident) (H5 : dst <> For_effects) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_exprlist ce le el sl2 al2 tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H15 : incl tmp1 tmps) (H16 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : dst <> For_effects.","conclusion":"dst <> For_effects","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (el : exprlist) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (t : ident) (H5 : dst <> For_effects) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_exprlist ce le el sl2 al2 tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H15 : incl tmp1 tmps) (H16 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (el : exprlist) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (t : ident) (H5 : dst <> For_effects) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_exprlist ce le el sl2 al2 tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H15 : incl tmp1 tmps) (H16 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : In t tmps.","conclusion":"In t tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (el : exprlist) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl4 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl4 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl5 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl5 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst0 (C e'0) (sl5 ++ sl4) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (t : ident) (H5 : dst <> For_effects) (H6 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H7 : tr_exprlist ce le el sl2 al2 tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : In t tmps) (H15 : incl tmp1 tmps) (H16 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_val (C e'0) (sl0 ++ sl2') a1 tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontextlist k C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a0 : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_exprlist ce le' (C e') (sl3 ++ sl0) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_exprlist ce le (C e) sl2 al2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_exprlist ce le' (C e') (sl3 ++ sl2') al2 tmp2) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontextlist k C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a0 : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_exprlist ce le' (C e') (sl3 ++ sl0) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (H6 : tr_expr ce le For_val e1 nil a1 tmp1) (H7 : tr_exprlist ce le (C e) sl2 al2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmps) (H15 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_exprlist ce le' (C e') (sl3 ++ sl2') al2 tmp2)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontextlist k C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_exprlist ce le' (C e') (sl3 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (t : ident) (H6 : dst <> For_effects) (H7 : tr_expr ce le For_val e1 nil a1 tmp1) (H8 : tr_exprlist ce le (C e) sl2 al2 tmp2) (H9 : list_disjoint tmp1 tmp2) (H12 : In t tmps) (H16 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_exprlist ce le' (C e') (sl3 ++ sl2') al2 tmp2) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontextlist k C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_exprlist ce le' (C e') (sl3 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (t : ident) (H6 : dst <> For_effects) (H7 : tr_expr ce le For_val e1 nil a1 tmp1) (H8 : tr_exprlist ce le (C e) sl2 al2 tmp2) (H9 : list_disjoint tmp1 tmp2) (H12 : In t tmps) (H16 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_exprlist ce le' (C e') (sl3 ++ sl2') al2 tmp2)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontextlist k C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (t : ident) (H6 : dst <> For_effects) (H7 : tr_expr ce le For_val e1 nil a1 tmp1) (H8 : tr_exprlist ce le (C e) sl2 al2 tmp2) (H9 : list_disjoint tmp1 tmp2) (H12 : In t tmps) (H16 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl0 ++ sl2') al2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H2 : tr_expr ce le' dst' e' sl3 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e) : dst <> For_effects.","conclusion":"dst <> For_effects","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontextlist k C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (t : ident) (H6 : dst <> For_effects) (H7 : tr_expr ce le For_val e1 nil a1 tmp1) (H8 : tr_exprlist ce le (C e) sl2 al2 tmp2) (H9 : list_disjoint tmp1 tmp2) (H12 : In t tmps) (H16 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl0 ++ sl2') al2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H2 : tr_expr ce le' dst' e' sl3 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontextlist k C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (t : ident) (H6 : dst <> For_effects) (H7 : tr_expr ce le For_val e1 nil a1 tmp1) (H8 : tr_exprlist ce le (C e) sl2 al2 tmp2) (H9 : list_disjoint tmp1 tmp2) (H12 : In t tmps) (H16 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl0 ++ sl2') al2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H2 : tr_expr ce le' dst' e' sl3 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e) : In t tmps.","conclusion":"In t tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (e1 : Csyntax.expr) (ty : type) (H : simple e1 = true) (H0 : leftcontextlist k C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (t : ident) (H6 : dst <> For_effects) (H7 : tr_expr ce le For_val e1 nil a1 tmp1) (H8 : tr_exprlist ce le (C e) sl2 al2 tmp2) (H9 : list_disjoint tmp1 tmp2) (H12 : In t tmps) (H16 : incl tmp1 tmps) (H17 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl0 ++ sl2') al2 tmp2) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H2 : tr_expr ce le' dst' e' sl3 a' tmp') (H3 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H4 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a0 : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_exprlist ce le' (C e') (sl3 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (H11 : tr_exprlist ce le (C e) sl0 al tmp1) (H12 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_exprlist ce le' (C e') (sl3 ++ sl2') al tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a0 : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_exprlist ce le' (C e') (sl3 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (H11 : tr_exprlist ce le (C e) sl0 al tmp1) (H12 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_exprlist ce le' (C e') (sl3 ++ sl2') al tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a0 : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (H11 : tr_exprlist ce le (C e) sl0 al tmp1) (H12 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' For_effects (Ebuiltin ef tyargs (C e') ty)\n  (sl3 ++ sl2' ++ Sbuiltin None ef tyargs al :: nil) a tmps.","conclusion":"tr_expr ce le' For_effects (Ebuiltin ef tyargs (C e') ty)\n  (sl3 ++ sl2' ++ Sbuiltin None ef tyargs al :: nil) a tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a0 : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (H11 : tr_exprlist ce le (C e) sl0 al tmp1) (H12 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"rewrite <- app_ass.\nchange (sl3++sl2') with (nil ++ sl3 ++ sl2').\nrewrite app_ass.\neconstructor.\napply S; auto.\nauto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a0 : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (H11 : tr_exprlist ce le (C e) sl0 al tmp1) (H12 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' For_effects (Ebuiltin ef tyargs (C e') ty)\n  ((sl3 ++ sl2') ++ Sbuiltin None ef tyargs al :: nil) a tmps.","conclusion":"tr_expr ce le' For_effects (Ebuiltin ef tyargs (C e') ty)\n  ((sl3 ++ sl2') ++ Sbuiltin None ef tyargs al :: nil) a tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a0 : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (H11 : tr_exprlist ce le (C e) sl0 al tmp1) (H12 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"change (sl3++sl2') with (nil ++ sl3 ++ sl2').\nrewrite app_ass.\neconstructor.\napply S; auto.\nauto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a0 : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (H11 : tr_exprlist ce le (C e) sl0 al tmp1) (H12 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' For_effects (Ebuiltin ef tyargs (C e') ty)\n  ((nil ++ sl3 ++ sl2') ++ Sbuiltin None ef tyargs al :: nil) a tmps.","conclusion":"tr_expr ce le' For_effects (Ebuiltin ef tyargs (C e') ty)\n  ((nil ++ sl3 ++ sl2') ++ Sbuiltin None ef tyargs al :: nil) a tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a0 : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (H11 : tr_exprlist ce le (C e) sl0 al tmp1) (H12 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"rewrite app_ass.\neconstructor.\napply S; auto.\nauto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a0 : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (H11 : tr_exprlist ce le (C e) sl0 al tmp1) (H12 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' For_effects (Ebuiltin ef tyargs (C e') ty)\n  (nil ++ (sl3 ++ sl2') ++ Sbuiltin None ef tyargs al :: nil) a tmps.","conclusion":"tr_expr ce le' For_effects (Ebuiltin ef tyargs (C e') ty)\n  (nil ++ (sl3 ++ sl2') ++ Sbuiltin None ef tyargs al :: nil) a tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a0 : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (a : expr) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (H11 : tr_exprlist ce le (C e) sl0 al tmp1) (H12 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"econstructor.\napply S; auto.\nauto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_exprlist ce le' (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_exprlist ce le' (C e') (sl3 ++ sl2') al tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_exprlist ce le' (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_exprlist ce le' (C e') (sl3 ++ sl2') al tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Ebuiltin ef tyargs (C e') ty)\n  (sl3 ++ sl2' ++ Sbuiltin (Some t) ef tyargs al :: final dst (Etempvar t ty))\n  (Etempvar t ty) tmps.","conclusion":"tr_expr ce le' dst (Ebuiltin ef tyargs (C e') ty)\n  (sl3 ++ sl2' ++ Sbuiltin (Some t) ef tyargs al :: final dst (Etempvar t ty))\n  (Etempvar t ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"rewrite <- app_ass.\nchange (sl3++sl2') with (nil ++ sl3 ++ sl2').\nrewrite app_ass.\neconstructor.\nauto.\napply S; auto.\nauto.\nauto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Ebuiltin ef tyargs (C e') ty)\n  ((sl3 ++ sl2') ++\n   Sbuiltin (Some t) ef tyargs al :: final dst (Etempvar t ty))\n  (Etempvar t ty) tmps.","conclusion":"tr_expr ce le' dst (Ebuiltin ef tyargs (C e') ty)\n  ((sl3 ++ sl2') ++\n   Sbuiltin (Some t) ef tyargs al :: final dst (Etempvar t ty))\n  (Etempvar t ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"change (sl3++sl2') with (nil ++ sl3 ++ sl2').\nrewrite app_ass.\neconstructor.\nauto.\napply S; auto.\nauto.\nauto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Ebuiltin ef tyargs (C e') ty)\n  ((nil ++ sl3 ++ sl2') ++\n   Sbuiltin (Some t) ef tyargs al :: final dst (Etempvar t ty))\n  (Etempvar t ty) tmps.","conclusion":"tr_expr ce le' dst (Ebuiltin ef tyargs (C e') ty)\n  ((nil ++ sl3 ++ sl2') ++\n   Sbuiltin (Some t) ef tyargs al :: final dst (Etempvar t ty))\n  (Etempvar t ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"rewrite app_ass.\neconstructor.\nauto.\napply S; auto.\nauto.\nauto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' dst (Ebuiltin ef tyargs (C e') ty)\n  (nil ++\n   (sl3 ++ sl2') ++\n   Sbuiltin (Some t) ef tyargs al :: final dst (Etempvar t ty))\n  (Etempvar t ty) tmps.","conclusion":"tr_expr ce le' dst (Ebuiltin ef tyargs (C e') ty)\n  (nil ++\n   (sl3 ++ sl2') ++\n   Sbuiltin (Some t) ef tyargs al :: final dst (Etempvar t ty))\n  (Etempvar t ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"econstructor.\nauto.\napply S; auto.\nauto.\nauto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : dst <> For_effects.","conclusion":"dst <> For_effects","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : In t tmps.","conclusion":"In t tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (ef : external_function) (tyargs : list type) (ty : type) (H : leftcontextlist k C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_exprlist ce le'0 (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (tmps : list ident) (sl0 : list statement) (al : list expr) (tmp1 : list ident) (t : ident) (H8 : dst <> For_effects) (H12 : tr_exprlist ce le (C e) sl0 al tmp1) (H13 : In t tmps) (H14 : incl tmp1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl0 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl1 : list statement),\ntr_expr ce le'0 dst' e'0 sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_exprlist ce le'0 (C e'0) (sl1 ++ sl2') al tmp1) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (tmp2 : list ident) (H5 : tr_expr ce le For_effects (C e) sl1 a1 tmp1) (H6 : tr_expr ce le dst e2 sl2 a tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_effects (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (e2 : Csyntax.expr) (ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst0 : destination)\n  (sl : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst0 (C e0) sl a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst0 (C e') (sl4 ++ sl3) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (dst : destination) (a : expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (tmp2 : list ident) (H5 : tr_expr ce le For_effects (C e) sl1 a1 tmp1) (H6 : tr_expr ce le dst e2 sl2 a tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmps) (H14 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_effects (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (tycast ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (tmps : list ident) (a1 : expr) (t : ident) (H10 : tr_expr ce le (For_set (SDbase tycast ty t)) (C e) sl a1 tmps) (H11 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' (For_set (SDbase tycast ty t)) (C e') (sl3 ++ sl2') a1 tmps) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (tycast ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl3 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (tmps : list ident) (a1 : expr) (t : ident) (H10 : tr_expr ce le (For_set (SDbase tycast ty t)) (C e) sl a1 tmps) (H11 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' (For_set (SDbase tycast ty t)) (C e') (sl3 ++ sl2') a1 tmps)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (tycast ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (tmps : list ident) (a1 : expr) (t : ident) (H10 : tr_expr ce le (For_set (SDbase tycast ty t)) (C e) sl a1 tmps) (H11 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 (For_set (SDbase tycast ty t)) (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' For_val (Eparen (C e') tycast ty) (sl3 ++ sl2')\n  (Etempvar t ty) tmps.","conclusion":"tr_expr ce le' For_val (Eparen (C e') tycast ty) (sl3 ++ sl2')\n  (Etempvar t ty) tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (tycast ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl4 ++ sl2) a tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (tmps : list ident) (a1 : expr) (t : ident) (H10 : tr_expr ce le (For_set (SDbase tycast ty t)) (C e) sl a1 tmps) (H11 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 (For_set (SDbase tycast ty t)) (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"econstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (tycast ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl3 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (a1 : expr) (H10 : tr_expr ce le For_effects (C e) sl a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_effects (C e') (sl3 ++ sl2') a1 tmps) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (tycast ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl3 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (a1 : expr) (H10 : tr_expr ce le For_effects (C e) sl a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_effects (C e') (sl3 ++ sl2') a1 tmps)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (tycast ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (a1 : expr) (H10 : tr_expr ce le For_effects (C e) sl a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_effects (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' For_effects (Eparen (C e') tycast ty) (sl3 ++ sl2') a tmps.","conclusion":"tr_expr ce le' For_effects (Eparen (C e') tycast ty) (sl3 ++ sl2') a tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (tycast ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (a1 : expr) (H10 : tr_expr ce le For_effects (C e) sl a1 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 For_effects (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"econstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (tycast ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl3 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (t : ident) (sd : set_destination) (a1 : expr) (H10 : tr_expr ce le (For_set (SDcons tycast ty t sd)) (C e) sl a1 tmps) (H11 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' (For_set (SDcons tycast ty t sd)) (C e') (sl3 ++ sl2') a1 tmps) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (tycast ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl3 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (t : ident) (sd : set_destination) (a1 : expr) (H10 : tr_expr ce le (For_set (SDcons tycast ty t sd)) (C e) sl a1 tmps) (H11 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' (For_set (SDcons tycast ty t sd)) (C e') (sl3 ++ sl2') a1 tmps)","proofString":"auto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (tycast ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (t : ident) (sd : set_destination) (a1 : expr) (H10 : tr_expr ce le (For_set (SDcons tycast ty t sd)) (C e) sl a1 tmps) (H11 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 (For_set (SDcons tycast ty t sd)) \n  (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e) : tr_expr ce le' (For_set sd) (Eparen (C e') tycast ty) (sl3 ++ sl2') a tmps.","conclusion":"tr_expr ce le' (For_set sd) (Eparen (C e') tycast ty) (sl3 ++ sl2') a tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (tycast ty : type) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl0 : list statement) (a0 : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl0 a0 tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl2 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl0 = sl1 ++ sl2 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le'0 dst'0 e'0 sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le'0 ! id = le0 ! id) ->\n   Csyntax.typeof e'0 = Csyntax.typeof e0 ->\n   tr_expr ce le'0 dst (C e'0) (sl4 ++ sl2) a0 tmps0)) (le : temp_env) (e : Csyntax.expr) (sl : list statement) (a : expr) (tmps : list ident) (t : ident) (sd : set_destination) (a1 : expr) (H10 : tr_expr ce le (For_set (SDcons tycast ty t sd)) (C e) sl a1 tmps) (H11 : In t tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl = sl1' ++ sl2') (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (e'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' e'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof e'0 = Csyntax.typeof e ->\ntr_expr ce le'0 (For_set (SDcons tycast ty t sd)) \n  (C e'0) (sl0 ++ sl2') a1 tmps) (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement) (H1 : tr_expr ce le' dst' e' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof e' = Csyntax.typeof e)","proofString":"econstructor; eauto."},{"statement":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (el : exprlist) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (H4 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H5 : tr_exprlist ce le el sl2 al2 tmp2) (H6 : list_disjoint tmp1 tmp2) (H8 : incl tmp1 tmps) (H12 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> Csyntax.expr) (el : exprlist) (H : leftcontext k RV C) (H0 : forall (le0 : temp_env) (e0 : Csyntax.expr) (dst : destination)\n  (sl : list statement) (a : expr) (tmps0 : list ident),\ntr_expr ce le0 dst (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl4 : list statement),\n   tr_expr ce le' dst'0 e' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_expr ce le' dst (C e') (sl4 ++ sl3) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (H4 : tr_expr ce le For_val (C e) sl1 a1 tmp1) (H5 : tr_exprlist ce le el sl2 al2 tmp2) (H6 : list_disjoint tmp1 tmp2) (H8 : incl tmp1 tmps) (H12 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl1 = sl1' ++ sl2') (R : incl tmp' tmp1) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_expr ce le' For_val (C e') (sl3 ++ sl2') a1 tmp1)","proofString":"red; auto."},{"statement":"(k : kind) (C : Csyntax.expr -> exprlist) (e1 : Csyntax.expr) (H : simple e1 = true) (H0 : leftcontextlist k C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_exprlist ce le' (C e') (sl3 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val e1 nil a1 tmp1) (H6 : tr_exprlist ce le (C e) sl2 al2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H9 : incl tmp1 tmps) (H13 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_exprlist ce le' (C e') (sl3 ++ sl2') al2 tmp2) : incl tmp' tmps.","conclusion":"incl tmp' tmps","hypotheses":"(k : kind) (C : Csyntax.expr -> exprlist) (e1 : Csyntax.expr) (H : simple e1 = true) (H0 : leftcontextlist k C) (H1 : forall (le0 : temp_env) (e0 : Csyntax.expr) (sl : list statement)\n  (a : list expr) (tmps0 : list ident),\ntr_exprlist ce le0 (C e0) sl a tmps0 ->\nexists\n  (dst'0 : destination) (sl1 sl0 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_expr ce le0 dst'0 e0 sl1 a'0 tmp'0 /\\\n  sl = sl1 ++ sl0 /\\\n  incl tmp'0 tmps0 /\\\n  (forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst'0 e' sl3 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le0 ! id) ->\n   Csyntax.typeof e' = Csyntax.typeof e0 ->\n   tr_exprlist ce le' (C e') (sl3 ++ sl0) a tmps0)) (le : temp_env) (e : Csyntax.expr) (tmps : list ident) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (al2 : list expr) (tmp2 : list ident) (H5 : tr_expr ce le For_val e1 nil a1 tmp1) (H6 : tr_exprlist ce le (C e) sl2 al2 tmp2) (H7 : list_disjoint tmp1 tmp2) (H9 : incl tmp1 tmps) (H13 : incl tmp2 tmps) (dst' : destination) (sl1' sl2' : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' e sl1' a' tmp') (Q : sl2 = sl1' ++ sl2') (R : incl tmp' tmp2) (S : forall (le' : temp_env) (e' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' e' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof e' = Csyntax.typeof e ->\ntr_exprlist ce le' (C e') (sl3 ++ sl2') al2 tmp2)","proofString":"red; auto."},{"statement":"(C : Csyntax.expr -> Csyntax.expr) (le : temp_env) (r : Csyntax.expr) (dst : destination) (sl : list statement) (a : expr) (tmps : list ident) (H : leftcontext RV RV C) (H0 : tr_expr ce le dst (C r) sl a tmps) : exists\n  (dst' : destination) (sl1 sl2 : list statement) \n(a' : expr) (tmp' : list ident),\n  tr_expr ce le dst' r sl1 a' tmp' /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp' tmps /\\\n  (forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst' r' sl3 a' tmp' ->\n   (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof r ->\n   tr_expr ce le' dst (C r') (sl3 ++ sl2) a tmps).","conclusion":"exists\n  (dst' : destination) (sl1 sl2 : list statement) \n(a' : expr) (tmp' : list ident),\n  tr_expr ce le dst' r sl1 a' tmp' /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp' tmps /\\\n  (forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\n   tr_expr ce le' dst' r' sl3 a' tmp' ->\n   (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof r ->\n   tr_expr ce le' dst (C r') (sl3 ++ sl2) a tmps)","hypotheses":"(C : Csyntax.expr -> Csyntax.expr) (le : temp_env) (r : Csyntax.expr) (dst : destination) (sl : list statement) (a : expr) (tmps : list ident) (H : leftcontext RV RV C) (H0 : tr_expr ce le dst (C r) sl a tmps)","proofString":"eapply (proj1 tr_expr_leftcontext_rec); eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (v : val) (ty : type) (a : expr) (tmp : list ident) (H : typeof a = ty) (H0 : eval_expr tge e le m a v) (r : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H1 : Eval v ty = C r) (H2 : leftcontext RV RV C) : exists\n  (dst' : destination) (sl1 sl2 : list statement) \n(a' : expr) (tmp' : list ident),\n  tr_top ce tge e le m dst' r sl1 a' tmp' /\\\n  nil = sl1 ++ sl2 /\\\n  incl tmp' tmp /\\\n  (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n     (sl3 : list statement),\n   tr_expr ce le' dst' r' sl3 a' tmp' ->\n   (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof r ->\n   tr_top ce tge e le' m' For_val (C r') (sl3 ++ sl2) a tmp).","conclusion":"exists\n  (dst' : destination) (sl1 sl2 : list statement) \n(a' : expr) (tmp' : list ident),\n  tr_top ce tge e le m dst' r sl1 a' tmp' /\\\n  nil = sl1 ++ sl2 /\\\n  incl tmp' tmp /\\\n  (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n     (sl3 : list statement),\n   tr_expr ce le' dst' r' sl3 a' tmp' ->\n   (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof r ->\n   tr_top ce tge e le' m' For_val (C r') (sl3 ++ sl2) a tmp)","hypotheses":"(e : env) (le : temp_env) (m : mem) (v : val) (ty : type) (a : expr) (tmp : list ident) (H : typeof a = ty) (H0 : eval_expr tge e le m a v) (r : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H1 : Eval v ty = C r) (H2 : leftcontext RV RV C)","proofString":"inv H2; inv H1.\nexists For_val; econstructor; econstructor; econstructor; econstructor.\nsplit.\napply tr_top_val_val; eauto.\nsplit.\ninstantiate (1 := nil); auto.\nsplit.\napply incl_refl.\nintros.\nrewrite app_nil_r.\nconstructor; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (v : val) (a : expr) (tmp : list ident) (H0 : eval_expr tge e le m a v) : exists\n  (dst' : destination) (sl1 sl2 : list statement) \n(a' : expr) (tmp' : list ident),\n  tr_top ce tge e le m dst' (Eval v (typeof a)) sl1 a' tmp' /\\\n  nil = sl1 ++ sl2 /\\\n  incl tmp' tmp /\\\n  (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n     (sl3 : list statement),\n   tr_expr ce le' dst' r' sl3 a' tmp' ->\n   (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof (Eval v (typeof a)) ->\n   tr_top ce tge e le' m' For_val r' (sl3 ++ sl2) a tmp).","conclusion":"exists\n  (dst' : destination) (sl1 sl2 : list statement) \n(a' : expr) (tmp' : list ident),\n  tr_top ce tge e le m dst' (Eval v (typeof a)) sl1 a' tmp' /\\\n  nil = sl1 ++ sl2 /\\\n  incl tmp' tmp /\\\n  (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n     (sl3 : list statement),\n   tr_expr ce le' dst' r' sl3 a' tmp' ->\n   (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof (Eval v (typeof a)) ->\n   tr_top ce tge e le' m' For_val r' (sl3 ++ sl2) a tmp)","hypotheses":"(e : env) (le : temp_env) (m : mem) (v : val) (a : expr) (tmp : list ident) (H0 : eval_expr tge e le m a v)","proofString":"exists For_val; econstructor; econstructor; econstructor; econstructor.\nsplit.\napply tr_top_val_val; eauto.\nsplit.\ninstantiate (1 := nil); auto.\nsplit.\napply incl_refl.\nintros.\nrewrite app_nil_r.\nconstructor; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (v : val) (a : expr) (tmp : list ident) (H0 : eval_expr tge e le m a v) (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement) (H : tr_expr ce le' For_val r' sl3 a tmp) (H1 : forall id : ident, ~ In id tmp -> le' ! id = le ! id) (H2 : Csyntax.typeof r' = Csyntax.typeof (Eval v (typeof a))) : tr_top ce tge e le' m' For_val r' (sl3 ++ nil) a tmp.","conclusion":"tr_top ce tge e le' m' For_val r' (sl3 ++ nil) a tmp","hypotheses":"(e : env) (le : temp_env) (m : mem) (v : val) (a : expr) (tmp : list ident) (H0 : eval_expr tge e le m a v) (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement) (H : tr_expr ce le' For_val r' sl3 a tmp) (H1 : forall id : ident, ~ In id tmp -> le' ! id = le ! id) (H2 : Csyntax.typeof r' = Csyntax.typeof (Eval v (typeof a)))","proofString":"rewrite app_nil_r.\nconstructor; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (v : val) (a : expr) (tmp : list ident) (H0 : eval_expr tge e le m a v) (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement) (H : tr_expr ce le' For_val r' sl3 a tmp) (H1 : forall id : ident, ~ In id tmp -> le' ! id = le ! id) (H2 : Csyntax.typeof r' = Csyntax.typeof (Eval v (typeof a))) : tr_top ce tge e le' m' For_val r' sl3 a tmp.","conclusion":"tr_top ce tge e le' m' For_val r' sl3 a tmp","hypotheses":"(e : env) (le : temp_env) (m : mem) (v : val) (a : expr) (tmp : list ident) (H0 : eval_expr tge e le m a v) (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement) (H : tr_expr ce le' For_val r' sl3 a tmp) (H1 : forall id : ident, ~ In id tmp -> le' ! id = le ! id) (H2 : Csyntax.typeof r' = Csyntax.typeof (Eval v (typeof a)))","proofString":"constructor; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (r : Csyntax.expr) (sl : list statement) (a : expr) (tmp : list ident) (H : tr_expr ce le dst r sl a tmp) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H0 : r = C r0) (H1 : leftcontext RV RV C) : exists\n  (dst' : destination) (sl1 sl2 : list statement) \n(a' : expr) (tmp' : list ident),\n  tr_top ce tge e le m dst' r0 sl1 a' tmp' /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp' tmp /\\\n  (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n     (sl3 : list statement),\n   tr_expr ce le' dst' r' sl3 a' tmp' ->\n   (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof r0 ->\n   tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp).","conclusion":"exists\n  (dst' : destination) (sl1 sl2 : list statement) \n(a' : expr) (tmp' : list ident),\n  tr_top ce tge e le m dst' r0 sl1 a' tmp' /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp' tmp /\\\n  (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n     (sl3 : list statement),\n   tr_expr ce le' dst' r' sl3 a' tmp' ->\n   (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof r0 ->\n   tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp)","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (r : Csyntax.expr) (sl : list statement) (a : expr) (tmp : list ident) (H : tr_expr ce le dst r sl a tmp) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H0 : r = C r0) (H1 : leftcontext RV RV C)","proofString":"subst r.\nexploit tr_expr_leftcontext; eauto.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\nexists dst'; exists sl1; exists sl2; exists a'; exists tmp'.\nsplit.\napply tr_top_base; auto.\nsplit.\nauto.\nsplit.\nauto.\nintros.\napply tr_top_base.\napply S; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) : exists\n  (dst' : destination) (sl1 sl2 : list statement) \n(a' : expr) (tmp' : list ident),\n  tr_top ce tge e le m dst' r0 sl1 a' tmp' /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp' tmp /\\\n  (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n     (sl3 : list statement),\n   tr_expr ce le' dst' r' sl3 a' tmp' ->\n   (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof r0 ->\n   tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp).","conclusion":"exists\n  (dst' : destination) (sl1 sl2 : list statement) \n(a' : expr) (tmp' : list ident),\n  tr_top ce tge e le m dst' r0 sl1 a' tmp' /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp' tmp /\\\n  (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n     (sl3 : list statement),\n   tr_expr ce le' dst' r' sl3 a' tmp' ->\n   (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof r0 ->\n   tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp)","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C)","proofString":"exploit tr_expr_leftcontext; eauto.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\nexists dst'; exists sl1; exists sl2; exists a'; exists tmp'.\nsplit.\napply tr_top_base; auto.\nsplit.\nauto.\nsplit.\nauto.\nintros.\napply tr_top_base.\napply S; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_expr ce le dst' r0 sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmp /\\\n   (forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\n    tr_expr ce le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof r0 ->\n    tr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp)) ->\nexists\n  (dst' : destination) (sl1 sl2 : list statement) \n(a' : expr) (tmp' : list ident),\n  tr_top ce tge e le m dst' r0 sl1 a' tmp' /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp' tmp /\\\n  (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n     (sl3 : list statement),\n   tr_expr ce le' dst' r' sl3 a' tmp' ->\n   (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof r0 ->\n   tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp).","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_expr ce le dst' r0 sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmp /\\\n   (forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\n    tr_expr ce le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof r0 ->\n    tr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp)) ->\nexists\n  (dst' : destination) (sl1 sl2 : list statement) \n(a' : expr) (tmp' : list ident),\n  tr_top ce tge e le m dst' r0 sl1 a' tmp' /\\\n  sl = sl1 ++ sl2 /\\\n  incl tmp' tmp /\\\n  (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n     (sl3 : list statement),\n   tr_expr ce le' dst' r' sl3 a' tmp' ->\n   (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof r0 ->\n   tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp)","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\nexists dst'; exists sl1; exists sl2; exists a'; exists tmp'.\nsplit.\napply tr_top_base; auto.\nsplit.\nauto.\nsplit.\nauto.\nintros.\napply tr_top_base.\napply S; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp) : exists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_top ce tge e le m dst'0 r0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmp /\\\n  (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n     (sl4 : list statement),\n   tr_expr ce le' dst'0 r' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof r0 ->\n   tr_top ce tge e le' m' dst (C r') (sl4 ++ sl3) a tmp).","conclusion":"exists\n  (dst'0 : destination) (sl0 sl3 : list statement) \n(a'0 : expr) (tmp'0 : list ident),\n  tr_top ce tge e le m dst'0 r0 sl0 a'0 tmp'0 /\\\n  sl = sl0 ++ sl3 /\\\n  incl tmp'0 tmp /\\\n  (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n     (sl4 : list statement),\n   tr_expr ce le' dst'0 r' sl4 a'0 tmp'0 ->\n   (forall id : ident, ~ In id tmp'0 -> le' ! id = le ! id) ->\n   Csyntax.typeof r' = Csyntax.typeof r0 ->\n   tr_top ce tge e le' m' dst (C r') (sl4 ++ sl3) a tmp)","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp)","proofString":"exists dst'; exists sl1; exists sl2; exists a'; exists tmp'.\nsplit.\napply tr_top_base; auto.\nsplit.\nauto.\nsplit.\nauto.\nintros.\napply tr_top_base.\napply S; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp) : tr_top ce tge e le m dst' r0 sl1 a' tmp' /\\\nsl = sl1 ++ sl2 /\\\nincl tmp' tmp /\\\n(forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n   (sl3 : list statement),\n tr_expr ce le' dst' r' sl3 a' tmp' ->\n (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n Csyntax.typeof r' = Csyntax.typeof r0 ->\n tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp).","conclusion":"tr_top ce tge e le m dst' r0 sl1 a' tmp' /\\\nsl = sl1 ++ sl2 /\\\nincl tmp' tmp /\\\n(forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n   (sl3 : list statement),\n tr_expr ce le' dst' r' sl3 a' tmp' ->\n (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n Csyntax.typeof r' = Csyntax.typeof r0 ->\n tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp)","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp)","proofString":"split.\napply tr_top_base; auto.\nsplit.\nauto.\nsplit.\nauto.\nintros.\napply tr_top_base.\napply S; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp) : tr_top ce tge e le m dst' r0 sl1 a' tmp'.","conclusion":"tr_top ce tge e le m dst' r0 sl1 a' tmp'","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp)","proofString":"apply tr_top_base; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp) : sl = sl1 ++ sl2 /\\\nincl tmp' tmp /\\\n(forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n   (sl3 : list statement),\n tr_expr ce le' dst' r' sl3 a' tmp' ->\n (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n Csyntax.typeof r' = Csyntax.typeof r0 ->\n tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp).","conclusion":"sl = sl1 ++ sl2 /\\\nincl tmp' tmp /\\\n(forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n   (sl3 : list statement),\n tr_expr ce le' dst' r' sl3 a' tmp' ->\n (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n Csyntax.typeof r' = Csyntax.typeof r0 ->\n tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp)","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp)","proofString":"split.\nauto.\nsplit.\nauto.\nintros.\napply tr_top_base.\napply S; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp) : sl = sl1 ++ sl2.","conclusion":"sl = sl1 ++ sl2","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp)","proofString":"auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp) : incl tmp' tmp /\\\n(forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n   (sl3 : list statement),\n tr_expr ce le' dst' r' sl3 a' tmp' ->\n (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n Csyntax.typeof r' = Csyntax.typeof r0 ->\n tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp).","conclusion":"incl tmp' tmp /\\\n(forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n   (sl3 : list statement),\n tr_expr ce le' dst' r' sl3 a' tmp' ->\n (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n Csyntax.typeof r' = Csyntax.typeof r0 ->\n tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp)","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp)","proofString":"split.\nauto.\nintros.\napply tr_top_base.\napply S; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp) : incl tmp' tmp.","conclusion":"incl tmp' tmp","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp)","proofString":"auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp) : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp.","conclusion":"forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le' : temp_env) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr ce le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof r0 ->\ntr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp)","proofString":"intros.\napply tr_top_base.\napply S; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le'0 : temp_env) (r'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' r'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r'0 = Csyntax.typeof r0 ->\ntr_expr ce le'0 dst (C r'0) (sl0 ++ sl2) a tmp) (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement) (H0 : tr_expr ce le' dst' r' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof r' = Csyntax.typeof r0) : tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp.","conclusion":"tr_top ce tge e le' m' dst (C r') (sl3 ++ sl2) a tmp","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le'0 : temp_env) (r'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' r'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r'0 = Csyntax.typeof r0 ->\ntr_expr ce le'0 dst (C r'0) (sl0 ++ sl2) a tmp) (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement) (H0 : tr_expr ce le' dst' r' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof r' = Csyntax.typeof r0)","proofString":"apply tr_top_base.\napply S; auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le'0 : temp_env) (r'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' r'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r'0 = Csyntax.typeof r0 ->\ntr_expr ce le'0 dst (C r'0) (sl0 ++ sl2) a tmp) (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement) (H0 : tr_expr ce le' dst' r' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof r' = Csyntax.typeof r0) : tr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp.","conclusion":"tr_expr ce le' dst (C r') (sl3 ++ sl2) a tmp","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (sl : list statement) (a : expr) (tmp : list ident) (r0 : Csyntax.expr) (C : Csyntax.expr -> Csyntax.expr) (H : tr_expr ce le dst (C r0) sl a tmp) (H1 : leftcontext RV RV C) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_expr ce le dst' r0 sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmp) (S : forall (le'0 : temp_env) (r'0 : Csyntax.expr) (sl0 : list statement),\ntr_expr ce le'0 dst' r'0 sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r'0 = Csyntax.typeof r0 ->\ntr_expr ce le'0 dst (C r'0) (sl0 ++ sl2) a tmp) (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement) (H0 : tr_expr ce le' dst' r' sl3 a' tmp') (H2 : forall id : ident, ~ In id tmp' -> le' ! id = le ! id) (H3 : Csyntax.typeof r' = Csyntax.typeof r0)","proofString":"apply S; auto."},{"statement":"(v : val) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : match classify_cast ty ty' with\n| cast_case_pointer =>\n    match v with\n    | Vint _ => if Archi.ptr64 then None else Some v\n    | Vlong _ => if Archi.ptr64 then Some v else None\n    | Vptr _ _ => Some v\n    | _ => None\n    end\n| cast_case_i2i sz2 si2 =>\n    match v with\n    | Vint i => Some (Vint (cast_int_int sz2 si2 i))\n    | _ => None\n    end\n| cast_case_f2f => match v with\n                   | Vfloat f => Some (Vfloat f)\n                   | _ => None\n                   end\n| cast_case_s2s =>\n    match v with\n    | Vsingle f => Some (Vsingle f)\n    | _ => None\n    end\n| cast_case_f2s =>\n    match v with\n    | Vfloat f => Some (Vsingle (Floats.Float.to_single f))\n    | _ => None\n    end\n| cast_case_s2f =>\n    match v with\n    | Vsingle f => Some (Vfloat (Floats.Float.of_single f))\n    | _ => None\n    end\n| cast_case_i2f si1 =>\n    match v with\n    | Vint i => Some (Vfloat (cast_int_float si1 i))\n    | _ => None\n    end\n| cast_case_i2s si1 =>\n    match v with\n    | Vint i => Some (Vsingle (cast_int_single si1 i))\n    | _ => None\n    end\n| cast_case_f2i sz2 si2 =>\n    match v with\n    | Vfloat f =>\n        match cast_float_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2i sz2 si2 =>\n    match v with\n    | Vsingle f =>\n        match cast_single_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_l2l => match v with\n                   | Vlong n => Some (Vlong n)\n                   | _ => None\n                   end\n| cast_case_i2l si =>\n    match v with\n    | Vint n => Some (Vlong (cast_int_long si n))\n    | _ => None\n    end\n| cast_case_l2i sz si =>\n    match v with\n    | Vlong n =>\n        Some (Vint (cast_int_int sz si (Int.repr (Int64.unsigned n))))\n    | _ => None\n    end\n| cast_case_l2f si1 =>\n    match v with\n    | Vlong i => Some (Vfloat (cast_long_float si1 i))\n    | _ => None\n    end\n| cast_case_l2s si1 =>\n    match v with\n    | Vlong i => Some (Vsingle (cast_long_single si1 i))\n    | _ => None\n    end\n| cast_case_f2l si2 =>\n    match v with\n    | Vfloat f =>\n        match cast_float_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2l si2 =>\n    match v with\n    | Vsingle f =>\n        match cast_single_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_i2bool =>\n    match v with\n    | Vint n => Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_l2bool =>\n    match v with\n    | Vlong n =>\n        Some (Vint (if Int64.eq n Int64.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_f2bool =>\n    match v with\n    | Vfloat f =>\n        Some\n          (Vint\n             (if Floats.Float.cmp Ceq f Floats.Float.zero\n              then Int.zero\n              else Int.one))\n    | _ => None\n    end\n| cast_case_s2bool =>\n    match v with\n    | Vsingle f =>\n        Some\n          (Vint\n             (if Floats.Float32.cmp Ceq f Floats.Float32.zero\n              then Int.zero\n              else Int.one))\n    | _ => None\n    end\n| cast_case_struct id1 id2 | cast_case_union id1 id2 =>\n    match v with\n    | Vptr _ _ => if ident_eq id1 id2 then Some v else None\n    | _ => None\n    end\n| cast_case_void => Some v\n| cast_case_default => None\nend = Some v1) (H0 : match classify_cast ty ty' with\n| cast_case_pointer =>\n    match v with\n    | Vint _ => if Archi.ptr64 then None else Some v\n    | Vlong _ => if Archi.ptr64 then Some v else None\n    | Vptr _ _ => Some v\n    | _ => None\n    end\n| cast_case_i2i sz2 si2 =>\n    match v with\n    | Vint i => Some (Vint (cast_int_int sz2 si2 i))\n    | _ => None\n    end\n| cast_case_f2f => match v with\n                   | Vfloat f => Some (Vfloat f)\n                   | _ => None\n                   end\n| cast_case_s2s =>\n    match v with\n    | Vsingle f => Some (Vsingle f)\n    | _ => None\n    end\n| cast_case_f2s =>\n    match v with\n    | Vfloat f => Some (Vsingle (Floats.Float.to_single f))\n    | _ => None\n    end\n| cast_case_s2f =>\n    match v with\n    | Vsingle f => Some (Vfloat (Floats.Float.of_single f))\n    | _ => None\n    end\n| cast_case_i2f si1 =>\n    match v with\n    | Vint i => Some (Vfloat (cast_int_float si1 i))\n    | _ => None\n    end\n| cast_case_i2s si1 =>\n    match v with\n    | Vint i => Some (Vsingle (cast_int_single si1 i))\n    | _ => None\n    end\n| cast_case_f2i sz2 si2 =>\n    match v with\n    | Vfloat f =>\n        match cast_float_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2i sz2 si2 =>\n    match v with\n    | Vsingle f =>\n        match cast_single_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_l2l => match v with\n                   | Vlong n => Some (Vlong n)\n                   | _ => None\n                   end\n| cast_case_i2l si =>\n    match v with\n    | Vint n => Some (Vlong (cast_int_long si n))\n    | _ => None\n    end\n| cast_case_l2i sz si =>\n    match v with\n    | Vlong n =>\n        Some (Vint (cast_int_int sz si (Int.repr (Int64.unsigned n))))\n    | _ => None\n    end\n| cast_case_l2f si1 =>\n    match v with\n    | Vlong i => Some (Vfloat (cast_long_float si1 i))\n    | _ => None\n    end\n| cast_case_l2s si1 =>\n    match v with\n    | Vlong i => Some (Vsingle (cast_long_single si1 i))\n    | _ => None\n    end\n| cast_case_f2l si2 =>\n    match v with\n    | Vfloat f =>\n        match cast_float_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2l si2 =>\n    match v with\n    | Vsingle f =>\n        match cast_single_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_i2bool =>\n    match v with\n    | Vint n => Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_l2bool =>\n    match v with\n    | Vlong n =>\n        Some (Vint (if Int64.eq n Int64.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_f2bool =>\n    match v with\n    | Vfloat f =>\n        Some\n          (Vint\n             (if Floats.Float.cmp Ceq f Floats.Float.zero\n              then Int.zero\n              else Int.one))\n    | _ => None\n    end\n| cast_case_s2bool =>\n    match v with\n    | Vsingle f =>\n        Some\n          (Vint\n             (if Floats.Float32.cmp Ceq f Floats.Float32.zero\n              then Int.zero\n              else Int.one))\n    | _ => None\n    end\n| cast_case_struct id1 id2 | cast_case_union id1 id2 =>\n    match v with\n    | Vptr _ _ => if ident_eq id1 id2 then Some v else None\n    | _ => None\n    end\n| cast_case_void => Some v\n| cast_case_default => None\nend = Some v2) : v1 = v2.","conclusion":"v1 = v2","hypotheses":"(v : val) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : match classify_cast ty ty' with\n| cast_case_pointer =>\n    match v with\n    | Vint _ => if Archi.ptr64 then None else Some v\n    | Vlong _ => if Archi.ptr64 then Some v else None\n    | Vptr _ _ => Some v\n    | _ => None\n    end\n| cast_case_i2i sz2 si2 =>\n    match v with\n    | Vint i => Some (Vint (cast_int_int sz2 si2 i))\n    | _ => None\n    end\n| cast_case_f2f => match v with\n                   | Vfloat f => Some (Vfloat f)\n                   | _ => None\n                   end\n| cast_case_s2s =>\n    match v with\n    | Vsingle f => Some (Vsingle f)\n    | _ => None\n    end\n| cast_case_f2s =>\n    match v with\n    | Vfloat f => Some (Vsingle (Floats.Float.to_single f))\n    | _ => None\n    end\n| cast_case_s2f =>\n    match v with\n    | Vsingle f => Some (Vfloat (Floats.Float.of_single f))\n    | _ => None\n    end\n| cast_case_i2f si1 =>\n    match v with\n    | Vint i => Some (Vfloat (cast_int_float si1 i))\n    | _ => None\n    end\n| cast_case_i2s si1 =>\n    match v with\n    | Vint i => Some (Vsingle (cast_int_single si1 i))\n    | _ => None\n    end\n| cast_case_f2i sz2 si2 =>\n    match v with\n    | Vfloat f =>\n        match cast_float_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2i sz2 si2 =>\n    match v with\n    | Vsingle f =>\n        match cast_single_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_l2l => match v with\n                   | Vlong n => Some (Vlong n)\n                   | _ => None\n                   end\n| cast_case_i2l si =>\n    match v with\n    | Vint n => Some (Vlong (cast_int_long si n))\n    | _ => None\n    end\n| cast_case_l2i sz si =>\n    match v with\n    | Vlong n =>\n        Some (Vint (cast_int_int sz si (Int.repr (Int64.unsigned n))))\n    | _ => None\n    end\n| cast_case_l2f si1 =>\n    match v with\n    | Vlong i => Some (Vfloat (cast_long_float si1 i))\n    | _ => None\n    end\n| cast_case_l2s si1 =>\n    match v with\n    | Vlong i => Some (Vsingle (cast_long_single si1 i))\n    | _ => None\n    end\n| cast_case_f2l si2 =>\n    match v with\n    | Vfloat f =>\n        match cast_float_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2l si2 =>\n    match v with\n    | Vsingle f =>\n        match cast_single_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_i2bool =>\n    match v with\n    | Vint n => Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_l2bool =>\n    match v with\n    | Vlong n =>\n        Some (Vint (if Int64.eq n Int64.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_f2bool =>\n    match v with\n    | Vfloat f =>\n        Some\n          (Vint\n             (if Floats.Float.cmp Ceq f Floats.Float.zero\n              then Int.zero\n              else Int.one))\n    | _ => None\n    end\n| cast_case_s2bool =>\n    match v with\n    | Vsingle f =>\n        Some\n          (Vint\n             (if Floats.Float32.cmp Ceq f Floats.Float32.zero\n              then Int.zero\n              else Int.one))\n    | _ => None\n    end\n| cast_case_struct id1 id2 | cast_case_union id1 id2 =>\n    match v with\n    | Vptr _ _ => if ident_eq id1 id2 then Some v else None\n    | _ => None\n    end\n| cast_case_void => Some v\n| cast_case_default => None\nend = Some v1) (H0 : match classify_cast ty ty' with\n| cast_case_pointer =>\n    match v with\n    | Vint _ => if Archi.ptr64 then None else Some v\n    | Vlong _ => if Archi.ptr64 then Some v else None\n    | Vptr _ _ => Some v\n    | _ => None\n    end\n| cast_case_i2i sz2 si2 =>\n    match v with\n    | Vint i => Some (Vint (cast_int_int sz2 si2 i))\n    | _ => None\n    end\n| cast_case_f2f => match v with\n                   | Vfloat f => Some (Vfloat f)\n                   | _ => None\n                   end\n| cast_case_s2s =>\n    match v with\n    | Vsingle f => Some (Vsingle f)\n    | _ => None\n    end\n| cast_case_f2s =>\n    match v with\n    | Vfloat f => Some (Vsingle (Floats.Float.to_single f))\n    | _ => None\n    end\n| cast_case_s2f =>\n    match v with\n    | Vsingle f => Some (Vfloat (Floats.Float.of_single f))\n    | _ => None\n    end\n| cast_case_i2f si1 =>\n    match v with\n    | Vint i => Some (Vfloat (cast_int_float si1 i))\n    | _ => None\n    end\n| cast_case_i2s si1 =>\n    match v with\n    | Vint i => Some (Vsingle (cast_int_single si1 i))\n    | _ => None\n    end\n| cast_case_f2i sz2 si2 =>\n    match v with\n    | Vfloat f =>\n        match cast_float_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2i sz2 si2 =>\n    match v with\n    | Vsingle f =>\n        match cast_single_int si2 f with\n        | Some i => Some (Vint (cast_int_int sz2 si2 i))\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_l2l => match v with\n                   | Vlong n => Some (Vlong n)\n                   | _ => None\n                   end\n| cast_case_i2l si =>\n    match v with\n    | Vint n => Some (Vlong (cast_int_long si n))\n    | _ => None\n    end\n| cast_case_l2i sz si =>\n    match v with\n    | Vlong n =>\n        Some (Vint (cast_int_int sz si (Int.repr (Int64.unsigned n))))\n    | _ => None\n    end\n| cast_case_l2f si1 =>\n    match v with\n    | Vlong i => Some (Vfloat (cast_long_float si1 i))\n    | _ => None\n    end\n| cast_case_l2s si1 =>\n    match v with\n    | Vlong i => Some (Vsingle (cast_long_single si1 i))\n    | _ => None\n    end\n| cast_case_f2l si2 =>\n    match v with\n    | Vfloat f =>\n        match cast_float_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_s2l si2 =>\n    match v with\n    | Vsingle f =>\n        match cast_single_long si2 f with\n        | Some i => Some (Vlong i)\n        | None => None\n        end\n    | _ => None\n    end\n| cast_case_i2bool =>\n    match v with\n    | Vint n => Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_l2bool =>\n    match v with\n    | Vlong n =>\n        Some (Vint (if Int64.eq n Int64.zero then Int.zero else Int.one))\n    | Vptr b ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned ofs)\n         then Some Vone\n         else None\n    | _ => None\n    end\n| cast_case_f2bool =>\n    match v with\n    | Vfloat f =>\n        Some\n          (Vint\n             (if Floats.Float.cmp Ceq f Floats.Float.zero\n              then Int.zero\n              else Int.one))\n    | _ => None\n    end\n| cast_case_s2bool =>\n    match v with\n    | Vsingle f =>\n        Some\n          (Vint\n             (if Floats.Float32.cmp Ceq f Floats.Float32.zero\n              then Int.zero\n              else Int.one))\n    | _ => None\n    end\n| cast_case_struct id1 id2 | cast_case_union id1 id2 =>\n    match v with\n    | Vptr _ _ => if ident_eq id1 id2 then Some v else None\n    | _ => None\n    end\n| cast_case_void => Some v\n| cast_case_default => None\nend = Some v2)","proofString":"destruct (classify_cast ty ty'); try congruence.\ndestruct v; try congruence.\ndestruct Archi.ptr64; try discriminate.\ndestruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.\ndestruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.\nauto.\ndestruct v; try congruence.\ndestruct (negb Archi.ptr64); try discriminate.\ndestruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.\ndestruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.\nauto."},{"statement":"(v : val) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : match v with\n| Vint n => Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))\n| Vptr b ofs =>\n    if Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| _ => None\nend = Some v1) (H0 : match v with\n| Vint n => Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))\n| Vptr b ofs =>\n    if Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| _ => None\nend = Some v2) : v1 = v2.","conclusion":"v1 = v2","hypotheses":"(v : val) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : match v with\n| Vint n => Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))\n| Vptr b ofs =>\n    if Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| _ => None\nend = Some v1) (H0 : match v with\n| Vint n => Some (Vint (if Int.eq n Int.zero then Int.zero else Int.one))\n| Vptr b ofs =>\n    if Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| _ => None\nend = Some v2)","proofString":"destruct v; try congruence.\ndestruct Archi.ptr64; try discriminate.\ndestruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.\ndestruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.\nauto."},{"statement":"(b : block) (i : ptrofs) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : (if Archi.ptr64\n then None\n else\n  if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v1) (H0 : (if Archi.ptr64\n then None\n else\n  if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v2) : v1 = v2.","conclusion":"v1 = v2","hypotheses":"(b : block) (i : ptrofs) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : (if Archi.ptr64\n then None\n else\n  if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v1) (H0 : (if Archi.ptr64\n then None\n else\n  if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v2)","proofString":"destruct Archi.ptr64; try discriminate.\ndestruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.\ndestruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.\nauto."},{"statement":"(b : block) (i : ptrofs) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : (if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v1) (H0 : (if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v2) : v1 = v2.","conclusion":"v1 = v2","hypotheses":"(b : block) (i : ptrofs) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : (if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v1) (H0 : (if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v2)","proofString":"destruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.\ndestruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.\nauto."},{"statement":"(b : block) (i : ptrofs) (ty ty' : type) (m1 m2 : mem) (v2 : val) (H0 : (if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v2) : Vone = v2.","conclusion":"Vone = v2","hypotheses":"(b : block) (i : ptrofs) (ty ty' : type) (m1 m2 : mem) (v2 : val) (H0 : (if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v2)","proofString":"destruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.\nauto."},{"statement":"(b : block) (i : ptrofs) (ty ty' : type) (m1 m2 : mem) : Vone = Vone.","conclusion":"Vone = Vone","hypotheses":"(b : block) (i : ptrofs) (ty ty' : type) (m1 m2 : mem)","proofString":"auto."},{"statement":"(v : val) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : match v with\n| Vlong n =>\n    Some (Vint (if Int64.eq n Int64.zero then Int.zero else Int.one))\n| Vptr b ofs =>\n    if negb Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| _ => None\nend = Some v1) (H0 : match v with\n| Vlong n =>\n    Some (Vint (if Int64.eq n Int64.zero then Int.zero else Int.one))\n| Vptr b ofs =>\n    if negb Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| _ => None\nend = Some v2) : v1 = v2.","conclusion":"v1 = v2","hypotheses":"(v : val) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : match v with\n| Vlong n =>\n    Some (Vint (if Int64.eq n Int64.zero then Int.zero else Int.one))\n| Vptr b ofs =>\n    if negb Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| _ => None\nend = Some v1) (H0 : match v with\n| Vlong n =>\n    Some (Vint (if Int64.eq n Int64.zero then Int.zero else Int.one))\n| Vptr b ofs =>\n    if negb Archi.ptr64\n    then None\n    else\n     if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned ofs)\n     then Some Vone\n     else None\n| _ => None\nend = Some v2)","proofString":"destruct v; try congruence.\ndestruct (negb Archi.ptr64); try discriminate.\ndestruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.\ndestruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.\nauto."},{"statement":"(b : block) (i : ptrofs) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : (if negb Archi.ptr64\n then None\n else\n  if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v1) (H0 : (if negb Archi.ptr64\n then None\n else\n  if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v2) : v1 = v2.","conclusion":"v1 = v2","hypotheses":"(b : block) (i : ptrofs) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : (if negb Archi.ptr64\n then None\n else\n  if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v1) (H0 : (if negb Archi.ptr64\n then None\n else\n  if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v2)","proofString":"destruct (negb Archi.ptr64); try discriminate.\ndestruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.\ndestruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.\nauto."},{"statement":"(b : block) (i : ptrofs) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : (if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v1) (H0 : (if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v2) : v1 = v2.","conclusion":"v1 = v2","hypotheses":"(b : block) (i : ptrofs) (ty ty' : type) (m1 : mem) (v1 : val) (m2 : mem) (v2 : val) (H : (if Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v1) (H0 : (if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v2)","proofString":"destruct (Mem.weak_valid_pointer m1 b (Ptrofs.unsigned i)); inv H.\ndestruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.\nauto."},{"statement":"(b : block) (i : ptrofs) (ty ty' : type) (m1 m2 : mem) (v2 : val) (H0 : (if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v2) : Vone = v2.","conclusion":"Vone = v2","hypotheses":"(b : block) (i : ptrofs) (ty ty' : type) (m1 m2 : mem) (v2 : val) (H0 : (if Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i) then Some Vone else None) =\nSome v2)","proofString":"destruct (Mem.weak_valid_pointer m2 b (Ptrofs.unsigned i)); inv H0.\nauto."},{"statement":"(b : block) (i : ptrofs) (ty ty' : type) (m1 m2 : mem) : Vone = Vone.","conclusion":"Vone = Vone","hypotheses":"(b : block) (i : ptrofs) (ty ty' : type) (m1 m2 : mem)","proofString":"auto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (ty : type) (v1 v : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v) (IHeval_expr : match eval_simpl_expr a with\n| Some v' => v' = v1\n| None => True\nend) : match\n  match eval_simpl_expr a with\n  | Some v0 => sem_cast v0 (typeof a) ty Mem.empty\n  | None => None\n  end\nwith\n| Some v' => v' = v\n| None => True\nend.","conclusion":"match\n  match eval_simpl_expr a with\n  | Some v0 => sem_cast v0 (typeof a) ty Mem.empty\n  | None => None\n  end\nwith\n| Some v' => v' = v\n| None => True\nend","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (ty : type) (v1 v : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v) (IHeval_expr : match eval_simpl_expr a with\n| Some v' => v' = v1\n| None => True\nend)","proofString":"destruct (eval_simpl_expr a); auto.\nsubst.\ndestruct (sem_cast v1 (typeof a) ty Mem.empty) as [v'|] eqn:C; auto.\neapply sem_cast_deterministic; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (ty : type) (v1 v : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v) (v0 : val) (IHeval_expr : v0 = v1) : match sem_cast v0 (typeof a) ty Mem.empty with\n| Some v' => v' = v\n| None => True\nend.","conclusion":"match sem_cast v0 (typeof a) ty Mem.empty with\n| Some v' => v' = v\n| None => True\nend","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (ty : type) (v1 v : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v) (v0 : val) (IHeval_expr : v0 = v1)","proofString":"subst.\ndestruct (sem_cast v1 (typeof a) ty Mem.empty) as [v'|] eqn:C; auto.\neapply sem_cast_deterministic; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (ty : type) (v1 v : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v) : match sem_cast v1 (typeof a) ty Mem.empty with\n| Some v' => v' = v\n| None => True\nend.","conclusion":"match sem_cast v1 (typeof a) ty Mem.empty with\n| Some v' => v' = v\n| None => True\nend","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (ty : type) (v1 v : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v)","proofString":"destruct (sem_cast v1 (typeof a) ty Mem.empty) as [v'|] eqn:C; auto.\neapply sem_cast_deterministic; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (ty : type) (v1 v : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v) (v' : val) (C : sem_cast v1 (typeof a) ty Mem.empty = Some v') : v' = v.","conclusion":"v' = v","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (ty : type) (v1 v : val) (H : eval_expr tge e le m a v1) (H0 : sem_cast v1 (typeof a) ty m = Some v) (v' : val) (C : sem_cast v1 (typeof a) ty Mem.empty = Some v')","proofString":"eapply sem_cast_deterministic; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (a : expr) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : eval_lvalue tge e le m a loc ofs bf) (H0 : deref_loc (typeof a) m loc ofs bf v) : match eval_simpl_expr a with\n| Some v' => v' = v\n| None => True\nend.","conclusion":"match eval_simpl_expr a with\n| Some v' => v' = v\n| None => True\nend","hypotheses":"(e : env) (le : temp_env) (m : mem) (a : expr) (loc : block) (ofs : ptrofs) (bf : bitfield) (v : val) (H : eval_lvalue tge e le m a loc ofs bf) (H0 : deref_loc (typeof a) m loc ofs bf v)","proofString":"inv H; simpl; auto."},{"statement":"(v : val) (t : type) (m : mem) (b : bool) : match classify_bool t with\n| bool_case_i =>\n    match v with\n    | Vint n => Some (negb (Int.eq n Int.zero))\n    | Vptr b0 ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer Mem.empty b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_l =>\n    match v with\n    | Vlong n => Some (negb (Int64.eq n Int64.zero))\n    | Vptr b0 ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer Mem.empty b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_f =>\n    match v with\n    | Vfloat f => Some (negb (Floats.Float.cmp Ceq f Floats.Float.zero))\n    | _ => None\n    end\n| bool_case_s =>\n    match v with\n    | Vsingle f => Some (negb (Floats.Float32.cmp Ceq f Floats.Float32.zero))\n    | _ => None\n    end\n| bool_default => None\nend = Some b ->\nmatch classify_bool t with\n| bool_case_i =>\n    match v with\n    | Vint n => Some (negb (Int.eq n Int.zero))\n    | Vptr b0 ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_l =>\n    match v with\n    | Vlong n => Some (negb (Int64.eq n Int64.zero))\n    | Vptr b0 ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_f =>\n    match v with\n    | Vfloat f => Some (negb (Floats.Float.cmp Ceq f Floats.Float.zero))\n    | _ => None\n    end\n| bool_case_s =>\n    match v with\n    | Vsingle f => Some (negb (Floats.Float32.cmp Ceq f Floats.Float32.zero))\n    | _ => None\n    end\n| bool_default => None\nend = Some b.","conclusion":"match classify_bool t with\n| bool_case_i =>\n    match v with\n    | Vint n => Some (negb (Int.eq n Int.zero))\n    | Vptr b0 ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer Mem.empty b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_l =>\n    match v with\n    | Vlong n => Some (negb (Int64.eq n Int64.zero))\n    | Vptr b0 ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer Mem.empty b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_f =>\n    match v with\n    | Vfloat f => Some (negb (Floats.Float.cmp Ceq f Floats.Float.zero))\n    | _ => None\n    end\n| bool_case_s =>\n    match v with\n    | Vsingle f => Some (negb (Floats.Float32.cmp Ceq f Floats.Float32.zero))\n    | _ => None\n    end\n| bool_default => None\nend = Some b ->\nmatch classify_bool t with\n| bool_case_i =>\n    match v with\n    | Vint n => Some (negb (Int.eq n Int.zero))\n    | Vptr b0 ofs =>\n        if Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_l =>\n    match v with\n    | Vlong n => Some (negb (Int64.eq n Int64.zero))\n    | Vptr b0 ofs =>\n        if negb Archi.ptr64\n        then None\n        else\n         if Mem.weak_valid_pointer m b0 (Ptrofs.unsigned ofs)\n         then Some true\n         else None\n    | _ => None\n    end\n| bool_case_f =>\n    match v with\n    | Vfloat f => Some (negb (Floats.Float.cmp Ceq f Floats.Float.zero))\n    | _ => None\n    end\n| bool_case_s =>\n    match v with\n    | Vsingle f => Some (negb (Floats.Float32.cmp Ceq f Floats.Float32.zero))\n    | _ => None\n    end\n| bool_default => None\nend = Some b","hypotheses":"(v : val) (t : type) (m : mem) (b : bool)","proofString":"destruct (classify_bool t); destruct v; destruct Archi.ptr64 eqn:SF; auto;  simpl; congruence."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) : star step1 tge (State f (makeif a s1 s2) k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"star step1 tge (State f (makeif a s1 s2) k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b)","proofString":"functional induction (makeif a s1 s2).\nexploit eval_simpl_expr_sound; eauto.\nrewrite e0.\nintro EQ; subst v.\nassert (bool_val v1 (typeof a) m = Some true) by (apply static_bool_val_sound; auto).\nreplace b with true by congruence.\nconstructor.\nexploit eval_simpl_expr_sound; eauto.\nrewrite e0.\nintro EQ; subst v.\nassert (bool_val v1 (typeof a) m = Some false) by (apply static_bool_val_sound; auto).\nreplace b with false by congruence.\nconstructor.\napply star_one.\neapply step_ifthenelse; eauto.\napply star_one.\neapply step_ifthenelse; eauto."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = Some true) : star step1 tge (State f s1 k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"star step1 tge (State f s1 k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = Some true)","proofString":"exploit eval_simpl_expr_sound; eauto.\nrewrite e0.\nintro EQ; subst v.\nassert (bool_val v1 (typeof a) m = Some true) by (apply static_bool_val_sound; auto).\nreplace b with true by congruence.\nconstructor."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = Some true) : match eval_simpl_expr a with\n| Some v' => v' = v1\n| None => True\nend ->\nstar step1 tge (State f s1 k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"match eval_simpl_expr a with\n| Some v' => v' = v1\n| None => True\nend ->\nstar step1 tge (State f s1 k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = Some true)","proofString":"rewrite e0.\nintro EQ; subst v.\nassert (bool_val v1 (typeof a) m = Some true) by (apply static_bool_val_sound; auto).\nreplace b with true by congruence.\nconstructor."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = Some true) : v = v1 ->\nstar step1 tge (State f s1 k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"v = v1 ->\nstar step1 tge (State f s1 k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = Some true)","proofString":"intro EQ; subst v.\nassert (bool_val v1 (typeof a) m = Some true) by (apply static_bool_val_sound; auto).\nreplace b with true by congruence.\nconstructor."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e1 : bool_val v1 (typeof a) Mem.empty = Some true) (e0 : eval_simpl_expr a = Some v1) : star step1 tge (State f s1 k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"star step1 tge (State f s1 k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e1 : bool_val v1 (typeof a) Mem.empty = Some true) (e0 : eval_simpl_expr a = Some v1)","proofString":"assert (bool_val v1 (typeof a) m = Some true) by (apply static_bool_val_sound; auto).\nreplace b with true by congruence.\nconstructor."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e1 : bool_val v1 (typeof a) Mem.empty = Some true) (e0 : eval_simpl_expr a = Some v1) (H1 : bool_val v1 (typeof a) m = Some true) : star step1 tge (State f s1 k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"star step1 tge (State f s1 k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e1 : bool_val v1 (typeof a) Mem.empty = Some true) (e0 : eval_simpl_expr a = Some v1) (H1 : bool_val v1 (typeof a) m = Some true)","proofString":"replace b with true by congruence.\nconstructor."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e1 : bool_val v1 (typeof a) Mem.empty = Some true) (e0 : eval_simpl_expr a = Some v1) (H1 : bool_val v1 (typeof a) m = Some true) : star step1 tge (State f s1 k e le m) E0 (State f s1 k e le m).","conclusion":"star step1 tge (State f s1 k e le m) E0 (State f s1 k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e1 : bool_val v1 (typeof a) Mem.empty = Some true) (e0 : eval_simpl_expr a = Some v1) (H1 : bool_val v1 (typeof a) m = Some true)","proofString":"constructor."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = Some false) : star step1 tge (State f s2 k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"star step1 tge (State f s2 k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = Some false)","proofString":"exploit eval_simpl_expr_sound; eauto.\nrewrite e0.\nintro EQ; subst v.\nassert (bool_val v1 (typeof a) m = Some false) by (apply static_bool_val_sound; auto).\nreplace b with false by congruence.\nconstructor."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = Some false) : match eval_simpl_expr a with\n| Some v' => v' = v1\n| None => True\nend ->\nstar step1 tge (State f s2 k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"match eval_simpl_expr a with\n| Some v' => v' = v1\n| None => True\nend ->\nstar step1 tge (State f s2 k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = Some false)","proofString":"rewrite e0.\nintro EQ; subst v.\nassert (bool_val v1 (typeof a) m = Some false) by (apply static_bool_val_sound; auto).\nreplace b with false by congruence.\nconstructor."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = Some false) : v = v1 ->\nstar step1 tge (State f s2 k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"v = v1 ->\nstar step1 tge (State f s2 k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = Some false)","proofString":"intro EQ; subst v.\nassert (bool_val v1 (typeof a) m = Some false) by (apply static_bool_val_sound; auto).\nreplace b with false by congruence.\nconstructor."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e1 : bool_val v1 (typeof a) Mem.empty = Some false) (e0 : eval_simpl_expr a = Some v1) : star step1 tge (State f s2 k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"star step1 tge (State f s2 k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e1 : bool_val v1 (typeof a) Mem.empty = Some false) (e0 : eval_simpl_expr a = Some v1)","proofString":"assert (bool_val v1 (typeof a) m = Some false) by (apply static_bool_val_sound; auto).\nreplace b with false by congruence.\nconstructor."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e1 : bool_val v1 (typeof a) Mem.empty = Some false) (e0 : eval_simpl_expr a = Some v1) (H1 : bool_val v1 (typeof a) m = Some false) : star step1 tge (State f s2 k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"star step1 tge (State f s2 k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e1 : bool_val v1 (typeof a) Mem.empty = Some false) (e0 : eval_simpl_expr a = Some v1) (H1 : bool_val v1 (typeof a) m = Some false)","proofString":"replace b with false by congruence.\nconstructor."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e1 : bool_val v1 (typeof a) Mem.empty = Some false) (e0 : eval_simpl_expr a = Some v1) (H1 : bool_val v1 (typeof a) m = Some false) : star step1 tge (State f s2 k e le m) E0 (State f s2 k e le m).","conclusion":"star step1 tge (State f s2 k e le m) E0 (State f s2 k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e1 : bool_val v1 (typeof a) Mem.empty = Some false) (e0 : eval_simpl_expr a = Some v1) (H1 : bool_val v1 (typeof a) m = Some false)","proofString":"constructor."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = None) : star step1 tge (State f (Sifthenelse a s1 s2) k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"star step1 tge (State f (Sifthenelse a s1 s2) k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = None)","proofString":"apply star_one.\neapply step_ifthenelse; eauto."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = None) : step1 tge (State f (Sifthenelse a s1 s2) k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"step1 tge (State f (Sifthenelse a s1 s2) k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (v : val) (e0 : eval_simpl_expr a = Some v) (e1 : bool_val v (typeof a) Mem.empty = None)","proofString":"eapply step_ifthenelse; eauto."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e0 : eval_simpl_expr a = None) : star step1 tge (State f (Sifthenelse a s1 s2) k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"star step1 tge (State f (Sifthenelse a s1 s2) k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e0 : eval_simpl_expr a = None)","proofString":"apply star_one.\neapply step_ifthenelse; eauto."},{"statement":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e0 : eval_simpl_expr a = None) : step1 tge (State f (Sifthenelse a s1 s2) k e le m) E0\n  (State f (if b then s1 else s2) k e le m).","conclusion":"step1 tge (State f (Sifthenelse a s1 s2) k e le m) E0\n  (State f (if b then s1 else s2) k e le m)","hypotheses":"(f : function) (a : expr) (s1 s2 : statement) (k : cont) (e : env) (le : temp_env) (m : mem) (v1 : val) (b : bool) (H : eval_expr tge e le m a v1) (H0 : bool_val v1 (typeof a) m = Some b) (e0 : eval_simpl_expr a = None)","proofString":"eapply step_ifthenelse; eauto."},{"statement":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) : step1 tge (State f (make_set bf id a) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m).","conclusion":"step1 tge (State f (make_set bf id a) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m)","hypotheses":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty)","proofString":"exploit deref_loc_translated; eauto.\nrewrite <- H1.\nunfold make_set.\ndestruct (chunk_for_volatile_type (typeof a) bf) as [chunk|].\nintros [A B].\nsubst bf.\nchange (PTree.set id v le) with (set_opttemp (Some id) v le).\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\nconstructor.\nsimpl.\neconstructor; eauto.\nintros [A B].\nsubst t.\nconstructor.\neapply eval_Elvalue; eauto."},{"statement":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) : match chunk_for_volatile_type ty bf with\n| Some chunk => bf = Full /\\ volatile_load tge chunk m b ofs t v\n| None => t = E0 /\\ deref_loc ty m b ofs bf v\nend ->\nstep1 tge (State f (make_set bf id a) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m).","conclusion":"match chunk_for_volatile_type ty bf with\n| Some chunk => bf = Full /\\ volatile_load tge chunk m b ofs t v\n| None => t = E0 /\\ deref_loc ty m b ofs bf v\nend ->\nstep1 tge (State f (make_set bf id a) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m)","hypotheses":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty)","proofString":"rewrite <- H1.\nunfold make_set.\ndestruct (chunk_for_volatile_type (typeof a) bf) as [chunk|].\nintros [A B].\nsubst bf.\nchange (PTree.set id v le) with (set_opttemp (Some id) v le).\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\nconstructor.\nsimpl.\neconstructor; eauto.\nintros [A B].\nsubst t.\nconstructor.\neapply eval_Elvalue; eauto."},{"statement":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) : match chunk_for_volatile_type (typeof a) bf with\n| Some chunk => bf = Full /\\ volatile_load tge chunk m b ofs t v\n| None => t = E0 /\\ deref_loc (typeof a) m b ofs bf v\nend ->\nstep1 tge (State f (make_set bf id a) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m).","conclusion":"match chunk_for_volatile_type (typeof a) bf with\n| Some chunk => bf = Full /\\ volatile_load tge chunk m b ofs t v\n| None => t = E0 /\\ deref_loc (typeof a) m b ofs bf v\nend ->\nstep1 tge (State f (make_set bf id a) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m)","hypotheses":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty)","proofString":"unfold make_set.\ndestruct (chunk_for_volatile_type (typeof a) bf) as [chunk|].\nintros [A B].\nsubst bf.\nchange (PTree.set id v le) with (set_opttemp (Some id) v le).\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\nconstructor.\nsimpl.\neconstructor; eauto.\nintros [A B].\nsubst t.\nconstructor.\neapply eval_Elvalue; eauto."},{"statement":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) : match chunk_for_volatile_type (typeof a) bf with\n| Some chunk => bf = Full /\\ volatile_load tge chunk m b ofs t v\n| None => t = E0 /\\ deref_loc (typeof a) m b ofs bf v\nend ->\nstep1 tge\n  (State f\n     match chunk_for_volatile_type (typeof a) bf with\n     | Some chunk =>\n         Sbuiltin (Some id) (EF_vload chunk)\n           (Tpointer (typeof a) noattr :: nil)\n           (Eaddrof a (Tpointer (typeof a) noattr) :: nil)\n     | None => Sset id a\n     end k e le m) t (State f Sskip k e (PTree.set id v le) m).","conclusion":"match chunk_for_volatile_type (typeof a) bf with\n| Some chunk => bf = Full /\\ volatile_load tge chunk m b ofs t v\n| None => t = E0 /\\ deref_loc (typeof a) m b ofs bf v\nend ->\nstep1 tge\n  (State f\n     match chunk_for_volatile_type (typeof a) bf with\n     | Some chunk =>\n         Sbuiltin (Some id) (EF_vload chunk)\n           (Tpointer (typeof a) noattr :: nil)\n           (Eaddrof a (Tpointer (typeof a) noattr) :: nil)\n     | None => Sset id a\n     end k e le m) t (State f Sskip k e (PTree.set id v le) m)","hypotheses":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty)","proofString":"destruct (chunk_for_volatile_type (typeof a) bf) as [chunk|].\nintros [A B].\nsubst bf.\nchange (PTree.set id v le) with (set_opttemp (Some id) v le).\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\nconstructor.\nsimpl.\neconstructor; eauto.\nintros [A B].\nsubst t.\nconstructor.\neapply eval_Elvalue; eauto."},{"statement":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) (chunk : memory_chunk) : bf = Full /\\ volatile_load tge chunk m b ofs t v ->\nstep1 tge\n  (State f\n     (Sbuiltin (Some id) (EF_vload chunk) (Tpointer (typeof a) noattr :: nil)\n        (Eaddrof a (Tpointer (typeof a) noattr) :: nil)) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m).","conclusion":"bf = Full /\\ volatile_load tge chunk m b ofs t v ->\nstep1 tge\n  (State f\n     (Sbuiltin (Some id) (EF_vload chunk) (Tpointer (typeof a) noattr :: nil)\n        (Eaddrof a (Tpointer (typeof a) noattr) :: nil)) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m)","hypotheses":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) (chunk : memory_chunk)","proofString":"intros [A B].\nsubst bf.\nchange (PTree.set id v le) with (set_opttemp (Some id) v le).\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\nconstructor.\nsimpl.\neconstructor; eauto."},{"statement":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) (chunk : memory_chunk) (A : bf = Full) (B : volatile_load tge chunk m b ofs t v) : step1 tge\n  (State f\n     (Sbuiltin (Some id) (EF_vload chunk) (Tpointer (typeof a) noattr :: nil)\n        (Eaddrof a (Tpointer (typeof a) noattr) :: nil)) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m).","conclusion":"step1 tge\n  (State f\n     (Sbuiltin (Some id) (EF_vload chunk) (Tpointer (typeof a) noattr :: nil)\n        (Eaddrof a (Tpointer (typeof a) noattr) :: nil)) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m)","hypotheses":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) (chunk : memory_chunk) (A : bf = Full) (B : volatile_load tge chunk m b ofs t v)","proofString":"subst bf.\nchange (PTree.set id v le) with (set_opttemp (Some id) v le).\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\nconstructor.\nsimpl.\neconstructor; eauto."},{"statement":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a b ofs Full) (H : Csem.deref_loc ge ty m b ofs Full t v) (H1 : typeof a = ty) (chunk : memory_chunk) (B : volatile_load tge chunk m b ofs t v) : step1 tge\n  (State f\n     (Sbuiltin (Some id) (EF_vload chunk) (Tpointer (typeof a) noattr :: nil)\n        (Eaddrof a (Tpointer (typeof a) noattr) :: nil)) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m).","conclusion":"step1 tge\n  (State f\n     (Sbuiltin (Some id) (EF_vload chunk) (Tpointer (typeof a) noattr :: nil)\n        (Eaddrof a (Tpointer (typeof a) noattr) :: nil)) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m)","hypotheses":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a b ofs Full) (H : Csem.deref_loc ge ty m b ofs Full t v) (H1 : typeof a = ty) (chunk : memory_chunk) (B : volatile_load tge chunk m b ofs t v)","proofString":"change (PTree.set id v le) with (set_opttemp (Some id) v le).\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\nconstructor.\nsimpl.\neconstructor; eauto."},{"statement":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a b ofs Full) (H : Csem.deref_loc ge ty m b ofs Full t v) (H1 : typeof a = ty) (chunk : memory_chunk) (B : volatile_load tge chunk m b ofs t v) : step1 tge\n  (State f\n     (Sbuiltin (Some id) (EF_vload chunk) (Tpointer (typeof a) noattr :: nil)\n        (Eaddrof a (Tpointer (typeof a) noattr) :: nil)) k e le m) t\n  (State f Sskip k e (set_opttemp (Some id) v le) m).","conclusion":"step1 tge\n  (State f\n     (Sbuiltin (Some id) (EF_vload chunk) (Tpointer (typeof a) noattr :: nil)\n        (Eaddrof a (Tpointer (typeof a) noattr) :: nil)) k e le m) t\n  (State f Sskip k e (set_opttemp (Some id) v le) m)","hypotheses":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a b ofs Full) (H : Csem.deref_loc ge ty m b ofs Full t v) (H1 : typeof a = ty) (chunk : memory_chunk) (B : volatile_load tge chunk m b ofs t v)","proofString":"econstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\nconstructor.\nsimpl.\neconstructor; eauto."},{"statement":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a b ofs Full) (H : Csem.deref_loc ge ty m b ofs Full t v) (H1 : typeof a = ty) (chunk : memory_chunk) (B : volatile_load tge chunk m b ofs t v) : volatile_load_sem chunk (Genv.globalenv tprog) (Vptr b ofs :: nil) m t v m.","conclusion":"volatile_load_sem chunk (Genv.globalenv tprog) (Vptr b ofs :: nil) m t v m","hypotheses":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a b ofs Full) (H : Csem.deref_loc ge ty m b ofs Full t v) (H1 : typeof a = ty) (chunk : memory_chunk) (B : volatile_load tge chunk m b ofs t v)","proofString":"econstructor; eauto."},{"statement":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) : t = E0 /\\ deref_loc (typeof a) m b ofs bf v ->\nstep1 tge (State f (Sset id a) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m).","conclusion":"t = E0 /\\ deref_loc (typeof a) m b ofs bf v ->\nstep1 tge (State f (Sset id a) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m)","hypotheses":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty)","proofString":"intros [A B].\nsubst t.\nconstructor.\neapply eval_Elvalue; eauto."},{"statement":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) (A : t = E0) (B : deref_loc (typeof a) m b ofs bf v) : step1 tge (State f (Sset id a) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m).","conclusion":"step1 tge (State f (Sset id a) k e le m) t\n  (State f Sskip k e (PTree.set id v le) m)","hypotheses":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) (A : t = E0) (B : deref_loc (typeof a) m b ofs bf v)","proofString":"subst t.\nconstructor.\neapply eval_Elvalue; eauto."},{"statement":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf E0 v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) (B : deref_loc (typeof a) m b ofs bf v) : step1 tge (State f (Sset id a) k e le m) E0\n  (State f Sskip k e (PTree.set id v le) m).","conclusion":"step1 tge (State f (Sset id a) k e le m) E0\n  (State f Sskip k e (PTree.set id v le) m)","hypotheses":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf E0 v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) (B : deref_loc (typeof a) m b ofs bf v)","proofString":"constructor.\neapply eval_Elvalue; eauto."},{"statement":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf E0 v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) (B : deref_loc (typeof a) m b ofs bf v) : eval_expr tge e le m a v.","conclusion":"eval_expr tge e le m a v","hypotheses":"(id : ident) (a : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf E0 v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : typeof a = ty) (B : deref_loc (typeof a) m b ofs bf v)","proofString":"eapply eval_Elvalue; eauto."},{"statement":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) : step1 tge (State f (make_assign bf a1 a2) k e le m) t\n  (State f Sskip k e le m').","conclusion":"step1 tge (State f (make_assign bf a1 a2) k e le m) t\n  (State f Sskip k e le m')","hypotheses":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty)","proofString":"exploit assign_loc_translated; eauto.\nrewrite <- H3.\nunfold make_assign.\ndestruct (chunk_for_volatile_type (typeof a1) bf) as [chunk|].\nintros [A B].\nsubst bf.\nchange le with (set_opttemp None Vundef le) at 2.\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\neconstructor; eauto.\nrewrite H3; eauto.\nconstructor.\nsimpl.\neconstructor; eauto.\nintros [A B].\nsubst t.\neconstructor; eauto.\ncongruence."},{"statement":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) : match chunk_for_volatile_type ty bf with\n| Some chunk => bf = Full /\\ volatile_store tge chunk m b ofs v t m'\n| None => t = E0 /\\ assign_loc tge ty m b ofs bf v m'\nend ->\nstep1 tge (State f (make_assign bf a1 a2) k e le m) t\n  (State f Sskip k e le m').","conclusion":"match chunk_for_volatile_type ty bf with\n| Some chunk => bf = Full /\\ volatile_store tge chunk m b ofs v t m'\n| None => t = E0 /\\ assign_loc tge ty m b ofs bf v m'\nend ->\nstep1 tge (State f (make_assign bf a1 a2) k e le m) t\n  (State f Sskip k e le m')","hypotheses":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty)","proofString":"rewrite <- H3.\nunfold make_assign.\ndestruct (chunk_for_volatile_type (typeof a1) bf) as [chunk|].\nintros [A B].\nsubst bf.\nchange le with (set_opttemp None Vundef le) at 2.\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\neconstructor; eauto.\nrewrite H3; eauto.\nconstructor.\nsimpl.\neconstructor; eauto.\nintros [A B].\nsubst t.\neconstructor; eauto.\ncongruence."},{"statement":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) : match chunk_for_volatile_type (typeof a1) bf with\n| Some chunk => bf = Full /\\ volatile_store tge chunk m b ofs v t m'\n| None => t = E0 /\\ assign_loc tge (typeof a1) m b ofs bf v m'\nend ->\nstep1 tge (State f (make_assign bf a1 a2) k e le m) t\n  (State f Sskip k e le m').","conclusion":"match chunk_for_volatile_type (typeof a1) bf with\n| Some chunk => bf = Full /\\ volatile_store tge chunk m b ofs v t m'\n| None => t = E0 /\\ assign_loc tge (typeof a1) m b ofs bf v m'\nend ->\nstep1 tge (State f (make_assign bf a1 a2) k e le m) t\n  (State f Sskip k e le m')","hypotheses":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty)","proofString":"unfold make_assign.\ndestruct (chunk_for_volatile_type (typeof a1) bf) as [chunk|].\nintros [A B].\nsubst bf.\nchange le with (set_opttemp None Vundef le) at 2.\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\neconstructor; eauto.\nrewrite H3; eauto.\nconstructor.\nsimpl.\neconstructor; eauto.\nintros [A B].\nsubst t.\neconstructor; eauto.\ncongruence."},{"statement":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) : match chunk_for_volatile_type (typeof a1) bf with\n| Some chunk => bf = Full /\\ volatile_store tge chunk m b ofs v t m'\n| None => t = E0 /\\ assign_loc tge (typeof a1) m b ofs bf v m'\nend ->\nstep1 tge\n  (State f\n     match chunk_for_volatile_type (typeof a1) bf with\n     | Some chunk =>\n         Sbuiltin None (EF_vstore chunk)\n           (Tpointer (typeof a1) noattr :: typeof a1 :: nil)\n           (Eaddrof a1 (Tpointer (typeof a1) noattr) :: a2 :: nil)\n     | None => Sassign a1 a2\n     end k e le m) t (State f Sskip k e le m').","conclusion":"match chunk_for_volatile_type (typeof a1) bf with\n| Some chunk => bf = Full /\\ volatile_store tge chunk m b ofs v t m'\n| None => t = E0 /\\ assign_loc tge (typeof a1) m b ofs bf v m'\nend ->\nstep1 tge\n  (State f\n     match chunk_for_volatile_type (typeof a1) bf with\n     | Some chunk =>\n         Sbuiltin None (EF_vstore chunk)\n           (Tpointer (typeof a1) noattr :: typeof a1 :: nil)\n           (Eaddrof a1 (Tpointer (typeof a1) noattr) :: a2 :: nil)\n     | None => Sassign a1 a2\n     end k e le m) t (State f Sskip k e le m')","hypotheses":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty)","proofString":"destruct (chunk_for_volatile_type (typeof a1) bf) as [chunk|].\nintros [A B].\nsubst bf.\nchange le with (set_opttemp None Vundef le) at 2.\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\neconstructor; eauto.\nrewrite H3; eauto.\nconstructor.\nsimpl.\neconstructor; eauto.\nintros [A B].\nsubst t.\neconstructor; eauto.\ncongruence."},{"statement":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (chunk : memory_chunk) : bf = Full /\\ volatile_store tge chunk m b ofs v t m' ->\nstep1 tge\n  (State f\n     (Sbuiltin None (EF_vstore chunk)\n        (Tpointer (typeof a1) noattr :: typeof a1 :: nil)\n        (Eaddrof a1 (Tpointer (typeof a1) noattr) :: a2 :: nil)) k e le m) t\n  (State f Sskip k e le m').","conclusion":"bf = Full /\\ volatile_store tge chunk m b ofs v t m' ->\nstep1 tge\n  (State f\n     (Sbuiltin None (EF_vstore chunk)\n        (Tpointer (typeof a1) noattr :: typeof a1 :: nil)\n        (Eaddrof a1 (Tpointer (typeof a1) noattr) :: a2 :: nil)) k e le m) t\n  (State f Sskip k e le m')","hypotheses":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (chunk : memory_chunk)","proofString":"intros [A B].\nsubst bf.\nchange le with (set_opttemp None Vundef le) at 2.\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\neconstructor; eauto.\nrewrite H3; eauto.\nconstructor.\nsimpl.\neconstructor; eauto."},{"statement":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (chunk : memory_chunk) (A : bf = Full) (B : volatile_store tge chunk m b ofs v t m') : step1 tge\n  (State f\n     (Sbuiltin None (EF_vstore chunk)\n        (Tpointer (typeof a1) noattr :: typeof a1 :: nil)\n        (Eaddrof a1 (Tpointer (typeof a1) noattr) :: a2 :: nil)) k e le m) t\n  (State f Sskip k e le m').","conclusion":"step1 tge\n  (State f\n     (Sbuiltin None (EF_vstore chunk)\n        (Tpointer (typeof a1) noattr :: typeof a1 :: nil)\n        (Eaddrof a1 (Tpointer (typeof a1) noattr) :: a2 :: nil)) k e le m) t\n  (State f Sskip k e le m')","hypotheses":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (chunk : memory_chunk) (A : bf = Full) (B : volatile_store tge chunk m b ofs v t m')","proofString":"subst bf.\nchange le with (set_opttemp None Vundef le) at 2.\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\neconstructor; eauto.\nrewrite H3; eauto.\nconstructor.\nsimpl.\neconstructor; eauto."},{"statement":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a1 b ofs Full) (H : Csem.assign_loc ge ty m b ofs Full v t m' v') (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (chunk : memory_chunk) (B : volatile_store tge chunk m b ofs v t m') : step1 tge\n  (State f\n     (Sbuiltin None (EF_vstore chunk)\n        (Tpointer (typeof a1) noattr :: typeof a1 :: nil)\n        (Eaddrof a1 (Tpointer (typeof a1) noattr) :: a2 :: nil)) k e le m) t\n  (State f Sskip k e le m').","conclusion":"step1 tge\n  (State f\n     (Sbuiltin None (EF_vstore chunk)\n        (Tpointer (typeof a1) noattr :: typeof a1 :: nil)\n        (Eaddrof a1 (Tpointer (typeof a1) noattr) :: a2 :: nil)) k e le m) t\n  (State f Sskip k e le m')","hypotheses":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a1 b ofs Full) (H : Csem.assign_loc ge ty m b ofs Full v t m' v') (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (chunk : memory_chunk) (B : volatile_store tge chunk m b ofs v t m')","proofString":"change le with (set_opttemp None Vundef le) at 2.\neconstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\neconstructor; eauto.\nrewrite H3; eauto.\nconstructor.\nsimpl.\neconstructor; eauto."},{"statement":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a1 b ofs Full) (H : Csem.assign_loc ge ty m b ofs Full v t m' v') (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (chunk : memory_chunk) (B : volatile_store tge chunk m b ofs v t m') : step1 tge\n  (State f\n     (Sbuiltin None (EF_vstore chunk)\n        (Tpointer (typeof a1) noattr :: typeof a1 :: nil)\n        (Eaddrof a1 (Tpointer (typeof a1) noattr) :: a2 :: nil)) k e le m) t\n  (State f Sskip k e (set_opttemp None Vundef le) m').","conclusion":"step1 tge\n  (State f\n     (Sbuiltin None (EF_vstore chunk)\n        (Tpointer (typeof a1) noattr :: typeof a1 :: nil)\n        (Eaddrof a1 (Tpointer (typeof a1) noattr) :: a2 :: nil)) k e le m) t\n  (State f Sskip k e (set_opttemp None Vundef le) m')","hypotheses":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a1 b ofs Full) (H : Csem.assign_loc ge ty m b ofs Full v t m' v') (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (chunk : memory_chunk) (B : volatile_store tge chunk m b ofs v t m')","proofString":"econstructor.\neconstructor.\nconstructor.\neauto.\nsimpl.\nunfold sem_cast.\nsimpl.\neauto.\neconstructor; eauto.\nrewrite H3; eauto.\nconstructor.\nsimpl.\neconstructor; eauto."},{"statement":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a1 b ofs Full) (H : Csem.assign_loc ge ty m b ofs Full v t m' v') (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (chunk : memory_chunk) (B : volatile_store tge chunk m b ofs v t m') : volatile_store_sem chunk (Genv.globalenv tprog) (Vptr b ofs :: v :: nil) m t\n  Vundef m'.","conclusion":"volatile_store_sem chunk (Genv.globalenv tprog) (Vptr b ofs :: v :: nil) m t\n  Vundef m'","hypotheses":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a1 b ofs Full) (H : Csem.assign_loc ge ty m b ofs Full v t m' v') (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (chunk : memory_chunk) (B : volatile_store tge chunk m b ofs v t m')","proofString":"econstructor; eauto."},{"statement":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) : t = E0 /\\ assign_loc tge (typeof a1) m b ofs bf v m' ->\nstep1 tge (State f (Sassign a1 a2) k e le m) t (State f Sskip k e le m').","conclusion":"t = E0 /\\ assign_loc tge (typeof a1) m b ofs bf v m' ->\nstep1 tge (State f (Sassign a1 a2) k e le m) t (State f Sskip k e le m')","hypotheses":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty)","proofString":"intros [A B].\nsubst t.\neconstructor; eauto.\ncongruence."},{"statement":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (A : t = E0) (B : assign_loc tge (typeof a1) m b ofs bf v m') : step1 tge (State f (Sassign a1 a2) k e le m) t (State f Sskip k e le m').","conclusion":"step1 tge (State f (Sassign a1 a2) k e le m) t (State f Sskip k e le m')","hypotheses":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v t m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (A : t = E0) (B : assign_loc tge (typeof a1) m b ofs bf v m')","proofString":"subst t.\neconstructor; eauto.\ncongruence."},{"statement":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v E0 m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (B : assign_loc tge (typeof a1) m b ofs bf v m') : step1 tge (State f (Sassign a1 a2) k e le m) E0 (State f Sskip k e le m').","conclusion":"step1 tge (State f (Sassign a1 a2) k e le m) E0 (State f Sskip k e le m')","hypotheses":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v E0 m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (B : assign_loc tge (typeof a1) m b ofs bf v m')","proofString":"econstructor; eauto.\ncongruence."},{"statement":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v E0 m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (B : assign_loc tge (typeof a1) m b ofs bf v m') : sem_cast v2 (typeof a2) (typeof a1) m = Some v.","conclusion":"sem_cast v2 (typeof a2) (typeof a1) m = Some v","hypotheses":"(a1 a2 : expr) (ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (m' : mem) (v' v2 : val) (e : env) (le : temp_env) (f : function) (k : cont) (H : Csem.assign_loc ge ty m b ofs bf v E0 m' v') (H0 : eval_lvalue tge e le m a1 b ofs bf) (H1 : eval_expr tge e le m a2 v2) (H2 : sem_cast v2 (typeof a2) ty m = Some v) (H3 : typeof a1 = ty) (B : assign_loc tge (typeof a1) m b ofs bf v m')","proofString":"congruence."},{"statement":"(f : function) (sl : list statement) (k : cont) (e : env) (le : temp_env) (m : mem) : star step1 tge (State f (makeseq sl) k e le m) E0\n  (State f Sskip (Kseqlist sl k) e le m).","conclusion":"star step1 tge (State f (makeseq sl) k e le m) E0\n  (State f Sskip (Kseqlist sl k) e le m)","hypotheses":"(f : function) (sl : list statement) (k : cont) (e : env) (le : temp_env) (m : mem)","proofString":"unfold makeseq.\ngeneralize Sskip.\nrevert sl k.\ninduction sl; simpl; intros.\napply star_refl.\neapply star_right.\napply IHsl.\nconstructor.\ntraceEq."},{"statement":"(f : function) (sl : list statement) (k : cont) (e : env) (le : temp_env) (m : mem) : star step1 tge (State f (makeseq_rec Sskip sl) k e le m) E0\n  (State f Sskip (Kseqlist sl k) e le m).","conclusion":"star step1 tge (State f (makeseq_rec Sskip sl) k e le m) E0\n  (State f Sskip (Kseqlist sl k) e le m)","hypotheses":"(f : function) (sl : list statement) (k : cont) (e : env) (le : temp_env) (m : mem)","proofString":"generalize Sskip.\nrevert sl k.\ninduction sl; simpl; intros.\napply star_refl.\neapply star_right.\napply IHsl.\nconstructor.\ntraceEq."},{"statement":"(f : function) (sl : list statement) (k : cont) (e : env) (le : temp_env) (m : mem) : forall s : statement,\nstar step1 tge (State f (makeseq_rec s sl) k e le m) E0\n  (State f s (Kseqlist sl k) e le m).","conclusion":"forall s : statement,\nstar step1 tge (State f (makeseq_rec s sl) k e le m) E0\n  (State f s (Kseqlist sl k) e le m)","hypotheses":"(f : function) (sl : list statement) (k : cont) (e : env) (le : temp_env) (m : mem)","proofString":"revert sl k.\ninduction sl; simpl; intros.\napply star_refl.\neapply star_right.\napply IHsl.\nconstructor.\ntraceEq."},{"statement":"(f : function) (e : env) (le : temp_env) (m : mem) : forall (sl : list statement) (k : cont) (s : statement),\nstar step1 tge (State f (makeseq_rec s sl) k e le m) E0\n  (State f s (Kseqlist sl k) e le m).","conclusion":"forall (sl : list statement) (k : cont) (s : statement),\nstar step1 tge (State f (makeseq_rec s sl) k e le m) E0\n  (State f s (Kseqlist sl k) e le m)","hypotheses":"(f : function) (e : env) (le : temp_env) (m : mem)","proofString":"induction sl; simpl; intros.\napply star_refl.\neapply star_right.\napply IHsl.\nconstructor.\ntraceEq."},{"statement":"(f : function) (e : env) (le : temp_env) (m : mem) (k : cont) (s : statement) : star step1 tge (State f s k e le m) E0 (State f s k e le m).","conclusion":"star step1 tge (State f s k e le m) E0 (State f s k e le m)","hypotheses":"(f : function) (e : env) (le : temp_env) (m : mem) (k : cont) (s : statement)","proofString":"apply star_refl."},{"statement":"(f : function) (e : env) (le : temp_env) (m : mem) (a : statement) (sl : list statement) (IHsl : forall (k0 : cont) (s0 : statement),\nstar step1 tge (State f (makeseq_rec s0 sl) k0 e le m) E0\n  (State f s0 (Kseqlist sl k0) e le m)) (k : cont) (s : statement) : star step1 tge (State f (makeseq_rec (Ssequence s a) sl) k e le m) E0\n  (State f s (Kseq a (Kseqlist sl k)) e le m).","conclusion":"star step1 tge (State f (makeseq_rec (Ssequence s a) sl) k e le m) E0\n  (State f s (Kseq a (Kseqlist sl k)) e le m)","hypotheses":"(f : function) (e : env) (le : temp_env) (m : mem) (a : statement) (sl : list statement) (IHsl : forall (k0 : cont) (s0 : statement),\nstar step1 tge (State f (makeseq_rec s0 sl) k0 e le m) E0\n  (State f s0 (Kseqlist sl k0) e le m)) (k : cont) (s : statement)","proofString":"eapply star_right.\napply IHsl.\nconstructor.\ntraceEq."},{"statement":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (sl : list statement) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : tr_rvalof ce ty a sl a' tmp) (H2 : typeof a = ty) : exists le' : temp_env,\n  star step1 tge (State f Sskip (Kseqlist sl k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m a' v /\\\n  typeof a' = typeof a /\\ (forall x : ident, ~ In x tmp -> le' ! x = le ! x).","conclusion":"exists le' : temp_env,\n  star step1 tge (State f Sskip (Kseqlist sl k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m a' v /\\\n  typeof a' = typeof a /\\ (forall x : ident, ~ In x tmp -> le' ! x = le ! x)","hypotheses":"(ty : type) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (sl : list statement) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge ty m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (H1 : tr_rvalof ce ty a sl a' tmp) (H2 : typeof a = ty)","proofString":"inv H1.\nexploit deref_loc_translated; eauto.\nunfold chunk_for_volatile_type; rewrite H3.\nintros [A B].\nsubst t.\nexists le; split.\napply star_refl.\nsplit.\neapply eval_Elvalue; eauto.\nauto.\nintros.\nexploit is_bitfield_access_sound; eauto.\nintros EQ; subst bf0.\nexists (PTree.set t0 v le); split.\nsimpl.\neapply star_two.\neconstructor.\neapply step_make_set; eauto.\ntraceEq.\nsplit.\nconstructor.\napply PTree.gss.\nsplit.\nauto.\nintros.\napply PTree.gso.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf t v) (H3 : type_is_volatile (typeof a') = false) : exists le' : temp_env,\n  star step1 tge (State f Sskip (Kseqlist nil k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m a' v /\\\n  typeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le' ! x = le ! x).","conclusion":"exists le' : temp_env,\n  star step1 tge (State f Sskip (Kseqlist nil k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m a' v /\\\n  typeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le' ! x = le ! x)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf t v) (H3 : type_is_volatile (typeof a') = false)","proofString":"exploit deref_loc_translated; eauto.\nunfold chunk_for_volatile_type; rewrite H3.\nintros [A B].\nsubst t.\nexists le; split.\napply star_refl.\nsplit.\neapply eval_Elvalue; eauto.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf t v) (H3 : type_is_volatile (typeof a') = false) : match chunk_for_volatile_type (typeof a') bf with\n| Some chunk => bf = Full /\\ volatile_load tge chunk m b ofs t v\n| None => t = E0 /\\ deref_loc (typeof a') m b ofs bf v\nend ->\nexists le' : temp_env,\n  star step1 tge (State f Sskip (Kseqlist nil k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m a' v /\\\n  typeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le' ! x = le ! x).","conclusion":"match chunk_for_volatile_type (typeof a') bf with\n| Some chunk => bf = Full /\\ volatile_load tge chunk m b ofs t v\n| None => t = E0 /\\ deref_loc (typeof a') m b ofs bf v\nend ->\nexists le' : temp_env,\n  star step1 tge (State f Sskip (Kseqlist nil k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m a' v /\\\n  typeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le' ! x = le ! x)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf t v) (H3 : type_is_volatile (typeof a') = false)","proofString":"unfold chunk_for_volatile_type; rewrite H3.\nintros [A B].\nsubst t.\nexists le; split.\napply star_refl.\nsplit.\neapply eval_Elvalue; eauto.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf t v) (H3 : type_is_volatile (typeof a') = false) : t = E0 /\\ deref_loc (typeof a') m b ofs bf v ->\nexists le' : temp_env,\n  star step1 tge (State f Sskip (Kseqlist nil k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m a' v /\\\n  typeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le' ! x = le ! x).","conclusion":"t = E0 /\\ deref_loc (typeof a') m b ofs bf v ->\nexists le' : temp_env,\n  star step1 tge (State f Sskip (Kseqlist nil k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m a' v /\\\n  typeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le' ! x = le ! x)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf t v) (H3 : type_is_volatile (typeof a') = false)","proofString":"intros [A B].\nsubst t.\nexists le; split.\napply star_refl.\nsplit.\neapply eval_Elvalue; eauto.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf t v) (H3 : type_is_volatile (typeof a') = false) (A : t = E0) (B : deref_loc (typeof a') m b ofs bf v) : exists le' : temp_env,\n  star step1 tge (State f Sskip (Kseqlist nil k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m a' v /\\\n  typeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le' ! x = le ! x).","conclusion":"exists le' : temp_env,\n  star step1 tge (State f Sskip (Kseqlist nil k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m a' v /\\\n  typeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le' ! x = le ! x)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf t v) (H3 : type_is_volatile (typeof a') = false) (A : t = E0) (B : deref_loc (typeof a') m b ofs bf v)","proofString":"subst t.\nexists le; split.\napply star_refl.\nsplit.\neapply eval_Elvalue; eauto.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf E0 v) (H3 : type_is_volatile (typeof a') = false) (B : deref_loc (typeof a') m b ofs bf v) : exists le' : temp_env,\n  star step1 tge (State f Sskip (Kseqlist nil k) e le m) E0\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m a' v /\\\n  typeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le' ! x = le ! x).","conclusion":"exists le' : temp_env,\n  star step1 tge (State f Sskip (Kseqlist nil k) e le m) E0\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m a' v /\\\n  typeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le' ! x = le ! x)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf E0 v) (H3 : type_is_volatile (typeof a') = false) (B : deref_loc (typeof a') m b ofs bf v)","proofString":"exists le; split.\napply star_refl.\nsplit.\neapply eval_Elvalue; eauto.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf E0 v) (H3 : type_is_volatile (typeof a') = false) (B : deref_loc (typeof a') m b ofs bf v) : star step1 tge (State f Sskip (Kseqlist nil k) e le m) E0\n  (State f Sskip k e le m).","conclusion":"star step1 tge (State f Sskip (Kseqlist nil k) e le m) E0\n  (State f Sskip k e le m)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf E0 v) (H3 : type_is_volatile (typeof a') = false) (B : deref_loc (typeof a') m b ofs bf v)","proofString":"apply star_refl."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf E0 v) (H3 : type_is_volatile (typeof a') = false) (B : deref_loc (typeof a') m b ofs bf v) : eval_expr tge e le m a' v /\\\ntypeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le ! x = le ! x).","conclusion":"eval_expr tge e le m a' v /\\\ntypeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le ! x = le ! x)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf E0 v) (H3 : type_is_volatile (typeof a') = false) (B : deref_loc (typeof a') m b ofs bf v)","proofString":"split.\neapply eval_Elvalue; eauto.\nauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf E0 v) (H3 : type_is_volatile (typeof a') = false) (B : deref_loc (typeof a') m b ofs bf v) : eval_expr tge e le m a' v.","conclusion":"eval_expr tge e le m a' v","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf E0 v) (H3 : type_is_volatile (typeof a') = false) (B : deref_loc (typeof a') m b ofs bf v)","proofString":"eapply eval_Elvalue; eauto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf E0 v) (H3 : type_is_volatile (typeof a') = false) (B : deref_loc (typeof a') m b ofs bf v) : typeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le ! x = le ! x).","conclusion":"typeof a' = typeof a' /\\ (forall x : ident, ~ In x tmp -> le ! x = le ! x)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v : val) (e : env) (le : temp_env) (a' : expr) (tmp : list ident) (f : function) (k : cont) (H0 : eval_lvalue tge e le m a' b ofs bf) (H : Csem.deref_loc ge (typeof a') m b ofs bf E0 v) (H3 : type_is_volatile (typeof a') = false) (B : deref_loc (typeof a') m b ofs bf v)","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (bf0 : bitfield) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf0) : exists le' : temp_env,\n  star step1 tge\n    (State f Sskip (Kseqlist (make_set bf0 t0 a :: nil) k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m (Etempvar t0 (typeof a)) v /\\\n  typeof (Etempvar t0 (typeof a)) = typeof a /\\\n  (forall x : ident, ~ In x tmp -> le' ! x = le ! x).","conclusion":"exists le' : temp_env,\n  star step1 tge\n    (State f Sskip (Kseqlist (make_set bf0 t0 a :: nil) k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m (Etempvar t0 (typeof a)) v /\\\n  typeof (Etempvar t0 (typeof a)) = typeof a /\\\n  (forall x : ident, ~ In x tmp -> le' ! x = le ! x)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (bf0 : bitfield) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf0)","proofString":"intros.\nexploit is_bitfield_access_sound; eauto.\nintros EQ; subst bf0.\nexists (PTree.set t0 v le); split.\nsimpl.\neapply star_two.\neconstructor.\neapply step_make_set; eauto.\ntraceEq.\nsplit.\nconstructor.\napply PTree.gss.\nsplit.\nauto.\nintros.\napply PTree.gso.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (bf0 : bitfield) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf0) : exists le' : temp_env,\n  star step1 tge\n    (State f Sskip (Kseqlist (make_set bf0 t0 a :: nil) k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m (Etempvar t0 (typeof a)) v /\\\n  typeof (Etempvar t0 (typeof a)) = typeof a /\\\n  (forall x : ident, ~ In x tmp -> le' ! x = le ! x).","conclusion":"exists le' : temp_env,\n  star step1 tge\n    (State f Sskip (Kseqlist (make_set bf0 t0 a :: nil) k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m (Etempvar t0 (typeof a)) v /\\\n  typeof (Etempvar t0 (typeof a)) = typeof a /\\\n  (forall x : ident, ~ In x tmp -> le' ! x = le ! x)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (bf0 : bitfield) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf0)","proofString":"exploit is_bitfield_access_sound; eauto.\nintros EQ; subst bf0.\nexists (PTree.set t0 v le); split.\nsimpl.\neapply star_two.\neconstructor.\neapply step_make_set; eauto.\ntraceEq.\nsplit.\nconstructor.\napply PTree.gss.\nsplit.\nauto.\nintros.\napply PTree.gso.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (bf0 : bitfield) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf0) : bf0 = bf ->\nexists le' : temp_env,\n  star step1 tge\n    (State f Sskip (Kseqlist (make_set bf0 t0 a :: nil) k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m (Etempvar t0 (typeof a)) v /\\\n  typeof (Etempvar t0 (typeof a)) = typeof a /\\\n  (forall x : ident, ~ In x tmp -> le' ! x = le ! x).","conclusion":"bf0 = bf ->\nexists le' : temp_env,\n  star step1 tge\n    (State f Sskip (Kseqlist (make_set bf0 t0 a :: nil) k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m (Etempvar t0 (typeof a)) v /\\\n  typeof (Etempvar t0 (typeof a)) = typeof a /\\\n  (forall x : ident, ~ In x tmp -> le' ! x = le ! x)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (bf0 : bitfield) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf0)","proofString":"intros EQ; subst bf0.\nexists (PTree.set t0 v le); split.\nsimpl.\neapply star_two.\neconstructor.\neapply step_make_set; eauto.\ntraceEq.\nsplit.\nconstructor.\napply PTree.gss.\nsplit.\nauto.\nintros.\napply PTree.gso.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf) : exists le' : temp_env,\n  star step1 tge\n    (State f Sskip (Kseqlist (make_set bf t0 a :: nil) k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m (Etempvar t0 (typeof a)) v /\\\n  typeof (Etempvar t0 (typeof a)) = typeof a /\\\n  (forall x : ident, ~ In x tmp -> le' ! x = le ! x).","conclusion":"exists le' : temp_env,\n  star step1 tge\n    (State f Sskip (Kseqlist (make_set bf t0 a :: nil) k) e le m) t\n    (State f Sskip k e le' m) /\\\n  eval_expr tge e le' m (Etempvar t0 (typeof a)) v /\\\n  typeof (Etempvar t0 (typeof a)) = typeof a /\\\n  (forall x : ident, ~ In x tmp -> le' ! x = le ! x)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf)","proofString":"exists (PTree.set t0 v le); split.\nsimpl.\neapply star_two.\neconstructor.\neapply step_make_set; eauto.\ntraceEq.\nsplit.\nconstructor.\napply PTree.gss.\nsplit.\nauto.\nintros.\napply PTree.gso.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf) : star step1 tge (State f Sskip (Kseqlist (make_set bf t0 a :: nil) k) e le m)\n  t (State f Sskip k e (PTree.set t0 v le) m).","conclusion":"star step1 tge (State f Sskip (Kseqlist (make_set bf t0 a :: nil) k) e le m)\n  t (State f Sskip k e (PTree.set t0 v le) m)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf)","proofString":"simpl.\neapply star_two.\neconstructor.\neapply step_make_set; eauto.\ntraceEq."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf) : star step1 tge (State f Sskip (Kseq (make_set bf t0 a) k) e le m) t\n  (State f Sskip k e (PTree.set t0 v le) m).","conclusion":"star step1 tge (State f Sskip (Kseq (make_set bf t0 a) k) e le m) t\n  (State f Sskip k e (PTree.set t0 v le) m)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf)","proofString":"eapply star_two.\neconstructor.\neapply step_make_set; eauto.\ntraceEq."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf) : eval_expr tge e (PTree.set t0 v le) m (Etempvar t0 (typeof a)) v /\\\ntypeof (Etempvar t0 (typeof a)) = typeof a /\\\n(forall x : ident, ~ In x tmp -> (PTree.set t0 v le) ! x = le ! x).","conclusion":"eval_expr tge e (PTree.set t0 v le) m (Etempvar t0 (typeof a)) v /\\\ntypeof (Etempvar t0 (typeof a)) = typeof a /\\\n(forall x : ident, ~ In x tmp -> (PTree.set t0 v le) ! x = le ! x)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf)","proofString":"split.\nconstructor.\napply PTree.gss.\nsplit.\nauto.\nintros.\napply PTree.gso.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf) : eval_expr tge e (PTree.set t0 v le) m (Etempvar t0 (typeof a)) v.","conclusion":"eval_expr tge e (PTree.set t0 v le) m (Etempvar t0 (typeof a)) v","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf)","proofString":"constructor.\napply PTree.gss."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf) : (PTree.set t0 v le) ! t0 = Some v.","conclusion":"(PTree.set t0 v le) ! t0 = Some v","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf)","proofString":"apply PTree.gss."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf) : typeof (Etempvar t0 (typeof a)) = typeof a /\\\n(forall x : ident, ~ In x tmp -> (PTree.set t0 v le) ! x = le ! x).","conclusion":"typeof (Etempvar t0 (typeof a)) = typeof a /\\\n(forall x : ident, ~ In x tmp -> (PTree.set t0 v le) ! x = le ! x)","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf)","proofString":"split.\nauto.\nintros.\napply PTree.gso.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf) : typeof (Etempvar t0 (typeof a)) = typeof a.","conclusion":"typeof (Etempvar t0 (typeof a)) = typeof a","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf)","proofString":"auto."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf) : forall x : ident, ~ In x tmp -> (PTree.set t0 v le) ! x = le ! x.","conclusion":"forall x : ident, ~ In x tmp -> (PTree.set t0 v le) ! x = le ! x","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf)","proofString":"intros.\napply PTree.gso.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf) (x : ident) (H1 : ~ In x tmp) : (PTree.set t0 v le) ! x = le ! x.","conclusion":"(PTree.set t0 v le) ! x = le ! x","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf) (x : ident) (H1 : ~ In x tmp)","proofString":"apply PTree.gso.\ncongruence."},{"statement":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf) (x : ident) (H1 : ~ In x tmp) : x <> t0.","conclusion":"x <> t0","hypotheses":"(m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (e : env) (le : temp_env) (a : expr) (tmp : list ident) (f : function) (k : cont) (H : Csem.deref_loc ge (typeof a) m b ofs bf t v) (H0 : eval_lvalue tge e le m a b ofs bf) (t0 : ident) (H3 : type_is_volatile (typeof a) = true) (H4 : In t0 tmp) (H5 : tr_is_bitfield_access ce a bf) (x : ident) (H1 : ~ In x tmp)","proofString":"congruence."},{"statement":"(ce : composite_env) : forall (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch n ls) (select_switch n tls).","conclusion":"forall (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch n ls) (select_switch n tls)","hypotheses":"(ce : composite_env)","proofString":"assert (DFL: forall ls tls,      tr_lblstmts ce ls tls ->      tr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls)).\ninduction 1; simpl.\nconstructor.\ndestruct c; auto.\nconstructor; auto.\nassert (CASE: forall n ls tls,      tr_lblstmts ce ls tls ->      match Csem.select_switch_case n ls with      | None =>          select_switch_case n tls = None      | Some ls' =>          exists tls', select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'      end).\ninduction 1; simpl; intros.\nauto.\ndestruct c; auto.\ndestruct (zeq z n); auto.\neconstructor; split; eauto.\nconstructor; auto.\nintros.\nunfold Csem.select_switch, select_switch.\nspecialize (CASE n ls tls H).\ndestruct (Csem.select_switch_case n ls) as [ls'|].\ndestruct CASE as [tls' [P Q]].\nrewrite P.\nauto.\nrewrite CASE.\napply DFL; auto."},{"statement":"(ce : composite_env) : forall (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls).","conclusion":"forall (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls)","hypotheses":"(ce : composite_env)","proofString":"induction 1; simpl.\nconstructor.\ndestruct c; auto.\nconstructor; auto."},{"statement":"(ce : composite_env) : tr_lblstmts ce Csyntax.LSnil LSnil.","conclusion":"tr_lblstmts ce Csyntax.LSnil LSnil","hypotheses":"(ce : composite_env)","proofString":"constructor."},{"statement":"(ce : composite_env) (c : option Z) (s : Csyntax.statement) (ls : Csyntax.labeled_statements) (ts : statement) (tls : labeled_statements) (H : tr_stmt ce s ts) (H0 : tr_lblstmts ce ls tls) (IHtr_lblstmts : tr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls)) : tr_lblstmts ce\n  match c with\n  | Some _ => Csem.select_switch_default ls\n  | None => Csyntax.LScons c s ls\n  end\n  match c with\n  | Some _ => select_switch_default tls\n  | None => LScons c ts tls\n  end.","conclusion":"tr_lblstmts ce\n  match c with\n  | Some _ => Csem.select_switch_default ls\n  | None => Csyntax.LScons c s ls\n  end\n  match c with\n  | Some _ => select_switch_default tls\n  | None => LScons c ts tls\n  end","hypotheses":"(ce : composite_env) (c : option Z) (s : Csyntax.statement) (ls : Csyntax.labeled_statements) (ts : statement) (tls : labeled_statements) (H : tr_stmt ce s ts) (H0 : tr_lblstmts ce ls tls) (IHtr_lblstmts : tr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls))","proofString":"destruct c; auto.\nconstructor; auto."},{"statement":"(ce : composite_env) (s : Csyntax.statement) (ls : Csyntax.labeled_statements) (ts : statement) (tls : labeled_statements) (H : tr_stmt ce s ts) (H0 : tr_lblstmts ce ls tls) (IHtr_lblstmts : tr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls)) : tr_lblstmts ce (Csyntax.LScons None s ls) (LScons None ts tls).","conclusion":"tr_lblstmts ce (Csyntax.LScons None s ls) (LScons None ts tls)","hypotheses":"(ce : composite_env) (s : Csyntax.statement) (ls : Csyntax.labeled_statements) (ts : statement) (tls : labeled_statements) (H : tr_stmt ce s ts) (H0 : tr_lblstmts ce ls tls) (IHtr_lblstmts : tr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls))","proofString":"constructor; auto."},{"statement":"(ce : composite_env) (DFL : forall (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls)) : forall (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch n ls) (select_switch n tls).","conclusion":"forall (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch n ls) (select_switch n tls)","hypotheses":"(ce : composite_env) (DFL : forall (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls))","proofString":"assert (CASE: forall n ls tls,      tr_lblstmts ce ls tls ->      match Csem.select_switch_case n ls with      | None =>          select_switch_case n tls = None      | Some ls' =>          exists tls', select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'      end).\ninduction 1; simpl; intros.\nauto.\ndestruct c; auto.\ndestruct (zeq z n); auto.\neconstructor; split; eauto.\nconstructor; auto.\nintros.\nunfold Csem.select_switch, select_switch.\nspecialize (CASE n ls tls H).\ndestruct (Csem.select_switch_case n ls) as [ls'|].\ndestruct CASE as [tls' [P Q]].\nrewrite P.\nauto.\nrewrite CASE.\napply DFL; auto."},{"statement":"(ce : composite_env) (DFL : forall (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls)) : forall (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\nmatch Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend.","conclusion":"forall (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\nmatch Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend","hypotheses":"(ce : composite_env) (DFL : forall (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls))","proofString":"induction 1; simpl; intros.\nauto.\ndestruct c; auto.\ndestruct (zeq z n); auto.\neconstructor; split; eauto.\nconstructor; auto."},{"statement":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (c : option Z) (s : Csyntax.statement) (ls : Csyntax.labeled_statements) (ts : statement) (tls : labeled_statements) (H : tr_stmt ce s ts) (H0 : tr_lblstmts ce ls tls) (IHtr_lblstmts : match Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend) : match\n  match c with\n  | Some c0 =>\n      if zeq c0 n\n      then Some (Csyntax.LScons c s ls)\n      else Csem.select_switch_case n ls\n  | None => Csem.select_switch_case n ls\n  end\nwith\n| Some ls' =>\n    exists tls' : labeled_statements,\n      match c with\n      | Some c0 =>\n          if zeq c0 n\n          then Some (LScons c ts tls)\n          else select_switch_case n tls\n      | None => select_switch_case n tls\n      end = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None =>\n    match c with\n    | Some c0 =>\n        if zeq c0 n then Some (LScons c ts tls) else select_switch_case n tls\n    | None => select_switch_case n tls\n    end = None\nend.","conclusion":"match\n  match c with\n  | Some c0 =>\n      if zeq c0 n\n      then Some (Csyntax.LScons c s ls)\n      else Csem.select_switch_case n ls\n  | None => Csem.select_switch_case n ls\n  end\nwith\n| Some ls' =>\n    exists tls' : labeled_statements,\n      match c with\n      | Some c0 =>\n          if zeq c0 n\n          then Some (LScons c ts tls)\n          else select_switch_case n tls\n      | None => select_switch_case n tls\n      end = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None =>\n    match c with\n    | Some c0 =>\n        if zeq c0 n then Some (LScons c ts tls) else select_switch_case n tls\n    | None => select_switch_case n tls\n    end = None\nend","hypotheses":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (c : option Z) (s : Csyntax.statement) (ls : Csyntax.labeled_statements) (ts : statement) (tls : labeled_statements) (H : tr_stmt ce s ts) (H0 : tr_lblstmts ce ls tls) (IHtr_lblstmts : match Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend)","proofString":"destruct c; auto.\ndestruct (zeq z n); auto.\neconstructor; split; eauto.\nconstructor; auto."},{"statement":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n z : Z) (s : Csyntax.statement) (ls : Csyntax.labeled_statements) (ts : statement) (tls : labeled_statements) (H : tr_stmt ce s ts) (H0 : tr_lblstmts ce ls tls) (IHtr_lblstmts : match Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend) : match\n  (if zeq z n\n   then Some (Csyntax.LScons (Some z) s ls)\n   else Csem.select_switch_case n ls)\nwith\n| Some ls' =>\n    exists tls' : labeled_statements,\n      (if zeq z n\n       then Some (LScons (Some z) ts tls)\n       else select_switch_case n tls) = Some tls' /\\ \n      tr_lblstmts ce ls' tls'\n| None =>\n    (if zeq z n\n     then Some (LScons (Some z) ts tls)\n     else select_switch_case n tls) = None\nend.","conclusion":"match\n  (if zeq z n\n   then Some (Csyntax.LScons (Some z) s ls)\n   else Csem.select_switch_case n ls)\nwith\n| Some ls' =>\n    exists tls' : labeled_statements,\n      (if zeq z n\n       then Some (LScons (Some z) ts tls)\n       else select_switch_case n tls) = Some tls' /\\ \n      tr_lblstmts ce ls' tls'\n| None =>\n    (if zeq z n\n     then Some (LScons (Some z) ts tls)\n     else select_switch_case n tls) = None\nend","hypotheses":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n z : Z) (s : Csyntax.statement) (ls : Csyntax.labeled_statements) (ts : statement) (tls : labeled_statements) (H : tr_stmt ce s ts) (H0 : tr_lblstmts ce ls tls) (IHtr_lblstmts : match Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend)","proofString":"destruct (zeq z n); auto.\neconstructor; split; eauto.\nconstructor; auto."},{"statement":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n z : Z) (s : Csyntax.statement) (ls : Csyntax.labeled_statements) (ts : statement) (tls : labeled_statements) (H : tr_stmt ce s ts) (H0 : tr_lblstmts ce ls tls) (IHtr_lblstmts : match Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend) (e : z = n) : exists tls' : labeled_statements,\n  Some (LScons (Some z) ts tls) = Some tls' /\\\n  tr_lblstmts ce (Csyntax.LScons (Some z) s ls) tls'.","conclusion":"exists tls' : labeled_statements,\n  Some (LScons (Some z) ts tls) = Some tls' /\\\n  tr_lblstmts ce (Csyntax.LScons (Some z) s ls) tls'","hypotheses":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n z : Z) (s : Csyntax.statement) (ls : Csyntax.labeled_statements) (ts : statement) (tls : labeled_statements) (H : tr_stmt ce s ts) (H0 : tr_lblstmts ce ls tls) (IHtr_lblstmts : match Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend) (e : z = n)","proofString":"econstructor; split; eauto.\nconstructor; auto."},{"statement":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n z : Z) (s : Csyntax.statement) (ls : Csyntax.labeled_statements) (ts : statement) (tls : labeled_statements) (H : tr_stmt ce s ts) (H0 : tr_lblstmts ce ls tls) (IHtr_lblstmts : match Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend) (e : z = n) : tr_lblstmts ce (Csyntax.LScons (Some z) s ls) (LScons (Some z) ts tls).","conclusion":"tr_lblstmts ce (Csyntax.LScons (Some z) s ls) (LScons (Some z) ts tls)","hypotheses":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n z : Z) (s : Csyntax.statement) (ls : Csyntax.labeled_statements) (ts : statement) (tls : labeled_statements) (H : tr_stmt ce s ts) (H0 : tr_lblstmts ce ls tls) (IHtr_lblstmts : match Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend) (e : z = n)","proofString":"constructor; auto."},{"statement":"(ce : composite_env) (DFL : forall (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls)) (CASE : forall (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\nmatch Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend) : forall (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch n ls) (select_switch n tls).","conclusion":"forall (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch n ls) (select_switch n tls)","hypotheses":"(ce : composite_env) (DFL : forall (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\ntr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls)) (CASE : forall (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements),\ntr_lblstmts ce ls tls ->\nmatch Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend)","proofString":"intros.\nunfold Csem.select_switch, select_switch.\nspecialize (CASE n ls tls H).\ndestruct (Csem.select_switch_case n ls) as [ls'|].\ndestruct CASE as [tls' [P Q]].\nrewrite P.\nauto.\nrewrite CASE.\napply DFL; auto."},{"statement":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (CASE : forall (n0 : Z) (ls0 : Csyntax.labeled_statements)\n  (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\nmatch Csem.select_switch_case n0 ls0 with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n0 tls0 = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n0 tls0 = None\nend) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (H : tr_lblstmts ce ls tls) : tr_lblstmts ce (Csem.select_switch n ls) (select_switch n tls).","conclusion":"tr_lblstmts ce (Csem.select_switch n ls) (select_switch n tls)","hypotheses":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (CASE : forall (n0 : Z) (ls0 : Csyntax.labeled_statements)\n  (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\nmatch Csem.select_switch_case n0 ls0 with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n0 tls0 = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n0 tls0 = None\nend) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (H : tr_lblstmts ce ls tls)","proofString":"unfold Csem.select_switch, select_switch.\nspecialize (CASE n ls tls H).\ndestruct (Csem.select_switch_case n ls) as [ls'|].\ndestruct CASE as [tls' [P Q]].\nrewrite P.\nauto.\nrewrite CASE.\napply DFL; auto."},{"statement":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (CASE : forall (n0 : Z) (ls0 : Csyntax.labeled_statements)\n  (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\nmatch Csem.select_switch_case n0 ls0 with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n0 tls0 = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n0 tls0 = None\nend) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (H : tr_lblstmts ce ls tls) : tr_lblstmts ce\n  match Csem.select_switch_case n ls with\n  | Some sl' => sl'\n  | None => Csem.select_switch_default ls\n  end\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end.","conclusion":"tr_lblstmts ce\n  match Csem.select_switch_case n ls with\n  | Some sl' => sl'\n  | None => Csem.select_switch_default ls\n  end\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end","hypotheses":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (CASE : forall (n0 : Z) (ls0 : Csyntax.labeled_statements)\n  (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\nmatch Csem.select_switch_case n0 ls0 with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n0 tls0 = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n0 tls0 = None\nend) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (H : tr_lblstmts ce ls tls)","proofString":"specialize (CASE n ls tls H).\ndestruct (Csem.select_switch_case n ls) as [ls'|].\ndestruct CASE as [tls' [P Q]].\nrewrite P.\nauto.\nrewrite CASE.\napply DFL; auto."},{"statement":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (CASE : match Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend) (H : tr_lblstmts ce ls tls) : tr_lblstmts ce\n  match Csem.select_switch_case n ls with\n  | Some sl' => sl'\n  | None => Csem.select_switch_default ls\n  end\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end.","conclusion":"tr_lblstmts ce\n  match Csem.select_switch_case n ls with\n  | Some sl' => sl'\n  | None => Csem.select_switch_default ls\n  end\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end","hypotheses":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (CASE : match Csem.select_switch_case n ls with\n| Some ls' =>\n    exists tls' : labeled_statements,\n      select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls'\n| None => select_switch_case n tls = None\nend) (H : tr_lblstmts ce ls tls)","proofString":"destruct (Csem.select_switch_case n ls) as [ls'|].\ndestruct CASE as [tls' [P Q]].\nrewrite P.\nauto.\nrewrite CASE.\napply DFL; auto."},{"statement":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (ls' : Csyntax.labeled_statements) (CASE : exists tls' : labeled_statements,\n  select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls') (H : tr_lblstmts ce ls tls) : tr_lblstmts ce ls'\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end.","conclusion":"tr_lblstmts ce ls'\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end","hypotheses":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (ls' : Csyntax.labeled_statements) (CASE : exists tls' : labeled_statements,\n  select_switch_case n tls = Some tls' /\\ tr_lblstmts ce ls' tls') (H : tr_lblstmts ce ls tls)","proofString":"destruct CASE as [tls' [P Q]].\nrewrite P.\nauto."},{"statement":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (ls' : Csyntax.labeled_statements) (tls' : labeled_statements) (P : select_switch_case n tls = Some tls') (Q : tr_lblstmts ce ls' tls') (H : tr_lblstmts ce ls tls) : tr_lblstmts ce ls'\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end.","conclusion":"tr_lblstmts ce ls'\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end","hypotheses":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (ls' : Csyntax.labeled_statements) (tls' : labeled_statements) (P : select_switch_case n tls = Some tls') (Q : tr_lblstmts ce ls' tls') (H : tr_lblstmts ce ls tls)","proofString":"rewrite P.\nauto."},{"statement":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (ls' : Csyntax.labeled_statements) (tls' : labeled_statements) (P : select_switch_case n tls = Some tls') (Q : tr_lblstmts ce ls' tls') (H : tr_lblstmts ce ls tls) : tr_lblstmts ce ls' tls'.","conclusion":"tr_lblstmts ce ls' tls'","hypotheses":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (ls' : Csyntax.labeled_statements) (tls' : labeled_statements) (P : select_switch_case n tls = Some tls') (Q : tr_lblstmts ce ls' tls') (H : tr_lblstmts ce ls tls)","proofString":"auto."},{"statement":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (CASE : select_switch_case n tls = None) (H : tr_lblstmts ce ls tls) : tr_lblstmts ce (Csem.select_switch_default ls)\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end.","conclusion":"tr_lblstmts ce (Csem.select_switch_default ls)\n  match select_switch_case n tls with\n  | Some sl' => sl'\n  | None => select_switch_default tls\n  end","hypotheses":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (CASE : select_switch_case n tls = None) (H : tr_lblstmts ce ls tls)","proofString":"rewrite CASE.\napply DFL; auto."},{"statement":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (CASE : select_switch_case n tls = None) (H : tr_lblstmts ce ls tls) : tr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls).","conclusion":"tr_lblstmts ce (Csem.select_switch_default ls) (select_switch_default tls)","hypotheses":"(ce : composite_env) (DFL : forall (ls0 : Csyntax.labeled_statements) (tls0 : labeled_statements),\ntr_lblstmts ce ls0 tls0 ->\ntr_lblstmts ce (Csem.select_switch_default ls0) (select_switch_default tls0)) (n : Z) (ls : Csyntax.labeled_statements) (tls : labeled_statements) (CASE : select_switch_case n tls = None) (H : tr_lblstmts ce ls tls)","proofString":"apply DFL; auto."},{"statement":"(sl2 : list statement) (H : True) (H0 : nolabel_list sl2) : nolabel_list sl2.","conclusion":"nolabel_list sl2","hypotheses":"(sl2 : list statement) (H : True) (H0 : nolabel_list sl2)","proofString":"auto."},{"statement":"(sl2 : list statement) (a : statement) (sl1 : list statement) (IHsl1 : nolabel_list sl1 -> nolabel_list sl2 -> nolabel_list (sl1 ++ sl2)) (H : nolabel a /\\ nolabel_list sl1) (H0 : nolabel_list sl2) : nolabel a /\\ nolabel_list (sl1 ++ sl2).","conclusion":"nolabel a /\\ nolabel_list (sl1 ++ sl2)","hypotheses":"(sl2 : list statement) (a : statement) (sl1 : list statement) (IHsl1 : nolabel_list sl1 -> nolabel_list sl2 -> nolabel_list (sl1 ++ sl2)) (H : nolabel a /\\ nolabel_list sl1) (H0 : nolabel_list sl2)","proofString":"tauto."},{"statement":"forall (sl : list statement) (s : statement),\nnolabel s -> nolabel_list sl -> nolabel (makeseq_rec s sl).","conclusion":"forall (sl : list statement) (s : statement),\nnolabel s -> nolabel_list sl -> nolabel (makeseq_rec s sl)","hypotheses":"","proofString":"induction sl; simpl; intros.\nauto.\ndestruct H0.\napply IHsl; auto.\nred.\nintros; simpl.\nrewrite H.\napply H0."},{"statement":"(s : statement) (H : nolabel s) (H0 : True) : nolabel s.","conclusion":"nolabel s","hypotheses":"(s : statement) (H : nolabel s) (H0 : True)","proofString":"auto."},{"statement":"(a : statement) (sl : list statement) (IHsl : forall s0 : statement,\nnolabel s0 -> nolabel_list sl -> nolabel (makeseq_rec s0 sl)) (s : statement) (H : nolabel s) (H0 : nolabel a /\\ nolabel_list sl) : nolabel (makeseq_rec (Ssequence s a) sl).","conclusion":"nolabel (makeseq_rec (Ssequence s a) sl)","hypotheses":"(a : statement) (sl : list statement) (IHsl : forall s0 : statement,\nnolabel s0 -> nolabel_list sl -> nolabel (makeseq_rec s0 sl)) (s : statement) (H : nolabel s) (H0 : nolabel a /\\ nolabel_list sl)","proofString":"destruct H0.\napply IHsl; auto.\nred.\nintros; simpl.\nrewrite H.\napply H0."},{"statement":"(a : statement) (sl : list statement) (IHsl : forall s0 : statement,\nnolabel s0 -> nolabel_list sl -> nolabel (makeseq_rec s0 sl)) (s : statement) (H : nolabel s) (H0 : nolabel a) (H1 : nolabel_list sl) : nolabel (makeseq_rec (Ssequence s a) sl).","conclusion":"nolabel (makeseq_rec (Ssequence s a) sl)","hypotheses":"(a : statement) (sl : list statement) (IHsl : forall s0 : statement,\nnolabel s0 -> nolabel_list sl -> nolabel (makeseq_rec s0 sl)) (s : statement) (H : nolabel s) (H0 : nolabel a) (H1 : nolabel_list sl)","proofString":"apply IHsl; auto.\nred.\nintros; simpl.\nrewrite H.\napply H0."},{"statement":"(a : statement) (sl : list statement) (IHsl : forall s0 : statement,\nnolabel s0 -> nolabel_list sl -> nolabel (makeseq_rec s0 sl)) (s : statement) (H : nolabel s) (H0 : nolabel a) (H1 : nolabel_list sl) : nolabel (Ssequence s a).","conclusion":"nolabel (Ssequence s a)","hypotheses":"(a : statement) (sl : list statement) (IHsl : forall s0 : statement,\nnolabel s0 -> nolabel_list sl -> nolabel (makeseq_rec s0 sl)) (s : statement) (H : nolabel s) (H0 : nolabel a) (H1 : nolabel_list sl)","proofString":"red.\nintros; simpl.\nrewrite H.\napply H0."},{"statement":"(a : statement) (sl : list statement) (IHsl : forall s0 : statement,\nnolabel s0 -> nolabel_list sl -> nolabel (makeseq_rec s0 sl)) (s : statement) (H : nolabel s) (H0 : nolabel a) (H1 : nolabel_list sl) : forall k : cont, find_label lbl (Ssequence s a) k = None.","conclusion":"forall k : cont, find_label lbl (Ssequence s a) k = None","hypotheses":"(a : statement) (sl : list statement) (IHsl : forall s0 : statement,\nnolabel s0 -> nolabel_list sl -> nolabel (makeseq_rec s0 sl)) (s : statement) (H : nolabel s) (H0 : nolabel a) (H1 : nolabel_list sl)","proofString":"intros; simpl.\nrewrite H.\napply H0."},{"statement":"(a : statement) (sl : list statement) (IHsl : forall s0 : statement,\nnolabel s0 -> nolabel_list sl -> nolabel (makeseq_rec s0 sl)) (s : statement) (H : nolabel s) (H0 : nolabel a) (H1 : nolabel_list sl) (k : cont) : match find_label lbl s (Kseq a k) with\n| Some sk => Some sk\n| None => find_label lbl a k\nend = None.","conclusion":"match find_label lbl s (Kseq a k) with\n| Some sk => Some sk\n| None => find_label lbl a k\nend = None","hypotheses":"(a : statement) (sl : list statement) (IHsl : forall s0 : statement,\nnolabel s0 -> nolabel_list sl -> nolabel (makeseq_rec s0 sl)) (s : statement) (H : nolabel s) (H0 : nolabel a) (H1 : nolabel_list sl) (k : cont)","proofString":"rewrite H.\napply H0."},{"statement":"(a : statement) (sl : list statement) (IHsl : forall s0 : statement,\nnolabel s0 -> nolabel_list sl -> nolabel (makeseq_rec s0 sl)) (s : statement) (H : nolabel s) (H0 : nolabel a) (H1 : nolabel_list sl) (k : cont) : find_label lbl a k = None.","conclusion":"find_label lbl a k = None","hypotheses":"(a : statement) (sl : list statement) (IHsl : forall s0 : statement,\nnolabel s0 -> nolabel_list sl -> nolabel (makeseq_rec s0 sl)) (s : statement) (H : nolabel s) (H0 : nolabel a) (H1 : nolabel_list sl) (k : cont)","proofString":"apply H0."},{"statement":"(H : forall (sl : list statement) (s : statement),\nnolabel s -> nolabel_list sl -> nolabel (makeseq_rec s sl)) : forall sl : list statement, nolabel_list sl -> nolabel (makeseq sl).","conclusion":"forall sl : list statement, nolabel_list sl -> nolabel (makeseq sl)","hypotheses":"(H : forall (sl : list statement) (s : statement),\nnolabel s -> nolabel_list sl -> nolabel (makeseq_rec s sl))","proofString":"intros.\nunfold makeseq.\napply H; auto.\nred.\nauto."},{"statement":"(H : forall (sl0 : list statement) (s : statement),\nnolabel s -> nolabel_list sl0 -> nolabel (makeseq_rec s sl0)) (sl : list statement) (H0 : nolabel_list sl) : nolabel (makeseq sl).","conclusion":"nolabel (makeseq sl)","hypotheses":"(H : forall (sl0 : list statement) (s : statement),\nnolabel s -> nolabel_list sl0 -> nolabel (makeseq_rec s sl0)) (sl : list statement) (H0 : nolabel_list sl)","proofString":"unfold makeseq.\napply H; auto.\nred.\nauto."},{"statement":"(H : forall (sl0 : list statement) (s : statement),\nnolabel s -> nolabel_list sl0 -> nolabel (makeseq_rec s sl0)) (sl : list statement) (H0 : nolabel_list sl) : nolabel (makeseq_rec Sskip sl).","conclusion":"nolabel (makeseq_rec Sskip sl)","hypotheses":"(H : forall (sl0 : list statement) (s : statement),\nnolabel s -> nolabel_list sl0 -> nolabel (makeseq_rec s sl0)) (sl : list statement) (H0 : nolabel_list sl)","proofString":"apply H; auto.\nred.\nauto."},{"statement":"(H : forall (sl0 : list statement) (s : statement),\nnolabel s -> nolabel_list sl0 -> nolabel (makeseq_rec s sl0)) (sl : list statement) (H0 : nolabel_list sl) : nolabel Sskip.","conclusion":"nolabel Sskip","hypotheses":"(H : forall (sl0 : list statement) (s : statement),\nnolabel s -> nolabel_list sl0 -> nolabel (makeseq_rec s sl0)) (sl : list statement) (H0 : nolabel_list sl)","proofString":"red.\nauto."},{"statement":"(H : forall (sl0 : list statement) (s : statement),\nnolabel s -> nolabel_list sl0 -> nolabel (makeseq_rec s sl0)) (sl : list statement) (H0 : nolabel_list sl) : forall k : cont, find_label lbl Sskip k = None.","conclusion":"forall k : cont, find_label lbl Sskip k = None","hypotheses":"(H : forall (sl0 : list statement) (s : statement),\nnolabel s -> nolabel_list sl0 -> nolabel (makeseq_rec s sl0)) (sl : list statement) (H0 : nolabel_list sl)","proofString":"auto."},{"statement":"(a : expr) (s1 s2 : statement) (H : nolabel s1) (H0 : nolabel s2) : nolabel (makeif a s1 s2).","conclusion":"nolabel (makeif a s1 s2)","hypotheses":"(a : expr) (s1 s2 : statement) (H : nolabel s1) (H0 : nolabel s2)","proofString":"functional induction (makeif a s1 s2); auto.\nred; simpl; intros.\nrewrite H; auto.\nred; simpl; intros.\nrewrite H; auto."},{"statement":"(a : expr) (s1 s2 : statement) (H : nolabel s1) (H0 : nolabel s2) (v : val) (e : eval_simpl_expr a = Some v) (e0 : bool_val v (typeof a) Mem.empty = None) : nolabel (Sifthenelse a s1 s2).","conclusion":"nolabel (Sifthenelse a s1 s2)","hypotheses":"(a : expr) (s1 s2 : statement) (H : nolabel s1) (H0 : nolabel s2) (v : val) (e : eval_simpl_expr a = Some v) (e0 : bool_val v (typeof a) Mem.empty = None)","proofString":"red; simpl; intros.\nrewrite H; auto."},{"statement":"(a : expr) (s1 s2 : statement) (H : nolabel s1) (H0 : nolabel s2) (v : val) (e : eval_simpl_expr a = Some v) (e0 : bool_val v (typeof a) Mem.empty = None) (k : cont) : match find_label lbl s1 k with\n| Some sk => Some sk\n| None => find_label lbl s2 k\nend = None.","conclusion":"match find_label lbl s1 k with\n| Some sk => Some sk\n| None => find_label lbl s2 k\nend = None","hypotheses":"(a : expr) (s1 s2 : statement) (H : nolabel s1) (H0 : nolabel s2) (v : val) (e : eval_simpl_expr a = Some v) (e0 : bool_val v (typeof a) Mem.empty = None) (k : cont)","proofString":"rewrite H; auto."},{"statement":"(a : expr) (s1 s2 : statement) (H : nolabel s1) (H0 : nolabel s2) (e : eval_simpl_expr a = None) : nolabel (Sifthenelse a s1 s2).","conclusion":"nolabel (Sifthenelse a s1 s2)","hypotheses":"(a : expr) (s1 s2 : statement) (H : nolabel s1) (H0 : nolabel s2) (e : eval_simpl_expr a = None)","proofString":"red; simpl; intros.\nrewrite H; auto."},{"statement":"(a : expr) (s1 s2 : statement) (H : nolabel s1) (H0 : nolabel s2) (e : eval_simpl_expr a = None) (k : cont) : match find_label lbl s1 k with\n| Some sk => Some sk\n| None => find_label lbl s2 k\nend = None.","conclusion":"match find_label lbl s1 k with\n| Some sk => Some sk\n| None => find_label lbl s2 k\nend = None","hypotheses":"(a : expr) (s1 s2 : statement) (H : nolabel s1) (H0 : nolabel s2) (e : eval_simpl_expr a = None) (k : cont)","proofString":"rewrite H; auto."},{"statement":"(bf : bitfield) (t : ident) (a : expr) (k : cont) : find_label lbl\n  match chunk_for_volatile_type (typeof a) bf with\n  | Some chunk =>\n      Sbuiltin (Some t) (EF_vload chunk) (Tpointer (typeof a) noattr :: nil)\n        (Eaddrof a (Tpointer (typeof a) noattr) :: nil)\n  | None => Sset t a\n  end k = None.","conclusion":"find_label lbl\n  match chunk_for_volatile_type (typeof a) bf with\n  | Some chunk =>\n      Sbuiltin (Some t) (EF_vload chunk) (Tpointer (typeof a) noattr :: nil)\n        (Eaddrof a (Tpointer (typeof a) noattr) :: nil)\n  | None => Sset t a\n  end k = None","hypotheses":"(bf : bitfield) (t : ident) (a : expr) (k : cont)","proofString":"destruct (chunk_for_volatile_type (typeof a) bf); auto."},{"statement":"(bf : bitfield) (l r : expr) (k : cont) : find_label lbl\n  match chunk_for_volatile_type (typeof l) bf with\n  | Some chunk =>\n      Sbuiltin None (EF_vstore chunk)\n        (Tpointer (typeof l) noattr :: typeof l :: nil)\n        (Eaddrof l (Tpointer (typeof l) noattr) :: r :: nil)\n  | None => Sassign l r\n  end k = None.","conclusion":"find_label lbl\n  match chunk_for_volatile_type (typeof l) bf with\n  | Some chunk =>\n      Sbuiltin None (EF_vstore chunk)\n        (Tpointer (typeof l) noattr :: typeof l :: nil)\n        (Eaddrof l (Tpointer (typeof l) noattr) :: r :: nil)\n  | None => Sassign l r\n  end k = None","hypotheses":"(bf : bitfield) (l r : expr) (k : cont)","proofString":"destruct (chunk_for_volatile_type (typeof l) bf); auto."},{"statement":"(ce0 : composite_env) (ty : type) (a : expr) (t : ident) (bf : bitfield) (tmp : list ident) (H : type_is_volatile ty = true) (H0 : In t tmp) (H1 : tr_is_bitfield_access ce0 a bf) : nolabel (make_set bf t a).","conclusion":"nolabel (make_set bf t a)","hypotheses":"(ce0 : composite_env) (ty : type) (a : expr) (t : ident) (bf : bitfield) (tmp : list ident) (H : type_is_volatile ty = true) (H0 : In t tmp) (H1 : tr_is_bitfield_access ce0 a bf)","proofString":"apply make_set_nolabel."},{"statement":"(a : expr) : True.","conclusion":"True","hypotheses":"(a : expr)","proofString":"auto."},{"statement":"(a : expr) : True.","conclusion":"True","hypotheses":"(a : expr)","proofString":"auto."},{"statement":"(sd : set_destination) (a : expr) : nolabel_list (do_set sd a).","conclusion":"nolabel_list (do_set sd a)","hypotheses":"(sd : set_destination) (a : expr)","proofString":"apply nolabel_do_set."},{"statement":"(le : PTree.tree val) (sd : set_destination) (v : val) (ty : type) (a any : expr) (tmp : list positive) (H : typeof a = ty) (H0 : forall (tge0 : genv) (e : env) (le' : PTree.tree val) (m : mem),\n(forall id : positive, In id tmp -> le' ! id = le ! id) ->\neval_expr tge0 e le' m a v) : nolabel_list (do_set sd a).","conclusion":"nolabel_list (do_set sd a)","hypotheses":"(le : PTree.tree val) (sd : set_destination) (v : val) (ty : type) (a any : expr) (tmp : list positive) (H : typeof a = ty) (H0 : forall (tge0 : genv) (e : env) (le' : PTree.tree val) (m : mem),\n(forall id : positive, In id tmp -> le' ! id = le ! id) ->\neval_expr tge0 e le' m a v)","proofString":"apply nolabel_do_set."},{"statement":"(le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : nolabel_list sl1) (H1 : tr_rvalof ce (Csyntax.typeof e1) a1 sl2 a2 tmp2) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) : nolabel_list sl2.","conclusion":"nolabel_list sl2","hypotheses":"(le : temp_env) (dst : destination) (e1 : Csyntax.expr) (ty : type) (tmp : list ident) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : nolabel_list sl1) (H1 : tr_rvalof ce (Csyntax.typeof e1) a1 sl2 a2 tmp2) (H2 : list_disjoint tmp1 tmp2) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp)","proofString":"eapply tr_rvalof_nolabel; eauto."},{"statement":"(le : temp_env) (sd : set_destination) (e1 e2 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (any : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : nolabel_list sl1) (H1 : tr_expr ce le (For_set (SDcons type_bool ty t sd)) e2 sl2 a2 tmp2) (H2 : nolabel_list sl2) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : In t tmp) : nolabel_list (do_set sd (Econst_int Int.zero ty)).","conclusion":"nolabel_list (do_set sd (Econst_int Int.zero ty))","hypotheses":"(le : temp_env) (sd : set_destination) (e1 e2 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (any : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : nolabel_list sl1) (H1 : tr_expr ce le (For_set (SDcons type_bool ty t sd)) e2 sl2 a2 tmp2) (H2 : nolabel_list sl2) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : In t tmp)","proofString":"apply nolabel_do_set."},{"statement":"(le : temp_env) (sd : set_destination) (e1 e2 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (any : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : nolabel_list sl1) (H1 : tr_expr ce le (For_set (SDcons type_bool ty t sd)) e2 sl2 a2 tmp2) (H2 : nolabel_list sl2) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : In t tmp) : nolabel_list (do_set sd (Econst_int Int.one ty)).","conclusion":"nolabel_list (do_set sd (Econst_int Int.one ty))","hypotheses":"(le : temp_env) (sd : set_destination) (e1 e2 : Csyntax.expr) (ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (any : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : nolabel_list sl1) (H1 : tr_expr ce le (For_set (SDcons type_bool ty t sd)) e2 sl2 a2 tmp2) (H2 : nolabel_list sl2) (H3 : list_disjoint tmp1 tmp2) (H4 : incl tmp1 tmp) (H5 : incl tmp2 tmp) (H6 : In t tmp)","proofString":"apply nolabel_do_set."},{"statement":"(le : temp_env) (op : binary_operation) (e1 e2 : Csyntax.expr) (tyres ty ty1 : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (any : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : nolabel_list sl1) (H1 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H2 : nolabel_list sl2) (H3 : ty1 = Csyntax.typeof e1) (H4 : tr_rvalof ce ty1 a1 sl3 a3 tmp3) (H5 : list_disjoint tmp1 tmp2) (H6 : list_disjoint tmp1 tmp3) (H7 : list_disjoint tmp2 tmp3) (H8 : incl tmp1 tmp) (H9 : incl tmp2 tmp) (H10 : incl tmp3 tmp) (H11 : tr_is_bitfield_access ce a1 bf) : nolabel_list sl3.","conclusion":"nolabel_list sl3","hypotheses":"(le : temp_env) (op : binary_operation) (e1 e2 : Csyntax.expr) (tyres ty ty1 : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (any : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : nolabel_list sl1) (H1 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H2 : nolabel_list sl2) (H3 : ty1 = Csyntax.typeof e1) (H4 : tr_rvalof ce ty1 a1 sl3 a3 tmp3) (H5 : list_disjoint tmp1 tmp2) (H6 : list_disjoint tmp1 tmp3) (H7 : list_disjoint tmp2 tmp3) (H8 : incl tmp1 tmp) (H9 : incl tmp2 tmp) (H10 : incl tmp3 tmp) (H11 : tr_is_bitfield_access ce a1 bf)","proofString":"eapply tr_rvalof_nolabel; eauto."},{"statement":"(le : temp_env) (dst : destination) (op : binary_operation) (e1 e2 : Csyntax.expr) (tyres ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (tmp : list ident) (ty1 : type) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : nolabel_list sl1) (H1 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H2 : nolabel_list sl2) (H3 : tr_rvalof ce ty1 a1 sl3 a3 tmp3) (H4 : list_disjoint tmp1 tmp2) (H5 : list_disjoint tmp1 tmp3) (H6 : list_disjoint tmp2 tmp3) (H7 : incl tmp1 tmp) (H8 : incl tmp2 tmp) (H9 : incl tmp3 tmp) (H10 : In t tmp) (H11 : ~ In t tmp1) (H12 : ~ In t tmp2) (H13 : ~ In t tmp3) (H14 : ty1 = Csyntax.typeof e1) (H15 : tr_is_bitfield_access ce a1 bf) : nolabel_list sl3.","conclusion":"nolabel_list sl3","hypotheses":"(le : temp_env) (dst : destination) (op : binary_operation) (e1 e2 : Csyntax.expr) (tyres ty : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (sl3 : list statement) (a3 : expr) (tmp3 : list ident) (t : ident) (bf : bitfield) (tmp : list ident) (ty1 : type) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : nolabel_list sl1) (H1 : tr_expr ce le For_val e2 sl2 a2 tmp2) (H2 : nolabel_list sl2) (H3 : tr_rvalof ce ty1 a1 sl3 a3 tmp3) (H4 : list_disjoint tmp1 tmp2) (H5 : list_disjoint tmp1 tmp3) (H6 : list_disjoint tmp2 tmp3) (H7 : incl tmp1 tmp) (H8 : incl tmp2 tmp) (H9 : incl tmp3 tmp) (H10 : In t tmp) (H11 : ~ In t tmp1) (H12 : ~ In t tmp2) (H13 : ~ In t tmp3) (H14 : ty1 = Csyntax.typeof e1) (H15 : tr_is_bitfield_access ce a1 bf)","proofString":"eapply tr_rvalof_nolabel; eauto."},{"statement":"(le : temp_env) (id : incr_or_decr) (e1 : Csyntax.expr) (ty ty1 : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (any : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : nolabel_list sl1) (H1 : tr_rvalof ce ty1 a1 sl2 a2 tmp2) (H2 : ty1 = Csyntax.typeof e1) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : list_disjoint tmp1 tmp2) (H6 : tr_is_bitfield_access ce a1 bf) : nolabel_list sl2.","conclusion":"nolabel_list sl2","hypotheses":"(le : temp_env) (id : incr_or_decr) (e1 : Csyntax.expr) (ty ty1 : type) (sl1 : list statement) (a1 : expr) (tmp1 : list ident) (sl2 : list statement) (a2 : expr) (tmp2 : list ident) (bf : bitfield) (any : expr) (tmp : list ident) (H : tr_expr ce le For_val e1 sl1 a1 tmp1) (H0 : nolabel_list sl1) (H1 : tr_rvalof ce ty1 a1 sl2 a2 tmp2) (H2 : ty1 = Csyntax.typeof e1) (H3 : incl tmp1 tmp) (H4 : incl tmp2 tmp) (H5 : list_disjoint tmp1 tmp2) (H6 : tr_is_bitfield_access ce a1 bf)","proofString":"eapply tr_rvalof_nolabel; eauto."},{"statement":"(e : env) (le : temp_env) (m : mem) (dst : destination) (r : Csyntax.expr) (sl : list statement) (a : expr) (tmp : list ident) (H : tr_expr ce le dst r sl a tmp) : nolabel_list sl.","conclusion":"nolabel_list sl","hypotheses":"(e : env) (le : temp_env) (m : mem) (dst : destination) (r : Csyntax.expr) (sl : list statement) (a : expr) (tmp : list ident) (H : tr_expr ce le dst r sl a tmp)","proofString":"eapply (proj1 tr_find_label_expr); eauto."},{"statement":"(r : Csyntax.expr) (s : statement) (a : expr) (H : tr_expression ce r s a) (k : cont) : find_label lbl s k = None.","conclusion":"find_label lbl s k = None","hypotheses":"(r : Csyntax.expr) (s : statement) (a : expr) (H : tr_expression ce r s a) (k : cont)","proofString":"inv H.\nassert (nolabel (makeseq sl)).\napply makeseq_nolabel.\neapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).\neauto.\napply H."},{"statement":"(r : Csyntax.expr) (a : expr) (k : cont) (sl : list statement) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) : find_label lbl (makeseq sl) k = None.","conclusion":"find_label lbl (makeseq sl) k = None","hypotheses":"(r : Csyntax.expr) (a : expr) (k : cont) (sl : list statement) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps)","proofString":"assert (nolabel (makeseq sl)).\napply makeseq_nolabel.\neapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).\neauto.\napply H."},{"statement":"(r : Csyntax.expr) (a : expr) (k : cont) (sl : list statement) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) : nolabel (makeseq sl).","conclusion":"nolabel (makeseq sl)","hypotheses":"(r : Csyntax.expr) (a : expr) (k : cont) (sl : list statement) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps)","proofString":"apply makeseq_nolabel.\neapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).\neauto."},{"statement":"(r : Csyntax.expr) (a : expr) (k : cont) (sl : list statement) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) : nolabel_list sl.","conclusion":"nolabel_list sl","hypotheses":"(r : Csyntax.expr) (a : expr) (k : cont) (sl : list statement) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps)","proofString":"eapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).\neauto."},{"statement":"(r : Csyntax.expr) (a : expr) (k : cont) (sl : list statement) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) (H : nolabel (makeseq sl)) : find_label lbl (makeseq sl) k = None.","conclusion":"find_label lbl (makeseq sl) k = None","hypotheses":"(r : Csyntax.expr) (a : expr) (k : cont) (sl : list statement) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) (H : nolabel (makeseq sl))","proofString":"apply H."},{"statement":"(r : Csyntax.expr) (s : statement) (H : tr_expr_stmt ce r s) (k : cont) : find_label lbl s k = None.","conclusion":"find_label lbl s k = None","hypotheses":"(r : Csyntax.expr) (s : statement) (H : tr_expr_stmt ce r s) (k : cont)","proofString":"inv H.\nassert (nolabel (makeseq sl)).\napply makeseq_nolabel.\neapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).\neauto.\napply H."},{"statement":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_effects r sl a tmps) : find_label lbl (makeseq sl) k = None.","conclusion":"find_label lbl (makeseq sl) k = None","hypotheses":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_effects r sl a tmps)","proofString":"assert (nolabel (makeseq sl)).\napply makeseq_nolabel.\neapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).\neauto.\napply H."},{"statement":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_effects r sl a tmps) : nolabel (makeseq sl).","conclusion":"nolabel (makeseq sl)","hypotheses":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_effects r sl a tmps)","proofString":"apply makeseq_nolabel.\neapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).\neauto."},{"statement":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_effects r sl a tmps) : nolabel_list sl.","conclusion":"nolabel_list sl","hypotheses":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_effects r sl a tmps)","proofString":"eapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).\neauto."},{"statement":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_effects r sl a tmps) (H : nolabel (makeseq sl)) : find_label lbl (makeseq sl) k = None.","conclusion":"find_label lbl (makeseq sl) k = None","hypotheses":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_effects r sl a tmps) (H : nolabel (makeseq sl))","proofString":"apply H."},{"statement":"(r : Csyntax.expr) (s : statement) (H : tr_if ce r Sskip Sbreak s) (k : cont) : find_label lbl s k = None.","conclusion":"find_label lbl s k = None","hypotheses":"(r : Csyntax.expr) (s : statement) (H : tr_if ce r Sskip Sbreak s) (k : cont)","proofString":"inv H.\nassert (nolabel (makeseq (sl ++ makeif a Sskip Sbreak :: nil))).\napply makeseq_nolabel.\napply nolabel_list_app.\neapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).\neauto.\nsimpl; split; auto.\napply makeif_nolabel.\nred; simpl; auto.\nred; simpl; auto.\napply H."},{"statement":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) : find_label lbl (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) k = None.","conclusion":"find_label lbl (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) k = None","hypotheses":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps)","proofString":"assert (nolabel (makeseq (sl ++ makeif a Sskip Sbreak :: nil))).\napply makeseq_nolabel.\napply nolabel_list_app.\neapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).\neauto.\nsimpl; split; auto.\napply makeif_nolabel.\nred; simpl; auto.\nred; simpl; auto.\napply H."},{"statement":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) : nolabel (makeseq (sl ++ makeif a Sskip Sbreak :: nil)).","conclusion":"nolabel (makeseq (sl ++ makeif a Sskip Sbreak :: nil))","hypotheses":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps)","proofString":"apply makeseq_nolabel.\napply nolabel_list_app.\neapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).\neauto.\nsimpl; split; auto.\napply makeif_nolabel.\nred; simpl; auto.\nred; simpl; auto."},{"statement":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) : nolabel_list (sl ++ makeif a Sskip Sbreak :: nil).","conclusion":"nolabel_list (sl ++ makeif a Sskip Sbreak :: nil)","hypotheses":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps)","proofString":"apply nolabel_list_app.\neapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).\neauto.\nsimpl; split; auto.\napply makeif_nolabel.\nred; simpl; auto.\nred; simpl; auto."},{"statement":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) : nolabel_list sl.","conclusion":"nolabel_list sl","hypotheses":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps)","proofString":"eapply tr_find_label_top with (e := empty_env) (le := PTree.empty val) (m := Mem.empty).\neauto."},{"statement":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) : nolabel_list (makeif a Sskip Sbreak :: nil).","conclusion":"nolabel_list (makeif a Sskip Sbreak :: nil)","hypotheses":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps)","proofString":"simpl; split; auto.\napply makeif_nolabel.\nred; simpl; auto.\nred; simpl; auto."},{"statement":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) : nolabel (makeif a Sskip Sbreak).","conclusion":"nolabel (makeif a Sskip Sbreak)","hypotheses":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps)","proofString":"apply makeif_nolabel.\nred; simpl; auto.\nred; simpl; auto."},{"statement":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) : nolabel Sskip.","conclusion":"nolabel Sskip","hypotheses":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps)","proofString":"red; simpl; auto."},{"statement":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) : nolabel Sbreak.","conclusion":"nolabel Sbreak","hypotheses":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps)","proofString":"red; simpl; auto."},{"statement":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) (H : nolabel (makeseq (sl ++ makeif a Sskip Sbreak :: nil))) : find_label lbl (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) k = None.","conclusion":"find_label lbl (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) k = None","hypotheses":"(r : Csyntax.expr) (k : cont) (sl : list statement) (a : expr) (tmps : list ident) (H0 : forall (ge0 : genv) (e : env) (le : temp_env) (m : mem),\ntr_top ce ge0 e le m For_val r sl a tmps) (H : nolabel (makeseq (sl ++ makeif a Sskip Sbreak :: nil)))","proofString":"apply H."},{"statement":"(ce : composite_env) (le : PTree.tree val) (dst : destination) (v : val) (ty : type) (a : expr) (tmp : list positive) (H : typeof a = ty) (H0 : forall (tge0 : genv) (e : env) (le' : PTree.tree val) (m : mem),\n(forall id : positive, In id tmp -> le' ! id = le ! id) ->\neval_expr tge0 e le' m a v) : tr_expr ce le dst (Eval v ty) (final dst a) a tmp.","conclusion":"tr_expr ce le dst (Eval v ty) (final dst a) a tmp","hypotheses":"(ce : composite_env) (le : PTree.tree val) (dst : destination) (v : val) (ty : type) (a : expr) (tmp : list positive) (H : typeof a = ty) (H0 : forall (tge0 : genv) (e : env) (le' : PTree.tree val) (m : mem),\n(forall id : positive, In id tmp -> le' ! id = le ! id) ->\neval_expr tge0 e le' m a v)","proofString":"destruct dst; simpl; econstructor; auto."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"assert (tr_expr (prog_comp_env cu) le dest r sl a tmps).\ninv TR.\ncontradiction.\nauto.\nexploit tr_simple_rvalue; eauto.\ndestruct dest.\nintros [SL1 [TY1 EV1]].\nsubst sl.\neconstructor; split.\nright; split.\napply star_refl.\ndestruct r; simpl; (contradiction || lia).\neconstructor; eauto.\ninstantiate (1 := tmps).\napply tr_top_val_val; auto.\nintros SL1.\nsubst sl.\neconstructor; split.\nright; split.\napply star_refl.\ndestruct r; simpl; (contradiction || lia).\neconstructor; eauto.\ninstantiate (1 := tmps).\napply tr_top_base.\nconstructor.\ninv MK."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : tr_expr (prog_comp_env cu) le dest r sl a tmps.","conclusion":"tr_expr (prog_comp_env cu) le dest r sl a tmps","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"inv TR.\ncontradiction.\nauto."},{"statement":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H0 : False) (a : expr) (v0 : val) (H : eval_simple_rvalue ge e m (Eval v0 (typeof a)) v) (tf : function) (tk : cont) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) For_val a k tk) (H2 : eval_expr tge e le m a v0) : tr_expr (prog_comp_env cu) le For_val (Eval v0 (typeof a)) nil a tmps.","conclusion":"tr_expr (prog_comp_env cu) le For_val (Eval v0 (typeof a)) nil a tmps","hypotheses":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H0 : False) (a : expr) (v0 : val) (H : eval_simple_rvalue ge e m (Eval v0 (typeof a)) v) (tf : function) (tk : cont) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) For_val a k tk) (H2 : eval_expr tge e le m a v0)","proofString":"contradiction."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (H1 : tr_expr (prog_comp_env cu) le dest r sl a tmps) : tr_expr (prog_comp_env cu) le dest r sl a tmps.","conclusion":"tr_expr (prog_comp_env cu) le dest r sl a tmps","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (H1 : tr_expr (prog_comp_env cu) le dest r sl a tmps)","proofString":"auto."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (H1 : tr_expr (prog_comp_env cu) le dest r sl a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (H1 : tr_expr (prog_comp_env cu) le dest r sl a tmps)","proofString":"exploit tr_simple_rvalue; eauto.\ndestruct dest.\nintros [SL1 [TY1 EV1]].\nsubst sl.\neconstructor; split.\nright; split.\napply star_refl.\ndestruct r; simpl; (contradiction || lia).\neconstructor; eauto.\ninstantiate (1 := tmps).\napply tr_top_val_val; auto.\nintros SL1.\nsubst sl.\neconstructor; split.\nright; split.\napply star_refl.\ndestruct r; simpl; (contradiction || lia).\neconstructor; eauto.\ninstantiate (1 := tmps).\napply tr_top_base.\nconstructor.\ninv MK."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (H1 : tr_expr (prog_comp_env cu) le dest r sl a tmps) : match dest with\n| For_val =>\n    sl = nil /\\ Csyntax.typeof r = typeof a /\\ eval_expr tge e le m a v\n| For_effects => sl = nil\n| For_set sd =>\n    exists b : expr,\n      sl = do_set sd b /\\\n      Csyntax.typeof r = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'.","conclusion":"match dest with\n| For_val =>\n    sl = nil /\\ Csyntax.typeof r = typeof a /\\ eval_expr tge e le m a v\n| For_effects => sl = nil\n| For_set sd =>\n    exists b : expr,\n      sl = do_set sd b /\\\n      Csyntax.typeof r = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (H1 : tr_expr (prog_comp_env cu) le dest r sl a tmps)","proofString":"destruct dest.\nintros [SL1 [TY1 EV1]].\nsubst sl.\neconstructor; split.\nright; split.\napply star_refl.\ndestruct r; simpl; (contradiction || lia).\neconstructor; eauto.\ninstantiate (1 := tmps).\napply tr_top_val_val; auto.\nintros SL1.\nsubst sl.\neconstructor; split.\nright; split.\napply star_refl.\ndestruct r; simpl; (contradiction || lia).\neconstructor; eauto.\ninstantiate (1 := tmps).\napply tr_top_base.\nconstructor.\ninv MK."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) For_val a k tk) (H1 : tr_expr (prog_comp_env cu) le For_val r sl a tmps) : sl = nil /\\ Csyntax.typeof r = typeof a /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'.","conclusion":"sl = nil /\\ Csyntax.typeof r = typeof a /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) For_val a k tk) (H1 : tr_expr (prog_comp_env cu) le For_val r sl a tmps)","proofString":"intros [SL1 [TY1 EV1]].\nsubst sl.\neconstructor; split.\nright; split.\napply star_refl.\ndestruct r; simpl; (contradiction || lia).\neconstructor; eauto.\ninstantiate (1 := tmps).\napply tr_top_val_val; auto."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) For_val a k tk) (H1 : tr_expr (prog_comp_env cu) le For_val r sl a tmps) (SL1 : sl = nil) (TY1 : Csyntax.typeof r = typeof a) (EV1 : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) For_val a k tk) (H1 : tr_expr (prog_comp_env cu) le For_val r sl a tmps) (SL1 : sl = nil) (TY1 : Csyntax.typeof r = typeof a) (EV1 : eval_expr tge e le m a v)","proofString":"subst sl.\neconstructor; split.\nright; split.\napply star_refl.\ndestruct r; simpl; (contradiction || lia).\neconstructor; eauto.\ninstantiate (1 := tmps).\napply tr_top_val_val; auto."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_val a k tk) (H1 : tr_expr (prog_comp_env cu) le For_val r nil a tmps) (TY1 : Csyntax.typeof r = typeof a) (EV1 : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist nil tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist nil tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist nil tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist nil tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_val a k tk) (H1 : tr_expr (prog_comp_env cu) le For_val r nil a tmps) (TY1 : Csyntax.typeof r = typeof a) (EV1 : eval_expr tge e le m a v)","proofString":"econstructor; split.\nright; split.\napply star_refl.\ndestruct r; simpl; (contradiction || lia).\neconstructor; eauto.\ninstantiate (1 := tmps).\napply tr_top_val_val; auto."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_val a k tk) (H1 : tr_expr (prog_comp_env cu) le For_val r nil a tmps) (TY1 : Csyntax.typeof r = typeof a) (EV1 : eval_expr tge e le m a v) : (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n measure (ExprState f r k e m))%nat.","conclusion":"(measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n measure (ExprState f r k e m))%nat","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_val a k tk) (H1 : tr_expr (prog_comp_env cu) le For_val r nil a tmps) (TY1 : Csyntax.typeof r = typeof a) (EV1 : eval_expr tge e le m a v)","proofString":"destruct r; simpl; (contradiction || lia)."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_val a k tk) (H1 : tr_expr (prog_comp_env cu) le For_val r nil a tmps) (TY1 : Csyntax.typeof r = typeof a) (EV1 : eval_expr tge e le m a v) : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (Csyntax.typeof r)) nil\n  a tmps.","conclusion":"tr_top (prog_comp_env cu) tge e le m For_val (Eval v (Csyntax.typeof r)) nil\n  a tmps","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_val a k tk) (H1 : tr_expr (prog_comp_env cu) le For_val r nil a tmps) (TY1 : Csyntax.typeof r = typeof a) (EV1 : eval_expr tge e le m a v)","proofString":"apply tr_top_val_val; auto."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) For_effects a k tk) (H1 : tr_expr (prog_comp_env cu) le For_effects r sl a tmps) : sl = nil ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'.","conclusion":"sl = nil ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) For_effects a k tk) (H1 : tr_expr (prog_comp_env cu) le For_effects r sl a tmps)","proofString":"intros SL1.\nsubst sl.\neconstructor; split.\nright; split.\napply star_refl.\ndestruct r; simpl; (contradiction || lia).\neconstructor; eauto.\ninstantiate (1 := tmps).\napply tr_top_base.\nconstructor."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) For_effects a k tk) (H1 : tr_expr (prog_comp_env cu) le For_effects r sl a tmps) (SL1 : sl = nil) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) For_effects a k tk) (H1 : tr_expr (prog_comp_env cu) le For_effects r sl a tmps) (SL1 : sl = nil)","proofString":"subst sl.\neconstructor; split.\nright; split.\napply star_refl.\ndestruct r; simpl; (contradiction || lia).\neconstructor; eauto.\ninstantiate (1 := tmps).\napply tr_top_base.\nconstructor."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_effects a k tk) (H1 : tr_expr (prog_comp_env cu) le For_effects r nil a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist nil tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist nil tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist nil tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist nil tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_effects a k tk) (H1 : tr_expr (prog_comp_env cu) le For_effects r nil a tmps)","proofString":"econstructor; split.\nright; split.\napply star_refl.\ndestruct r; simpl; (contradiction || lia).\neconstructor; eauto.\ninstantiate (1 := tmps).\napply tr_top_base.\nconstructor."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_effects a k tk) (H1 : tr_expr (prog_comp_env cu) le For_effects r nil a tmps) : (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n measure (ExprState f r k e m))%nat.","conclusion":"(measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n measure (ExprState f r k e m))%nat","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_effects a k tk) (H1 : tr_expr (prog_comp_env cu) le For_effects r nil a tmps)","proofString":"destruct r; simpl; (contradiction || lia)."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_effects a k tk) (H1 : tr_expr (prog_comp_env cu) le For_effects r nil a tmps) : tr_top (prog_comp_env cu) tge e le m For_effects (Eval v (Csyntax.typeof r))\n  nil a tmps.","conclusion":"tr_top (prog_comp_env cu) tge e le m For_effects (Eval v (Csyntax.typeof r))\n  nil a tmps","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_effects a k tk) (H1 : tr_expr (prog_comp_env cu) le For_effects r nil a tmps)","proofString":"apply tr_top_base.\nconstructor."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_effects a k tk) (H1 : tr_expr (prog_comp_env cu) le For_effects r nil a tmps) : tr_expr (prog_comp_env cu) le For_effects (Eval v (Csyntax.typeof r)) nil a\n  tmps.","conclusion":"tr_expr (prog_comp_env cu) le For_effects (Eval v (Csyntax.typeof r)) nil a\n  tmps","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects r nil a tmps) (MK : match_cont_exp (prog_comp_env cu) For_effects a k tk) (H1 : tr_expr (prog_comp_env cu) le For_effects r nil a tmps)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (sd : set_destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m (For_set sd) r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) (For_set sd) a k tk) (H1 : tr_expr (prog_comp_env cu) le (For_set sd) r sl a tmps) : (exists b : expr,\n   sl = do_set sd b /\\\n   Csyntax.typeof r = typeof b /\\ eval_expr tge e le m b v) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'.","conclusion":"(exists b : expr,\n   sl = do_set sd b /\\\n   Csyntax.typeof r = typeof b /\\ eval_expr tge e le m b v) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (Eval v (Csyntax.typeof r)) k e m) <\n    measure (ExprState f r k e m))%nat) /\\\n  match_states (ExprState f (Eval v (Csyntax.typeof r)) k e m) S2'","hypotheses":"(f : Csyntax.function) (r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : eval_simple_rvalue ge e m r v) (H0 : match r with\n| Eval _ _ => False\n| _ => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (sd : set_destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m (For_set sd) r sl a tmps) (MK : match_cont_exp (prog_comp_env cu) (For_set sd) a k tk) (H1 : tr_expr (prog_comp_env cu) le (For_set sd) r sl a tmps)","proofString":"inv MK."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Evalof l (Csyntax.typeof l)))\n  sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Evalof l (Csyntax.typeof l)))\n  sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"exploit tr_top_leftcontext; eauto.\nclear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\ninv H7; try congruence.\nexploit tr_simple_lvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl.\nexploit is_bitfield_access_sound; eauto.\nintros EQ; subst bf0.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\neconstructor; eauto.\nchange (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nred; intros; subst; elim H7; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Evalof l (Csyntax.typeof l)))\n  sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Evalof l (Csyntax.typeof l))\n     sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Evalof l (Csyntax.typeof l))\n     sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Evalof l (Csyntax.typeof l)))\n  sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"clear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\ninv H7; try congruence.\nexploit tr_simple_lvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl.\nexploit is_bitfield_access_sound; eauto.\nintros EQ; subst bf0.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\neconstructor; eauto.\nchange (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nred; intros; subst; elim H7; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Evalof l (Csyntax.typeof l))\n     sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Evalof l (Csyntax.typeof l))\n     sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\ninv H7; try congruence.\nexploit tr_simple_lvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl.\nexploit is_bitfield_access_sound; eauto.\nintros EQ; subst bf0.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\neconstructor; eauto.\nchange (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nred; intros; subst; elim H7; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Evalof l (Csyntax.typeof l)) sl1\n  a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Evalof l (Csyntax.typeof l)) sl1\n  a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)","proofString":"inv P.\ninv H2.\ninv H7; try congruence.\nexploit tr_simple_lvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl.\nexploit is_bitfield_access_sound; eauto.\nintros EQ; subst bf0.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\neconstructor; eauto.\nchange (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nred; intros; subst; elim H7; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Evalof l (Csyntax.typeof l)) sl1 a' tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Evalof l (Csyntax.typeof l)) sl1 a' tmp')","proofString":"inv H2.\ninv H7; try congruence.\nexploit tr_simple_lvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl.\nexploit is_bitfield_access_sound; eauto.\nintros EQ; subst bf0.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\neconstructor; eauto.\nchange (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nred; intros; subst; elim H7; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H7 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl3 a' tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist ((sl0 ++ sl3 ++ final dst' a') ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist ((sl0 ++ sl3 ++ final dst' a') ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist ((sl0 ++ sl3 ++ final dst' a') ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist ((sl0 ++ sl3 ++ final dst' a') ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H7 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl3 a' tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp')","proofString":"inv H7; try congruence.\nexploit tr_simple_lvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl.\nexploit is_bitfield_access_sound; eauto.\nintros EQ; subst bf0.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\neconstructor; eauto.\nchange (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nred; intros; subst; elim H7; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (bf0 : bitfield) (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             (make_set bf0 t0 a1 :: nil) ++\n             final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e le m)\n     t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             (make_set bf0 t0 a1 :: nil) ++\n             final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e le m)\n     t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             (make_set bf0 t0 a1 :: nil) ++\n             final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e le m)\n     t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             (make_set bf0 t0 a1 :: nil) ++\n             final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e le m)\n     t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (bf0 : bitfield) (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"exploit tr_simple_lvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl.\nexploit is_bitfield_access_sound; eauto.\nintros EQ; subst bf0.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\neconstructor; eauto.\nchange (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nred; intros; subst; elim H7; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (bf0 : bitfield) (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             (make_set bf0 t0 a1 :: nil) ++\n             final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e le m)\n     t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             (make_set bf0 t0 a1 :: nil) ++\n             final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e le m)\n     t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'.","conclusion":"sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             (make_set bf0 t0 a1 :: nil) ++\n             final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e le m)\n     t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             (make_set bf0 t0 a1 :: nil) ++\n             final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e le m)\n     t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (bf0 : bitfield) (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl.\nexploit is_bitfield_access_sound; eauto.\nintros EQ; subst bf0.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\neconstructor; eauto.\nchange (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nred; intros; subst; elim H7; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (bf0 : bitfield) (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL : sl0 = nil) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             (make_set bf0 t0 a1 :: nil) ++\n             final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e le m)\n     t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             (make_set bf0 t0 a1 :: nil) ++\n             final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e le m)\n     t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             (make_set bf0 t0 a1 :: nil) ++\n             final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e le m)\n     t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             (make_set bf0 t0 a1 :: nil) ++\n             final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e le m)\n     t S2' /\\\n   (measure (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) <\n    measure (ExprState f (C (Evalof l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (bf0 : bitfield) (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL : sl0 = nil) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf)","proofString":"subst sl0; simpl.\nexploit is_bitfield_access_sound; eauto.\nintros EQ; subst bf0.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\neconstructor; eauto.\nchange (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nred; intros; subst; elim H7; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (bf0 : bitfield) (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf0 t0 a1)\n           (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) tk))\n        e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf0 t0 a1)\n           (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) tk))\n        e le m) t S2' /\\\n   (esize (C (Eval v (Csyntax.typeof l))) + 1 <\n    esize (C (Evalof l (Csyntax.typeof l))) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf0 t0 a1)\n           (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) tk))\n        e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf0 t0 a1)\n           (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) tk))\n        e le m) t S2' /\\\n   (esize (C (Eval v (Csyntax.typeof l))) + 1 <\n    esize (C (Evalof l (Csyntax.typeof l))) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (bf0 : bitfield) (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf)","proofString":"exploit is_bitfield_access_sound; eauto.\nintros EQ; subst bf0.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\neconstructor; eauto.\nchange (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nred; intros; subst; elim H7; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (bf0 : bitfield) (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) : bf0 = bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf0 t0 a1)\n           (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) tk))\n        e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf0 t0 a1)\n           (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) tk))\n        e le m) t S2' /\\\n   (esize (C (Eval v (Csyntax.typeof l))) + 1 <\n    esize (C (Evalof l (Csyntax.typeof l))) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'.","conclusion":"bf0 = bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf0 t0 a1)\n           (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) tk))\n        e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf0 t0 a1)\n           (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) tk))\n        e le m) t S2' /\\\n   (esize (C (Eval v (Csyntax.typeof l))) + 1 <\n    esize (C (Evalof l (Csyntax.typeof l))) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (bf0 : bitfield) (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf)","proofString":"intros EQ; subst bf0.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\neconstructor; eauto.\nchange (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nred; intros; subst; elim H7; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf t0 a1)\n           (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) tk))\n        e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf t0 a1)\n           (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) tk))\n        e le m) t S2' /\\\n   (esize (C (Eval v (Csyntax.typeof l))) + 1 <\n    esize (C (Evalof l (Csyntax.typeof l))) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf t0 a1)\n           (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) tk))\n        e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf t0 a1)\n           (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) tk))\n        e le m) t S2' /\\\n   (esize (C (Eval v (Csyntax.typeof l))) + 1 <\n    esize (C (Evalof l (Csyntax.typeof l))) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v (Csyntax.typeof l))) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf)","proofString":"econstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\neconstructor; eauto.\nchange (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2) with (nil ++ (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nred; intros; subst; elim H7; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) : tr_expr (prog_comp_env cu) (PTree.set t0 v le) dst'\n  (Eval v (Csyntax.typeof l)) (final dst' (Etempvar t0 (Csyntax.typeof l)))\n  (Etempvar t0 (Csyntax.typeof l)) tmp'.","conclusion":"tr_expr (prog_comp_env cu) (PTree.set t0 v le) dst'\n  (Eval v (Csyntax.typeof l)) (final dst' (Etempvar t0 (Csyntax.typeof l)))\n  (Etempvar t0 (Csyntax.typeof l)) tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf)","proofString":"apply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) : typeof (Etempvar t0 (Csyntax.typeof l)) = Csyntax.typeof l.","conclusion":"typeof (Etempvar t0 (Csyntax.typeof l)) = Csyntax.typeof l","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) : forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v le) ! id) ->\neval_expr tge0 e0 le' m0 (Etempvar t0 (Csyntax.typeof l)) v.","conclusion":"forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v le) ! id) ->\neval_expr tge0 e0 le' m0 (Etempvar t0 (Csyntax.typeof l)) v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf)","proofString":"intros.\nconstructor.\nrewrite H7; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H7 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v le) ! id) : eval_expr tge0 e0 le' m0 (Etempvar t0 (Csyntax.typeof l)) v.","conclusion":"eval_expr tge0 e0 le' m0 (Etempvar t0 (Csyntax.typeof l)) v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H7 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v le) ! id)","proofString":"constructor.\nrewrite H7; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H7 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v le) ! id) : le' ! t0 = Some v.","conclusion":"le' ! t0 = Some v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H7 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v le) ! id)","proofString":"rewrite H7; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H7 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v le) ! id) : (PTree.set t0 v le) ! t0 = Some v.","conclusion":"(PTree.set t0 v le) ! t0 = Some v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H7 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v le) ! id)","proofString":"apply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) : forall id : ident, ~ In id tmp' -> (PTree.set t0 v le) ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> (PTree.set t0 v le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf)","proofString":"intros.\napply PTree.gso.\nred; intros; subst; elim H7; auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) (id : ident) (H7 : ~ In id tmp') : (PTree.set t0 v le) ! id = le ! id.","conclusion":"(PTree.set t0 v le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) (id : ident) (H7 : ~ In id tmp')","proofString":"apply PTree.gso.\nred; intros; subst; elim H7; auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) (id : ident) (H7 : ~ In id tmp') : id <> t0.","conclusion":"id <> t0","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) (id : ident) (H7 : ~ In id tmp')","proofString":"red; intros; subst; elim H7; auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf) : Csyntax.typeof (Eval v (Csyntax.typeof l)) =\nCsyntax.typeof (Evalof l (Csyntax.typeof l)).","conclusion":"Csyntax.typeof (Eval v (Csyntax.typeof l)) =\nCsyntax.typeof (Evalof l (Csyntax.typeof l))","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (t : trace) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v) (H3 : type_is_volatile (Csyntax.typeof l) = true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Evalof l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H2 : type_is_volatile (Csyntax.typeof l) = true) (H4 : In t0 tmp2) (H5 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY : Csyntax.typeof l = typeof a1) (EV : eval_lvalue tge e le m a1 b ofs bf)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqand r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqand r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"exploit tr_top_leftcontext; eauto.\nclear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqand r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqand r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqand r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqand r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"clear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqand r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqand r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Eseqand r1 r2 ty) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Eseqand r1 r2 ty) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)","proofString":"inv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Eseqand r1 r2 ty) sl1 a' tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Eseqand r1 r2 ty) sl1 a' tmp')","proofString":"inv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)))\n           (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)))\n           (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)))\n           (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)))\n           (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some true.","conclusion":"bool_val v (typeof a1) m = Some true","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m).","conclusion":"match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"eapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le For_val (Eparen r2 type_bool ty) sl3\n  (Etempvar t ty) tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_val (Eparen r2 type_bool ty) sl3\n  (Etempvar t ty) tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"apply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp'.","conclusion":"tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"apply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eparen r2 type_bool ty) = Csyntax.typeof (Eseqand r1 r2 ty).","conclusion":"Csyntax.typeof (Eparen r2 type_bool ty) = Csyntax.typeof (Eseqand r1 r2 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (makeif a1 (makeseq sl3) Sskip) (Kseqlist sl2 tk))\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (makeif a1 (makeseq sl3) Sskip) (Kseqlist sl2 tk))\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (makeif a1 (makeseq sl3) Sskip) (Kseqlist sl2 tk))\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (makeif a1 (makeseq sl3) Sskip) (Kseqlist sl2 tk))\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some true.","conclusion":"bool_val v (typeof a1) m = Some true","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m).","conclusion":"match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"eapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le For_effects (Eparen r2 type_bool ty) sl3 a'\n  tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_effects (Eparen r2 type_bool ty) sl3 a'\n  tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"apply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"apply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eparen r2 type_bool ty) = Csyntax.typeof (Eseqand r1 r2 ty).","conclusion":"Csyntax.typeof (Eparen r2 type_bool ty) = Csyntax.typeof (Eseqand r1 r2 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd0 =>\n    exists b : expr,\n      sl0 = do_set sd0 b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd0 =>\n    exists b : expr,\n      sl0 = do_set sd0 b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq sl3)\n              (makeseq (do_set sd (Econst_int Int.zero ty))))\n           (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq sl3)\n              (makeseq (do_set sd (Econst_int Int.zero ty))))\n           (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq sl3)\n              (makeseq (do_set sd (Econst_int Int.zero ty))))\n           (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq sl3)\n              (makeseq (do_set sd (Econst_int Int.zero ty))))\n           (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some true.","conclusion":"bool_val v (typeof a1) m = Some true","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m).","conclusion":"match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"eapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le (For_set sd) (Eparen r2 type_bool ty) sl3 a'\n  tmp'.","conclusion":"tr_expr (prog_comp_env cu) le (For_set sd) (Eparen r2 type_bool ty) sl3 a'\n  tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"apply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp'.","conclusion":"tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"apply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eparen r2 type_bool ty) = Csyntax.typeof (Eseqand r1 r2 ty).","conclusion":"Csyntax.typeof (Eparen r2 type_bool ty) = Csyntax.typeof (Eseqand r1 r2 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqand r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqand r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"exploit tr_top_leftcontext; eauto.\nclear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqand r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqand r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqand r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqand r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"clear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqand r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqand r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Eseqand r1 r2 ty) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Eseqand r1 r2 ty) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)","proofString":"inv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Eseqand r1 r2 ty) sl1 a' tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Eseqand r1 r2 ty) sl1 a' tmp')","proofString":"inv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)))\n           (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)))\n           (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)))\n           (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (Sset t (Econst_int Int.zero ty)))\n           (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some false.","conclusion":"bool_val v (typeof a1) m = Some false","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) (PTree.set t (Vint Int.zero) le) For_val\n  (Eval (Vint Int.zero) ty) nil (Etempvar t ty) tmp'.","conclusion":"tr_expr (prog_comp_env cu) (PTree.set t (Vint Int.zero) le) For_val\n  (Eval (Vint Int.zero) ty) nil (Etempvar t ty) tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive,\n In id tmp' -> le' ! id = (PTree.set t (Vint Int.zero) le) ! id) ->\neval_expr tge0 e0 le' m0 (Etempvar t ty) (Vint Int.zero).","conclusion":"forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive,\n In id tmp' -> le' ! id = (PTree.set t (Vint Int.zero) le) ! id) ->\neval_expr tge0 e0 le' m0 (Etempvar t ty) (Vint Int.zero)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"intros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.zero) le) ! id) : eval_expr tge0 e0 le' m0 (Etempvar t ty) (Vint Int.zero).","conclusion":"eval_expr tge0 e0 le' m0 (Etempvar t ty) (Vint Int.zero)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.zero) le) ! id)","proofString":"constructor.\nrewrite H2.\napply PTree.gss.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.zero) le) ! id) : le' ! t = Some (Vint Int.zero).","conclusion":"le' ! t = Some (Vint Int.zero)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.zero) le) ! id)","proofString":"rewrite H2.\napply PTree.gss.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.zero) le) ! id) : (PTree.set t (Vint Int.zero) le) ! t = Some (Vint Int.zero).","conclusion":"(PTree.set t (Vint Int.zero) le) ! t = Some (Vint Int.zero)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.zero) le) ! id)","proofString":"apply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.zero) le) ! id) : In t tmp'.","conclusion":"In t tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.zero) le) ! id)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident,\n~ In id tmp' -> (PTree.set t (Vint Int.zero) le) ! id = le ! id.","conclusion":"forall id : ident,\n~ In id tmp' -> (PTree.set t (Vint Int.zero) le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"intros.\napply PTree.gso.\ncongruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (id : ident) (H2 : ~ In id tmp') : (PTree.set t (Vint Int.zero) le) ! id = le ! id.","conclusion":"(PTree.set t (Vint Int.zero) le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (id : ident) (H2 : ~ In id tmp')","proofString":"apply PTree.gso.\ncongruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (id : ident) (H2 : ~ In id tmp') : id <> t.","conclusion":"id <> t","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (id : ident) (H2 : ~ In id tmp')","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eval (Vint Int.zero) ty) = Csyntax.typeof (Eseqand r1 r2 ty).","conclusion":"Csyntax.typeof (Eval (Vint Int.zero) ty) = Csyntax.typeof (Eseqand r1 r2 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 (makeseq sl3) Sskip :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (makeif a1 (makeseq sl3) Sskip) (Kseqlist sl2 tk))\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (makeif a1 (makeseq sl3) Sskip) (Kseqlist sl2 tk))\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (makeif a1 (makeseq sl3) Sskip) (Kseqlist sl2 tk))\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (makeif a1 (makeseq sl3) Sskip) (Kseqlist sl2 tk))\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some false.","conclusion":"bool_val v (typeof a1) m = Some false","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le For_effects (Eval (Vint Int.zero) ty) nil a'\n  tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_effects (Eval (Vint Int.zero) ty) nil a'\n  tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eval (Vint Int.zero) ty) = Csyntax.typeof (Eseqand r1 r2 ty).","conclusion":"Csyntax.typeof (Eval (Vint Int.zero) ty) = Csyntax.typeof (Eseqand r1 r2 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd0 =>\n    exists b : expr,\n      sl0 = do_set sd0 b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd0 =>\n    exists b : expr,\n      sl0 = do_set sd0 b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq sl3)\n               (makeseq (do_set sd (Econst_int Int.zero ty))) :: nil) ++ sl2)\n           tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq sl3)\n              (makeseq (do_set sd (Econst_int Int.zero ty))))\n           (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq sl3)\n              (makeseq (do_set sd (Econst_int Int.zero ty))))\n           (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq sl3)\n              (makeseq (do_set sd (Econst_int Int.zero ty))))\n           (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq sl3)\n              (makeseq (do_set sd (Econst_int Int.zero ty))))\n           (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) <\n    measure (ExprState f (C (Eseqand r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some false.","conclusion":"bool_val v (typeof a1) m = Some false","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m)\n  (State tf Sskip (Kseqlist (do_set sd (Econst_int Int.zero ty) ++ sl2) tk) e\n     le m).","conclusion":"match_states (ExprState f (C (Eval (Vint Int.zero) ty)) k e m)\n  (State tf Sskip (Kseqlist (do_set sd (Econst_int Int.zero ty) ++ sl2) tk) e\n     le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"eapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le (For_set sd) (Eval (Vint Int.zero) ty)\n  (do_set sd (Econst_int Int.zero ty)) a' tmp'.","conclusion":"tr_expr (prog_comp_env cu) le (For_set sd) (Eval (Vint Int.zero) ty)\n  (do_set sd (Econst_int Int.zero ty)) a' tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\nintros.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive, In id tmp' -> le' ! id = le ! id) ->\neval_expr tge0 e0 le' m0 (Econst_int Int.zero ty) (Vint Int.zero).","conclusion":"forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive, In id tmp' -> le' ! id = le ! id) ->\neval_expr tge0 e0 le' m0 (Econst_int Int.zero ty) (Vint Int.zero)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"intros.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = le ! id) : eval_expr tge0 e0 le' m0 (Econst_int Int.zero ty) (Vint Int.zero).","conclusion":"eval_expr tge0 e0 le' m0 (Econst_int Int.zero ty) (Vint Int.zero)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = le ! id)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eval (Vint Int.zero) ty) = Csyntax.typeof (Eseqand r1 r2 ty).","conclusion":"Csyntax.typeof (Eval (Vint Int.zero) ty) = Csyntax.typeof (Eseqand r1 r2 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqand r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqor r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqor r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"exploit tr_top_leftcontext; eauto.\nclear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqor r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqor r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqor r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqor r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"clear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqor r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqor r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Eseqor r1 r2 ty) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Eseqor r1 r2 ty) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)","proofString":"inv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Eseqor r1 r2 ty) sl1 a' tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Eseqor r1 r2 ty) sl1 a' tmp')","proofString":"inv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3))\n           (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3))\n           (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3))\n           (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3))\n           (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply star_one.\nconstructor.\nconstructor.\nreflexivity.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some true.","conclusion":"bool_val v (typeof a1) m = Some true","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) (PTree.set t (Vint Int.one) le) For_val\n  (Eval (Vint Int.one) ty) nil (Etempvar t ty) tmp'.","conclusion":"tr_expr (prog_comp_env cu) (PTree.set t (Vint Int.one) le) For_val\n  (Eval (Vint Int.one) ty) nil (Etempvar t ty) tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive,\n In id tmp' -> le' ! id = (PTree.set t (Vint Int.one) le) ! id) ->\neval_expr tge0 e0 le' m0 (Etempvar t ty) (Vint Int.one).","conclusion":"forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive,\n In id tmp' -> le' ! id = (PTree.set t (Vint Int.one) le) ! id) ->\neval_expr tge0 e0 le' m0 (Etempvar t ty) (Vint Int.one)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"intros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.one) le) ! id) : eval_expr tge0 e0 le' m0 (Etempvar t ty) (Vint Int.one).","conclusion":"eval_expr tge0 e0 le' m0 (Etempvar t ty) (Vint Int.one)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.one) le) ! id)","proofString":"constructor.\nrewrite H2.\napply PTree.gss.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.one) le) ! id) : le' ! t = Some (Vint Int.one).","conclusion":"le' ! t = Some (Vint Int.one)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.one) le) ! id)","proofString":"rewrite H2.\napply PTree.gss.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.one) le) ! id) : (PTree.set t (Vint Int.one) le) ! t = Some (Vint Int.one).","conclusion":"(PTree.set t (Vint Int.one) le) ! t = Some (Vint Int.one)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.one) le) ! id)","proofString":"apply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.one) le) ! id) : In t tmp'.","conclusion":"In t tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (PTree.set t (Vint Int.one) le) ! id)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident,\n~ In id tmp' -> (PTree.set t (Vint Int.one) le) ! id = le ! id.","conclusion":"forall id : ident,\n~ In id tmp' -> (PTree.set t (Vint Int.one) le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"intros.\napply PTree.gso.\ncongruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (id : ident) (H2 : ~ In id tmp') : (PTree.set t (Vint Int.one) le) ! id = le ! id.","conclusion":"(PTree.set t (Vint Int.one) le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (id : ident) (H2 : ~ In id tmp')","proofString":"apply PTree.gso.\ncongruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (id : ident) (H2 : ~ In id tmp') : id <> t.","conclusion":"id <> t","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (id : ident) (H2 : ~ In id tmp')","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eval (Vint Int.one) ty) = Csyntax.typeof (Eseqor r1 r2 ty).","conclusion":"Csyntax.typeof (Eval (Vint Int.one) ty) = Csyntax.typeof (Eseqor r1 r2 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (makeif a1 Sskip (makeseq sl3)) (Kseqlist sl2 tk))\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (makeif a1 Sskip (makeseq sl3)) (Kseqlist sl2 tk))\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (makeif a1 Sskip (makeseq sl3)) (Kseqlist sl2 tk))\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (makeif a1 Sskip (makeseq sl3)) (Kseqlist sl2 tk))\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\nreflexivity.\neapply match_exprstates; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\neconstructor; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some true.","conclusion":"bool_val v (typeof a1) m = Some true","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le For_effects (Eval (Vint Int.one) ty) nil a'\n  tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_effects (Eval (Vint Int.one) ty) nil a'\n  tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eval (Vint Int.one) ty) = Csyntax.typeof (Eseqor r1 r2 ty).","conclusion":"Csyntax.typeof (Eval (Vint Int.one) ty) = Csyntax.typeof (Eseqor r1 r2 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd0 =>\n    exists b : expr,\n      sl0 = do_set sd0 b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd0 =>\n    exists b : expr,\n      sl0 = do_set sd0 b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n              (makeseq sl3)) (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n              (makeseq sl3)) (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n              (makeseq sl3)) (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n              (makeseq sl3)) (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval (Vint Int.one) ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some true.","conclusion":"bool_val v (typeof a1) m = Some true","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m)\n  (State tf Sskip (Kseqlist (do_set sd (Econst_int Int.one ty) ++ sl2) tk) e\n     le m).","conclusion":"match_states (ExprState f (C (Eval (Vint Int.one) ty)) k e m)\n  (State tf Sskip (Kseqlist (do_set sd (Econst_int Int.one ty) ++ sl2) tk) e\n     le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"eapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\nintros.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le (For_set sd) (Eval (Vint Int.one) ty)\n  (do_set sd (Econst_int Int.one ty)) a' tmp'.","conclusion":"tr_expr (prog_comp_env cu) le (For_set sd) (Eval (Vint Int.one) ty)\n  (do_set sd (Econst_int Int.one ty)) a' tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\nintros.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive, In id tmp' -> le' ! id = le ! id) ->\neval_expr tge0 e0 le' m0 (Econst_int Int.one ty) (Vint Int.one).","conclusion":"forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive, In id tmp' -> le' ! id = le ! id) ->\neval_expr tge0 e0 le' m0 (Econst_int Int.one ty) (Vint Int.one)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"intros.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = le ! id) : eval_expr tge0 e0 le' m0 (Econst_int Int.one ty) (Vint Int.one).","conclusion":"eval_expr tge0 e0 le' m0 (Econst_int Int.one ty) (Vint Int.one)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl0 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = le ! id)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eval (Vint Int.one) ty) = Csyntax.typeof (Eseqor r1 r2 ty).","conclusion":"Csyntax.typeof (Eval (Vint Int.one) ty) = Csyntax.typeof (Eseqor r1 r2 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqor r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqor r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"exploit tr_top_leftcontext; eauto.\nclear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqor r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqor r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqor r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eseqor r1 r2 ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"clear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqor r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eseqor r1 r2 ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Eseqor r1 r2 ty) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Eseqor r1 r2 ty) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)","proofString":"inv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Eseqor r1 r2 ty) sl1 a' tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Eseqor r1 r2 ty) sl1 a' tmp')","proofString":"inv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3) :: nil) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3))\n           (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3))\n           (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3))\n           (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (Sset t (Econst_int Int.one ty)) (makeseq sl3))\n           (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some false.","conclusion":"bool_val v (typeof a1) m = Some false","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m).","conclusion":"match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"eapply match_exprstates; eauto.\napply S.\napply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le For_val (Eparen r2 type_bool ty) sl3\n  (Etempvar t ty) tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_val (Eparen r2 type_bool ty) sl3\n  (Etempvar t ty) tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"apply tr_paren_val with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp'.","conclusion":"tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"apply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eparen r2 type_bool ty) = Csyntax.typeof (Eseqor r1 r2 ty).","conclusion":"Csyntax.typeof (Eparen r2 type_bool ty) = Csyntax.typeof (Eseqor r1 r2 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDbase type_bool ty t)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ makeif a1 Sskip (makeseq sl3) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (makeif a1 Sskip (makeseq sl3)) (Kseqlist sl2 tk))\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (makeif a1 Sskip (makeseq sl3)) (Kseqlist sl2 tk))\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (makeif a1 Sskip (makeseq sl3)) (Kseqlist sl2 tk))\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (makeif a1 Sskip (makeseq sl3)) (Kseqlist sl2 tk))\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some false.","conclusion":"bool_val v (typeof a1) m = Some false","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m).","conclusion":"match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"eapply match_exprstates; eauto.\napply S.\napply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le For_effects (Eparen r2 type_bool ty) sl3 a'\n  tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_effects (Eparen r2 type_bool ty) sl3 a'\n  tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"apply tr_paren_effects with (a1 := a2); auto.\napply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"apply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eparen r2 type_bool ty) = Csyntax.typeof (Eseqor r1 r2 ty).","conclusion":"Csyntax.typeof (Eparen r2 type_bool ty) = Csyntax.typeof (Eseqor r1 r2 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H14 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd0 =>\n    exists b : expr,\n      sl0 = do_set sd0 b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd0 =>\n    exists b : expr,\n      sl0 = do_set sd0 b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n               (makeseq sl3) :: nil) ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n              (makeseq sl3)) (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n              (makeseq sl3)) (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n              (makeseq sl3)) (Kseqlist sl2 tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq\n           (makeif a1 (makeseq (do_set sd (Econst_int Int.one ty)))\n              (makeseq sl3)) (Kseqlist sl2 tk)) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 type_bool ty)) k e m) <\n    measure (ExprState f (C (Eseqor r1 r2 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some false.","conclusion":"bool_val v (typeof a1) m = Some false","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m).","conclusion":"match_states (ExprState f (C (Eparen r2 type_bool ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"eapply match_exprstates; eauto.\napply S.\napply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le (For_set sd) (Eparen r2 type_bool ty) sl3 a'\n  tmp'.","conclusion":"tr_expr (prog_comp_env cu) le (For_set sd) (Eparen r2 type_bool ty) sl3 a'\n  tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"apply tr_paren_set with (a1 := a2) (t := t); auto.\napply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp'.","conclusion":"tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"apply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eparen r2 type_bool ty) = Csyntax.typeof (Eseqor r1 r2 ty).","conclusion":"Csyntax.typeof (Eparen r2 type_bool ty) = Csyntax.typeof (Eseqor r1 r2 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eseqor r1 r2 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (t : ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H6 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H7 : tr_expr (prog_comp_env cu) le (For_set (SDcons type_bool ty t sd)) r2 sl3 a2\n  tmp2) (H8 : list_disjoint tmp1 tmp2) (H11 : incl tmp1 tmp') (H15 : incl tmp2 tmp') (H16 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Econdition r1 r2 r3 ty)) sl a\n  tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Econdition r1 r2 r3 ty)) sl a\n  tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"exploit tr_top_leftcontext; eauto.\nclear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Econdition r1 r2 r3 ty)) sl a\n  tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Econdition r1 r2 r3 ty) sl1 a'\n     tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Econdition r1 r2 r3 ty) sl1 a'\n     tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Econdition r1 r2 r3 ty)) sl a\n  tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"clear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Econdition r1 r2 r3 ty) sl1 a'\n     tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Econdition r1 r2 r3 ty) sl1 a'\n     tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Econdition r1 r2 r3 ty) sl1 a'\n  tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Econdition r1 r2 r3 ty) sl1 a'\n  tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)","proofString":"inv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Econdition r1 r2 r3 ty) sl1 a' tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Econdition r1 r2 r3 ty) sl1 a' tmp')","proofString":"inv H2.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b0 : expr,\n      sl0 = do_set sd b0 /\\\n      Csyntax.typeof r1 = typeof b0 /\\ eval_expr tge e le m b0 v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b0 : expr,\n      sl0 = do_set sd b0 /\\\n      Csyntax.typeof r1 = typeof b0 /\\ eval_expr tge e le m b0 v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"destruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 ty ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 ty ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some true.","conclusion":"bool_val v (typeof a1) m = Some true","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eparen r2 ty ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m).","conclusion":"match_states (ExprState f (C (Eparen r2 ty ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"eapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le For_val (Eparen r2 ty ty) sl3 \n  (Etempvar t ty) tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_val (Eparen r2 ty ty) sl3 \n  (Etempvar t ty) tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\napply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eparen r2 ty ty) = Csyntax.typeof (Econdition r1 r2 r3 ty).","conclusion":"Csyntax.typeof (Eparen r2 ty ty) = Csyntax.typeof (Econdition r1 r2 r3 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r3 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r3 ty ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r3 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r3 ty ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\nreflexivity.\nrewrite <- Kseqlist_app.\neapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some false.","conclusion":"bool_val v (typeof a1) m = Some false","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eparen r3 ty ty)) k e m)\n  (State tf Sskip (Kseqlist (sl4 ++ sl2) tk) e le m).","conclusion":"match_states (ExprState f (C (Eparen r3 ty ty)) k e m)\n  (State tf Sskip (Kseqlist (sl4 ++ sl2) tk) e le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"eapply match_exprstates; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le For_val (Eparen r3 ty ty) sl4 \n  (Etempvar t ty) tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_val (Eparen r3 ty ty) sl4 \n  (Etempvar t ty) tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\napply tr_expr_monotone with tmp3; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eparen r3 ty ty) = Csyntax.typeof (Econdition r1 r2 r3 ty).","conclusion":"Csyntax.typeof (Eparen r3 ty ty) = Csyntax.typeof (Econdition r1 r2 r3 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl0 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDbase ty ty t)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b0 : expr,\n      sl0 = do_set sd b0 /\\\n      Csyntax.typeof r1 = typeof b0 /\\ eval_expr tge e le m b0 v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b0 : expr,\n      sl0 = do_set sd b0 /\\\n      Csyntax.typeof r1 = typeof b0 /\\ eval_expr tge e le m b0 v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"destruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 ty ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 ty ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some true.","conclusion":"bool_val v (typeof a1) m = Some true","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eparen r2 ty ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m).","conclusion":"match_states (ExprState f (C (Eparen r2 ty ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le For_effects (Eparen r2 ty ty) sl3 a' tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_effects (Eparen r2 ty ty) sl3 a' tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\napply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eparen r2 ty ty) = Csyntax.typeof (Econdition r1 r2 r3 ty).","conclusion":"Csyntax.typeof (Eparen r2 ty ty) = Csyntax.typeof (Econdition r1 r2 r3 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r3 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r3 ty ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r3 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r3 ty ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r3 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r3 ty ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r3 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r3 ty ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some false.","conclusion":"bool_val v (typeof a1) m = Some false","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eparen r3 ty ty)) k e m)\n  (State tf Sskip (Kseqlist (sl4 ++ sl2) tk) e le m).","conclusion":"match_states (ExprState f (C (Eparen r3 ty ty)) k e m)\n  (State tf Sskip (Kseqlist (sl4 ++ sl2) tk) e le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le For_effects (Eparen r3 ty ty) sl4 a' tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_effects (Eparen r3 ty ty) sl4 a' tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\napply tr_expr_monotone with tmp3; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eparen r3 ty ty) = Csyntax.typeof (Econdition r1 r2 r3 ty).","conclusion":"Csyntax.typeof (Eparen r3 ty ty) = Csyntax.typeof (Econdition r1 r2 r3 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le For_effects r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le For_effects r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H13 : list_disjoint tmp1 tmp3) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (t : ident) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (t : ident) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (t : ident) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd0 =>\n    exists b0 : expr,\n      sl0 = do_set sd0 b0 /\\\n      Csyntax.typeof r1 = typeof b0 /\\ eval_expr tge e le m b0 v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd0 =>\n    exists b0 : expr,\n      sl0 = do_set sd0 b0 /\\\n      Csyntax.typeof r1 = typeof b0 /\\ eval_expr tge e le m b0 v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (t : ident) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp')","proofString":"intros [SL [TY EV]].\nsubst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (t : ident) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++ makeif a1 (makeseq sl3) (makeseq sl4) :: nil) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (t : ident) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 sl0 a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (SL : sl0 = nil) (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"subst sl0; simpl Kseqlist.\ndestruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen (if b then r2 else r3) ty ty)) k e m)\n    S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (b : bool) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some b) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"destruct b.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 ty ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r2 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r2 ty ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := true) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some true.","conclusion":"bool_val v (typeof a1) m = Some true","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eparen r2 ty ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m).","conclusion":"match_states (ExprState f (C (Eparen r2 ty ty)) k e m)\n  (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp2; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le (For_set sd) (Eparen r2 ty ty) sl3 a' tmp'.","conclusion":"tr_expr (prog_comp_env cu) le (For_set sd) (Eparen r2 ty ty) sl3 a' tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\napply tr_expr_monotone with tmp2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eparen r2 ty ty) = Csyntax.typeof (Econdition r1 r2 r3 ty).","conclusion":"Csyntax.typeof (Eparen r2 ty ty) = Csyntax.typeof (Econdition r1 r2 r3 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some true) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r3 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r3 ty ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (makeif a1 (makeseq sl3) (makeseq sl4)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eparen r3 ty ty)) k e m) <\n    measure (ExprState f (C (Econdition r1 r2 r3 ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eparen r3 ty ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (b := false) (v1 := v); auto.\ncongruence.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite <- Kseqlist_app.\neconstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : bool_val v (typeof a1) m = Some false.","conclusion":"bool_val v (typeof a1) m = Some false","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : match_states (ExprState f (C (Eparen r3 ty ty)) k e m)\n  (State tf Sskip (Kseqlist (sl4 ++ sl2) tk) e le m).","conclusion":"match_states (ExprState f (C (Eparen r3 ty ty)) k e m)\n  (State tf Sskip (Kseqlist (sl4 ++ sl2) tk) e le m)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\napply S.\neconstructor; eauto.\napply tr_expr_monotone with tmp3; eauto.\neconstructor; eauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : tr_expr (prog_comp_env cu) le (For_set sd) (Eparen r3 ty ty) sl4 a' tmp'.","conclusion":"tr_expr (prog_comp_env cu) le (For_set sd) (Eparen r3 ty ty) sl4 a' tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto.\napply tr_expr_monotone with tmp3; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v) : Csyntax.typeof (Eparen r3 ty ty) = Csyntax.typeof (Econdition r1 r2 r3 ty).","conclusion":"Csyntax.typeof (Eparen r3 ty ty) = Csyntax.typeof (Econdition r1 r2 r3 ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 r3 : Csyntax.expr) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (H1 : bool_val v (Csyntax.typeof r1) m = Some false) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Econdition r1 r2 r3 ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (t : ident) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val r1 nil a1 tmp1) (H8 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r2 sl3 a2 tmp2) (H9 : tr_expr (prog_comp_env cu) le (For_set (SDcons ty ty t sd)) r3 sl4 a3 tmp3) (H10 : list_disjoint tmp1 tmp2) (H11 : list_disjoint tmp1 tmp3) (H14 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (H19 : incl tmp3 tmp') (H20 : In t tmp') (TY : Csyntax.typeof r1 = typeof a1) (EV : eval_expr tge e le m a1 v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Eassign l r (Csyntax.typeof l))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Eassign l r (Csyntax.typeof l))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"exploit tr_top_leftcontext; eauto.\nclear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H4.\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nrewrite <- TY2; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue.\neauto.\neapply tr_expr_invariant with (le' := PTree.set t0 v1 le).\neauto.\nintros.\napply PTree.gso.\nintuition congruence.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\neconstructor.\neauto.\nrewrite <- TY2; eauto.\neapply star_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nconstructor.\napply PTree.gss.\nsimpl.\neapply cast_idempotent; eauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nrewrite typeof_make_assign_value; auto.\nintros.\neapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Eassign l r (Csyntax.typeof l))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eassign l r (Csyntax.typeof l))\n     sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eassign l r (Csyntax.typeof l))\n     sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Eassign l r (Csyntax.typeof l))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"clear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H4.\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nrewrite <- TY2; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue.\neauto.\neapply tr_expr_invariant with (le' := PTree.set t0 v1 le).\neauto.\nintros.\napply PTree.gso.\nintuition congruence.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\neconstructor.\neauto.\nrewrite <- TY2; eauto.\neapply star_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nconstructor.\napply PTree.gss.\nsimpl.\neapply cast_idempotent; eauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nrewrite typeof_make_assign_value; auto.\nintros.\neapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eassign l r (Csyntax.typeof l))\n     sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eassign l r (Csyntax.typeof l))\n     sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H4.\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nrewrite <- TY2; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue.\neauto.\neapply tr_expr_invariant with (le' := PTree.set t0 v1 le).\neauto.\nintros.\napply PTree.gso.\nintuition congruence.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\neconstructor.\neauto.\nrewrite <- TY2; eauto.\neapply star_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nconstructor.\napply PTree.gss.\nsimpl.\neapply cast_idempotent; eauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nrewrite typeof_make_assign_value; auto.\nintros.\neapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Eassign l r (Csyntax.typeof l))\n  sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Eassign l r (Csyntax.typeof l))\n  sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps)","proofString":"inv P.\ninv H4.\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nrewrite <- TY2; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue.\neauto.\neapply tr_expr_invariant with (le' := PTree.set t0 v1 le).\neauto.\nintros.\napply PTree.gso.\nintuition congruence.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\neconstructor.\neauto.\nrewrite <- TY2; eauto.\neapply star_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nconstructor.\napply PTree.gss.\nsimpl.\neapply cast_idempotent; eauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nrewrite typeof_make_assign_value; auto.\nintros.\neapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (H4 : tr_expr (prog_comp_env cu) le dst' (Eassign l r (Csyntax.typeof l)) sl1 a'\n  tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (H4 : tr_expr (prog_comp_env cu) le dst' (Eassign l r (Csyntax.typeof l)) sl1 a'\n  tmp')","proofString":"inv H4.\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nrewrite <- TY2; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue.\neauto.\neapply tr_expr_invariant with (le' := PTree.set t0 v1 le).\neauto.\nintros.\napply PTree.gso.\nintuition congruence.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\neconstructor.\neauto.\nrewrite <- TY2; eauto.\neapply star_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nconstructor.\napply PTree.gss.\nsimpl.\neapply cast_idempotent; eauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nrewrite typeof_make_assign_value; auto.\nintros.\neapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nrewrite <- TY2; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : match For_val with\n| For_val =>\n    sl3 = nil /\\ Csyntax.typeof r = typeof a2 /\\ eval_expr tge e le m a2 v\n| For_effects => sl3 = nil\n| For_set sd =>\n    exists b0 : expr,\n      sl3 = do_set sd b0 /\\\n      Csyntax.typeof r = typeof b0 /\\ eval_expr tge e le m b0 v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"match For_val with\n| For_val =>\n    sl3 = nil /\\ Csyntax.typeof r = typeof a2 /\\ eval_expr tge e le m a2 v\n| For_effects => sl3 = nil\n| For_set sd =>\n    exists b0 : expr,\n      sl3 = do_set sd b0 /\\\n      Csyntax.typeof r = typeof b0 /\\ eval_expr tge e le m b0 v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"intros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nrewrite <- TY2; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v)","proofString":"exploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nrewrite <- TY2; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) : sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v)","proofString":"intros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nrewrite <- TY2; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"assert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nrewrite <- TY2; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (H4 : bf0 = bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ make_assign bf0 a1 a2 :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (H4 : bf0 = bf)","proofString":"subst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nrewrite <- TY2; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (make_assign bf a1 a2) (Kseqlist sl2 tk)) e le m)\n     t S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (make_assign bf a1 a2) (Kseqlist sl2 tk)) e le m)\n     t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (make_assign bf a1 a2) (Kseqlist sl2 tk)) e le m)\n     t S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (make_assign bf a1 a2) (Kseqlist sl2 tk)) e le m)\n     t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nrewrite <- TY2; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : sem_cast v (typeof a2) (Csyntax.typeof l) m = Some v1.","conclusion":"sem_cast v (typeof a2) (Csyntax.typeof l) m = Some v1","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"rewrite <- TY2; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : tr_expr (prog_comp_env cu) le For_effects (Eval v' (Csyntax.typeof l)) nil a'\n  tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_effects (Eval v' (Csyntax.typeof l)) nil a'\n  tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : Csyntax.typeof (Eval v' (Csyntax.typeof l)) =\nCsyntax.typeof (Eassign l r (Csyntax.typeof l)).","conclusion":"Csyntax.typeof (Eval v' (Csyntax.typeof l)) =\nCsyntax.typeof (Eassign l r (Csyntax.typeof l))","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue.\neauto.\neapply tr_expr_invariant with (le' := PTree.set t0 v1 le).\neauto.\nintros.\napply PTree.gso.\nintuition congruence.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\neconstructor.\neauto.\nrewrite <- TY2; eauto.\neapply star_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nconstructor.\napply PTree.gss.\nsimpl.\neapply cast_idempotent; eauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nrewrite typeof_make_assign_value; auto.\nintros.\neapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : match For_val with\n| For_val =>\n    sl3 = nil /\\ Csyntax.typeof r = typeof a2 /\\ eval_expr tge e le m a2 v\n| For_effects => sl3 = nil\n| For_set sd =>\n    exists b0 : expr,\n      sl3 = do_set sd b0 /\\\n      Csyntax.typeof r = typeof b0 /\\ eval_expr tge e le m b0 v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"match For_val with\n| For_val =>\n    sl3 = nil /\\ Csyntax.typeof r = typeof a2 /\\ eval_expr tge e le m a2 v\n| For_effects => sl3 = nil\n| For_set sd =>\n    exists b0 : expr,\n      sl3 = do_set sd b0 /\\\n      Csyntax.typeof r = typeof b0 /\\ eval_expr tge e le m b0 v\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"intros [SL2 [TY2 EV2]].\nexploit tr_simple_lvalue.\neauto.\neapply tr_expr_invariant with (le' := PTree.set t0 v1 le).\neauto.\nintros.\napply PTree.gso.\nintuition congruence.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\neconstructor.\neauto.\nrewrite <- TY2; eauto.\neapply star_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nconstructor.\napply PTree.gss.\nsimpl.\neapply cast_idempotent; eauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nrewrite typeof_make_assign_value; auto.\nintros.\neapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v)","proofString":"exploit tr_simple_lvalue.\neauto.\neapply tr_expr_invariant with (le' := PTree.set t0 v1 le).\neauto.\nintros.\napply PTree.gso.\nintuition congruence.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\neconstructor.\neauto.\nrewrite <- TY2; eauto.\neapply star_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nconstructor.\napply PTree.gss.\nsimpl.\neapply cast_idempotent; eauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nrewrite typeof_make_assign_value; auto.\nintros.\neapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (x : ident) (H4 : In x tmp1) : (PTree.set t0 v1 le) ! x = le ! x.","conclusion":"(PTree.set t0 v1 le) ! x = le ! x","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (x : ident) (H4 : In x tmp1)","proofString":"apply PTree.gso.\nintuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (x : ident) (H4 : In x tmp1) : x <> t0.","conclusion":"x <> t0","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (x : ident) (H4 : In x tmp1)","proofString":"intuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf)","proofString":"assert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\neconstructor.\neauto.\nrewrite <- TY2; eauto.\neapply star_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nconstructor.\napply PTree.gss.\nsimpl.\neapply cast_idempotent; eauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nrewrite typeof_make_assign_value; auto.\nintros.\neapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (H4 : bf0 = bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             Sset t0 (Ecast a2 (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (H4 : bf0 = bf)","proofString":"subst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\neconstructor.\neauto.\nrewrite <- TY2; eauto.\neapply star_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nconstructor.\napply PTree.gss.\nsimpl.\neapply cast_idempotent; eauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nrewrite typeof_make_assign_value; auto.\nintros.\neapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (Sset t0 (Ecast a2 (Csyntax.typeof l)))\n           (Kseq (make_assign bf a1 (Etempvar t0 (Csyntax.typeof l)))\n              (Kseqlist\n                 (final dst'\n                    (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) ++\n                  sl2) tk))) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (Sset t0 (Ecast a2 (Csyntax.typeof l)))\n           (Kseq (make_assign bf a1 (Etempvar t0 (Csyntax.typeof l)))\n              (Kseqlist\n                 (final dst'\n                    (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) ++\n                  sl2) tk))) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (Sset t0 (Ecast a2 (Csyntax.typeof l)))\n           (Kseq (make_assign bf a1 (Etempvar t0 (Csyntax.typeof l)))\n              (Kseqlist\n                 (final dst'\n                    (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) ++\n                  sl2) tk))) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (Sset t0 (Ecast a2 (Csyntax.typeof l)))\n           (Kseq (make_assign bf a1 (Etempvar t0 (Csyntax.typeof l)))\n              (Kseqlist\n                 (final dst'\n                    (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) ++\n                  sl2) tk))) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Eassign l r (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v' (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\neconstructor.\neauto.\nrewrite <- TY2; eauto.\neapply star_left.\nconstructor.\napply star_one.\neapply step_make_assign; eauto.\nconstructor.\napply PTree.gss.\nsimpl.\neapply cast_idempotent; eauto.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nrewrite typeof_make_assign_value; auto.\nintros.\neapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) : sem_cast v1 (Csyntax.typeof l) (Csyntax.typeof l) m = Some v1.","conclusion":"sem_cast v1 (Csyntax.typeof l) (Csyntax.typeof l) m = Some v1","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf)","proofString":"eapply cast_idempotent; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) : tr_expr (prog_comp_env cu) (PTree.set t0 v1 le) dst'\n  (Eval v' (Csyntax.typeof l))\n  (final dst' (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))))\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp'.","conclusion":"tr_expr (prog_comp_env cu) (PTree.set t0 v1 le) dst'\n  (Eval v' (Csyntax.typeof l))\n  (final dst' (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))))\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf)","proofString":"apply tr_val_gen.\nrewrite typeof_make_assign_value; auto.\nintros.\neapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) : typeof (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) =\nCsyntax.typeof l.","conclusion":"typeof (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) =\nCsyntax.typeof l","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf)","proofString":"rewrite typeof_make_assign_value; auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) : forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v1 le) ! id) ->\neval_expr tge0 e0 le' m0\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) v'.","conclusion":"forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v1 le) ! id) ->\neval_expr tge0 e0 le' m0\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) v'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf)","proofString":"intros.\neapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H4 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v1 le) ! id) : eval_expr tge0 e0 le' m0\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) v'.","conclusion":"eval_expr tge0 e0 le' m0\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) v'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H4 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v1 le) ! id)","proofString":"eapply make_assign_value_sound; eauto.\nconstructor.\nrewrite H4; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H4 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v1 le) ! id) : eval_expr tge0 e0 le' m0 (Etempvar t0 (Csyntax.typeof l)) v1.","conclusion":"eval_expr tge0 e0 le' m0 (Etempvar t0 (Csyntax.typeof l)) v1","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H4 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v1 le) ! id)","proofString":"constructor.\nrewrite H4; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H4 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v1 le) ! id) : le' ! t0 = Some v1.","conclusion":"le' ! t0 = Some v1","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H4 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v1 le) ! id)","proofString":"rewrite H4; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H4 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v1 le) ! id) : (PTree.set t0 v1 le) ! t0 = Some v1.","conclusion":"(PTree.set t0 v1 le) ! t0 = Some v1","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H4 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t0 v1 le) ! id)","proofString":"apply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) : forall id : ident, ~ In id tmp' -> (PTree.set t0 v1 le) ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> (PTree.set t0 v1 le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf)","proofString":"intros.\napply PTree.gso.\nintuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (id : ident) (H4 : ~ In id tmp') : (PTree.set t0 v1 le) ! id = le ! id.","conclusion":"(PTree.set t0 v1 le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (id : ident) (H4 : ~ In id tmp')","proofString":"apply PTree.gso.\nintuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (id : ident) (H4 : ~ In id tmp') : id <> t0.","conclusion":"id <> t0","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) (id : ident) (H4 : ~ In id tmp')","proofString":"intuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf) : Csyntax.typeof (Eval v' (Csyntax.typeof l)) =\nCsyntax.typeof (Eassign l r (Csyntax.typeof l)).","conclusion":"Csyntax.typeof (Eval v' (Csyntax.typeof l)) =\nCsyntax.typeof (Eassign l r (Csyntax.typeof l))","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (l r : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v v1 : val) (t : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : eval_simple_rvalue ge e m r v) (H2 : sem_cast v (Csyntax.typeof r) (Csyntax.typeof l) m = Some v1) (H3 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v1 t m' v') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3\n  (make_assign_value bf (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eassign l r (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (H8 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H9 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H10 : incl tmp1 tmp') (H11 : incl tmp2 tmp') (H12 : list_disjoint tmp1 tmp2) (H13 : In t0 tmp') (H14 : ~ In t0 tmp1) (H15 : ~ In t0 tmp2) (H23 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e (PTree.set t0 v1 le) m a1 b ofs bf)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Eassignop op l r tyres (Csyntax.typeof l))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Eassignop op l r tyres (Csyntax.typeof l))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"exploit tr_top_leftcontext; eauto.\nclear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H4.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Eassignop op l r tyres (Csyntax.typeof l))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst'\n     (Eassignop op l r tyres (Csyntax.typeof l)) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' =\n    Csyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst'\n     (Eassignop op l r tyres (Csyntax.typeof l)) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' =\n    Csyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Eassignop op l r tyres (Csyntax.typeof l))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"clear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H4.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst'\n     (Eassignop op l r tyres (Csyntax.typeof l)) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' =\n    Csyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst'\n     (Eassignop op l r tyres (Csyntax.typeof l)) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' =\n    Csyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H4.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst'\n  (Eassignop op l r tyres (Csyntax.typeof l)) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst'\n  (Eassignop op l r tyres (Csyntax.typeof l)) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)","proofString":"inv P.\ninv H4.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H4 : tr_expr (prog_comp_env cu) le dst'\n  (Eassignop op l r tyres (Csyntax.typeof l)) sl1 a' tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H4 : tr_expr (prog_comp_env cu) le dst'\n  (Eassignop op l r tyres (Csyntax.typeof l)) sl1 a' tmp')","proofString":"inv H4.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H13 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H14 : list_disjoint tmp1 tmp2) (H15 : list_disjoint tmp1 tmp3) (H18 : list_disjoint tmp2 tmp3) (H22 : incl tmp1 tmp') (H23 : incl tmp2 tmp') (H24 : incl tmp3 tmp') (H25 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H13 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H14 : list_disjoint tmp1 tmp2) (H15 : list_disjoint tmp1 tmp3) (H18 : list_disjoint tmp2 tmp3) (H22 : incl tmp1 tmp') (H23 : incl tmp2 tmp') (H24 : incl tmp3 tmp') (H25 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"exploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H13 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H14 : list_disjoint tmp1 tmp2) (H15 : list_disjoint tmp1 tmp3) (H18 : list_disjoint tmp2 tmp3) (H22 : incl tmp1 tmp') (H23 : incl tmp2 tmp') (H24 : incl tmp3 tmp') (H25 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H13 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H14 : list_disjoint tmp1 tmp2) (H15 : list_disjoint tmp1 tmp3) (H18 : list_disjoint tmp2 tmp3) (H22 : incl tmp1 tmp') (H23 : incl tmp2 tmp') (H24 : incl tmp3 tmp') (H25 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"intros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H13 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H14 : list_disjoint tmp1 tmp2) (H15 : list_disjoint tmp1 tmp3) (H18 : list_disjoint tmp2 tmp3) (H22 : incl tmp1 tmp') (H23 : incl tmp2 tmp') (H24 : incl tmp3 tmp') (H25 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H13 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H14 : list_disjoint tmp1 tmp2) (H15 : list_disjoint tmp1 tmp3) (H18 : list_disjoint tmp2 tmp3) (H22 : incl tmp1 tmp') (H23 : incl tmp2 tmp') (H24 : incl tmp3 tmp') (H25 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H13 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H14 : list_disjoint tmp1 tmp2) (H15 : list_disjoint tmp1 tmp3) (H18 : list_disjoint tmp2 tmp3) (H22 : incl tmp1 tmp') (H23 : incl tmp2 tmp') (H24 : incl tmp3 tmp') (H25 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : match For_val with\n| For_val =>\n    sl3 = nil /\\ Csyntax.typeof r = typeof a2 /\\ eval_expr tge e le m a2 v2\n| For_effects => sl3 = nil\n| For_set sd =>\n    exists b0 : expr,\n      sl3 = do_set sd b0 /\\\n      Csyntax.typeof r = typeof b0 /\\ eval_expr tge e le m b0 v2\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"match For_val with\n| For_val =>\n    sl3 = nil /\\ Csyntax.typeof r = typeof a2 /\\ eval_expr tge e le m a2 v2\n| For_effects => sl3 = nil\n| For_set sd =>\n    exists b0 : expr,\n      sl3 = do_set sd b0 /\\\n      Csyntax.typeof r = typeof b0 /\\ eval_expr tge e le m b0 v2\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H13 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H14 : list_disjoint tmp1 tmp2) (H15 : list_disjoint tmp1 tmp3) (H18 : list_disjoint tmp2 tmp3) (H22 : incl tmp1 tmp') (H23 : incl tmp2 tmp') (H24 : incl tmp3 tmp') (H25 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"intros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H13 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H14 : list_disjoint tmp1 tmp2) (H15 : list_disjoint tmp1 tmp3) (H18 : list_disjoint tmp2 tmp3) (H22 : incl tmp1 tmp') (H23 : incl tmp2 tmp') (H24 : incl tmp3 tmp') (H25 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v2) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ sl4 ++ make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H13 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H14 : list_disjoint tmp1 tmp2) (H15 : list_disjoint tmp1 tmp3) (H18 : list_disjoint tmp2 tmp3) (H22 : incl tmp1 tmp') (H23 : incl tmp2 tmp') (H24 : incl tmp3 tmp') (H25 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v2)","proofString":"exploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H13 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H14 : list_disjoint tmp1 tmp2) (H15 : list_disjoint tmp1 tmp3) (H18 : list_disjoint tmp2 tmp3) (H22 : incl tmp1 tmp') (H23 : incl tmp2 tmp') (H24 : incl tmp3 tmp') (H25 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v2) (le' : temp_env) (EXEC : star step1 tge\n  (State tf Sskip\n     (Kseqlist sl4\n        (Kseqlist\n           ((make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++ sl2) tk))\n     e le m) t\n  (State tf Sskip\n     (Kseqlist ((make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++ sl2)\n        tk) e le' m)) (EV3 : eval_expr tge e le' m a3 v1) (TY3 : typeof a3 = typeof a1) (INV : forall x : ident, ~ In x tmp3 -> le' ! x = le ! x) : (0 < esize (C (Eassignop op l r tyres (Csyntax.typeof l))) + 1)%nat.","conclusion":"(0 < esize (C (Eassignop op l r tyres (Csyntax.typeof l))) + 1)%nat","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H13 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H14 : list_disjoint tmp1 tmp2) (H15 : list_disjoint tmp1 tmp3) (H18 : list_disjoint tmp2 tmp3) (H22 : incl tmp1 tmp') (H23 : incl tmp2 tmp') (H24 : incl tmp3 tmp') (H25 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v2) (le' : temp_env) (EXEC : star step1 tge\n  (State tf Sskip\n     (Kseqlist sl4\n        (Kseqlist\n           ((make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++ sl2) tk))\n     e le m) t\n  (State tf Sskip\n     (Kseqlist ((make_assign bf0 a1 (Ebinop op a3 a2 tyres) :: nil) ++ sl2)\n        tk) e le' m)) (EV3 : eval_expr tge e le' m a3 v1) (TY3 : typeof a3 = typeof a1) (INV : forall x : ident, ~ In x tmp3 -> le' ! x = le ! x)","proofString":"lia."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H12 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H13 : list_disjoint tmp1 tmp2) (H14 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H16 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : incl tmp3 tmp') (H19 : In t0 tmp') (H22 : ~ In t0 tmp1) (H26 : ~ In t0 tmp2) (H27 : ~ In t0 tmp3) (H29 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H12 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H13 : list_disjoint tmp1 tmp2) (H14 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H16 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : incl tmp3 tmp') (H19 : In t0 tmp') (H22 : ~ In t0 tmp1) (H26 : ~ In t0 tmp2) (H27 : ~ In t0 tmp3) (H29 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"exploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H12 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H13 : list_disjoint tmp1 tmp2) (H14 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H16 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : incl tmp3 tmp') (H19 : In t0 tmp') (H22 : ~ In t0 tmp1) (H26 : ~ In t0 tmp2) (H27 : ~ In t0 tmp3) (H29 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H12 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H13 : list_disjoint tmp1 tmp2) (H14 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H16 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : incl tmp3 tmp') (H19 : In t0 tmp') (H22 : ~ In t0 tmp1) (H26 : ~ In t0 tmp2) (H27 : ~ In t0 tmp3) (H29 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"intros [SL1 [TY1 EV1]].\nexploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H12 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H13 : list_disjoint tmp1 tmp2) (H14 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H16 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : incl tmp3 tmp') (H19 : In t0 tmp') (H22 : ~ In t0 tmp1) (H26 : ~ In t0 tmp2) (H27 : ~ In t0 tmp3) (H29 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H12 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H13 : list_disjoint tmp1 tmp2) (H14 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H16 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : incl tmp3 tmp') (H19 : In t0 tmp') (H22 : ~ In t0 tmp1) (H26 : ~ In t0 tmp2) (H27 : ~ In t0 tmp3) (H29 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H12 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H13 : list_disjoint tmp1 tmp2) (H14 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H16 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : incl tmp3 tmp') (H19 : In t0 tmp') (H22 : ~ In t0 tmp1) (H26 : ~ In t0 tmp2) (H27 : ~ In t0 tmp3) (H29 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : match For_val with\n| For_val =>\n    sl3 = nil /\\ Csyntax.typeof r = typeof a2 /\\ eval_expr tge e le m a2 v2\n| For_effects => sl3 = nil\n| For_set sd =>\n    exists b0 : expr,\n      sl3 = do_set sd b0 /\\\n      Csyntax.typeof r = typeof b0 /\\ eval_expr tge e le m b0 v2\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"match For_val with\n| For_val =>\n    sl3 = nil /\\ Csyntax.typeof r = typeof a2 /\\ eval_expr tge e le m a2 v2\n| For_effects => sl3 = nil\n| For_set sd =>\n    exists b0 : expr,\n      sl3 = do_set sd b0 /\\\n      Csyntax.typeof r = typeof b0 /\\ eval_expr tge e le m b0 v2\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H12 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H13 : list_disjoint tmp1 tmp2) (H14 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H16 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : incl tmp3 tmp') (H19 : In t0 tmp') (H22 : ~ In t0 tmp1) (H26 : ~ In t0 tmp2) (H27 : ~ In t0 tmp3) (H29 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"intros [SL2 [TY2 EV2]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H12 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H13 : list_disjoint tmp1 tmp2) (H14 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H16 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : incl tmp3 tmp') (H19 : In t0 tmp') (H22 : ~ In t0 tmp1) (H26 : ~ In t0 tmp2) (H27 : ~ In t0 tmp3) (H29 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v2) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             sl4 ++\n             Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure\n      (ExprState f (C (Eassignop op l r tyres (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r sl3 a2 tmp2) (H12 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H13 : list_disjoint tmp1 tmp2) (H14 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H16 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : incl tmp3 tmp') (H19 : In t0 tmp') (H22 : ~ In t0 tmp1) (H26 : ~ In t0 tmp2) (H27 : ~ In t0 tmp3) (H29 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (SL2 : sl3 = nil) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v2)","proofString":"exploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst; simpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass.\nrewrite Kseqlist_app.\neexact EXEC.\nsimpl.\nlia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H12 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H13 : list_disjoint tmp1 tmp2) (H14 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H16 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : incl tmp3 tmp') (H19 : In t0 tmp') (H22 : ~ In t0 tmp1) (H26 : ~ In t0 tmp2) (H27 : ~ In t0 tmp3) (H29 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v2) (le' : temp_env) (EXEC : star step1 tge\n  (State tf Sskip\n     (Kseqlist sl4\n        (Kseqlist\n           ((Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk)) e le m) t\n  (State tf Sskip\n     (Kseqlist\n        ((Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n          :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n             :: final dst'\n                  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n         sl2) tk) e le' m)) (EV3 : eval_expr tge e le' m a3 v1) (TY3 : typeof a3 = typeof a1) (INV : forall x : ident, ~ In x tmp3 -> le' ! x = le ! x) : (0 < esize (C (Eassignop op l r tyres (Csyntax.typeof l))) + 1)%nat.","conclusion":"(0 < esize (C (Eassignop op l r tyres (Csyntax.typeof l))) + 1)%nat","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (op : binary_operation) (l r : Csyntax.expr) (tyres : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (H2 : eval_simple_rvalue ge e m r v2) (H3 : match\n  sem_binary_operation ge op v1 (Csyntax.typeof l) v2 (Csyntax.typeof r) m\nwith\n| Some v3 =>\n    match sem_cast v3 tyres (Csyntax.typeof l) m with\n    | Some v4 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v4 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (bf0 : bitfield) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3\n  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l))) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' =\nCsyntax.typeof (Eassignop op l r tyres (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (a2 : expr) (tmp2 : list ident) (sl4 : list statement) (a3 : expr) (tmp3 : list ident) (H10 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H11 : tr_expr (prog_comp_env cu) le For_val r nil a2 tmp2) (H12 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl4 a3 tmp3) (H13 : list_disjoint tmp1 tmp2) (H14 : list_disjoint tmp1 tmp3) (H15 : list_disjoint tmp2 tmp3) (H16 : incl tmp1 tmp') (H17 : incl tmp2 tmp') (H18 : incl tmp3 tmp') (H19 : In t0 tmp') (H22 : ~ In t0 tmp1) (H26 : ~ In t0 tmp2) (H27 : ~ In t0 tmp3) (H29 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (TY2 : Csyntax.typeof r = typeof a2) (EV2 : eval_expr tge e le m a2 v2) (le' : temp_env) (EXEC : star step1 tge\n  (State tf Sskip\n     (Kseqlist sl4\n        (Kseqlist\n           ((Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n             :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n                :: final dst'\n                     (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n            sl2) tk)) e le m) t\n  (State tf Sskip\n     (Kseqlist\n        ((Sset t0 (Ecast (Ebinop op a3 a2 tyres) (Csyntax.typeof l))\n          :: make_assign bf0 a1 (Etempvar t0 (Csyntax.typeof l))\n             :: final dst'\n                  (make_assign_value bf0 (Etempvar t0 (Csyntax.typeof l)))) ++\n         sl2) tk) e le' m)) (EV3 : eval_expr tge e le' m a3 v1) (TY3 : typeof a3 = typeof a1) (INV : forall x : ident, ~ In x tmp3 -> le' ! x = le ! x)","proofString":"lia."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' /\\\n   (measure (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' /\\\n   (measure (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"exploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_lvalue.\neauto.\neapply tr_expr_invariant with (le' := PTree.set t v1 le).\neauto.\nintros.\napply PTree.gso.\nintuition congruence.\nintros [SL2 [TY2 EV2]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_four.\nconstructor.\neapply step_make_set; eauto.\nconstructor.\neapply step_make_assign; eauto.\nunfold transl_incrdecr.\ndestruct id; simpl in H2.\neconstructor.\nconstructor.\napply PTree.gss.\nconstructor.\nrewrite comp_env_preserved; simpl; eauto.\neconstructor.\nconstructor.\napply PTree.gss.\nconstructor.\nrewrite comp_env_preserved; simpl; eauto.\ndestruct id; auto.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nauto.\nintros.\neconstructor; eauto.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' /\\\n   (measure (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') S2'.","conclusion":"sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' /\\\n   (measure (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"intros [SL1 [TY1 EV1]].\nexploit tr_simple_lvalue.\neauto.\neapply tr_expr_invariant with (le' := PTree.set t v1 le).\neauto.\nintros.\napply PTree.gso.\nintuition congruence.\nintros [SL2 [TY2 EV2]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_four.\nconstructor.\neapply step_make_set; eauto.\nconstructor.\neapply step_make_assign; eauto.\nunfold transl_incrdecr.\ndestruct id; simpl in H2.\neconstructor.\nconstructor.\napply PTree.gss.\nconstructor.\nrewrite comp_env_preserved; simpl; eauto.\neconstructor.\nconstructor.\napply PTree.gss.\nconstructor.\nrewrite comp_env_preserved; simpl; eauto.\ndestruct id; auto.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nauto.\nintros.\neconstructor; eauto.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' /\\\n   (measure (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' /\\\n   (measure (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"exploit tr_simple_lvalue.\neauto.\neapply tr_expr_invariant with (le' := PTree.set t v1 le).\neauto.\nintros.\napply PTree.gso.\nintuition congruence.\nintros [SL2 [TY2 EV2]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_four.\nconstructor.\neapply step_make_set; eauto.\nconstructor.\neapply step_make_assign; eauto.\nunfold transl_incrdecr.\ndestruct id; simpl in H2.\neconstructor.\nconstructor.\napply PTree.gss.\nconstructor.\nrewrite comp_env_preserved; simpl; eauto.\neconstructor.\nconstructor.\napply PTree.gss.\nconstructor.\nrewrite comp_env_preserved; simpl; eauto.\ndestruct id; auto.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nauto.\nintros.\neconstructor; eauto.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (x : ident) (H5 : In x tmp1) : (PTree.set t v1 le) ! x = le ! x.","conclusion":"(PTree.set t v1 le) ! x = le ! x","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (x : ident) (H5 : In x tmp1)","proofString":"apply PTree.gso.\nintuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (x : ident) (H5 : In x tmp1) : x <> t.","conclusion":"x <> t","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (x : ident) (H5 : In x tmp1)","proofString":"intuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (SL2 : sl0 = nil) (TY2 : Csyntax.typeof l = typeof a1) (EV2 : eval_lvalue tge e (PTree.set t v1 le) m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' /\\\n   (measure (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' /\\\n   (measure (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (SL2 : sl0 = nil) (TY2 : Csyntax.typeof l = typeof a1) (EV2 : eval_lvalue tge e (PTree.set t v1 le) m a1 b ofs bf)","proofString":"assert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_four.\nconstructor.\neapply step_make_set; eauto.\nconstructor.\neapply step_make_assign; eauto.\nunfold transl_incrdecr.\ndestruct id; simpl in H2.\neconstructor.\nconstructor.\napply PTree.gss.\nconstructor.\nrewrite comp_env_preserved; simpl; eauto.\neconstructor.\nconstructor.\napply PTree.gss.\nconstructor.\nrewrite comp_env_preserved; simpl; eauto.\ndestruct id; auto.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nauto.\nintros.\neconstructor; eauto.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (SL2 : sl0 = nil) (TY2 : Csyntax.typeof l = typeof a1) (EV2 : eval_lvalue tge e (PTree.set t v1 le) m a1 b ofs bf) (H5 : bf0 = bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' /\\\n   (measure (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) (t1 ** t2) S2' /\\\n   (measure (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v1 (Csyntax.typeof l))) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 v2 v3 : val) (t1 t2 : trace) (m' : mem) (v' : val) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H4 : Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v') (H3 : sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m = Some v3) (H2 : sem_incrdecr ge id v1 (Csyntax.typeof l) m = Some v2) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t1 v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H9 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H10 : incl tmp1 tmp') (H11 : In t tmp') (H14 : ~ In t tmp1) (H19 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (SL2 : sl0 = nil) (TY2 : Csyntax.typeof l = typeof a1) (EV2 : eval_lvalue tge e (PTree.set t v1 le) m a1 b ofs bf) (H5 : bf0 = bf)","proofString":"subst; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_four.\nconstructor.\neapply step_make_set; eauto.\nconstructor.\neapply step_make_assign; eauto.\nunfold transl_incrdecr.\ndestruct id; simpl in H2.\neconstructor.\nconstructor.\napply PTree.gss.\nconstructor.\nrewrite comp_env_preserved; simpl; eauto.\neconstructor.\nconstructor.\napply PTree.gss.\nconstructor.\nrewrite comp_env_preserved; simpl; eauto.\ndestruct id; auto.\ntraceEq.\neconstructor; eauto.\napply S.\napply tr_val_gen.\nauto.\nintros.\neconstructor; eauto.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Epostincr id l (Csyntax.typeof l))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Epostincr id l (Csyntax.typeof l))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"exploit tr_top_leftcontext; eauto.\nclear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H3.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass; rewrite Kseqlist_app.\neexact EXEC.\nsimpl; lia.\nconstructor.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Epostincr id l (Csyntax.typeof l))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst'\n     (Epostincr id l (Csyntax.typeof l)) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\n    Csyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst'\n     (Epostincr id l (Csyntax.typeof l)) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\n    Csyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Epostincr id l (Csyntax.typeof l))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"clear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H3.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass; rewrite Kseqlist_app.\neexact EXEC.\nsimpl; lia.\nconstructor.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst'\n     (Epostincr id l (Csyntax.typeof l)) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\n    Csyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst'\n     (Epostincr id l (Csyntax.typeof l)) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\n    Csyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H3.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass; rewrite Kseqlist_app.\neexact EXEC.\nsimpl; lia.\nconstructor.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Epostincr id l (Csyntax.typeof l))\n  sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Epostincr id l (Csyntax.typeof l))\n  sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)","proofString":"inv P.\ninv H3.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass; rewrite Kseqlist_app.\neexact EXEC.\nsimpl; lia.\nconstructor.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H3 : tr_expr (prog_comp_env cu) le dst' (Epostincr id l (Csyntax.typeof l)) sl1 a'\n  tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H3 : tr_expr (prog_comp_env cu) le dst' (Epostincr id l (Csyntax.typeof l)) sl1 a'\n  tmp')","proofString":"inv H3.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass; rewrite Kseqlist_app.\neexact EXEC.\nsimpl; lia.\nconstructor.\nexploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H13 : incl tmp2 tmp') (H17 : list_disjoint tmp1 tmp2) (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             make_assign bf0 a1 (transl_incrdecr id a2 (Csyntax.typeof l))\n             :: nil) ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             make_assign bf0 a1 (transl_incrdecr id a2 (Csyntax.typeof l))\n             :: nil) ++ sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             make_assign bf0 a1 (transl_incrdecr id a2 (Csyntax.typeof l))\n             :: nil) ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             make_assign bf0 a1 (transl_incrdecr id a2 (Csyntax.typeof l))\n             :: nil) ++ sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H13 : incl tmp2 tmp') (H17 : list_disjoint tmp1 tmp2) (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"exploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass; rewrite Kseqlist_app.\neexact EXEC.\nsimpl; lia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H13 : incl tmp2 tmp') (H17 : list_disjoint tmp1 tmp2) (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             make_assign bf0 a1 (transl_incrdecr id a2 (Csyntax.typeof l))\n             :: nil) ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             make_assign bf0 a1 (transl_incrdecr id a2 (Csyntax.typeof l))\n             :: nil) ++ sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             make_assign bf0 a1 (transl_incrdecr id a2 (Csyntax.typeof l))\n             :: nil) ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             make_assign bf0 a1 (transl_incrdecr id a2 (Csyntax.typeof l))\n             :: nil) ++ sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H13 : incl tmp2 tmp') (H17 : list_disjoint tmp1 tmp2) (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"intros [SL1 [TY1 EV1]].\nexploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass; rewrite Kseqlist_app.\neexact EXEC.\nsimpl; lia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H13 : incl tmp2 tmp') (H17 : list_disjoint tmp1 tmp2) (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             make_assign bf0 a1 (transl_incrdecr id a2 (Csyntax.typeof l))\n             :: nil) ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             make_assign bf0 a1 (transl_incrdecr id a2 (Csyntax.typeof l))\n             :: nil) ++ sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             make_assign bf0 a1 (transl_incrdecr id a2 (Csyntax.typeof l))\n             :: nil) ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++\n             make_assign bf0 a1 (transl_incrdecr id a2 (Csyntax.typeof l))\n             :: nil) ++ sl2) tk) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (a2 : expr) (tmp2 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : tr_rvalof (prog_comp_env cu) (Csyntax.typeof l) a1 sl3 a2 tmp2) (H10 : incl tmp1 tmp') (H13 : incl tmp2 tmp') (H17 : list_disjoint tmp1 tmp2) (H18 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"exploit step_tr_rvalof; eauto.\nintros [le' [EXEC [EV3 [TY3 INV]]]].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nright; split.\nrewrite app_ass; rewrite Kseqlist_app.\neexact EXEC.\nsimpl; lia.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : incl tmp1 tmp') (H9 : In t0 tmp') (H12 : ~ In t0 tmp1) (H17 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : incl tmp1 tmp') (H9 : In t0 tmp') (H12 : ~ In t0 tmp1) (H17 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"exploit tr_simple_lvalue; eauto.\nintros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : incl tmp1 tmp') (H9 : In t0 tmp') (H12 : ~ In t0 tmp1) (H17 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) : sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"sl0 = nil /\\\nCsyntax.typeof l = typeof a1 /\\ eval_lvalue tge e le m a1 b ofs bf ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : incl tmp1 tmp') (H9 : In t0 tmp') (H12 : ~ In t0 tmp1) (H17 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0)","proofString":"intros [SL1 [TY1 EV1]].\nassert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : incl tmp1 tmp') (H9 : In t0 tmp') (H12 : ~ In t0 tmp1) (H17 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : incl tmp1 tmp') (H9 : In t0 tmp') (H12 : ~ In t0 tmp1) (H17 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"assert (bf0 = bf) by (eapply is_bitfield_access_sound; eauto).\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : incl tmp1 tmp') (H9 : In t0 tmp') (H12 : ~ In t0 tmp1) (H17 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (H3 : bf0 = bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             make_set bf0 t0 a1\n             :: make_assign bf0 a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (bf0 : bitfield) (H7 : tr_expr (prog_comp_env cu) le For_val l sl0 a1 tmp1) (H8 : incl tmp1 tmp') (H9 : In t0 tmp') (H12 : ~ In t0 tmp1) (H17 : tr_is_bitfield_access (prog_comp_env cu) a1 bf0) (SL1 : sl0 = nil) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) (H3 : bf0 = bf)","proofString":"subst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : incl tmp1 tmp') (H9 : In t0 tmp') (H12 : ~ In t0 tmp1) (H17 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((nil ++\n             make_set bf t0 a1\n             :: make_assign bf a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((nil ++\n             make_set bf t0 a1\n             :: make_assign bf a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((nil ++\n             make_set bf t0 a1\n             :: make_assign bf a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((nil ++\n             make_set bf t0 a1\n             :: make_assign bf a1\n                  (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                     (Csyntax.typeof l))\n                :: final dst' (Etempvar t0 (Csyntax.typeof l))) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : incl tmp1 tmp') (H9 : In t0 tmp') (H12 : ~ In t0 tmp1) (H17 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : incl tmp1 tmp') (H9 : In t0 tmp') (H12 : ~ In t0 tmp1) (H17 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf t0 a1)\n           (Kseq\n              (make_assign bf a1\n                 (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                    (Csyntax.typeof l)))\n              (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)\n                 tk))) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf t0 a1)\n           (Kseq\n              (make_assign bf a1\n                 (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                    (Csyntax.typeof l)))\n              (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)\n                 tk))) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf t0 a1)\n           (Kseq\n              (make_assign bf a1\n                 (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                    (Csyntax.typeof l)))\n              (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)\n                 tk))) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (make_set bf t0 a1)\n           (Kseq\n              (make_assign bf a1\n                 (transl_incrdecr id (Etempvar t0 (Csyntax.typeof l))\n                    (Csyntax.typeof l)))\n              (Kseqlist (final dst' (Etempvar t0 (Csyntax.typeof l)) ++ sl2)\n                 tk))) e le m) t S2' /\\\n   (measure Stuckstate <\n    measure (ExprState f (C (Epostincr id l (Csyntax.typeof l))) k e m))%nat) /\\\n  match_states Stuckstate S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (id : incr_or_decr) (l : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (b : block) (ofs : ptrofs) (bf : bitfield) (v1 : val) (t : trace) (H : leftcontext RV RV C) (H0 : eval_simple_lvalue ge e m l b ofs bf) (H2 : match sem_incrdecr ge id v1 (Csyntax.typeof l) m with\n| Some v2 =>\n    match\n      sem_cast v2 (incrdecr_type (Csyntax.typeof l)) (Csyntax.typeof l) m\n    with\n    | Some v3 =>\n        forall (t2 : trace) (m' : mem) (v' : val),\n        ~ Csem.assign_loc ge (Csyntax.typeof l) m b ofs bf v3 t2 m' v'\n    | None => True\n    end\n| None => True\nend) (H1 : Csem.deref_loc ge (Csyntax.typeof l) m b ofs bf t v1) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 (Csyntax.typeof l))\n  tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Epostincr id l (Csyntax.typeof l)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (H7 : tr_expr (prog_comp_env cu) le For_val l nil a1 tmp1) (H8 : incl tmp1 tmp') (H9 : In t0 tmp') (H12 : ~ In t0 tmp1) (H17 : tr_is_bitfield_access (prog_comp_env cu) a1 bf) (TY1 : Csyntax.typeof l = typeof a1) (EV1 : eval_lvalue tge e le m a1 b ofs bf)","proofString":"econstructor; split.\nleft.\neapply plus_two.\nconstructor.\neapply step_make_set; eauto.\ntraceEq.\nconstructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Ecomma r1 r2 (Csyntax.typeof r2))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Ecomma r1 r2 (Csyntax.typeof r2))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"exploit tr_top_leftcontext; eauto.\nclear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H1.\nexploit tr_simple_rvalue; eauto.\nsimpl; intro SL1.\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\napply S.\neapply tr_expr_monotone; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Ecomma r1 r2 (Csyntax.typeof r2))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst'\n     (Ecomma r1 r2 (Csyntax.typeof r2)) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst'\n     (Ecomma r1 r2 (Csyntax.typeof r2)) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest\n  (C (Ecomma r1 r2 (Csyntax.typeof r2))) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"clear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H1.\nexploit tr_simple_rvalue; eauto.\nsimpl; intro SL1.\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\napply S.\neapply tr_expr_monotone; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst'\n     (Ecomma r1 r2 (Csyntax.typeof r2)) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst'\n     (Ecomma r1 r2 (Csyntax.typeof r2)) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H1.\nexploit tr_simple_rvalue; eauto.\nsimpl; intro SL1.\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\napply S.\neapply tr_expr_monotone; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Ecomma r1 r2 (Csyntax.typeof r2))\n  sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Ecomma r1 r2 (Csyntax.typeof r2))\n  sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)","proofString":"inv P.\ninv H1.\nexploit tr_simple_rvalue; eauto.\nsimpl; intro SL1.\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\napply S.\neapply tr_expr_monotone; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H1 : tr_expr (prog_comp_env cu) le dst' (Ecomma r1 r2 (Csyntax.typeof r2)) sl1 a'\n  tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H1 : tr_expr (prog_comp_env cu) le dst' (Ecomma r1 r2 (Csyntax.typeof r2)) sl1 a'\n  tmp')","proofString":"inv H1.\nexploit tr_simple_rvalue; eauto.\nsimpl; intro SL1.\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\napply S.\neapply tr_expr_monotone; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 sl0 a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist ((sl0 ++ sl3) ++ sl2) tk) e le m)\n     E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist ((sl0 ++ sl3) ++ sl2) tk) e le m)\n     E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist ((sl0 ++ sl3) ++ sl2) tk) e le m)\n     E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist ((sl0 ++ sl3) ++ sl2) tk) e le m)\n     E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 sl0 a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nsimpl; intro SL1.\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\napply S.\neapply tr_expr_monotone; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 sl0 a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp') : match For_effects with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist ((sl0 ++ sl3) ++ sl2) tk) e le m)\n     E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist ((sl0 ++ sl3) ++ sl2) tk) e le m)\n     E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'.","conclusion":"match For_effects with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof r1 = typeof a1 /\\ eval_expr tge e le m a1 v\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof r1 = typeof b /\\ eval_expr tge e le m b v\nend ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist ((sl0 ++ sl3) ++ sl2) tk) e le m)\n     E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist ((sl0 ++ sl3) ++ sl2) tk) e le m)\n     E0 S2' /\\\n   (measure (ExprState f (C r2) k e m) <\n    measure (ExprState f (C (Ecomma r1 r2 (Csyntax.typeof r2))) k e m))%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 sl0 a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp')","proofString":"simpl; intro SL1.\nsubst sl0; simpl Kseqlist.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\napply S.\neapply tr_expr_monotone; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 sl0 a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp') (SL1 : sl0 = nil) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist ((sl0 ++ sl3) ++ sl2) tk) e le m)\n     E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist ((sl0 ++ sl3) ++ sl2) tk) e le m)\n     E0 S2' /\\\n   (esize (C r2) + 1 < esize (C (Ecomma r1 r2 (Csyntax.typeof r2))) + 1)%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist ((sl0 ++ sl3) ++ sl2) tk) e le m)\n     E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist ((sl0 ++ sl3) ++ sl2) tk) e le m)\n     E0 S2' /\\\n   (esize (C r2) + 1 < esize (C (Ecomma r1 r2 (Csyntax.typeof r2))) + 1)%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 sl0 a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp') (SL1 : sl0 = nil)","proofString":"subst sl0; simpl Kseqlist.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\napply S.\neapply tr_expr_monotone; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m) E0 S2' /\\\n   (esize (C r2) + 1 < esize (C (Ecomma r1 r2 (Csyntax.typeof r2))) + 1)%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl3 ++ sl2) tk) e le m) E0 S2' /\\\n   (esize (C r2) + 1 < esize (C (Ecomma r1 r2 (Csyntax.typeof r2))) + 1)%nat) /\\\n  match_states (ExprState f (C r2) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp')","proofString":"econstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\napply S.\neapply tr_expr_monotone; eauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp') : (esize (C r2) + 1 < esize (C (Ecomma r1 r2 (Csyntax.typeof r2))) + 1)%nat.","conclusion":"(esize (C r2) + 1 < esize (C (Ecomma r1 r2 (Csyntax.typeof r2))) + 1)%nat","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp')","proofString":"simpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp') : (esize (C r2) + 1 < esize (C (Ecomma r1 r2 (Csyntax.typeof r2))) + 1)%nat.","conclusion":"(esize (C r2) + 1 < esize (C (Ecomma r1 r2 (Csyntax.typeof r2))) + 1)%nat","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp')","proofString":"apply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp') : (esize (C r2) < esize (C (Ecomma r1 r2 (Csyntax.typeof r2))))%nat.","conclusion":"(esize (C r2) < esize (C (Ecomma r1 r2 (Csyntax.typeof r2))))%nat","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp')","proofString":"apply (leftcontext_size _ _ _ H).\nsimpl.\nlia."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp') : (esize r2 < esize (Ecomma r1 r2 (Csyntax.typeof r2)))%nat.","conclusion":"(esize r2 < esize (Ecomma r1 r2 (Csyntax.typeof r2)))%nat","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp')","proofString":"simpl.\nlia."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp') : (esize r2 < Datatypes.S (esize r1 + esize r2))%nat.","conclusion":"(esize r2 < Datatypes.S (esize r1 + esize r2))%nat","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp')","proofString":"lia."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp') : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp'.","conclusion":"tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp')","proofString":"eapply tr_expr_monotone; eauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp') : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp')","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp') : Csyntax.typeof r2 = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)).","conclusion":"Csyntax.typeof r2 = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2))","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r1 r2 : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r1 v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl0 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl0 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecomma r1 r2 (Csyntax.typeof r2)) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl0 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (tmp2 : list ident) (H5 : tr_expr (prog_comp_env cu) le For_effects r1 nil a1 tmp1) (H6 : tr_expr (prog_comp_env cu) le dst' r2 sl3 a' tmp2) (H9 : list_disjoint tmp1 tmp2) (H13 : incl tmp1 tmp') (H14 : incl tmp2 tmp')","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eparen r tycast ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eparen r tycast ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"exploit tr_top_leftcontext; eauto.\nclear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [b [SL1 [TY1 EV1]]].\nsubst sl1; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (final For_val (Etempvar t (Csyntax.typeof r)) ++ sl2).\napply S.\nconstructor.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\nexploit tr_simple_rvalue; eauto.\nsimpl.\nintros A.\nsubst sl1.\napply S.\nconstructor; auto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nsimpl.\nintros [b [SL1 [TY1 EV1]]].\nsubst sl1.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\napply S.\nconstructor; auto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eparen r tycast ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eparen r tycast ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eparen r tycast ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Eparen r tycast ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"clear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [b [SL1 [TY1 EV1]]].\nsubst sl1; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (final For_val (Etempvar t (Csyntax.typeof r)) ++ sl2).\napply S.\nconstructor.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\nexploit tr_simple_rvalue; eauto.\nsimpl.\nintros A.\nsubst sl1.\napply S.\nconstructor; auto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nsimpl.\nintros [b [SL1 [TY1 EV1]]].\nsubst sl1.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\napply S.\nconstructor; auto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eparen r tycast ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Eparen r tycast ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [b [SL1 [TY1 EV1]]].\nsubst sl1; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (final For_val (Etempvar t (Csyntax.typeof r)) ++ sl2).\napply S.\nconstructor.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\nexploit tr_simple_rvalue; eauto.\nsimpl.\nintros A.\nsubst sl1.\napply S.\nconstructor; auto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nsimpl.\nintros [b [SL1 [TY1 EV1]]].\nsubst sl1.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\napply S.\nconstructor; auto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Eparen r tycast ty) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Eparen r tycast ty) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)","proofString":"inv P.\ninv H2.\nexploit tr_simple_rvalue; eauto.\nintros [b [SL1 [TY1 EV1]]].\nsubst sl1; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (final For_val (Etempvar t (Csyntax.typeof r)) ++ sl2).\napply S.\nconstructor.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\nexploit tr_simple_rvalue; eauto.\nsimpl.\nintros A.\nsubst sl1.\napply S.\nconstructor; auto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nsimpl.\nintros [b [SL1 [TY1 EV1]]].\nsubst sl1.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\napply S.\nconstructor; auto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Eparen r tycast ty) sl1 a' tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Eparen r tycast ty) sl1 a' tmp')","proofString":"inv H2.\nexploit tr_simple_rvalue; eauto.\nintros [b [SL1 [TY1 EV1]]].\nsubst sl1; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (final For_val (Etempvar t (Csyntax.typeof r)) ++ sl2).\napply S.\nconstructor.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\nexploit tr_simple_rvalue; eauto.\nsimpl.\nintros A.\nsubst sl1.\napply S.\nconstructor; auto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nsimpl.\nintros [b [SL1 [TY1 EV1]]].\nsubst sl1.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\napply S.\nconstructor; auto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r sl1 a1 tmp') (H12 : In t tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r sl1 a1 tmp') (H12 : In t tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [b [SL1 [TY1 EV1]]].\nsubst sl1; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (final For_val (Etempvar t (Csyntax.typeof r)) ++ sl2).\napply S.\nconstructor.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r sl1 a1 tmp') (H12 : In t tmp') : match For_set (SDbase tycast ty t) with\n| For_val =>\n    sl1 = nil /\\ Csyntax.typeof r = typeof a1 /\\ eval_expr tge e le m a1 v1\n| For_effects => sl1 = nil\n| For_set sd =>\n    exists b : expr,\n      sl1 = do_set sd b /\\\n      Csyntax.typeof r = typeof b /\\ eval_expr tge e le m b v1\nend ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"match For_set (SDbase tycast ty t) with\n| For_val =>\n    sl1 = nil /\\ Csyntax.typeof r = typeof a1 /\\ eval_expr tge e le m a1 v1\n| For_effects => sl1 = nil\n| For_set sd =>\n    exists b : expr,\n      sl1 = do_set sd b /\\\n      Csyntax.typeof r = typeof b /\\ eval_expr tge e le m b v1\nend ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r sl1 a1 tmp') (H12 : In t tmp')","proofString":"intros [b [SL1 [TY1 EV1]]].\nsubst sl1; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (final For_val (Etempvar t (Csyntax.typeof r)) ++ sl2).\napply S.\nconstructor.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r sl1 a1 tmp') (H12 : In t tmp') (b : expr) (SL1 : sl1 = do_set (SDbase tycast ty t) b) (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r sl1 a1 tmp') (H12 : In t tmp') (b : expr) (SL1 : sl1 = do_set (SDbase tycast ty t) b) (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"subst sl1; simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (final For_val (Etempvar t (Csyntax.typeof r)) ++ sl2).\napply S.\nconstructor.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (Sset t (Ecast b tycast)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (Sset t (Ecast b tycast)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (Sset t (Ecast b tycast)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (Sset t (Ecast b tycast)) (Kseqlist sl2 tk)) e le\n        m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (final For_val (Etempvar t (Csyntax.typeof r)) ++ sl2).\napply S.\nconstructor.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : tr_expr (prog_comp_env cu) (PTree.set t v le) For_val \n  (Eval v ty) (final For_val (Etempvar t (Csyntax.typeof r))) \n  (Etempvar t ty) tmp'.","conclusion":"tr_expr (prog_comp_env cu) (PTree.set t v le) For_val \n  (Eval v ty) (final For_val (Etempvar t (Csyntax.typeof r))) \n  (Etempvar t ty) tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"constructor.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : typeof (Etempvar t ty) = ty.","conclusion":"typeof (Etempvar t ty) = ty","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id) ->\neval_expr tge0 e0 le' m0 (Etempvar t ty) v.","conclusion":"forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id) ->\neval_expr tge0 e0 le' m0 (Etempvar t ty) v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"intros.\nconstructor.\nrewrite H2; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id) : eval_expr tge0 e0 le' m0 (Etempvar t ty) v.","conclusion":"eval_expr tge0 e0 le' m0 (Etempvar t ty) v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id)","proofString":"constructor.\nrewrite H2; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id) : le' ! t = Some v.","conclusion":"le' ! t = Some v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id)","proofString":"rewrite H2; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id) : (PTree.set t v le) ! t = Some v.","conclusion":"(PTree.set t v le) ! t = Some v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id)","proofString":"apply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : forall id : ident, ~ In id tmp' -> (PTree.set t v le) ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> (PTree.set t v le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"intros.\napply PTree.gso.\nintuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (id : ident) (H2 : ~ In id tmp') : (PTree.set t v le) ! id = le ! id.","conclusion":"(PTree.set t v le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (id : ident) (H2 : ~ In id tmp')","proofString":"apply PTree.gso.\nintuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (id : ident) (H2 : ~ In id tmp') : id <> t.","conclusion":"id <> t","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (id : ident) (H2 : ~ In id tmp')","proofString":"intuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : Csyntax.typeof (Eval v ty) = Csyntax.typeof (Eparen r tycast ty).","conclusion":"Csyntax.typeof (Eval v ty) = Csyntax.typeof (Eparen r tycast ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDbase tycast ty t)) r\n  (do_set (SDbase tycast ty t) b) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r sl1 a1 tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r sl1 a1 tmp')","proofString":"econstructor; split.\nright; split.\napply star_refl.\nsimpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia.\neconstructor; eauto.\nexploit tr_simple_rvalue; eauto.\nsimpl.\nintros A.\nsubst sl1.\napply S.\nconstructor; auto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r sl1 a1 tmp') : (measure (ExprState f (C (Eval v ty)) k e m) <\n measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat.","conclusion":"(measure (ExprState f (C (Eval v ty)) k e m) <\n measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r sl1 a1 tmp')","proofString":"simpl.\napply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r sl1 a1 tmp') : (esize (C (Eval v ty)) + 1 < esize (C (Eparen r tycast ty)) + 1)%nat.","conclusion":"(esize (C (Eval v ty)) + 1 < esize (C (Eparen r tycast ty)) + 1)%nat","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r sl1 a1 tmp')","proofString":"apply Nat.add_lt_mono_r.\napply (leftcontext_size _ _ _ H).\nsimpl.\nlia."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r sl1 a1 tmp') : (esize (C (Eval v ty)) < esize (C (Eparen r tycast ty)))%nat.","conclusion":"(esize (C (Eval v ty)) < esize (C (Eparen r tycast ty)))%nat","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r sl1 a1 tmp')","proofString":"apply (leftcontext_size _ _ _ H).\nsimpl.\nlia."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r sl1 a1 tmp') : (esize (Eval v ty) < esize (Eparen r tycast ty))%nat.","conclusion":"(esize (Eval v ty) < esize (Eparen r tycast ty))%nat","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r sl1 a1 tmp')","proofString":"simpl.\nlia."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r sl1 a1 tmp') : (0 < Datatypes.S (esize r))%nat.","conclusion":"(0 < Datatypes.S (esize r))%nat","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r sl1 a1 tmp')","proofString":"lia."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r nil a1 tmp') : tr_expr (prog_comp_env cu) le For_effects (Eval v ty) nil a' tmp'.","conclusion":"tr_expr (prog_comp_env cu) le For_effects (Eval v ty) nil a' tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r nil a1 tmp')","proofString":"constructor; auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r nil a1 tmp') : forall id : ident, ~ In id tmp' -> le ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> le ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r nil a1 tmp')","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r nil a1 tmp') : Csyntax.typeof (Eval v ty) = Csyntax.typeof (Eparen r tycast ty).","conclusion":"Csyntax.typeof (Eval v ty) = Csyntax.typeof (Eparen r tycast ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le For_effects r nil a1 tmp')","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r sl1 a1 tmp') (H12 : In t tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r sl1 a1 tmp') (H12 : In t tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nsimpl.\nintros [b [SL1 [TY1 EV1]]].\nsubst sl1.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\napply S.\nconstructor; auto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r sl1 a1 tmp') (H12 : In t tmp') : match For_set (SDcons tycast ty t sd) with\n| For_val =>\n    sl1 = nil /\\ Csyntax.typeof r = typeof a1 /\\ eval_expr tge e le m a1 v1\n| For_effects => sl1 = nil\n| For_set sd0 =>\n    exists b : expr,\n      sl1 = do_set sd0 b /\\\n      Csyntax.typeof r = typeof b /\\ eval_expr tge e le m b v1\nend ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"match For_set (SDcons tycast ty t sd) with\n| For_val =>\n    sl1 = nil /\\ Csyntax.typeof r = typeof a1 /\\ eval_expr tge e le m a1 v1\n| For_effects => sl1 = nil\n| For_set sd0 =>\n    exists b : expr,\n      sl1 = do_set sd0 b /\\\n      Csyntax.typeof r = typeof b /\\ eval_expr tge e le m b v1\nend ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (ExprState f (C (Eparen r tycast ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r sl1 a1 tmp') (H12 : In t tmp')","proofString":"simpl.\nintros [b [SL1 [TY1 EV1]]].\nsubst sl1.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\napply S.\nconstructor; auto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r sl1 a1 tmp') (H12 : In t tmp') : (exists b : expr,\n   sl1 = Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty) /\\\n   Csyntax.typeof r = typeof b /\\ eval_expr tge e le m b v1) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (esize (C (Eval v ty)) + 1 < esize (C (Eparen r tycast ty)) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"(exists b : expr,\n   sl1 = Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty) /\\\n   Csyntax.typeof r = typeof b /\\ eval_expr tge e le m b v1) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (esize (C (Eval v ty)) + 1 < esize (C (Eparen r tycast ty)) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r sl1 a1 tmp') (H12 : In t tmp')","proofString":"intros [b [SL1 [TY1 EV1]]].\nsubst sl1.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\napply S.\nconstructor; auto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r sl1 a1 tmp') (H12 : In t tmp') (b : expr) (SL1 : sl1 = Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (esize (C (Eval v ty)) + 1 < esize (C (Eparen r tycast ty)) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (esize (C (Eval v ty)) + 1 < esize (C (Eparen r tycast ty)) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r sl1 a1 tmp') (H12 : In t tmp') (b : expr) (SL1 : sl1 = Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"subst sl1.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\napply S.\nconstructor; auto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (esize (C (Eval v ty)) + 1 < esize (C (Eparen r tycast ty)) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) ++ sl2) tk)\n        e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) ++ sl2) tk)\n        e le m) E0 S2' /\\\n   (esize (C (Eval v ty)) + 1 < esize (C (Eparen r tycast ty)) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\napply S.\nconstructor; auto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (Sset t (Ecast b tycast))\n           (Kseqlist (do_set sd (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (Sset t (Ecast b tycast))\n           (Kseqlist (do_set sd (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' /\\\n   (esize (C (Eval v ty)) + 1 < esize (C (Eparen r tycast ty)) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (Sset t (Ecast b tycast))\n           (Kseqlist (do_set sd (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (Sset t (Ecast b tycast))\n           (Kseqlist (do_set sd (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' /\\\n   (esize (C (Eval v ty)) + 1 < esize (C (Eparen r tycast ty)) + 1)%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor.\neconstructor; eauto.\nrewrite <- TY1; eauto.\ntraceEq.\neconstructor; eauto.\napply S.\nconstructor; auto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto.\nintros.\napply PTree.gso.\ncongruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : tr_expr (prog_comp_env cu) (PTree.set t v le) (For_set sd) \n  (Eval v ty) (do_set sd (Etempvar t ty)) a' tmp'.","conclusion":"tr_expr (prog_comp_env cu) (PTree.set t v le) (For_set sd) \n  (Eval v ty) (do_set sd (Etempvar t ty)) a' tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"constructor; auto.\nintros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id) ->\neval_expr tge0 e0 le' m0 (Etempvar t ty) v.","conclusion":"forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id) ->\neval_expr tge0 e0 le' m0 (Etempvar t ty) v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"intros.\nconstructor.\nrewrite H2.\napply PTree.gss.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id) : eval_expr tge0 e0 le' m0 (Etempvar t ty) v.","conclusion":"eval_expr tge0 e0 le' m0 (Etempvar t ty) v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id)","proofString":"constructor.\nrewrite H2.\napply PTree.gss.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id) : le' ! t = Some v.","conclusion":"le' ! t = Some v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id)","proofString":"rewrite H2.\napply PTree.gss.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id) : (PTree.set t v le) ! t = Some v.","conclusion":"(PTree.set t v le) ! t = Some v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id)","proofString":"apply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id) : In t tmp'.","conclusion":"In t tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive, In id tmp' -> le' ! id = (PTree.set t v le) ! id)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : forall id : ident, ~ In id tmp' -> (PTree.set t v le) ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> (PTree.set t v le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"intros.\napply PTree.gso.\ncongruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (id : ident) (H2 : ~ In id tmp') : (PTree.set t v le) ! id = le ! id.","conclusion":"(PTree.set t v le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (id : ident) (H2 : ~ In id tmp')","proofString":"apply PTree.gso.\ncongruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (id : ident) (H2 : ~ In id tmp') : id <> t.","conclusion":"id <> t","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) (id : ident) (H2 : ~ In id tmp')","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1) : Csyntax.typeof (Eval v ty) = Csyntax.typeof (Eparen r tycast ty).","conclusion":"Csyntax.typeof (Eval v ty) = Csyntax.typeof (Eparen r tycast ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (r : Csyntax.expr) (tycast ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v1 v : val) (H : leftcontext RV RV C) (H0 : eval_simple_rvalue ge e m r v1) (H1 : sem_cast v1 (Csyntax.typeof r) tycast m = Some v) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (sd : set_destination) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Eparen r tycast ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (t : ident) (a1 b : expr) (H11 : tr_expr (prog_comp_env cu) le (For_set (SDcons tycast ty t sd)) r\n  (Sset t (Ecast b tycast) :: do_set sd (Etempvar t ty)) a1 tmp') (H12 : In t tmp') (TY1 : Csyntax.typeof r = typeof b) (EV1 : eval_expr tge e le m b v1)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Ecall rf rargs ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Ecall rf rargs ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"exploit tr_top_leftcontext; eauto.\nclear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H5.\nexploit tr_simple_rvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Ecall rf rargs ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Ecall rf rargs ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Ecall rf rargs ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Ecall rf rargs ty)) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"clear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H5.\nexploit tr_simple_rvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Ecall rf rargs ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Ecall rf rargs ty) sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\n    tr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H5.\nexploit tr_simple_rvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Ecall rf rargs ty) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Ecall rf rargs ty) sl1 a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps)","proofString":"inv P.\ninv H5.\nexploit tr_simple_rvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H5 : tr_expr (prog_comp_env cu) le dst' (Ecall rf rargs ty) sl1 a' tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (H5 : tr_expr (prog_comp_env cu) le dst' (Ecall rf rargs ty) sl1 a' tmp')","proofString":"inv H5.\nexploit tr_simple_rvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto.\nexploit tr_simple_rvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof rf = typeof a1 /\\ eval_expr tge e le m a1 vf\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof rf = typeof b /\\ eval_expr tge e le m b vf\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof rf = typeof a1 /\\ eval_expr tge e le m a1 vf\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof rf = typeof b /\\ eval_expr tge e le m b vf\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp')","proofString":"intros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (SL1 : sl0 = nil) (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (SL1 : sl0 = nil) (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf)","proofString":"exploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (SL1 : sl0 = nil) (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) : sl3 = nil /\\ eval_exprlist tge e le m al2 targs vargs ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"sl3 = nil /\\ eval_exprlist tge e le m al2 targs vargs ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (SL1 : sl0 = nil) (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf)","proofString":"intros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (SL1 : sl0 = nil) (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (SL2 : sl3 = nil) (EV2 : eval_exprlist tge e le m al2 targs vargs) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl0 ++ sl3 ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl1 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (SL1 : sl0 = nil) (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (SL2 : sl3 = nil) (EV2 : eval_exprlist tge e le m al2 targs vargs)","proofString":"subst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((nil ++ nil ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((nil ++ nil ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((nil ++ nil ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((nil ++ nil ++ Scall None a1 al2 :: nil) ++ sl2) tk) e le\n        m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs)","proofString":"simpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (Scall None a1 al2) (Kseqlist sl2 tk)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (Scall None a1 al2) (Kseqlist sl2 tk)) e le m) E0\n     S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (Scall None a1 al2) (Kseqlist sl2 tk)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (Scall None a1 al2) (Kseqlist sl2 tk)) e le m) E0\n     S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs)","proofString":"exploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) : (exists (cu0 : Csyntax.program) (tf0 : fundef),\n   Genv.find_funct tge vf = Some tf0 /\\\n   tr_fundef cu0 fd tf0 /\\ linkorder cu0 prog) ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (Scall None a1 al2) (Kseqlist sl2 tk)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (Scall None a1 al2) (Kseqlist sl2 tk)) e le m) E0\n     S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"(exists (cu0 : Csyntax.program) (tf0 : fundef),\n   Genv.find_funct tge vf = Some tf0 /\\\n   tr_fundef cu0 fd tf0 /\\ linkorder cu0 prog) ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (Scall None a1 al2) (Kseqlist sl2 tk)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (Scall None a1 al2) (Kseqlist sl2 tk)) e le m) E0\n     S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs)","proofString":"intros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (Scall None a1 al2) (Kseqlist sl2 tk)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (Scall None a1 al2) (Kseqlist sl2 tk)) e le m) E0\n     S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (Scall None a1 al2) (Kseqlist sl2 tk)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (Scall None a1 al2) (Kseqlist sl2 tk)) e le m) E0\n     S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) : type_of_fundef tfd = Csyntax.type_of_fundef fd ->\ntype_of_fundef tfd = Tfunction targs tres cconv.","conclusion":"type_of_fundef tfd = Csyntax.type_of_fundef fd ->\ntype_of_fundef tfd = Tfunction targs tres cconv","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) : forall ce : composite_env,\nmatch_cont ce (Csem.Kcall f e C ty k) (Kcall None tf e le (Kseqlist sl2 tk)).","conclusion":"forall ce : composite_env,\nmatch_cont ce (Csem.Kcall f e C ty k) (Kcall None tf e le (Kseqlist sl2 tk))","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog)","proofString":"econstructor.\neexact LINK.\nauto.\nauto.\nintros.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nauto.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) : leftcontext RV RV C.","conclusion":"leftcontext RV RV C","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) : tr_expr (prog_comp_env cu) (set_opttemp None v le) For_effects \n  (Eval v ty) nil a' tmp'.","conclusion":"tr_expr (prog_comp_env cu) (set_opttemp None v le) For_effects \n  (Eval v ty) nil a' tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) : forall id : ident, ~ In id tmp' -> (set_opttemp None v le) ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> (set_opttemp None v le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) : Csyntax.typeof (Eval v ty) = Csyntax.typeof (Ecall rf rargs ty).","conclusion":"Csyntax.typeof (Eval v ty) = Csyntax.typeof (Ecall rf rargs ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H10 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H13 : list_disjoint tmp1 tmp2) (H17 : incl tmp1 tmp') (H18 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp')","proofString":"exploit tr_simple_rvalue; eauto.\nintros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') : match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof rf = typeof a1 /\\ eval_expr tge e le m a1 vf\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof rf = typeof b /\\ eval_expr tge e le m b vf\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"match For_val with\n| For_val =>\n    sl0 = nil /\\ Csyntax.typeof rf = typeof a1 /\\ eval_expr tge e le m a1 vf\n| For_effects => sl0 = nil\n| For_set sd =>\n    exists b : expr,\n      sl0 = do_set sd b /\\\n      Csyntax.typeof rf = typeof b /\\ eval_expr tge e le m b vf\nend ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp')","proofString":"intros [SL1 [TY1 EV1]].\nexploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (SL1 : sl0 = nil) (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (SL1 : sl0 = nil) (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf)","proofString":"exploit tr_simple_exprlist; eauto.\nintros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (SL1 : sl0 = nil) (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) : sl3 = nil /\\ eval_exprlist tge e le m al2 targs vargs ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"sl3 = nil /\\ eval_exprlist tge e le m al2 targs vargs ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (SL1 : sl0 = nil) (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf)","proofString":"intros [SL2 EV2].\nsubst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (SL1 : sl0 = nil) (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (SL2 : sl3 = nil) (EV2 : eval_exprlist tge e le m al2 targs vargs) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl0 ++\n             sl3 ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl1 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl1 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl1 ++ sl2) a tmps) (sl0 : list statement) (a1 : expr) (tmp1 : list ident) (sl3 : list statement) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf sl0 a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs sl3 al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (SL1 : sl0 = nil) (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (SL2 : sl3 = nil) (EV2 : eval_exprlist tge e le m al2 targs vargs)","proofString":"subst.\nsimpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((nil ++\n             nil ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((nil ++\n             nil ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((nil ++\n             nil ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((nil ++\n             nil ++ Scall (Some t) a1 al2 :: final dst' (Etempvar t ty)) ++\n            sl2) tk) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs)","proofString":"simpl Kseqlist.\nexploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (Scall (Some t) a1 al2)\n           (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (Scall (Some t) a1 al2)\n           (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (Scall (Some t) a1 al2)\n           (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (Scall (Some t) a1 al2)\n           (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs)","proofString":"exploit functions_translated; eauto.\nintros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) : (exists (cu0 : Csyntax.program) (tf0 : fundef),\n   Genv.find_funct tge vf = Some tf0 /\\\n   tr_fundef cu0 fd tf0 /\\ linkorder cu0 prog) ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (Scall (Some t) a1 al2)\n           (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (Scall (Some t) a1 al2)\n           (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"(exists (cu0 : Csyntax.program) (tf0 : fundef),\n   Genv.find_funct tge vf = Some tf0 /\\\n   tr_fundef cu0 fd tf0 /\\ linkorder cu0 prog) ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (Scall (Some t) a1 al2)\n           (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (Scall (Some t) a1 al2)\n           (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs)","proofString":"intros (cu' & tfd & J & K & L).\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (Scall (Some t) a1 al2)\n           (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (Scall (Some t) a1 al2)\n           (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (Scall (Some t) a1 al2)\n           (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (Scall (Some t) a1 al2)\n           (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk)) e le m) E0 S2' /\\\n   (measure (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) <\n    measure (ExprState f (C (Ecall rf rargs ty)) k e m))%nat) /\\\n  match_states (Csem.Callstate fd vargs (Csem.Kcall f e C ty k) m) S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\nrewrite <- TY1; eauto.\nexploit type_of_fundef_preserved; eauto.\ncongruence.\ntraceEq.\neconstructor.\neexact L.\neauto.\neconstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) : type_of_fundef tfd = Csyntax.type_of_fundef fd ->\ntype_of_fundef tfd = Tfunction targs tres cconv.","conclusion":"type_of_fundef tfd = Csyntax.type_of_fundef fd ->\ntype_of_fundef tfd = Tfunction targs tres cconv","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) : forall ce : composite_env,\nmatch_cont ce (Csem.Kcall f e C ty k)\n  (Kcall (Some t) tf e le (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk)).","conclusion":"forall ce : composite_env,\nmatch_cont ce (Csem.Kcall f e C ty k)\n  (Kcall (Some t) tf e le (Kseqlist (final dst' (Etempvar t ty) ++ sl2) tk))","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog)","proofString":"econstructor.\neexact LINK.\nauto.\nauto.\nintros.\napply S.\ndestruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nintros.\napply PTree.gso.\nintuition congruence.\nauto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) : leftcontext RV RV C.","conclusion":"leftcontext RV RV C","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) : tr_expr (prog_comp_env cu) (set_opttemp (Some t) v le) dst' \n  (Eval v ty) (final dst' (Etempvar t ty)) (Etempvar t ty) tmp'.","conclusion":"tr_expr (prog_comp_env cu) (set_opttemp (Some t) v le) dst' \n  (Eval v ty) (final dst' (Etempvar t ty)) (Etempvar t ty) tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem)","proofString":"destruct dst'; constructor.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss.\nauto.\nintros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_val <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) : typeof (Etempvar t ty) = ty.","conclusion":"typeof (Etempvar t ty) = ty","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_val <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_val <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) : forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem),\n(forall id : positive,\n In id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id) ->\neval_expr tge0 e0 le' m1 (Etempvar t ty) v.","conclusion":"forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem),\n(forall id : positive,\n In id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id) ->\neval_expr tge0 e0 le' m1 (Etempvar t ty) v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_val <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem)","proofString":"intros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_val <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem) (H5 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id) : eval_expr tge0 e0 le' m1 (Etempvar t ty) v.","conclusion":"eval_expr tge0 e0 le' m1 (Etempvar t ty) v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_val <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem) (H5 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id)","proofString":"constructor.\nrewrite H5; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_val <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem) (H5 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id) : le' ! t = Some v.","conclusion":"le' ! t = Some v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_val <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem) (H5 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id)","proofString":"rewrite H5; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_val <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem) (H5 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id) : (set_opttemp (Some t) v le) ! t = Some v.","conclusion":"(set_opttemp (Some t) v le) ! t = Some v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 For_val r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_val <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem) (H5 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id)","proofString":"apply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sd : set_destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_set sd <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) : typeof (Etempvar t ty) = ty.","conclusion":"typeof (Etempvar t ty) = ty","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sd : set_destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_set sd <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sd : set_destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_set sd <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) : forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem),\n(forall id : positive,\n In id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id) ->\neval_expr tge0 e0 le' m1 (Etempvar t ty) v.","conclusion":"forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem),\n(forall id : positive,\n In id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id) ->\neval_expr tge0 e0 le' m1 (Etempvar t ty) v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sd : set_destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' (For_set sd) r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_set sd <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem)","proofString":"intros.\nconstructor.\nrewrite H5; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sd : set_destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_set sd <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem) (H5 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id) : eval_expr tge0 e0 le' m1 (Etempvar t ty) v.","conclusion":"eval_expr tge0 e0 le' m1 (Etempvar t ty) v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sd : set_destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_set sd <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem) (H5 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id)","proofString":"constructor.\nrewrite H5; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sd : set_destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_set sd <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem) (H5 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id) : le' ! t = Some v.","conclusion":"le' ! t = Some v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sd : set_destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_set sd <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem) (H5 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id)","proofString":"rewrite H5; auto.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sd : set_destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_set sd <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem) (H5 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id) : (set_opttemp (Some t) v le) ! t = Some v.","conclusion":"(set_opttemp (Some t) v le) ! t = Some v","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sd : set_destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le'0 : temp_env) (m' : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 (For_set sd) r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : For_set sd <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m1 : mem) (H5 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t) v le) ! id)","proofString":"apply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) : forall id : ident, ~ In id tmp' -> (set_opttemp (Some t) v le) ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> (set_opttemp (Some t) v le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem)","proofString":"intros.\napply PTree.gso.\nintuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (id : ident) (H5 : ~ In id tmp') : (set_opttemp (Some t) v le) ! id = le ! id.","conclusion":"(set_opttemp (Some t) v le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (id : ident) (H5 : ~ In id tmp')","proofString":"apply PTree.gso.\nintuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (id : ident) (H5 : ~ In id tmp') : id <> t.","conclusion":"id <> t","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) (id : ident) (H5 : ~ In id tmp')","proofString":"intuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem) : Csyntax.typeof (Eval v ty) = Csyntax.typeof (Ecall rf rargs ty).","conclusion":"Csyntax.typeof (Eval v ty) = Csyntax.typeof (Ecall rf rargs ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (rf : Csyntax.expr) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (targs : list type) (tres : type) (cconv : calling_convention) (vf : val) (vargs : list val) (fd : Csyntax.fundef) (H : leftcontext RV RV C) (H0 : classify_fun (Csyntax.typeof rf) = fun_case_f targs tres cconv) (H1 : eval_simple_rvalue ge e m rf vf) (H2 : eval_simple_list ge e m rargs targs vargs) (H3 : Genv.find_funct ge vf = Some fd) (H4 : Csyntax.type_of_fundef fd = Tfunction targs tres cconv) (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t : ident) (S : forall (le' : temp_env) (m' : mem) (r' : Csyntax.expr) (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ecall rf rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m' dest (C r') (sl3 ++ sl2) a tmps) (a1 : expr) (tmp1 : list ident) (al2 : list expr) (tmp2 : list ident) (H9 : dst' <> For_effects) (H10 : tr_expr (prog_comp_env cu) le For_val rf nil a1 tmp1) (H11 : tr_exprlist (prog_comp_env cu) le rargs nil al2 tmp2) (H12 : list_disjoint tmp1 tmp2) (H15 : In t tmp') (H19 : incl tmp1 tmp') (H20 : incl tmp2 tmp') (TY1 : Csyntax.typeof rf = typeof a1) (EV1 : eval_expr tge e le m a1 vf) (EV2 : eval_exprlist tge e le m al2 targs vargs) (cu' : Csyntax.program) (tfd : fundef) (J : Genv.find_funct tge vf = Some tfd) (K : tr_fundef cu' fd tfd) (L : linkorder cu' prog) (ce : composite_env) (v : val) (m0 : mem)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Ebuiltin ef tyargs rargs ty))\n  sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Ebuiltin ef tyargs rargs ty))\n  sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"exploit tr_top_leftcontext; eauto.\nclear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_exprlist; eauto.\nintros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nsimpl; auto.\nauto.\nexploit tr_simple_exprlist; eauto.\nintros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\nsimpl.\napply PTree.gss.\nintros; simpl.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Ebuiltin ef tyargs rargs ty))\n  sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Ebuiltin ef tyargs rargs ty)\n     sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\n    tr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Ebuiltin ef tyargs rargs ty)\n     sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\n    tr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (C (Ebuiltin ef tyargs rargs ty))\n  sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"clear TR.\nintros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_exprlist; eauto.\nintros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nsimpl; auto.\nauto.\nexploit tr_simple_exprlist; eauto.\nintros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\nsimpl.\napply PTree.gss.\nintros; simpl.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) : (exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Ebuiltin ef tyargs rargs ty)\n     sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\n    tr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"(exists\n   (dst' : destination) (sl1 sl2 : list statement) \n (a' : expr) (tmp' : list ident),\n   tr_top (prog_comp_env cu) tge e le m dst' (Ebuiltin ef tyargs rargs ty)\n     sl1 a' tmp' /\\\n   sl = sl1 ++ sl2 /\\\n   incl tmp' tmps /\\\n   (forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n      (sl3 : list statement),\n    tr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n    (forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\n    Csyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\n    tr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps)) ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk)","proofString":"intros [dst' [sl1 [sl2 [a' [tmp' [P [Q [R S]]]]]]]].\ninv P.\ninv H2.\nexploit tr_simple_exprlist; eauto.\nintros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nsimpl; auto.\nauto.\nexploit tr_simple_exprlist; eauto.\nintros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\nsimpl.\napply PTree.gss.\nintros; simpl.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Ebuiltin ef tyargs rargs ty) sl1\n  a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (P : tr_top (prog_comp_env cu) tge e le m dst' (Ebuiltin ef tyargs rargs ty) sl1\n  a' tmp') (Q : sl = sl1 ++ sl2) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps)","proofString":"inv P.\ninv H2.\nexploit tr_simple_exprlist; eauto.\nintros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nsimpl; auto.\nauto.\nexploit tr_simple_exprlist; eauto.\nintros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\nsimpl.\napply PTree.gss.\nintros; simpl.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Ebuiltin ef tyargs rargs ty) sl1 a' tmp') : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist (sl1 ++ sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl1 sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (H2 : tr_expr (prog_comp_env cu) le dst' (Ebuiltin ef tyargs rargs ty) sl1 a' tmp')","proofString":"inv H2.\nexploit tr_simple_exprlist; eauto.\nintros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nsimpl; auto.\nauto.\nexploit tr_simple_exprlist; eauto.\nintros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\nsimpl.\napply PTree.gss.\nintros; simpl.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl : list statement) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs sl al tmp1) (H13 : incl tmp1 tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e le\n        m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e le\n        m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e le\n        m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e le\n        m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl : list statement) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs sl al tmp1) (H13 : incl tmp1 tmp')","proofString":"exploit tr_simple_exprlist; eauto.\nintros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nsimpl; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl : list statement) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs sl al tmp1) (H13 : incl tmp1 tmp') : sl = nil /\\ eval_exprlist tge e le m al tyargs vargs ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e le\n        m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e le\n        m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"sl = nil /\\ eval_exprlist tge e le m al tyargs vargs ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e le\n        m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e le\n        m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl : list statement) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs sl al tmp1) (H13 : incl tmp1 tmp')","proofString":"intros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nsimpl; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl : list statement) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs sl al tmp1) (H13 : incl tmp1 tmp') (SL : sl = nil) (EV : eval_exprlist tge e le m al tyargs vargs) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e le\n        m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e le\n        m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e le\n        m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((sl ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e le\n        m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl : list statement) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs sl al tmp1) (H13 : incl tmp1 tmp') (SL : sl = nil) (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"subst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nsimpl; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H13 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((nil ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((nil ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist ((nil ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist ((nil ++ Sbuiltin None ef tyargs al :: nil) ++ sl2) tk) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H13 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nsimpl; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H13 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (Sbuiltin None ef tyargs al) (Kseqlist sl2 tk)) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (Sbuiltin None ef tyargs al) (Kseqlist sl2 tk)) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseq (Sbuiltin None ef tyargs al) (Kseqlist sl2 tk)) e\n        le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseq (Sbuiltin None ef tyargs al) (Kseqlist sl2 tk)) e\n        le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H13 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\nconstructor.\nsimpl; auto.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H13 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H13 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"apply senv_preserved."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H13 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : tr_expr (prog_comp_env cu) (set_opttemp None vres le) For_effects\n  (Eval vres ty) nil a' tmp'.","conclusion":"tr_expr (prog_comp_env cu) (set_opttemp None vres le) For_effects\n  (Eval vres ty) nil a' tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H13 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H13 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : forall id : ident, ~ In id tmp' -> (set_opttemp None vres le) ! id = le ! id.","conclusion":"forall id : ident, ~ In id tmp' -> (set_opttemp None vres le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H13 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"simpl; auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H13 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : Csyntax.typeof (Eval vres ty) = Csyntax.typeof (Ebuiltin ef tyargs rargs ty).","conclusion":"Csyntax.typeof (Eval vres ty) = Csyntax.typeof (Ebuiltin ef tyargs rargs ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (sl2 : list statement) (a' : expr) (tmp' : list ident) (R : incl tmp' tmps) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' For_effects r' sl3 a' tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H12 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H13 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl : list statement) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs sl al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl : list statement) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs sl al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp')","proofString":"exploit tr_simple_exprlist; eauto.\nintros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\nsimpl.\napply PTree.gss.\nintros; simpl.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl : list statement) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs sl al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') : sl = nil /\\ eval_exprlist tge e le m al tyargs vargs ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"sl = nil /\\ eval_exprlist tge e le m al tyargs vargs ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl : list statement) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs sl al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp')","proofString":"intros [SL EV].\nsubst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\nsimpl.\napply PTree.gss.\nintros; simpl.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl : list statement) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs sl al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (SL : sl = nil) (EV : eval_exprlist tge e le m al tyargs vargs) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((sl ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (sl : list statement) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs sl al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (SL : sl = nil) (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"subst.\nsimpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\nsimpl.\napply PTree.gss.\nintros; simpl.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((nil ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((nil ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((nil ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist\n           ((nil ++\n             Sbuiltin (Some t0) ef tyargs al :: final dst' (Etempvar t0 ty)) ++\n            sl2) tk) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"simpl Kseqlist.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\nsimpl.\napply PTree.gss.\nintros; simpl.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (Sbuiltin (Some t0) ef tyargs al)\n           (Kseqlist (final dst' (Etempvar t0 ty) ++ sl2) tk)) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (Sbuiltin (Some t0) ef tyargs al)\n           (Kseqlist (final dst' (Etempvar t0 ty) ++ sl2) tk)) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseq (Sbuiltin (Some t0) ef tyargs al)\n           (Kseqlist (final dst' (Etempvar t0 ty) ++ sl2) tk)) e le m) t S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseq (Sbuiltin (Some t0) ef tyargs al)\n           (Kseqlist (final dst' (Etempvar t0 ty) ++ sl2) tk)) e le m) t S2' /\\\n   (measure (ExprState f (C (Eval vres ty)) k e m') <\n    measure (ExprState f (C (Ebuiltin ef tyargs rargs ty)) k e m))%nat) /\\\n  match_states (ExprState f (C (Eval vres ty)) k e m') S2'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply star_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\ntraceEq.\neconstructor; eauto.\nchange sl2 with (nil ++ sl2).\napply S.\napply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\nsimpl.\napply PTree.gss.\nintros; simpl.\napply PTree.gso.\nintuition congruence.\nauto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"apply senv_preserved."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : tr_expr (prog_comp_env cu) (set_opttemp (Some t0) vres le) dst'\n  (Eval vres ty) (final dst' (Etempvar t0 ty)) (Etempvar t0 ty) tmp'.","conclusion":"tr_expr (prog_comp_env cu) (set_opttemp (Some t0) vres le) dst'\n  (Eval vres ty) (final dst' (Etempvar t0 ty)) (Etempvar t0 ty) tmp'","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"apply tr_val_gen.\nauto.\nintros.\nconstructor.\nrewrite H2; auto.\nsimpl.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : typeof (Etempvar t0 ty) = ty.","conclusion":"typeof (Etempvar t0 ty) = ty","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"auto."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive,\n In id tmp' -> le' ! id = (set_opttemp (Some t0) vres le) ! id) ->\neval_expr tge0 e0 le' m0 (Etempvar t0 ty) vres.","conclusion":"forall (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem),\n(forall id : positive,\n In id tmp' -> le' ! id = (set_opttemp (Some t0) vres le) ! id) ->\neval_expr tge0 e0 le' m0 (Etempvar t0 ty) vres","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"intros.\nconstructor.\nrewrite H2; auto.\nsimpl.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t0) vres le) ! id) : eval_expr tge0 e0 le' m0 (Etempvar t0 ty) vres.","conclusion":"eval_expr tge0 e0 le' m0 (Etempvar t0 ty) vres","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t0) vres le) ! id)","proofString":"constructor.\nrewrite H2; auto.\nsimpl.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t0) vres le) ! id) : le' ! t0 = Some vres.","conclusion":"le' ! t0 = Some vres","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t0) vres le) ! id)","proofString":"rewrite H2; auto.\nsimpl.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t0) vres le) ! id) : (set_opttemp (Some t0) vres le) ! t0 = Some vres.","conclusion":"(set_opttemp (Some t0) vres le) ! t0 = Some vres","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t0) vres le) ! id)","proofString":"simpl.\napply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t0) vres le) ! id) : (PTree.set t0 vres le) ! t0 = Some vres.","conclusion":"(PTree.set t0 vres le) ! t0 = Some vres","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le'0 : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le'0 dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le'0 ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le'0 m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) (tge0 : genv) (e0 : env) (le' : PTree.tree val) (m0 : mem) (H2 : forall id : positive,\nIn id tmp' -> le' ! id = (set_opttemp (Some t0) vres le) ! id)","proofString":"apply PTree.gss."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : forall id : ident,\n~ In id tmp' -> (set_opttemp (Some t0) vres le) ! id = le ! id.","conclusion":"forall id : ident,\n~ In id tmp' -> (set_opttemp (Some t0) vres le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"intros; simpl.\napply PTree.gso.\nintuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) (id : ident) (H2 : ~ In id tmp') : (PTree.set t0 vres le) ! id = le ! id.","conclusion":"(PTree.set t0 vres le) ! id = le ! id","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) (id : ident) (H2 : ~ In id tmp')","proofString":"apply PTree.gso.\nintuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) (id : ident) (H2 : ~ In id tmp') : id <> t0.","conclusion":"id <> t0","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id0 : ident, ~ In id0 tmp' -> le' ! id0 = le ! id0) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) (id : ident) (H2 : ~ In id tmp')","proofString":"intuition congruence."},{"statement":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs) : Csyntax.typeof (Eval vres ty) = Csyntax.typeof (Ebuiltin ef tyargs rargs ty).","conclusion":"Csyntax.typeof (Eval vres ty) = Csyntax.typeof (Ebuiltin ef tyargs rargs ty)","hypotheses":"(f : Csyntax.function) (C : Csyntax.expr -> Csyntax.expr) (ef : external_function) (tyargs : list type) (rargs : exprlist) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : leftcontext RV RV C) (H0 : eval_simple_list ge e m rargs tyargs vargs) (H1 : external_call ef ge vargs m t vres m') (tf : function) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont_exp (prog_comp_env cu) dest a k tk) (dst' : destination) (sl2 : list statement) (tmp' : list ident) (R : incl tmp' tmps) (t0 : ident) (S : forall (le' : temp_env) (m'0 : mem) (r' : Csyntax.expr)\n  (sl3 : list statement),\ntr_expr (prog_comp_env cu) le' dst' r' sl3 (Etempvar t0 ty) tmp' ->\n(forall id : ident, ~ In id tmp' -> le' ! id = le ! id) ->\nCsyntax.typeof r' = Csyntax.typeof (Ebuiltin ef tyargs rargs ty) ->\ntr_top (prog_comp_env cu) tge e le' m'0 dest (C r') (sl3 ++ sl2) a tmps) (al : list expr) (tmp1 : list ident) (H9 : dst' <> For_effects) (H13 : tr_exprlist (prog_comp_env cu) le rargs nil al tmp1) (H14 : In t0 tmp') (H15 : incl tmp1 tmp') (EV : eval_exprlist tge e le m al tyargs vargs)","proofString":"auto."},{"statement":"(ce : composite_env) (e : env) (le : temp_env) (m : mem) (v : val) (ty : type) (sl : list statement) (a : expr) (tmps : list ident) (H : tr_top ce tge e le m For_val (Eval v ty) sl a tmps) : sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v.","conclusion":"sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v","hypotheses":"(ce : composite_env) (e : env) (le : temp_env) (m : mem) (v : val) (ty : type) (sl : list statement) (a : expr) (tmps : list ident) (H : tr_top ce tge e le m For_val (Eval v ty) sl a tmps)","proofString":"inv H.\nauto.\ninv H0.\nauto."},{"statement":"(ce : composite_env) (e : env) (le : temp_env) (m : mem) (v : val) (ty : type) (sl : list statement) (a : expr) (tmps : list ident) (H0 : tr_expr ce le For_val (Eval v ty) sl a tmps) : sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v.","conclusion":"sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v","hypotheses":"(ce : composite_env) (e : env) (le : temp_env) (m : mem) (v : val) (ty : type) (sl : list statement) (a : expr) (tmps : list ident) (H0 : tr_expr ce le For_val (Eval v ty) sl a tmps)","proofString":"inv H0.\nauto."},{"statement":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csem.env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : Csem.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : alloc_variables tge (PTree.set id (b1, ty) e) m1 vars e2 m2) : Mem.alloc m 0 (sizeof tge ty) = (m1, b1).","conclusion":"Mem.alloc m 0 (sizeof tge ty) = (m1, b1)","hypotheses":"(e : PTree.tree (block * type)) (m : mem) (id : positive) (ty : type) (vars : list (ident * type)) (m1 : Mem.mem') (b1 : block) (m2 : mem) (e2 : Csem.env) (H : Mem.alloc m 0 (sizeof ge ty) = (m1, b1)) (H0 : Csem.alloc_variables ge (PTree.set id (b1, ty) e) m1 vars e2 m2) (IHalloc_variables : alloc_variables tge (PTree.set id (b1, ty) e) m1 vars e2 m2)","proofString":"rewrite comp_env_preserved; auto."},{"statement":"(e : Csem.env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (v1' : val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H0 : Csem.assign_loc ge ty m b Ptrofs.zero Full v1 E0 m1 v1') (H1 : Csem.bind_parameters ge e m1 params vl m2) (IHbind_parameters : bind_parameters tge e m1 params vl m2) : assign_loc tge ty m b Ptrofs.zero Full v1 m1.","conclusion":"assign_loc tge ty m b Ptrofs.zero Full v1 m1","hypotheses":"(e : Csem.env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (v1 : val) (vl : list val) (v1' : val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H0 : Csem.assign_loc ge ty m b Ptrofs.zero Full v1 E0 m1 v1') (H1 : Csem.bind_parameters ge e m1 params vl m2) (IHbind_parameters : bind_parameters tge e m1 params vl m2)","proofString":"inv H0.\neapply assign_loc_value; eauto.\ninv H4.\neapply assign_loc_value; eauto.\nrewrite <- comp_env_preserved in *.\neapply assign_loc_copy; eauto."},{"statement":"(e : Csem.env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (vl : list val) (v1' : val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H1 : Csem.bind_parameters ge e m1 params vl m2) (IHbind_parameters : bind_parameters tge e m1 params vl m2) (chunk : memory_chunk) (H2 : access_mode ty = By_value chunk) (H3 : type_is_volatile ty = false) (H4 : Mem.storev chunk m (Vptr b Ptrofs.zero) v1' = Some m1) : assign_loc tge ty m b Ptrofs.zero Full v1' m1.","conclusion":"assign_loc tge ty m b Ptrofs.zero Full v1' m1","hypotheses":"(e : Csem.env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (vl : list val) (v1' : val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H1 : Csem.bind_parameters ge e m1 params vl m2) (IHbind_parameters : bind_parameters tge e m1 params vl m2) (chunk : memory_chunk) (H2 : access_mode ty = By_value chunk) (H3 : type_is_volatile ty = false) (H4 : Mem.storev chunk m (Vptr b Ptrofs.zero) v1' = Some m1)","proofString":"eapply assign_loc_value; eauto."},{"statement":"(e : Csem.env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (vl : list val) (v1' : val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H1 : Csem.bind_parameters ge e m1 params vl m2) (IHbind_parameters : bind_parameters tge e m1 params vl m2) (chunk : memory_chunk) (H2 : access_mode ty = By_value chunk) (H3 : type_is_volatile ty = true) (H4 : volatile_store ge chunk m b Ptrofs.zero v1' E0 m1) : assign_loc tge ty m b Ptrofs.zero Full v1' m1.","conclusion":"assign_loc tge ty m b Ptrofs.zero Full v1' m1","hypotheses":"(e : Csem.env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (vl : list val) (v1' : val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H1 : Csem.bind_parameters ge e m1 params vl m2) (IHbind_parameters : bind_parameters tge e m1 params vl m2) (chunk : memory_chunk) (H2 : access_mode ty = By_value chunk) (H3 : type_is_volatile ty = true) (H4 : volatile_store ge chunk m b Ptrofs.zero v1' E0 m1)","proofString":"inv H4.\neapply assign_loc_value; eauto."},{"statement":"(e : Csem.env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (vl : list val) (v1' : val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H1 : Csem.bind_parameters ge e m1 params vl m2) (IHbind_parameters : bind_parameters tge e m1 params vl m2) (chunk : memory_chunk) (H2 : access_mode ty = By_value chunk) (H3 : type_is_volatile ty = true) (H0 : Senv.block_is_volatile ge b = false) (H5 : Mem.store chunk m b (Ptrofs.unsigned Ptrofs.zero) v1' = Some m1) : assign_loc tge ty m b Ptrofs.zero Full v1' m1.","conclusion":"assign_loc tge ty m b Ptrofs.zero Full v1' m1","hypotheses":"(e : Csem.env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (vl : list val) (v1' : val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H1 : Csem.bind_parameters ge e m1 params vl m2) (IHbind_parameters : bind_parameters tge e m1 params vl m2) (chunk : memory_chunk) (H2 : access_mode ty = By_value chunk) (H3 : type_is_volatile ty = true) (H0 : Senv.block_is_volatile ge b = false) (H5 : Mem.store chunk m b (Ptrofs.unsigned Ptrofs.zero) v1' = Some m1)","proofString":"eapply assign_loc_value; eauto."},{"statement":"(e : Csem.env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (vl : list val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H1 : Csem.bind_parameters ge e m1 params vl m2) (IHbind_parameters : bind_parameters tge e m1 params vl m2) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H2 : access_mode ty = By_copy) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H4 : (alignof_blockcopy ge ty | Ptrofs.unsigned Ptrofs.zero)) (H5 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned Ptrofs.zero \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned Ptrofs.zero \\/\nPtrofs.unsigned Ptrofs.zero + sizeof ge ty <= Ptrofs.unsigned ofs') (H6 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H7 : Mem.storebytes m b (Ptrofs.unsigned Ptrofs.zero) bytes = Some m1) : assign_loc tge ty m b Ptrofs.zero Full (Vptr b' ofs') m1.","conclusion":"assign_loc tge ty m b Ptrofs.zero Full (Vptr b' ofs') m1","hypotheses":"(e : Csem.env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (vl : list val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H1 : Csem.bind_parameters ge e m1 params vl m2) (IHbind_parameters : bind_parameters tge e m1 params vl m2) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H2 : access_mode ty = By_copy) (H3 : (alignof_blockcopy ge ty | Ptrofs.unsigned ofs')) (H4 : (alignof_blockcopy ge ty | Ptrofs.unsigned Ptrofs.zero)) (H5 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned Ptrofs.zero \\/\nPtrofs.unsigned ofs' + sizeof ge ty <= Ptrofs.unsigned Ptrofs.zero \\/\nPtrofs.unsigned Ptrofs.zero + sizeof ge ty <= Ptrofs.unsigned ofs') (H6 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ge ty) = Some bytes) (H7 : Mem.storebytes m b (Ptrofs.unsigned Ptrofs.zero) bytes = Some m1)","proofString":"rewrite <- comp_env_preserved in *.\neapply assign_loc_copy; eauto."},{"statement":"(e : Csem.env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (vl : list val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H1 : Csem.bind_parameters ge e m1 params vl m2) (IHbind_parameters : bind_parameters tge e m1 params vl m2) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H2 : access_mode ty = By_copy) (H3 : (alignof_blockcopy tge ty | Ptrofs.unsigned ofs')) (H4 : (alignof_blockcopy tge ty | Ptrofs.unsigned Ptrofs.zero)) (H5 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned Ptrofs.zero \\/\nPtrofs.unsigned ofs' + sizeof tge ty <= Ptrofs.unsigned Ptrofs.zero \\/\nPtrofs.unsigned Ptrofs.zero + sizeof tge ty <= Ptrofs.unsigned ofs') (H6 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof tge ty) = Some bytes) (H7 : Mem.storebytes m b (Ptrofs.unsigned Ptrofs.zero) bytes = Some m1) : assign_loc tge ty m b Ptrofs.zero Full (Vptr b' ofs') m1.","conclusion":"assign_loc tge ty m b Ptrofs.zero Full (Vptr b' ofs') m1","hypotheses":"(e : Csem.env) (m : mem) (id : positive) (ty : type) (params : list (ident * type)) (vl : list val) (b : block) (m1 m2 : mem) (H : e ! id = Some (b, ty)) (H1 : Csem.bind_parameters ge e m1 params vl m2) (IHbind_parameters : bind_parameters tge e m1 params vl m2) (b' : block) (ofs' : ptrofs) (bytes : list memval) (H2 : access_mode ty = By_copy) (H3 : (alignof_blockcopy tge ty | Ptrofs.unsigned ofs')) (H4 : (alignof_blockcopy tge ty | Ptrofs.unsigned Ptrofs.zero)) (H5 : b' <> b \\/\nPtrofs.unsigned ofs' = Ptrofs.unsigned Ptrofs.zero \\/\nPtrofs.unsigned ofs' + sizeof tge ty <= Ptrofs.unsigned Ptrofs.zero \\/\nPtrofs.unsigned Ptrofs.zero + sizeof tge ty <= Ptrofs.unsigned ofs') (H6 : Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof tge ty) = Some bytes) (H7 : Mem.storebytes m b (Ptrofs.unsigned Ptrofs.zero) bytes = Some m1)","proofString":"eapply assign_loc_copy; eauto."},{"statement":"(e : env) : map (block_of_binding tge) (PTree.elements e) =\nmap (Csem.block_of_binding ge) (PTree.elements e).","conclusion":"map (block_of_binding tge) (PTree.elements e) =\nmap (Csem.block_of_binding ge) (PTree.elements e)","hypotheses":"(e : env)","proofString":"unfold block_of_binding, Csem.block_of_binding.\nrewrite comp_env_preserved.\nauto."},{"statement":"(e : env) : map\n  (fun id_b_ty : ident * (block * type) =>\n   let (_, p) := id_b_ty in let (b, ty) := p in (b, 0, sizeof tge ty))\n  (PTree.elements e) =\nmap\n  (fun id_b_ty : ident * (block * type) =>\n   let (_, p) := id_b_ty in let (b, ty) := p in (b, 0, sizeof ge ty))\n  (PTree.elements e).","conclusion":"map\n  (fun id_b_ty : ident * (block * type) =>\n   let (_, p) := id_b_ty in let (b, ty) := p in (b, 0, sizeof tge ty))\n  (PTree.elements e) =\nmap\n  (fun id_b_ty : ident * (block * type) =>\n   let (_, p) := id_b_ty in let (b, ty) := p in (b, 0, sizeof ge ty))\n  (PTree.elements e)","hypotheses":"(e : env)","proofString":"rewrite comp_env_preserved.\nauto."},{"statement":"(e : env) : map\n  (fun id_b_ty : ident * (block * type) =>\n   let (_, p) := id_b_ty in let (b, ty) := p in (b, 0, sizeof ge ty))\n  (PTree.elements e) =\nmap\n  (fun id_b_ty : ident * (block * type) =>\n   let (_, p) := id_b_ty in let (b, ty) := p in (b, 0, sizeof ge ty))\n  (PTree.elements e).","conclusion":"map\n  (fun id_b_ty : ident * (block * type) =>\n   let (_, p) := id_b_ty in let (b, ty) := p in (b, 0, sizeof ge ty))\n  (PTree.elements e) =\nmap\n  (fun id_b_ty : ident * (block * type) =>\n   let (_, p) := id_b_ty in let (b, ty) := p in (b, 0, sizeof ge ty))\n  (PTree.elements e)","hypotheses":"(e : env)","proofString":"auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Sdo x) ts) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kdo k) e m) <\n    measure (Csem.State f (Sdo x) k e m))%nat) /\\\n  match_states (ExprState f x (Kdo k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kdo k) e m) <\n    measure (Csem.State f (Sdo x) k e m))%nat) /\\\n  match_states (ExprState f x (Kdo k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Sdo x) ts) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR.\ninv H0.\neconstructor; split.\nright; split.\napply push_seq.\nsimpl.\nlia.\neconstructor; eauto.\nconstructor.\nauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H0 : tr_expr_stmt (prog_comp_env cu) x ts) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kdo k) e m) <\n    measure (Csem.State f (Sdo x) k e m))%nat) /\\\n  match_states (ExprState f x (Kdo k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kdo k) e m) <\n    measure (Csem.State f (Sdo x) k e m))%nat) /\\\n  match_states (ExprState f x (Kdo k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H0 : tr_expr_stmt (prog_comp_env cu) x ts)","proofString":"inv H0.\neconstructor; split.\nright; split.\napply push_seq.\nsimpl.\nlia.\neconstructor; eauto.\nconstructor.\nauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_effects x sl a tmps) : exists S2' : state,\n  (plus step1 tge (State tf (makeseq sl) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (makeseq sl) tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kdo k) e m) <\n    measure (Csem.State f (Sdo x) k e m))%nat) /\\\n  match_states (ExprState f x (Kdo k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (makeseq sl) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (makeseq sl) tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kdo k) e m) <\n    measure (Csem.State f (Sdo x) k e m))%nat) /\\\n  match_states (ExprState f x (Kdo k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_effects x sl a tmps)","proofString":"econstructor; split.\nright; split.\napply push_seq.\nsimpl.\nlia.\neconstructor; eauto.\nconstructor.\nauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_effects x sl a tmps) : (measure (ExprState f x (Kdo k) e m) < measure (Csem.State f (Sdo x) k e m))%nat.","conclusion":"(measure (ExprState f x (Kdo k) e m) < measure (Csem.State f (Sdo x) k e m))%nat","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_effects x sl a tmps)","proofString":"simpl.\nlia."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_effects x sl a tmps) : (esize x + 1 < esize x + 2)%nat.","conclusion":"(esize x + 1 < esize x + 2)%nat","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_effects x sl a tmps)","proofString":"lia."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_effects x sl a tmps) : match_cont_exp (prog_comp_env cu) For_effects a (Kdo k) tk.","conclusion":"match_cont_exp (prog_comp_env cu) For_effects a (Kdo k) tk","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_effects x sl a tmps)","proofString":"constructor.\nauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_effects x sl a tmps) : match_cont (prog_comp_env cu) k tk.","conclusion":"match_cont (prog_comp_env cu) k tk","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_effects x sl a tmps)","proofString":"auto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kdo k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdo k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdo k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kdo k) tk)","proofString":"inv MK.\ninv TR.\ninv H.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\nlia.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects (Eval v ty) sl a tmps) (H3 : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdo k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdo k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_effects (Eval v ty) sl a tmps) (H3 : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR.\ninv H.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\nlia.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (H3 : match_cont (prog_comp_env cu) k tk) (H : tr_expr (prog_comp_env cu) le For_effects (Eval v ty) sl a tmps) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdo k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdo k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (H3 : match_cont (prog_comp_env cu) k tk) (H : tr_expr (prog_comp_env cu) le For_effects (Eval v ty) sl a tmps)","proofString":"inv H.\neconstructor; split.\nright; split.\napply star_refl.\nsimpl.\nlia.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (H3 : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist nil tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist nil tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdo k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist nil tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist nil tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdo k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (H3 : match_cont (prog_comp_env cu) k tk)","proofString":"econstructor; split.\nright; split.\napply star_refl.\nsimpl.\nlia.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (H3 : match_cont (prog_comp_env cu) k tk) : (measure (Csem.State f Csyntax.Sskip k e m) <\n measure (ExprState f (Eval v ty) (Kdo k) e m))%nat.","conclusion":"(measure (Csem.State f Csyntax.Sskip k e m) <\n measure (ExprState f (Eval v ty) (Kdo k) e m))%nat","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (H3 : match_cont (prog_comp_env cu) k tk)","proofString":"simpl.\nlia."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (H3 : match_cont (prog_comp_env cu) k tk) : (0 < 1)%nat.","conclusion":"(0 < 1)%nat","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (H3 : match_cont (prog_comp_env cu) k tk)","proofString":"lia."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (H3 : match_cont (prog_comp_env cu) k tk) : tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip.","conclusion":"tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (H3 : match_cont (prog_comp_env cu) k tk)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Ssequence s1 s2) ts) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f s1 (Csem.Kseq s2 k) e m) <\n    measure (Csem.State f (Csyntax.Ssequence s1 s2) k e m))%nat) /\\\n  match_states (Csem.State f s1 (Csem.Kseq s2 k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f s1 (Csem.Kseq s2 k) e m) <\n    measure (Csem.State f (Csyntax.Ssequence s1 s2) k e m))%nat) /\\\n  match_states (Csem.State f s1 (Csem.Kseq s2 k) e m) S2'","hypotheses":"(f : Csyntax.function) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Ssequence s1 s2) ts) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR.\neconstructor; split.\nleft.\napply plus_one.\nconstructor.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 ts2 : statement) (H1 : tr_stmt (prog_comp_env cu) s1 ts1) (H3 : tr_stmt (prog_comp_env cu) s2 ts2) : exists S2' : state,\n  (plus step1 tge (State tf (Ssequence ts1 ts2) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Ssequence ts1 ts2) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s1 (Csem.Kseq s2 k) e m) <\n    measure (Csem.State f (Csyntax.Ssequence s1 s2) k e m))%nat) /\\\n  match_states (Csem.State f s1 (Csem.Kseq s2 k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Ssequence ts1 ts2) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Ssequence ts1 ts2) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s1 (Csem.Kseq s2 k) e m) <\n    measure (Csem.State f (Csyntax.Ssequence s1 s2) k e m))%nat) /\\\n  match_states (Csem.State f s1 (Csem.Kseq s2 k) e m) S2'","hypotheses":"(f : Csyntax.function) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 ts2 : statement) (H1 : tr_stmt (prog_comp_env cu) s1 ts1) (H3 : tr_stmt (prog_comp_env cu) s2 ts2)","proofString":"econstructor; split.\nleft.\napply plus_one.\nconstructor.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 ts2 : statement) (H1 : tr_stmt (prog_comp_env cu) s1 ts1) (H3 : tr_stmt (prog_comp_env cu) s2 ts2) : match_cont (prog_comp_env cu) (Csem.Kseq s2 k) (Kseq ts2 tk).","conclusion":"match_cont (prog_comp_env cu) (Csem.Kseq s2 k) (Kseq ts2 tk)","hypotheses":"(f : Csyntax.function) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 ts2 : statement) (H1 : tr_stmt (prog_comp_env cu) s1 ts1) (H3 : tr_stmt (prog_comp_env cu) s2 ts2)","proofString":"constructor; auto."},{"statement":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sskip ts) (MK : match_cont (prog_comp_env cu) (Csem.Kseq s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f s k e m) <\n    measure (Csem.State f Csyntax.Sskip (Csem.Kseq s k) e m))%nat) /\\\n  match_states (Csem.State f s k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f s k e m) <\n    measure (Csem.State f Csyntax.Sskip (Csem.Kseq s k) e m))%nat) /\\\n  match_states (Csem.State f s k e m) S2'","hypotheses":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sskip ts) (MK : match_cont (prog_comp_env cu) (Csem.Kseq s k) tk)","proofString":"inv TR; inv MK.\neconstructor; split.\nleft.\napply plus_one; constructor.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts : statement) (tk0 : cont) (H2 : tr_stmt (prog_comp_env cu) s ts) (H4 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseq ts tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseq ts tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f s k e m) <\n    measure (Csem.State f Csyntax.Sskip (Csem.Kseq s k) e m))%nat) /\\\n  match_states (Csem.State f s k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseq ts tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseq ts tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f s k e m) <\n    measure (Csem.State f Csyntax.Sskip (Csem.Kseq s k) e m))%nat) /\\\n  match_states (Csem.State f s k e m) S2'","hypotheses":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts : statement) (tk0 : cont) (H2 : tr_stmt (prog_comp_env cu) s ts) (H4 : match_cont (prog_comp_env cu) k tk0)","proofString":"econstructor; split.\nleft.\napply plus_one; constructor.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Scontinue ts) (MK : match_cont (prog_comp_env cu) (Csem.Kseq s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Scontinue k e m) <\n    measure (Csem.State f Csyntax.Scontinue (Csem.Kseq s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Scontinue k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Scontinue k e m) <\n    measure (Csem.State f Csyntax.Scontinue (Csem.Kseq s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Scontinue k e m) S2'","hypotheses":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Scontinue ts) (MK : match_cont (prog_comp_env cu) (Csem.Kseq s k) tk)","proofString":"inv TR; inv MK.\neconstructor; split.\nleft.\napply plus_one; constructor.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts : statement) (tk0 : cont) (H2 : tr_stmt (prog_comp_env cu) s ts) (H4 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge (State tf Scontinue (Kseq ts tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf Scontinue (Kseq ts tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Scontinue k e m) <\n    measure (Csem.State f Csyntax.Scontinue (Csem.Kseq s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Scontinue k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Scontinue (Kseq ts tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf Scontinue (Kseq ts tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Scontinue k e m) <\n    measure (Csem.State f Csyntax.Scontinue (Csem.Kseq s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Scontinue k e m) S2'","hypotheses":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts : statement) (tk0 : cont) (H2 : tr_stmt (prog_comp_env cu) s ts) (H4 : match_cont (prog_comp_env cu) k tk0)","proofString":"econstructor; split.\nleft.\napply plus_one; constructor.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts : statement) (tk0 : cont) (H2 : tr_stmt (prog_comp_env cu) s ts) (H4 : match_cont (prog_comp_env cu) k tk0) : tr_stmt (prog_comp_env cu) Csyntax.Scontinue Scontinue.","conclusion":"tr_stmt (prog_comp_env cu) Csyntax.Scontinue Scontinue","hypotheses":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts : statement) (tk0 : cont) (H2 : tr_stmt (prog_comp_env cu) s ts) (H4 : match_cont (prog_comp_env cu) k tk0)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sbreak ts) (MK : match_cont (prog_comp_env cu) (Csem.Kseq s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sbreak k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Csem.Kseq s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sbreak k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sbreak k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Csem.Kseq s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sbreak k e m) S2'","hypotheses":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sbreak ts) (MK : match_cont (prog_comp_env cu) (Csem.Kseq s k) tk)","proofString":"inv TR; inv MK.\neconstructor; split.\nleft.\napply plus_one; constructor.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts : statement) (tk0 : cont) (H2 : tr_stmt (prog_comp_env cu) s ts) (H4 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge (State tf Sbreak (Kseq ts tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf Sbreak (Kseq ts tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sbreak k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Csem.Kseq s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sbreak k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sbreak (Kseq ts tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf Sbreak (Kseq ts tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sbreak k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Csem.Kseq s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sbreak k e m) S2'","hypotheses":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts : statement) (tk0 : cont) (H2 : tr_stmt (prog_comp_env cu) s ts) (H4 : match_cont (prog_comp_env cu) k tk0)","proofString":"econstructor; split.\nleft.\napply plus_one; constructor.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts : statement) (tk0 : cont) (H2 : tr_stmt (prog_comp_env cu) s ts) (H4 : match_cont (prog_comp_env cu) k tk0) : tr_stmt (prog_comp_env cu) Csyntax.Sbreak Sbreak.","conclusion":"tr_stmt (prog_comp_env cu) Csyntax.Sbreak Sbreak","hypotheses":"(f : Csyntax.function) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts : statement) (tk0 : cont) (H2 : tr_stmt (prog_comp_env cu) s ts) (H4 : match_cont (prog_comp_env cu) k tk0)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sifthenelse a s1 s2) ts) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f a (Kifthenelse s1 s2 k) e m) <\n    measure (Csem.State f (Csyntax.Sifthenelse a s1 s2) k e m))%nat) /\\\n  match_states (ExprState f a (Kifthenelse s1 s2 k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f a (Kifthenelse s1 s2 k) e m) <\n    measure (Csem.State f (Csyntax.Sifthenelse a s1 s2) k e m))%nat) /\\\n  match_states (ExprState f a (Kifthenelse s1 s2 k) e m) S2'","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sifthenelse a s1 s2) ts) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR.\ninv H3.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply push_seq.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto.\ninv H2.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply push_seq.\ntraceEq.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' : statement) (a0 : expr) (H3 : tr_expression (prog_comp_env cu) a s' a0) : exists S2' : state,\n  (plus step1 tge (State tf (Ssequence s' Sskip) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Ssequence s' Sskip) tk e le m) E0 S2' /\\\n   (measure (ExprState f a (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e m) <\n    measure\n      (Csem.State f (Csyntax.Sifthenelse a Csyntax.Sskip Csyntax.Sskip) k e m))%nat) /\\\n  match_states\n    (ExprState f a (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Ssequence s' Sskip) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Ssequence s' Sskip) tk e le m) E0 S2' /\\\n   (measure (ExprState f a (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e m) <\n    measure\n      (Csem.State f (Csyntax.Sifthenelse a Csyntax.Sskip Csyntax.Sskip) k e m))%nat) /\\\n  match_states\n    (ExprState f a (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e m) S2'","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' : statement) (a0 : expr) (H3 : tr_expression (prog_comp_env cu) a s' a0)","proofString":"inv H3.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply push_seq.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a0 : expr) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a sl a0 tmps) : exists S2' : state,\n  (plus step1 tge (State tf (Ssequence (makeseq sl) Sskip) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Ssequence (makeseq sl) Sskip) tk e le m) E0 S2' /\\\n   (measure (ExprState f a (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e m) <\n    measure\n      (Csem.State f (Csyntax.Sifthenelse a Csyntax.Sskip Csyntax.Sskip) k e m))%nat) /\\\n  match_states\n    (ExprState f a (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Ssequence (makeseq sl) Sskip) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Ssequence (makeseq sl) Sskip) tk e le m) E0 S2' /\\\n   (measure (ExprState f a (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e m) <\n    measure\n      (Csem.State f (Csyntax.Sifthenelse a Csyntax.Sskip Csyntax.Sskip) k e m))%nat) /\\\n  match_states\n    (ExprState f a (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e m) S2'","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a0 : expr) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a sl a0 tmps)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply push_seq.\neconstructor; eauto.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a0 : expr) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a sl a0 tmps) : match_cont_exp (prog_comp_env cu) For_val a0\n  (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) (Kseq Sskip tk).","conclusion":"match_cont_exp (prog_comp_env cu) For_val a0\n  (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) (Kseq Sskip tk)","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a0 : expr) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a sl a0 tmps)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' : statement) (a0 : expr) (ts1 ts2 : statement) (H2 : tr_expression (prog_comp_env cu) a s' a0) (H4 : tr_stmt (prog_comp_env cu) s1 ts1) (H5 : tr_stmt (prog_comp_env cu) s2 ts2) : exists S2' : state,\n  (plus step1 tge\n     (State tf (Ssequence s' (Sifthenelse a0 ts1 ts2)) tk e le m) E0 S2' \\/\n   star step1 tge\n     (State tf (Ssequence s' (Sifthenelse a0 ts1 ts2)) tk e le m) E0 S2' /\\\n   (measure (ExprState f a (Kifthenelse s1 s2 k) e m) <\n    measure (Csem.State f (Csyntax.Sifthenelse a s1 s2) k e m))%nat) /\\\n  match_states (ExprState f a (Kifthenelse s1 s2 k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf (Ssequence s' (Sifthenelse a0 ts1 ts2)) tk e le m) E0 S2' \\/\n   star step1 tge\n     (State tf (Ssequence s' (Sifthenelse a0 ts1 ts2)) tk e le m) E0 S2' /\\\n   (measure (ExprState f a (Kifthenelse s1 s2 k) e m) <\n    measure (Csem.State f (Csyntax.Sifthenelse a s1 s2) k e m))%nat) /\\\n  match_states (ExprState f a (Kifthenelse s1 s2 k) e m) S2'","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' : statement) (a0 : expr) (ts1 ts2 : statement) (H2 : tr_expression (prog_comp_env cu) a s' a0) (H4 : tr_stmt (prog_comp_env cu) s1 ts1) (H5 : tr_stmt (prog_comp_env cu) s2 ts2)","proofString":"inv H2.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply push_seq.\ntraceEq.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a0 : expr) (ts1 ts2 : statement) (H4 : tr_stmt (prog_comp_env cu) s1 ts1) (H5 : tr_stmt (prog_comp_env cu) s2 ts2) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a sl a0 tmps) : exists S2' : state,\n  (plus step1 tge\n     (State tf (Ssequence (makeseq sl) (Sifthenelse a0 ts1 ts2)) tk e le m)\n     E0 S2' \\/\n   star step1 tge\n     (State tf (Ssequence (makeseq sl) (Sifthenelse a0 ts1 ts2)) tk e le m)\n     E0 S2' /\\\n   (measure (ExprState f a (Kifthenelse s1 s2 k) e m) <\n    measure (Csem.State f (Csyntax.Sifthenelse a s1 s2) k e m))%nat) /\\\n  match_states (ExprState f a (Kifthenelse s1 s2 k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf (Ssequence (makeseq sl) (Sifthenelse a0 ts1 ts2)) tk e le m)\n     E0 S2' \\/\n   star step1 tge\n     (State tf (Ssequence (makeseq sl) (Sifthenelse a0 ts1 ts2)) tk e le m)\n     E0 S2' /\\\n   (measure (ExprState f a (Kifthenelse s1 s2 k) e m) <\n    measure (Csem.State f (Csyntax.Sifthenelse a s1 s2) k e m))%nat) /\\\n  match_states (ExprState f a (Kifthenelse s1 s2 k) e m) S2'","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a0 : expr) (ts1 ts2 : statement) (H4 : tr_stmt (prog_comp_env cu) s1 ts1) (H5 : tr_stmt (prog_comp_env cu) s2 ts2) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a sl a0 tmps)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\napply push_seq.\ntraceEq.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a0 : expr) (ts1 ts2 : statement) (H4 : tr_stmt (prog_comp_env cu) s1 ts1) (H5 : tr_stmt (prog_comp_env cu) s2 ts2) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a sl a0 tmps) : match_cont_exp (prog_comp_env cu) For_val a0 (Kifthenelse s1 s2 k)\n  (Kseq (Sifthenelse a0 ts1 ts2) tk).","conclusion":"match_cont_exp (prog_comp_env cu) For_val a0 (Kifthenelse s1 s2 k)\n  (Kseq (Sifthenelse a0 ts1 ts2) tk)","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a0 : expr) (ts1 ts2 : statement) (H4 : tr_stmt (prog_comp_env cu) s1 ts1) (H5 : tr_stmt (prog_comp_env cu) s2 ts2) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a sl a0 tmps)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kifthenelse s1 s2 k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f (if b then s1 else s2) k e m) <\n    measure (ExprState f (Eval v ty) (Kifthenelse s1 s2 k) e m))%nat) /\\\n  match_states (Csem.State f (if b then s1 else s2) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f (if b then s1 else s2) k e m) <\n    measure (ExprState f (Eval v ty) (Kifthenelse s1 s2 k) e m))%nat) /\\\n  match_states (Csem.State f (if b then s1 else s2) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kifthenelse s1 s2 k) tk)","proofString":"inv MK.\nexploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split; simpl.\nright.\ndestruct b; econstructor; eauto.\neapply star_left.\napply step_skip_seq.\neconstructor.\ntraceEq.\neapply star_left.\napply step_skip_seq.\neconstructor.\ntraceEq.\ndestruct b; econstructor; eauto.\neconstructor; eauto.\neconstructor; eauto.\nexploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\napply step_ifthenelse with (v1 := v) (b := b); auto.\ntraceEq.\ndestruct b; econstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (tk0 : cont) (H7 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl (Kseq Sskip tk0)) e le m) E0\n     S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl (Kseq Sskip tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) <\n    measure\n      (ExprState f (Eval v ty) (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e\n         m))%nat) /\\\n  match_states\n    (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl (Kseq Sskip tk0)) e le m) E0\n     S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl (Kseq Sskip tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) <\n    measure\n      (ExprState f (Eval v ty) (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e\n         m))%nat) /\\\n  match_states\n    (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (tk0 : cont) (H7 : match_cont (prog_comp_env cu) k tk0)","proofString":"exploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split; simpl.\nright.\ndestruct b; econstructor; eauto.\neapply star_left.\napply step_skip_seq.\neconstructor.\ntraceEq.\neapply star_left.\napply step_skip_seq.\neconstructor.\ntraceEq.\ndestruct b; econstructor; eauto.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (tk0 : cont) (H7 : match_cont (prog_comp_env cu) k tk0) : sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl (Kseq Sskip tk0)) e le m) E0\n     S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl (Kseq Sskip tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) <\n    measure\n      (ExprState f (Eval v ty) (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e\n         m))%nat) /\\\n  match_states\n    (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) S2'.","conclusion":"sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl (Kseq Sskip tk0)) e le m) E0\n     S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl (Kseq Sskip tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) <\n    measure\n      (ExprState f (Eval v ty) (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e\n         m))%nat) /\\\n  match_states\n    (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (tk0 : cont) (H7 : match_cont (prog_comp_env cu) k tk0)","proofString":"intros [A [B C]].\nsubst.\neconstructor; split; simpl.\nright.\ndestruct b; econstructor; eauto.\neapply star_left.\napply step_skip_seq.\neconstructor.\ntraceEq.\neapply star_left.\napply step_skip_seq.\neconstructor.\ntraceEq.\ndestruct b; econstructor; eauto.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (tk0 : cont) (H7 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl (Kseq Sskip tk0)) e le m) E0\n     S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl (Kseq Sskip tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) <\n    measure\n      (ExprState f (Eval v ty) (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e\n         m))%nat) /\\\n  match_states\n    (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl (Kseq Sskip tk0)) e le m) E0\n     S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl (Kseq Sskip tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) <\n    measure\n      (ExprState f (Eval v ty) (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e\n         m))%nat) /\\\n  match_states\n    (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (tk0 : cont) (H7 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v)","proofString":"subst.\neconstructor; split; simpl.\nright.\ndestruct b; econstructor; eauto.\neapply star_left.\napply step_skip_seq.\neconstructor.\ntraceEq.\neapply star_left.\napply step_skip_seq.\neconstructor.\ntraceEq.\ndestruct b; econstructor; eauto.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (a : expr) (H : bool_val v (typeof a) m = Some b) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tk0 : cont) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist nil (Kseq Sskip tk0)) e le m) E0\n     S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist nil (Kseq Sskip tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) <\n    measure\n      (ExprState f (Eval v (typeof a))\n         (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e m))%nat) /\\\n  match_states\n    (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist nil (Kseq Sskip tk0)) e le m) E0\n     S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist nil (Kseq Sskip tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) <\n    measure\n      (ExprState f (Eval v (typeof a))\n         (Kifthenelse Csyntax.Sskip Csyntax.Sskip k) e m))%nat) /\\\n  match_states\n    (Csem.State f (if b then Csyntax.Sskip else Csyntax.Sskip) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (a : expr) (H : bool_val v (typeof a) m = Some b) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tk0 : cont) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"econstructor; split; simpl.\nright.\ndestruct b; econstructor; eauto.\neapply star_left.\napply step_skip_seq.\neconstructor.\ntraceEq.\neapply star_left.\napply step_skip_seq.\neconstructor.\ntraceEq.\ndestruct b; econstructor; eauto.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tk0 : cont) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip.","conclusion":"tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip","hypotheses":"(f : Csyntax.function) (v : val) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tk0 : cont) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tk0 : cont) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip.","conclusion":"tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip","hypotheses":"(f : Csyntax.function) (v : val) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tk0 : cont) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (ts1 ts2 : statement) (tk0 : cont) (H6 : tr_stmt (prog_comp_env cu) s1 ts1) (H8 : tr_stmt (prog_comp_env cu) s2 ts2) (H9 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f (if b then s1 else s2) k e m) <\n    measure (ExprState f (Eval v ty) (Kifthenelse s1 s2 k) e m))%nat) /\\\n  match_states (Csem.State f (if b then s1 else s2) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f (if b then s1 else s2) k e m) <\n    measure (ExprState f (Eval v ty) (Kifthenelse s1 s2 k) e m))%nat) /\\\n  match_states (Csem.State f (if b then s1 else s2) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (ts1 ts2 : statement) (tk0 : cont) (H6 : tr_stmt (prog_comp_env cu) s1 ts1) (H8 : tr_stmt (prog_comp_env cu) s2 ts2) (H9 : match_cont (prog_comp_env cu) k tk0)","proofString":"exploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\napply step_ifthenelse with (v1 := v) (b := b); auto.\ntraceEq.\ndestruct b; econstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (ts1 ts2 : statement) (tk0 : cont) (H6 : tr_stmt (prog_comp_env cu) s1 ts1) (H8 : tr_stmt (prog_comp_env cu) s2 ts2) (H9 : match_cont (prog_comp_env cu) k tk0) : sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f (if b then s1 else s2) k e m) <\n    measure (ExprState f (Eval v ty) (Kifthenelse s1 s2 k) e m))%nat) /\\\n  match_states (Csem.State f (if b then s1 else s2) k e m) S2'.","conclusion":"sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f (if b then s1 else s2) k e m) <\n    measure (ExprState f (Eval v ty) (Kifthenelse s1 s2 k) e m))%nat) /\\\n  match_states (Csem.State f (if b then s1 else s2) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (ts1 ts2 : statement) (tk0 : cont) (H6 : tr_stmt (prog_comp_env cu) s1 ts1) (H8 : tr_stmt (prog_comp_env cu) s2 ts2) (H9 : match_cont (prog_comp_env cu) k tk0)","proofString":"intros [A [B C]].\nsubst.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\napply step_ifthenelse with (v1 := v) (b := b); auto.\ntraceEq.\ndestruct b; econstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (ts1 ts2 : statement) (tk0 : cont) (H6 : tr_stmt (prog_comp_env cu) s1 ts1) (H8 : tr_stmt (prog_comp_env cu) s2 ts2) (H9 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f (if b then s1 else s2) k e m) <\n    measure (ExprState f (Eval v ty) (Kifthenelse s1 s2 k) e m))%nat) /\\\n  match_states (Csem.State f (if b then s1 else s2) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f (if b then s1 else s2) k e m) <\n    measure (ExprState f (Eval v ty) (Kifthenelse s1 s2 k) e m))%nat) /\\\n  match_states (Csem.State f (if b then s1 else s2) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (H : bool_val v ty m = Some b) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (ts1 ts2 : statement) (tk0 : cont) (H6 : tr_stmt (prog_comp_env cu) s1 ts1) (H8 : tr_stmt (prog_comp_env cu) s2 ts2) (H9 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v)","proofString":"subst.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\napply step_ifthenelse with (v1 := v) (b := b); auto.\ntraceEq.\ndestruct b; econstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (a : expr) (H : bool_val v (typeof a) m = Some b) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (ts1 ts2 : statement) (tk0 : cont) (H6 : tr_stmt (prog_comp_env cu) s1 ts1) (H8 : tr_stmt (prog_comp_env cu) s2 ts2) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist nil (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist nil (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f (if b then s1 else s2) k e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kifthenelse s1 s2 k) e m))%nat) /\\\n  match_states (Csem.State f (if b then s1 else s2) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist nil (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist nil (Kseq (Sifthenelse a ts1 ts2) tk0)) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f (if b then s1 else s2) k e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kifthenelse s1 s2 k) e m))%nat) /\\\n  match_states (Csem.State f (if b then s1 else s2) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (s1 s2 : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (b : bool) (a : expr) (H : bool_val v (typeof a) m = Some b) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (ts1 ts2 : statement) (tk0 : cont) (H6 : tr_stmt (prog_comp_env cu) s1 ts1) (H8 : tr_stmt (prog_comp_env cu) s2 ts2) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"econstructor; split.\nleft.\neapply plus_two.\nconstructor.\napply step_ifthenelse with (v1 := v) (b := b); auto.\ntraceEq.\ndestruct b; econstructor; eauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Swhile x s) ts) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kwhile1 x s k) e m) <\n    measure (Csem.State f (Csyntax.Swhile x s) k e m))%nat) /\\\n  match_states (ExprState f x (Kwhile1 x s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kwhile1 x s k) e m) <\n    measure (Csem.State f (Csyntax.Swhile x s) k e m))%nat) /\\\n  match_states (ExprState f x (Kwhile1 x s k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Swhile x s) ts) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR.\ninv H1.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite Kseqlist_app.\neconstructor; eauto.\nsimpl.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts1 : statement) (H1 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H3 : tr_stmt (prog_comp_env cu) s ts1) : exists S2' : state,\n  (plus step1 tge (State tf (Sloop (Ssequence s' ts1) Sskip) tk e le m) E0\n     S2' \\/\n   star step1 tge (State tf (Sloop (Ssequence s' ts1) Sskip) tk e le m) E0\n     S2' /\\\n   (measure (ExprState f x (Kwhile1 x s k) e m) <\n    measure (Csem.State f (Csyntax.Swhile x s) k e m))%nat) /\\\n  match_states (ExprState f x (Kwhile1 x s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Sloop (Ssequence s' ts1) Sskip) tk e le m) E0\n     S2' \\/\n   star step1 tge (State tf (Sloop (Ssequence s' ts1) Sskip) tk e le m) E0\n     S2' /\\\n   (measure (ExprState f x (Kwhile1 x s k) e m) <\n    measure (Csem.State f (Csyntax.Swhile x s) k e m))%nat) /\\\n  match_states (ExprState f x (Kwhile1 x s k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts1 : statement) (H1 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H3 : tr_stmt (prog_comp_env cu) s ts1)","proofString":"inv H1.\neconstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite Kseqlist_app.\neconstructor; eauto.\nsimpl.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 : statement) (H3 : tr_stmt (prog_comp_env cu) s ts1) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : exists S2' : state,\n  (plus step1 tge\n     (State tf\n        (Sloop (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts1)\n           Sskip) tk e le m) E0 S2' \\/\n   star step1 tge\n     (State tf\n        (Sloop (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts1)\n           Sskip) tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kwhile1 x s k) e m) <\n    measure (Csem.State f (Csyntax.Swhile x s) k e m))%nat) /\\\n  match_states (ExprState f x (Kwhile1 x s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf\n        (Sloop (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts1)\n           Sskip) tk e le m) E0 S2' \\/\n   star step1 tge\n     (State tf\n        (Sloop (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts1)\n           Sskip) tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kwhile1 x s k) e m) <\n    measure (Csem.State f (Csyntax.Swhile x s) k e m))%nat) /\\\n  match_states (ExprState f x (Kwhile1 x s k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 : statement) (H3 : tr_stmt (prog_comp_env cu) s ts1) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"econstructor; split.\nleft.\neapply plus_left.\nconstructor.\neapply star_left.\nconstructor.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite Kseqlist_app.\neconstructor; eauto.\nsimpl.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 : statement) (H3 : tr_stmt (prog_comp_env cu) s ts1) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : match_states (ExprState f x (Kwhile1 x s k) e m)\n  (State tf Sskip\n     (Kseqlist sl\n        (Kseqlist (makeif a Sskip Sbreak :: nil)\n           (Kseq ts1\n              (Kloop1\n                 (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil))\n                    ts1) Sskip tk)))) e le m).","conclusion":"match_states (ExprState f x (Kwhile1 x s k) e m)\n  (State tf Sskip\n     (Kseqlist sl\n        (Kseqlist (makeif a Sskip Sbreak :: nil)\n           (Kseq ts1\n              (Kloop1\n                 (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil))\n                    ts1) Sskip tk)))) e le m)","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 : statement) (H3 : tr_stmt (prog_comp_env cu) s ts1) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"econstructor; eauto.\nsimpl.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 : statement) (H3 : tr_stmt (prog_comp_env cu) s ts1) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : match_cont_exp (prog_comp_env cu) For_val a (Kwhile1 x s k)\n  (Kseqlist (makeif a Sskip Sbreak :: nil)\n     (Kseq ts1\n        (Kloop1\n           (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts1)\n           Sskip tk))).","conclusion":"match_cont_exp (prog_comp_env cu) For_val a (Kwhile1 x s k)\n  (Kseqlist (makeif a Sskip Sbreak :: nil)\n     (Kseq ts1\n        (Kloop1\n           (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts1)\n           Sskip tk)))","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 : statement) (H3 : tr_stmt (prog_comp_env cu) s ts1) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"simpl.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 : statement) (H3 : tr_stmt (prog_comp_env cu) s ts1) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : match_cont_exp (prog_comp_env cu) For_val a (Kwhile1 x s k)\n  (Kseq (makeif a Sskip Sbreak)\n     (Kseq ts1\n        (Kloop1\n           (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts1)\n           Sskip tk))).","conclusion":"match_cont_exp (prog_comp_env cu) For_val a (Kwhile1 x s k)\n  (Kseq (makeif a Sskip Sbreak)\n     (Kseq ts1\n        (Kloop1\n           (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts1)\n           Sskip tk)))","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 : statement) (H3 : tr_stmt (prog_comp_env cu) s ts1) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"econstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 : statement) (H3 : tr_stmt (prog_comp_env cu) s ts1) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : tr_if (prog_comp_env cu) x Sskip Sbreak\n  (makeseq (sl ++ makeif a Sskip Sbreak :: nil)).","conclusion":"tr_if (prog_comp_env cu) x Sskip Sbreak\n  (makeseq (sl ++ makeif a Sskip Sbreak :: nil))","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts1 : statement) (H3 : tr_stmt (prog_comp_env cu) s ts1) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kwhile1 x s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kwhile1 x s k) tk)","proofString":"inv MK.\nexploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (v1 := v) (b := false); auto.\neapply star_two.\nconstructor.\napply step_break_loop1.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0)","proofString":"exploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (v1 := v) (b := false); auto.\neapply star_two.\nconstructor.\napply step_break_loop1.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) : sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0)","proofString":"intros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (v1 := v) (b := false); auto.\neapply star_two.\nconstructor.\napply step_break_loop1.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v)","proofString":"subst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (v1 := v) (b := false); auto.\neapply star_two.\nconstructor.\napply step_break_loop1.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"econstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (v1 := v) (b := false); auto.\neapply star_two.\nconstructor.\napply step_break_loop1.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip.","conclusion":"tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip","hypotheses":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kwhile1 x s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kwhile2 x s k) e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kwhile2 x s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kwhile2 x s k) e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kwhile2 x s k) e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kwhile1 x s k) tk)","proofString":"inv MK.\nexploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kwhile2 x s k) e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kwhile2 x s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kwhile2 x s k) e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kwhile2 x s k) e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0)","proofString":"exploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) : sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kwhile2 x s k) e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kwhile2 x s k) e m) S2'.","conclusion":"sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kwhile2 x s k) e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kwhile2 x s k) e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0)","proofString":"intros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kwhile2 x s k) e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kwhile2 x s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kwhile2 x s k) e m) <\n    measure (ExprState f (Eval v ty) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kwhile2 x s k) e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v)","proofString":"subst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kwhile2 x s k) e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kwhile2 x s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) Sskip tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kwhile2 x s k) e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kwhile1 x s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kwhile2 x s k) e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"econstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : match_cont (prog_comp_env cu) (Kwhile2 x s k)\n  (Kloop1 (Ssequence s' ts) Sskip tk0).","conclusion":"match_cont (prog_comp_env cu) (Kwhile2 x s k)\n  (Kloop1 (Ssequence s' ts) Sskip tk0)","hypotheses":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"constructor; auto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (MK : match_cont (prog_comp_env cu) (Kwhile2 x s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Swhile x s) k e m) <\n    measure (Csem.State f s0 (Kwhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Swhile x s) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Swhile x s) k e m) <\n    measure (Csem.State f s0 (Kwhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Swhile x s) k e m) S2'","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (MK : match_cont (prog_comp_env cu) (Kwhile2 x s k) tk)","proofString":"assert (ts = Sskip \\/ ts = Scontinue).\ndestruct H; subst s0; inv TR; auto.\ninv MK.\neconstructor; split.\nleft.\neapply plus_two.\napply step_skip_or_continue_loop1; auto.\napply step_skip_loop2.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (MK : match_cont (prog_comp_env cu) (Kwhile2 x s k) tk) : ts = Sskip \\/ ts = Scontinue.","conclusion":"ts = Sskip \\/ ts = Scontinue","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (MK : match_cont (prog_comp_env cu) (Kwhile2 x s k) tk)","proofString":"destruct H; subst s0; inv TR; auto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (MK : match_cont (prog_comp_env cu) (Kwhile2 x s k) tk) (H0 : ts = Sskip \\/ ts = Scontinue) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Swhile x s) k e m) <\n    measure (Csem.State f s0 (Kwhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Swhile x s) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Swhile x s) k e m) <\n    measure (Csem.State f s0 (Kwhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Swhile x s) k e m) S2'","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (MK : match_cont (prog_comp_env cu) (Kwhile2 x s k) tk) (H0 : ts = Sskip \\/ ts = Scontinue)","proofString":"inv MK.\neconstructor; split.\nleft.\neapply plus_two.\napply step_skip_or_continue_loop1; auto.\napply step_skip_loop2.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (s' ts0 : statement) (tk0 : cont) (H5 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge (State tf ts (Kloop1 (Ssequence s' ts0) Sskip tk0) e le m)\n     E0 S2' \\/\n   star step1 tge (State tf ts (Kloop1 (Ssequence s' ts0) Sskip tk0) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Swhile x s) k e m) <\n    measure (Csem.State f s0 (Kwhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Swhile x s) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts (Kloop1 (Ssequence s' ts0) Sskip tk0) e le m)\n     E0 S2' \\/\n   star step1 tge (State tf ts (Kloop1 (Ssequence s' ts0) Sskip tk0) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Swhile x s) k e m) <\n    measure (Csem.State f s0 (Kwhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Swhile x s) k e m) S2'","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (s' ts0 : statement) (tk0 : cont) (H5 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0)","proofString":"econstructor; split.\nleft.\neapply plus_two.\napply step_skip_or_continue_loop1; auto.\napply step_skip_loop2.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (s' ts0 : statement) (tk0 : cont) (H5 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) : tr_stmt (prog_comp_env cu) (Csyntax.Swhile x s)\n  (Sloop (Ssequence s' ts0) Sskip).","conclusion":"tr_stmt (prog_comp_env cu) (Csyntax.Swhile x s)\n  (Sloop (Ssequence s' ts0) Sskip)","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (s' ts0 : statement) (tk0 : cont) (H5 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0)","proofString":"constructor; auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sbreak ts) (MK : match_cont (prog_comp_env cu) (Kwhile2 x s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kwhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kwhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sbreak ts) (MK : match_cont (prog_comp_env cu) (Kwhile2 x s k) tk)","proofString":"inv TR.\ninv MK.\neconstructor; split.\nleft.\napply plus_one.\napply step_break_loop1.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) (Kwhile2 x s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sbreak tk e le m) E0 S2' \\/\n   star step1 tge (State tf Sbreak tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kwhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sbreak tk e le m) E0 S2' \\/\n   star step1 tge (State tf Sbreak tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kwhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) (Kwhile2 x s k) tk)","proofString":"inv MK.\neconstructor; split.\nleft.\napply plus_one.\napply step_break_loop1.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (s' ts : statement) (tk0 : cont) (H3 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H5 : tr_stmt (prog_comp_env cu) s ts) (H6 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sbreak (Kloop1 (Ssequence s' ts) Sskip tk0) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sbreak (Kloop1 (Ssequence s' ts) Sskip tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kwhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sbreak (Kloop1 (Ssequence s' ts) Sskip tk0) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sbreak (Kloop1 (Ssequence s' ts) Sskip tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kwhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (s' ts : statement) (tk0 : cont) (H3 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H5 : tr_stmt (prog_comp_env cu) s ts) (H6 : match_cont (prog_comp_env cu) k tk0)","proofString":"econstructor; split.\nleft.\napply plus_one.\napply step_break_loop1.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (s' ts : statement) (tk0 : cont) (H3 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H5 : tr_stmt (prog_comp_env cu) s ts) (H6 : match_cont (prog_comp_env cu) k tk0) : tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip.","conclusion":"tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (s' ts : statement) (tk0 : cont) (H3 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H5 : tr_stmt (prog_comp_env cu) s ts) (H6 : match_cont (prog_comp_env cu) k tk0)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sdowhile a s) ts) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kdowhile1 a s k) e m) <\n    measure (Csem.State f (Csyntax.Sdowhile a s) k e m))%nat) /\\\n  match_states (Csem.State f s (Kdowhile1 a s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kdowhile1 a s k) e m) <\n    measure (Csem.State f (Csyntax.Sdowhile a s) k e m))%nat) /\\\n  match_states (Csem.State f s (Kdowhile1 a s k) e m) S2'","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sdowhile a s) ts) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR.\neconstructor; split.\nleft.\napply plus_one.\napply step_loop.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts1 : statement) (H1 : tr_if (prog_comp_env cu) a Sskip Sbreak s') (H3 : tr_stmt (prog_comp_env cu) s ts1) : exists S2' : state,\n  (plus step1 tge (State tf (Sloop ts1 s') tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sloop ts1 s') tk e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kdowhile1 a s k) e m) <\n    measure (Csem.State f (Csyntax.Sdowhile a s) k e m))%nat) /\\\n  match_states (Csem.State f s (Kdowhile1 a s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Sloop ts1 s') tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sloop ts1 s') tk e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kdowhile1 a s k) e m) <\n    measure (Csem.State f (Csyntax.Sdowhile a s) k e m))%nat) /\\\n  match_states (Csem.State f s (Kdowhile1 a s k) e m) S2'","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts1 : statement) (H1 : tr_if (prog_comp_env cu) a Sskip Sbreak s') (H3 : tr_stmt (prog_comp_env cu) s ts1)","proofString":"econstructor; split.\nleft.\napply plus_one.\napply step_loop.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts1 : statement) (H1 : tr_if (prog_comp_env cu) a Sskip Sbreak s') (H3 : tr_stmt (prog_comp_env cu) s ts1) : match_cont (prog_comp_env cu) (Kdowhile1 a s k) (Kloop1 ts1 s' tk).","conclusion":"match_cont (prog_comp_env cu) (Kdowhile1 a s k) (Kloop1 ts1 s' tk)","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts1 : statement) (H1 : tr_if (prog_comp_env cu) a Sskip Sbreak s') (H3 : tr_stmt (prog_comp_env cu) s ts1)","proofString":"constructor; auto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (MK : match_cont (prog_comp_env cu) (Kdowhile1 x s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kdowhile2 x s k) e m) <\n    measure (Csem.State f s0 (Kdowhile1 x s k) e m))%nat) /\\\n  match_states (ExprState f x (Kdowhile2 x s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kdowhile2 x s k) e m) <\n    measure (Csem.State f s0 (Kdowhile1 x s k) e m))%nat) /\\\n  match_states (ExprState f x (Kdowhile2 x s k) e m) S2'","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (MK : match_cont (prog_comp_env cu) (Kdowhile1 x s k) tk)","proofString":"assert (ts = Sskip \\/ ts = Scontinue).\ndestruct H; subst s0; inv TR; auto.\ninv MK.\ninv H5.\neconstructor; split.\nleft.\neapply plus_left.\napply step_skip_or_continue_loop1.\nauto.\napply push_seq.\ntraceEq.\nrewrite Kseqlist_app.\neconstructor; eauto.\nsimpl.\neconstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (MK : match_cont (prog_comp_env cu) (Kdowhile1 x s k) tk) : ts = Sskip \\/ ts = Scontinue.","conclusion":"ts = Sskip \\/ ts = Scontinue","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (MK : match_cont (prog_comp_env cu) (Kdowhile1 x s k) tk)","proofString":"destruct H; subst s0; inv TR; auto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (MK : match_cont (prog_comp_env cu) (Kdowhile1 x s k) tk) (H0 : ts = Sskip \\/ ts = Scontinue) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kdowhile2 x s k) e m) <\n    measure (Csem.State f s0 (Kdowhile1 x s k) e m))%nat) /\\\n  match_states (ExprState f x (Kdowhile2 x s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kdowhile2 x s k) e m) <\n    measure (Csem.State f s0 (Kdowhile1 x s k) e m))%nat) /\\\n  match_states (ExprState f x (Kdowhile2 x s k) e m) S2'","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (MK : match_cont (prog_comp_env cu) (Kdowhile1 x s k) tk) (H0 : ts = Sskip \\/ ts = Scontinue)","proofString":"inv MK.\ninv H5.\neconstructor; split.\nleft.\neapply plus_left.\napply step_skip_or_continue_loop1.\nauto.\napply push_seq.\ntraceEq.\nrewrite Kseqlist_app.\neconstructor; eauto.\nsimpl.\neconstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (s' ts0 : statement) (tk0 : cont) (H5 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge (State tf ts (Kloop1 ts0 s' tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf ts (Kloop1 ts0 s' tk0) e le m) E0 S2' /\\\n   (measure (ExprState f x (Kdowhile2 x s k) e m) <\n    measure (Csem.State f s0 (Kdowhile1 x s k) e m))%nat) /\\\n  match_states (ExprState f x (Kdowhile2 x s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts (Kloop1 ts0 s' tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf ts (Kloop1 ts0 s' tk0) e le m) E0 S2' /\\\n   (measure (ExprState f x (Kdowhile2 x s k) e m) <\n    measure (Csem.State f s0 (Kdowhile1 x s k) e m))%nat) /\\\n  match_states (ExprState f x (Kdowhile2 x s k) e m) S2'","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (s' ts0 : statement) (tk0 : cont) (H5 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0)","proofString":"inv H5.\neconstructor; split.\nleft.\neapply plus_left.\napply step_skip_or_continue_loop1.\nauto.\napply push_seq.\ntraceEq.\nrewrite Kseqlist_app.\neconstructor; eauto.\nsimpl.\neconstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts0 : statement) (tk0 : cont) (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) (sl : list statement) (a : expr) (tmps : list ident) (H1 : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : exists S2' : state,\n  (plus step1 tge\n     (State tf ts\n        (Kloop1 ts0 (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) tk0) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf ts\n        (Kloop1 ts0 (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) tk0) e le\n        m) E0 S2' /\\\n   (measure (ExprState f x (Kdowhile2 x s k) e m) <\n    measure (Csem.State f s0 (Kdowhile1 x s k) e m))%nat) /\\\n  match_states (ExprState f x (Kdowhile2 x s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf ts\n        (Kloop1 ts0 (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) tk0) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf ts\n        (Kloop1 ts0 (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) tk0) e le\n        m) E0 S2' /\\\n   (measure (ExprState f x (Kdowhile2 x s k) e m) <\n    measure (Csem.State f s0 (Kdowhile1 x s k) e m))%nat) /\\\n  match_states (ExprState f x (Kdowhile2 x s k) e m) S2'","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts0 : statement) (tk0 : cont) (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) (sl : list statement) (a : expr) (tmps : list ident) (H1 : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"econstructor; split.\nleft.\neapply plus_left.\napply step_skip_or_continue_loop1.\nauto.\napply push_seq.\ntraceEq.\nrewrite Kseqlist_app.\neconstructor; eauto.\nsimpl.\neconstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts0 : statement) (tk0 : cont) (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) (sl : list statement) (a : expr) (tmps : list ident) (H1 : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : ts = Sskip \\/ ts = Scontinue.","conclusion":"ts = Sskip \\/ ts = Scontinue","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts0 : statement) (tk0 : cont) (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) (sl : list statement) (a : expr) (tmps : list ident) (H1 : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"auto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts0 : statement) (tk0 : cont) (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) (sl : list statement) (a : expr) (tmps : list ident) (H1 : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : match_states (ExprState f x (Kdowhile2 x s k) e m)\n  (State tf Sskip\n     (Kseqlist sl\n        (Kseqlist (makeif a Sskip Sbreak :: nil)\n           (Kloop2 ts0 (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) tk0)))\n     e le m).","conclusion":"match_states (ExprState f x (Kdowhile2 x s k) e m)\n  (State tf Sskip\n     (Kseqlist sl\n        (Kseqlist (makeif a Sskip Sbreak :: nil)\n           (Kloop2 ts0 (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) tk0)))\n     e le m)","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts0 : statement) (tk0 : cont) (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) (sl : list statement) (a : expr) (tmps : list ident) (H1 : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"econstructor; eauto.\nsimpl.\neconstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts0 : statement) (tk0 : cont) (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) (sl : list statement) (a : expr) (tmps : list ident) (H1 : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : match_cont_exp (prog_comp_env cu) For_val a (Kdowhile2 x s k)\n  (Kseqlist (makeif a Sskip Sbreak :: nil)\n     (Kloop2 ts0 (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) tk0)).","conclusion":"match_cont_exp (prog_comp_env cu) For_val a (Kdowhile2 x s k)\n  (Kseqlist (makeif a Sskip Sbreak :: nil)\n     (Kloop2 ts0 (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) tk0))","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts0 : statement) (tk0 : cont) (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) (sl : list statement) (a : expr) (tmps : list ident) (H1 : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"simpl.\neconstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts0 : statement) (tk0 : cont) (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) (sl : list statement) (a : expr) (tmps : list ident) (H1 : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : match_cont_exp (prog_comp_env cu) For_val a (Kdowhile2 x s k)\n  (Kseq (makeif a Sskip Sbreak)\n     (Kloop2 ts0 (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) tk0)).","conclusion":"match_cont_exp (prog_comp_env cu) For_val a (Kdowhile2 x s k)\n  (Kseq (makeif a Sskip Sbreak)\n     (Kloop2 ts0 (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) tk0))","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts0 : statement) (tk0 : cont) (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) (sl : list statement) (a : expr) (tmps : list ident) (H1 : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"econstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts0 : statement) (tk0 : cont) (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) (sl : list statement) (a : expr) (tmps : list ident) (H1 : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : tr_if (prog_comp_env cu) x Sskip Sbreak\n  (makeseq (sl ++ makeif a Sskip Sbreak :: nil)).","conclusion":"tr_if (prog_comp_env cu) x Sskip Sbreak\n  (makeseq (sl ++ makeif a Sskip Sbreak :: nil))","hypotheses":"(f : Csyntax.function) (s0 : Csyntax.statement) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : s0 = Csyntax.Sskip \\/ s0 = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) s0 ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts0 : statement) (tk0 : cont) (H7 : tr_stmt (prog_comp_env cu) s ts0) (H8 : match_cont (prog_comp_env cu) k tk0) (sl : list statement) (a : expr) (tmps : list ident) (H1 : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kdowhile2 x s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kdowhile2 x s k) tk)","proofString":"inv MK.\nexploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := false); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0)","proofString":"exploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := false); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) : sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0)","proofString":"intros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := false); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v)","proofString":"subst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := false); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist nil (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist nil (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist nil (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist nil (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"econstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := false); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip.","conclusion":"tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip","hypotheses":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kdowhile2 x s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sdowhile x s) k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sdowhile x s) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sdowhile x s) k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sdowhile x s) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kdowhile2 x s k) tk)","proofString":"inv MK.\nexploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sdowhile x s) k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sdowhile x s) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sdowhile x s) k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sdowhile x s) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0)","proofString":"exploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) : sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sdowhile x s) k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sdowhile x s) k e m) S2'.","conclusion":"sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sdowhile x s) k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sdowhile x s) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0)","proofString":"intros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sdowhile x s) k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sdowhile x s) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sdowhile x s) k e m) <\n    measure (ExprState f (Eval v ty) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sdowhile x s) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v)","proofString":"subst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist nil (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist nil (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sdowhile x s) k e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sdowhile x s) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist nil (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist nil (Kseq (makeif a Sskip Sbreak) (Kloop2 ts s' tk0))) e le\n        m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sdowhile x s) k e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kdowhile2 x s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sdowhile x s) k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"econstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : tr_stmt (prog_comp_env cu) (Csyntax.Sdowhile x s) (Sloop ts s').","conclusion":"tr_stmt (prog_comp_env cu) (Csyntax.Sdowhile x s) (Sloop ts s')","hypotheses":"(f : Csyntax.function) (v : val) (x : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) x Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) s ts) (H9 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"constructor; auto."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sbreak ts) (MK : match_cont (prog_comp_env cu) (Kdowhile1 a s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kdowhile1 a s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kdowhile1 a s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sbreak ts) (MK : match_cont (prog_comp_env cu) (Kdowhile1 a s k) tk)","proofString":"inv TR.\ninv MK.\neconstructor; split.\nleft.\napply plus_one.\napply step_break_loop1.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) (Kdowhile1 a s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sbreak tk e le m) E0 S2' \\/\n   star step1 tge (State tf Sbreak tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kdowhile1 a s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sbreak tk e le m) E0 S2' \\/\n   star step1 tge (State tf Sbreak tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kdowhile1 a s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) (Kdowhile1 a s k) tk)","proofString":"inv MK.\neconstructor; split.\nleft.\napply plus_one.\napply step_break_loop1.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (s' ts : statement) (tk0 : cont) (H3 : tr_if (prog_comp_env cu) a Sskip Sbreak s') (H5 : tr_stmt (prog_comp_env cu) s ts) (H6 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge (State tf Sbreak (Kloop1 ts s' tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf Sbreak (Kloop1 ts s' tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kdowhile1 a s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sbreak (Kloop1 ts s' tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf Sbreak (Kloop1 ts s' tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kdowhile1 a s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (s' ts : statement) (tk0 : cont) (H3 : tr_if (prog_comp_env cu) a Sskip Sbreak s') (H5 : tr_stmt (prog_comp_env cu) s ts) (H6 : match_cont (prog_comp_env cu) k tk0)","proofString":"econstructor; split.\nleft.\napply plus_one.\napply step_break_loop1.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (s' ts : statement) (tk0 : cont) (H3 : tr_if (prog_comp_env cu) a Sskip Sbreak s') (H5 : tr_stmt (prog_comp_env cu) s ts) (H6 : match_cont (prog_comp_env cu) k tk0) : tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip.","conclusion":"tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip","hypotheses":"(f : Csyntax.function) (a : Csyntax.expr) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (s' ts : statement) (tk0 : cont) (H3 : tr_if (prog_comp_env cu) a Sskip Sbreak s') (H5 : tr_stmt (prog_comp_env cu) s ts) (H6 : match_cont (prog_comp_env cu) k tk0)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (a1 : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : a1 <> Csyntax.Sskip) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sfor a1 a2 a3 s) ts) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure\n      (Csem.State f a1 (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k) e m) <\n    measure (Csem.State f (Csyntax.Sfor a1 a2 a3 s) k e m))%nat) /\\\n  match_states\n    (Csem.State f a1 (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k) e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure\n      (Csem.State f a1 (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k) e m) <\n    measure (Csem.State f (Csyntax.Sfor a1 a2 a3 s) k e m))%nat) /\\\n  match_states\n    (Csem.State f a1 (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k) e m)\n    S2'","hypotheses":"(f : Csyntax.function) (a1 : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : a1 <> Csyntax.Sskip) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sfor a1 a2 a3 s) ts) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR.\ncongruence.\neconstructor; split.\nleft; apply plus_one.\nconstructor.\neconstructor; eauto.\nconstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : Csyntax.Sskip <> Csyntax.Sskip) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts3 ts4 : statement) (H5 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H6 : tr_stmt (prog_comp_env cu) a3 ts3) (H7 : tr_stmt (prog_comp_env cu) s ts4) : exists S2' : state,\n  (plus step1 tge (State tf (Sloop (Ssequence s' ts4) ts3) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sloop (Ssequence s' ts4) ts3) tk e le m) E0 S2' /\\\n   (measure\n      (Csem.State f Csyntax.Sskip\n         (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k) e m) <\n    measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m))%nat) /\\\n  match_states\n    (Csem.State f Csyntax.Sskip\n       (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Sloop (Ssequence s' ts4) ts3) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sloop (Ssequence s' ts4) ts3) tk e le m) E0 S2' /\\\n   (measure\n      (Csem.State f Csyntax.Sskip\n         (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k) e m) <\n    measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m))%nat) /\\\n  match_states\n    (Csem.State f Csyntax.Sskip\n       (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k) e m) S2'","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : Csyntax.Sskip <> Csyntax.Sskip) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts3 ts4 : statement) (H5 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H6 : tr_stmt (prog_comp_env cu) a3 ts3) (H7 : tr_stmt (prog_comp_env cu) s ts4)","proofString":"congruence."},{"statement":"(f : Csyntax.function) (a1 : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : a1 <> Csyntax.Sskip) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts1 ts3 ts4 : statement) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H5 : a1 <> Csyntax.Sskip) (H7 : tr_stmt (prog_comp_env cu) a1 ts1) (H8 : tr_stmt (prog_comp_env cu) a3 ts3) (H9 : tr_stmt (prog_comp_env cu) s ts4) : exists S2' : state,\n  (plus step1 tge\n     (State tf (Ssequence ts1 (Sloop (Ssequence s' ts4) ts3)) tk e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf (Ssequence ts1 (Sloop (Ssequence s' ts4) ts3)) tk e le m) E0\n     S2' /\\\n   (measure\n      (Csem.State f a1 (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k) e m) <\n    measure (Csem.State f (Csyntax.Sfor a1 a2 a3 s) k e m))%nat) /\\\n  match_states\n    (Csem.State f a1 (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k) e m)\n    S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf (Ssequence ts1 (Sloop (Ssequence s' ts4) ts3)) tk e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf (Ssequence ts1 (Sloop (Ssequence s' ts4) ts3)) tk e le m) E0\n     S2' /\\\n   (measure\n      (Csem.State f a1 (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k) e m) <\n    measure (Csem.State f (Csyntax.Sfor a1 a2 a3 s) k e m))%nat) /\\\n  match_states\n    (Csem.State f a1 (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k) e m)\n    S2'","hypotheses":"(f : Csyntax.function) (a1 : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : a1 <> Csyntax.Sskip) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts1 ts3 ts4 : statement) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H5 : a1 <> Csyntax.Sskip) (H7 : tr_stmt (prog_comp_env cu) a1 ts1) (H8 : tr_stmt (prog_comp_env cu) a3 ts3) (H9 : tr_stmt (prog_comp_env cu) s ts4)","proofString":"econstructor; split.\nleft; apply plus_one.\nconstructor.\neconstructor; eauto.\nconstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a1 : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : a1 <> Csyntax.Sskip) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts1 ts3 ts4 : statement) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H5 : a1 <> Csyntax.Sskip) (H7 : tr_stmt (prog_comp_env cu) a1 ts1) (H8 : tr_stmt (prog_comp_env cu) a3 ts3) (H9 : tr_stmt (prog_comp_env cu) s ts4) : match_cont (prog_comp_env cu)\n  (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k)\n  (Kseq (Sloop (Ssequence s' ts4) ts3) tk).","conclusion":"match_cont (prog_comp_env cu)\n  (Csem.Kseq (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k)\n  (Kseq (Sloop (Ssequence s' ts4) ts3) tk)","hypotheses":"(f : Csyntax.function) (a1 : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : a1 <> Csyntax.Sskip) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts1 ts3 ts4 : statement) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H5 : a1 <> Csyntax.Sskip) (H7 : tr_stmt (prog_comp_env cu) a1 ts1) (H8 : tr_stmt (prog_comp_env cu) a3 ts3) (H9 : tr_stmt (prog_comp_env cu) s ts4)","proofString":"constructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a1 : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : a1 <> Csyntax.Sskip) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts1 ts3 ts4 : statement) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H5 : a1 <> Csyntax.Sskip) (H7 : tr_stmt (prog_comp_env cu) a1 ts1) (H8 : tr_stmt (prog_comp_env cu) a3 ts3) (H9 : tr_stmt (prog_comp_env cu) s ts4) : tr_stmt (prog_comp_env cu) (Csyntax.Sfor Csyntax.Sskip a2 a3 s)\n  (Sloop (Ssequence s' ts4) ts3).","conclusion":"tr_stmt (prog_comp_env cu) (Csyntax.Sfor Csyntax.Sskip a2 a3 s)\n  (Sloop (Ssequence s' ts4) ts3)","hypotheses":"(f : Csyntax.function) (a1 : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : a1 <> Csyntax.Sskip) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts1 ts3 ts4 : statement) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H5 : a1 <> Csyntax.Sskip) (H7 : tr_stmt (prog_comp_env cu) a1 ts1) (H8 : tr_stmt (prog_comp_env cu) a3 ts3) (H9 : tr_stmt (prog_comp_env cu) s ts4)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sfor Csyntax.Sskip a2 a3 s) ts) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f a2 (Kfor2 a2 a3 s k) e m) <\n    measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m))%nat) /\\\n  match_states (ExprState f a2 (Kfor2 a2 a3 s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f a2 (Kfor2 a2 a3 s k) e m) <\n    measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m))%nat) /\\\n  match_states (ExprState f a2 (Kfor2 a2 a3 s k) e m) S2'","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sfor Csyntax.Sskip a2 a3 s) ts) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR; try congruence.\ninv H2.\neconstructor; split.\nleft.\neapply plus_left.\napply step_loop.\neapply star_left.\nconstructor.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite Kseqlist_app.\neconstructor; eauto.\nsimpl.\nconstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts3 ts4 : statement) (H2 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H4 : tr_stmt (prog_comp_env cu) a3 ts3) (H5 : tr_stmt (prog_comp_env cu) s ts4) : exists S2' : state,\n  (plus step1 tge (State tf (Sloop (Ssequence s' ts4) ts3) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sloop (Ssequence s' ts4) ts3) tk e le m) E0 S2' /\\\n   (measure (ExprState f a2 (Kfor2 a2 a3 s k) e m) <\n    measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m))%nat) /\\\n  match_states (ExprState f a2 (Kfor2 a2 a3 s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Sloop (Ssequence s' ts4) ts3) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sloop (Ssequence s' ts4) ts3) tk e le m) E0 S2' /\\\n   (measure (ExprState f a2 (Kfor2 a2 a3 s k) e m) <\n    measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m))%nat) /\\\n  match_states (ExprState f a2 (Kfor2 a2 a3 s k) e m) S2'","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' ts3 ts4 : statement) (H2 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H4 : tr_stmt (prog_comp_env cu) a3 ts3) (H5 : tr_stmt (prog_comp_env cu) s ts4)","proofString":"inv H2.\neconstructor; split.\nleft.\neapply plus_left.\napply step_loop.\neapply star_left.\nconstructor.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite Kseqlist_app.\neconstructor; eauto.\nsimpl.\nconstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts3 ts4 : statement) (H4 : tr_stmt (prog_comp_env cu) a3 ts3) (H5 : tr_stmt (prog_comp_env cu) s ts4) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a2 sl a tmps) : exists S2' : state,\n  (plus step1 tge\n     (State tf\n        (Sloop (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts4)\n           ts3) tk e le m) E0 S2' \\/\n   star step1 tge\n     (State tf\n        (Sloop (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts4)\n           ts3) tk e le m) E0 S2' /\\\n   (measure (ExprState f a2 (Kfor2 a2 a3 s k) e m) <\n    measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m))%nat) /\\\n  match_states (ExprState f a2 (Kfor2 a2 a3 s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf\n        (Sloop (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts4)\n           ts3) tk e le m) E0 S2' \\/\n   star step1 tge\n     (State tf\n        (Sloop (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts4)\n           ts3) tk e le m) E0 S2' /\\\n   (measure (ExprState f a2 (Kfor2 a2 a3 s k) e m) <\n    measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m))%nat) /\\\n  match_states (ExprState f a2 (Kfor2 a2 a3 s k) e m) S2'","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts3 ts4 : statement) (H4 : tr_stmt (prog_comp_env cu) a3 ts3) (H5 : tr_stmt (prog_comp_env cu) s ts4) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a2 sl a tmps)","proofString":"econstructor; split.\nleft.\neapply plus_left.\napply step_loop.\neapply star_left.\nconstructor.\napply push_seq.\nreflexivity.\ntraceEq.\nrewrite Kseqlist_app.\neconstructor; eauto.\nsimpl.\nconstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts3 ts4 : statement) (H4 : tr_stmt (prog_comp_env cu) a3 ts3) (H5 : tr_stmt (prog_comp_env cu) s ts4) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a2 sl a tmps) : match_states (ExprState f a2 (Kfor2 a2 a3 s k) e m)\n  (State tf Sskip\n     (Kseqlist sl\n        (Kseqlist (makeif a Sskip Sbreak :: nil)\n           (Kseq ts4\n              (Kloop1\n                 (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil))\n                    ts4) ts3 tk)))) e le m).","conclusion":"match_states (ExprState f a2 (Kfor2 a2 a3 s k) e m)\n  (State tf Sskip\n     (Kseqlist sl\n        (Kseqlist (makeif a Sskip Sbreak :: nil)\n           (Kseq ts4\n              (Kloop1\n                 (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil))\n                    ts4) ts3 tk)))) e le m)","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts3 ts4 : statement) (H4 : tr_stmt (prog_comp_env cu) a3 ts3) (H5 : tr_stmt (prog_comp_env cu) s ts4) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a2 sl a tmps)","proofString":"econstructor; eauto.\nsimpl.\nconstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts3 ts4 : statement) (H4 : tr_stmt (prog_comp_env cu) a3 ts3) (H5 : tr_stmt (prog_comp_env cu) s ts4) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a2 sl a tmps) : match_cont_exp (prog_comp_env cu) For_val a (Kfor2 a2 a3 s k)\n  (Kseqlist (makeif a Sskip Sbreak :: nil)\n     (Kseq ts4\n        (Kloop1\n           (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts4) ts3\n           tk))).","conclusion":"match_cont_exp (prog_comp_env cu) For_val a (Kfor2 a2 a3 s k)\n  (Kseqlist (makeif a Sskip Sbreak :: nil)\n     (Kseq ts4\n        (Kloop1\n           (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts4) ts3\n           tk)))","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts3 ts4 : statement) (H4 : tr_stmt (prog_comp_env cu) a3 ts3) (H5 : tr_stmt (prog_comp_env cu) s ts4) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a2 sl a tmps)","proofString":"simpl.\nconstructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts3 ts4 : statement) (H4 : tr_stmt (prog_comp_env cu) a3 ts3) (H5 : tr_stmt (prog_comp_env cu) s ts4) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a2 sl a tmps) : match_cont_exp (prog_comp_env cu) For_val a (Kfor2 a2 a3 s k)\n  (Kseq (makeif a Sskip Sbreak)\n     (Kseq ts4\n        (Kloop1\n           (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts4) ts3\n           tk))).","conclusion":"match_cont_exp (prog_comp_env cu) For_val a (Kfor2 a2 a3 s k)\n  (Kseq (makeif a Sskip Sbreak)\n     (Kseq ts4\n        (Kloop1\n           (Ssequence (makeseq (sl ++ makeif a Sskip Sbreak :: nil)) ts4) ts3\n           tk)))","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts3 ts4 : statement) (H4 : tr_stmt (prog_comp_env cu) a3 ts3) (H5 : tr_stmt (prog_comp_env cu) s ts4) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a2 sl a tmps)","proofString":"constructor; auto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts3 ts4 : statement) (H4 : tr_stmt (prog_comp_env cu) a3 ts3) (H5 : tr_stmt (prog_comp_env cu) s ts4) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a2 sl a tmps) : tr_if (prog_comp_env cu) a2 Sskip Sbreak\n  (makeseq (sl ++ makeif a Sskip Sbreak :: nil)).","conclusion":"tr_if (prog_comp_env cu) a2 Sskip Sbreak\n  (makeseq (sl ++ makeif a Sskip Sbreak :: nil))","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts3 ts4 : statement) (H4 : tr_stmt (prog_comp_env cu) a3 ts3) (H5 : tr_stmt (prog_comp_env cu) s ts4) (sl : list statement) (a : expr) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val a2 sl a tmps)","proofString":"econstructor; eauto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kfor2 a2 a3 s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kfor2 a2 a3 s k) tk)","proofString":"inv MK.\nexploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (v1 := v) (b := false); auto.\neapply star_two.\nconstructor.\napply step_break_loop1.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0)","proofString":"exploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (v1 := v) (b := false); auto.\neapply star_two.\nconstructor.\napply step_break_loop1.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) : sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0)","proofString":"intros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (v1 := v) (b := false); auto.\neapply star_two.\nconstructor.\napply step_break_loop1.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some false) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v)","proofString":"subst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (v1 := v) (b := false); auto.\neapply star_two.\nconstructor.\napply step_break_loop1.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"econstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_trans.\napply step_makeif with (v1 := v) (b := false); auto.\neapply star_two.\nconstructor.\napply step_break_loop1.\nreflexivity.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (v : val) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip.","conclusion":"tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip","hypotheses":"(f : Csyntax.function) (v : val) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some false) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kfor2 a2 a3 s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kfor3 a2 a3 s k) e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kfor3 a2 a3 s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kfor3 a2 a3 s k) e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kfor3 a2 a3 s k) e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kfor2 a2 a3 s k) tk)","proofString":"inv MK.\nexploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kfor3 a2 a3 s k) e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kfor3 a2 a3 s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kfor3 a2 a3 s k) e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kfor3 a2 a3 s k) e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0)","proofString":"exploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) : sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kfor3 a2 a3 s k) e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kfor3 a2 a3 s k) e m) S2'.","conclusion":"sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kfor3 a2 a3 s k) e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kfor3 a2 a3 s k) e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0)","proofString":"intros [A [B C]].\nsubst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kfor3 a2 a3 s k) e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kfor3 a2 a3 s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist sl\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kfor3 a2 a3 s k) e m) <\n    measure (ExprState f (Eval v ty) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kfor3 a2 a3 s k) e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (ty : type) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : bool_val v ty m = Some true) (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v)","proofString":"subst.\neconstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kfor3 a2 a3 s k) e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kfor3 a2 a3 s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip\n        (Kseqlist nil\n           (Kseq (makeif a Sskip Sbreak)\n              (Kseq ts (Kloop1 (Ssequence s' ts) ts3 tk0)))) e le m) E0 S2' /\\\n   (measure (Csem.State f s (Kfor3 a2 a3 s k) e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kfor2 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f s (Kfor3 a2 a3 s k) e m) S2'","hypotheses":"(f : Csyntax.function) (v : val) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"econstructor; split.\nleft.\nsimpl.\neapply plus_left.\nconstructor.\neapply star_right.\napply step_makeif with (v1 := v) (b := true); auto.\nconstructor.\nreflexivity.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (v : val) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : match_cont (prog_comp_env cu) (Kfor3 a2 a3 s k)\n  (Kloop1 (Ssequence s' ts) ts3 tk0).","conclusion":"match_cont (prog_comp_env cu) (Kfor3 a2 a3 s k)\n  (Kloop1 (Ssequence s' ts) ts3 tk0)","hypotheses":"(f : Csyntax.function) (v : val) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (a : expr) (H : bool_val v (typeof a) m = Some true) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (s' ts3 ts : statement) (tk0 : cont) (H7 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H9 : tr_stmt (prog_comp_env cu) a3 ts3) (H10 : tr_stmt (prog_comp_env cu) s ts) (H11 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"constructor; auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (MK : match_cont (prog_comp_env cu) (Kfor3 a2 a3 s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f a3 (Kfor4 a2 a3 s k) e m) <\n    measure (Csem.State f x (Kfor3 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f a3 (Kfor4 a2 a3 s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f a3 (Kfor4 a2 a3 s k) e m) <\n    measure (Csem.State f x (Kfor3 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f a3 (Kfor4 a2 a3 s k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (MK : match_cont (prog_comp_env cu) (Kfor3 a2 a3 s k) tk)","proofString":"assert (ts = Sskip \\/ ts = Scontinue).\ndestruct H; subst x; inv TR; auto.\ninv MK.\neconstructor; split.\nleft.\napply plus_one.\napply step_skip_or_continue_loop1.\nauto.\neconstructor; eauto.\neconstructor; auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (MK : match_cont (prog_comp_env cu) (Kfor3 a2 a3 s k) tk) : ts = Sskip \\/ ts = Scontinue.","conclusion":"ts = Sskip \\/ ts = Scontinue","hypotheses":"(f : Csyntax.function) (x : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (MK : match_cont (prog_comp_env cu) (Kfor3 a2 a3 s k) tk)","proofString":"destruct H; subst x; inv TR; auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (MK : match_cont (prog_comp_env cu) (Kfor3 a2 a3 s k) tk) (H0 : ts = Sskip \\/ ts = Scontinue) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f a3 (Kfor4 a2 a3 s k) e m) <\n    measure (Csem.State f x (Kfor3 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f a3 (Kfor4 a2 a3 s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f a3 (Kfor4 a2 a3 s k) e m) <\n    measure (Csem.State f x (Kfor3 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f a3 (Kfor4 a2 a3 s k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Scontinue) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (MK : match_cont (prog_comp_env cu) (Kfor3 a2 a3 s k) tk) (H0 : ts = Sskip \\/ ts = Scontinue)","proofString":"inv MK.\neconstructor; split.\nleft.\napply plus_one.\napply step_skip_or_continue_loop1.\nauto.\neconstructor; eauto.\neconstructor; auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts3 s' ts0 : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) a3 ts3) (H9 : tr_stmt (prog_comp_env cu) s ts0) (H10 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge (State tf ts (Kloop1 (Ssequence s' ts0) ts3 tk0) e le m) E0\n     S2' \\/\n   star step1 tge (State tf ts (Kloop1 (Ssequence s' ts0) ts3 tk0) e le m) E0\n     S2' /\\\n   (measure (Csem.State f a3 (Kfor4 a2 a3 s k) e m) <\n    measure (Csem.State f x (Kfor3 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f a3 (Kfor4 a2 a3 s k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts (Kloop1 (Ssequence s' ts0) ts3 tk0) e le m) E0\n     S2' \\/\n   star step1 tge (State tf ts (Kloop1 (Ssequence s' ts0) ts3 tk0) e le m) E0\n     S2' /\\\n   (measure (Csem.State f a3 (Kfor4 a2 a3 s k) e m) <\n    measure (Csem.State f x (Kfor3 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f a3 (Kfor4 a2 a3 s k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts3 s' ts0 : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) a3 ts3) (H9 : tr_stmt (prog_comp_env cu) s ts0) (H10 : match_cont (prog_comp_env cu) k tk0)","proofString":"econstructor; split.\nleft.\napply plus_one.\napply step_skip_or_continue_loop1.\nauto.\neconstructor; eauto.\neconstructor; auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts3 s' ts0 : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) a3 ts3) (H9 : tr_stmt (prog_comp_env cu) s ts0) (H10 : match_cont (prog_comp_env cu) k tk0) : ts = Sskip \\/ ts = Scontinue.","conclusion":"ts = Sskip \\/ ts = Scontinue","hypotheses":"(f : Csyntax.function) (x : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts3 s' ts0 : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) a3 ts3) (H9 : tr_stmt (prog_comp_env cu) s ts0) (H10 : match_cont (prog_comp_env cu) k tk0)","proofString":"auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts3 s' ts0 : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) a3 ts3) (H9 : tr_stmt (prog_comp_env cu) s ts0) (H10 : match_cont (prog_comp_env cu) k tk0) : match_cont (prog_comp_env cu) (Kfor4 a2 a3 s k)\n  (Kloop2 (Ssequence s' ts0) ts3 tk0).","conclusion":"match_cont (prog_comp_env cu) (Kfor4 a2 a3 s k)\n  (Kloop2 (Ssequence s' ts0) ts3 tk0)","hypotheses":"(f : Csyntax.function) (x : Csyntax.statement) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Scontinue) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (H0 : ts = Sskip \\/ ts = Scontinue) (ts3 s' ts0 : statement) (tk0 : cont) (H6 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H8 : tr_stmt (prog_comp_env cu) a3 ts3) (H9 : tr_stmt (prog_comp_env cu) s ts0) (H10 : match_cont (prog_comp_env cu) k tk0)","proofString":"econstructor; auto."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sbreak ts) (MK : match_cont (prog_comp_env cu) (Kfor3 a2 a3 s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kfor3 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kfor3 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sbreak ts) (MK : match_cont (prog_comp_env cu) (Kfor3 a2 a3 s k) tk)","proofString":"inv TR.\ninv MK.\neconstructor; split.\nleft.\napply plus_one.\napply step_break_loop1.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) (Kfor3 a2 a3 s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sbreak tk e le m) E0 S2' \\/\n   star step1 tge (State tf Sbreak tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kfor3 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sbreak tk e le m) E0 S2' \\/\n   star step1 tge (State tf Sbreak tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kfor3 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) (Kfor3 a2 a3 s k) tk)","proofString":"inv MK.\neconstructor; split.\nleft.\napply plus_one.\napply step_break_loop1.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts3 s' ts : statement) (tk0 : cont) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H6 : tr_stmt (prog_comp_env cu) a3 ts3) (H7 : tr_stmt (prog_comp_env cu) s ts) (H8 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge (State tf Sbreak (Kloop1 (Ssequence s' ts) ts3 tk0) e le m)\n     E0 S2' \\/\n   star step1 tge (State tf Sbreak (Kloop1 (Ssequence s' ts) ts3 tk0) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kfor3 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sbreak (Kloop1 (Ssequence s' ts) ts3 tk0) e le m)\n     E0 S2' \\/\n   star step1 tge (State tf Sbreak (Kloop1 (Ssequence s' ts) ts3 tk0) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f Csyntax.Sbreak (Kfor3 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts3 s' ts : statement) (tk0 : cont) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H6 : tr_stmt (prog_comp_env cu) a3 ts3) (H7 : tr_stmt (prog_comp_env cu) s ts) (H8 : match_cont (prog_comp_env cu) k tk0)","proofString":"econstructor; split.\nleft.\napply plus_one.\napply step_break_loop1.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts3 s' ts : statement) (tk0 : cont) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H6 : tr_stmt (prog_comp_env cu) a3 ts3) (H7 : tr_stmt (prog_comp_env cu) s ts) (H8 : match_cont (prog_comp_env cu) k tk0) : tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip.","conclusion":"tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts3 s' ts : statement) (tk0 : cont) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H6 : tr_stmt (prog_comp_env cu) a3 ts3) (H7 : tr_stmt (prog_comp_env cu) s ts) (H8 : match_cont (prog_comp_env cu) k tk0)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sskip ts) (MK : match_cont (prog_comp_env cu) (Kfor4 a2 a3 s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m) <\n    measure (Csem.State f Csyntax.Sskip (Kfor4 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m) <\n    measure (Csem.State f Csyntax.Sskip (Kfor4 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m) S2'","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sskip ts) (MK : match_cont (prog_comp_env cu) (Kfor4 a2 a3 s k) tk)","proofString":"inv TR.\ninv MK.\neconstructor; split.\nleft.\napply plus_one.\nconstructor.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) (Kfor4 a2 a3 s k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip tk e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip tk e le m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m) <\n    measure (Csem.State f Csyntax.Sskip (Kfor4 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip tk e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip tk e le m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m) <\n    measure (Csem.State f Csyntax.Sskip (Kfor4 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m) S2'","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) (Kfor4 a2 a3 s k) tk)","proofString":"inv MK.\neconstructor; split.\nleft.\napply plus_one.\nconstructor.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts3 s' ts : statement) (tk0 : cont) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H6 : tr_stmt (prog_comp_env cu) a3 ts3) (H7 : tr_stmt (prog_comp_env cu) s ts) (H8 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kloop2 (Ssequence s' ts) ts3 tk0) e le m)\n     E0 S2' \\/\n   star step1 tge (State tf Sskip (Kloop2 (Ssequence s' ts) ts3 tk0) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m) <\n    measure (Csem.State f Csyntax.Sskip (Kfor4 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kloop2 (Ssequence s' ts) ts3 tk0) e le m)\n     E0 S2' \\/\n   star step1 tge (State tf Sskip (Kloop2 (Ssequence s' ts) ts3 tk0) e le m)\n     E0 S2' /\\\n   (measure (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m) <\n    measure (Csem.State f Csyntax.Sskip (Kfor4 a2 a3 s k) e m))%nat) /\\\n  match_states (Csem.State f (Csyntax.Sfor Csyntax.Sskip a2 a3 s) k e m) S2'","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts3 s' ts : statement) (tk0 : cont) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H6 : tr_stmt (prog_comp_env cu) a3 ts3) (H7 : tr_stmt (prog_comp_env cu) s ts) (H8 : match_cont (prog_comp_env cu) k tk0)","proofString":"econstructor; split.\nleft.\napply plus_one.\nconstructor.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts3 s' ts : statement) (tk0 : cont) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H6 : tr_stmt (prog_comp_env cu) a3 ts3) (H7 : tr_stmt (prog_comp_env cu) s ts) (H8 : match_cont (prog_comp_env cu) k tk0) : tr_stmt (prog_comp_env cu) (Csyntax.Sfor Csyntax.Sskip a2 a3 s)\n  (Sloop (Ssequence s' ts) ts3).","conclusion":"tr_stmt (prog_comp_env cu) (Csyntax.Sfor Csyntax.Sskip a2 a3 s)\n  (Sloop (Ssequence s' ts) ts3)","hypotheses":"(f : Csyntax.function) (a2 : Csyntax.expr) (a3 s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (ts3 s' ts : statement) (tk0 : cont) (H4 : tr_if (prog_comp_env cu) a2 Sskip Sbreak s') (H6 : tr_stmt (prog_comp_env cu) a3 ts3) (H7 : tr_stmt (prog_comp_env cu) s ts) (H8 : match_cont (prog_comp_env cu) k tk0)","proofString":"constructor; auto."},{"statement":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sreturn None) ts) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.Returnstate Vundef (Csem.call_cont k) m') <\n    measure (Csem.State f (Csyntax.Sreturn None) k e m))%nat) /\\\n  match_states (Csem.Returnstate Vundef (Csem.call_cont k) m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.Returnstate Vundef (Csem.call_cont k) m') <\n    measure (Csem.State f (Csyntax.Sreturn None) k e m))%nat) /\\\n  match_states (Csem.Returnstate Vundef (Csem.call_cont k) m') S2'","hypotheses":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sreturn None) ts) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR.\neconstructor; split.\nleft.\napply plus_one.\neconstructor; eauto.\nrewrite blocks_of_env_preserved; eauto.\neconstructor.\nintros; eapply match_cont_call_cont; eauto."},{"statement":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf (Sreturn None) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sreturn None) tk e le m) E0 S2' /\\\n   (measure (Csem.Returnstate Vundef (Csem.call_cont k) m') <\n    measure (Csem.State f (Csyntax.Sreturn None) k e m))%nat) /\\\n  match_states (Csem.Returnstate Vundef (Csem.call_cont k) m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Sreturn None) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sreturn None) tk e le m) E0 S2' /\\\n   (measure (Csem.Returnstate Vundef (Csem.call_cont k) m') <\n    measure (Csem.State f (Csyntax.Sreturn None) k e m))%nat) /\\\n  match_states (Csem.Returnstate Vundef (Csem.call_cont k) m') S2'","hypotheses":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"econstructor; split.\nleft.\napply plus_one.\neconstructor; eauto.\nrewrite blocks_of_env_preserved; eauto.\neconstructor.\nintros; eapply match_cont_call_cont; eauto."},{"statement":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) : forall ce : composite_env, match_cont ce (Csem.call_cont k) (call_cont tk).","conclusion":"forall ce : composite_env, match_cont ce (Csem.call_cont k) (call_cont tk)","hypotheses":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"intros; eapply match_cont_call_cont; eauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sreturn (Some x)) ts) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kreturn k) e m) <\n    measure (Csem.State f (Csyntax.Sreturn (Some x)) k e m))%nat) /\\\n  match_states (ExprState f x (Kreturn k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kreturn k) e m) <\n    measure (Csem.State f (Csyntax.Sreturn (Some x)) k e m))%nat) /\\\n  match_states (ExprState f x (Kreturn k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sreturn (Some x)) ts) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR.\ninv H0.\neconstructor; split.\nleft; eapply plus_left.\nconstructor.\napply push_seq.\ntraceEq.\neconstructor; eauto.\nconstructor.\nauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' : statement) (a : expr) (H0 : tr_expression (prog_comp_env cu) x s' a) : exists S2' : state,\n  (plus step1 tge (State tf (Ssequence s' (Sreturn (Some a))) tk e le m) E0\n     S2' \\/\n   star step1 tge (State tf (Ssequence s' (Sreturn (Some a))) tk e le m) E0\n     S2' /\\\n   (measure (ExprState f x (Kreturn k) e m) <\n    measure (Csem.State f (Csyntax.Sreturn (Some x)) k e m))%nat) /\\\n  match_states (ExprState f x (Kreturn k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Ssequence s' (Sreturn (Some a))) tk e le m) E0\n     S2' \\/\n   star step1 tge (State tf (Ssequence s' (Sreturn (Some a))) tk e le m) E0\n     S2' /\\\n   (measure (ExprState f x (Kreturn k) e m) <\n    measure (Csem.State f (Csyntax.Sreturn (Some x)) k e m))%nat) /\\\n  match_states (ExprState f x (Kreturn k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' : statement) (a : expr) (H0 : tr_expression (prog_comp_env cu) x s' a)","proofString":"inv H0.\neconstructor; split.\nleft; eapply plus_left.\nconstructor.\napply push_seq.\ntraceEq.\neconstructor; eauto.\nconstructor.\nauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a : expr) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : exists S2' : state,\n  (plus step1 tge\n     (State tf (Ssequence (makeseq sl) (Sreturn (Some a))) tk e le m) E0 S2' \\/\n   star step1 tge\n     (State tf (Ssequence (makeseq sl) (Sreturn (Some a))) tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kreturn k) e m) <\n    measure (Csem.State f (Csyntax.Sreturn (Some x)) k e m))%nat) /\\\n  match_states (ExprState f x (Kreturn k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf (Ssequence (makeseq sl) (Sreturn (Some a))) tk e le m) E0 S2' \\/\n   star step1 tge\n     (State tf (Ssequence (makeseq sl) (Sreturn (Some a))) tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kreturn k) e m) <\n    measure (Csem.State f (Csyntax.Sreturn (Some x)) k e m))%nat) /\\\n  match_states (ExprState f x (Kreturn k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a : expr) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"econstructor; split.\nleft; eapply plus_left.\nconstructor.\napply push_seq.\ntraceEq.\neconstructor; eauto.\nconstructor.\nauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a : expr) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : match_cont_exp (prog_comp_env cu) For_val a (Kreturn k)\n  (Kseq (Sreturn (Some a)) tk).","conclusion":"match_cont_exp (prog_comp_env cu) For_val a (Kreturn k)\n  (Kseq (Sreturn (Some a)) tk)","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a : expr) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"constructor.\nauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a : expr) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps) : match_cont (prog_comp_env cu) k tk.","conclusion":"match_cont (prog_comp_env cu) k tk","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a : expr) (sl : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl a tmps)","proofString":"auto."},{"statement":"(f : Csyntax.function) (v1 : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v1 ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kreturn k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.Returnstate v2 (Csem.call_cont k) m') <\n    measure (ExprState f (Eval v1 ty) (Kreturn k) e m))%nat) /\\\n  match_states (Csem.Returnstate v2 (Csem.call_cont k) m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl tk) e le m) E0 S2' /\\\n   (measure (Csem.Returnstate v2 (Csem.call_cont k) m') <\n    measure (ExprState f (Eval v1 ty) (Kreturn k) e m))%nat) /\\\n  match_states (Csem.Returnstate v2 (Csem.call_cont k) m') S2'","hypotheses":"(f : Csyntax.function) (v1 : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (sl : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v1 ty) sl a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kreturn k) tk)","proofString":"inv MK.\nexploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neconstructor.\neauto.\nerewrite function_return_preserved; eauto.\nrewrite blocks_of_env_preserved; eauto.\neauto.\ntraceEq.\neconstructor.\nintros; eapply match_cont_call_cont; eauto."},{"statement":"(f : Csyntax.function) (v1 : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v1 ty) sl a tmps) (tk0 : cont) (H5 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.Returnstate v2 (Csem.call_cont k) m') <\n    measure (ExprState f (Eval v1 ty) (Kreturn k) e m))%nat) /\\\n  match_states (Csem.Returnstate v2 (Csem.call_cont k) m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.Returnstate v2 (Csem.call_cont k) m') <\n    measure (ExprState f (Eval v1 ty) (Kreturn k) e m))%nat) /\\\n  match_states (Csem.Returnstate v2 (Csem.call_cont k) m') S2'","hypotheses":"(f : Csyntax.function) (v1 : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v1 ty) sl a tmps) (tk0 : cont) (H5 : match_cont (prog_comp_env cu) k tk0)","proofString":"exploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neconstructor.\neauto.\nerewrite function_return_preserved; eauto.\nrewrite blocks_of_env_preserved; eauto.\neauto.\ntraceEq.\neconstructor.\nintros; eapply match_cont_call_cont; eauto."},{"statement":"(f : Csyntax.function) (v1 : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v1 ty) sl a tmps) (tk0 : cont) (H5 : match_cont (prog_comp_env cu) k tk0) : sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v1 ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.Returnstate v2 (Csem.call_cont k) m') <\n    measure (ExprState f (Eval v1 ty) (Kreturn k) e m))%nat) /\\\n  match_states (Csem.Returnstate v2 (Csem.call_cont k) m') S2'.","conclusion":"sl = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v1 ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.Returnstate v2 (Csem.call_cont k) m') <\n    measure (ExprState f (Eval v1 ty) (Kreturn k) e m))%nat) /\\\n  match_states (Csem.Returnstate v2 (Csem.call_cont k) m') S2'","hypotheses":"(f : Csyntax.function) (v1 : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v1 ty) sl a tmps) (tk0 : cont) (H5 : match_cont (prog_comp_env cu) k tk0)","proofString":"intros [A [B C]].\nsubst.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neconstructor.\neauto.\nerewrite function_return_preserved; eauto.\nrewrite blocks_of_env_preserved; eauto.\neauto.\ntraceEq.\neconstructor.\nintros; eapply match_cont_call_cont; eauto."},{"statement":"(f : Csyntax.function) (v1 : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v1 ty) sl a tmps) (tk0 : cont) (H5 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v1) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.Returnstate v2 (Csem.call_cont k) m') <\n    measure (ExprState f (Eval v1 ty) (Kreturn k) e m))%nat) /\\\n  match_states (Csem.Returnstate v2 (Csem.call_cont k) m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.Returnstate v2 (Csem.call_cont k) m') <\n    measure (ExprState f (Eval v1 ty) (Kreturn k) e m))%nat) /\\\n  match_states (Csem.Returnstate v2 (Csem.call_cont k) m') S2'","hypotheses":"(f : Csyntax.function) (v1 : val) (ty : type) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (H : sem_cast v1 ty (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (sl : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v1 ty) sl a tmps) (tk0 : cont) (H5 : match_cont (prog_comp_env cu) k tk0) (A : sl = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v1)","proofString":"subst.\neconstructor; split.\nleft.\neapply plus_two.\nconstructor.\neconstructor.\neauto.\nerewrite function_return_preserved; eauto.\nrewrite blocks_of_env_preserved; eauto.\neauto.\ntraceEq.\neconstructor.\nintros; eapply match_cont_call_cont; eauto."},{"statement":"(f : Csyntax.function) (v1 : val) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (a : expr) (H : sem_cast v1 (typeof a) (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v1 (typeof a)) nil a tmps) (tk0 : cont) (H5 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v1) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist nil (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist nil (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.Returnstate v2 (Csem.call_cont k) m') <\n    measure (ExprState f (Eval v1 (typeof a)) (Kreturn k) e m))%nat) /\\\n  match_states (Csem.Returnstate v2 (Csem.call_cont k) m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist nil (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist nil (Kseq (Sreturn (Some a)) tk0)) e le m) E0\n     S2' /\\\n   (measure (Csem.Returnstate v2 (Csem.call_cont k) m') <\n    measure (ExprState f (Eval v1 (typeof a)) (Kreturn k) e m))%nat) /\\\n  match_states (Csem.Returnstate v2 (Csem.call_cont k) m') S2'","hypotheses":"(f : Csyntax.function) (v1 : val) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (a : expr) (H : sem_cast v1 (typeof a) (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v1 (typeof a)) nil a tmps) (tk0 : cont) (H5 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v1)","proofString":"econstructor; split.\nleft.\neapply plus_two.\nconstructor.\neconstructor.\neauto.\nerewrite function_return_preserved; eauto.\nrewrite blocks_of_env_preserved; eauto.\neauto.\ntraceEq.\neconstructor.\nintros; eapply match_cont_call_cont; eauto."},{"statement":"(f : Csyntax.function) (v1 : val) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (a : expr) (H : sem_cast v1 (typeof a) (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v1 (typeof a)) nil a tmps) (tk0 : cont) (H5 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v1) : match_states (Csem.Returnstate v2 (Csem.call_cont k) m')\n  (Returnstate v2 (call_cont tk0) m').","conclusion":"match_states (Csem.Returnstate v2 (Csem.call_cont k) m')\n  (Returnstate v2 (call_cont tk0) m')","hypotheses":"(f : Csyntax.function) (v1 : val) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (a : expr) (H : sem_cast v1 (typeof a) (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v1 (typeof a)) nil a tmps) (tk0 : cont) (H5 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v1)","proofString":"econstructor.\nintros; eapply match_cont_call_cont; eauto."},{"statement":"(f : Csyntax.function) (v1 : val) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (a : expr) (H : sem_cast v1 (typeof a) (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v1 (typeof a)) nil a tmps) (tk0 : cont) (H5 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v1) : forall ce : composite_env, match_cont ce (Csem.call_cont k) (call_cont tk0).","conclusion":"forall ce : composite_env, match_cont ce (Csem.call_cont k) (call_cont tk0)","hypotheses":"(f : Csyntax.function) (v1 : val) (k : Csem.cont) (e : Csem.env) (m : mem) (v2 : val) (m' : mem) (a : expr) (H : sem_cast v1 (typeof a) (Csyntax.fn_return f) m = Some v2) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v1 (typeof a)) nil a tmps) (tk0 : cont) (H5 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v1)","proofString":"intros; eapply match_cont_call_cont; eauto."},{"statement":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Csem.is_call_cont k) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sskip ts) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.Returnstate Vundef k m') <\n    measure (Csem.State f Csyntax.Sskip k e m))%nat) /\\\n  match_states (Csem.Returnstate Vundef k m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.Returnstate Vundef k m') <\n    measure (Csem.State f Csyntax.Sskip k e m))%nat) /\\\n  match_states (Csem.Returnstate Vundef k m') S2'","hypotheses":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Csem.is_call_cont k) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Sskip ts) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR.\nassert (is_call_cont tk).\ninv MK; simpl in *; auto.\neconstructor; split.\nleft.\napply plus_one.\napply step_skip_call; eauto.\nrewrite blocks_of_env_preserved; eauto.\neconstructor.\nintros; eapply match_cont_is_call_cont; eauto."},{"statement":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Csem.is_call_cont k) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip tk e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip tk e le m) E0 S2' /\\\n   (measure (Csem.Returnstate Vundef k m') <\n    measure (Csem.State f Csyntax.Sskip k e m))%nat) /\\\n  match_states (Csem.Returnstate Vundef k m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip tk e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip tk e le m) E0 S2' /\\\n   (measure (Csem.Returnstate Vundef k m') <\n    measure (Csem.State f Csyntax.Sskip k e m))%nat) /\\\n  match_states (Csem.Returnstate Vundef k m') S2'","hypotheses":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Csem.is_call_cont k) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"assert (is_call_cont tk).\ninv MK; simpl in *; auto.\neconstructor; split.\nleft.\napply plus_one.\napply step_skip_call; eauto.\nrewrite blocks_of_env_preserved; eauto.\neconstructor.\nintros; eapply match_cont_is_call_cont; eauto."},{"statement":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Csem.is_call_cont k) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) : is_call_cont tk.","conclusion":"is_call_cont tk","hypotheses":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Csem.is_call_cont k) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv MK; simpl in *; auto."},{"statement":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Csem.is_call_cont k) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H1 : is_call_cont tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip tk e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip tk e le m) E0 S2' /\\\n   (measure (Csem.Returnstate Vundef k m') <\n    measure (Csem.State f Csyntax.Sskip k e m))%nat) /\\\n  match_states (Csem.Returnstate Vundef k m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip tk e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip tk e le m) E0 S2' /\\\n   (measure (Csem.Returnstate Vundef k m') <\n    measure (Csem.State f Csyntax.Sskip k e m))%nat) /\\\n  match_states (Csem.Returnstate Vundef k m') S2'","hypotheses":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Csem.is_call_cont k) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H1 : is_call_cont tk)","proofString":"econstructor; split.\nleft.\napply plus_one.\napply step_skip_call; eauto.\nrewrite blocks_of_env_preserved; eauto.\neconstructor.\nintros; eapply match_cont_is_call_cont; eauto."},{"statement":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Csem.is_call_cont k) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H1 : is_call_cont tk) : forall ce : composite_env, match_cont ce k tk.","conclusion":"forall ce : composite_env, match_cont ce k tk","hypotheses":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m m' : mem) (H : Csem.is_call_cont k) (H0 : Mem.free_list m (Csem.blocks_of_env ge e) = Some m') (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H1 : is_call_cont tk)","proofString":"intros; eapply match_cont_is_call_cont; eauto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sswitch x sl) ts) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kswitch1 sl k) e m) <\n    measure (Csem.State f (Csyntax.Sswitch x sl) k e m))%nat) /\\\n  match_states (ExprState f x (Kswitch1 sl k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kswitch1 sl k) e m) <\n    measure (Csem.State f (Csyntax.Sswitch x sl) k e m))%nat) /\\\n  match_states (ExprState f x (Kswitch1 sl k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sswitch x sl) ts) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR.\ninv H1.\neconstructor; split.\nleft; eapply plus_left.\nconstructor.\napply push_seq.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' : statement) (a : expr) (tls : labeled_statements) (H1 : tr_expression (prog_comp_env cu) x s' a) (H3 : tr_lblstmts (prog_comp_env cu) sl tls) : exists S2' : state,\n  (plus step1 tge (State tf (Ssequence s' (Sswitch a tls)) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Ssequence s' (Sswitch a tls)) tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kswitch1 sl k) e m) <\n    measure (Csem.State f (Csyntax.Sswitch x sl) k e m))%nat) /\\\n  match_states (ExprState f x (Kswitch1 sl k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Ssequence s' (Sswitch a tls)) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Ssequence s' (Sswitch a tls)) tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kswitch1 sl k) e m) <\n    measure (Csem.State f (Csyntax.Sswitch x sl) k e m))%nat) /\\\n  match_states (ExprState f x (Kswitch1 sl k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (s' : statement) (a : expr) (tls : labeled_statements) (H1 : tr_expression (prog_comp_env cu) x s' a) (H3 : tr_lblstmts (prog_comp_env cu) sl tls)","proofString":"inv H1.\neconstructor; split.\nleft; eapply plus_left.\nconstructor.\napply push_seq.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a : expr) (tls : labeled_statements) (H3 : tr_lblstmts (prog_comp_env cu) sl tls) (sl0 : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl0 a tmps) : exists S2' : state,\n  (plus step1 tge\n     (State tf (Ssequence (makeseq sl0) (Sswitch a tls)) tk e le m) E0 S2' \\/\n   star step1 tge\n     (State tf (Ssequence (makeseq sl0) (Sswitch a tls)) tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kswitch1 sl k) e m) <\n    measure (Csem.State f (Csyntax.Sswitch x sl) k e m))%nat) /\\\n  match_states (ExprState f x (Kswitch1 sl k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf (Ssequence (makeseq sl0) (Sswitch a tls)) tk e le m) E0 S2' \\/\n   star step1 tge\n     (State tf (Ssequence (makeseq sl0) (Sswitch a tls)) tk e le m) E0 S2' /\\\n   (measure (ExprState f x (Kswitch1 sl k) e m) <\n    measure (Csem.State f (Csyntax.Sswitch x sl) k e m))%nat) /\\\n  match_states (ExprState f x (Kswitch1 sl k) e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a : expr) (tls : labeled_statements) (H3 : tr_lblstmts (prog_comp_env cu) sl tls) (sl0 : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl0 a tmps)","proofString":"econstructor; split.\nleft; eapply plus_left.\nconstructor.\napply push_seq.\ntraceEq.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.expr) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a : expr) (tls : labeled_statements) (H3 : tr_lblstmts (prog_comp_env cu) sl tls) (sl0 : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl0 a tmps) : match_cont_exp (prog_comp_env cu) For_val a (Kswitch1 sl k)\n  (Kseq (Sswitch a tls) tk).","conclusion":"match_cont_exp (prog_comp_env cu) For_val a (Kswitch1 sl k)\n  (Kseq (Sswitch a tls) tk)","hypotheses":"(f : Csyntax.function) (x : Csyntax.expr) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (a : expr) (tls : labeled_statements) (H3 : tr_lblstmts (prog_comp_env cu) sl tls) (sl0 : list statement) (tmps : list ident) (H : forall (ge0 : genv) (e0 : env) (le0 : temp_env) (m0 : mem),\ntr_top (prog_comp_env cu) ge0 e0 le0 m0 For_val x sl0 a tmps)","proofString":"constructor; auto."},{"statement":"(f : Csyntax.function) (ty : type) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (tf : function) (sl0 : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl0 a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kswitch1 sl k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl0 tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl0 tk) e le m) E0 S2' /\\\n   (measure\n      (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n         (Kswitch2 k) e m) <\n    measure (ExprState f (Eval v ty) (Kswitch1 sl k) e m))%nat) /\\\n  match_states\n    (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n       (Kswitch2 k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Sskip (Kseqlist sl0 tk) e le m) E0 S2' \\/\n   star step1 tge (State tf Sskip (Kseqlist sl0 tk) e le m) E0 S2' /\\\n   (measure\n      (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n         (Kswitch2 k) e m) <\n    measure (ExprState f (Eval v ty) (Kswitch1 sl k) e m))%nat) /\\\n  match_states\n    (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n       (Kswitch2 k) e m) S2'","hypotheses":"(f : Csyntax.function) (ty : type) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (tf : function) (sl0 : list statement) (tk : cont) (le : temp_env) (dest : destination) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m dest (Eval v ty) sl0 a tmps) (MK : match_cont_exp (prog_comp_env cu) dest a (Kswitch1 sl k) tk)","proofString":"inv MK.\nexploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft; eapply plus_two.\nconstructor.\neconstructor; eauto.\ntraceEq.\neconstructor; eauto.\napply tr_seq_of_labeled_statement.\napply tr_select_switch.\nauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (ty : type) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (tf : function) (sl0 : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl0 a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl0 (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl0 (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' /\\\n   (measure\n      (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n         (Kswitch2 k) e m) <\n    measure (ExprState f (Eval v ty) (Kswitch1 sl k) e m))%nat) /\\\n  match_states\n    (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n       (Kswitch2 k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl0 (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl0 (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' /\\\n   (measure\n      (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n         (Kswitch2 k) e m) <\n    measure (ExprState f (Eval v ty) (Kswitch1 sl k) e m))%nat) /\\\n  match_states\n    (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n       (Kswitch2 k) e m) S2'","hypotheses":"(f : Csyntax.function) (ty : type) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (tf : function) (sl0 : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl0 a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0)","proofString":"exploit tr_top_val_for_val_inv; eauto.\nintros [A [B C]].\nsubst.\neconstructor; split.\nleft; eapply plus_two.\nconstructor.\neconstructor; eauto.\ntraceEq.\neconstructor; eauto.\napply tr_seq_of_labeled_statement.\napply tr_select_switch.\nauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (ty : type) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (tf : function) (sl0 : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl0 a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) : sl0 = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl0 (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl0 (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' /\\\n   (measure\n      (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n         (Kswitch2 k) e m) <\n    measure (ExprState f (Eval v ty) (Kswitch1 sl k) e m))%nat) /\\\n  match_states\n    (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n       (Kswitch2 k) e m) S2'.","conclusion":"sl0 = nil /\\ typeof a = ty /\\ eval_expr tge e le m a v ->\nexists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl0 (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl0 (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' /\\\n   (measure\n      (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n         (Kswitch2 k) e m) <\n    measure (ExprState f (Eval v ty) (Kswitch1 sl k) e m))%nat) /\\\n  match_states\n    (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n       (Kswitch2 k) e m) S2'","hypotheses":"(f : Csyntax.function) (ty : type) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (tf : function) (sl0 : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl0 a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0)","proofString":"intros [A [B C]].\nsubst.\neconstructor; split.\nleft; eapply plus_two.\nconstructor.\neconstructor; eauto.\ntraceEq.\neconstructor; eauto.\napply tr_seq_of_labeled_statement.\napply tr_select_switch.\nauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (ty : type) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (tf : function) (sl0 : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl0 a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) (A : sl0 = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl0 (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl0 (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' /\\\n   (measure\n      (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n         (Kswitch2 k) e m) <\n    measure (ExprState f (Eval v ty) (Kswitch1 sl k) e m))%nat) /\\\n  match_states\n    (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n       (Kswitch2 k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist sl0 (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist sl0 (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' /\\\n   (measure\n      (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n         (Kswitch2 k) e m) <\n    measure (ExprState f (Eval v ty) (Kswitch1 sl k) e m))%nat) /\\\n  match_states\n    (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n       (Kswitch2 k) e m) S2'","hypotheses":"(f : Csyntax.function) (ty : type) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (H : sem_switch_arg v ty = Some n) (tf : function) (sl0 : list statement) (le : temp_env) (a : expr) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v ty) sl0 a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) (A : sl0 = nil) (B : typeof a = ty) (C : eval_expr tge e le m a v)","proofString":"subst.\neconstructor; split.\nleft; eapply plus_two.\nconstructor.\neconstructor; eauto.\ntraceEq.\neconstructor; eauto.\napply tr_seq_of_labeled_statement.\napply tr_select_switch.\nauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (a : expr) (H : sem_switch_arg v (typeof a) = Some n) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist nil (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist nil (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' /\\\n   (measure\n      (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n         (Kswitch2 k) e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kswitch1 sl k) e m))%nat) /\\\n  match_states\n    (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n       (Kswitch2 k) e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge\n     (State tf Sskip (Kseqlist nil (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' \\/\n   star step1 tge\n     (State tf Sskip (Kseqlist nil (Kseq (Sswitch a tls) tk0)) e le m) E0 S2' /\\\n   (measure\n      (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n         (Kswitch2 k) e m) <\n    measure (ExprState f (Eval v (typeof a)) (Kswitch1 sl k) e m))%nat) /\\\n  match_states\n    (Csem.State f (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n       (Kswitch2 k) e m) S2'","hypotheses":"(f : Csyntax.function) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (a : expr) (H : sem_switch_arg v (typeof a) = Some n) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"econstructor; split.\nleft; eapply plus_two.\nconstructor.\neconstructor; eauto.\ntraceEq.\neconstructor; eauto.\napply tr_seq_of_labeled_statement.\napply tr_select_switch.\nauto.\nconstructor; auto."},{"statement":"(f : Csyntax.function) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (a : expr) (H : sem_switch_arg v (typeof a) = Some n) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : tr_stmt (prog_comp_env cu)\n  (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n  (seq_of_labeled_statement (select_switch n tls)).","conclusion":"tr_stmt (prog_comp_env cu)\n  (Csem.seq_of_labeled_statement (Csem.select_switch n sl))\n  (seq_of_labeled_statement (select_switch n tls))","hypotheses":"(f : Csyntax.function) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (a : expr) (H : sem_switch_arg v (typeof a) = Some n) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"apply tr_seq_of_labeled_statement.\napply tr_select_switch.\nauto."},{"statement":"(f : Csyntax.function) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (a : expr) (H : sem_switch_arg v (typeof a) = Some n) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : tr_lblstmts (prog_comp_env cu) (Csem.select_switch n sl)\n  (select_switch n tls).","conclusion":"tr_lblstmts (prog_comp_env cu) (Csem.select_switch n sl)\n  (select_switch n tls)","hypotheses":"(f : Csyntax.function) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (a : expr) (H : sem_switch_arg v (typeof a) = Some n) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"apply tr_select_switch.\nauto."},{"statement":"(f : Csyntax.function) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (a : expr) (H : sem_switch_arg v (typeof a) = Some n) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : tr_lblstmts (prog_comp_env cu) sl tls.","conclusion":"tr_lblstmts (prog_comp_env cu) sl tls","hypotheses":"(f : Csyntax.function) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (a : expr) (H : sem_switch_arg v (typeof a) = Some n) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"auto."},{"statement":"(f : Csyntax.function) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (a : expr) (H : sem_switch_arg v (typeof a) = Some n) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v) : match_cont (prog_comp_env cu) (Kswitch2 k) (Kswitch tk0).","conclusion":"match_cont (prog_comp_env cu) (Kswitch2 k) (Kswitch tk0)","hypotheses":"(f : Csyntax.function) (sl : Csyntax.labeled_statements) (k : Csem.cont) (e : Csem.env) (m : mem) (v : val) (n : Z) (a : expr) (H : sem_switch_arg v (typeof a) = Some n) (tf : function) (le : temp_env) (tmps : list ident) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_top (prog_comp_env cu) tge e le m For_val (Eval v (typeof a)) nil a tmps) (tls : labeled_statements) (tk0 : cont) (H5 : tr_lblstmts (prog_comp_env cu) sl tls) (H7 : match_cont (prog_comp_env cu) k tk0) (C : eval_expr tge e le m a v)","proofString":"constructor; auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Sbreak) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (MK : match_cont (prog_comp_env cu) (Kswitch2 k) tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f x (Kswitch2 k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f x (Kswitch2 k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Sbreak) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (MK : match_cont (prog_comp_env cu) (Kswitch2 k) tk)","proofString":"assert (ts = Sskip \\/ ts = Sbreak).\ndestruct H; subst x; inv TR; auto.\ninv MK.\neconstructor; split.\nleft; apply plus_one.\napply step_skip_break_switch.\nauto.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (x : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Sbreak) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (MK : match_cont (prog_comp_env cu) (Kswitch2 k) tk) : ts = Sskip \\/ ts = Sbreak.","conclusion":"ts = Sskip \\/ ts = Sbreak","hypotheses":"(f : Csyntax.function) (x : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Sbreak) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (MK : match_cont (prog_comp_env cu) (Kswitch2 k) tk)","proofString":"destruct H; subst x; inv TR; auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Sbreak) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (MK : match_cont (prog_comp_env cu) (Kswitch2 k) tk) (H0 : ts = Sskip \\/ ts = Sbreak) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f x (Kswitch2 k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f x (Kswitch2 k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Sbreak) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (MK : match_cont (prog_comp_env cu) (Kswitch2 k) tk) (H0 : ts = Sskip \\/ ts = Sbreak)","proofString":"inv MK.\neconstructor; split.\nleft; apply plus_one.\napply step_skip_break_switch.\nauto.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (x : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Sbreak) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (H0 : ts = Sskip \\/ ts = Sbreak) (tk0 : cont) (H3 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge (State tf ts (Kswitch tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf ts (Kswitch tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f x (Kswitch2 k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts (Kswitch tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf ts (Kswitch tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Sskip k e m) <\n    measure (Csem.State f x (Kswitch2 k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Sskip k e m) S2'","hypotheses":"(f : Csyntax.function) (x : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Sbreak) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (H0 : ts = Sskip \\/ ts = Sbreak) (tk0 : cont) (H3 : match_cont (prog_comp_env cu) k tk0)","proofString":"econstructor; split.\nleft; apply plus_one.\napply step_skip_break_switch.\nauto.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (x : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Sbreak) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (H0 : ts = Sskip \\/ ts = Sbreak) (tk0 : cont) (H3 : match_cont (prog_comp_env cu) k tk0) : ts = Sskip \\/ ts = Sbreak.","conclusion":"ts = Sskip \\/ ts = Sbreak","hypotheses":"(f : Csyntax.function) (x : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Sbreak) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (H0 : ts = Sskip \\/ ts = Sbreak) (tk0 : cont) (H3 : match_cont (prog_comp_env cu) k tk0)","proofString":"auto."},{"statement":"(f : Csyntax.function) (x : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Sbreak) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (H0 : ts = Sskip \\/ ts = Sbreak) (tk0 : cont) (H3 : match_cont (prog_comp_env cu) k tk0) : tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip.","conclusion":"tr_stmt (prog_comp_env cu) Csyntax.Sskip Sskip","hypotheses":"(f : Csyntax.function) (x : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (H : x = Csyntax.Sskip \\/ x = Csyntax.Sbreak) (tf : function) (ts : statement) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) x ts) (H0 : ts = Sskip \\/ ts = Sbreak) (tk0 : cont) (H3 : match_cont (prog_comp_env cu) k tk0)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Scontinue ts) (MK : match_cont (prog_comp_env cu) (Kswitch2 k) tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Scontinue k e m) <\n    measure (Csem.State f Csyntax.Scontinue (Kswitch2 k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Scontinue k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Scontinue k e m) <\n    measure (Csem.State f Csyntax.Scontinue (Kswitch2 k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Scontinue k e m) S2'","hypotheses":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) Csyntax.Scontinue ts) (MK : match_cont (prog_comp_env cu) (Kswitch2 k) tk)","proofString":"inv TR.\ninv MK.\neconstructor; split.\nleft; apply plus_one.\napply step_continue_switch.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) (Kswitch2 k) tk) : exists S2' : state,\n  (plus step1 tge (State tf Scontinue tk e le m) E0 S2' \\/\n   star step1 tge (State tf Scontinue tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Scontinue k e m) <\n    measure (Csem.State f Csyntax.Scontinue (Kswitch2 k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Scontinue k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Scontinue tk e le m) E0 S2' \\/\n   star step1 tge (State tf Scontinue tk e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Scontinue k e m) <\n    measure (Csem.State f Csyntax.Scontinue (Kswitch2 k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Scontinue k e m) S2'","hypotheses":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) (Kswitch2 k) tk)","proofString":"inv MK.\neconstructor; split.\nleft; apply plus_one.\napply step_continue_switch.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (tk0 : cont) (H1 : match_cont (prog_comp_env cu) k tk0) : exists S2' : state,\n  (plus step1 tge (State tf Scontinue (Kswitch tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf Scontinue (Kswitch tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Scontinue k e m) <\n    measure (Csem.State f Csyntax.Scontinue (Kswitch2 k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Scontinue k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf Scontinue (Kswitch tk0) e le m) E0 S2' \\/\n   star step1 tge (State tf Scontinue (Kswitch tk0) e le m) E0 S2' /\\\n   (measure (Csem.State f Csyntax.Scontinue k e m) <\n    measure (Csem.State f Csyntax.Scontinue (Kswitch2 k) e m))%nat) /\\\n  match_states (Csem.State f Csyntax.Scontinue k e m) S2'","hypotheses":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (tk0 : cont) (H1 : match_cont (prog_comp_env cu) k tk0)","proofString":"econstructor; split.\nleft; apply plus_one.\napply step_continue_switch.\neconstructor; eauto.\nconstructor."},{"statement":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (tk0 : cont) (H1 : match_cont (prog_comp_env cu) k tk0) : tr_stmt (prog_comp_env cu) Csyntax.Scontinue Scontinue.","conclusion":"tr_stmt (prog_comp_env cu) Csyntax.Scontinue Scontinue","hypotheses":"(f : Csyntax.function) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (tk0 : cont) (H1 : match_cont (prog_comp_env cu) k tk0)","proofString":"constructor."},{"statement":"(f : Csyntax.function) (lbl : Csyntax.label) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Slabel lbl s) ts) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f s k e m) <\n    measure (Csem.State f (Csyntax.Slabel lbl s) k e m))%nat) /\\\n  match_states (Csem.State f s k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f s k e m) <\n    measure (Csem.State f (Csyntax.Slabel lbl s) k e m))%nat) /\\\n  match_states (Csem.State f s k e m) S2'","hypotheses":"(f : Csyntax.function) (lbl : Csyntax.label) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Slabel lbl s) ts) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR.\neconstructor; split.\nleft; apply plus_one.\nconstructor.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (lbl : Csyntax.label) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts0 : statement) (H2 : tr_stmt (prog_comp_env cu) s ts0) : exists S2' : state,\n  (plus step1 tge (State tf (Slabel lbl ts0) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Slabel lbl ts0) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s k e m) <\n    measure (Csem.State f (Csyntax.Slabel lbl s) k e m))%nat) /\\\n  match_states (Csem.State f s k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Slabel lbl ts0) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Slabel lbl ts0) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s k e m) <\n    measure (Csem.State f (Csyntax.Slabel lbl s) k e m))%nat) /\\\n  match_states (Csem.State f s k e m) S2'","hypotheses":"(f : Csyntax.function) (lbl : Csyntax.label) (s : Csyntax.statement) (k : Csem.cont) (e : Csem.env) (m : mem) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (ts0 : statement) (H2 : tr_stmt (prog_comp_env cu) s ts0)","proofString":"econstructor; split.\nleft; apply plus_one.\nconstructor.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (lbl : Csyntax.label) (k : Csem.cont) (e : Csem.env) (m : mem) (s' : Csyntax.statement) (k' : Csem.cont) (H : Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) = Some (s', k')) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sgoto lbl) ts) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f s' k' e m) <\n    measure (Csem.State f (Csyntax.Sgoto lbl) k e m))%nat) /\\\n  match_states (Csem.State f s' k' e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf ts tk e le m) E0 S2' \\/\n   star step1 tge (State tf ts tk e le m) E0 S2' /\\\n   (measure (Csem.State f s' k' e m) <\n    measure (Csem.State f (Csyntax.Sgoto lbl) k e m))%nat) /\\\n  match_states (Csem.State f s' k' e m) S2'","hypotheses":"(f : Csyntax.function) (lbl : Csyntax.label) (k : Csem.cont) (e : Csem.env) (m : mem) (s' : Csyntax.statement) (k' : Csem.cont) (H : Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) = Some (s', k')) (tf : function) (ts : statement) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (TR : tr_stmt (prog_comp_env cu) (Csyntax.Sgoto lbl) ts) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inv TR.\ninversion TRF; subst.\nexploit tr_find_label.\neauto.\neapply match_cont_call_cont; eauto.\ninstantiate (1 := lbl).\nrewrite H.\nintros [ts' [tk' [P [Q R]]]].\neconstructor; split.\nleft.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (lbl : Csyntax.label) (k : Csem.cont) (e : Csem.env) (m : mem) (s' : Csyntax.statement) (k' : Csem.cont) (H : Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) = Some (s', k')) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) : exists S2' : state,\n  (plus step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s' k' e m) <\n    measure (Csem.State f (Csyntax.Sgoto lbl) k e m))%nat) /\\\n  match_states (Csem.State f s' k' e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s' k' e m) <\n    measure (Csem.State f (Csyntax.Sgoto lbl) k e m))%nat) /\\\n  match_states (Csem.State f s' k' e m) S2'","hypotheses":"(f : Csyntax.function) (lbl : Csyntax.label) (k : Csem.cont) (e : Csem.env) (m : mem) (s' : Csyntax.statement) (k' : Csem.cont) (H : Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) = Some (s', k')) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk)","proofString":"inversion TRF; subst.\nexploit tr_find_label.\neauto.\neapply match_cont_call_cont; eauto.\ninstantiate (1 := lbl).\nrewrite H.\nintros [ts' [tk' [P [Q R]]]].\neconstructor; split.\nleft.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (lbl : Csyntax.label) (k : Csem.cont) (e : Csem.env) (m : mem) (s' : Csyntax.statement) (k' : Csem.cont) (H : Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) = Some (s', k')) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H0 : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f) (fn_body tf)) (H1 : fn_return tf = Csyntax.fn_return f) (H2 : fn_callconv tf = Csyntax.fn_callconv f) (H3 : fn_params tf = Csyntax.fn_params f) (H4 : fn_vars tf = Csyntax.fn_vars f) : exists S2' : state,\n  (plus step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s' k' e m) <\n    measure (Csem.State f (Csyntax.Sgoto lbl) k e m))%nat) /\\\n  match_states (Csem.State f s' k' e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s' k' e m) <\n    measure (Csem.State f (Csyntax.Sgoto lbl) k e m))%nat) /\\\n  match_states (Csem.State f s' k' e m) S2'","hypotheses":"(f : Csyntax.function) (lbl : Csyntax.label) (k : Csem.cont) (e : Csem.env) (m : mem) (s' : Csyntax.statement) (k' : Csem.cont) (H : Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) = Some (s', k')) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H0 : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f) (fn_body tf)) (H1 : fn_return tf = Csyntax.fn_return f) (H2 : fn_callconv tf = Csyntax.fn_callconv f) (H3 : fn_params tf = Csyntax.fn_params f) (H4 : fn_vars tf = Csyntax.fn_vars f)","proofString":"exploit tr_find_label.\neauto.\neapply match_cont_call_cont; eauto.\ninstantiate (1 := lbl).\nrewrite H.\nintros [ts' [tk' [P [Q R]]]].\neconstructor; split.\nleft.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (lbl : Csyntax.label) (k : Csem.cont) (e : Csem.env) (m : mem) (s' : Csyntax.statement) (k' : Csem.cont) (H : Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) = Some (s', k')) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H0 : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f) (fn_body tf)) (H1 : fn_return tf = Csyntax.fn_return f) (H2 : fn_callconv tf = Csyntax.fn_callconv f) (H3 : fn_params tf = Csyntax.fn_params f) (H4 : fn_vars tf = Csyntax.fn_vars f) : match Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) with\n| Some (s'0, k'0) =>\n    exists (ts' : statement) (tk' : cont),\n      find_label lbl (fn_body tf) (call_cont tk) = Some (ts', tk') /\\\n      tr_stmt (prog_comp_env cu) s'0 ts' /\\\n      match_cont (prog_comp_env cu) k'0 tk'\n| None => find_label lbl (fn_body tf) (call_cont tk) = None\nend ->\nexists S2' : state,\n  (plus step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s' k' e m) <\n    measure (Csem.State f (Csyntax.Sgoto lbl) k e m))%nat) /\\\n  match_states (Csem.State f s' k' e m) S2'.","conclusion":"match Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) with\n| Some (s'0, k'0) =>\n    exists (ts' : statement) (tk' : cont),\n      find_label lbl (fn_body tf) (call_cont tk) = Some (ts', tk') /\\\n      tr_stmt (prog_comp_env cu) s'0 ts' /\\\n      match_cont (prog_comp_env cu) k'0 tk'\n| None => find_label lbl (fn_body tf) (call_cont tk) = None\nend ->\nexists S2' : state,\n  (plus step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s' k' e m) <\n    measure (Csem.State f (Csyntax.Sgoto lbl) k e m))%nat) /\\\n  match_states (Csem.State f s' k' e m) S2'","hypotheses":"(f : Csyntax.function) (lbl : Csyntax.label) (k : Csem.cont) (e : Csem.env) (m : mem) (s' : Csyntax.statement) (k' : Csem.cont) (H : Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) = Some (s', k')) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H0 : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f) (fn_body tf)) (H1 : fn_return tf = Csyntax.fn_return f) (H2 : fn_callconv tf = Csyntax.fn_callconv f) (H3 : fn_params tf = Csyntax.fn_params f) (H4 : fn_vars tf = Csyntax.fn_vars f)","proofString":"rewrite H.\nintros [ts' [tk' [P [Q R]]]].\neconstructor; split.\nleft.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (lbl : Csyntax.label) (k : Csem.cont) (e : Csem.env) (m : mem) (s' : Csyntax.statement) (k' : Csem.cont) (H : Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) = Some (s', k')) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H0 : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f) (fn_body tf)) (H1 : fn_return tf = Csyntax.fn_return f) (H2 : fn_callconv tf = Csyntax.fn_callconv f) (H3 : fn_params tf = Csyntax.fn_params f) (H4 : fn_vars tf = Csyntax.fn_vars f) : (exists (ts' : statement) (tk' : cont),\n   find_label lbl (fn_body tf) (call_cont tk) = Some (ts', tk') /\\\n   tr_stmt (prog_comp_env cu) s' ts' /\\ match_cont (prog_comp_env cu) k' tk') ->\nexists S2' : state,\n  (plus step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s' k' e m) <\n    measure (Csem.State f (Csyntax.Sgoto lbl) k e m))%nat) /\\\n  match_states (Csem.State f s' k' e m) S2'.","conclusion":"(exists (ts' : statement) (tk' : cont),\n   find_label lbl (fn_body tf) (call_cont tk) = Some (ts', tk') /\\\n   tr_stmt (prog_comp_env cu) s' ts' /\\ match_cont (prog_comp_env cu) k' tk') ->\nexists S2' : state,\n  (plus step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s' k' e m) <\n    measure (Csem.State f (Csyntax.Sgoto lbl) k e m))%nat) /\\\n  match_states (Csem.State f s' k' e m) S2'","hypotheses":"(f : Csyntax.function) (lbl : Csyntax.label) (k : Csem.cont) (e : Csem.env) (m : mem) (s' : Csyntax.statement) (k' : Csem.cont) (H : Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) = Some (s', k')) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H0 : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f) (fn_body tf)) (H1 : fn_return tf = Csyntax.fn_return f) (H2 : fn_callconv tf = Csyntax.fn_callconv f) (H3 : fn_params tf = Csyntax.fn_params f) (H4 : fn_vars tf = Csyntax.fn_vars f)","proofString":"intros [ts' [tk' [P [Q R]]]].\neconstructor; split.\nleft.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (lbl : Csyntax.label) (k : Csem.cont) (e : Csem.env) (m : mem) (s' : Csyntax.statement) (k' : Csem.cont) (H : Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) = Some (s', k')) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H0 : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f) (fn_body tf)) (H1 : fn_return tf = Csyntax.fn_return f) (H2 : fn_callconv tf = Csyntax.fn_callconv f) (H3 : fn_params tf = Csyntax.fn_params f) (H4 : fn_vars tf = Csyntax.fn_vars f) (ts' : statement) (tk' : cont) (P : find_label lbl (fn_body tf) (call_cont tk) = Some (ts', tk')) (Q : tr_stmt (prog_comp_env cu) s' ts') (R : match_cont (prog_comp_env cu) k' tk') : exists S2' : state,\n  (plus step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s' k' e m) <\n    measure (Csem.State f (Csyntax.Sgoto lbl) k e m))%nat) /\\\n  match_states (Csem.State f s' k' e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' \\/\n   star step1 tge (State tf (Sgoto lbl) tk e le m) E0 S2' /\\\n   (measure (Csem.State f s' k' e m) <\n    measure (Csem.State f (Csyntax.Sgoto lbl) k e m))%nat) /\\\n  match_states (Csem.State f s' k' e m) S2'","hypotheses":"(f : Csyntax.function) (lbl : Csyntax.label) (k : Csem.cont) (e : Csem.env) (m : mem) (s' : Csyntax.statement) (k' : Csem.cont) (H : Csem.find_label lbl (Csyntax.fn_body f) (Csem.call_cont k) = Some (s', k')) (tf : function) (tk : cont) (le : temp_env) (cu : Csyntax.program) (LINK : linkorder cu prog) (TRF : tr_function (prog_comp_env cu) f tf) (MK : match_cont (prog_comp_env cu) k tk) (H0 : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f) (fn_body tf)) (H1 : fn_return tf = Csyntax.fn_return f) (H2 : fn_callconv tf = Csyntax.fn_callconv f) (H3 : fn_params tf = Csyntax.fn_params f) (H4 : fn_vars tf = Csyntax.fn_vars f) (ts' : statement) (tk' : cont) (P : find_label lbl (fn_body tf) (call_cont tk) = Some (ts', tk')) (Q : tr_stmt (prog_comp_env cu) s' ts') (R : match_cont (prog_comp_env cu) k' tk')","proofString":"econstructor; split.\nleft.\napply plus_one.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (vargs : list val) (k : Csem.cont) (m : mem) (e : Csem.env) (m1 m2 : mem) (H : list_norepet\n  (Csyntax.var_names (Csyntax.fn_params f) ++\n   Csyntax.var_names (Csyntax.fn_vars f))) (H0 : Csem.alloc_variables ge Csem.empty_env m\n  (Csyntax.fn_params f ++ Csyntax.fn_vars f) e m1) (H1 : Csem.bind_parameters ge e m1 (Csyntax.fn_params f) vargs m2) (tfd : fundef) (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (TR : tr_fundef cu (Internal f) tfd) (MK : forall ce : composite_env, match_cont ce k tk) : exists S2' : state,\n  (plus step1 tge (Callstate tfd vargs tk m) E0 S2' \\/\n   star step1 tge (Callstate tfd vargs tk m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.fn_body f) k e m2) <\n    measure (Csem.Callstate (Internal f) vargs k m))%nat) /\\\n  match_states (Csem.State f (Csyntax.fn_body f) k e m2) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (Callstate tfd vargs tk m) E0 S2' \\/\n   star step1 tge (Callstate tfd vargs tk m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.fn_body f) k e m2) <\n    measure (Csem.Callstate (Internal f) vargs k m))%nat) /\\\n  match_states (Csem.State f (Csyntax.fn_body f) k e m2) S2'","hypotheses":"(f : Csyntax.function) (vargs : list val) (k : Csem.cont) (m : mem) (e : Csem.env) (m1 m2 : mem) (H : list_norepet\n  (Csyntax.var_names (Csyntax.fn_params f) ++\n   Csyntax.var_names (Csyntax.fn_vars f))) (H0 : Csem.alloc_variables ge Csem.empty_env m\n  (Csyntax.fn_params f ++ Csyntax.fn_vars f) e m1) (H1 : Csem.bind_parameters ge e m1 (Csyntax.fn_params f) vargs m2) (tfd : fundef) (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (TR : tr_fundef cu (Internal f) tfd) (MK : forall ce : composite_env, match_cont ce k tk)","proofString":"inv TR.\ninversion H3; subst.\neconstructor; split.\nleft; apply plus_one.\neapply step_internal_function.\neconstructor.\nrewrite H6; rewrite H7; auto.\nrewrite H6; rewrite H7.\neapply alloc_variables_preserved; eauto.\nrewrite H6.\neapply bind_parameters_preserved; eauto.\neauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (vargs : list val) (k : Csem.cont) (m : mem) (e : Csem.env) (m1 m2 : mem) (H : list_norepet\n  (Csyntax.var_names (Csyntax.fn_params f) ++\n   Csyntax.var_names (Csyntax.fn_vars f))) (H0 : Csem.alloc_variables ge Csem.empty_env m\n  (Csyntax.fn_params f ++ Csyntax.fn_vars f) e m1) (H1 : Csem.bind_parameters ge e m1 (Csyntax.fn_params f) vargs m2) (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (MK : forall ce : composite_env, match_cont ce k tk) (tf : function) (H3 : tr_function (prog_comp_env cu) f tf) : exists S2' : state,\n  (plus step1 tge (Callstate (Internal tf) vargs tk m) E0 S2' \\/\n   star step1 tge (Callstate (Internal tf) vargs tk m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.fn_body f) k e m2) <\n    measure (Csem.Callstate (Internal f) vargs k m))%nat) /\\\n  match_states (Csem.State f (Csyntax.fn_body f) k e m2) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (Callstate (Internal tf) vargs tk m) E0 S2' \\/\n   star step1 tge (Callstate (Internal tf) vargs tk m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.fn_body f) k e m2) <\n    measure (Csem.Callstate (Internal f) vargs k m))%nat) /\\\n  match_states (Csem.State f (Csyntax.fn_body f) k e m2) S2'","hypotheses":"(f : Csyntax.function) (vargs : list val) (k : Csem.cont) (m : mem) (e : Csem.env) (m1 m2 : mem) (H : list_norepet\n  (Csyntax.var_names (Csyntax.fn_params f) ++\n   Csyntax.var_names (Csyntax.fn_vars f))) (H0 : Csem.alloc_variables ge Csem.empty_env m\n  (Csyntax.fn_params f ++ Csyntax.fn_vars f) e m1) (H1 : Csem.bind_parameters ge e m1 (Csyntax.fn_params f) vargs m2) (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (MK : forall ce : composite_env, match_cont ce k tk) (tf : function) (H3 : tr_function (prog_comp_env cu) f tf)","proofString":"inversion H3; subst.\neconstructor; split.\nleft; apply plus_one.\neapply step_internal_function.\neconstructor.\nrewrite H6; rewrite H7; auto.\nrewrite H6; rewrite H7.\neapply alloc_variables_preserved; eauto.\nrewrite H6.\neapply bind_parameters_preserved; eauto.\neauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (vargs : list val) (k : Csem.cont) (m : mem) (e : Csem.env) (m1 m2 : mem) (H : list_norepet\n  (Csyntax.var_names (Csyntax.fn_params f) ++\n   Csyntax.var_names (Csyntax.fn_vars f))) (H0 : Csem.alloc_variables ge Csem.empty_env m\n  (Csyntax.fn_params f ++ Csyntax.fn_vars f) e m1) (H1 : Csem.bind_parameters ge e m1 (Csyntax.fn_params f) vargs m2) (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (MK : forall ce : composite_env, match_cont ce k tk) (tf : function) (H3 : tr_function (prog_comp_env cu) f tf) (H2 : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f) (fn_body tf)) (H4 : fn_return tf = Csyntax.fn_return f) (H5 : fn_callconv tf = Csyntax.fn_callconv f) (H6 : fn_params tf = Csyntax.fn_params f) (H7 : fn_vars tf = Csyntax.fn_vars f) : exists S2' : state,\n  (plus step1 tge (Callstate (Internal tf) vargs tk m) E0 S2' \\/\n   star step1 tge (Callstate (Internal tf) vargs tk m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.fn_body f) k e m2) <\n    measure (Csem.Callstate (Internal f) vargs k m))%nat) /\\\n  match_states (Csem.State f (Csyntax.fn_body f) k e m2) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (Callstate (Internal tf) vargs tk m) E0 S2' \\/\n   star step1 tge (Callstate (Internal tf) vargs tk m) E0 S2' /\\\n   (measure (Csem.State f (Csyntax.fn_body f) k e m2) <\n    measure (Csem.Callstate (Internal f) vargs k m))%nat) /\\\n  match_states (Csem.State f (Csyntax.fn_body f) k e m2) S2'","hypotheses":"(f : Csyntax.function) (vargs : list val) (k : Csem.cont) (m : mem) (e : Csem.env) (m1 m2 : mem) (H : list_norepet\n  (Csyntax.var_names (Csyntax.fn_params f) ++\n   Csyntax.var_names (Csyntax.fn_vars f))) (H0 : Csem.alloc_variables ge Csem.empty_env m\n  (Csyntax.fn_params f ++ Csyntax.fn_vars f) e m1) (H1 : Csem.bind_parameters ge e m1 (Csyntax.fn_params f) vargs m2) (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (MK : forall ce : composite_env, match_cont ce k tk) (tf : function) (H3 : tr_function (prog_comp_env cu) f tf) (H2 : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f) (fn_body tf)) (H4 : fn_return tf = Csyntax.fn_return f) (H5 : fn_callconv tf = Csyntax.fn_callconv f) (H6 : fn_params tf = Csyntax.fn_params f) (H7 : fn_vars tf = Csyntax.fn_vars f)","proofString":"econstructor; split.\nleft; apply plus_one.\neapply step_internal_function.\neconstructor.\nrewrite H6; rewrite H7; auto.\nrewrite H6; rewrite H7.\neapply alloc_variables_preserved; eauto.\nrewrite H6.\neapply bind_parameters_preserved; eauto.\neauto.\neconstructor; eauto."},{"statement":"(f : Csyntax.function) (vargs : list val) (k : Csem.cont) (m : mem) (e : Csem.env) (m1 m2 : mem) (H : list_norepet\n  (Csyntax.var_names (Csyntax.fn_params f) ++\n   Csyntax.var_names (Csyntax.fn_vars f))) (H0 : Csem.alloc_variables ge Csem.empty_env m\n  (Csyntax.fn_params f ++ Csyntax.fn_vars f) e m1) (H1 : Csem.bind_parameters ge e m1 (Csyntax.fn_params f) vargs m2) (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (MK : forall ce : composite_env, match_cont ce k tk) (tf : function) (H3 : tr_function (prog_comp_env cu) f tf) (H2 : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f) (fn_body tf)) (H4 : fn_return tf = Csyntax.fn_return f) (H5 : fn_callconv tf = Csyntax.fn_callconv f) (H6 : fn_params tf = Csyntax.fn_params f) (H7 : fn_vars tf = Csyntax.fn_vars f) : list_norepet (var_names (fn_params tf) ++ var_names (fn_vars tf)).","conclusion":"list_norepet (var_names (fn_params tf) ++ var_names (fn_vars tf))","hypotheses":"(f : Csyntax.function) (vargs : list val) (k : Csem.cont) (m : mem) (e : Csem.env) (m1 m2 : mem) (H : list_norepet\n  (Csyntax.var_names (Csyntax.fn_params f) ++\n   Csyntax.var_names (Csyntax.fn_vars f))) (H0 : Csem.alloc_variables ge Csem.empty_env m\n  (Csyntax.fn_params f ++ Csyntax.fn_vars f) e m1) (H1 : Csem.bind_parameters ge e m1 (Csyntax.fn_params f) vargs m2) (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (MK : forall ce : composite_env, match_cont ce k tk) (tf : function) (H3 : tr_function (prog_comp_env cu) f tf) (H2 : tr_stmt (prog_comp_env cu) (Csyntax.fn_body f) (fn_body tf)) (H4 : fn_return tf = Csyntax.fn_return f) (H5 : fn_callconv tf = Csyntax.fn_callconv f) (H6 : fn_params tf = Csyntax.fn_params f) (H7 : fn_vars tf = Csyntax.fn_vars f)","proofString":"rewrite H6; rewrite H7; auto."},{"statement":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : Csem.cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tfd : fundef) (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (TR : tr_fundef cu (External ef targs tres cc) tfd) (MK : forall ce : composite_env, match_cont ce k tk) : exists S2' : state,\n  (plus step1 tge (Callstate tfd vargs tk m) t S2' \\/\n   star step1 tge (Callstate tfd vargs tk m) t S2' /\\\n   (measure (Csem.Returnstate vres k m') <\n    measure (Csem.Callstate (External ef targs tres cc) vargs k m))%nat) /\\\n  match_states (Csem.Returnstate vres k m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (Callstate tfd vargs tk m) t S2' \\/\n   star step1 tge (Callstate tfd vargs tk m) t S2' /\\\n   (measure (Csem.Returnstate vres k m') <\n    measure (Csem.Callstate (External ef targs tres cc) vargs k m))%nat) /\\\n  match_states (Csem.Returnstate vres k m') S2'","hypotheses":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : Csem.cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tfd : fundef) (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (TR : tr_fundef cu (External ef targs tres cc) tfd) (MK : forall ce : composite_env, match_cont ce k tk)","proofString":"inv TR.\neconstructor; split.\nleft; apply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : Csem.cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (MK : forall ce : composite_env, match_cont ce k tk) : exists S2' : state,\n  (plus step1 tge (Callstate (External ef targs tres cc) vargs tk m) t S2' \\/\n   star step1 tge (Callstate (External ef targs tres cc) vargs tk m) t S2' /\\\n   (measure (Csem.Returnstate vres k m') <\n    measure (Csem.Callstate (External ef targs tres cc) vargs k m))%nat) /\\\n  match_states (Csem.Returnstate vres k m') S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (Callstate (External ef targs tres cc) vargs tk m) t S2' \\/\n   star step1 tge (Callstate (External ef targs tres cc) vargs tk m) t S2' /\\\n   (measure (Csem.Returnstate vres k m') <\n    measure (Csem.Callstate (External ef targs tres cc) vargs k m))%nat) /\\\n  match_states (Csem.Returnstate vres k m') S2'","hypotheses":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : Csem.cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (MK : forall ce : composite_env, match_cont ce k tk)","proofString":"econstructor; split.\nleft; apply plus_one.\neconstructor; eauto.\neapply external_call_symbols_preserved; eauto.\napply senv_preserved.\neconstructor; eauto."},{"statement":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : Csem.cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (MK : forall ce : composite_env, match_cont ce k tk) : Senv.equiv ge tge.","conclusion":"Senv.equiv ge tge","hypotheses":"(ef : external_function) (targs : list type) (tres : type) (cc : calling_convention) (vargs : list val) (k : Csem.cont) (m : mem) (vres : val) (t : trace) (m' : mem) (H : external_call ef ge vargs m t vres m') (tk : cont) (cu : Csyntax.program) (LINK : linkorder cu prog) (MK : forall ce : composite_env, match_cont ce k tk)","proofString":"apply senv_preserved."},{"statement":"(v : val) (f : Csyntax.function) (e : Csem.env) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (k : Csem.cont) (m : mem) (tk : cont) (MK : forall ce : composite_env, match_cont ce (Csem.Kcall f e C ty k) tk) : exists S2' : state,\n  (plus step1 tge (Returnstate v tk m) E0 S2' \\/\n   star step1 tge (Returnstate v tk m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (Csem.Returnstate v (Csem.Kcall f e C ty k) m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (Returnstate v tk m) E0 S2' \\/\n   star step1 tge (Returnstate v tk m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (Csem.Returnstate v (Csem.Kcall f e C ty k) m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(v : val) (f : Csyntax.function) (e : Csem.env) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (k : Csem.cont) (m : mem) (tk : cont) (MK : forall ce : composite_env, match_cont ce (Csem.Kcall f e C ty k) tk)","proofString":"specialize (MK (PTree.empty _)).\ninv MK.\neconstructor; split.\nleft; apply plus_one.\nconstructor.\neconstructor; eauto."},{"statement":"(v : val) (f : Csyntax.function) (e : Csem.env) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (k : Csem.cont) (m : mem) (tk : cont) (MK : match_cont (PTree.empty composite) (Csem.Kcall f e C ty k) tk) : exists S2' : state,\n  (plus step1 tge (Returnstate v tk m) E0 S2' \\/\n   star step1 tge (Returnstate v tk m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (Csem.Returnstate v (Csem.Kcall f e C ty k) m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (Returnstate v tk m) E0 S2' \\/\n   star step1 tge (Returnstate v tk m) E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (Csem.Returnstate v (Csem.Kcall f e C ty k) m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(v : val) (f : Csyntax.function) (e : Csem.env) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (k : Csem.cont) (m : mem) (tk : cont) (MK : match_cont (PTree.empty composite) (Csem.Kcall f e C ty k) tk)","proofString":"inv MK.\neconstructor; split.\nleft; apply plus_one.\nconstructor.\neconstructor; eauto."},{"statement":"(v : val) (f : Csyntax.function) (e : Csem.env) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (k : Csem.cont) (m : mem) (optid : option ident) (tf : function) (le : temp_env) (sl : list statement) (tk0 : cont) (a : expr) (dest : destination) (tmps : list ident) (cu : Csyntax.program) (H5 : linkorder cu prog) (H7 : tr_function (prog_comp_env cu) f tf) (H8 : leftcontext RV RV C) (H9 : forall (v0 : val) (m0 : mem),\ntr_top (prog_comp_env cu) tge e (set_opttemp optid v0 le) m0 dest\n  (C (Eval v0 ty)) sl a tmps) (H10 : match_cont_exp (prog_comp_env cu) dest a k tk0) : exists S2' : state,\n  (plus step1 tge (Returnstate v (Kcall optid tf e le (Kseqlist sl tk0)) m)\n     E0 S2' \\/\n   star step1 tge (Returnstate v (Kcall optid tf e le (Kseqlist sl tk0)) m)\n     E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (Csem.Returnstate v (Csem.Kcall f e C ty k) m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'.","conclusion":"exists S2' : state,\n  (plus step1 tge (Returnstate v (Kcall optid tf e le (Kseqlist sl tk0)) m)\n     E0 S2' \\/\n   star step1 tge (Returnstate v (Kcall optid tf e le (Kseqlist sl tk0)) m)\n     E0 S2' /\\\n   (measure (ExprState f (C (Eval v ty)) k e m) <\n    measure (Csem.Returnstate v (Csem.Kcall f e C ty k) m))%nat) /\\\n  match_states (ExprState f (C (Eval v ty)) k e m) S2'","hypotheses":"(v : val) (f : Csyntax.function) (e : Csem.env) (C : Csyntax.expr -> Csyntax.expr) (ty : type) (k : Csem.cont) (m : mem) (optid : option ident) (tf : function) (le : temp_env) (sl : list statement) (tk0 : cont) (a : expr) (dest : destination) (tmps : list ident) (cu : Csyntax.program) (H5 : linkorder cu prog) (H7 : tr_function (prog_comp_env cu) f tf) (H8 : leftcontext RV RV C) (H9 : forall (v0 : val) (m0 : mem),\ntr_top (prog_comp_env cu) tge e (set_opttemp optid v0 le) m0 dest\n  (C (Eval v0 ty)) sl a tmps) (H10 : match_cont_exp (prog_comp_env cu) dest a k tk0)","proofString":"econstructor; split.\nleft; apply plus_one.\nconstructor.\neconstructor; eauto."},{"statement":"(S1 : Csem.state) (t : trace) (S2 : Csem.state) (STEP : Cstrategy.step ge S1 t S2) : forall S1' : state,\nmatch_states S1 S1' ->\nexists S2' : state,\n  (plus step1 tge S1' t S2' \\/\n   star step1 tge S1' t S2' /\\ (measure S2 < measure S1)%nat) /\\\n  match_states S2 S2'.","conclusion":"forall S1' : state,\nmatch_states S1 S1' ->\nexists S2' : state,\n  (plus step1 tge S1' t S2' \\/\n   star step1 tge S1' t S2' /\\ (measure S2 < measure S1)%nat) /\\\n  match_states S2 S2'","hypotheses":"(S1 : Csem.state) (t : trace) (S2 : Csem.state) (STEP : Cstrategy.step ge S1 t S2)","proofString":"destruct STEP.\napply estep_simulation; auto.\napply sstep_simulation; auto."},{"statement":"(S1 : Csem.state) (t : trace) (S2 : Csem.state) (H : estep ge S1 t S2) : forall S1' : state,\nmatch_states S1 S1' ->\nexists S2' : state,\n  (plus step1 tge S1' t S2' \\/\n   star step1 tge S1' t S2' /\\ (measure S2 < measure S1)%nat) /\\\n  match_states S2 S2'.","conclusion":"forall S1' : state,\nmatch_states S1 S1' ->\nexists S2' : state,\n  (plus step1 tge S1' t S2' \\/\n   star step1 tge S1' t S2' /\\ (measure S2 < measure S1)%nat) /\\\n  match_states S2 S2'","hypotheses":"(S1 : Csem.state) (t : trace) (S2 : Csem.state) (H : estep ge S1 t S2)","proofString":"apply estep_simulation; auto."},{"statement":"(S1 : Csem.state) (t : trace) (S2 : Csem.state) (H : sstep ge S1 t S2) : forall S1' : state,\nmatch_states S1 S1' ->\nexists S2' : state,\n  (plus step1 tge S1' t S2' \\/\n   star step1 tge S1' t S2' /\\ (measure S2 < measure S1)%nat) /\\\n  match_states S2 S2'.","conclusion":"forall S1' : state,\nmatch_states S1 S1' ->\nexists S2' : state,\n  (plus step1 tge S1' t S2' \\/\n   star step1 tge S1' t S2' /\\ (measure S2 < measure S1)%nat) /\\\n  match_states S2 S2'","hypotheses":"(S1 : Csem.state) (t : trace) (S2 : Csem.state) (H : sstep ge S1 t S2)","proofString":"apply sstep_simulation; auto."},{"statement":"(S : Csem.state) (H : Csem.initial_state prog S) : exists S' : state, initial_state tprog S' /\\ match_states S S'.","conclusion":"exists S' : state, initial_state tprog S' /\\ match_states S S'","hypotheses":"(S : Csem.state) (H : Csem.initial_state prog S)","proofString":"inv H.\nexploit function_ptr_translated; eauto.\nintros (cu & tf & FIND & TR & L).\neconstructor; split.\neconstructor.\neapply (Genv.init_mem_match (proj1 TRANSL)); eauto.\nreplace (prog_main tprog) with (prog_main prog).\nrewrite symbols_preserved.\neauto.\ndestruct TRANSL.\ndestruct H as (A & B & C).\nsimpl in B.\nauto.\neexact FIND.\nrewrite <- H3.\neapply type_of_fundef_preserved; eauto.\neconstructor; eauto.\nintros; constructor."},{"statement":"(b : block) (f : Csyntax.fundef) (m0 : mem) (ge0 : Csem.genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Csyntax.type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Csyntax.program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : tr_fundef cu f tf) (L : linkorder cu prog) : prog_main prog = prog_main tprog.","conclusion":"prog_main prog = prog_main tprog","hypotheses":"(b : block) (f : Csyntax.fundef) (m0 : mem) (ge0 : Csem.genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Csyntax.type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Csyntax.program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : tr_fundef cu f tf) (L : linkorder cu prog)","proofString":"destruct TRANSL.\ndestruct H as (A & B & C).\nsimpl in B.\nauto."},{"statement":"(b : block) (f : Csyntax.fundef) (m0 : mem) (ge0 : Csem.genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Csyntax.type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Csyntax.program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : tr_fundef cu f tf) (L : linkorder cu prog) (H : match_program_gen tr_fundef eq prog prog tprog) (H4 : prog_types tprog = prog_types prog) : prog_main prog = prog_main tprog.","conclusion":"prog_main prog = prog_main tprog","hypotheses":"(b : block) (f : Csyntax.fundef) (m0 : mem) (ge0 : Csem.genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Csyntax.type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Csyntax.program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : tr_fundef cu f tf) (L : linkorder cu prog) (H : match_program_gen tr_fundef eq prog prog tprog) (H4 : prog_types tprog = prog_types prog)","proofString":"destruct H as (A & B & C).\nsimpl in B.\nauto."},{"statement":"(b : block) (f : Csyntax.fundef) (m0 : mem) (ge0 : Csem.genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Csyntax.type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Csyntax.program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : tr_fundef cu f tf) (L : linkorder cu prog) (A : list_forall2 (match_ident_globdef tr_fundef eq prog) \n  (AST.prog_defs prog) (AST.prog_defs tprog)) (B : AST.prog_main tprog = AST.prog_main prog) (C : AST.prog_public tprog = AST.prog_public prog) (H4 : prog_types tprog = prog_types prog) : prog_main prog = prog_main tprog.","conclusion":"prog_main prog = prog_main tprog","hypotheses":"(b : block) (f : Csyntax.fundef) (m0 : mem) (ge0 : Csem.genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Csyntax.type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Csyntax.program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : tr_fundef cu f tf) (L : linkorder cu prog) (A : list_forall2 (match_ident_globdef tr_fundef eq prog) \n  (AST.prog_defs prog) (AST.prog_defs tprog)) (B : AST.prog_main tprog = AST.prog_main prog) (C : AST.prog_public tprog = AST.prog_public prog) (H4 : prog_types tprog = prog_types prog)","proofString":"simpl in B.\nauto."},{"statement":"(b : block) (f : Csyntax.fundef) (m0 : mem) (ge0 : Csem.genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Csyntax.type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Csyntax.program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : tr_fundef cu f tf) (L : linkorder cu prog) (A : list_forall2 (match_ident_globdef tr_fundef eq prog) \n  (AST.prog_defs prog) (AST.prog_defs tprog)) (B : prog_main tprog = prog_main prog) (C : AST.prog_public tprog = AST.prog_public prog) (H4 : prog_types tprog = prog_types prog) : prog_main prog = prog_main tprog.","conclusion":"prog_main prog = prog_main tprog","hypotheses":"(b : block) (f : Csyntax.fundef) (m0 : mem) (ge0 : Csem.genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Csyntax.type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Csyntax.program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : tr_fundef cu f tf) (L : linkorder cu prog) (A : list_forall2 (match_ident_globdef tr_fundef eq prog) \n  (AST.prog_defs prog) (AST.prog_defs tprog)) (B : prog_main tprog = prog_main prog) (C : AST.prog_public tprog = AST.prog_public prog) (H4 : prog_types tprog = prog_types prog)","proofString":"auto."},{"statement":"(b : block) (f : Csyntax.fundef) (m0 : mem) (ge0 : Csem.genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Csyntax.type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Csyntax.program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : tr_fundef cu f tf) (L : linkorder cu prog) : type_of_fundef tf = Csyntax.type_of_fundef f.","conclusion":"type_of_fundef tf = Csyntax.type_of_fundef f","hypotheses":"(b : block) (f : Csyntax.fundef) (m0 : mem) (ge0 : Csem.genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Csyntax.type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Csyntax.program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : tr_fundef cu f tf) (L : linkorder cu prog)","proofString":"eapply type_of_fundef_preserved; eauto."},{"statement":"(b : block) (f : Csyntax.fundef) (m0 : mem) (ge0 : Csem.genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Csyntax.type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Csyntax.program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : tr_fundef cu f tf) (L : linkorder cu prog) : forall ce : composite_env, match_cont ce Csem.Kstop Kstop.","conclusion":"forall ce : composite_env, match_cont ce Csem.Kstop Kstop","hypotheses":"(b : block) (f : Csyntax.fundef) (m0 : mem) (ge0 : Csem.genv) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : Csyntax.type_of_fundef f = Tfunction nil type_int32s cc_default) (cu : Csyntax.program) (tf : fundef) (FIND : Genv.find_funct_ptr tge b = Some tf) (TR : tr_fundef cu f tf) (L : linkorder cu prog)","proofString":"intros; constructor."},{"statement":"(S : Csem.state) (S' : state) (r : int) (H : match_states S S') (H0 : Csem.final_state S r) : final_state S' r.","conclusion":"final_state S' r","hypotheses":"(S : Csem.state) (S' : state) (r : int) (H : match_states S S') (H0 : Csem.final_state S r)","proofString":"inv H0.\ninv H.\nspecialize (MK (PTree.empty _)).\ninv MK.\nconstructor."},{"statement":"(S' : state) (r : int) (m : mem) (H : match_states (Csem.Returnstate (Vint r) Csem.Kstop m) S') : final_state S' r.","conclusion":"final_state S' r","hypotheses":"(S' : state) (r : int) (m : mem) (H : match_states (Csem.Returnstate (Vint r) Csem.Kstop m) S')","proofString":"inv H.\nspecialize (MK (PTree.empty _)).\ninv MK.\nconstructor."},{"statement":"(r : int) (m : mem) (tk : cont) (MK : forall ce : composite_env, match_cont ce Csem.Kstop tk) : final_state (Returnstate (Vint r) tk m) r.","conclusion":"final_state (Returnstate (Vint r) tk m) r","hypotheses":"(r : int) (m : mem) (tk : cont) (MK : forall ce : composite_env, match_cont ce Csem.Kstop tk)","proofString":"specialize (MK (PTree.empty _)).\ninv MK.\nconstructor."},{"statement":"(r : int) (m : mem) (tk : cont) (MK : match_cont (PTree.empty composite) Csem.Kstop tk) : final_state (Returnstate (Vint r) tk m) r.","conclusion":"final_state (Returnstate (Vint r) tk m) r","hypotheses":"(r : int) (m : mem) (tk : cont) (MK : match_cont (PTree.empty composite) Csem.Kstop tk)","proofString":"inv MK.\nconstructor."},{"statement":"(r : int) (m : mem) : final_state (Returnstate (Vint r) Kstop m) r.","conclusion":"final_state (Returnstate (Vint r) Kstop m) r","hypotheses":"(r : int) (m : mem)","proofString":"constructor."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics1 tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id.","conclusion":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics1 tprog)) id =\nSenv.public_symbol (symbolenv (semantics prog)) id","hypotheses":"","proofString":"eapply senv_preserved."},{"statement":"well_founded (ltof Csem.state measure).","conclusion":"well_founded (ltof Csem.state measure)","hypotheses":"","proofString":"apply well_founded_ltof."}]}