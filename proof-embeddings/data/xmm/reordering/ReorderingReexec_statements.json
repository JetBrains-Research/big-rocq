{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/xmm/src/reordering/ReorderingReexec.v","fileSamples":[{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : extra_d ⊆₁ E_s.","proofString":"unfold extra_d.\ndesf.\ntransitivity (mapper ↑₁ E_t);    [| rewrite (rsr_acts SIMREL); basic_solver].\nrewrite <- (WCore.reexec_embd_acts (WCore.reexec_embd_corr GREEXEC)).\nassert (INA : E_t' a_t).\nnow apply (WCore.reexec_embd_dom GREEXEC).\nassert (NEQ : a_t <> b_t) by apply INV.\narewrite (    eq a_s ≡₁ mapper ↑₁ (f_t ↑₁ eq a_t)  ).\nrewrite set_collect_eq, RCFAT; [| desf].\nrewrite set_collect_eq, rsr_mapper_at; auto.\ndo 2 (apply set_collect_mori; auto).\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : (ifP ~ cmt_t b_t /\\\n     cmt_t a_t /\\\n     ~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t\n then eq a_s else ∅) ⊆₁ E_s.","proofString":"desf.\ntransitivity (mapper ↑₁ E_t);    [| rewrite (rsr_acts SIMREL); basic_solver].\nrewrite <- (WCore.reexec_embd_acts (WCore.reexec_embd_corr GREEXEC)).\nassert (INA : E_t' a_t).\nnow apply (WCore.reexec_embd_dom GREEXEC).\nassert (NEQ : a_t <> b_t) by apply INV.\narewrite (    eq a_s ≡₁ mapper ↑₁ (f_t ↑₁ eq a_t)  ).\nrewrite set_collect_eq, RCFAT; [| desf].\nrewrite set_collect_eq, rsr_mapper_at; auto.\ndo 2 (apply set_collect_mori; auto).\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) : eq a_s ⊆₁ E_s.","proofString":"transitivity (mapper ↑₁ E_t);    [| rewrite (rsr_acts SIMREL); basic_solver].\nrewrite <- (WCore.reexec_embd_acts (WCore.reexec_embd_corr GREEXEC)).\nassert (INA : E_t' a_t).\nnow apply (WCore.reexec_embd_dom GREEXEC).\nassert (NEQ : a_t <> b_t) by apply INV.\narewrite (    eq a_s ≡₁ mapper ↑₁ (f_t ↑₁ eq a_t)  ).\nrewrite set_collect_eq, RCFAT; [| desf].\nrewrite set_collect_eq, rsr_mapper_at; auto.\ndo 2 (apply set_collect_mori; auto).\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) : eq a_s ⊆₁ mapper ↑₁ E_t.","proofString":"rewrite <- (WCore.reexec_embd_acts (WCore.reexec_embd_corr GREEXEC)).\nassert (INA : E_t' a_t).\nnow apply (WCore.reexec_embd_dom GREEXEC).\nassert (NEQ : a_t <> b_t) by apply INV.\narewrite (    eq a_s ≡₁ mapper ↑₁ (f_t ↑₁ eq a_t)  ).\nrewrite set_collect_eq, RCFAT; [| desf].\nrewrite set_collect_eq, rsr_mapper_at; auto.\ndo 2 (apply set_collect_mori; auto).\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) : eq a_s ⊆₁ mapper ↑₁ (f_t ↑₁ cmt_t).","proofString":"assert (INA : E_t' a_t).\nnow apply (WCore.reexec_embd_dom GREEXEC).\nassert (NEQ : a_t <> b_t) by apply INV.\narewrite (    eq a_s ≡₁ mapper ↑₁ (f_t ↑₁ eq a_t)  ).\nrewrite set_collect_eq, RCFAT; [| desf].\nrewrite set_collect_eq, rsr_mapper_at; auto.\ndo 2 (apply set_collect_mori; auto).\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) : E_t' a_t.","proofString":"now apply (WCore.reexec_embd_dom GREEXEC)."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) (INA : E_t' a_t) : eq a_s ⊆₁ mapper ↑₁ (f_t ↑₁ cmt_t).","proofString":"assert (NEQ : a_t <> b_t) by apply INV.\narewrite (    eq a_s ≡₁ mapper ↑₁ (f_t ↑₁ eq a_t)  ).\nrewrite set_collect_eq, RCFAT; [| desf].\nrewrite set_collect_eq, rsr_mapper_at; auto.\ndo 2 (apply set_collect_mori; auto).\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) (INA : E_t' a_t) (NEQ : a_t <> b_t) : eq a_s ⊆₁ mapper ↑₁ (f_t ↑₁ cmt_t).","proofString":"arewrite (    eq a_s ≡₁ mapper ↑₁ (f_t ↑₁ eq a_t)  ).\nrewrite set_collect_eq, RCFAT; [| desf].\nrewrite set_collect_eq, rsr_mapper_at; auto.\ndo 2 (apply set_collect_mori; auto).\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) (INA : E_t' a_t) (NEQ : a_t <> b_t) : eq a_s ≡₁ mapper ↑₁ (f_t ↑₁ eq a_t).","proofString":"rewrite set_collect_eq, RCFAT; [| desf].\nrewrite set_collect_eq, rsr_mapper_at; auto."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) (INA : E_t' a_t) (NEQ : a_t <> b_t) : eq a_s ≡₁ mapper ↑₁ eq a_t.","proofString":"rewrite set_collect_eq, rsr_mapper_at; auto."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) (INA : E_t' a_t) (NEQ : a_t <> b_t) : mapper ↑₁ (f_t ↑₁ eq a_t) ⊆₁ mapper ↑₁ (f_t ↑₁ cmt_t).","proofString":"do 2 (apply set_collect_mori; auto).\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) (INA : E_t' a_t) (NEQ : a_t <> b_t) : eq a_t ⊆₁ cmt_t.","proofString":"basic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : mapper ↑₁ (dtrmt_t \\₁ extra_b) ∪₁ extra_d ⊆₁ E_s.","proofString":"arewrite (dtrmt_t \\₁ extra_b ⊆₁ dtrmt_t).\nbasic_solver.\nrewrite extra_d_in_E_s, (rexec_dtrmt_in_start GREEXEC); eauto.\napply set_subset_union_l; split; [| reflexivity].\nrewrite (rsr_acts SIMREL); basic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : dtrmt_t \\₁ extra_b ⊆₁ dtrmt_t.","proofString":"basic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : mapper ↑₁ dtrmt_t ∪₁ extra_d ⊆₁ E_s.","proofString":"rewrite extra_d_in_E_s, (rexec_dtrmt_in_start GREEXEC); eauto.\napply set_subset_union_l; split; [| reflexivity].\nrewrite (rsr_acts SIMREL); basic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : mapper ↑₁ E_t ∪₁ E_s ⊆₁ E_s.","proofString":"apply set_subset_union_l; split; [| reflexivity].\nrewrite (rsr_acts SIMREL); basic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : mapper ↑₁ E_t ⊆₁ E_s.","proofString":"rewrite (rsr_acts SIMREL); basic_solver."},{"statement":"(ifP ~ cmt_t b_t /\\\n     cmt_t a_t /\\\n     ~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t\n then eq b_t else ∅) ⊆₁ mapper ↑₁ cmt_t.","proofString":"desf.\nunfolder.\nintros x XEQ.\nsubst x.\nexists a_t.\nsplit; [desf |].\napply rsr_mapper_at, INV."},{"statement":"(a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) : eq b_t ⊆₁ mapper ↑₁ cmt_t.","proofString":"unfolder.\nintros x XEQ.\nsubst x.\nexists a_t.\nsplit; [desf |].\napply rsr_mapper_at, INV."},{"statement":"(a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) : forall x : actid, b_t = x -> exists y : actid, cmt_t y /\\ mapper y = x.","proofString":"intros x XEQ.\nsubst x.\nexists a_t.\nsplit; [desf |].\napply rsr_mapper_at, INV."},{"statement":"(a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) (x : actid) (XEQ : b_t = x) : exists y : actid, cmt_t y /\\ mapper y = x.","proofString":"subst x.\nexists a_t.\nsplit; [desf |].\napply rsr_mapper_at, INV."},{"statement":"(a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) : exists y : actid, cmt_t y /\\ mapper y = b_t.","proofString":"exists a_t.\nsplit; [desf |].\napply rsr_mapper_at, INV."},{"statement":"(a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) : cmt_t a_t /\\ mapper a_t = b_t.","proofString":"split; [desf |].\napply rsr_mapper_at, INV."},{"statement":"(a : ~ cmt_t b_t /\\\ncmt_t a_t /\\\n~ dtrmt_t a_t /\\ dom_rel (immediate (nin_sb G_t') ⨾ ⦗eq b_t⦘) ⊆₁ dtrmt_t) : mapper a_t = b_t.","proofString":"apply rsr_mapper_at, INV."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : A_s ⊆₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t ∪₁ tid ↓₁ (tid ↑₁ A_s').","proofString":"assert (TEQ : tid a_t = tid b_t) by apply INV.\nunfold extra_a at 1; desf.\nassert (NDA : ~ dtrmt_t a_t).\nintro FALSO.\nenough (E_t a_t) by desf.\neapply rexec_dtrmt_in_start; eauto.\ndestruct classic with (dtrmt_t b_t) as [DB|NDB].\nunfold extra_a; desf; [basic_solver |].\nassert (INB : E_t' b_t).\neapply rexec_dtrmt_in_fin; eauto.\nassert (INA : E_t' a_t) by tauto.\napply set_subset_union_r.\nleft.\nunfold WCore.reexec_thread.\nbasic_solver.\nassert (INB : E_t b_t) by desf.\napply (WCore.rexec_acts GREEXEC) in INB.\ndestruct INB as [DB | [_ OK]]; basic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) : A_s ⊆₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t ∪₁ tid ↓₁ (tid ↑₁ A_s').","proofString":"unfold extra_a at 1; desf.\nassert (NDA : ~ dtrmt_t a_t).\nintro FALSO.\nenough (E_t a_t) by desf.\neapply rexec_dtrmt_in_start; eauto.\ndestruct classic with (dtrmt_t b_t) as [DB|NDB].\nunfold extra_a; desf; [basic_solver |].\nassert (INB : E_t' b_t).\neapply rexec_dtrmt_in_fin; eauto.\nassert (INA : E_t' a_t) by tauto.\napply set_subset_union_r.\nleft.\nunfold WCore.reexec_thread.\nbasic_solver.\nassert (INB : E_t b_t) by desf.\napply (WCore.rexec_acts GREEXEC) in INB.\ndestruct INB as [DB | [_ OK]]; basic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t /\\ E_t b_t) : eq b_t ⊆₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t ∪₁ tid ↓₁ (tid ↑₁ A_s').","proofString":"assert (NDA : ~ dtrmt_t a_t).\nintro FALSO.\nenough (E_t a_t) by desf.\neapply rexec_dtrmt_in_start; eauto.\ndestruct classic with (dtrmt_t b_t) as [DB|NDB].\nunfold extra_a; desf; [basic_solver |].\nassert (INB : E_t' b_t).\neapply rexec_dtrmt_in_fin; eauto.\nassert (INA : E_t' a_t) by tauto.\napply set_subset_union_r.\nleft.\nunfold WCore.reexec_thread.\nbasic_solver.\nassert (INB : E_t b_t) by desf.\napply (WCore.rexec_acts GREEXEC) in INB.\ndestruct INB as [DB | [_ OK]]; basic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t /\\ E_t b_t) : ~ dtrmt_t a_t.","proofString":"intro FALSO.\nenough (E_t a_t) by desf.\neapply rexec_dtrmt_in_start; eauto."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t /\\ E_t b_t) (FALSO : dtrmt_t a_t) : False.","proofString":"enough (E_t a_t) by desf.\neapply rexec_dtrmt_in_start; eauto."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t /\\ E_t b_t) (FALSO : dtrmt_t a_t) : E_t a_t.","proofString":"eapply rexec_dtrmt_in_start; eauto."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t /\\ E_t b_t) (NDA : ~ dtrmt_t a_t) : eq b_t ⊆₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t ∪₁ tid ↓₁ (tid ↑₁ A_s').","proofString":"destruct classic with (dtrmt_t b_t) as [DB|NDB].\nunfold extra_a; desf; [basic_solver |].\nassert (INB : E_t' b_t).\neapply rexec_dtrmt_in_fin; eauto.\nassert (INA : E_t' a_t) by tauto.\napply set_subset_union_r.\nleft.\nunfold WCore.reexec_thread.\nbasic_solver.\nassert (INB : E_t b_t) by desf.\napply (WCore.rexec_acts GREEXEC) in INB.\ndestruct INB as [DB | [_ OK]]; basic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t /\\ E_t b_t) (NDA : ~ dtrmt_t a_t) (DB : dtrmt_t b_t) : eq b_t ⊆₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t ∪₁ tid ↓₁ (tid ↑₁ A_s').","proofString":"unfold extra_a; desf; [basic_solver |].\nassert (INB : E_t' b_t).\neapply rexec_dtrmt_in_fin; eauto.\nassert (INA : E_t' a_t) by tauto.\napply set_subset_union_r.\nleft.\nunfold WCore.reexec_thread.\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t) (a0 : E_t b_t) (NDA : ~ dtrmt_t a_t) (DB : dtrmt_t b_t) (n : ~ (~ E_t' a_t /\\ E_t' b_t)) : eq b_t ⊆₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t ∪₁ tid ↓₁ (tid ↑₁ ∅).","proofString":"assert (INB : E_t' b_t).\neapply rexec_dtrmt_in_fin; eauto.\nassert (INA : E_t' a_t) by tauto.\napply set_subset_union_r.\nleft.\nunfold WCore.reexec_thread.\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t) (a0 : E_t b_t) (NDA : ~ dtrmt_t a_t) (DB : dtrmt_t b_t) (n : ~ (~ E_t' a_t /\\ E_t' b_t)) : E_t' b_t.","proofString":"eapply rexec_dtrmt_in_fin; eauto."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t) (a0 : E_t b_t) (NDA : ~ dtrmt_t a_t) (DB : dtrmt_t b_t) (n : ~ (~ E_t' a_t /\\ E_t' b_t)) (INB : E_t' b_t) : eq b_t ⊆₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t ∪₁ tid ↓₁ (tid ↑₁ ∅).","proofString":"assert (INA : E_t' a_t) by tauto.\napply set_subset_union_r.\nleft.\nunfold WCore.reexec_thread.\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t) (a0 : E_t b_t) (NDA : ~ dtrmt_t a_t) (DB : dtrmt_t b_t) (n : ~ (~ E_t' a_t /\\ E_t' b_t)) (INB : E_t' b_t) (INA : E_t' a_t) : eq b_t ⊆₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t ∪₁ tid ↓₁ (tid ↑₁ ∅).","proofString":"apply set_subset_union_r.\nleft.\nunfold WCore.reexec_thread.\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t) (a0 : E_t b_t) (NDA : ~ dtrmt_t a_t) (DB : dtrmt_t b_t) (n : ~ (~ E_t' a_t /\\ E_t' b_t)) (INB : E_t' b_t) (INA : E_t' a_t) : eq b_t ⊆₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t \\/\neq b_t ⊆₁ tid ↓₁ (tid ↑₁ ∅).","proofString":"left.\nunfold WCore.reexec_thread.\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t) (a0 : E_t b_t) (NDA : ~ dtrmt_t a_t) (DB : dtrmt_t b_t) (n : ~ (~ E_t' a_t /\\ E_t' b_t)) (INB : E_t' b_t) (INA : E_t' a_t) : eq b_t ⊆₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t.","proofString":"unfold WCore.reexec_thread.\nbasic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t) (a0 : E_t b_t) (NDA : ~ dtrmt_t a_t) (DB : dtrmt_t b_t) (n : ~ (~ E_t' a_t /\\ E_t' b_t)) (INB : E_t' b_t) (INA : E_t' a_t) : eq b_t ⊆₁ tid ↓₁ (tid ↑₁ (E_t' \\₁ dtrmt_t)).","proofString":"basic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t /\\ E_t b_t) (NDA : ~ dtrmt_t a_t) (NDB : ~ dtrmt_t b_t) : eq b_t ⊆₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t ∪₁ tid ↓₁ (tid ↑₁ A_s').","proofString":"assert (INB : E_t b_t) by desf.\napply (WCore.rexec_acts GREEXEC) in INB.\ndestruct INB as [DB | [_ OK]]; basic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t /\\ E_t b_t) (NDA : ~ dtrmt_t a_t) (NDB : ~ dtrmt_t b_t) (INB : E_t b_t) : eq b_t ⊆₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t ∪₁ tid ↓₁ (tid ↑₁ A_s').","proofString":"apply (WCore.rexec_acts GREEXEC) in INB.\ndestruct INB as [DB | [_ OK]]; basic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (TEQ : tid a_t = tid b_t) (a : ~ E_t a_t /\\ E_t b_t) (NDA : ~ dtrmt_t a_t) (NDB : ~ dtrmt_t b_t) (INB : (dtrmt_t ∪₁ E_t ∩₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t) b_t) : eq b_t ⊆₁ tid ↓₁ WCore.reexec_thread X_t' dtrmt_t ∪₁ tid ↓₁ (tid ↑₁ A_s').","proofString":"destruct INB as [DB | [_ OK]]; basic_solver."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : A_s' ⊆₁ set_compl cmt'.","proofString":"assert (NEQ : a_t <> b_t) by apply INV.\nunfold extra_a, cmt'.\ndesf.\nunfolder.\nins.\ndesf.\nintros (y & CMT & MAP).\nassert (YIN : E_t' y).\nnow apply (WCore.reexec_embd_dom GREEXEC).\nenough (E_t' a_t) by desf.\nerewrite <- (rsr_mapper_inv_bt _ NEQ); eauto."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (NEQ : a_t <> b_t) : A_s' ⊆₁ set_compl cmt'.","proofString":"unfold extra_a, cmt'.\ndesf.\nunfolder.\nins.\ndesf.\nintros (y & CMT & MAP).\nassert (YIN : E_t' y).\nnow apply (WCore.reexec_embd_dom GREEXEC).\nenough (E_t' a_t) by desf.\nerewrite <- (rsr_mapper_inv_bt _ NEQ); eauto."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (NEQ : a_t <> b_t) : (ifP ~ E_t' a_t /\\ E_t' b_t then eq b_t else ∅)\n⊆₁ set_compl (mapper ↑₁ cmt_t).","proofString":"desf.\nunfolder.\nins.\ndesf.\nintros (y & CMT & MAP).\nassert (YIN : E_t' y).\nnow apply (WCore.reexec_embd_dom GREEXEC).\nenough (E_t' a_t) by desf.\nerewrite <- (rsr_mapper_inv_bt _ NEQ); eauto."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (NEQ : a_t <> b_t) (a : ~ E_t' a_t /\\ E_t' b_t) : eq b_t ⊆₁ set_compl (mapper ↑₁ cmt_t).","proofString":"unfolder.\nins.\ndesf.\nintros (y & CMT & MAP).\nassert (YIN : E_t' y).\nnow apply (WCore.reexec_embd_dom GREEXEC).\nenough (E_t' a_t) by desf.\nerewrite <- (rsr_mapper_inv_bt _ NEQ); eauto."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (NEQ : a_t <> b_t) (a : ~ E_t' a_t /\\ E_t' b_t) : forall x : actid, b_t = x -> ~ (exists y : actid, cmt_t y /\\ mapper y = x).","proofString":"ins.\ndesf.\nintros (y & CMT & MAP).\nassert (YIN : E_t' y).\nnow apply (WCore.reexec_embd_dom GREEXEC).\nenough (E_t' a_t) by desf.\nerewrite <- (rsr_mapper_inv_bt _ NEQ); eauto."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) (NEQ : a_t <> b_t) (a : ~ E_t' a_t /\\ E_t' b_t) (x : actid) (H : b_t = x) : ~ (exists y : actid, cmt_t y /\\ mapper y = x).","proofString":"desf.\nintros (y & CMT & MAP).\nassert (YIN : E_t' y).\nnow apply (WCore.reexec_embd_dom GREEXEC).\nenough (E_t' a_t) by desf.\nerewrite <- (rsr_mapper_inv_bt _ NEQ); eauto."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : mapper ↑₁ (dtrmt_t \\₁ extra_b) ∪₁ extra_d ⊆₁ cmt'.","proofString":"rewrite extra_d_cmt; eauto.\napply set_subset_union_l.\nsplit; auto with hahn.\nunfold cmt'.\napply set_collect_mori; auto.\ntransitivity dtrmt_t; [basic_solver |].\nexact (WCore.dtrmt_cmt GREEXEC)."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : mapper ↑₁ (dtrmt_t \\₁ extra_b) ∪₁ cmt' ⊆₁ cmt'.","proofString":"apply set_subset_union_l.\nsplit; auto with hahn.\nunfold cmt'.\napply set_collect_mori; auto.\ntransitivity dtrmt_t; [basic_solver |].\nexact (WCore.dtrmt_cmt GREEXEC)."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : mapper ↑₁ (dtrmt_t \\₁ extra_b) ⊆₁ cmt' /\\ cmt' ⊆₁ cmt'.","proofString":"split; auto with hahn.\nunfold cmt'.\napply set_collect_mori; auto.\ntransitivity dtrmt_t; [basic_solver |].\nexact (WCore.dtrmt_cmt GREEXEC)."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : mapper ↑₁ (dtrmt_t \\₁ extra_b) ⊆₁ cmt'.","proofString":"unfold cmt'.\napply set_collect_mori; auto.\ntransitivity dtrmt_t; [basic_solver |].\nexact (WCore.dtrmt_cmt GREEXEC)."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : mapper ↑₁ (dtrmt_t \\₁ extra_b) ⊆₁ mapper ↑₁ cmt_t.","proofString":"apply set_collect_mori; auto.\ntransitivity dtrmt_t; [basic_solver |].\nexact (WCore.dtrmt_cmt GREEXEC)."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : dtrmt_t \\₁ extra_b ⊆₁ cmt_t.","proofString":"transitivity dtrmt_t; [basic_solver |].\nexact (WCore.dtrmt_cmt GREEXEC)."},{"statement":"(GREEXEC : WCore.reexec_gen X_t X_t' f_t dtrmt_t cmt_t thrdle) : dtrmt_t ⊆₁ cmt_t.","proofString":"exact (WCore.dtrmt_cmt GREEXEC)."},{"statement":"(x : actid) : ⦗eq x⦘ ⨾ immediate (⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t') ⨾ ⦗eq x⦘ ⊆ ∅₂.","proofString":"rewrite immediateE.\ntransitivity (⦗eq x⦘ ⨾ sb_t' ⨾ ⦗eq x⦘); [basic_solver|].\nunfolder.\nins.\ndesf.\neapply sb_irr; eauto."},{"statement":"(x : actid) : ⦗eq x⦘\n⨾ (⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t' \\\n   (⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t')\n   ⨾ ⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t') ⨾ ⦗eq x⦘ ⊆ ∅₂.","proofString":"transitivity (⦗eq x⦘ ⨾ sb_t' ⨾ ⦗eq x⦘); [basic_solver|].\nunfolder.\nins.\ndesf.\neapply sb_irr; eauto."},{"statement":"(x : actid) : ⦗eq x⦘ ⨾ sb_t' ⨾ ⦗eq x⦘ ⊆ ∅₂.","proofString":"unfolder.\nins.\ndesf.\neapply sb_irr; eauto."},{"statement":"(x : actid) : forall x0 y : actid, x = x0 /\\ sb_t' x0 y /\\ x = y -> False.","proofString":"ins.\ndesf.\neapply sb_irr; eauto."},{"statement":"(x x0 y : actid) (H : x = x0 /\\ sb_t' x0 y /\\ x = y) : False.","proofString":"desf.\neapply sb_irr; eauto."},{"statement":"(y : actid) (H0 : sb_t' y y) : False.","proofString":"eapply sb_irr; eauto."},{"statement":"immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘\n⊆ ⦗eq b_t⦘ ⨾ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘.","proofString":"assert (NINIT : ~is_init b_t) by apply INV.\nassert (IMM :    (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆      immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘  ).\ntransitivity (      ⦗set_compl is_init⦘ ⨾ (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⨾ ⦗eq a_t⦘    ); [basic_solver |].\nrewrite (rsr_at_bt_imm INV').\nunfold nin_sb.\nbasic_solver.\nintros x y HREL.\nexists x.\nsplit; [| apply HREL].\nunfolder.\nsplit; auto.\ndestruct HREL as (a' & SB & EQ).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst y a'.\nassert (INA : E_t' a_t).\nenough (SB' : sb_t' x a_t).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in SB.\nforward apply SB.\nbasic_solver.\nassert (INB : E_t' b_t).\nnow apply (rsr_at_bt_ord INV').\neapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) : immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘\n⊆ ⦗eq b_t⦘ ⨾ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘.","proofString":"assert (IMM :    (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆      immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘  ).\ntransitivity (      ⦗set_compl is_init⦘ ⨾ (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⨾ ⦗eq a_t⦘    ); [basic_solver |].\nrewrite (rsr_at_bt_imm INV').\nunfold nin_sb.\nbasic_solver.\nintros x y HREL.\nexists x.\nsplit; [| apply HREL].\nunfolder.\nsplit; auto.\ndestruct HREL as (a' & SB & EQ).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst y a'.\nassert (INA : E_t' a_t).\nenough (SB' : sb_t' x a_t).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in SB.\nforward apply SB.\nbasic_solver.\nassert (INB : E_t' b_t).\nnow apply (rsr_at_bt_ord INV').\neapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘.","proofString":"transitivity (      ⦗set_compl is_init⦘ ⨾ (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⨾ ⦗eq a_t⦘    ); [basic_solver |].\nrewrite (rsr_at_bt_imm INV').\nunfold nin_sb.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) : ⦗set_compl (fun a : actid => is_init a)⦘\n⨾ (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⨾ ⦗eq a_t⦘\n⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘.","proofString":"rewrite (rsr_at_bt_imm INV').\nunfold nin_sb.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ immediate sb_t' ⨾ ⦗eq a_t⦘\n⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘.","proofString":"unfold nin_sb.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ immediate sb_t' ⨾ ⦗eq a_t⦘\n⊆ immediate (⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t') ⨾ ⦗eq a_t⦘.","proofString":"basic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) : immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘\n⊆ ⦗eq b_t⦘ ⨾ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘.","proofString":"intros x y HREL.\nexists x.\nsplit; [| apply HREL].\nunfolder.\nsplit; auto.\ndestruct HREL as (a' & SB & EQ).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst y a'.\nassert (INA : E_t' a_t).\nenough (SB' : sb_t' x a_t).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in SB.\nforward apply SB.\nbasic_solver.\nassert (INB : E_t' b_t).\nnow apply (rsr_at_bt_ord INV').\neapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) x y) : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) x y.","proofString":"exists x.\nsplit; [| apply HREL].\nunfolder.\nsplit; auto.\ndestruct HREL as (a' & SB & EQ).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst y a'.\nassert (INA : E_t' a_t).\nenough (SB' : sb_t' x a_t).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in SB.\nforward apply SB.\nbasic_solver.\nassert (INB : E_t' b_t).\nnow apply (rsr_at_bt_ord INV').\neapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) x y) : ⦗eq b_t⦘ x x /\\ (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) x y.","proofString":"split; [| apply HREL].\nunfolder.\nsplit; auto.\ndestruct HREL as (a' & SB & EQ).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst y a'.\nassert (INA : E_t' a_t).\nenough (SB' : sb_t' x a_t).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in SB.\nforward apply SB.\nbasic_solver.\nassert (INB : E_t' b_t).\nnow apply (rsr_at_bt_ord INV').\neapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) x y) : ⦗eq b_t⦘ x x.","proofString":"unfolder.\nsplit; auto.\ndestruct HREL as (a' & SB & EQ).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst y a'.\nassert (INA : E_t' a_t).\nenough (SB' : sb_t' x a_t).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in SB.\nforward apply SB.\nbasic_solver.\nassert (INB : E_t' b_t).\nnow apply (rsr_at_bt_ord INV').\neapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) x y) : x = x /\\ b_t = x.","proofString":"split; auto.\ndestruct HREL as (a' & SB & EQ).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst y a'.\nassert (INA : E_t' a_t).\nenough (SB' : sb_t' x a_t).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in SB.\nforward apply SB.\nbasic_solver.\nassert (INB : E_t' b_t).\nnow apply (rsr_at_bt_ord INV').\neapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) x y) : b_t = x.","proofString":"destruct HREL as (a' & SB & EQ).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst y a'.\nassert (INA : E_t' a_t).\nenough (SB' : sb_t' x a_t).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in SB.\nforward apply SB.\nbasic_solver.\nassert (INB : E_t' b_t).\nnow apply (rsr_at_bt_ord INV').\neapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y a' : actid) (SB : immediate (nin_sb G_t') x a') (EQ : ⦗eq a_t⦘ a' y) : b_t = x.","proofString":"unfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst y a'.\nassert (INA : E_t' a_t).\nenough (SB' : sb_t' x a_t).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in SB.\nforward apply SB.\nbasic_solver.\nassert (INB : E_t' b_t).\nnow apply (rsr_at_bt_ord INV').\neapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y a' : actid) (SB : immediate (nin_sb G_t') x a') (EQ : a' = y /\\ a_t = a') : b_t = x.","proofString":"destruct EQ as (EQ & EQ').\nsubst y a'.\nassert (INA : E_t' a_t).\nenough (SB' : sb_t' x a_t).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in SB.\nforward apply SB.\nbasic_solver.\nassert (INB : E_t' b_t).\nnow apply (rsr_at_bt_ord INV').\neapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y a' : actid) (SB : immediate (nin_sb G_t') x a') (EQ : a' = y) (EQ' : a_t = a') : b_t = x.","proofString":"subst y a'.\nassert (INA : E_t' a_t).\nenough (SB' : sb_t' x a_t).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in SB.\nforward apply SB.\nbasic_solver.\nassert (INB : E_t' b_t).\nnow apply (rsr_at_bt_ord INV').\neapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (nin_sb G_t') x a_t) : b_t = x.","proofString":"assert (INA : E_t' a_t).\nenough (SB' : sb_t' x a_t).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in SB.\nforward apply SB.\nbasic_solver.\nassert (INB : E_t' b_t).\nnow apply (rsr_at_bt_ord INV').\neapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (nin_sb G_t') x a_t) : E_t' a_t.","proofString":"enough (SB' : sb_t' x a_t).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in SB.\nforward apply SB.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (nin_sb G_t') x a_t) (SB' : sb_t' x a_t) : E_t' a_t.","proofString":"hahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (nin_sb G_t') x a_t) (SB' : (⦗E_t'⦘ ⨾ sb_t' ⨾ ⦗E_t'⦘) x a_t) : E_t' a_t.","proofString":"forward apply SB'.\nclear.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (nin_sb G_t') x a_t) (SB' : (⦗E_t'⦘ ⨾ sb_t' ⨾ ⦗E_t'⦘) x a_t) : (⦗E_t'⦘ ⨾ sb_t' ⨾ ⦗E_t'⦘) x a_t -> E_t' a_t.","proofString":"clear.\nbasic_solver."},{"statement":"(x : actid) : (⦗E_t'⦘ ⨾ sb_t' ⨾ ⦗E_t'⦘) x a_t -> E_t' a_t.","proofString":"basic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (nin_sb G_t') x a_t) : sb_t' x a_t.","proofString":"unfold nin_sb in SB.\nforward apply SB.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t') x a_t) : sb_t' x a_t.","proofString":"forward apply SB.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t') x a_t) : immediate (⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t') x a_t -> sb_t' x a_t.","proofString":"basic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (nin_sb G_t') x a_t) (INA : E_t' a_t) : b_t = x.","proofString":"assert (INB : E_t' b_t).\nnow apply (rsr_at_bt_ord INV').\neapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (nin_sb G_t') x a_t) (INA : E_t' a_t) : E_t' b_t.","proofString":"now apply (rsr_at_bt_ord INV')."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (nin_sb G_t') x a_t) (INA : E_t' a_t) (INB : E_t' b_t) : b_t = x.","proofString":"eapply nin_sb_functional_l with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nunfold transp.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (nin_sb G_t') x a_t) (INA : E_t' a_t) (INB : E_t' b_t) : Wf G_t'.","proofString":"apply INV'."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (nin_sb G_t') x a_t) (INA : E_t' a_t) (INB : E_t' b_t) : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t.","proofString":"apply (IMM b_t a_t).\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (nin_sb G_t') x a_t) (INA : E_t' a_t) (INB : E_t' b_t) : ((eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t')) b_t a_t.","proofString":"basic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x : actid) (SB : immediate (nin_sb G_t') x a_t) (INA : E_t' a_t) (INB : E_t' b_t) : immediate (nin_sb G_t') x a_t.","proofString":"auto."},{"statement":"⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')\n⊆ ⦗eq b_t⦘ ⨾ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘.","proofString":"assert (NINIT : ~is_init b_t) by apply INV.\nassert (IMM :    (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆      immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘  ).\ntransitivity (      ⦗set_compl is_init⦘ ⨾ (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⨾ ⦗eq a_t⦘    ); [basic_solver |].\nrewrite (rsr_at_bt_imm INV').\nunfold nin_sb.\nbasic_solver.\nrewrite <- seqA.\nintros x y HREL.\nexists y.\nsplit; [apply HREL |].\nunfolder.\nsplit; auto.\nassert (INB : E_t' b_t).\nenough (SB' : sb_t' b_t y).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in HREL.\nforward apply HREL.\nbasic_solver.\ndestruct classic with (~E_t' a_t) as [NINA|INA'].\nexfalso.\neapply (rsr_bt_max INV'); eauto.\nenough (SB : sb_t' b_t y).\nunfolder.\nsplits; eauto.\nforward apply HREL.\nclear.\nunfold nin_sb.\nbasic_solver.\nassert (INA : E_t' a_t) by tauto.\nclear INA'.\ndestruct HREL as (a' & EQ & SB).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) : ⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')\n⊆ ⦗eq b_t⦘ ⨾ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘.","proofString":"assert (IMM :    (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆      immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘  ).\ntransitivity (      ⦗set_compl is_init⦘ ⨾ (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⨾ ⦗eq a_t⦘    ); [basic_solver |].\nrewrite (rsr_at_bt_imm INV').\nunfold nin_sb.\nbasic_solver.\nrewrite <- seqA.\nintros x y HREL.\nexists y.\nsplit; [apply HREL |].\nunfolder.\nsplit; auto.\nassert (INB : E_t' b_t).\nenough (SB' : sb_t' b_t y).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in HREL.\nforward apply HREL.\nbasic_solver.\ndestruct classic with (~E_t' a_t) as [NINA|INA'].\nexfalso.\neapply (rsr_bt_max INV'); eauto.\nenough (SB : sb_t' b_t y).\nunfolder.\nsplits; eauto.\nforward apply HREL.\nclear.\nunfold nin_sb.\nbasic_solver.\nassert (INA : E_t' a_t) by tauto.\nclear INA'.\ndestruct HREL as (a' & EQ & SB).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘.","proofString":"transitivity (      ⦗set_compl is_init⦘ ⨾ (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⨾ ⦗eq a_t⦘    ); [basic_solver |].\nrewrite (rsr_at_bt_imm INV').\nunfold nin_sb.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) : ⦗set_compl (fun a : actid => is_init a)⦘\n⨾ (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⨾ ⦗eq a_t⦘\n⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘.","proofString":"rewrite (rsr_at_bt_imm INV').\nunfold nin_sb.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ immediate sb_t' ⨾ ⦗eq a_t⦘\n⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘.","proofString":"unfold nin_sb.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) : ⦗set_compl (fun a : actid => is_init a)⦘ ⨾ immediate sb_t' ⨾ ⦗eq a_t⦘\n⊆ immediate (⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t') ⨾ ⦗eq a_t⦘.","proofString":"basic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) : ⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')\n⊆ ⦗eq b_t⦘ ⨾ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘.","proofString":"rewrite <- seqA.\nintros x y HREL.\nexists y.\nsplit; [apply HREL |].\nunfolder.\nsplit; auto.\nassert (INB : E_t' b_t).\nenough (SB' : sb_t' b_t y).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in HREL.\nforward apply HREL.\nbasic_solver.\ndestruct classic with (~E_t' a_t) as [NINA|INA'].\nexfalso.\neapply (rsr_bt_max INV'); eauto.\nenough (SB : sb_t' b_t y).\nunfolder.\nsplits; eauto.\nforward apply HREL.\nclear.\nunfold nin_sb.\nbasic_solver.\nassert (INA : E_t' a_t) by tauto.\nclear INA'.\ndestruct HREL as (a' & EQ & SB).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) : ⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')\n⊆ (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) ⨾ ⦗eq a_t⦘.","proofString":"intros x y HREL.\nexists y.\nsplit; [apply HREL |].\nunfolder.\nsplit; auto.\nassert (INB : E_t' b_t).\nenough (SB' : sb_t' b_t y).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in HREL.\nforward apply HREL.\nbasic_solver.\ndestruct classic with (~E_t' a_t) as [NINA|INA'].\nexfalso.\neapply (rsr_bt_max INV'); eauto.\nenough (SB : sb_t' b_t y).\nunfolder.\nsplits; eauto.\nforward apply HREL.\nclear.\nunfold nin_sb.\nbasic_solver.\nassert (INA : E_t' a_t) by tauto.\nclear INA'.\ndestruct HREL as (a' & EQ & SB).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) : ((⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) ⨾ ⦗eq a_t⦘) x y.","proofString":"exists y.\nsplit; [apply HREL |].\nunfolder.\nsplit; auto.\nassert (INB : E_t' b_t).\nenough (SB' : sb_t' b_t y).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in HREL.\nforward apply HREL.\nbasic_solver.\ndestruct classic with (~E_t' a_t) as [NINA|INA'].\nexfalso.\neapply (rsr_bt_max INV'); eauto.\nenough (SB : sb_t' b_t y).\nunfolder.\nsplits; eauto.\nforward apply HREL.\nclear.\nunfold nin_sb.\nbasic_solver.\nassert (INA : E_t' a_t) by tauto.\nclear INA'.\ndestruct HREL as (a' & EQ & SB).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y /\\ ⦗eq a_t⦘ y y.","proofString":"split; [apply HREL |].\nunfolder.\nsplit; auto.\nassert (INB : E_t' b_t).\nenough (SB' : sb_t' b_t y).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in HREL.\nforward apply HREL.\nbasic_solver.\ndestruct classic with (~E_t' a_t) as [NINA|INA'].\nexfalso.\neapply (rsr_bt_max INV'); eauto.\nenough (SB : sb_t' b_t y).\nunfolder.\nsplits; eauto.\nforward apply HREL.\nclear.\nunfold nin_sb.\nbasic_solver.\nassert (INA : E_t' a_t) by tauto.\nclear INA'.\ndestruct HREL as (a' & EQ & SB).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) : ⦗eq a_t⦘ y y.","proofString":"unfolder.\nsplit; auto.\nassert (INB : E_t' b_t).\nenough (SB' : sb_t' b_t y).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in HREL.\nforward apply HREL.\nbasic_solver.\ndestruct classic with (~E_t' a_t) as [NINA|INA'].\nexfalso.\neapply (rsr_bt_max INV'); eauto.\nenough (SB : sb_t' b_t y).\nunfolder.\nsplits; eauto.\nforward apply HREL.\nclear.\nunfold nin_sb.\nbasic_solver.\nassert (INA : E_t' a_t) by tauto.\nclear INA'.\ndestruct HREL as (a' & EQ & SB).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) : y = y /\\ a_t = y.","proofString":"split; auto.\nassert (INB : E_t' b_t).\nenough (SB' : sb_t' b_t y).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in HREL.\nforward apply HREL.\nbasic_solver.\ndestruct classic with (~E_t' a_t) as [NINA|INA'].\nexfalso.\neapply (rsr_bt_max INV'); eauto.\nenough (SB : sb_t' b_t y).\nunfolder.\nsplits; eauto.\nforward apply HREL.\nclear.\nunfold nin_sb.\nbasic_solver.\nassert (INA : E_t' a_t) by tauto.\nclear INA'.\ndestruct HREL as (a' & EQ & SB).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) : a_t = y.","proofString":"assert (INB : E_t' b_t).\nenough (SB' : sb_t' b_t y).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in HREL.\nforward apply HREL.\nbasic_solver.\ndestruct classic with (~E_t' a_t) as [NINA|INA'].\nexfalso.\neapply (rsr_bt_max INV'); eauto.\nenough (SB : sb_t' b_t y).\nunfolder.\nsplits; eauto.\nforward apply HREL.\nclear.\nunfold nin_sb.\nbasic_solver.\nassert (INA : E_t' a_t) by tauto.\nclear INA'.\ndestruct HREL as (a' & EQ & SB).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) : E_t' b_t.","proofString":"enough (SB' : sb_t' b_t y).\nhahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver.\nunfold nin_sb in HREL.\nforward apply HREL.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) (SB' : sb_t' b_t y) : E_t' b_t.","proofString":"hahn_rewrite wf_sbE in SB'.\nforward apply SB'.\nclear.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) (SB' : (⦗E_t'⦘ ⨾ sb_t' ⨾ ⦗E_t'⦘) b_t y) : E_t' b_t.","proofString":"forward apply SB'.\nclear.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) (SB' : (⦗E_t'⦘ ⨾ sb_t' ⨾ ⦗E_t'⦘) b_t y) : (⦗E_t'⦘ ⨾ sb_t' ⨾ ⦗E_t'⦘) b_t y -> E_t' b_t.","proofString":"clear.\nbasic_solver."},{"statement":"(y : actid) : (⦗E_t'⦘ ⨾ sb_t' ⨾ ⦗E_t'⦘) b_t y -> E_t' b_t.","proofString":"basic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) : sb_t' b_t y.","proofString":"unfold nin_sb in HREL.\nforward apply HREL.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t')) x y) : sb_t' b_t y.","proofString":"forward apply HREL.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t')) x y) : (⦗eq b_t⦘ ⨾ immediate (⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t')) x y ->\nsb_t' b_t y.","proofString":"basic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) (INB : E_t' b_t) : a_t = y.","proofString":"destruct classic with (~E_t' a_t) as [NINA|INA'].\nexfalso.\neapply (rsr_bt_max INV'); eauto.\nenough (SB : sb_t' b_t y).\nunfolder.\nsplits; eauto.\nforward apply HREL.\nclear.\nunfold nin_sb.\nbasic_solver.\nassert (INA : E_t' a_t) by tauto.\nclear INA'.\ndestruct HREL as (a' & EQ & SB).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) (INB : E_t' b_t) (NINA : ~ E_t' a_t) : a_t = y.","proofString":"exfalso.\neapply (rsr_bt_max INV'); eauto.\nenough (SB : sb_t' b_t y).\nunfolder.\nsplits; eauto.\nforward apply HREL.\nclear.\nunfold nin_sb.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) (INB : E_t' b_t) (NINA : ~ E_t' a_t) : False.","proofString":"eapply (rsr_bt_max INV'); eauto.\nenough (SB : sb_t' b_t y).\nunfolder.\nsplits; eauto.\nforward apply HREL.\nclear.\nunfold nin_sb.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) (INB : E_t' b_t) (NINA : ~ E_t' a_t) : sb_t' b_t y.","proofString":"forward apply HREL.\nclear.\nunfold nin_sb.\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) (INB : E_t' b_t) (NINA : ~ E_t' a_t) : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y -> sb_t' b_t y.","proofString":"clear.\nunfold nin_sb.\nbasic_solver."},{"statement":"(x y : actid) : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y -> sb_t' b_t y.","proofString":"unfold nin_sb.\nbasic_solver."},{"statement":"(x y : actid) : (⦗eq b_t⦘ ⨾ immediate (⦗fun e : actid => ~ is_init e⦘ ⨾ sb_t')) x y ->\nsb_t' b_t y.","proofString":"basic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) (INB : E_t' b_t) (INA' : ~ ~ E_t' a_t) : a_t = y.","proofString":"assert (INA : E_t' a_t) by tauto.\nclear INA'.\ndestruct HREL as (a' & EQ & SB).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) (INB : E_t' b_t) (INA' : ~ ~ E_t' a_t) (INA : E_t' a_t) : a_t = y.","proofString":"clear INA'.\ndestruct HREL as (a' & EQ & SB).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y : actid) (HREL : (⦗eq b_t⦘ ⨾ immediate (nin_sb G_t')) x y) (INB : E_t' b_t) (INA : E_t' a_t) : a_t = y.","proofString":"destruct HREL as (a' & EQ & SB).\nunfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y a' : actid) (EQ : ⦗eq b_t⦘ x a') (SB : immediate (nin_sb G_t') a' y) (INB : E_t' b_t) (INA : E_t' a_t) : a_t = y.","proofString":"unfolder in EQ.\ndestruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y a' : actid) (EQ : x = a' /\\ b_t = x) (SB : immediate (nin_sb G_t') a' y) (INB : E_t' b_t) (INA : E_t' a_t) : a_t = y.","proofString":"destruct EQ as (EQ & EQ').\nsubst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (x y a' : actid) (EQ : x = a') (EQ' : b_t = x) (SB : immediate (nin_sb G_t') a' y) (INB : E_t' b_t) (INA : E_t' a_t) : a_t = y.","proofString":"subst a' x.\neapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (y : actid) (SB : immediate (nin_sb G_t') b_t y) (INB : E_t' b_t) (INA : E_t' a_t) : a_t = y.","proofString":"eapply nin_sb_functional_r with (G := G_t').\napply INV'.\nunfold transp.\nenough (SB' : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t).\nforward apply SB'.\nbasic_solver.\napply (IMM b_t a_t).\nbasic_solver.\nauto."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (y : actid) (SB : immediate (nin_sb G_t') b_t y) (INB : E_t' b_t) (INA : E_t' a_t) : Wf G_t'.","proofString":"apply INV'."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (y : actid) (SB : immediate (nin_sb G_t') b_t y) (INB : E_t' b_t) (INA : E_t' a_t) : (immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) b_t a_t.","proofString":"apply (IMM b_t a_t).\nbasic_solver."},{"statement":"(NINIT : ~ is_init b_t) (IMM : (eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t') ⊆ immediate (nin_sb G_t') ⨾ ⦗eq a_t⦘) (y : actid) (SB : immediate (nin_sb G_t') b_t y) (INB : E_t' b_t) (INA : E_t' a_t) : ((eq b_t ∩₁ E_t') × (eq a_t ∩₁ E_t')) b_t a_t.","proofString":"basic_solver."}]}