{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/IEEE754/BinarySingleNaN.v","fileSamples":[{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : valid_binary (B2SF (B754_finite sx mx ex Hx)) = true) : SF2B (B2SF (B754_finite sx mx ex Hx)) H = B754_finite sx mx ex Hx.","conclusion":"SF2B (B2SF (B754_finite sx mx ex Hx)) H = B754_finite sx mx ex Hx","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : valid_binary (B2SF (B754_finite sx mx ex Hx)) = true)","proofString":"apply f_equal, eqbool_irrelevance."},{"statement":"(x : binary_float) : SF2B (B2SF x) (valid_binary_B2SF x) = x.","conclusion":"SF2B (B2SF x) (valid_binary_B2SF x) = x","hypotheses":"(x : binary_float)","proofString":"apply SF2B_B2SF."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (H : canonical_mantissa mx ex = true) : canonical radix2 fexp {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}.","conclusion":"canonical radix2 fexp {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (H : canonical_mantissa mx ex = true)","proofString":"assert (Hx := Zeq_bool_eq _ _ H).\nclear H.\napply sym_eq.\nsimpl.\npattern ex at 2 ; rewrite <- Hx.\napply (f_equal fexp).\nrewrite mag_F2R_Zdigits.\nrewrite <- Zdigits_abs.\nrewrite Zpos_digits2_pos.\nnow case sx.\nnow case sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (H : canonical_mantissa mx ex = true) (Hx : fexp (Z.pos (digits2_pos mx) + ex) = ex) : canonical radix2 fexp {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}.","conclusion":"canonical radix2 fexp {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (H : canonical_mantissa mx ex = true) (Hx : fexp (Z.pos (digits2_pos mx) + ex) = ex)","proofString":"clear H.\napply sym_eq.\nsimpl.\npattern ex at 2 ; rewrite <- Hx.\napply (f_equal fexp).\nrewrite mag_F2R_Zdigits.\nrewrite <- Zdigits_abs.\nrewrite Zpos_digits2_pos.\nnow case sx.\nnow case sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : fexp (Z.pos (digits2_pos mx) + ex) = ex) : canonical radix2 fexp {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}.","conclusion":"canonical radix2 fexp {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : fexp (Z.pos (digits2_pos mx) + ex) = ex)","proofString":"apply sym_eq.\nsimpl.\npattern ex at 2 ; rewrite <- Hx.\napply (f_equal fexp).\nrewrite mag_F2R_Zdigits.\nrewrite <- Zdigits_abs.\nrewrite Zpos_digits2_pos.\nnow case sx.\nnow case sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : fexp (Z.pos (digits2_pos mx) + ex) = ex) : (Zdigits radix2 (cond_Zopp sx (Z.pos mx)) + ex)%Z =\n(Z.pos (digits2_pos mx) + ex)%Z.","conclusion":"(Zdigits radix2 (cond_Zopp sx (Z.pos mx)) + ex)%Z =\n(Z.pos (digits2_pos mx) + ex)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : fexp (Z.pos (digits2_pos mx) + ex) = ex)","proofString":"rewrite <- Zdigits_abs.\nrewrite Zpos_digits2_pos.\nnow case sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : fexp (Z.pos (digits2_pos mx) + ex) = ex) : (Zdigits radix2 (Z.abs (cond_Zopp sx (Z.pos mx))) + ex)%Z =\n(Z.pos (digits2_pos mx) + ex)%Z.","conclusion":"(Zdigits radix2 (Z.abs (cond_Zopp sx (Z.pos mx))) + ex)%Z =\n(Z.pos (digits2_pos mx) + ex)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : fexp (Z.pos (digits2_pos mx) + ex) = ex)","proofString":"rewrite Zpos_digits2_pos.\nnow case sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : fexp (Z.pos (digits2_pos mx) + ex) = ex) : (Zdigits radix2 (Z.abs (cond_Zopp sx (Z.pos mx))) + ex)%Z =\n(Zdigits radix2 (Z.pos mx) + ex)%Z.","conclusion":"(Zdigits radix2 (Z.abs (cond_Zopp sx (Z.pos mx))) + ex)%Z =\n(Zdigits radix2 (Z.pos mx) + ex)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : fexp (Z.pos (digits2_pos mx) + ex) = ex)","proofString":"now case sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : fexp (Z.pos (digits2_pos mx) + ex) = ex) : cond_Zopp sx (Z.pos mx) <> 0%Z.","conclusion":"cond_Zopp sx (Z.pos mx) <> 0%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : fexp (Z.pos (digits2_pos mx) + ex) = ex)","proofString":"now case sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (H : bounded mx ex = true) : canonical radix2 fexp {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}.","conclusion":"canonical radix2 fexp {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (H : bounded mx ex = true)","proofString":"apply canonical_canonical_mantissa.\nnow apply andb_prop in H."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (H : bounded mx ex = true) : canonical_mantissa mx ex = true.","conclusion":"canonical_mantissa mx ex = true","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (H : bounded mx ex = true)","proofString":"now apply andb_prop in H."},{"statement":"(3 - emax - prec < emax)%Z.","conclusion":"(3 - emax - prec < emax)%Z","hypotheses":"","proofString":"unfold Prec_gt_0 in prec_gt_0_.\nunfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(emin <= emax - prec)%Z.","conclusion":"(emin <= emax - prec)%Z","hypotheses":"","proofString":"unfold emin.\nunfold Prec_gt_0 in prec_gt_0_.\nunfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(3 - emax - prec <= emax - prec)%Z.","conclusion":"(3 - emax - prec <= emax - prec)%Z","hypotheses":"","proofString":"unfold Prec_gt_0 in prec_gt_0_.\nunfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) : generic_format radix2 fexp (B2R (B754_finite sx mx ex Hx)).","conclusion":"generic_format radix2 fexp (B2R (B754_finite sx mx ex Hx))","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"simpl.\napply generic_format_canonical.\nnow apply canonical_bounded."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) : canonical radix2 fexp {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}.","conclusion":"canonical radix2 fexp {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"now apply canonical_bounded."},{"statement":"(x : binary_float) : generic_format radix2 (FLT_exp emin prec) (B2R x).","conclusion":"generic_format radix2 (FLT_exp emin prec) (B2R x)","hypotheses":"(x : binary_float)","proofString":"apply generic_format_B2R."},{"statement":"(sx sy : bool) : B2SF (B754_zero sx) = B2SF (B754_zero sy) -> B754_zero sx = B754_zero sy.","conclusion":"B2SF (B754_zero sx) = B2SF (B754_zero sy) -> B754_zero sx = B754_zero sy","hypotheses":"(sx sy : bool)","proofString":"intros H.\nnow inversion H."},{"statement":"(sx sy : bool) (H : B2SF (B754_zero sx) = B2SF (B754_zero sy)) : B754_zero sx = B754_zero sy.","conclusion":"B754_zero sx = B754_zero sy","hypotheses":"(sx sy : bool) (H : B2SF (B754_zero sx) = B2SF (B754_zero sy))","proofString":"now inversion H."},{"statement":"(sx sy : bool) : B2SF (B754_infinity sx) = B2SF (B754_infinity sy) ->\nB754_infinity sx = B754_infinity sy.","conclusion":"B2SF (B754_infinity sx) = B2SF (B754_infinity sy) ->\nB754_infinity sx = B754_infinity sy","hypotheses":"(sx sy : bool)","proofString":"intros H.\nnow inversion H."},{"statement":"(sx sy : bool) (H : B2SF (B754_infinity sx) = B2SF (B754_infinity sy)) : B754_infinity sx = B754_infinity sy.","conclusion":"B754_infinity sx = B754_infinity sy","hypotheses":"(sx sy : bool) (H : B2SF (B754_infinity sx) = B2SF (B754_infinity sy))","proofString":"now inversion H."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) : B2SF (B754_finite sx mx ex Hx) = B2SF (B754_finite sy my ey Hy) ->\nB754_finite sx mx ex Hx = B754_finite sy my ey Hy.","conclusion":"B2SF (B754_finite sx mx ex Hx) = B2SF (B754_finite sy my ey Hy) ->\nB754_finite sx mx ex Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true)","proofString":"intros H.\ninversion H.\nclear H.\nrevert Hx.\nrewrite H2, H3.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : B2SF (B754_finite sx mx ex Hx) = B2SF (B754_finite sy my ey Hy)) : B754_finite sx mx ex Hx = B754_finite sy my ey Hy.","conclusion":"B754_finite sx mx ex Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : B2SF (B754_finite sx mx ex Hx) = B2SF (B754_finite sy my ey Hy))","proofString":"inversion H.\nclear H.\nrevert Hx.\nrewrite H2, H3.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : B2SF (B754_finite sx mx ex Hx) = B2SF (B754_finite sy my ey Hy)) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey) : B754_finite sy mx ex Hx = B754_finite sy my ey Hy.","conclusion":"B754_finite sy mx ex Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H : B2SF (B754_finite sx mx ex Hx) = B2SF (B754_finite sy my ey Hy)) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey)","proofString":"clear H.\nrevert Hx.\nrewrite H2, H3.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey) : B754_finite sy mx ex Hx = B754_finite sy my ey Hy.","conclusion":"B754_finite sy mx ex Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey)","proofString":"revert Hx.\nrewrite H2, H3.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey) : forall Hx : bounded mx ex = true,\nB754_finite sy mx ex Hx = B754_finite sy my ey Hy.","conclusion":"forall Hx : bounded mx ex = true,\nB754_finite sy mx ex Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey)","proofString":"rewrite H2, H3.\nintros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey) : forall Hx : bounded my ey = true,\nB754_finite sy my ey Hx = B754_finite sy my ey Hy.","conclusion":"forall Hx : bounded my ey = true,\nB754_finite sy my ey Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey)","proofString":"intros Hx.\napply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey) (Hx : bounded my ey = true) : B754_finite sy my ey Hx = B754_finite sy my ey Hy.","conclusion":"B754_finite sy my ey Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : sx = sy) (H2 : mx = my) (H3 : ex = ey) (Hx : bounded my ey = true)","proofString":"apply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) : is_finite_strict (B754_finite sx mx ex Hx) = true ->\nis_finite_strict (B754_finite sy my ey Hy) = true ->\nB2R (B754_finite sx mx ex Hx) = B2R (B754_finite sy my ey Hy) ->\nB754_finite sx mx ex Hx = B754_finite sy my ey Hy.","conclusion":"is_finite_strict (B754_finite sx mx ex Hx) = true ->\nis_finite_strict (B754_finite sy my ey Hy) = true ->\nB2R (B754_finite sx mx ex Hx) = B2R (B754_finite sy my ey Hy) ->\nB754_finite sx mx ex Hx = B754_finite sy my ey Hy","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true)","proofString":"simpl.\nintros _ _ Heq.\nassert (Hs: sx = sy).\nrevert Heq.\nclear.\ncase sx ; case sy ; try easy ;  intros Heq ; apply False_ind ; revert Heq.\napply Rlt_not_eq.\napply Rlt_trans with R0.\nnow apply F2R_lt_0.\nnow apply F2R_gt_0.\napply Rgt_not_eq.\napply Rgt_trans with R0.\nnow apply F2R_gt_0.\nnow apply F2R_lt_0.\nassert (mx = my /\\ ex = ey).\nrefine (_ (canonical_unique _ fexp _ _ _ _ Heq)).\nrewrite Hs.\nnow case sy ; intro H ; injection H ; split.\nnow apply canonical_bounded.\nnow apply canonical_bounded.\nrevert Hx.\nrewrite Hs, (proj1 H), (proj2 H).\nintros Hx.\napply f_equal.\napply eqbool_irrelevance."},{"statement":"(x y : binary_float) (H : is_finite x = true) (H0 : is_finite y = true) (H1 : B2R x = B2R y) (H2 : Bsign x = Bsign y) : x = y.","conclusion":"x = y","hypotheses":"(x y : binary_float) (H : is_finite x = true) (H0 : is_finite y = true) (H1 : B2R x = B2R y) (H2 : Bsign x = Bsign y)","proofString":"destruct x, y; try (apply B2R_inj; now eauto).\nsimpl in H2.\ncongruence.\nsymmetry in H1.\napply Rmult_integral in H1.\ndestruct H1.\napply (eq_IZR _ 0) in H1.\ndestruct s0; discriminate H1.\nsimpl in H1.\npose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3.\napply Rmult_integral in H1.\ndestruct H1.\napply (eq_IZR _ 0) in H1.\ndestruct s; discriminate H1.\nsimpl in H1.\npose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s s0 : bool) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : B2R (B754_zero s) = B2R (B754_zero s0)) (H2 : Bsign (B754_zero s) = Bsign (B754_zero s0)) : B754_zero s = B754_zero s0.","conclusion":"B754_zero s = B754_zero s0","hypotheses":"(s s0 : bool) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : B2R (B754_zero s) = B2R (B754_zero s0)) (H2 : Bsign (B754_zero s) = Bsign (B754_zero s0))","proofString":"simpl in H2.\ncongruence."},{"statement":"(s s0 : bool) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : B2R (B754_zero s) = B2R (B754_zero s0)) (H2 : s = s0) : B754_zero s = B754_zero s0.","conclusion":"B754_zero s = B754_zero s0","hypotheses":"(s s0 : bool) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : B2R (B754_zero s) = B2R (B754_zero s0)) (H2 : s = s0)","proofString":"congruence."},{"statement":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : B2R (B754_zero s) = B2R (B754_finite s0 m e e0)) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) : B754_zero s = B754_finite s0 m e e0.","conclusion":"B754_zero s = B754_finite s0 m e e0","hypotheses":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : B2R (B754_zero s) = B2R (B754_finite s0 m e e0)) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0))","proofString":"symmetry in H1.\napply Rmult_integral in H1.\ndestruct H1.\napply (eq_IZR _ 0) in H1.\ndestruct s0; discriminate H1.\nsimpl in H1.\npose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : B2R (B754_finite s0 m e e0) = B2R (B754_zero s)) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) : B754_zero s = B754_finite s0 m e e0.","conclusion":"B754_zero s = B754_finite s0 m e e0","hypotheses":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : B2R (B754_finite s0 m e e0) = B2R (B754_zero s)) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0))","proofString":"apply Rmult_integral in H1.\ndestruct H1.\napply (eq_IZR _ 0) in H1.\ndestruct s0; discriminate H1.\nsimpl in H1.\npose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) : B754_zero s = B754_finite s0 m e e0.","conclusion":"B754_zero s = B754_finite s0 m e e0","hypotheses":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0))","proofString":"pose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) (H3 : (0 < bpow radix2 e)%R) : B754_zero s = B754_finite s0 m e e0.","conclusion":"B754_zero s = B754_finite s0 m e e0","hypotheses":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) (H3 : (0 < bpow radix2 e)%R)","proofString":"rewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) (H3 : (0 < 0)%R) : B754_zero s = B754_finite s0 m e e0.","conclusion":"B754_zero s = B754_finite s0 m e e0","hypotheses":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) (H3 : (0 < 0)%R)","proofString":"apply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) (H3 : False) : B754_zero s = B754_finite s0 m e e0.","conclusion":"B754_zero s = B754_finite s0 m e e0","hypotheses":"(s s0 : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (H : is_finite (B754_zero s) = true) (H0 : is_finite (B754_finite s0 m e e0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_zero s) = Bsign (B754_finite s0 m e e0)) (H3 : False)","proofString":"destruct H3."},{"statement":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : B2R (B754_finite s m e e0) = B2R (B754_zero s0)) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) : B754_finite s m e e0 = B754_zero s0.","conclusion":"B754_finite s m e e0 = B754_zero s0","hypotheses":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : B2R (B754_finite s m e e0) = B2R (B754_zero s0)) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0))","proofString":"apply Rmult_integral in H1.\ndestruct H1.\napply (eq_IZR _ 0) in H1.\ndestruct s; discriminate H1.\nsimpl in H1.\npose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) : B754_finite s m e e0 = B754_zero s0.","conclusion":"B754_finite s m e e0 = B754_zero s0","hypotheses":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0))","proofString":"pose proof (bpow_gt_0 radix2 e).\nrewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) (H3 : (0 < bpow radix2 e)%R) : B754_finite s m e e0 = B754_zero s0.","conclusion":"B754_finite s m e e0 = B754_zero s0","hypotheses":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) (H3 : (0 < bpow radix2 e)%R)","proofString":"rewrite H1 in H3.\napply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) (H3 : (0 < 0)%R) : B754_finite s m e e0 = B754_zero s0.","conclusion":"B754_finite s m e e0 = B754_zero s0","hypotheses":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) (H3 : (0 < 0)%R)","proofString":"apply Rlt_irrefl in H3.\ndestruct H3."},{"statement":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) (H3 : False) : B754_finite s m e e0 = B754_zero s0.","conclusion":"B754_finite s m e e0 = B754_zero s0","hypotheses":"(s : bool) (m : positive) (e : Z) (e0 : bounded m e = true) (s0 : bool) (H : is_finite (B754_finite s m e e0) = true) (H0 : is_finite (B754_zero s0) = true) (H1 : bpow radix2 e = 0%R) (H2 : Bsign (B754_finite s m e e0) = Bsign (B754_zero s0)) (H3 : False)","proofString":"destruct H3."},{"statement":"(s : bool) : binary_float.","conclusion":"binary_float","hypotheses":"(s : bool)","proofString":"exact (B754_zero s)."},{"statement":"(s : bool) : binary_float.","conclusion":"binary_float","hypotheses":"(s : bool)","proofString":"exact (B754_infinity s)."},{"statement":"binary_float.","conclusion":"binary_float","hypotheses":"","proofString":"exact B754_nan."},{"statement":"(s : bool) (m : positive) (e : Z) (H : bounded m e = true) : binary_float.","conclusion":"binary_float","hypotheses":"(s : bool) (m : positive) (e : Z) (H : bounded m e = true)","proofString":"apply (B754_finite s m e).\ndestruct bounded.\napply eq_refl.\nexact H."},{"statement":"(s : bool) (m : positive) (e : Z) (H : bounded m e = true) : bounded m e = true.","conclusion":"bounded m e = true","hypotheses":"(s : bool) (m : positive) (e : Z) (H : bounded m e = true)","proofString":"destruct bounded.\napply eq_refl.\nexact H."},{"statement":"(s : bool) (m : positive) (e : Z) (H : true = true) : true = true.","conclusion":"true = true","hypotheses":"(s : bool) (m : positive) (e : Z) (H : true = true)","proofString":"apply eq_refl."},{"statement":"(s : bool) (m : positive) (e : Z) (H : false = true) : false = true.","conclusion":"false = true","hypotheses":"(s : bool) (m : positive) (e : Z) (H : false = true)","proofString":"exact H."},{"statement":"(s : bool) (m : positive) (e : Z) (H : bounded m e = true) : B754_finite s m e\n  ((if bounded m e as b return (b = true -> b = true)\n    then fun _ : true = true => eq_refl\n    else fun H0 : false = true => H0) H) = B754_finite s m e H.","conclusion":"B754_finite s m e\n  ((if bounded m e as b return (b = true -> b = true)\n    then fun _ : true = true => eq_refl\n    else fun H0 : false = true => H0) H) = B754_finite s m e H","hypotheses":"(s : bool) (m : positive) (e : Z) (H : bounded m e = true)","proofString":"apply f_equal, eqbool_irrelevance."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) : (- B2R (B754_finite sx mx ex Hx))%R = B2R (Bopp (B754_finite sx mx ex Hx)).","conclusion":"(- B2R (B754_finite sx mx ex Hx))%R = B2R (Bopp (B754_finite sx mx ex Hx))","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"simpl.\nrewrite <- F2R_opp.\nnow case sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) : Rabs (B2R (B754_finite sx mx ex Hx)) = B2R (Babs (B754_finite sx mx ex Hx)).","conclusion":"Rabs (B2R (B754_finite sx mx ex Hx)) = B2R (Babs (B754_finite sx mx ex Hx))","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"simpl.\nrewrite <- F2R_abs.\nnow destruct sx."},{"statement":"(x y : binary_float) : Bcompare y x =\nmatch Bcompare x y with\n| Some c => Some (CompOpp c)\n| None => None\nend.","conclusion":"Bcompare y x =\nmatch Bcompare x y with\n| Some c => Some (CompOpp c)\n| None => None\nend","hypotheses":"(x y : binary_float)","proofString":"unfold Bcompare.\ndestruct x as [ ? | [] | | [] mx ex Bx ];  destruct y as [ ? | [] | | [] my ey By ]; simpl; try easy.\nrewrite <- (Zcompare_antisym ex ey).\ndestruct (ex ?= ey)%Z; try easy.\nnow rewrite (Pcompare_antisym mx my).\nrewrite <- (Zcompare_antisym ex ey).\ndestruct (ex ?= ey)%Z; try easy.\nnow rewrite Pcompare_antisym."},{"statement":"(x y : binary_float) : SFcompare (B2SF y) (B2SF x) =\nmatch SFcompare (B2SF x) (B2SF y) with\n| Some c => Some (CompOpp c)\n| None => None\nend.","conclusion":"SFcompare (B2SF y) (B2SF x) =\nmatch SFcompare (B2SF x) (B2SF y) with\n| Some c => Some (CompOpp c)\n| None => None\nend","hypotheses":"(x y : binary_float)","proofString":"destruct x as [ ? | [] | | [] mx ex Bx ];  destruct y as [ ? | [] | | [] my ey By ]; simpl; try easy.\nrewrite <- (Zcompare_antisym ex ey).\ndestruct (ex ?= ey)%Z; try easy.\nnow rewrite (Pcompare_antisym mx my).\nrewrite <- (Zcompare_antisym ex ey).\ndestruct (ex ?= ey)%Z; try easy.\nnow rewrite Pcompare_antisym."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (my : positive) (ey : Z) (By : bounded my ey = true) : Some\n  match (ey ?= ex)%Z with\n  | Eq => CompOpp (Pos.compare_cont Eq my mx)\n  | Lt => Gt\n  | Gt => Lt\n  end =\nSome\n  (CompOpp\n     match (ex ?= ey)%Z with\n     | Eq => CompOpp (Pos.compare_cont Eq mx my)\n     | Lt => Gt\n     | Gt => Lt\n     end).","conclusion":"Some\n  match (ey ?= ex)%Z with\n  | Eq => CompOpp (Pos.compare_cont Eq my mx)\n  | Lt => Gt\n  | Gt => Lt\n  end =\nSome\n  (CompOpp\n     match (ex ?= ey)%Z with\n     | Eq => CompOpp (Pos.compare_cont Eq mx my)\n     | Lt => Gt\n     | Gt => Lt\n     end)","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (my : positive) (ey : Z) (By : bounded my ey = true)","proofString":"rewrite <- (Zcompare_antisym ex ey).\ndestruct (ex ?= ey)%Z; try easy.\nnow rewrite (Pcompare_antisym mx my)."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (my : positive) (ey : Z) (By : bounded my ey = true) : Some\n  match CompOpp (ex ?= ey)%Z with\n  | Eq => CompOpp (Pos.compare_cont Eq my mx)\n  | Lt => Gt\n  | Gt => Lt\n  end =\nSome\n  (CompOpp\n     match (ex ?= ey)%Z with\n     | Eq => CompOpp (Pos.compare_cont Eq mx my)\n     | Lt => Gt\n     | Gt => Lt\n     end).","conclusion":"Some\n  match CompOpp (ex ?= ey)%Z with\n  | Eq => CompOpp (Pos.compare_cont Eq my mx)\n  | Lt => Gt\n  | Gt => Lt\n  end =\nSome\n  (CompOpp\n     match (ex ?= ey)%Z with\n     | Eq => CompOpp (Pos.compare_cont Eq mx my)\n     | Lt => Gt\n     | Gt => Lt\n     end)","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (my : positive) (ey : Z) (By : bounded my ey = true)","proofString":"destruct (ex ?= ey)%Z; try easy.\nnow rewrite (Pcompare_antisym mx my)."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (my : positive) (ey : Z) (By : bounded my ey = true) : Some\n  match CompOpp Eq with\n  | Eq => CompOpp (Pos.compare_cont Eq my mx)\n  | Lt => Gt\n  | Gt => Lt\n  end = Some (CompOpp (CompOpp (Pos.compare_cont Eq mx my))).","conclusion":"Some\n  match CompOpp Eq with\n  | Eq => CompOpp (Pos.compare_cont Eq my mx)\n  | Lt => Gt\n  | Gt => Lt\n  end = Some (CompOpp (CompOpp (Pos.compare_cont Eq mx my)))","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (my : positive) (ey : Z) (By : bounded my ey = true)","proofString":"now rewrite (Pcompare_antisym mx my)."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (my : positive) (ey : Z) (By : bounded my ey = true) : Some\n  match (ey ?= ex)%Z with\n  | Eq => Pos.compare_cont Eq my mx\n  | Lt => Lt\n  | Gt => Gt\n  end =\nSome\n  (CompOpp\n     match (ex ?= ey)%Z with\n     | Eq => Pos.compare_cont Eq mx my\n     | Lt => Lt\n     | Gt => Gt\n     end).","conclusion":"Some\n  match (ey ?= ex)%Z with\n  | Eq => Pos.compare_cont Eq my mx\n  | Lt => Lt\n  | Gt => Gt\n  end =\nSome\n  (CompOpp\n     match (ex ?= ey)%Z with\n     | Eq => Pos.compare_cont Eq mx my\n     | Lt => Lt\n     | Gt => Gt\n     end)","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (my : positive) (ey : Z) (By : bounded my ey = true)","proofString":"rewrite <- (Zcompare_antisym ex ey).\ndestruct (ex ?= ey)%Z; try easy.\nnow rewrite Pcompare_antisym."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (my : positive) (ey : Z) (By : bounded my ey = true) : Some\n  match CompOpp (ex ?= ey)%Z with\n  | Eq => Pos.compare_cont Eq my mx\n  | Lt => Lt\n  | Gt => Gt\n  end =\nSome\n  (CompOpp\n     match (ex ?= ey)%Z with\n     | Eq => Pos.compare_cont Eq mx my\n     | Lt => Lt\n     | Gt => Gt\n     end).","conclusion":"Some\n  match CompOpp (ex ?= ey)%Z with\n  | Eq => Pos.compare_cont Eq my mx\n  | Lt => Lt\n  | Gt => Gt\n  end =\nSome\n  (CompOpp\n     match (ex ?= ey)%Z with\n     | Eq => Pos.compare_cont Eq mx my\n     | Lt => Lt\n     | Gt => Gt\n     end)","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (my : positive) (ey : Z) (By : bounded my ey = true)","proofString":"destruct (ex ?= ey)%Z; try easy.\nnow rewrite Pcompare_antisym."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (my : positive) (ey : Z) (By : bounded my ey = true) : Some\n  match CompOpp Eq with\n  | Eq => Pos.compare_cont Eq my mx\n  | Lt => Lt\n  | Gt => Gt\n  end = Some (CompOpp (Pos.compare_cont Eq mx my)).","conclusion":"Some\n  match CompOpp Eq with\n  | Eq => Pos.compare_cont Eq my mx\n  | Lt => Lt\n  | Gt => Gt\n  end = Some (CompOpp (Pos.compare_cont Eq mx my))","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (my : positive) (ey : Z) (By : bounded my ey = true)","proofString":"now rewrite Pcompare_antisym."},{"statement":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true) : Beqb f1 f2 = Req_bool (B2R f1) (B2R f2).","conclusion":"Beqb f1 f2 = Req_bool (B2R f1) (B2R f2)","hypotheses":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true)","proofString":"generalize (Bcompare_correct _ _ F1 F2).\nunfold Beqb, SFeqb, Bcompare.\nintros ->.\ncase Rcompare_spec; intro H; case Req_bool_spec; intro H'; try reflexivity; lra."},{"statement":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true) : Bcompare f1 f2 = Some (Rcompare (B2R f1) (B2R f2)) ->\nBeqb f1 f2 = Req_bool (B2R f1) (B2R f2).","conclusion":"Bcompare f1 f2 = Some (Rcompare (B2R f1) (B2R f2)) ->\nBeqb f1 f2 = Req_bool (B2R f1) (B2R f2)","hypotheses":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true)","proofString":"unfold Beqb, SFeqb, Bcompare.\nintros ->.\ncase Rcompare_spec; intro H; case Req_bool_spec; intro H'; try reflexivity; lra."},{"statement":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true) : SFcompare (B2SF f1) (B2SF f2) = Some (Rcompare (B2R f1) (B2R f2)) ->\nmatch SFcompare (B2SF f1) (B2SF f2) with\n| Some Eq => true\n| _ => false\nend = Req_bool (B2R f1) (B2R f2).","conclusion":"SFcompare (B2SF f1) (B2SF f2) = Some (Rcompare (B2R f1) (B2R f2)) ->\nmatch SFcompare (B2SF f1) (B2SF f2) with\n| Some Eq => true\n| _ => false\nend = Req_bool (B2R f1) (B2R f2)","hypotheses":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true)","proofString":"intros ->.\ncase Rcompare_spec; intro H; case Req_bool_spec; intro H'; try reflexivity; lra."},{"statement":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true) : match Rcompare (B2R f1) (B2R f2) with\n| Eq => true\n| _ => false\nend = Req_bool (B2R f1) (B2R f2).","conclusion":"match Rcompare (B2R f1) (B2R f2) with\n| Eq => true\n| _ => false\nend = Req_bool (B2R f1) (B2R f2)","hypotheses":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true)","proofString":"case Rcompare_spec; intro H; case Req_bool_spec; intro H'; try reflexivity; lra."},{"statement":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true) : Bltb f1 f2 = Rlt_bool (B2R f1) (B2R f2).","conclusion":"Bltb f1 f2 = Rlt_bool (B2R f1) (B2R f2)","hypotheses":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true)","proofString":"generalize (Bcompare_correct _ _ F1 F2).\nunfold Bltb, SFltb, Bcompare.\nintros ->.\ncase Rcompare_spec; intro H; case Rlt_bool_spec; intro H'; try reflexivity; lra."},{"statement":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true) : Bcompare f1 f2 = Some (Rcompare (B2R f1) (B2R f2)) ->\nBltb f1 f2 = Rlt_bool (B2R f1) (B2R f2).","conclusion":"Bcompare f1 f2 = Some (Rcompare (B2R f1) (B2R f2)) ->\nBltb f1 f2 = Rlt_bool (B2R f1) (B2R f2)","hypotheses":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true)","proofString":"unfold Bltb, SFltb, Bcompare.\nintros ->.\ncase Rcompare_spec; intro H; case Rlt_bool_spec; intro H'; try reflexivity; lra."},{"statement":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true) : SFcompare (B2SF f1) (B2SF f2) = Some (Rcompare (B2R f1) (B2R f2)) ->\nmatch SFcompare (B2SF f1) (B2SF f2) with\n| Some Lt => true\n| _ => false\nend = Rlt_bool (B2R f1) (B2R f2).","conclusion":"SFcompare (B2SF f1) (B2SF f2) = Some (Rcompare (B2R f1) (B2R f2)) ->\nmatch SFcompare (B2SF f1) (B2SF f2) with\n| Some Lt => true\n| _ => false\nend = Rlt_bool (B2R f1) (B2R f2)","hypotheses":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true)","proofString":"intros ->.\ncase Rcompare_spec; intro H; case Rlt_bool_spec; intro H'; try reflexivity; lra."},{"statement":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true) : match Rcompare (B2R f1) (B2R f2) with\n| Lt => true\n| _ => false\nend = Rlt_bool (B2R f1) (B2R f2).","conclusion":"match Rcompare (B2R f1) (B2R f2) with\n| Lt => true\n| _ => false\nend = Rlt_bool (B2R f1) (B2R f2)","hypotheses":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true)","proofString":"case Rcompare_spec; intro H; case Rlt_bool_spec; intro H'; try reflexivity; lra."},{"statement":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true) : Bleb f1 f2 = Rle_bool (B2R f1) (B2R f2).","conclusion":"Bleb f1 f2 = Rle_bool (B2R f1) (B2R f2)","hypotheses":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true)","proofString":"generalize (Bcompare_correct _ _ F1 F2).\nunfold Bleb, SFleb, Bcompare.\nintros ->.\ncase Rcompare_spec; intro H; case Rle_bool_spec; intro H'; try reflexivity; lra."},{"statement":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true) : Bcompare f1 f2 = Some (Rcompare (B2R f1) (B2R f2)) ->\nBleb f1 f2 = Rle_bool (B2R f1) (B2R f2).","conclusion":"Bcompare f1 f2 = Some (Rcompare (B2R f1) (B2R f2)) ->\nBleb f1 f2 = Rle_bool (B2R f1) (B2R f2)","hypotheses":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true)","proofString":"unfold Bleb, SFleb, Bcompare.\nintros ->.\ncase Rcompare_spec; intro H; case Rle_bool_spec; intro H'; try reflexivity; lra."},{"statement":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true) : SFcompare (B2SF f1) (B2SF f2) = Some (Rcompare (B2R f1) (B2R f2)) ->\nmatch SFcompare (B2SF f1) (B2SF f2) with\n| Some Eq | Some Lt => true\n| _ => false\nend = Rle_bool (B2R f1) (B2R f2).","conclusion":"SFcompare (B2SF f1) (B2SF f2) = Some (Rcompare (B2R f1) (B2R f2)) ->\nmatch SFcompare (B2SF f1) (B2SF f2) with\n| Some Eq | Some Lt => true\n| _ => false\nend = Rle_bool (B2R f1) (B2R f2)","hypotheses":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true)","proofString":"intros ->.\ncase Rcompare_spec; intro H; case Rle_bool_spec; intro H'; try reflexivity; lra."},{"statement":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true) : match Rcompare (B2R f1) (B2R f2) with\n| Gt => false\n| _ => true\nend = Rle_bool (B2R f1) (B2R f2).","conclusion":"match Rcompare (B2R f1) (B2R f2) with\n| Gt => false\n| _ => true\nend = Rle_bool (B2R f1) (B2R f2)","hypotheses":"(f1 f2 : binary_float) (F1 : is_finite f1 = true) (F2 : is_finite f2 = true)","proofString":"case Rcompare_spec; intro H; case Rle_bool_spec; intro H'; try reflexivity; lra."},{"statement":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) : (0 <= bpow radix2 ex)%R.","conclusion":"(0 <= bpow radix2 ex)%R","hypotheses":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"apply bpow_ge_0."},{"statement":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) : ((bpow radix2 (Zdigits radix2 (Z.pos mx)) - 1) * bpow radix2 ex <=\n bpow radix2 emax - bpow radix2 (emax - prec))%R.","conclusion":"((bpow radix2 (Zdigits radix2 (Z.pos mx)) - 1) * bpow radix2 ex <=\n bpow radix2 emax - bpow radix2 (emax - prec))%R","hypotheses":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"destruct (andb_prop _ _ Hx) as [H1 H2].\napply Rle_trans with (bpow radix2 (ex + prec) - bpow radix2 ex)%R.\nrewrite Rmult_minus_distr_r, Rmult_1_l, <- bpow_plus.\napply Rplus_le_compat_r.\napply bpow_le.\napply Zeq_bool_eq in H1.\nrewrite Zpos_digits2_pos in H1.\nunfold fexp, FLT_exp in H1.\nclear -H1 ; lia.\nreplace emax with (emax - prec - ex + (ex + prec))%Z at 1 by ring.\nreplace (emax - prec)%Z with (emax - prec - ex + ex)%Z at 2 by ring.\ndo 2 rewrite (bpow_plus _ (emax - prec - ex)).\nrewrite <- Rmult_minus_distr_l.\nrewrite <- (Rmult_1_l (_ - _)) at 1.\napply Rmult_le_compat_r.\napply Rle_0_minus, bpow_le.\nunfold Prec_gt_0 in prec_gt_0_.\nclear -prec_gt_0_ ; lia.\napply (bpow_le radix2 0).\napply Zle_minus_le_0.\nnow apply Zle_bool_imp_le."},{"statement":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true) : ((bpow radix2 (Zdigits radix2 (Z.pos mx)) - 1) * bpow radix2 ex <=\n bpow radix2 emax - bpow radix2 (emax - prec))%R.","conclusion":"((bpow radix2 (Zdigits radix2 (Z.pos mx)) - 1) * bpow radix2 ex <=\n bpow radix2 emax - bpow radix2 (emax - prec))%R","hypotheses":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true)","proofString":"apply Rle_trans with (bpow radix2 (ex + prec) - bpow radix2 ex)%R.\nrewrite Rmult_minus_distr_r, Rmult_1_l, <- bpow_plus.\napply Rplus_le_compat_r.\napply bpow_le.\napply Zeq_bool_eq in H1.\nrewrite Zpos_digits2_pos in H1.\nunfold fexp, FLT_exp in H1.\nclear -H1 ; lia.\nreplace emax with (emax - prec - ex + (ex + prec))%Z at 1 by ring.\nreplace (emax - prec)%Z with (emax - prec - ex + ex)%Z at 2 by ring.\ndo 2 rewrite (bpow_plus _ (emax - prec - ex)).\nrewrite <- Rmult_minus_distr_l.\nrewrite <- (Rmult_1_l (_ - _)) at 1.\napply Rmult_le_compat_r.\napply Rle_0_minus, bpow_le.\nunfold Prec_gt_0 in prec_gt_0_.\nclear -prec_gt_0_ ; lia.\napply (bpow_le radix2 0).\napply Zle_minus_le_0.\nnow apply Zle_bool_imp_le."},{"statement":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true) : (bpow radix2 (ex + prec) - bpow radix2 ex <=\n bpow radix2 (emax - prec - ex + (ex + prec)) - bpow radix2 (emax - prec))%R.","conclusion":"(bpow radix2 (ex + prec) - bpow radix2 ex <=\n bpow radix2 (emax - prec - ex + (ex + prec)) - bpow radix2 (emax - prec))%R","hypotheses":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true)","proofString":"replace (emax - prec)%Z with (emax - prec - ex + ex)%Z at 2 by ring.\ndo 2 rewrite (bpow_plus _ (emax - prec - ex)).\nrewrite <- Rmult_minus_distr_l.\nrewrite <- (Rmult_1_l (_ - _)) at 1.\napply Rmult_le_compat_r.\napply Rle_0_minus, bpow_le.\nunfold Prec_gt_0 in prec_gt_0_.\nclear -prec_gt_0_ ; lia.\napply (bpow_le radix2 0).\napply Zle_minus_le_0.\nnow apply Zle_bool_imp_le."},{"statement":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true) : (bpow radix2 (ex + prec) - bpow radix2 ex <=\n bpow radix2 (emax - prec - ex + (ex + prec)) -\n bpow radix2 (emax - prec - ex + ex))%R.","conclusion":"(bpow radix2 (ex + prec) - bpow radix2 ex <=\n bpow radix2 (emax - prec - ex + (ex + prec)) -\n bpow radix2 (emax - prec - ex + ex))%R","hypotheses":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true)","proofString":"do 2 rewrite (bpow_plus _ (emax - prec - ex)).\nrewrite <- Rmult_minus_distr_l.\nrewrite <- (Rmult_1_l (_ - _)) at 1.\napply Rmult_le_compat_r.\napply Rle_0_minus, bpow_le.\nunfold Prec_gt_0 in prec_gt_0_.\nclear -prec_gt_0_ ; lia.\napply (bpow_le radix2 0).\napply Zle_minus_le_0.\nnow apply Zle_bool_imp_le."},{"statement":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true) : (bpow radix2 (ex + prec) - bpow radix2 ex <=\n bpow radix2 (emax - prec - ex) * bpow radix2 (ex + prec) -\n bpow radix2 (emax - prec - ex) * bpow radix2 ex)%R.","conclusion":"(bpow radix2 (ex + prec) - bpow radix2 ex <=\n bpow radix2 (emax - prec - ex) * bpow radix2 (ex + prec) -\n bpow radix2 (emax - prec - ex) * bpow radix2 ex)%R","hypotheses":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true)","proofString":"rewrite <- Rmult_minus_distr_l.\nrewrite <- (Rmult_1_l (_ - _)) at 1.\napply Rmult_le_compat_r.\napply Rle_0_minus, bpow_le.\nunfold Prec_gt_0 in prec_gt_0_.\nclear -prec_gt_0_ ; lia.\napply (bpow_le radix2 0).\napply Zle_minus_le_0.\nnow apply Zle_bool_imp_le."},{"statement":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true) : (bpow radix2 (ex + prec) - bpow radix2 ex <=\n bpow radix2 (emax - prec - ex) * (bpow radix2 (ex + prec) - bpow radix2 ex))%R.","conclusion":"(bpow radix2 (ex + prec) - bpow radix2 ex <=\n bpow radix2 (emax - prec - ex) * (bpow radix2 (ex + prec) - bpow radix2 ex))%R","hypotheses":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true)","proofString":"rewrite <- (Rmult_1_l (_ - _)) at 1.\napply Rmult_le_compat_r.\napply Rle_0_minus, bpow_le.\nunfold Prec_gt_0 in prec_gt_0_.\nclear -prec_gt_0_ ; lia.\napply (bpow_le radix2 0).\napply Zle_minus_le_0.\nnow apply Zle_bool_imp_le."},{"statement":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true) : (1 * (bpow radix2 (ex + prec) - bpow radix2 ex) <=\n bpow radix2 (emax - prec - ex) * (bpow radix2 (ex + prec) - bpow radix2 ex))%R.","conclusion":"(1 * (bpow radix2 (ex + prec) - bpow radix2 ex) <=\n bpow radix2 (emax - prec - ex) * (bpow radix2 (ex + prec) - bpow radix2 ex))%R","hypotheses":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true)","proofString":"apply Rmult_le_compat_r.\napply Rle_0_minus, bpow_le.\nunfold Prec_gt_0 in prec_gt_0_.\nclear -prec_gt_0_ ; lia.\napply (bpow_le radix2 0).\napply Zle_minus_le_0.\nnow apply Zle_bool_imp_le."},{"statement":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true) : (0 <= bpow radix2 (ex + prec) - bpow radix2 ex)%R.","conclusion":"(0 <= bpow radix2 (ex + prec) - bpow radix2 ex)%R","hypotheses":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true)","proofString":"apply Rle_0_minus, bpow_le.\nunfold Prec_gt_0 in prec_gt_0_.\nclear -prec_gt_0_ ; lia."},{"statement":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true) : (ex <= ex + prec)%Z.","conclusion":"(ex <= ex + prec)%Z","hypotheses":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true)","proofString":"unfold Prec_gt_0 in prec_gt_0_.\nclear -prec_gt_0_ ; lia."},{"statement":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true) : (1 <= bpow radix2 (emax - prec - ex))%R.","conclusion":"(1 <= bpow radix2 (emax - prec - ex))%R","hypotheses":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true)","proofString":"apply (bpow_le radix2 0).\napply Zle_minus_le_0.\nnow apply Zle_bool_imp_le."},{"statement":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true) : (0 <= emax - prec - ex)%Z.","conclusion":"(0 <= emax - prec - ex)%Z","hypotheses":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true)","proofString":"apply Zle_minus_le_0.\nnow apply Zle_bool_imp_le."},{"statement":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true) : (ex <= emax - prec)%Z.","conclusion":"(ex <= emax - prec)%Z","hypotheses":"(mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : canonical_mantissa mx ex = true) (H2 : (ex <=? emax - prec)%Z = true)","proofString":"now apply Zle_bool_imp_le."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : true = true) : (bpow radix2 emin <= IZR (Z.pos mx) * Rabs (bpow radix2 ex))%R.","conclusion":"(bpow radix2 emin <= IZR (Z.pos mx) * Rabs (bpow radix2 ex))%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : true = true)","proofString":"rewrite Rabs_pos_eq; [|apply bpow_ge_0].\nnow apply bounded_ge_emin."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : true = true) : (bpow radix2 emin <= IZR (Z.pos mx) * bpow radix2 ex)%R.","conclusion":"(bpow radix2 emin <= IZR (Z.pos mx) * bpow radix2 ex)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : true = true)","proofString":"now apply bounded_ge_emin."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : true = true) : (bpow radix2 emin <= IZR (Z.pos mx) * Rabs (bpow radix2 ex))%R.","conclusion":"(bpow radix2 emin <= IZR (Z.pos mx) * Rabs (bpow radix2 ex))%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : true = true)","proofString":"rewrite Rabs_pos_eq; [|apply bpow_ge_0].\nnow apply bounded_ge_emin."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : true = true) : (bpow radix2 emin <= IZR (Z.pos mx) * bpow radix2 ex)%R.","conclusion":"(bpow radix2 emin <= IZR (Z.pos mx) * bpow radix2 ex)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H : true = true)","proofString":"now apply bounded_ge_emin."},{"statement":"(m : Z) (r s : bool) : (0 <= shr_m {| shr_m := m; shr_r := r; shr_s := s |})%Z ->\n(0 <= 2 * shr_m (shr_1 {| shr_m := m; shr_r := r; shr_s := s |}) <=\n shr_m {| shr_m := m; shr_r := r; shr_s := s |})%Z /\\\n(shr_m {| shr_m := m; shr_r := r; shr_s := s |} <\n 2 * (shr_m (shr_1 {| shr_m := m; shr_r := r; shr_s := s |}) + 1))%Z.","conclusion":"(0 <= shr_m {| shr_m := m; shr_r := r; shr_s := s |})%Z ->\n(0 <= 2 * shr_m (shr_1 {| shr_m := m; shr_r := r; shr_s := s |}) <=\n shr_m {| shr_m := m; shr_r := r; shr_s := s |})%Z /\\\n(shr_m {| shr_m := m; shr_r := r; shr_s := s |} <\n 2 * (shr_m (shr_1 {| shr_m := m; shr_r := r; shr_s := s |}) + 1))%Z","hypotheses":"(m : Z) (r s : bool)","proofString":"simpl.\ndestruct m as [| p | p]; [simpl; lia | intros _ | intros; easy].\ndestruct p; simpl; [| | lia].\nrewrite Pos2Z.inj_xO, Pos2Z.inj_xI.\nlia.\nrewrite Pos2Z.inj_xO.\nlia."},{"statement":"(m : Z) (r s : bool) : (0 <= m)%Z ->\n(0 <=\n match\n   shr_m\n     match m with\n     | 0 => {| shr_m := 0; shr_r := false; shr_s := r || s |}\n     | Z.pos p~1 => {| shr_m := Z.pos p; shr_r := true; shr_s := r || s |}\n     | Z.pos p~0 => {| shr_m := Z.pos p; shr_r := false; shr_s := r || s |}\n     | Z.neg p~1 => {| shr_m := Z.neg p; shr_r := true; shr_s := r || s |}\n     | Z.neg p~0 => {| shr_m := Z.neg p; shr_r := false; shr_s := r || s |}\n     | _ => {| shr_m := 0; shr_r := true; shr_s := r || s |}\n     end\n with\n | 0 => 0\n | Z.pos y' => Z.pos y'~0\n | Z.neg y' => Z.neg y'~0\n end <= m)%Z /\\\n(m <\n match\n   shr_m\n     match m with\n     | 0 => {| shr_m := 0; shr_r := false; shr_s := r || s |}\n     | Z.pos p~1 => {| shr_m := Z.pos p; shr_r := true; shr_s := r || s |}\n     | Z.pos p~0 => {| shr_m := Z.pos p; shr_r := false; shr_s := r || s |}\n     | Z.neg p~1 => {| shr_m := Z.neg p; shr_r := true; shr_s := r || s |}\n     | Z.neg p~0 => {| shr_m := Z.neg p; shr_r := false; shr_s := r || s |}\n     | _ => {| shr_m := 0; shr_r := true; shr_s := r || s |}\n     end + 1\n with\n | 0 => 0\n | Z.pos y' => Z.pos y'~0\n | Z.neg y' => Z.neg y'~0\n end)%Z.","conclusion":"(0 <= m)%Z ->\n(0 <=\n match\n   shr_m\n     match m with\n     | 0 => {| shr_m := 0; shr_r := false; shr_s := r || s |}\n     | Z.pos p~1 => {| shr_m := Z.pos p; shr_r := true; shr_s := r || s |}\n     | Z.pos p~0 => {| shr_m := Z.pos p; shr_r := false; shr_s := r || s |}\n     | Z.neg p~1 => {| shr_m := Z.neg p; shr_r := true; shr_s := r || s |}\n     | Z.neg p~0 => {| shr_m := Z.neg p; shr_r := false; shr_s := r || s |}\n     | _ => {| shr_m := 0; shr_r := true; shr_s := r || s |}\n     end\n with\n | 0 => 0\n | Z.pos y' => Z.pos y'~0\n | Z.neg y' => Z.neg y'~0\n end <= m)%Z /\\\n(m <\n match\n   shr_m\n     match m with\n     | 0 => {| shr_m := 0; shr_r := false; shr_s := r || s |}\n     | Z.pos p~1 => {| shr_m := Z.pos p; shr_r := true; shr_s := r || s |}\n     | Z.pos p~0 => {| shr_m := Z.pos p; shr_r := false; shr_s := r || s |}\n     | Z.neg p~1 => {| shr_m := Z.neg p; shr_r := true; shr_s := r || s |}\n     | Z.neg p~0 => {| shr_m := Z.neg p; shr_r := false; shr_s := r || s |}\n     | _ => {| shr_m := 0; shr_r := true; shr_s := r || s |}\n     end + 1\n with\n | 0 => 0\n | Z.pos y' => Z.pos y'~0\n | Z.neg y' => Z.neg y'~0\n end)%Z","hypotheses":"(m : Z) (r s : bool)","proofString":"destruct m as [| p | p]; [simpl; lia | intros _ | intros; easy].\ndestruct p; simpl; [| | lia].\nrewrite Pos2Z.inj_xO, Pos2Z.inj_xI.\nlia.\nrewrite Pos2Z.inj_xO.\nlia."},{"statement":"(p : positive) (r s : bool) : (0 <=\n match\n   shr_m\n     match p with\n     | (p0~1)%positive =>\n         {| shr_m := Z.pos p0; shr_r := true; shr_s := r || s |}\n     | (p0~0)%positive =>\n         {| shr_m := Z.pos p0; shr_r := false; shr_s := r || s |}\n     | 1%positive => {| shr_m := 0; shr_r := true; shr_s := r || s |}\n     end\n with\n | 0 => 0\n | Z.pos y' => Z.pos y'~0\n | Z.neg y' => Z.neg y'~0\n end <= Z.pos p)%Z /\\\n(Z.pos p <\n match\n   shr_m\n     match p with\n     | (p0~1)%positive =>\n         {| shr_m := Z.pos p0; shr_r := true; shr_s := r || s |}\n     | (p0~0)%positive =>\n         {| shr_m := Z.pos p0; shr_r := false; shr_s := r || s |}\n     | 1%positive => {| shr_m := 0; shr_r := true; shr_s := r || s |}\n     end + 1\n with\n | 0 => 0\n | Z.pos y' => Z.pos y'~0\n | Z.neg y' => Z.neg y'~0\n end)%Z.","conclusion":"(0 <=\n match\n   shr_m\n     match p with\n     | (p0~1)%positive =>\n         {| shr_m := Z.pos p0; shr_r := true; shr_s := r || s |}\n     | (p0~0)%positive =>\n         {| shr_m := Z.pos p0; shr_r := false; shr_s := r || s |}\n     | 1%positive => {| shr_m := 0; shr_r := true; shr_s := r || s |}\n     end\n with\n | 0 => 0\n | Z.pos y' => Z.pos y'~0\n | Z.neg y' => Z.neg y'~0\n end <= Z.pos p)%Z /\\\n(Z.pos p <\n match\n   shr_m\n     match p with\n     | (p0~1)%positive =>\n         {| shr_m := Z.pos p0; shr_r := true; shr_s := r || s |}\n     | (p0~0)%positive =>\n         {| shr_m := Z.pos p0; shr_r := false; shr_s := r || s |}\n     | 1%positive => {| shr_m := 0; shr_r := true; shr_s := r || s |}\n     end + 1\n with\n | 0 => 0\n | Z.pos y' => Z.pos y'~0\n | Z.neg y' => Z.neg y'~0\n end)%Z","hypotheses":"(p : positive) (r s : bool)","proofString":"destruct p; simpl; [| | lia].\nrewrite Pos2Z.inj_xO, Pos2Z.inj_xI.\nlia.\nrewrite Pos2Z.inj_xO.\nlia."},{"statement":"(p : positive) (r s : bool) : (0 <= 2 * Z.pos p <= 2 * Z.pos p + 1)%Z /\\\n(2 * Z.pos p + 1 < Z.pos (p + 1)~0)%Z.","conclusion":"(0 <= 2 * Z.pos p <= 2 * Z.pos p + 1)%Z /\\\n(2 * Z.pos p + 1 < Z.pos (p + 1)~0)%Z","hypotheses":"(p : positive) (r s : bool)","proofString":"rewrite Pos2Z.inj_xO.\nlia."},{"statement":"(p : positive) (r s : bool) : (0 <= 2 * Z.pos p <= 2 * Z.pos p)%Z /\\ (2 * Z.pos p < Z.pos (p + 1)~0)%Z.","conclusion":"(0 <= 2 * Z.pos p <= 2 * Z.pos p)%Z /\\ (2 * Z.pos p < Z.pos (p + 1)~0)%Z","hypotheses":"(p : positive) (r s : bool)","proofString":"lia."},{"statement":"(mrs : shr_record) (e n : Z) (Hmrs : (0 <= shr_m mrs)%Z) : (0 <= n)%Z ->\n(0 <= 2 ^ n * shr_m (fst (shr mrs e n)) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ n * (shr_m (fst (shr mrs e n)) + 1))%Z.","conclusion":"(0 <= n)%Z ->\n(0 <= 2 ^ n * shr_m (fst (shr mrs e n)) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ n * (shr_m (fst (shr mrs e n)) + 1))%Z","hypotheses":"(mrs : shr_record) (e n : Z) (Hmrs : (0 <= shr_m mrs)%Z)","proofString":"destruct n as [| n | n ];    [intros _; simpl; now destruct (shr_m mrs); simpl; lia | intro Hn | lia].\nunfold shr.\nrewrite iter_pos_nat.\nrewrite <-!(positive_nat_Z n).\nsimpl fst.\ninduction (nat_of_P n) as [| n' IHn']; [simpl; destruct (shr_m mrs); simpl; lia |].\nrewrite !Nat2Z.inj_succ.\nrewrite Z.pow_succ_r; [| apply Zle_0_nat].\nrewrite iter_nat_S.\nrewrite (Z.mul_comm 2%Z _), <-Z.mul_assoc.\ndestruct IHn' as [[IHn'1 IHn'2] IHn'3].\napply Z.mul_nonneg_cancel_l in IHn'1; [| lia].\nrepeat split;    [| transitivity (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z; [| auto] |].\napply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le.\napply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le.\napply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) : (0 <= 2 ^ Z.pos n * shr_m (fst (shr mrs e (Z.pos n))) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.pos n * (shr_m (fst (shr mrs e (Z.pos n))) + 1))%Z.","conclusion":"(0 <= 2 ^ Z.pos n * shr_m (fst (shr mrs e (Z.pos n))) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.pos n * (shr_m (fst (shr mrs e (Z.pos n))) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z)","proofString":"unfold shr.\nrewrite iter_pos_nat.\nrewrite <-!(positive_nat_Z n).\nsimpl fst.\ninduction (nat_of_P n) as [| n' IHn']; [simpl; destruct (shr_m mrs); simpl; lia |].\nrewrite !Nat2Z.inj_succ.\nrewrite Z.pow_succ_r; [| apply Zle_0_nat].\nrewrite iter_nat_S.\nrewrite (Z.mul_comm 2%Z _), <-Z.mul_assoc.\ndestruct IHn' as [[IHn'1 IHn'2] IHn'3].\napply Z.mul_nonneg_cancel_l in IHn'1; [| lia].\nrepeat split;    [| transitivity (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z; [| auto] |].\napply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le.\napply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le.\napply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) : (0 <= 2 ^ Z.pos n * shr_m (fst (iter_pos shr_1 n mrs, e + Z.pos n)) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.pos n * (shr_m (fst (iter_pos shr_1 n mrs, e + Z.pos n)) + 1))%Z.","conclusion":"(0 <= 2 ^ Z.pos n * shr_m (fst (iter_pos shr_1 n mrs, e + Z.pos n)) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.pos n * (shr_m (fst (iter_pos shr_1 n mrs, e + Z.pos n)) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z)","proofString":"rewrite iter_pos_nat.\nrewrite <-!(positive_nat_Z n).\nsimpl fst.\ninduction (nat_of_P n) as [| n' IHn']; [simpl; destruct (shr_m mrs); simpl; lia |].\nrewrite !Nat2Z.inj_succ.\nrewrite Z.pow_succ_r; [| apply Zle_0_nat].\nrewrite iter_nat_S.\nrewrite (Z.mul_comm 2%Z _), <-Z.mul_assoc.\ndestruct IHn' as [[IHn'1 IHn'2] IHn'3].\napply Z.mul_nonneg_cancel_l in IHn'1; [| lia].\nrepeat split;    [| transitivity (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z; [| auto] |].\napply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le.\napply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le.\napply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) : (0 <=\n 2 ^ Z.pos n * shr_m (fst (iter_nat shr_1 (Pos.to_nat n) mrs, e + Z.pos n)) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.pos n *\n (shr_m (fst (iter_nat shr_1 (Pos.to_nat n) mrs, e + Z.pos n)) + 1))%Z.","conclusion":"(0 <=\n 2 ^ Z.pos n * shr_m (fst (iter_nat shr_1 (Pos.to_nat n) mrs, e + Z.pos n)) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.pos n *\n (shr_m (fst (iter_nat shr_1 (Pos.to_nat n) mrs, e + Z.pos n)) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z)","proofString":"rewrite <-!(positive_nat_Z n).\nsimpl fst.\ninduction (nat_of_P n) as [| n' IHn']; [simpl; destruct (shr_m mrs); simpl; lia |].\nrewrite !Nat2Z.inj_succ.\nrewrite Z.pow_succ_r; [| apply Zle_0_nat].\nrewrite iter_nat_S.\nrewrite (Z.mul_comm 2%Z _), <-Z.mul_assoc.\ndestruct IHn' as [[IHn'1 IHn'2] IHn'3].\napply Z.mul_nonneg_cancel_l in IHn'1; [| lia].\nrepeat split;    [| transitivity (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z; [| auto] |].\napply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le.\napply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le.\napply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) : (0 <=\n 2 ^ Z.of_nat (Pos.to_nat n) *\n shr_m (fst (iter_nat shr_1 (Pos.to_nat n) mrs, e + Z.of_nat (Pos.to_nat n))) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.of_nat (Pos.to_nat n) *\n (shr_m\n    (fst (iter_nat shr_1 (Pos.to_nat n) mrs, e + Z.of_nat (Pos.to_nat n))) +\n  1))%Z.","conclusion":"(0 <=\n 2 ^ Z.of_nat (Pos.to_nat n) *\n shr_m (fst (iter_nat shr_1 (Pos.to_nat n) mrs, e + Z.of_nat (Pos.to_nat n))) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.of_nat (Pos.to_nat n) *\n (shr_m\n    (fst (iter_nat shr_1 (Pos.to_nat n) mrs, e + Z.of_nat (Pos.to_nat n))) +\n  1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z)","proofString":"simpl fst.\ninduction (nat_of_P n) as [| n' IHn']; [simpl; destruct (shr_m mrs); simpl; lia |].\nrewrite !Nat2Z.inj_succ.\nrewrite Z.pow_succ_r; [| apply Zle_0_nat].\nrewrite iter_nat_S.\nrewrite (Z.mul_comm 2%Z _), <-Z.mul_assoc.\ndestruct IHn' as [[IHn'1 IHn'2] IHn'3].\napply Z.mul_nonneg_cancel_l in IHn'1; [| lia].\nrepeat split;    [| transitivity (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z; [| auto] |].\napply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le.\napply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le.\napply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) : (0 <=\n 2 ^ Z.of_nat (Pos.to_nat n) * shr_m (iter_nat shr_1 (Pos.to_nat n) mrs) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.of_nat (Pos.to_nat n) *\n (shr_m (iter_nat shr_1 (Pos.to_nat n) mrs) + 1))%Z.","conclusion":"(0 <=\n 2 ^ Z.of_nat (Pos.to_nat n) * shr_m (iter_nat shr_1 (Pos.to_nat n) mrs) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.of_nat (Pos.to_nat n) *\n (shr_m (iter_nat shr_1 (Pos.to_nat n) mrs) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z)","proofString":"induction (nat_of_P n) as [| n' IHn']; [simpl; destruct (shr_m mrs); simpl; lia |].\nrewrite !Nat2Z.inj_succ.\nrewrite Z.pow_succ_r; [| apply Zle_0_nat].\nrewrite iter_nat_S.\nrewrite (Z.mul_comm 2%Z _), <-Z.mul_assoc.\ndestruct IHn' as [[IHn'1 IHn'2] IHn'3].\napply Z.mul_nonneg_cancel_l in IHn'1; [| lia].\nrepeat split;    [| transitivity (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z; [| auto] |].\napply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le.\napply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le.\napply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn' : (0 <= 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (0 <= 2 ^ Z.of_nat (S n') * shr_m (iter_nat shr_1 (S n') mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.of_nat (S n') * (shr_m (iter_nat shr_1 (S n') mrs) + 1))%Z.","conclusion":"(0 <= 2 ^ Z.of_nat (S n') * shr_m (iter_nat shr_1 (S n') mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.of_nat (S n') * (shr_m (iter_nat shr_1 (S n') mrs) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn' : (0 <= 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"rewrite !Nat2Z.inj_succ.\nrewrite Z.pow_succ_r; [| apply Zle_0_nat].\nrewrite iter_nat_S.\nrewrite (Z.mul_comm 2%Z _), <-Z.mul_assoc.\ndestruct IHn' as [[IHn'1 IHn'2] IHn'3].\napply Z.mul_nonneg_cancel_l in IHn'1; [| lia].\nrepeat split;    [| transitivity (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z; [| auto] |].\napply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le.\napply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le.\napply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn' : (0 <= 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (0 <= 2 ^ Z.succ (Z.of_nat n') * shr_m (iter_nat shr_1 (S n') mrs) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.succ (Z.of_nat n') * (shr_m (iter_nat shr_1 (S n') mrs) + 1))%Z.","conclusion":"(0 <= 2 ^ Z.succ (Z.of_nat n') * shr_m (iter_nat shr_1 (S n') mrs) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.succ (Z.of_nat n') * (shr_m (iter_nat shr_1 (S n') mrs) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn' : (0 <= 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"rewrite Z.pow_succ_r; [| apply Zle_0_nat].\nrewrite iter_nat_S.\nrewrite (Z.mul_comm 2%Z _), <-Z.mul_assoc.\ndestruct IHn' as [[IHn'1 IHn'2] IHn'3].\napply Z.mul_nonneg_cancel_l in IHn'1; [| lia].\nrepeat split;    [| transitivity (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z; [| auto] |].\napply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le.\napply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le.\napply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn' : (0 <= 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (0 <= 2 * 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 (S n') mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 * 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 (S n') mrs) + 1))%Z.","conclusion":"(0 <= 2 * 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 (S n') mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 * 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 (S n') mrs) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn' : (0 <= 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"rewrite iter_nat_S.\nrewrite (Z.mul_comm 2%Z _), <-Z.mul_assoc.\ndestruct IHn' as [[IHn'1 IHn'2] IHn'3].\napply Z.mul_nonneg_cancel_l in IHn'1; [| lia].\nrepeat split;    [| transitivity (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z; [| auto] |].\napply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le.\napply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le.\napply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn' : (0 <= 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (0 <= 2 * 2 ^ Z.of_nat n' * shr_m (shr_1 (iter_nat shr_1 n' mrs)) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 * 2 ^ Z.of_nat n' * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z.","conclusion":"(0 <= 2 * 2 ^ Z.of_nat n' * shr_m (shr_1 (iter_nat shr_1 n' mrs)) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 * 2 ^ Z.of_nat n' * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn' : (0 <= 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"rewrite (Z.mul_comm 2%Z _), <-Z.mul_assoc.\ndestruct IHn' as [[IHn'1 IHn'2] IHn'3].\napply Z.mul_nonneg_cancel_l in IHn'1; [| lia].\nrepeat split;    [| transitivity (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z; [| auto] |].\napply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le.\napply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le.\napply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn' : (0 <= 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (0 <= 2 ^ Z.of_nat n' * (2 * shr_m (shr_1 (iter_nat shr_1 n' mrs))) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.of_nat n' * 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z.","conclusion":"(0 <= 2 ^ Z.of_nat n' * (2 * shr_m (shr_1 (iter_nat shr_1 n' mrs))) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.of_nat n' * 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn' : (0 <= 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z /\\\n(shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"destruct IHn' as [[IHn'1 IHn'2] IHn'3].\napply Z.mul_nonneg_cancel_l in IHn'1; [| lia].\nrepeat split;    [| transitivity (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z; [| auto] |].\napply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le.\napply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le.\napply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (0 <= 2 ^ Z.of_nat n' * (2 * shr_m (shr_1 (iter_nat shr_1 n' mrs))) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.of_nat n' * 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z.","conclusion":"(0 <= 2 ^ Z.of_nat n' * (2 * shr_m (shr_1 (iter_nat shr_1 n' mrs))) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.of_nat n' * 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"apply Z.mul_nonneg_cancel_l in IHn'1; [| lia].\nrepeat split;    [| transitivity (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z; [| auto] |].\napply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le.\napply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le.\napply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (0 <= 2 ^ Z.of_nat n' * (2 * shr_m (shr_1 (iter_nat shr_1 n' mrs))) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.of_nat n' * 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z.","conclusion":"(0 <= 2 ^ Z.of_nat n' * (2 * shr_m (shr_1 (iter_nat shr_1 n' mrs))) <=\n shr_m mrs)%Z /\\\n(shr_m mrs <\n 2 ^ Z.of_nat n' * 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"repeat split;    [| transitivity (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z; [| auto] |].\napply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le.\napply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le.\napply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (0 <= 2 ^ Z.of_nat n' * (2 * shr_m (shr_1 (iter_nat shr_1 n' mrs))))%Z.","conclusion":"(0 <= 2 ^ Z.of_nat n' * (2 * shr_m (shr_1 (iter_nat shr_1 n' mrs))))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"apply Z.mul_nonneg_nonneg; [lia |].\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (0 <= 2 * shr_m (shr_1 (iter_nat shr_1 n' mrs)))%Z.","conclusion":"(0 <= 2 * shr_m (shr_1 (iter_nat shr_1 n' mrs)))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"now apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (2 ^ Z.of_nat n' * (2 * shr_m (shr_1 (iter_nat shr_1 n' mrs))) <=\n 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z.","conclusion":"(2 ^ Z.of_nat n' * (2 * shr_m (shr_1 (iter_nat shr_1 n' mrs))) <=\n 2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"apply Z.mul_le_mono_nonneg_l; [lia |].\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (2 * shr_m (shr_1 (iter_nat shr_1 n' mrs)) <= shr_m (iter_nat shr_1 n' mrs))%Z.","conclusion":"(2 * shr_m (shr_1 (iter_nat shr_1 n' mrs)) <= shr_m (iter_nat shr_1 n' mrs))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"now apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (shr_m mrs <\n 2 ^ Z.of_nat n' * 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z.","conclusion":"(shr_m mrs <\n 2 ^ Z.of_nat n' * 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"apply Z.lt_le_trans with      (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z; [assumption |].\nrewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1) <=\n 2 ^ Z.of_nat n' * 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z.","conclusion":"(2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1) <=\n 2 ^ Z.of_nat n' * 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"rewrite <-Z.mul_assoc.\napply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1) <=\n 2 ^ Z.of_nat n' * (2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1)))%Z.","conclusion":"(2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1) <=\n 2 ^ Z.of_nat n' * (2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1)))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"apply Z.mul_le_mono_nonneg_l; [lia |].\napply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (shr_m (iter_nat shr_1 n' mrs) + 1 <=\n 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z.","conclusion":"(shr_m (iter_nat shr_1 n' mrs) + 1 <=\n 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"apply Ztac.Zlt_le_add_1.\nnow apply le_shr1_le."},{"statement":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z) : (shr_m (iter_nat shr_1 n' mrs) <\n 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z.","conclusion":"(shr_m (iter_nat shr_1 n' mrs) <\n 2 * (shr_m (shr_1 (iter_nat shr_1 n' mrs)) + 1))%Z","hypotheses":"(mrs : shr_record) (e : Z) (n : positive) (Hmrs : (0 <= shr_m mrs)%Z) (Hn : (0 <= Z.pos n)%Z) (n' : nat) (IHn'1 : (0 <= shr_m (iter_nat shr_1 n' mrs))%Z) (IHn'2 : (2 ^ Z.of_nat n' * shr_m (iter_nat shr_1 n' mrs) <= shr_m mrs)%Z) (IHn'3 : (shr_m mrs < 2 ^ Z.of_nat n' * (shr_m (iter_nat shr_1 n' mrs) + 1))%Z)","proofString":"now apply le_shr1_le."},{"statement":"(mrs : shr_record) (e n : Z) (Hmrs0 : (0 < shr_m mrs)%Z \\/ shr_m mrs = 0%Z /\\ (shr_r mrs || shr_s mrs)%bool = true) : (shr_m mrs < radix2 ^ (n - 1))%Z ->\nfst (shr mrs e n) = {| shr_m := 0; shr_r := false; shr_s := true |}.","conclusion":"(shr_m mrs < radix2 ^ (n - 1))%Z ->\nfst (shr mrs e n) = {| shr_m := 0; shr_r := false; shr_s := true |}","hypotheses":"(mrs : shr_record) (e n : Z) (Hmrs0 : (0 < shr_m mrs)%Z \\/ shr_m mrs = 0%Z /\\ (shr_r mrs || shr_s mrs)%bool = true)","proofString":"set (n' := (n - 1)%Z).\nreplace n with (n' + 1)%Z; [| lia].\ndestruct n' as [| p | p ].\nsimpl.\ndestruct Hmrs0 as [Hmrs0 | Hmrs0]; [lia | intros _].\ndestruct mrs as [m r s].\nsimpl in Hmrs0.\ndestruct Hmrs0 as [Hmrs00 Hmrs01].\nrewrite Hmrs00.\nsimpl.\nnow rewrite Hmrs01.\nintros Hmrs1.\nrewrite !Z.add_1_r.\nrewrite <-Pos2Z.inj_succ.\nsimpl shr.\nrewrite iter_pos_nat.\nrewrite Pos2Nat.inj_succ.\nsimpl iter_nat.\nrewrite <-(positive_nat_Z p) in Hmrs1.\nrewrite <-(Pos2Nat.id p) at 2.\nrevert Hmrs1.\nrevert Hmrs0.\nrevert mrs.\ninduction (nat_of_P p) as [| n'' IHn''].\nsimpl in *.\nintros mrs [Hmrs0 | [Hmrs00 Hmrs01]] Hmrs1; [lia |].\ndestruct mrs as [m r s].\nsimpl in Hmrs00, Hmrs01, Hmrs1.\nrewrite Hmrs00.\nsimpl.\nnow rewrite Hmrs01.\nintros mrs Hmrs0 Hmrs1.\nsimpl iter_nat.\ndestruct (le_shr1_le mrs) as [[Hmrs'0 Hmrs'1] Hmrs'2]; [destruct Hmrs0; lia |].\nset (mrs' := shr_1 mrs).\napply IHn''.\ncase (0 <? shr_m (shr_1 mrs))%Z eqn:Hmrs'3;         [apply Zlt_is_lt_bool in Hmrs'3; now left |].\nfold mrs' in Hmrs'0, Hmrs'1, Hmrs'2, Hmrs'3.\napply Z.ltb_ge in Hmrs'3.\napply Z.mul_nonneg_cancel_l in Hmrs'0; [| easy].\napply (Z.le_antisymm _ _ Hmrs'3) in Hmrs'0.\nright.\nsplit; [assumption |].\ndestruct Hmrs0 as [Hmrs0 | [Hmrs00 Hmrs01]].\nrewrite Hmrs'0 in Hmrs'2.\nsimpl in Hmrs'2.\nassert (Hmrs2 : shr_m mrs = 1%Z) by lia.\ndestruct mrs as [m r s].\nsimpl in Hmrs2.\nunfold mrs'.\nnow rewrite Hmrs2.\ndestruct mrs as [m r s].\nsimpl in Hmrs00, Hmrs01.\nunfold mrs'.\nnow rewrite Hmrs00.\nsimpl Z.of_nat in Hmrs1.\nunfold mrs'.\nrewrite Zpos_P_of_succ_nat in Hmrs1.\nrewrite Z.pow_succ_r in Hmrs1; [| lia].\napply (Z.le_lt_trans _ _ _ Hmrs'1) in Hmrs1.\napply Z.mul_lt_mono_pos_l in Hmrs1; [assumption | easy].\nsimpl.\ndestruct Hmrs0 as [Hmrs0 | Hmrs0]; lia."},{"statement":"(e n : Z) (p : positive) (n'' : nat) (IHn'' : forall mrs : shr_record,\n(0 < shr_m mrs)%Z \\/ shr_m mrs = 0%Z /\\ (shr_r mrs || shr_s mrs)%bool = true ->\n(shr_m mrs < radix2 ^ Z.of_nat n'')%Z ->\nfst (shr mrs e n) = {| shr_m := 0; shr_r := false; shr_s := true |}) (m : Z) (r s : bool) (Hmrs00 : m = 0%Z) (Hmrs01 : (r || s)%bool = true) (Hmrs1 : (shr_m {| shr_m := m; shr_r := r; shr_s := s |} < radix2 ^ Z.of_nat (S n''))%Z) (mrs' : shr_record) : shr_m {| shr_m := m; shr_r := r; shr_s := s |} = 0%Z /\\\n(shr_r {| shr_m := m; shr_r := r; shr_s := s |}\n || shr_s {| shr_m := m; shr_r := r; shr_s := s |})%bool = true.","conclusion":"shr_m {| shr_m := m; shr_r := r; shr_s := s |} = 0%Z /\\\n(shr_r {| shr_m := m; shr_r := r; shr_s := s |}\n || shr_s {| shr_m := m; shr_r := r; shr_s := s |})%bool = true","hypotheses":"(e n : Z) (p : positive) (n'' : nat) (IHn'' : forall mrs : shr_record,\n(0 < shr_m mrs)%Z \\/ shr_m mrs = 0%Z /\\ (shr_r mrs || shr_s mrs)%bool = true ->\n(shr_m mrs < radix2 ^ Z.of_nat n'')%Z ->\nfst (shr mrs e n) = {| shr_m := 0; shr_r := false; shr_s := true |}) (m : Z) (r s : bool) (Hmrs00 : m = 0%Z) (Hmrs01 : (r || s)%bool = true) (Hmrs1 : (shr_m {| shr_m := m; shr_r := r; shr_s := s |} < radix2 ^ Z.of_nat (S n''))%Z) (mrs' : shr_record)","proofString":"now rewrite Hmrs00."},{"statement":"(mrs : shr_record) (e n : Z) (Hmrs0 : (0 < shr_m mrs)%Z \\/ shr_m mrs = 0%Z /\\ (shr_r mrs || shr_s mrs)%bool = true) (p : positive) : (shr_m mrs < 0)%Z ->\nfst (shr mrs e n) = {| shr_m := 0; shr_r := false; shr_s := true |}.","conclusion":"(shr_m mrs < 0)%Z ->\nfst (shr mrs e n) = {| shr_m := 0; shr_r := false; shr_s := true |}","hypotheses":"(mrs : shr_record) (e n : Z) (Hmrs0 : (0 < shr_m mrs)%Z \\/ shr_m mrs = 0%Z /\\ (shr_r mrs || shr_s mrs)%bool = true) (p : positive)","proofString":"destruct Hmrs0 as [Hmrs0 | Hmrs0]; lia."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) : shr (shr_record_of_loc m l) e (f (Zdigits2 m + e)%Z - e) =\n(let\n '(m', e', l') := truncate radix2 f (m, e, l) in\n  (shr_record_of_loc m' l', e')).","conclusion":"shr (shr_record_of_loc m l) e (f (Zdigits2 m + e)%Z - e) =\n(let\n '(m', e', l') := truncate radix2 f (m, e, l) in\n  (shr_record_of_loc m' l', e'))","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z)","proofString":"case_eq (truncate radix2 f (m, e, l)).\nintros (m', e') l'.\nunfold shr_fexp.\nrewrite Zdigits2_Zdigits.\ncase_eq (f (Zdigits radix2 m + e) - e)%Z.\nintros He.\nunfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H.\nintros p Hp.\nassert (He: (e <= f (Zdigits radix2 m + e))%Z); [ clear -Hp; lia |].\ndestruct (inbetween_float_ex radix2 m e l) as (x, Hx).\ngeneralize (inbetween_shr x m e l (f (Zdigits radix2 m + e) - e) Hm Hx)%Z.\nassert (Hx0 : (0 <= x)%R);     [apply Rle_trans with (F2R (Float radix2 m e));       [now apply F2R_ge_0       |exact (proj1 (inbetween_float_bounds _ _ _ _ _ Hx))]     |].\ncase_eq (shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e) - e))%Z.\nintros mrs e'' H3 H4 H1.\ngeneralize (truncate_correct radix2 _ x m e l Hx0 Hx (or_introl _ He)).\nrewrite H1.\nintros (H2,_).\nrewrite <- Hp, H3.\nassert (e'' = e').\nchange (snd (mrs, e'') = snd (fst (m',e',l'))).\nrewrite <- H1, <- H3.\nunfold truncate.\nnow rewrite Hp.\nrewrite H in H4 |- *.\napply (f_equal (fun v => (v, _))).\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ H2 H4) as (H5, H6).\nrewrite H5, H6.\ncase mrs.\nnow intros m0 [|] [|].\nintros p Hp.\nunfold truncate.\nrewrite Hp.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) : forall (p : Z * Z) (l0 : location),\ntruncate radix2 f (m, e, l) = (p, l0) ->\nshr (shr_record_of_loc m l) e (f (Zdigits2 m + e)%Z - e) =\n(let '(m', e') := p in (shr_record_of_loc m' l0, e')).","conclusion":"forall (p : Z * Z) (l0 : location),\ntruncate radix2 f (m, e, l) = (p, l0) ->\nshr (shr_record_of_loc m l) e (f (Zdigits2 m + e)%Z - e) =\n(let '(m', e') := p in (shr_record_of_loc m' l0, e'))","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z)","proofString":"intros (m', e') l'.\nunfold shr_fexp.\nrewrite Zdigits2_Zdigits.\ncase_eq (f (Zdigits radix2 m + e) - e)%Z.\nintros He.\nunfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H.\nintros p Hp.\nassert (He: (e <= f (Zdigits radix2 m + e))%Z); [ clear -Hp; lia |].\ndestruct (inbetween_float_ex radix2 m e l) as (x, Hx).\ngeneralize (inbetween_shr x m e l (f (Zdigits radix2 m + e) - e) Hm Hx)%Z.\nassert (Hx0 : (0 <= x)%R);     [apply Rle_trans with (F2R (Float radix2 m e));       [now apply F2R_ge_0       |exact (proj1 (inbetween_float_bounds _ _ _ _ _ Hx))]     |].\ncase_eq (shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e) - e))%Z.\nintros mrs e'' H3 H4 H1.\ngeneralize (truncate_correct radix2 _ x m e l Hx0 Hx (or_introl _ He)).\nrewrite H1.\nintros (H2,_).\nrewrite <- Hp, H3.\nassert (e'' = e').\nchange (snd (mrs, e'') = snd (fst (m',e',l'))).\nrewrite <- H1, <- H3.\nunfold truncate.\nnow rewrite Hp.\nrewrite H in H4 |- *.\napply (f_equal (fun v => (v, _))).\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ H2 H4) as (H5, H6).\nrewrite H5, H6.\ncase mrs.\nnow intros m0 [|] [|].\nintros p Hp.\nunfold truncate.\nrewrite Hp.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) : truncate radix2 f (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (f (Zdigits2 m + e)%Z - e) =\n(shr_record_of_loc m' l', e').","conclusion":"truncate radix2 f (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (f (Zdigits2 m + e)%Z - e) =\n(shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location)","proofString":"unfold shr_fexp.\nrewrite Zdigits2_Zdigits.\ncase_eq (f (Zdigits radix2 m + e) - e)%Z.\nintros He.\nunfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H.\nintros p Hp.\nassert (He: (e <= f (Zdigits radix2 m + e))%Z); [ clear -Hp; lia |].\ndestruct (inbetween_float_ex radix2 m e l) as (x, Hx).\ngeneralize (inbetween_shr x m e l (f (Zdigits radix2 m + e) - e) Hm Hx)%Z.\nassert (Hx0 : (0 <= x)%R);     [apply Rle_trans with (F2R (Float radix2 m e));       [now apply F2R_ge_0       |exact (proj1 (inbetween_float_bounds _ _ _ _ _ Hx))]     |].\ncase_eq (shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e) - e))%Z.\nintros mrs e'' H3 H4 H1.\ngeneralize (truncate_correct radix2 _ x m e l Hx0 Hx (or_introl _ He)).\nrewrite H1.\nintros (H2,_).\nrewrite <- Hp, H3.\nassert (e'' = e').\nchange (snd (mrs, e'') = snd (fst (m',e',l'))).\nrewrite <- H1, <- H3.\nunfold truncate.\nnow rewrite Hp.\nrewrite H in H4 |- *.\napply (f_equal (fun v => (v, _))).\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ H2 H4) as (H5, H6).\nrewrite H5, H6.\ncase mrs.\nnow intros m0 [|] [|].\nintros p Hp.\nunfold truncate.\nrewrite Hp.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) : truncate radix2 f (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (f (Zdigits2 m + e)%Z - e) =\n(shr_record_of_loc m' l', e').","conclusion":"truncate radix2 f (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (f (Zdigits2 m + e)%Z - e) =\n(shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location)","proofString":"rewrite Zdigits2_Zdigits.\ncase_eq (f (Zdigits radix2 m + e) - e)%Z.\nintros He.\nunfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H.\nintros p Hp.\nassert (He: (e <= f (Zdigits radix2 m + e))%Z); [ clear -Hp; lia |].\ndestruct (inbetween_float_ex radix2 m e l) as (x, Hx).\ngeneralize (inbetween_shr x m e l (f (Zdigits radix2 m + e) - e) Hm Hx)%Z.\nassert (Hx0 : (0 <= x)%R);     [apply Rle_trans with (F2R (Float radix2 m e));       [now apply F2R_ge_0       |exact (proj1 (inbetween_float_bounds _ _ _ _ _ Hx))]     |].\ncase_eq (shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e) - e))%Z.\nintros mrs e'' H3 H4 H1.\ngeneralize (truncate_correct radix2 _ x m e l Hx0 Hx (or_introl _ He)).\nrewrite H1.\nintros (H2,_).\nrewrite <- Hp, H3.\nassert (e'' = e').\nchange (snd (mrs, e'') = snd (fst (m',e',l'))).\nrewrite <- H1, <- H3.\nunfold truncate.\nnow rewrite Hp.\nrewrite H in H4 |- *.\napply (f_equal (fun v => (v, _))).\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ H2 H4) as (H5, H6).\nrewrite H5, H6.\ncase mrs.\nnow intros m0 [|] [|].\nintros p Hp.\nunfold truncate.\nrewrite Hp.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) : truncate radix2 f (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e) =\n(shr_record_of_loc m' l', e').","conclusion":"truncate radix2 f (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e) =\n(shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location)","proofString":"case_eq (f (Zdigits radix2 m + e) - e)%Z.\nintros He.\nunfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H.\nintros p Hp.\nassert (He: (e <= f (Zdigits radix2 m + e))%Z); [ clear -Hp; lia |].\ndestruct (inbetween_float_ex radix2 m e l) as (x, Hx).\ngeneralize (inbetween_shr x m e l (f (Zdigits radix2 m + e) - e) Hm Hx)%Z.\nassert (Hx0 : (0 <= x)%R);     [apply Rle_trans with (F2R (Float radix2 m e));       [now apply F2R_ge_0       |exact (proj1 (inbetween_float_bounds _ _ _ _ _ Hx))]     |].\ncase_eq (shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e) - e))%Z.\nintros mrs e'' H3 H4 H1.\ngeneralize (truncate_correct radix2 _ x m e l Hx0 Hx (or_introl _ He)).\nrewrite H1.\nintros (H2,_).\nrewrite <- Hp, H3.\nassert (e'' = e').\nchange (snd (mrs, e'') = snd (fst (m',e',l'))).\nrewrite <- H1, <- H3.\nunfold truncate.\nnow rewrite Hp.\nrewrite H in H4 |- *.\napply (f_equal (fun v => (v, _))).\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ H2 H4) as (H5, H6).\nrewrite H5, H6.\ncase mrs.\nnow intros m0 [|] [|].\nintros p Hp.\nunfold truncate.\nrewrite Hp.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) : (f (Zdigits radix2 m + e) - e)%Z = 0%Z ->\ntruncate radix2 f (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e').","conclusion":"(f (Zdigits radix2 m + e) - e)%Z = 0%Z ->\ntruncate radix2 f (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location)","proofString":"intros He.\nunfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (f (Zdigits radix2 m + e) - e)%Z = 0%Z) : truncate radix2 f (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e').","conclusion":"truncate radix2 f (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (f (Zdigits radix2 m + e) - e)%Z = 0%Z)","proofString":"unfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (f (Zdigits radix2 m + e) - e)%Z = 0%Z) : (if (0 <? f (Zdigits radix2 m + e) - e)%Z\n then truncate_aux radix2 (m, e, l) (f (Zdigits radix2 m + e)%Z - e)\n else (m, e, l)) = (m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e').","conclusion":"(if (0 <? f (Zdigits radix2 m + e) - e)%Z\n then truncate_aux radix2 (m, e, l) (f (Zdigits radix2 m + e)%Z - e)\n else (m, e, l)) = (m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (f (Zdigits radix2 m + e) - e)%Z = 0%Z)","proofString":"rewrite He.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (f (Zdigits radix2 m + e) - e)%Z = 0%Z) : (if (0 <? 0)%Z then truncate_aux radix2 (m, e, l) 0 else (m, e, l)) =\n(m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e').","conclusion":"(if (0 <? 0)%Z then truncate_aux radix2 (m, e, l) 0 else (m, e, l)) =\n(m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (f (Zdigits radix2 m + e) - e)%Z = 0%Z)","proofString":"simpl.\nintros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (f (Zdigits radix2 m + e) - e)%Z = 0%Z) : (m, e, l) = (m', e', l') ->\n(shr_record_of_loc m l, e) = (shr_record_of_loc m' l', e').","conclusion":"(m, e, l) = (m', e', l') ->\n(shr_record_of_loc m l, e) = (shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (f (Zdigits radix2 m + e) - e)%Z = 0%Z)","proofString":"intros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (f (Zdigits radix2 m + e) - e)%Z = 0%Z) (H : (m, e, l) = (m', e', l')) : (shr_record_of_loc m l, e) = (shr_record_of_loc m' l', e').","conclusion":"(shr_record_of_loc m l, e) = (shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (f (Zdigits radix2 m + e) - e)%Z = 0%Z) (H : (m, e, l) = (m', e', l'))","proofString":"now inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.pos p) (x : R) (Hx : inbetween_float radix2 m e x l) (Hx0 : (0 <= x)%R) (mrs : shr_record) (e'' : Z) (H3 : shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e) = (mrs, e'')) (H4 : inbetween_float radix2 (shr_m mrs) e'' x (loc_of_shr_record mrs)) (H1 : truncate radix2 f (m, e, l) = (m', e', l')) : e'' = e'.","conclusion":"e'' = e'","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.pos p) (x : R) (Hx : inbetween_float radix2 m e x l) (Hx0 : (0 <= x)%R) (mrs : shr_record) (e'' : Z) (H3 : shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e) = (mrs, e'')) (H4 : inbetween_float radix2 (shr_m mrs) e'' x (loc_of_shr_record mrs)) (H1 : truncate radix2 f (m, e, l) = (m', e', l'))","proofString":"change (snd (mrs, e'') = snd (fst (m',e',l'))).\nrewrite <- H1, <- H3.\nunfold truncate.\nnow rewrite Hp."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.pos p) (x : R) (Hx : inbetween_float radix2 m e x l) (Hx0 : (0 <= x)%R) (mrs : shr_record) (e'' : Z) (H3 : shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e) = (mrs, e'')) (H4 : inbetween_float radix2 (shr_m mrs) e'' x (loc_of_shr_record mrs)) (H1 : truncate radix2 f (m, e, l) = (m', e', l')) : snd (mrs, e'') = snd (fst (m', e', l')).","conclusion":"snd (mrs, e'') = snd (fst (m', e', l'))","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.pos p) (x : R) (Hx : inbetween_float radix2 m e x l) (Hx0 : (0 <= x)%R) (mrs : shr_record) (e'' : Z) (H3 : shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e) = (mrs, e'')) (H4 : inbetween_float radix2 (shr_m mrs) e'' x (loc_of_shr_record mrs)) (H1 : truncate radix2 f (m, e, l) = (m', e', l'))","proofString":"rewrite <- H1, <- H3.\nunfold truncate.\nnow rewrite Hp."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.pos p) (x : R) (Hx : inbetween_float radix2 m e x l) (Hx0 : (0 <= x)%R) (mrs : shr_record) (e'' : Z) (H3 : shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e) = (mrs, e'')) (H4 : inbetween_float radix2 (shr_m mrs) e'' x (loc_of_shr_record mrs)) (H1 : truncate radix2 f (m, e, l) = (m', e', l')) : snd (shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e)) =\nsnd (fst (truncate radix2 f (m, e, l))).","conclusion":"snd (shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e)) =\nsnd (fst (truncate radix2 f (m, e, l)))","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.pos p) (x : R) (Hx : inbetween_float radix2 m e x l) (Hx0 : (0 <= x)%R) (mrs : shr_record) (e'' : Z) (H3 : shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e) = (mrs, e'')) (H4 : inbetween_float radix2 (shr_m mrs) e'' x (loc_of_shr_record mrs)) (H1 : truncate radix2 f (m, e, l) = (m', e', l'))","proofString":"unfold truncate.\nnow rewrite Hp."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.pos p) (x : R) (Hx : inbetween_float radix2 m e x l) (Hx0 : (0 <= x)%R) (mrs : shr_record) (e'' : Z) (H3 : shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e) = (mrs, e'')) (H4 : inbetween_float radix2 (shr_m mrs) e'' x (loc_of_shr_record mrs)) (H1 : truncate radix2 f (m, e, l) = (m', e', l')) : snd (shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e)) =\nsnd\n  (fst\n     (if (0 <? f (Zdigits radix2 m + e) - e)%Z\n      then truncate_aux radix2 (m, e, l) (f (Zdigits radix2 m + e)%Z - e)\n      else (m, e, l))).","conclusion":"snd (shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e)) =\nsnd\n  (fst\n     (if (0 <? f (Zdigits radix2 m + e) - e)%Z\n      then truncate_aux radix2 (m, e, l) (f (Zdigits radix2 m + e)%Z - e)\n      else (m, e, l)))","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.pos p) (x : R) (Hx : inbetween_float radix2 m e x l) (Hx0 : (0 <= x)%R) (mrs : shr_record) (e'' : Z) (H3 : shr (shr_record_of_loc m l) e (f (Zdigits radix2 m + e)%Z - e) = (mrs, e'')) (H4 : inbetween_float radix2 (shr_m mrs) e'' x (loc_of_shr_record mrs)) (H1 : truncate radix2 f (m, e, l) = (m', e', l'))","proofString":"now rewrite Hp."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.neg p) : truncate radix2 f (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (Z.neg p) = (shr_record_of_loc m' l', e').","conclusion":"truncate radix2 f (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (Z.neg p) = (shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.neg p)","proofString":"unfold truncate.\nrewrite Hp.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.neg p) : (if (0 <? f (Zdigits radix2 m + e) - e)%Z\n then truncate_aux radix2 (m, e, l) (f (Zdigits radix2 m + e)%Z - e)\n else (m, e, l)) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (Z.neg p) = (shr_record_of_loc m' l', e').","conclusion":"(if (0 <? f (Zdigits radix2 m + e) - e)%Z\n then truncate_aux radix2 (m, e, l) (f (Zdigits radix2 m + e)%Z - e)\n else (m, e, l)) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (Z.neg p) = (shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.neg p)","proofString":"rewrite Hp.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.neg p) : (if (0 <? Z.neg p)%Z\n then truncate_aux radix2 (m, e, l) (Z.neg p)\n else (m, e, l)) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (Z.neg p) = (shr_record_of_loc m' l', e').","conclusion":"(if (0 <? Z.neg p)%Z\n then truncate_aux radix2 (m, e, l) (Z.neg p)\n else (m, e, l)) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (Z.neg p) = (shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.neg p)","proofString":"simpl.\nintros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.neg p) : (m, e, l) = (m', e', l') ->\n(shr_record_of_loc m l, e) = (shr_record_of_loc m' l', e').","conclusion":"(m, e, l) = (m', e', l') ->\n(shr_record_of_loc m l, e) = (shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.neg p)","proofString":"intros H.\nnow inversion H."},{"statement":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.neg p) (H : (m, e, l) = (m', e', l')) : (shr_record_of_loc m l, e) = (shr_record_of_loc m' l', e').","conclusion":"(shr_record_of_loc m l, e) = (shr_record_of_loc m' l', e')","hypotheses":"(f : Z -> Z) (m e : Z) (l : location) (Hf : Valid_exp f) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (f (Zdigits radix2 m + e) - e)%Z = Z.neg p) (H : (m, e, l) = (m', e', l'))","proofString":"now inversion H."},{"statement":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) : shr_fexp m e l =\n(let\n '(m', e', l') := truncate radix2 fexp (m, e, l) in\n  (shr_record_of_loc m' l', e')).","conclusion":"shr_fexp m e l =\n(let\n '(m', e', l') := truncate radix2 fexp (m, e, l) in\n  (shr_record_of_loc m' l', e'))","hypotheses":"(m e : Z) (l : location) (Hm : (0 <= m)%Z)","proofString":"case_eq (truncate radix2 fexp (m, e, l)).\nintros (m', e') l'.\nunfold shr_fexp.\nrewrite Zdigits2_Zdigits.\ncase_eq (fexp (Zdigits radix2 m + e) - e)%Z.\nintros He.\nunfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H.\nintros p Hp.\nassert (He: (e <= fexp (Zdigits radix2 m + e))%Z).\nclear -Hp ; lia.\ndestruct (inbetween_float_ex radix2 m e l) as (x, Hx).\ngeneralize (inbetween_shr x m e l (fexp (Zdigits radix2 m + e) - e) Hm Hx).\nassert (Hx0 : (0 <= x)%R).\napply Rle_trans with (F2R (Float radix2 m e)).\nnow apply F2R_ge_0.\nexact (proj1 (inbetween_float_bounds _ _ _ _ _ Hx)).\ncase_eq (shr (shr_record_of_loc m l) e (fexp (Zdigits radix2 m + e) - e)).\nintros mrs e'' H3 H4 H1.\ngeneralize (truncate_correct radix2 _ x m e l Hx0 Hx (or_introl _ He)).\nrewrite H1.\nintros (H2,_).\nrewrite <- Hp, H3.\nassert (e'' = e').\nchange (snd (mrs, e'') = snd (fst (m',e',l'))).\nrewrite <- H1, <- H3.\nunfold truncate.\nnow rewrite Hp.\nrewrite H in H4 |- *.\napply (f_equal (fun v => (v, _))).\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ H2 H4) as (H5, H6).\nrewrite H5, H6.\ncase mrs.\nnow intros m0 [|] [|].\nintros p Hp.\nunfold truncate.\nrewrite Hp.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) : forall (p : Z * Z) (l0 : location),\ntruncate radix2 fexp (m, e, l) = (p, l0) ->\nshr_fexp m e l = (let '(m', e') := p in (shr_record_of_loc m' l0, e')).","conclusion":"forall (p : Z * Z) (l0 : location),\ntruncate radix2 fexp (m, e, l) = (p, l0) ->\nshr_fexp m e l = (let '(m', e') := p in (shr_record_of_loc m' l0, e'))","hypotheses":"(m e : Z) (l : location) (Hm : (0 <= m)%Z)","proofString":"intros (m', e') l'.\nunfold shr_fexp.\nrewrite Zdigits2_Zdigits.\ncase_eq (fexp (Zdigits radix2 m + e) - e)%Z.\nintros He.\nunfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H.\nintros p Hp.\nassert (He: (e <= fexp (Zdigits radix2 m + e))%Z).\nclear -Hp ; lia.\ndestruct (inbetween_float_ex radix2 m e l) as (x, Hx).\ngeneralize (inbetween_shr x m e l (fexp (Zdigits radix2 m + e) - e) Hm Hx).\nassert (Hx0 : (0 <= x)%R).\napply Rle_trans with (F2R (Float radix2 m e)).\nnow apply F2R_ge_0.\nexact (proj1 (inbetween_float_bounds _ _ _ _ _ Hx)).\ncase_eq (shr (shr_record_of_loc m l) e (fexp (Zdigits radix2 m + e) - e)).\nintros mrs e'' H3 H4 H1.\ngeneralize (truncate_correct radix2 _ x m e l Hx0 Hx (or_introl _ He)).\nrewrite H1.\nintros (H2,_).\nrewrite <- Hp, H3.\nassert (e'' = e').\nchange (snd (mrs, e'') = snd (fst (m',e',l'))).\nrewrite <- H1, <- H3.\nunfold truncate.\nnow rewrite Hp.\nrewrite H in H4 |- *.\napply (f_equal (fun v => (v, _))).\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ H2 H4) as (H5, H6).\nrewrite H5, H6.\ncase mrs.\nnow intros m0 [|] [|].\nintros p Hp.\nunfold truncate.\nrewrite Hp.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) : truncate radix2 fexp (m, e, l) = (m', e', l') ->\nshr_fexp m e l = (shr_record_of_loc m' l', e').","conclusion":"truncate radix2 fexp (m, e, l) = (m', e', l') ->\nshr_fexp m e l = (shr_record_of_loc m' l', e')","hypotheses":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location)","proofString":"unfold shr_fexp.\nrewrite Zdigits2_Zdigits.\ncase_eq (fexp (Zdigits radix2 m + e) - e)%Z.\nintros He.\nunfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H.\nintros p Hp.\nassert (He: (e <= fexp (Zdigits radix2 m + e))%Z).\nclear -Hp ; lia.\ndestruct (inbetween_float_ex radix2 m e l) as (x, Hx).\ngeneralize (inbetween_shr x m e l (fexp (Zdigits radix2 m + e) - e) Hm Hx).\nassert (Hx0 : (0 <= x)%R).\napply Rle_trans with (F2R (Float radix2 m e)).\nnow apply F2R_ge_0.\nexact (proj1 (inbetween_float_bounds _ _ _ _ _ Hx)).\ncase_eq (shr (shr_record_of_loc m l) e (fexp (Zdigits radix2 m + e) - e)).\nintros mrs e'' H3 H4 H1.\ngeneralize (truncate_correct radix2 _ x m e l Hx0 Hx (or_introl _ He)).\nrewrite H1.\nintros (H2,_).\nrewrite <- Hp, H3.\nassert (e'' = e').\nchange (snd (mrs, e'') = snd (fst (m',e',l'))).\nrewrite <- H1, <- H3.\nunfold truncate.\nnow rewrite Hp.\nrewrite H in H4 |- *.\napply (f_equal (fun v => (v, _))).\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ H2 H4) as (H5, H6).\nrewrite H5, H6.\ncase mrs.\nnow intros m0 [|] [|].\nintros p Hp.\nunfold truncate.\nrewrite Hp.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) : truncate radix2 fexp (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (fexp (Zdigits2 m + e) - e) =\n(shr_record_of_loc m' l', e').","conclusion":"truncate radix2 fexp (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (fexp (Zdigits2 m + e) - e) =\n(shr_record_of_loc m' l', e')","hypotheses":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location)","proofString":"rewrite Zdigits2_Zdigits.\ncase_eq (fexp (Zdigits radix2 m + e) - e)%Z.\nintros He.\nunfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H.\nintros p Hp.\nassert (He: (e <= fexp (Zdigits radix2 m + e))%Z).\nclear -Hp ; lia.\ndestruct (inbetween_float_ex radix2 m e l) as (x, Hx).\ngeneralize (inbetween_shr x m e l (fexp (Zdigits radix2 m + e) - e) Hm Hx).\nassert (Hx0 : (0 <= x)%R).\napply Rle_trans with (F2R (Float radix2 m e)).\nnow apply F2R_ge_0.\nexact (proj1 (inbetween_float_bounds _ _ _ _ _ Hx)).\ncase_eq (shr (shr_record_of_loc m l) e (fexp (Zdigits radix2 m + e) - e)).\nintros mrs e'' H3 H4 H1.\ngeneralize (truncate_correct radix2 _ x m e l Hx0 Hx (or_introl _ He)).\nrewrite H1.\nintros (H2,_).\nrewrite <- Hp, H3.\nassert (e'' = e').\nchange (snd (mrs, e'') = snd (fst (m',e',l'))).\nrewrite <- H1, <- H3.\nunfold truncate.\nnow rewrite Hp.\nrewrite H in H4 |- *.\napply (f_equal (fun v => (v, _))).\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ H2 H4) as (H5, H6).\nrewrite H5, H6.\ncase mrs.\nnow intros m0 [|] [|].\nintros p Hp.\nunfold truncate.\nrewrite Hp.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) : truncate radix2 fexp (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (fexp (Zdigits radix2 m + e) - e) =\n(shr_record_of_loc m' l', e').","conclusion":"truncate radix2 fexp (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e (fexp (Zdigits radix2 m + e) - e) =\n(shr_record_of_loc m' l', e')","hypotheses":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location)","proofString":"case_eq (fexp (Zdigits radix2 m + e) - e)%Z.\nintros He.\nunfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H.\nintros p Hp.\nassert (He: (e <= fexp (Zdigits radix2 m + e))%Z).\nclear -Hp ; lia.\ndestruct (inbetween_float_ex radix2 m e l) as (x, Hx).\ngeneralize (inbetween_shr x m e l (fexp (Zdigits radix2 m + e) - e) Hm Hx).\nassert (Hx0 : (0 <= x)%R).\napply Rle_trans with (F2R (Float radix2 m e)).\nnow apply F2R_ge_0.\nexact (proj1 (inbetween_float_bounds _ _ _ _ _ Hx)).\ncase_eq (shr (shr_record_of_loc m l) e (fexp (Zdigits radix2 m + e) - e)).\nintros mrs e'' H3 H4 H1.\ngeneralize (truncate_correct radix2 _ x m e l Hx0 Hx (or_introl _ He)).\nrewrite H1.\nintros (H2,_).\nrewrite <- Hp, H3.\nassert (e'' = e').\nchange (snd (mrs, e'') = snd (fst (m',e',l'))).\nrewrite <- H1, <- H3.\nunfold truncate.\nnow rewrite Hp.\nrewrite H in H4 |- *.\napply (f_equal (fun v => (v, _))).\ndestruct (inbetween_float_unique _ _ _ _ _ _ _ H2 H4) as (H5, H6).\nrewrite H5, H6.\ncase mrs.\nnow intros m0 [|] [|].\nintros p Hp.\nunfold truncate.\nrewrite Hp.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) : (fexp (Zdigits radix2 m + e) - e)%Z = 0%Z ->\ntruncate radix2 fexp (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e').","conclusion":"(fexp (Zdigits radix2 m + e) - e)%Z = 0%Z ->\ntruncate radix2 fexp (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e')","hypotheses":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location)","proofString":"intros He.\nunfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (fexp (Zdigits radix2 m + e) - e)%Z = 0%Z) : truncate radix2 fexp (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e').","conclusion":"truncate radix2 fexp (m, e, l) = (m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e')","hypotheses":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (fexp (Zdigits radix2 m + e) - e)%Z = 0%Z)","proofString":"unfold truncate.\nrewrite He.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (fexp (Zdigits radix2 m + e) - e)%Z = 0%Z) : (if (0 <? fexp (Zdigits radix2 m + e) - e)%Z\n then truncate_aux radix2 (m, e, l) (fexp (Zdigits radix2 m + e) - e)\n else (m, e, l)) = (m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e').","conclusion":"(if (0 <? fexp (Zdigits radix2 m + e) - e)%Z\n then truncate_aux radix2 (m, e, l) (fexp (Zdigits radix2 m + e) - e)\n else (m, e, l)) = (m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e')","hypotheses":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (fexp (Zdigits radix2 m + e) - e)%Z = 0%Z)","proofString":"rewrite He.\nsimpl.\nintros H.\nnow inversion H."},{"statement":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (fexp (Zdigits radix2 m + e) - e)%Z = 0%Z) : (if (0 <? 0)%Z then truncate_aux radix2 (m, e, l) 0 else (m, e, l)) =\n(m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e').","conclusion":"(if (0 <? 0)%Z then truncate_aux radix2 (m, e, l) 0 else (m, e, l)) =\n(m', e', l') ->\nshr (shr_record_of_loc m l) e 0 = (shr_record_of_loc m' l', e')","hypotheses":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (fexp (Zdigits radix2 m + e) - e)%Z = 0%Z)","proofString":"simpl.\nintros H.\nnow inversion H."},{"statement":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (fexp (Zdigits radix2 m + e) - e)%Z = 0%Z) : (m, e, l) = (m', e', l') ->\n(shr_record_of_loc m l, e) = (shr_record_of_loc m' l', e').","conclusion":"(m, e, l) = (m', e', l') ->\n(shr_record_of_loc m l, e) = (shr_record_of_loc m' l', e')","hypotheses":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (fexp (Zdigits radix2 m + e) - e)%Z = 0%Z)","proofString":"intros H.\nnow inversion H."},{"statement":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (fexp (Zdigits radix2 m + e) - e)%Z = 0%Z) (H : (m, e, l) = (m', e', l')) : (shr_record_of_loc m l, e) = (shr_record_of_loc m' l', e').","conclusion":"(shr_record_of_loc m l, e) = (shr_record_of_loc m' l', e')","hypotheses":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (He : (fexp (Zdigits radix2 m + e) - e)%Z = 0%Z) (H : (m, e, l) = (m', e', l'))","proofString":"now inversion H."},{"statement":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (fexp (Zdigits radix2 m + e) - e)%Z = Z.pos p) (x : R) (Hx : inbetween_float radix2 m e x l) : (0 <= x)%R.","conclusion":"(0 <= x)%R","hypotheses":"(m e : Z) (l : location) (Hm : (0 <= m)%Z) (m' e' : Z) (l' : location) (p : positive) (Hp : (fexp (Zdigits radix2 m + e) - e)%Z = Z.pos p) (x : R) (Hx : inbetween_float radix2 m e x l)","proofString":"apply Rle_trans with (F2R (Float radix2 m e)).\nnow apply F2R_ge_0.\nexact (proj1 (inbetween_float_bounds _ _ _ _ _ Hx))."},{"statement":"forall (x : R) (m : Z) (l : location),\ninbetween_int m (Rabs x) l ->\nround_mode mode_NE x =\ncond_Zopp (Rlt_bool x 0) (choice_mode mode_NE (Rlt_bool x 0) m l).","conclusion":"forall (x : R) (m : Z) (l : location),\ninbetween_int m (Rabs x) l ->\nround_mode mode_NE x =\ncond_Zopp (Rlt_bool x 0) (choice_mode mode_NE (Rlt_bool x 0) m l)","hypotheses":"","proofString":"exact inbetween_int_NE_sign."},{"statement":"forall (x : R) (m : Z) (l : location),\ninbetween_int m (Rabs x) l ->\nround_mode mode_ZR x =\ncond_Zopp (Rlt_bool x 0) (choice_mode mode_ZR (Rlt_bool x 0) m l).","conclusion":"forall (x : R) (m : Z) (l : location),\ninbetween_int m (Rabs x) l ->\nround_mode mode_ZR x =\ncond_Zopp (Rlt_bool x 0) (choice_mode mode_ZR (Rlt_bool x 0) m l)","hypotheses":"","proofString":"exact inbetween_int_ZR_sign."},{"statement":"forall (x : R) (m : Z) (l : location),\ninbetween_int m (Rabs x) l ->\nround_mode mode_DN x =\ncond_Zopp (Rlt_bool x 0) (choice_mode mode_DN (Rlt_bool x 0) m l).","conclusion":"forall (x : R) (m : Z) (l : location),\ninbetween_int m (Rabs x) l ->\nround_mode mode_DN x =\ncond_Zopp (Rlt_bool x 0) (choice_mode mode_DN (Rlt_bool x 0) m l)","hypotheses":"","proofString":"exact inbetween_int_DN_sign."},{"statement":"forall (x : R) (m : Z) (l : location),\ninbetween_int m (Rabs x) l ->\nround_mode mode_UP x =\ncond_Zopp (Rlt_bool x 0) (choice_mode mode_UP (Rlt_bool x 0) m l).","conclusion":"forall (x : R) (m : Z) (l : location),\ninbetween_int m (Rabs x) l ->\nround_mode mode_UP x =\ncond_Zopp (Rlt_bool x 0) (choice_mode mode_UP (Rlt_bool x 0) m l)","hypotheses":"","proofString":"exact inbetween_int_UP_sign."},{"statement":"forall (x : R) (m : Z) (l : location),\ninbetween_int m (Rabs x) l ->\nround_mode mode_NA x =\ncond_Zopp (Rlt_bool x 0) (choice_mode mode_NA (Rlt_bool x 0) m l).","conclusion":"forall (x : R) (m : Z) (l : location),\ninbetween_int m (Rabs x) l ->\nround_mode mode_NA x =\ncond_Zopp (Rlt_bool x 0) (choice_mode mode_NA (Rlt_bool x 0) m l)","hypotheses":"","proofString":"exact inbetween_int_NA_sign."},{"statement":"(mode : Binary.mode) (s : bool) : is_nan_SF (binary_overflow mode s) = false.","conclusion":"is_nan_SF (binary_overflow mode s) = false","hypotheses":"(mode : Binary.mode) (s : bool)","proofString":"unfold binary_overflow.\nnow destruct overflow_to_inf."},{"statement":"(mode : Binary.mode) (s : bool) : is_nan_SF\n  (if overflow_to_inf mode s\n   then S754_infinity s\n   else S754_finite s (Z.to_pos (2 ^ prec - 1)) (emax - prec)) = false.","conclusion":"is_nan_SF\n  (if overflow_to_inf mode s\n   then S754_infinity s\n   else S754_finite s (Z.to_pos (2 ^ prec - 1)) (emax - prec)) = false","hypotheses":"(mode : Binary.mode) (s : bool)","proofString":"now destruct overflow_to_inf."},{"statement":"(m : mode) (s : bool) : valid_binary (binary_overflow m s) = true.","conclusion":"valid_binary (binary_overflow m s) = true","hypotheses":"(m : mode) (s : bool)","proofString":"unfold binary_overflow.\ncase overflow_to_inf.\neasy.\nunfold valid_binary, bounded.\nrewrite Zle_bool_refl.\nrewrite Bool.andb_true_r.\napply Zeq_bool_true.\nrewrite Zpos_digits2_pos.\nreplace (Zdigits radix2 _) with prec.\nring_simplify (prec + (emax - prec))%Z.\napply fexp_emax.\nchange 2%Z with (radix_val radix2).\nassert (H: (0 < radix2 ^ prec - 1)%Z).\napply Zlt_succ_pred.\nnow apply Zpower_gt_1.\nrewrite Z2Pos.id by exact H.\napply Zle_antisym.\napply Z.lt_pred_le.\napply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\napply Zdigits_le_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) : valid_binary\n  (if overflow_to_inf m s\n   then S754_infinity s\n   else S754_finite s (Z.to_pos (2 ^ prec - 1)) (emax - prec)) = true.","conclusion":"valid_binary\n  (if overflow_to_inf m s\n   then S754_infinity s\n   else S754_finite s (Z.to_pos (2 ^ prec - 1)) (emax - prec)) = true","hypotheses":"(m : mode) (s : bool)","proofString":"case overflow_to_inf.\neasy.\nunfold valid_binary, bounded.\nrewrite Zle_bool_refl.\nrewrite Bool.andb_true_r.\napply Zeq_bool_true.\nrewrite Zpos_digits2_pos.\nreplace (Zdigits radix2 _) with prec.\nring_simplify (prec + (emax - prec))%Z.\napply fexp_emax.\nchange 2%Z with (radix_val radix2).\nassert (H: (0 < radix2 ^ prec - 1)%Z).\napply Zlt_succ_pred.\nnow apply Zpower_gt_1.\nrewrite Z2Pos.id by exact H.\napply Zle_antisym.\napply Z.lt_pred_le.\napply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\napply Zdigits_le_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) : valid_binary (S754_infinity s) = true.","conclusion":"valid_binary (S754_infinity s) = true","hypotheses":"(m : mode) (s : bool)","proofString":"easy."},{"statement":"(m : mode) (s : bool) : valid_binary (S754_finite s (Z.to_pos (2 ^ prec - 1)) (emax - prec)) = true.","conclusion":"valid_binary (S754_finite s (Z.to_pos (2 ^ prec - 1)) (emax - prec)) = true","hypotheses":"(m : mode) (s : bool)","proofString":"unfold valid_binary, bounded.\nrewrite Zle_bool_refl.\nrewrite Bool.andb_true_r.\napply Zeq_bool_true.\nrewrite Zpos_digits2_pos.\nreplace (Zdigits radix2 _) with prec.\nring_simplify (prec + (emax - prec))%Z.\napply fexp_emax.\nchange 2%Z with (radix_val radix2).\nassert (H: (0 < radix2 ^ prec - 1)%Z).\napply Zlt_succ_pred.\nnow apply Zpower_gt_1.\nrewrite Z2Pos.id by exact H.\napply Zle_antisym.\napply Z.lt_pred_le.\napply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\napply Zdigits_le_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) : (canonical_mantissa (Z.to_pos (2 ^ prec - 1)) (emax - prec) &&\n (emax - prec <=? emax - prec)%Z)%bool = true.","conclusion":"(canonical_mantissa (Z.to_pos (2 ^ prec - 1)) (emax - prec) &&\n (emax - prec <=? emax - prec)%Z)%bool = true","hypotheses":"(m : mode) (s : bool)","proofString":"rewrite Zle_bool_refl.\nrewrite Bool.andb_true_r.\napply Zeq_bool_true.\nrewrite Zpos_digits2_pos.\nreplace (Zdigits radix2 _) with prec.\nring_simplify (prec + (emax - prec))%Z.\napply fexp_emax.\nchange 2%Z with (radix_val radix2).\nassert (H: (0 < radix2 ^ prec - 1)%Z).\napply Zlt_succ_pred.\nnow apply Zpower_gt_1.\nrewrite Z2Pos.id by exact H.\napply Zle_antisym.\napply Z.lt_pred_le.\napply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\napply Zdigits_le_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) : (canonical_mantissa (Z.to_pos (2 ^ prec - 1)) (emax - prec) && true)%bool =\ntrue.","conclusion":"(canonical_mantissa (Z.to_pos (2 ^ prec - 1)) (emax - prec) && true)%bool =\ntrue","hypotheses":"(m : mode) (s : bool)","proofString":"rewrite Bool.andb_true_r.\napply Zeq_bool_true.\nrewrite Zpos_digits2_pos.\nreplace (Zdigits radix2 _) with prec.\nring_simplify (prec + (emax - prec))%Z.\napply fexp_emax.\nchange 2%Z with (radix_val radix2).\nassert (H: (0 < radix2 ^ prec - 1)%Z).\napply Zlt_succ_pred.\nnow apply Zpower_gt_1.\nrewrite Z2Pos.id by exact H.\napply Zle_antisym.\napply Z.lt_pred_le.\napply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\napply Zdigits_le_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) : canonical_mantissa (Z.to_pos (2 ^ prec - 1)) (emax - prec) = true.","conclusion":"canonical_mantissa (Z.to_pos (2 ^ prec - 1)) (emax - prec) = true","hypotheses":"(m : mode) (s : bool)","proofString":"apply Zeq_bool_true.\nrewrite Zpos_digits2_pos.\nreplace (Zdigits radix2 _) with prec.\nring_simplify (prec + (emax - prec))%Z.\napply fexp_emax.\nchange 2%Z with (radix_val radix2).\nassert (H: (0 < radix2 ^ prec - 1)%Z).\napply Zlt_succ_pred.\nnow apply Zpower_gt_1.\nrewrite Z2Pos.id by exact H.\napply Zle_antisym.\napply Z.lt_pred_le.\napply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\napply Zdigits_le_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) : fexp (Z.pos (digits2_pos (Z.to_pos (2 ^ prec - 1))) + (emax - prec)) =\n(emax - prec)%Z.","conclusion":"fexp (Z.pos (digits2_pos (Z.to_pos (2 ^ prec - 1))) + (emax - prec)) =\n(emax - prec)%Z","hypotheses":"(m : mode) (s : bool)","proofString":"rewrite Zpos_digits2_pos.\nreplace (Zdigits radix2 _) with prec.\nring_simplify (prec + (emax - prec))%Z.\napply fexp_emax.\nchange 2%Z with (radix_val radix2).\nassert (H: (0 < radix2 ^ prec - 1)%Z).\napply Zlt_succ_pred.\nnow apply Zpower_gt_1.\nrewrite Z2Pos.id by exact H.\napply Zle_antisym.\napply Z.lt_pred_le.\napply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\napply Zdigits_le_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) : fexp (Zdigits radix2 (Z.pos (Z.to_pos (2 ^ prec - 1))) + (emax - prec)) =\n(emax - prec)%Z.","conclusion":"fexp (Zdigits radix2 (Z.pos (Z.to_pos (2 ^ prec - 1))) + (emax - prec)) =\n(emax - prec)%Z","hypotheses":"(m : mode) (s : bool)","proofString":"replace (Zdigits radix2 _) with prec.\nring_simplify (prec + (emax - prec))%Z.\napply fexp_emax.\nchange 2%Z with (radix_val radix2).\nassert (H: (0 < radix2 ^ prec - 1)%Z).\napply Zlt_succ_pred.\nnow apply Zpower_gt_1.\nrewrite Z2Pos.id by exact H.\napply Zle_antisym.\napply Z.lt_pred_le.\napply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\napply Zdigits_le_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) : fexp (prec + (emax - prec)) = (emax - prec)%Z.","conclusion":"fexp (prec + (emax - prec)) = (emax - prec)%Z","hypotheses":"(m : mode) (s : bool)","proofString":"ring_simplify (prec + (emax - prec))%Z.\napply fexp_emax."},{"statement":"(m : mode) (s : bool) : fexp emax = (emax - prec)%Z.","conclusion":"fexp emax = (emax - prec)%Z","hypotheses":"(m : mode) (s : bool)","proofString":"apply fexp_emax."},{"statement":"(m : mode) (s : bool) : prec = Zdigits radix2 (Z.pos (Z.to_pos (2 ^ prec - 1))).","conclusion":"prec = Zdigits radix2 (Z.pos (Z.to_pos (2 ^ prec - 1)))","hypotheses":"(m : mode) (s : bool)","proofString":"change 2%Z with (radix_val radix2).\nassert (H: (0 < radix2 ^ prec - 1)%Z).\napply Zlt_succ_pred.\nnow apply Zpower_gt_1.\nrewrite Z2Pos.id by exact H.\napply Zle_antisym.\napply Z.lt_pred_le.\napply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\napply Zdigits_le_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) : prec = Zdigits radix2 (Z.pos (Z.to_pos (radix2 ^ prec - 1))).","conclusion":"prec = Zdigits radix2 (Z.pos (Z.to_pos (radix2 ^ prec - 1)))","hypotheses":"(m : mode) (s : bool)","proofString":"assert (H: (0 < radix2 ^ prec - 1)%Z).\napply Zlt_succ_pred.\nnow apply Zpower_gt_1.\nrewrite Z2Pos.id by exact H.\napply Zle_antisym.\napply Z.lt_pred_le.\napply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\napply Zdigits_le_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) : (0 < radix2 ^ prec - 1)%Z.","conclusion":"(0 < radix2 ^ prec - 1)%Z","hypotheses":"(m : mode) (s : bool)","proofString":"apply Zlt_succ_pred.\nnow apply Zpower_gt_1."},{"statement":"(m : mode) (s : bool) : (Z.succ 0 < radix2 ^ prec)%Z.","conclusion":"(Z.succ 0 < radix2 ^ prec)%Z","hypotheses":"(m : mode) (s : bool)","proofString":"now apply Zpower_gt_1."},{"statement":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z) : prec = Zdigits radix2 (Z.pos (Z.to_pos (radix2 ^ prec - 1))).","conclusion":"prec = Zdigits radix2 (Z.pos (Z.to_pos (radix2 ^ prec - 1)))","hypotheses":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z)","proofString":"rewrite Z2Pos.id by exact H.\napply Zle_antisym.\napply Z.lt_pred_le.\napply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\napply Zdigits_le_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z) : prec = Zdigits radix2 (radix2 ^ prec - 1).","conclusion":"prec = Zdigits radix2 (radix2 ^ prec - 1)","hypotheses":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z)","proofString":"apply Zle_antisym.\napply Z.lt_pred_le.\napply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\napply Zdigits_le_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z) : (prec <= Zdigits radix2 (radix2 ^ prec - 1))%Z.","conclusion":"(prec <= Zdigits radix2 (radix2 ^ prec - 1))%Z","hypotheses":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z)","proofString":"apply Z.lt_pred_le.\napply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z) : (Z.pred prec < Zdigits radix2 (radix2 ^ prec - 1))%Z.","conclusion":"(Z.pred prec < Zdigits radix2 (radix2 ^ prec - 1))%Z","hypotheses":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z)","proofString":"apply Zdigits_gt_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z) : (radix2 ^ Z.pred prec <= Z.abs (radix2 ^ prec - 1))%Z.","conclusion":"(radix2 ^ Z.pred prec <= Z.abs (radix2 ^ prec - 1))%Z","hypotheses":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z)","proofString":"rewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z) : (radix2 ^ Z.pred prec <= radix2 ^ prec - 1)%Z.","conclusion":"(radix2 ^ Z.pred prec <= radix2 ^ prec - 1)%Z","hypotheses":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z)","proofString":"apply Z.lt_le_pred.\napply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z) : (radix2 ^ Z.pred prec < radix2 ^ prec)%Z.","conclusion":"(radix2 ^ Z.pred prec < radix2 ^ prec)%Z","hypotheses":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z)","proofString":"apply Zpower_lt.\nnow apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z) : (0 <= prec)%Z.","conclusion":"(0 <= prec)%Z","hypotheses":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z)","proofString":"now apply Zlt_le_weak."},{"statement":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z) : (Z.pred prec < prec)%Z.","conclusion":"(Z.pred prec < prec)%Z","hypotheses":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z)","proofString":"apply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z) : (Zdigits radix2 (radix2 ^ prec - 1) <= prec)%Z.","conclusion":"(Zdigits radix2 (radix2 ^ prec - 1) <= prec)%Z","hypotheses":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z)","proofString":"apply Zdigits_le_Zpower.\nrewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z) : (Z.abs (radix2 ^ prec - 1) < radix2 ^ prec)%Z.","conclusion":"(Z.abs (radix2 ^ prec - 1) < radix2 ^ prec)%Z","hypotheses":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z)","proofString":"rewrite Z.abs_eq by now apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z) : (radix2 ^ prec - 1 < radix2 ^ prec)%Z.","conclusion":"(radix2 ^ prec - 1 < radix2 ^ prec)%Z","hypotheses":"(m : mode) (s : bool) (H : (0 < radix2 ^ prec - 1)%Z)","proofString":"apply Z.lt_pred_l."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) : let x := SF2R radix2 (S754_finite sx mx ex) in\nlet z := binary_fit_aux m sx mx ex in\nvalid_binary z = true /\\\n(if Rlt_bool (Rabs x) (bpow radix2 emax)\n then SF2R radix2 z = x /\\ is_finite_SF z = true /\\ sign_SF z = sx\n else z = binary_overflow m sx).","conclusion":"let x := SF2R radix2 (S754_finite sx mx ex) in\nlet z := binary_fit_aux m sx mx ex in\nvalid_binary z = true /\\\n(if Rlt_bool (Rabs x) (bpow radix2 emax)\n then SF2R radix2 z = x /\\ is_finite_SF z = true /\\ sign_SF z = sx\n else z = binary_overflow m sx)","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true)","proofString":"unfold binary_fit_aux.\nsimpl.\nrewrite F2R_cond_Zopp.\nrewrite abs_cond_Ropp.\nrewrite Rabs_pos_eq by now apply F2R_ge_0.\ndestruct Zle_bool eqn:He.\nassert (Hb: bounded mx ex = true).\nunfold bounded.\nnow rewrite Cx.\napply (conj Hb).\nrewrite Rlt_bool_true.\nrepeat split.\napply F2R_cond_Zopp.\nnow apply bounded_lt_emax.\nrewrite Rlt_bool_false.\nrepeat split.\napply binary_overflow_correct.\napply Rnot_lt_le.\nintros Hx.\napply bounded_canonical_lt_emax in Hx.\nrevert Hx.\nunfold bounded.\nnow rewrite Cx, He.\nnow apply (canonical_canonical_mantissa false)."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) : valid_binary\n  (if (ex <=? emax - prec)%Z\n   then S754_finite sx mx ex\n   else binary_overflow m sx) = true /\\\n(if Rlt_bool (Rabs (SF2R radix2 (S754_finite sx mx ex))) (bpow radix2 emax)\n then\n  SF2R radix2\n    (if (ex <=? emax - prec)%Z\n     then S754_finite sx mx ex\n     else binary_overflow m sx) = SF2R radix2 (S754_finite sx mx ex) /\\\n  is_finite_SF\n    (if (ex <=? emax - prec)%Z\n     then S754_finite sx mx ex\n     else binary_overflow m sx) = true /\\\n  sign_SF\n    (if (ex <=? emax - prec)%Z\n     then S754_finite sx mx ex\n     else binary_overflow m sx) = sx\n else\n  (if (ex <=? emax - prec)%Z\n   then S754_finite sx mx ex\n   else binary_overflow m sx) = binary_overflow m sx).","conclusion":"valid_binary\n  (if (ex <=? emax - prec)%Z\n   then S754_finite sx mx ex\n   else binary_overflow m sx) = true /\\\n(if Rlt_bool (Rabs (SF2R radix2 (S754_finite sx mx ex))) (bpow radix2 emax)\n then\n  SF2R radix2\n    (if (ex <=? emax - prec)%Z\n     then S754_finite sx mx ex\n     else binary_overflow m sx) = SF2R radix2 (S754_finite sx mx ex) /\\\n  is_finite_SF\n    (if (ex <=? emax - prec)%Z\n     then S754_finite sx mx ex\n     else binary_overflow m sx) = true /\\\n  sign_SF\n    (if (ex <=? emax - prec)%Z\n     then S754_finite sx mx ex\n     else binary_overflow m sx) = sx\n else\n  (if (ex <=? emax - prec)%Z\n   then S754_finite sx mx ex\n   else binary_overflow m sx) = binary_overflow m sx)","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true)","proofString":"simpl.\nrewrite F2R_cond_Zopp.\nrewrite abs_cond_Ropp.\nrewrite Rabs_pos_eq by now apply F2R_ge_0.\ndestruct Zle_bool eqn:He.\nassert (Hb: bounded mx ex = true).\nunfold bounded.\nnow rewrite Cx.\napply (conj Hb).\nrewrite Rlt_bool_true.\nrepeat split.\napply F2R_cond_Zopp.\nnow apply bounded_lt_emax.\nrewrite Rlt_bool_false.\nrepeat split.\napply binary_overflow_correct.\napply Rnot_lt_le.\nintros Hx.\napply bounded_canonical_lt_emax in Hx.\nrevert Hx.\nunfold bounded.\nnow rewrite Cx, He.\nnow apply (canonical_canonical_mantissa false)."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = true) : bounded mx ex = true.","conclusion":"bounded mx ex = true","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = true)","proofString":"unfold bounded.\nnow rewrite Cx."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = true) : (canonical_mantissa mx ex && (ex <=? emax - prec)%Z)%bool = true.","conclusion":"(canonical_mantissa mx ex && (ex <=? emax - prec)%Z)%bool = true","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = true)","proofString":"now rewrite Cx."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = false) : valid_binary (binary_overflow m sx) = true /\\\nbinary_overflow m sx = binary_overflow m sx.","conclusion":"valid_binary (binary_overflow m sx) = true /\\\nbinary_overflow m sx = binary_overflow m sx","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = false)","proofString":"repeat split.\napply binary_overflow_correct."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = false) : valid_binary (binary_overflow m sx) = true.","conclusion":"valid_binary (binary_overflow m sx) = true","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = false)","proofString":"apply binary_overflow_correct."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = false) (Hx : bounded mx ex = true) : False.","conclusion":"False","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = false) (Hx : bounded mx ex = true)","proofString":"revert Hx.\nunfold bounded.\nnow rewrite Cx, He."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = false) : bounded mx ex = true -> False.","conclusion":"bounded mx ex = true -> False","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = false)","proofString":"unfold bounded.\nnow rewrite Cx, He."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = false) : (canonical_mantissa mx ex && (ex <=? emax - prec)%Z)%bool = true -> False.","conclusion":"(canonical_mantissa mx ex && (ex <=? emax - prec)%Z)%bool = true -> False","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Cx : canonical_mantissa mx ex = true) (He : (ex <=? emax - prec)%Z = false)","proofString":"now rewrite Cx, He."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (x : R) (y : R) : Z.abs (cond_Zopp sx (Z.pos mx) * cond_Zopp sy (Z.pos my)) = Z.pos (mx * my).","conclusion":"Z.abs (cond_Zopp sx (Z.pos mx) * cond_Zopp sy (Z.pos my)) = Z.pos (mx * my)","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (x : R) (y : R)","proofString":"rewrite Zabs_Zmult.\nnow rewrite 2!abs_cond_Zopp."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (x : R) (y : R) : (Z.abs (cond_Zopp sx (Z.pos mx)) * Z.abs (cond_Zopp sy (Z.pos my)))%Z =\nZ.pos (mx * my).","conclusion":"(Z.abs (cond_Zopp sx (Z.pos mx)) * Z.abs (cond_Zopp sy (Z.pos my)))%Z =\nZ.pos (mx * my)","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (x : R) (y : R)","proofString":"now rewrite 2!abs_cond_Zopp."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (x : R) (y : R) : forall (m0 : positive) (e : Z),\nbounded m0 e = true -> fexp (Zdigits radix2 (Z.pos m0) + e) = e.","conclusion":"forall (m0 : positive) (e : Z),\nbounded m0 e = true -> fexp (Zdigits radix2 (Z.pos m0) + e) = e","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (x : R) (y : R)","proofString":"clear.\nintros m e Hb.\ndestruct (andb_prop _ _ Hb) as (H,_).\napply Zeq_bool_eq.\nnow rewrite <- Zpos_digits2_pos."},{"statement":"forall (m : positive) (e : Z),\nbounded m e = true -> fexp (Zdigits radix2 (Z.pos m) + e) = e.","conclusion":"forall (m : positive) (e : Z),\nbounded m e = true -> fexp (Zdigits radix2 (Z.pos m) + e) = e","hypotheses":"","proofString":"intros m e Hb.\ndestruct (andb_prop _ _ Hb) as (H,_).\napply Zeq_bool_eq.\nnow rewrite <- Zpos_digits2_pos."},{"statement":"(m : positive) (e : Z) (Hb : bounded m e = true) : fexp (Zdigits radix2 (Z.pos m) + e) = e.","conclusion":"fexp (Zdigits radix2 (Z.pos m) + e) = e","hypotheses":"(m : positive) (e : Z) (Hb : bounded m e = true)","proofString":"destruct (andb_prop _ _ Hb) as (H,_).\napply Zeq_bool_eq.\nnow rewrite <- Zpos_digits2_pos."},{"statement":"(m : positive) (e : Z) (Hb : bounded m e = true) (H : canonical_mantissa m e = true) : fexp (Zdigits radix2 (Z.pos m) + e) = e.","conclusion":"fexp (Zdigits radix2 (Z.pos m) + e) = e","hypotheses":"(m : positive) (e : Z) (Hb : bounded m e = true) (H : canonical_mantissa m e = true)","proofString":"apply Zeq_bool_eq.\nnow rewrite <- Zpos_digits2_pos."},{"statement":"(m : positive) (e : Z) (Hb : bounded m e = true) (H : canonical_mantissa m e = true) : Zeq_bool (fexp (Zdigits radix2 (Z.pos m) + e)) e = true.","conclusion":"Zeq_bool (fexp (Zdigits radix2 (Z.pos m) + e)) e = true","hypotheses":"(m : positive) (e : Z) (Hb : bounded m e = true) (H : canonical_mantissa m e = true)","proofString":"now rewrite <- Zpos_digits2_pos."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) : if\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R (Bmult m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m)\n   (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bmult m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n (is_finite (B754_finite sx mx ex Hx) && is_finite (B754_finite sy my ey Hy))%bool /\\\n (is_nan (Bmult m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  false ->\n  Bsign (Bmult m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2SF (Bmult m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow m\n   (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R (Bmult m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m)\n   (B2R (B754_finite sx mx ex Hx) * B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bmult m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n (is_finite (B754_finite sx mx ex Hx) && is_finite (B754_finite sy my ey Hy))%bool /\\\n (is_nan (Bmult m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  false ->\n  Bsign (Bmult m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2SF (Bmult m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow m\n   (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true)","proofString":"simpl.\ncase Bmult_correct_aux.\nintros H1.\ncase Rlt_bool.\nintros (H2, (H3, H4)).\nsplit.\nnow rewrite B2R_SF2B.\nsplit.\nnow rewrite is_finite_SF2B.\nrewrite Bsign_SF2B.\nauto.\nintros H2.\nnow rewrite B2SF_SF2B."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : valid_binary\n  (binary_round_aux m (xorb sx sy) (Z.pos (mx * my)) (ex + ey) loc_Exact) =\ntrue) : forall\n  y : binary_round_aux m (xorb sx sy) (Z.pos (mx * my)) (ex + ey) loc_Exact =\n      binary_overflow m (xorb sx sy),\nB2SF\n  (SF2B\n     (binary_round_aux m (xorb sx sy) (Z.pos (mx * my)) (ex + ey) loc_Exact)\n     (proj1 (conj H1 y))) = binary_overflow m (xorb sx sy).","conclusion":"forall\n  y : binary_round_aux m (xorb sx sy) (Z.pos (mx * my)) (ex + ey) loc_Exact =\n      binary_overflow m (xorb sx sy),\nB2SF\n  (SF2B\n     (binary_round_aux m (xorb sx sy) (Z.pos (mx * my)) (ex + ey) loc_Exact)\n     (proj1 (conj H1 y))) = binary_overflow m (xorb sx sy)","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : valid_binary\n  (binary_round_aux m (xorb sx sy) (Z.pos (mx * my)) (ex + ey) loc_Exact) =\ntrue)","proofString":"intros H2.\nnow rewrite B2SF_SF2B."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : valid_binary\n  (binary_round_aux m (xorb sx sy) (Z.pos (mx * my)) (ex + ey) loc_Exact) =\ntrue) (H2 : binary_round_aux m (xorb sx sy) (Z.pos (mx * my)) (ex + ey) loc_Exact =\nbinary_overflow m (xorb sx sy)) : B2SF\n  (SF2B\n     (binary_round_aux m (xorb sx sy) (Z.pos (mx * my)) (ex + ey) loc_Exact)\n     (proj1 (conj H1 H2))) = binary_overflow m (xorb sx sy).","conclusion":"B2SF\n  (SF2B\n     (binary_round_aux m (xorb sx sy) (Z.pos (mx * my)) (ex + ey) loc_Exact)\n     (proj1 (conj H1 H2))) = binary_overflow m (xorb sx sy)","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (H1 : valid_binary\n  (binary_round_aux m (xorb sx sy) (Z.pos (mx * my)) (ex + ey) loc_Exact) =\ntrue) (H2 : binary_round_aux m (xorb sx sy) (Z.pos (mx * my)) (ex + ey) loc_Exact =\nbinary_overflow m (xorb sx sy))","proofString":"now rewrite B2SF_SF2B."},{"statement":"(mx : positive) (ex ex' : Z) (He : (ex' <= ex)%Z) : snd (shl_align mx ex ex') = ex'.","conclusion":"snd (shl_align mx ex ex') = ex'","hypotheses":"(mx : positive) (ex ex' : Z) (He : (ex' <= ex)%Z)","proofString":"generalize (shl_align_correct' mx ex ex' He).\nnow destruct shl_align as [m e]."},{"statement":"(mode : Binary.mode) (sx : bool) (mx : positive) (ex : Z) : is_nan_SF (binary_round mode sx mx ex) = false.","conclusion":"is_nan_SF (binary_round mode sx mx ex) = false","hypotheses":"(mode : Binary.mode) (sx : bool) (mx : positive) (ex : Z)","proofString":"generalize (binary_round_correct mode sx mx ex).\nsimpl.\ndestruct binary_round ; try easy.\nintros [_ H].\ndestruct Rlt_bool ; try easy.\nunfold binary_overflow in H.\nnow destruct overflow_to_inf."},{"statement":"(mode : Binary.mode) (sx : bool) (mx : positive) (ex : Z) (H : S754_nan = binary_overflow mode sx) : is_nan_SF S754_nan = false.","conclusion":"is_nan_SF S754_nan = false","hypotheses":"(mode : Binary.mode) (sx : bool) (mx : positive) (ex : Z) (H : S754_nan = binary_overflow mode sx)","proofString":"unfold binary_overflow in H.\nnow destruct overflow_to_inf."},{"statement":"(mode : Binary.mode) (sx : bool) (mx : positive) (ex : Z) (H : S754_nan =\n(if overflow_to_inf mode sx\n then S754_infinity sx\n else S754_finite sx (Z.to_pos (2 ^ prec - 1)) (emax - prec))) : is_nan_SF S754_nan = false.","conclusion":"is_nan_SF S754_nan = false","hypotheses":"(mode : Binary.mode) (sx : bool) (mx : positive) (ex : Z) (H : S754_nan =\n(if overflow_to_inf mode sx\n then S754_infinity sx\n else S754_finite sx (Z.to_pos (2 ^ prec - 1)) (emax - prec)))","proofString":"now destruct overflow_to_inf."},{"statement":"(m : mode) (ez : Z) (szero : bool) : (0 < bpow radix2 emax)%R.","conclusion":"(0 < bpow radix2 emax)%R","hypotheses":"(m : mode) (ez : Z) (szero : bool)","proofString":"apply bpow_gt_0."},{"statement":"(mode : Binary.mode) (m e : Z) (szero : bool) : is_nan (binary_normalize mode m e szero) = false.","conclusion":"is_nan (binary_normalize mode m e szero) = false","hypotheses":"(mode : Binary.mode) (m e : Z) (szero : bool)","proofString":"generalize (binary_normalize_correct mode m e szero).\nsimpl.\ndestruct Rlt_bool.\nintros [_ [H _]].\nnow destruct binary_normalize.\nintros H.\nrewrite <- is_nan_SF_B2SF.\nrewrite H.\nunfold binary_overflow.\nnow destruct overflow_to_inf."},{"statement":"(mode : Binary.mode) (m e : Z) (szero : bool) (H : is_finite (binary_normalize mode m e szero) = true) : is_nan (binary_normalize mode m e szero) = false.","conclusion":"is_nan (binary_normalize mode m e szero) = false","hypotheses":"(mode : Binary.mode) (m e : Z) (szero : bool) (H : is_finite (binary_normalize mode m e szero) = true)","proofString":"now destruct binary_normalize."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey ez : Z) (Ex : (ez <= ex)%Z) (Ey : (ez <= ey)%Z) : (IZR\n   (cond_Zopp sx (Z.pos (fst (shl_align mx ex ez))) +\n    cond_Zopp sy (Z.pos (fst (shl_align my ey ez)))) * \n bpow radix2 ez)%R =\n(IZR (cond_Zopp sx (Z.pos mx)) * bpow radix2 ex +\n IZR (cond_Zopp sy (Z.pos my)) * bpow radix2 ey)%R.","conclusion":"(IZR\n   (cond_Zopp sx (Z.pos (fst (shl_align mx ex ez))) +\n    cond_Zopp sy (Z.pos (fst (shl_align my ey ez)))) * \n bpow radix2 ez)%R =\n(IZR (cond_Zopp sx (Z.pos mx)) * bpow radix2 ex +\n IZR (cond_Zopp sy (Z.pos my)) * bpow radix2 ey)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey ez : Z) (Ex : (ez <= ex)%Z) (Ey : (ez <= ey)%Z)","proofString":"generalize (shl_align_correct' mx ex ez Ex).\ngeneralize (shl_align_correct' my ey ez Ey).\ndestruct shl_align as [my' ey'].\ndestruct shl_align as [mx' ex'].\nintros [Hy _].\nintros [Hx _].\nsimpl.\nrewrite plus_IZR, Rmult_plus_distr_r.\ngeneralize (f_equal (cond_Ropp sx) Hx).\ngeneralize (f_equal (cond_Ropp sy) Hy).\nrewrite <- 4!F2R_cond_Zopp.\nunfold F2R.\nsimpl.\nnow intros -> ->."},{"statement":"(m : mode) (sx sy : bool) (Fx : is_finite (B754_zero sx) = true) (Fy : is_finite (B754_zero sy) = true) : B2R (Bplus m (B754_zero sx) (B754_zero sy)) = 0%R /\\\nis_finite (Bplus m (B754_zero sx) (B754_zero sy)) = true /\\\nBsign (Bplus m (B754_zero sx) (B754_zero sy)) =\nmatch Rcompare (B2R (B754_zero sx)) 0 with\n| Eq =>\n    match m with\n    | mode_DN => (Bsign (B754_zero sx) || Bsign (B754_zero sy))%bool\n    | _ => (Bsign (B754_zero sx) && Bsign (B754_zero sy))%bool\n    end\n| Lt => true\n| Gt => false\nend.","conclusion":"B2R (Bplus m (B754_zero sx) (B754_zero sy)) = 0%R /\\\nis_finite (Bplus m (B754_zero sx) (B754_zero sy)) = true /\\\nBsign (Bplus m (B754_zero sx) (B754_zero sy)) =\nmatch Rcompare (B2R (B754_zero sx)) 0 with\n| Eq =>\n    match m with\n    | mode_DN => (Bsign (B754_zero sx) || Bsign (B754_zero sy))%bool\n    | _ => (Bsign (B754_zero sx) && Bsign (B754_zero sy))%bool\n    end\n| Lt => true\n| Gt => false\nend","hypotheses":"(m : mode) (sx sy : bool) (Fx : is_finite (B754_zero sx) = true) (Fy : is_finite (B754_zero sy) = true)","proofString":"simpl.\nrewrite Rcompare_Eq by auto.\ndestruct sx, sy; try easy; now case m."},{"statement":"(m : mode) (sx sy : bool) (Fx : is_finite (B754_zero sx) = true) (Fy : is_finite (B754_zero sy) = true) : B2R\n  (if Bool.eqb sx sy\n   then B754_zero sx\n   else match m with\n        | mode_DN => B754_zero true\n        | _ => B754_zero false\n        end) = 0%R /\\\nis_finite\n  (if Bool.eqb sx sy\n   then B754_zero sx\n   else match m with\n        | mode_DN => B754_zero true\n        | _ => B754_zero false\n        end) = true /\\\nBsign\n  (if Bool.eqb sx sy\n   then B754_zero sx\n   else match m with\n        | mode_DN => B754_zero true\n        | _ => B754_zero false\n        end) =\nmatch Rcompare 0 0 with\n| Eq => match m with\n        | mode_DN => (sx || sy)%bool\n        | _ => (sx && sy)%bool\n        end\n| Lt => true\n| Gt => false\nend.","conclusion":"B2R\n  (if Bool.eqb sx sy\n   then B754_zero sx\n   else match m with\n        | mode_DN => B754_zero true\n        | _ => B754_zero false\n        end) = 0%R /\\\nis_finite\n  (if Bool.eqb sx sy\n   then B754_zero sx\n   else match m with\n        | mode_DN => B754_zero true\n        | _ => B754_zero false\n        end) = true /\\\nBsign\n  (if Bool.eqb sx sy\n   then B754_zero sx\n   else match m with\n        | mode_DN => B754_zero true\n        | _ => B754_zero false\n        end) =\nmatch Rcompare 0 0 with\n| Eq => match m with\n        | mode_DN => (sx || sy)%bool\n        | _ => (sx && sy)%bool\n        end\n| Lt => true\n| Gt => false\nend","hypotheses":"(m : mode) (sx sy : bool) (Fx : is_finite (B754_zero sx) = true) (Fy : is_finite (B754_zero sy) = true)","proofString":"rewrite Rcompare_Eq by auto.\ndestruct sx, sy; try easy; now case m."},{"statement":"(m : mode) (sx sy : bool) (Fx : is_finite (B754_zero sx) = true) (Fy : is_finite (B754_zero sy) = true) : B2R\n  (if Bool.eqb sx sy\n   then B754_zero sx\n   else match m with\n        | mode_DN => B754_zero true\n        | _ => B754_zero false\n        end) = 0%R /\\\nis_finite\n  (if Bool.eqb sx sy\n   then B754_zero sx\n   else match m with\n        | mode_DN => B754_zero true\n        | _ => B754_zero false\n        end) = true /\\\nBsign\n  (if Bool.eqb sx sy\n   then B754_zero sx\n   else match m with\n        | mode_DN => B754_zero true\n        | _ => B754_zero false\n        end) =\nmatch m with\n| mode_DN => (sx || sy)%bool\n| _ => (sx && sy)%bool\nend.","conclusion":"B2R\n  (if Bool.eqb sx sy\n   then B754_zero sx\n   else match m with\n        | mode_DN => B754_zero true\n        | _ => B754_zero false\n        end) = 0%R /\\\nis_finite\n  (if Bool.eqb sx sy\n   then B754_zero sx\n   else match m with\n        | mode_DN => B754_zero true\n        | _ => B754_zero false\n        end) = true /\\\nBsign\n  (if Bool.eqb sx sy\n   then B754_zero sx\n   else match m with\n        | mode_DN => B754_zero true\n        | _ => B754_zero false\n        end) =\nmatch m with\n| mode_DN => (sx || sy)%bool\n| _ => (sx && sy)%bool\nend","hypotheses":"(m : mode) (sx sy : bool) (Fx : is_finite (B754_zero sx) = true) (Fy : is_finite (B754_zero sy) = true)","proofString":"destruct sx, sy; try easy; now case m."},{"statement":"(m : mode) (sx sy : bool) (Fx : is_finite (B754_zero sx) = true) (Fy : is_finite (B754_zero sy) = true) : (0 < bpow radix2 emax)%R.","conclusion":"(0 < bpow radix2 emax)%R","hypotheses":"(m : mode) (sx sy : bool) (Fx : is_finite (B754_zero sx) = true) (Fy : is_finite (B754_zero sy) = true)","proofString":"apply bpow_gt_0."},{"statement":"(m : mode) (sx sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Fx : is_finite (B754_zero sx) = true) (Fy : is_finite (B754_finite sy my ey Hy) = true) : (Rabs (B2R (B754_finite sy my ey Hy)) < bpow radix2 emax)%R.","conclusion":"(Rabs (B2R (B754_finite sy my ey Hy)) < bpow radix2 emax)%R","hypotheses":"(m : mode) (sx sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Fx : is_finite (B754_zero sx) = true) (Fy : is_finite (B754_finite sy my ey Hy) = true)","proofString":"apply abs_B2R_lt_emax."},{"statement":"(m : mode) (sx sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Fx : is_finite (B754_zero sx) = true) (Fy : is_finite (B754_finite sy my ey Hy) = true) : generic_format radix2 fexp (B2R (B754_finite sy my ey Hy)).","conclusion":"generic_format radix2 fexp (B2R (B754_finite sy my ey Hy))","hypotheses":"(m : mode) (sx sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Fx : is_finite (B754_zero sx) = true) (Fy : is_finite (B754_finite sy my ey Hy) = true)","proofString":"apply generic_format_B2R."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (Fy : is_finite (B754_zero sy) = true) : (Rabs (B2R (B754_finite sx mx ex Hx)) < bpow radix2 emax)%R.","conclusion":"(Rabs (B2R (B754_finite sx mx ex Hx)) < bpow radix2 emax)%R","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (Fy : is_finite (B754_zero sy) = true)","proofString":"apply abs_B2R_lt_emax."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (Fy : is_finite (B754_zero sy) = true) : generic_format radix2 fexp (B2R (B754_finite sx mx ex Hx)).","conclusion":"generic_format radix2 fexp (B2R (B754_finite sx mx ex Hx))","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (Fy : is_finite (B754_zero sy) = true)","proofString":"apply generic_format_B2R."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (Fy : is_finite (B754_finite sy my ey Hy) = true) : if\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_finite sx mx ex Hx) + B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m)\n   (B2R (B754_finite sx mx ex Hx) + B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n true /\\\n Bsign (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n match\n   Rcompare (B2R (B754_finite sx mx ex Hx) + B2R (B754_finite sy my ey Hy)) 0\n with\n | Eq =>\n     match m with\n     | mode_DN =>\n         (Bsign (B754_finite sx mx ex Hx) || Bsign (B754_finite sy my ey Hy))%bool\n     | _ =>\n         (Bsign (B754_finite sx mx ex Hx) && Bsign (B754_finite sy my ey Hy))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow m (Bsign (B754_finite sx mx ex Hx)) /\\\n Bsign (B754_finite sx mx ex Hx) = Bsign (B754_finite sy my ey Hy).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_finite sx mx ex Hx) + B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m)\n   (B2R (B754_finite sx mx ex Hx) + B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n true /\\\n Bsign (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n match\n   Rcompare (B2R (B754_finite sx mx ex Hx) + B2R (B754_finite sy my ey Hy)) 0\n with\n | Eq =>\n     match m with\n     | mode_DN =>\n         (Bsign (B754_finite sx mx ex Hx) || Bsign (B754_finite sy my ey Hy))%bool\n     | _ =>\n         (Bsign (B754_finite sx mx ex Hx) && Bsign (B754_finite sy my ey Hy))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow m (Bsign (B754_finite sx mx ex Hx)) /\\\n Bsign (B754_finite sx mx ex Hx) = Bsign (B754_finite sy my ey Hy)","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (Fy : is_finite (B754_finite sy my ey Hy) = true)","proofString":"clear Fx Fy.\nsimpl.\nset (szero := match m with mode_DN => true | _ => false end).\nset (ez := Z.min ex ey).\nassert (Hp := Fplus_naive_correct sx mx ex sy my ey ez (Z.le_min_l _ _) (Z.le_min_r _ _)).\nset (mz := Fplus_naive sx mx ex sy my ey ez).\nsimpl in Hp.\nfold mz in Hp.\nrewrite <- Hp.\ngeneralize (binary_normalize_correct m mz ez szero).\nsimpl.\ncase Rlt_bool_spec ; intros Hz.\nintros [H1 [H2 H3]].\napply (conj H1).\napply (conj H2).\nrewrite H3.\ncase Rcompare_spec ; try easy.\nintros Hz'.\nrewrite Hz' in Hp.\napply eq_sym, Rplus_opp_r_uniq in Hp.\nrewrite <- F2R_Zopp in Hp.\neapply canonical_unique in Hp.\ninversion Hp.\nclear -H0.\ndestruct sy, sx, m ; easy.\nnow apply canonical_bounded.\nrewrite <- cond_Zopp_negb.\nnow apply canonical_bounded.\nintros Vz.\nrewrite Hp in Hz.\nassert (Sz := sign_plus_overflow m sx mx ex sy my ey Hx Hy Hz).\nsplit.\nrewrite Vz.\napply f_equal.\nnow rewrite Hp.\napply Sz."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) : if\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_finite sx mx ex Hx) + B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m)\n   (B2R (B754_finite sx mx ex Hx) + B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n true /\\\n Bsign (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n match\n   Rcompare (B2R (B754_finite sx mx ex Hx) + B2R (B754_finite sy my ey Hy)) 0\n with\n | Eq =>\n     match m with\n     | mode_DN =>\n         (Bsign (B754_finite sx mx ex Hx) || Bsign (B754_finite sy my ey Hy))%bool\n     | _ =>\n         (Bsign (B754_finite sx mx ex Hx) && Bsign (B754_finite sy my ey Hy))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow m (Bsign (B754_finite sx mx ex Hx)) /\\\n Bsign (B754_finite sx mx ex Hx) = Bsign (B754_finite sy my ey Hy).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_finite sx mx ex Hx) + B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m)\n   (B2R (B754_finite sx mx ex Hx) + B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n true /\\\n Bsign (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n match\n   Rcompare (B2R (B754_finite sx mx ex Hx) + B2R (B754_finite sy my ey Hy)) 0\n with\n | Eq =>\n     match m with\n     | mode_DN =>\n         (Bsign (B754_finite sx mx ex Hx) || Bsign (B754_finite sy my ey Hy))%bool\n     | _ =>\n         (Bsign (B754_finite sx mx ex Hx) && Bsign (B754_finite sy my ey Hy))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow m (Bsign (B754_finite sx mx ex Hx)) /\\\n Bsign (B754_finite sx mx ex Hx) = Bsign (B754_finite sy my ey Hy)","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true)","proofString":"simpl.\nset (szero := match m with mode_DN => true | _ => false end).\nset (ez := Z.min ex ey).\nassert (Hp := Fplus_naive_correct sx mx ex sy my ey ez (Z.le_min_l _ _) (Z.le_min_r _ _)).\nset (mz := Fplus_naive sx mx ex sy my ey ez).\nsimpl in Hp.\nfold mz in Hp.\nrewrite <- Hp.\ngeneralize (binary_normalize_correct m mz ez szero).\nsimpl.\ncase Rlt_bool_spec ; intros Hz.\nintros [H1 [H2 H3]].\napply (conj H1).\napply (conj H2).\nrewrite H3.\ncase Rcompare_spec ; try easy.\nintros Hz'.\nrewrite Hz' in Hp.\napply eq_sym, Rplus_opp_r_uniq in Hp.\nrewrite <- F2R_Zopp in Hp.\neapply canonical_unique in Hp.\ninversion Hp.\nclear -H0.\ndestruct sy, sx, m ; easy.\nnow apply canonical_bounded.\nrewrite <- cond_Zopp_negb.\nnow apply canonical_bounded.\nintros Vz.\nrewrite Hp in Hz.\nassert (Sz := sign_plus_overflow m sx mx ex sy my ey Hx Hy Hz).\nsplit.\nrewrite Vz.\napply f_equal.\nnow rewrite Hp.\napply Sz."},{"statement":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) : if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bminus m x y) = round radix2 fexp (round_mode m) (B2R x - B2R y) /\\\n is_finite (Bminus m x y) = true /\\\n Bsign (Bminus m x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bminus m x y) = binary_overflow m (Bsign x) /\\\n Bsign x = negb (Bsign y).","conclusion":"if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bminus m x y) = round radix2 fexp (round_mode m) (B2R x - B2R y) /\\\n is_finite (Bminus m x y) = true /\\\n Bsign (Bminus m x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bminus m x y) = binary_overflow m (Bsign x) /\\\n Bsign x = negb (Bsign y)","hypotheses":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true)","proofString":"generalize (Bplus_correct m x (Bopp y) Fx).\nrewrite is_finite_Bopp, B2R_Bopp.\nintros H.\nspecialize (H Fy).\nrewrite <- Bsign_Bopp.\ndestruct x as [| | |sx mx ex Hx], y as [| | |sy my ey Hy] ; try easy.\nnow clear -Fy; destruct y as [ | | | ]."},{"statement":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) : (is_finite (Bopp y) = true ->\n if\n  Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x + B2R (Bopp y))))\n    (bpow radix2 emax)\n then\n  B2R (Bplus m x (Bopp y)) =\n  round radix2 fexp (round_mode m) (B2R x + B2R (Bopp y)) /\\\n  is_finite (Bplus m x (Bopp y)) = true /\\\n  Bsign (Bplus m x (Bopp y)) =\n  match Rcompare (B2R x + B2R (Bopp y)) 0 with\n  | Eq =>\n      match m with\n      | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n      | _ => (Bsign x && Bsign (Bopp y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  B2SF (Bplus m x (Bopp y)) = binary_overflow m (Bsign x) /\\\n  Bsign x = Bsign (Bopp y)) ->\nif\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bminus m x y) = round radix2 fexp (round_mode m) (B2R x - B2R y) /\\\n is_finite (Bminus m x y) = true /\\\n Bsign (Bminus m x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bminus m x y) = binary_overflow m (Bsign x) /\\\n Bsign x = negb (Bsign y).","conclusion":"(is_finite (Bopp y) = true ->\n if\n  Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x + B2R (Bopp y))))\n    (bpow radix2 emax)\n then\n  B2R (Bplus m x (Bopp y)) =\n  round radix2 fexp (round_mode m) (B2R x + B2R (Bopp y)) /\\\n  is_finite (Bplus m x (Bopp y)) = true /\\\n  Bsign (Bplus m x (Bopp y)) =\n  match Rcompare (B2R x + B2R (Bopp y)) 0 with\n  | Eq =>\n      match m with\n      | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n      | _ => (Bsign x && Bsign (Bopp y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  B2SF (Bplus m x (Bopp y)) = binary_overflow m (Bsign x) /\\\n  Bsign x = Bsign (Bopp y)) ->\nif\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bminus m x y) = round radix2 fexp (round_mode m) (B2R x - B2R y) /\\\n is_finite (Bminus m x y) = true /\\\n Bsign (Bminus m x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bminus m x y) = binary_overflow m (Bsign x) /\\\n Bsign x = negb (Bsign y)","hypotheses":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true)","proofString":"rewrite is_finite_Bopp, B2R_Bopp.\nintros H.\nspecialize (H Fy).\nrewrite <- Bsign_Bopp.\ndestruct x as [| | |sx mx ex Hx], y as [| | |sy my ey Hy] ; try easy.\nnow clear -Fy; destruct y as [ | | | ]."},{"statement":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) : (is_finite y = true ->\n if\n  Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x + - B2R y)))\n    (bpow radix2 emax)\n then\n  B2R (Bplus m x (Bopp y)) =\n  round radix2 fexp (round_mode m) (B2R x + - B2R y) /\\\n  is_finite (Bplus m x (Bopp y)) = true /\\\n  Bsign (Bplus m x (Bopp y)) =\n  match Rcompare (B2R x + - B2R y) 0 with\n  | Eq =>\n      match m with\n      | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n      | _ => (Bsign x && Bsign (Bopp y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  B2SF (Bplus m x (Bopp y)) = binary_overflow m (Bsign x) /\\\n  Bsign x = Bsign (Bopp y)) ->\nif\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bminus m x y) = round radix2 fexp (round_mode m) (B2R x - B2R y) /\\\n is_finite (Bminus m x y) = true /\\\n Bsign (Bminus m x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bminus m x y) = binary_overflow m (Bsign x) /\\\n Bsign x = negb (Bsign y).","conclusion":"(is_finite y = true ->\n if\n  Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x + - B2R y)))\n    (bpow radix2 emax)\n then\n  B2R (Bplus m x (Bopp y)) =\n  round radix2 fexp (round_mode m) (B2R x + - B2R y) /\\\n  is_finite (Bplus m x (Bopp y)) = true /\\\n  Bsign (Bplus m x (Bopp y)) =\n  match Rcompare (B2R x + - B2R y) 0 with\n  | Eq =>\n      match m with\n      | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n      | _ => (Bsign x && Bsign (Bopp y))%bool\n      end\n  | Lt => true\n  | Gt => false\n  end\n else\n  B2SF (Bplus m x (Bopp y)) = binary_overflow m (Bsign x) /\\\n  Bsign x = Bsign (Bopp y)) ->\nif\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bminus m x y) = round radix2 fexp (round_mode m) (B2R x - B2R y) /\\\n is_finite (Bminus m x y) = true /\\\n Bsign (Bminus m x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bminus m x y) = binary_overflow m (Bsign x) /\\\n Bsign x = negb (Bsign y)","hypotheses":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true)","proofString":"intros H.\nspecialize (H Fy).\nrewrite <- Bsign_Bopp.\ndestruct x as [| | |sx mx ex Hx], y as [| | |sy my ey Hy] ; try easy.\nnow clear -Fy; destruct y as [ | | | ]."},{"statement":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) (H : is_finite y = true ->\nif\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x + - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bplus m x (Bopp y)) =\n round radix2 fexp (round_mode m) (B2R x + - B2R y) /\\\n is_finite (Bplus m x (Bopp y)) = true /\\\n Bsign (Bplus m x (Bopp y)) =\n match Rcompare (B2R x + - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n     | _ => (Bsign x && Bsign (Bopp y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus m x (Bopp y)) = binary_overflow m (Bsign x) /\\\n Bsign x = Bsign (Bopp y)) : if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bminus m x y) = round radix2 fexp (round_mode m) (B2R x - B2R y) /\\\n is_finite (Bminus m x y) = true /\\\n Bsign (Bminus m x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bminus m x y) = binary_overflow m (Bsign x) /\\\n Bsign x = negb (Bsign y).","conclusion":"if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bminus m x y) = round radix2 fexp (round_mode m) (B2R x - B2R y) /\\\n is_finite (Bminus m x y) = true /\\\n Bsign (Bminus m x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bminus m x y) = binary_overflow m (Bsign x) /\\\n Bsign x = negb (Bsign y)","hypotheses":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) (H : is_finite y = true ->\nif\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x + - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bplus m x (Bopp y)) =\n round radix2 fexp (round_mode m) (B2R x + - B2R y) /\\\n is_finite (Bplus m x (Bopp y)) = true /\\\n Bsign (Bplus m x (Bopp y)) =\n match Rcompare (B2R x + - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n     | _ => (Bsign x && Bsign (Bopp y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus m x (Bopp y)) = binary_overflow m (Bsign x) /\\\n Bsign x = Bsign (Bopp y))","proofString":"specialize (H Fy).\nrewrite <- Bsign_Bopp.\ndestruct x as [| | |sx mx ex Hx], y as [| | |sy my ey Hy] ; try easy.\nnow clear -Fy; destruct y as [ | | | ]."},{"statement":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) (H : if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x + - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bplus m x (Bopp y)) =\n round radix2 fexp (round_mode m) (B2R x + - B2R y) /\\\n is_finite (Bplus m x (Bopp y)) = true /\\\n Bsign (Bplus m x (Bopp y)) =\n match Rcompare (B2R x + - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n     | _ => (Bsign x && Bsign (Bopp y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus m x (Bopp y)) = binary_overflow m (Bsign x) /\\\n Bsign x = Bsign (Bopp y)) : if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bminus m x y) = round radix2 fexp (round_mode m) (B2R x - B2R y) /\\\n is_finite (Bminus m x y) = true /\\\n Bsign (Bminus m x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bminus m x y) = binary_overflow m (Bsign x) /\\\n Bsign x = negb (Bsign y).","conclusion":"if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bminus m x y) = round radix2 fexp (round_mode m) (B2R x - B2R y) /\\\n is_finite (Bminus m x y) = true /\\\n Bsign (Bminus m x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || negb (Bsign y))%bool\n     | _ => (Bsign x && negb (Bsign y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bminus m x y) = binary_overflow m (Bsign x) /\\\n Bsign x = negb (Bsign y)","hypotheses":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) (H : if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x + - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bplus m x (Bopp y)) =\n round radix2 fexp (round_mode m) (B2R x + - B2R y) /\\\n is_finite (Bplus m x (Bopp y)) = true /\\\n Bsign (Bplus m x (Bopp y)) =\n match Rcompare (B2R x + - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n     | _ => (Bsign x && Bsign (Bopp y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus m x (Bopp y)) = binary_overflow m (Bsign x) /\\\n Bsign x = Bsign (Bopp y))","proofString":"rewrite <- Bsign_Bopp.\ndestruct x as [| | |sx mx ex Hx], y as [| | |sy my ey Hy] ; try easy.\nnow clear -Fy; destruct y as [ | | | ]."},{"statement":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) (H : if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x + - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bplus m x (Bopp y)) =\n round radix2 fexp (round_mode m) (B2R x + - B2R y) /\\\n is_finite (Bplus m x (Bopp y)) = true /\\\n Bsign (Bplus m x (Bopp y)) =\n match Rcompare (B2R x + - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n     | _ => (Bsign x && Bsign (Bopp y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus m x (Bopp y)) = binary_overflow m (Bsign x) /\\\n Bsign x = Bsign (Bopp y)) : if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bminus m x y) = round radix2 fexp (round_mode m) (B2R x - B2R y) /\\\n is_finite (Bminus m x y) = true /\\\n Bsign (Bminus m x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n     | _ => (Bsign x && Bsign (Bopp y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bminus m x y) = binary_overflow m (Bsign x) /\\\n Bsign x = Bsign (Bopp y).","conclusion":"if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bminus m x y) = round radix2 fexp (round_mode m) (B2R x - B2R y) /\\\n is_finite (Bminus m x y) = true /\\\n Bsign (Bminus m x y) =\n match Rcompare (B2R x - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n     | _ => (Bsign x && Bsign (Bopp y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bminus m x y) = binary_overflow m (Bsign x) /\\\n Bsign x = Bsign (Bopp y)","hypotheses":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) (H : if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x + - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bplus m x (Bopp y)) =\n round radix2 fexp (round_mode m) (B2R x + - B2R y) /\\\n is_finite (Bplus m x (Bopp y)) = true /\\\n Bsign (Bplus m x (Bopp y)) =\n match Rcompare (B2R x + - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n     | _ => (Bsign x && Bsign (Bopp y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus m x (Bopp y)) = binary_overflow m (Bsign x) /\\\n Bsign x = Bsign (Bopp y))","proofString":"destruct x as [| | |sx mx ex Hx], y as [| | |sy my ey Hy] ; try easy."},{"statement":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) (H : if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x + - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bplus m x (Bopp y)) =\n round radix2 fexp (round_mode m) (B2R x + - B2R y) /\\\n is_finite (Bplus m x (Bopp y)) = true /\\\n Bsign (Bplus m x (Bopp y)) =\n match Rcompare (B2R x + - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n     | _ => (Bsign x && Bsign (Bopp y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus m x (Bopp y)) = binary_overflow m (Bsign x) /\\\n Bsign x = Bsign (Bopp y)) : is_nan y = false.","conclusion":"is_nan y = false","hypotheses":"(m : mode) (x y : binary_float) (Fx : is_finite x = true) (Fy : is_finite y = true) (H : if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R x + - B2R y)))\n   (bpow radix2 emax)\nthen\n B2R (Bplus m x (Bopp y)) =\n round radix2 fexp (round_mode m) (B2R x + - B2R y) /\\\n is_finite (Bplus m x (Bopp y)) = true /\\\n Bsign (Bplus m x (Bopp y)) =\n match Rcompare (B2R x + - B2R y) 0 with\n | Eq =>\n     match m with\n     | mode_DN => (Bsign x || Bsign (Bopp y))%bool\n     | _ => (Bsign x && Bsign (Bopp y))%bool\n     end\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus m x (Bopp y)) = binary_overflow m (Bsign x) /\\\n Bsign x = Bsign (Bopp y))","proofString":"now clear -Fy; destruct y as [ | | | ]."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (e' : Z) (mx' : Z) : match (ex - ey - e')%Z with\n| 0%Z => Z.pos mx\n| Z.pos _ => Z.shiftl (Z.pos mx) (ex - ey - e')\n| Z.neg _ => 0%Z\nend = (Z.pos mx * radix2 ^ (ex - ey - e'))%Z.","conclusion":"match (ex - ey - e')%Z with\n| 0%Z => Z.pos mx\n| Z.pos _ => Z.shiftl (Z.pos mx) (ex - ey - e')\n| Z.neg _ => 0%Z\nend = (Z.pos mx * radix2 ^ (ex - ey - e'))%Z","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (e' : Z) (mx' : Z)","proofString":"destruct (ex - ey - e')%Z as [|p|p].\nnow rewrite Zmult_1_r.\nnow rewrite Z.shiftl_mul_pow2.\neasy."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (e' : Z) (mx' : Z) : Z.pos mx = (Z.pos mx * radix2 ^ 0)%Z.","conclusion":"Z.pos mx = (Z.pos mx * radix2 ^ 0)%Z","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (e' : Z) (mx' : Z)","proofString":"now rewrite Zmult_1_r."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (e' : Z) (p : positive) (mx' : Z) : Z.shiftl (Z.pos mx) (Z.pos p) = (Z.pos mx * radix2 ^ Z.pos p)%Z.","conclusion":"Z.shiftl (Z.pos mx) (Z.pos p) = (Z.pos mx * radix2 ^ Z.pos p)%Z","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (e' : Z) (p : positive) (mx' : Z)","proofString":"now rewrite Z.shiftl_mul_pow2."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (e' : Z) (p : positive) (mx' : Z) : 0%Z = (Z.pos mx * radix2 ^ Z.neg p)%Z.","conclusion":"0%Z = (Z.pos mx * radix2 ^ Z.neg p)%Z","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (sy : bool) (my : positive) (ey : Z) (e' : Z) (p : positive) (mx' : Z)","proofString":"easy."},{"statement":"(m : mode) (x : binary_float) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : B2R (B754_finite sy my ey Hy) <> 0%R) : if\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R x / B2R (B754_finite sy my ey Hy)))) \n   (bpow radix2 emax)\nthen\n B2R (Bdiv m x (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m) (B2R x / B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bdiv m x (B754_finite sy my ey Hy)) = is_finite x /\\\n (is_nan (Bdiv m x (B754_finite sy my ey Hy)) = false ->\n  Bsign (Bdiv m x (B754_finite sy my ey Hy)) =\n  xorb (Bsign x) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2SF (Bdiv m x (B754_finite sy my ey Hy)) =\n binary_overflow m (xorb (Bsign x) (Bsign (B754_finite sy my ey Hy))).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R x / B2R (B754_finite sy my ey Hy)))) \n   (bpow radix2 emax)\nthen\n B2R (Bdiv m x (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m) (B2R x / B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bdiv m x (B754_finite sy my ey Hy)) = is_finite x /\\\n (is_nan (Bdiv m x (B754_finite sy my ey Hy)) = false ->\n  Bsign (Bdiv m x (B754_finite sy my ey Hy)) =\n  xorb (Bsign x) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2SF (Bdiv m x (B754_finite sy my ey Hy)) =\n binary_overflow m (xorb (Bsign x) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(m : mode) (x : binary_float) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : B2R (B754_finite sy my ey Hy) <> 0%R)","proofString":"revert x.\nunfold Rdiv.\nintros [sx|sx| |sx mx ex Hx] ;  try ( rewrite Rmult_0_l, round_0, Rabs_R0, Rlt_bool_true ; [ simpl ; try easy ; now rewrite B2R_build_nan, is_finite_build_nan, is_nan_build_nan | apply bpow_gt_0 | auto with typeclass_instances ] ).\nsimpl.\ncase Bdiv_correct_aux.\nintros H1.\nunfold Rdiv.\ncase Rlt_bool.\nintros (H2, (H3, H4)).\nsplit.\nnow rewrite B2R_SF2B.\nsplit.\nnow rewrite is_finite_SF2B.\nrewrite Bsign_SF2B.\ncongruence.\nintros H2.\nnow rewrite B2SF_SF2B."},{"statement":"(m : mode) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : B2R (B754_finite sy my ey Hy) <> 0%R) : forall x : binary_float,\nif\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R x / B2R (B754_finite sy my ey Hy)))) \n   (bpow radix2 emax)\nthen\n B2R (Bdiv m x (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m) (B2R x / B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bdiv m x (B754_finite sy my ey Hy)) = is_finite x /\\\n (is_nan (Bdiv m x (B754_finite sy my ey Hy)) = false ->\n  Bsign (Bdiv m x (B754_finite sy my ey Hy)) =\n  xorb (Bsign x) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2SF (Bdiv m x (B754_finite sy my ey Hy)) =\n binary_overflow m (xorb (Bsign x) (Bsign (B754_finite sy my ey Hy))).","conclusion":"forall x : binary_float,\nif\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R x / B2R (B754_finite sy my ey Hy)))) \n   (bpow radix2 emax)\nthen\n B2R (Bdiv m x (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m) (B2R x / B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bdiv m x (B754_finite sy my ey Hy)) = is_finite x /\\\n (is_nan (Bdiv m x (B754_finite sy my ey Hy)) = false ->\n  Bsign (Bdiv m x (B754_finite sy my ey Hy)) =\n  xorb (Bsign x) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2SF (Bdiv m x (B754_finite sy my ey Hy)) =\n binary_overflow m (xorb (Bsign x) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(m : mode) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : B2R (B754_finite sy my ey Hy) <> 0%R)","proofString":"unfold Rdiv.\nintros [sx|sx| |sx mx ex Hx] ;  try ( rewrite Rmult_0_l, round_0, Rabs_R0, Rlt_bool_true ; [ simpl ; try easy ; now rewrite B2R_build_nan, is_finite_build_nan, is_nan_build_nan | apply bpow_gt_0 | auto with typeclass_instances ] ).\nsimpl.\ncase Bdiv_correct_aux.\nintros H1.\nunfold Rdiv.\ncase Rlt_bool.\nintros (H2, (H3, H4)).\nsplit.\nnow rewrite B2R_SF2B.\nsplit.\nnow rewrite is_finite_SF2B.\nrewrite Bsign_SF2B.\ncongruence.\nintros H2.\nnow rewrite B2SF_SF2B."},{"statement":"(m : mode) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : B2R (B754_finite sy my ey Hy) <> 0%R) : forall x : binary_float,\nif\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R x * / B2R (B754_finite sy my ey Hy)))) \n   (bpow radix2 emax)\nthen\n B2R (Bdiv m x (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m) (B2R x * / B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bdiv m x (B754_finite sy my ey Hy)) = is_finite x /\\\n (is_nan (Bdiv m x (B754_finite sy my ey Hy)) = false ->\n  Bsign (Bdiv m x (B754_finite sy my ey Hy)) =\n  xorb (Bsign x) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2SF (Bdiv m x (B754_finite sy my ey Hy)) =\n binary_overflow m (xorb (Bsign x) (Bsign (B754_finite sy my ey Hy))).","conclusion":"forall x : binary_float,\nif\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R x * / B2R (B754_finite sy my ey Hy)))) \n   (bpow radix2 emax)\nthen\n B2R (Bdiv m x (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m) (B2R x * / B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bdiv m x (B754_finite sy my ey Hy)) = is_finite x /\\\n (is_nan (Bdiv m x (B754_finite sy my ey Hy)) = false ->\n  Bsign (Bdiv m x (B754_finite sy my ey Hy)) =\n  xorb (Bsign x) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2SF (Bdiv m x (B754_finite sy my ey Hy)) =\n binary_overflow m (xorb (Bsign x) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(m : mode) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : B2R (B754_finite sy my ey Hy) <> 0%R)","proofString":"intros [sx|sx| |sx mx ex Hx] ;  try ( rewrite Rmult_0_l, round_0, Rabs_R0, Rlt_bool_true ; [ simpl ; try easy ; now rewrite B2R_build_nan, is_finite_build_nan, is_nan_build_nan | apply bpow_gt_0 | auto with typeclass_instances ] ).\nsimpl.\ncase Bdiv_correct_aux.\nintros H1.\nunfold Rdiv.\ncase Rlt_bool.\nintros (H2, (H3, H4)).\nsplit.\nnow rewrite B2R_SF2B.\nsplit.\nnow rewrite is_finite_SF2B.\nrewrite Bsign_SF2B.\ncongruence.\nintros H2.\nnow rewrite B2SF_SF2B."},{"statement":"(m : mode) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : B2R (B754_finite sy my ey Hy) <> 0%R) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) : if\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_finite sx mx ex Hx) * / B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R (Bdiv m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m)\n   (B2R (B754_finite sx mx ex Hx) * / B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bdiv m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n is_finite (B754_finite sx mx ex Hx) /\\\n (is_nan (Bdiv m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) = false ->\n  Bsign (Bdiv m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2SF (Bdiv m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow m\n   (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy))).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_finite sx mx ex Hx) * / B2R (B754_finite sy my ey Hy))))\n   (bpow radix2 emax)\nthen\n B2R (Bdiv m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n round radix2 fexp (round_mode m)\n   (B2R (B754_finite sx mx ex Hx) * / B2R (B754_finite sy my ey Hy)) /\\\n is_finite (Bdiv m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n is_finite (B754_finite sx mx ex Hx) /\\\n (is_nan (Bdiv m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) = false ->\n  Bsign (Bdiv m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n  xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))\nelse\n B2SF (Bdiv m (B754_finite sx mx ex Hx) (B754_finite sy my ey Hy)) =\n binary_overflow m\n   (xorb (Bsign (B754_finite sx mx ex Hx)) (Bsign (B754_finite sy my ey Hy)))","hypotheses":"(m : mode) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : B2R (B754_finite sy my ey Hy) <> 0%R) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"simpl.\ncase Bdiv_correct_aux.\nintros H1.\nunfold Rdiv.\ncase Rlt_bool.\nintros (H2, (H3, H4)).\nsplit.\nnow rewrite B2R_SF2B.\nsplit.\nnow rewrite is_finite_SF2B.\nrewrite Bsign_SF2B.\ncongruence.\nintros H2.\nnow rewrite B2SF_SF2B."},{"statement":"(m : mode) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : B2R (B754_finite sy my ey Hy) <> 0%R) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : valid_binary\n  (let\n   '(mz, ez, lz) := SFdiv_core_binary prec emax (Z.pos mx) ex (Z.pos my) ey\n    in binary_round_aux m (xorb sx sy) mz ez lz) = true) : forall\n  y : (let\n       '(mz, ez, lz) :=\n        SFdiv_core_binary prec emax (Z.pos mx) ex (Z.pos my) ey in\n        binary_round_aux m (xorb sx sy) mz ez lz) =\n      binary_overflow m (xorb sx sy),\nB2SF\n  (SF2B\n     (let\n      '(mz, ez, lz) :=\n       SFdiv_core_binary prec emax (Z.pos mx) ex (Z.pos my) ey in\n       binary_round_aux m (xorb sx sy) mz ez lz) (proj1 (conj H1 y))) =\nbinary_overflow m (xorb sx sy).","conclusion":"forall\n  y : (let\n       '(mz, ez, lz) :=\n        SFdiv_core_binary prec emax (Z.pos mx) ex (Z.pos my) ey in\n        binary_round_aux m (xorb sx sy) mz ez lz) =\n      binary_overflow m (xorb sx sy),\nB2SF\n  (SF2B\n     (let\n      '(mz, ez, lz) :=\n       SFdiv_core_binary prec emax (Z.pos mx) ex (Z.pos my) ey in\n       binary_round_aux m (xorb sx sy) mz ez lz) (proj1 (conj H1 y))) =\nbinary_overflow m (xorb sx sy)","hypotheses":"(m : mode) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : B2R (B754_finite sy my ey Hy) <> 0%R) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : valid_binary\n  (let\n   '(mz, ez, lz) := SFdiv_core_binary prec emax (Z.pos mx) ex (Z.pos my) ey\n    in binary_round_aux m (xorb sx sy) mz ez lz) = true)","proofString":"intros H2.\nnow rewrite B2SF_SF2B."},{"statement":"(m : mode) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : B2R (B754_finite sy my ey Hy) <> 0%R) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : valid_binary\n  (let\n   '(mz, ez, lz) := SFdiv_core_binary prec emax (Z.pos mx) ex (Z.pos my) ey\n    in binary_round_aux m (xorb sx sy) mz ez lz) = true) (H2 : (let\n '(mz, ez, lz) := SFdiv_core_binary prec emax (Z.pos mx) ex (Z.pos my) ey in\n  binary_round_aux m (xorb sx sy) mz ez lz) = binary_overflow m (xorb sx sy)) : B2SF\n  (SF2B\n     (let\n      '(mz, ez, lz) :=\n       SFdiv_core_binary prec emax (Z.pos mx) ex (Z.pos my) ey in\n       binary_round_aux m (xorb sx sy) mz ez lz) (proj1 (conj H1 H2))) =\nbinary_overflow m (xorb sx sy).","conclusion":"B2SF\n  (SF2B\n     (let\n      '(mz, ez, lz) :=\n       SFdiv_core_binary prec emax (Z.pos mx) ex (Z.pos my) ey in\n       binary_round_aux m (xorb sx sy) mz ez lz) (proj1 (conj H1 H2))) =\nbinary_overflow m (xorb sx sy)","hypotheses":"(m : mode) (sy : bool) (my : positive) (ey : Z) (Hy : bounded my ey = true) (Zy : B2R (B754_finite sy my ey Hy) <> 0%R) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (H1 : valid_binary\n  (let\n   '(mz, ez, lz) := SFdiv_core_binary prec emax (Z.pos mx) ex (Z.pos my) ey\n    in binary_round_aux m (xorb sx sy) mz ez lz) = true) (H2 : (let\n '(mz, ez, lz) := SFdiv_core_binary prec emax (Z.pos mx) ex (Z.pos my) ey in\n  binary_round_aux m (xorb sx sy) mz ez lz) = binary_overflow m (xorb sx sy))","proofString":"now rewrite B2SF_SF2B."},{"statement":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) : B2R (Bsqrt m (B754_finite sx mx ex Hx)) =\nround radix2 fexp (round_mode m) (sqrt (B2R (B754_finite sx mx ex Hx))) /\\\nis_finite (Bsqrt m (B754_finite sx mx ex Hx)) = (if sx then false else true) /\\\n(is_nan (Bsqrt m (B754_finite sx mx ex Hx)) = false ->\n Bsign (Bsqrt m (B754_finite sx mx ex Hx)) = Bsign (B754_finite sx mx ex Hx)).","conclusion":"B2R (Bsqrt m (B754_finite sx mx ex Hx)) =\nround radix2 fexp (round_mode m) (sqrt (B2R (B754_finite sx mx ex Hx))) /\\\nis_finite (Bsqrt m (B754_finite sx mx ex Hx)) = (if sx then false else true) /\\\n(is_nan (Bsqrt m (B754_finite sx mx ex Hx)) = false ->\n Bsign (Bsqrt m (B754_finite sx mx ex Hx)) = Bsign (B754_finite sx mx ex Hx))","hypotheses":"(m : mode) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"simpl.\ncase Bsqrt_correct_aux.\nintros H1 (H2, (H3, H4)).\ncase sx.\nrefine (conj _ (conj (refl_equal false) _)).\napply sym_eq.\nunfold sqrt.\ncase Rcase_abs.\nintros _.\napply round_0.\nauto with typeclass_instances.\nintros H.\nelim Rge_not_lt with (1 := H).\nnow apply F2R_lt_0.\neasy.\nsplit.\nnow rewrite B2R_SF2B.\nsplit.\nnow rewrite is_finite_SF2B.\nintros _.\nnow rewrite Bsign_SF2B."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) : (if (ex <? - prec)%Z\n then {| shr_m := 0; shr_r := false; shr_s := true |}\n else\n  fst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex)).","conclusion":"(if (ex <? - prec)%Z\n then {| shr_m := 0; shr_r := false; shr_s := true |}\n else\n  fst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record)","proofString":"case Zlt_bool_spec; [ | easy].\nintros Hex1.\nsymmetry.\napply shr_limit; simpl; [now left |].\napply Z.lt_le_trans with (radix2 ^ prec)%Z.\nunfold bounded, canonical_mantissa, fexp in Hmxex.\napply andb_prop in Hmxex.\ndestruct Hmxex as [Hmxex _].\napply Zeq_bool_eq in Hmxex.\nrewrite Zpos_digits2_pos in Hmxex.\napply Z.eq_le_incl in Hmxex.\napply Z.max_lub_l in Hmxex.\nassert (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) by lia.\nreplace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits.\napply Zpower_le.\nlia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) : (ex < - prec)%Z ->\n{| shr_m := 0; shr_r := false; shr_s := true |} =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex)).","conclusion":"(ex < - prec)%Z ->\n{| shr_m := 0; shr_r := false; shr_s := true |} =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record)","proofString":"intros Hex1.\nsymmetry.\napply shr_limit; simpl; [now left |].\napply Z.lt_le_trans with (radix2 ^ prec)%Z.\nunfold bounded, canonical_mantissa, fexp in Hmxex.\napply andb_prop in Hmxex.\ndestruct Hmxex as [Hmxex _].\napply Zeq_bool_eq in Hmxex.\nrewrite Zpos_digits2_pos in Hmxex.\napply Z.eq_le_incl in Hmxex.\napply Z.max_lub_l in Hmxex.\nassert (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) by lia.\nreplace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits.\napply Zpower_le.\nlia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) : {| shr_m := 0; shr_r := false; shr_s := true |} =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex)).","conclusion":"{| shr_m := 0; shr_r := false; shr_s := true |} =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z)","proofString":"symmetry.\napply shr_limit; simpl; [now left |].\napply Z.lt_le_trans with (radix2 ^ prec)%Z.\nunfold bounded, canonical_mantissa, fexp in Hmxex.\napply andb_prop in Hmxex.\ndestruct Hmxex as [Hmxex _].\napply Zeq_bool_eq in Hmxex.\nrewrite Zpos_digits2_pos in Hmxex.\napply Z.eq_le_incl in Hmxex.\napply Z.max_lub_l in Hmxex.\nassert (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) by lia.\nreplace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits.\napply Zpower_le.\nlia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) : fst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex)) =\n{| shr_m := 0; shr_r := false; shr_s := true |}.","conclusion":"fst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex)) =\n{| shr_m := 0; shr_r := false; shr_s := true |}","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z)","proofString":"apply shr_limit; simpl; [now left |].\napply Z.lt_le_trans with (radix2 ^ prec)%Z.\nunfold bounded, canonical_mantissa, fexp in Hmxex.\napply andb_prop in Hmxex.\ndestruct Hmxex as [Hmxex _].\napply Zeq_bool_eq in Hmxex.\nrewrite Zpos_digits2_pos in Hmxex.\napply Z.eq_le_incl in Hmxex.\napply Z.max_lub_l in Hmxex.\nassert (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) by lia.\nreplace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits.\napply Zpower_le.\nlia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) : (Z.pos mx < 2 ^ (- ex - 1))%Z.","conclusion":"(Z.pos mx < 2 ^ (- ex - 1))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z)","proofString":"apply Z.lt_le_trans with (radix2 ^ prec)%Z.\nunfold bounded, canonical_mantissa, fexp in Hmxex.\napply andb_prop in Hmxex.\ndestruct Hmxex as [Hmxex _].\napply Zeq_bool_eq in Hmxex.\nrewrite Zpos_digits2_pos in Hmxex.\napply Z.eq_le_incl in Hmxex.\napply Z.max_lub_l in Hmxex.\nassert (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) by lia.\nreplace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits.\napply Zpower_le.\nlia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) : (Z.pos mx < radix2 ^ prec)%Z.","conclusion":"(Z.pos mx < radix2 ^ prec)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z)","proofString":"unfold bounded, canonical_mantissa, fexp in Hmxex.\napply andb_prop in Hmxex.\ndestruct Hmxex as [Hmxex _].\napply Zeq_bool_eq in Hmxex.\nrewrite Zpos_digits2_pos in Hmxex.\napply Z.eq_le_incl in Hmxex.\napply Z.max_lub_l in Hmxex.\nassert (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) by lia.\nreplace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : (Zeq_bool (Z.max (Z.pos (digits2_pos mx) + ex - prec) emin) ex &&\n (ex <=? emax - prec)%Z)%bool = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) : (Z.pos mx < radix2 ^ prec)%Z.","conclusion":"(Z.pos mx < radix2 ^ prec)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : (Zeq_bool (Z.max (Z.pos (digits2_pos mx) + ex - prec) emin) ex &&\n (ex <=? emax - prec)%Z)%bool = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z)","proofString":"apply andb_prop in Hmxex.\ndestruct Hmxex as [Hmxex _].\napply Zeq_bool_eq in Hmxex.\nrewrite Zpos_digits2_pos in Hmxex.\napply Z.eq_le_incl in Hmxex.\napply Z.max_lub_l in Hmxex.\nassert (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) by lia.\nreplace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (Z.max (Z.pos (digits2_pos mx) + ex - prec) emin) ex = true /\\\n(ex <=? emax - prec)%Z = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) : (Z.pos mx < radix2 ^ prec)%Z.","conclusion":"(Z.pos mx < radix2 ^ prec)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (Z.max (Z.pos (digits2_pos mx) + ex - prec) emin) ex = true /\\\n(ex <=? emax - prec)%Z = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z)","proofString":"destruct Hmxex as [Hmxex _].\napply Zeq_bool_eq in Hmxex.\nrewrite Zpos_digits2_pos in Hmxex.\napply Z.eq_le_incl in Hmxex.\napply Z.max_lub_l in Hmxex.\nassert (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) by lia.\nreplace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (Z.max (Z.pos (digits2_pos mx) + ex - prec) emin) ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) : (Z.pos mx < radix2 ^ prec)%Z.","conclusion":"(Z.pos mx < radix2 ^ prec)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (Z.max (Z.pos (digits2_pos mx) + ex - prec) emin) ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z)","proofString":"apply Zeq_bool_eq in Hmxex.\nrewrite Zpos_digits2_pos in Hmxex.\napply Z.eq_le_incl in Hmxex.\napply Z.max_lub_l in Hmxex.\nassert (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) by lia.\nreplace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Z.max (Z.pos (digits2_pos mx) + ex - prec) emin = ex) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) : (Z.pos mx < radix2 ^ prec)%Z.","conclusion":"(Z.pos mx < radix2 ^ prec)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Z.max (Z.pos (digits2_pos mx) + ex - prec) emin = ex) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z)","proofString":"rewrite Zpos_digits2_pos in Hmxex.\napply Z.eq_le_incl in Hmxex.\napply Z.max_lub_l in Hmxex.\nassert (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) by lia.\nreplace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Z.max (Zdigits radix2 (Z.pos mx) + ex - prec) emin = ex) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) : (Z.pos mx < radix2 ^ prec)%Z.","conclusion":"(Z.pos mx < radix2 ^ prec)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Z.max (Zdigits radix2 (Z.pos mx) + ex - prec) emin = ex) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z)","proofString":"apply Z.eq_le_incl in Hmxex.\napply Z.max_lub_l in Hmxex.\nassert (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) by lia.\nreplace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : (Z.max (Zdigits radix2 (Z.pos mx) + ex - prec) emin <= ex)%Z) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) : (Z.pos mx < radix2 ^ prec)%Z.","conclusion":"(Z.pos mx < radix2 ^ prec)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : (Z.max (Zdigits radix2 (Z.pos mx) + ex - prec) emin <= ex)%Z) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z)","proofString":"apply Z.max_lub_l in Hmxex.\nassert (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) by lia.\nreplace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : (Zdigits radix2 (Z.pos mx) + ex - prec <= ex)%Z) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) : (Z.pos mx < radix2 ^ prec)%Z.","conclusion":"(Z.pos mx < radix2 ^ prec)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : (Zdigits radix2 (Z.pos mx) + ex - prec <= ex)%Z) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z)","proofString":"assert (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) by lia.\nreplace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : (Zdigits radix2 (Z.pos mx) + ex - prec <= ex)%Z) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) : (Z.pos mx < radix2 ^ prec)%Z.","conclusion":"(Z.pos mx < radix2 ^ prec)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : (Zdigits radix2 (Z.pos mx) + ex - prec <= ex)%Z) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z)","proofString":"replace (Z.pos mx) with (Z.abs (Z.pos mx)); [| now simpl].\nnow apply Zpower_gt_Zdigits."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : (Zdigits radix2 (Z.pos mx) + ex - prec <= ex)%Z) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z) : (Z.abs (Z.pos mx) < radix2 ^ prec)%Z.","conclusion":"(Z.abs (Z.pos mx) < radix2 ^ prec)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : (Zdigits radix2 (Z.pos mx) + ex - prec <= ex)%Z) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) (Hmx : (Zdigits radix2 (Z.pos mx) <= prec)%Z)","proofString":"now apply Zpower_gt_Zdigits."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) : (radix2 ^ prec <= 2 ^ (- ex - 1))%Z.","conclusion":"(radix2 ^ prec <= 2 ^ (- ex - 1))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z)","proofString":"apply Zpower_le.\nlia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z) : (prec <= - ex - 1)%Z.","conclusion":"(prec <= - ex - 1)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (Hex1 : (ex < - prec)%Z)","proofString":"lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) : (ex < 0)%Z -> (0 <= shr_m mrs')%Z.","conclusion":"(ex < 0)%Z -> (0 <= shr_m mrs')%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex)))","proofString":"intros Hex.\nrewrite mrs'_simpl.\napply (Z.mul_le_mono_pos_l _ _ (2 ^ (- ex))).\napply (Zpower_gt_0 radix2).\nlia.\nrewrite Z.mul_0_r.\napply le_shr_le.\neasy.\nlia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z) : (0 <= shr_m mrs')%Z.","conclusion":"(0 <= shr_m mrs')%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z)","proofString":"rewrite mrs'_simpl.\napply (Z.mul_le_mono_pos_l _ _ (2 ^ (- ex))).\napply (Zpower_gt_0 radix2).\nlia.\nrewrite Z.mul_0_r.\napply le_shr_le.\neasy.\nlia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z) : (0 <=\n shr_m\n   (fst\n      (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))))%Z.","conclusion":"(0 <=\n shr_m\n   (fst\n      (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z)","proofString":"apply (Z.mul_le_mono_pos_l _ _ (2 ^ (- ex))).\napply (Zpower_gt_0 radix2).\nlia.\nrewrite Z.mul_0_r.\napply le_shr_le.\neasy.\nlia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z) : (0 < 2 ^ (- ex))%Z.","conclusion":"(0 < 2 ^ (- ex))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z)","proofString":"apply (Zpower_gt_0 radix2).\nlia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z) : (0 <= - ex)%Z.","conclusion":"(0 <= - ex)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z)","proofString":"lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z) : (2 ^ (- ex) * 0 <=\n 2 ^ (- ex) *\n shr_m\n   (fst\n      (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))))%Z.","conclusion":"(2 ^ (- ex) * 0 <=\n 2 ^ (- ex) *\n shr_m\n   (fst\n      (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z)","proofString":"rewrite Z.mul_0_r.\napply le_shr_le.\neasy.\nlia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z) : (0 <=\n 2 ^ (- ex) *\n shr_m\n   (fst\n      (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))))%Z.","conclusion":"(0 <=\n 2 ^ (- ex) *\n shr_m\n   (fst\n      (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z)","proofString":"apply le_shr_le.\neasy.\nlia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z) : (0 <= shr_m {| shr_m := Z.pos mx; shr_r := false; shr_s := false |})%Z.","conclusion":"(0 <= shr_m {| shr_m := Z.pos mx; shr_r := false; shr_s := false |})%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z)","proofString":"easy."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z) : (0 <= - ex)%Z.","conclusion":"(0 <= - ex)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (Hex : (ex < 0)%Z)","proofString":"lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (shr_m mrs' <= Z.pos mx / 2 ^ (- ex))%Z.","conclusion":"(shr_m mrs' <= Z.pos mx / 2 ^ (- ex))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"apply Zdiv.Zdiv_le_lower_bound; [lia |].\nrewrite Z.mul_comm.\nrewrite mrs'_simpl.\napply le_shr_le; simpl; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (shr_m mrs' * 2 ^ (- ex) <= Z.pos mx)%Z.","conclusion":"(shr_m mrs' * 2 ^ (- ex) <= Z.pos mx)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"rewrite Z.mul_comm.\nrewrite mrs'_simpl.\napply le_shr_le; simpl; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (2 ^ (- ex) * shr_m mrs' <= Z.pos mx)%Z.","conclusion":"(2 ^ (- ex) * shr_m mrs' <= Z.pos mx)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"rewrite mrs'_simpl.\napply le_shr_le; simpl; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (2 ^ (- ex) *\n shr_m\n   (fst\n      (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) <=\n Z.pos mx)%Z.","conclusion":"(2 ^ (- ex) *\n shr_m\n   (fst\n      (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) <=\n Z.pos mx)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"apply le_shr_le; simpl; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (fexp (Zdigits radix2 (Z.pos mx / 2 ^ (- ex)) + 1) <=\n fexp (Zdigits radix2 (Z.pos mx / 2 ^ 1) + 1))%Z.","conclusion":"(fexp (Zdigits radix2 (Z.pos mx / 2 ^ (- ex)) + 1) <=\n fexp (Zdigits radix2 (Z.pos mx / 2 ^ 1) + 1))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"apply fexp_monotone.\napply Zplus_le_compat_r.\napply Zdigits_le.\napply Z.div_pos; lia.\napply Z.opp_pos_neg in Hex0.\napply Z.div_le_compat_l; [lia |].\nsplit; [lia |].\napply Z.pow_le_mono_r; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (Zdigits radix2 (Z.pos mx / 2 ^ (- ex)) + 1 <=\n Zdigits radix2 (Z.pos mx / 2 ^ 1) + 1)%Z.","conclusion":"(Zdigits radix2 (Z.pos mx / 2 ^ (- ex)) + 1 <=\n Zdigits radix2 (Z.pos mx / 2 ^ 1) + 1)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"apply Zplus_le_compat_r.\napply Zdigits_le.\napply Z.div_pos; lia.\napply Z.opp_pos_neg in Hex0.\napply Z.div_le_compat_l; [lia |].\nsplit; [lia |].\napply Z.pow_le_mono_r; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (Zdigits radix2 (Z.pos mx / 2 ^ (- ex)) <= Zdigits radix2 (Z.pos mx / 2 ^ 1))%Z.","conclusion":"(Zdigits radix2 (Z.pos mx / 2 ^ (- ex)) <= Zdigits radix2 (Z.pos mx / 2 ^ 1))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"apply Zdigits_le.\napply Z.div_pos; lia.\napply Z.opp_pos_neg in Hex0.\napply Z.div_le_compat_l; [lia |].\nsplit; [lia |].\napply Z.pow_le_mono_r; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (0 <= Z.pos mx / 2 ^ (- ex))%Z.","conclusion":"(0 <= Z.pos mx / 2 ^ (- ex))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"apply Z.div_pos; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (Z.pos mx / 2 ^ (- ex) <= Z.pos mx / 2 ^ 1)%Z.","conclusion":"(Z.pos mx / 2 ^ (- ex) <= Z.pos mx / 2 ^ 1)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"apply Z.opp_pos_neg in Hex0.\napply Z.div_le_compat_l; [lia |].\nsplit; [lia |].\napply Z.pow_le_mono_r; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (0 < - ex)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (Z.pos mx / 2 ^ (- ex) <= Z.pos mx / 2 ^ 1)%Z.","conclusion":"(Z.pos mx / 2 ^ (- ex) <= Z.pos mx / 2 ^ 1)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (0 < - ex)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"apply Z.div_le_compat_l; [lia |].\nsplit; [lia |].\napply Z.pow_le_mono_r; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (0 < - ex)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (0 < 2 ^ 1 <= 2 ^ (- ex))%Z.","conclusion":"(0 < 2 ^ 1 <= 2 ^ (- ex))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (0 < - ex)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"split; [lia |].\napply Z.pow_le_mono_r; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (0 < - ex)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (2 ^ 1 <= 2 ^ (- ex))%Z.","conclusion":"(2 ^ 1 <= 2 ^ (- ex))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (0 < - ex)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"apply Z.pow_le_mono_r; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (1 <= Zdigits radix2 (Z.pos mx))%Z.","conclusion":"(1 <= Zdigits radix2 (Z.pos mx))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"replace 1%Z with (Zdigits radix2 (Z.pos 1)); [| easy].\napply Zdigits_le; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z) : (Zdigits radix2 1 <= Zdigits radix2 (Z.pos mx))%Z.","conclusion":"(Zdigits radix2 1 <= Zdigits radix2 (Z.pos mx))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Zdigits radix2 (Z.pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Zdigits radix2 (Z.pos p))) = (mx''', ex''')) (H2 : (0 <= 2 ^ (- ex) * shr_m (fst (shr mrs' ex (- ex))) <= shr_m mrs')%Z) (H3 : (shr_m mrs' < 2 ^ (- ex) * (shr_m (fst (shr mrs' ex (- ex))) + 1))%Z) (H4 : (shr_m mrs' <= Z.pos p)%Z) (H5 : (Z.pos p <= shr_m mrs' + 1)%Z)","proofString":"apply Zdigits_le; lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Z.pos (digits2_pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Z.pos (digits2_pos p) + 0)) = (mx''', ex''')) (A : (fexp (Z.pos (digits2_pos p) + 0) <= 0)%Z) : (fexp (Z.pos (digits2_pos p) + 0) <= 0)%Z.","conclusion":"(fexp (Z.pos (digits2_pos p) + 0) <= 0)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : Zeq_bool (fexp (Z.pos (digits2_pos mx) + ex)) ex = true) (Hex' : (ex <=? emax - prec)%Z = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (p : positive) (H0 : choice_mode md sx (shr_m mrs') (loc_of_shr_record mrs') = Z.pos p) (mx''' : positive) (ex''' : Z) (H1 : shl_align p 0 (fexp (Z.pos (digits2_pos p) + 0)) = (mx''', ex''')) (A : (fexp (Z.pos (digits2_pos p) + 0) <= 0)%Z)","proofString":"assumption."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (0 <= ex)%Z) : Valid_rnd (round_mode md).","conclusion":"Valid_rnd (round_mode md)","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (0 <= ex)%Z)","proofString":"apply valid_rnd_round_mode."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (0 <= ex)%Z) : generic_format radix2 (FIX_exp 0) (SF2R radix2 (S754_finite sx mx ex)).","conclusion":"generic_format radix2 (FIX_exp 0) (SF2R radix2 (S754_finite sx mx ex))","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (0 <= ex)%Z)","proofString":"apply generic_format_FIX.\nexists (Float radix2 (cond_Zopp sx (Z.pos mx) * Z.pow 2 ex) 0); auto.\nsimpl.\nrewrite <-(Z.sub_0_r ex) at 2.\nnow apply F2R_change_exp."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (0 <= ex)%Z) : FIX_format radix2 0 (SF2R radix2 (S754_finite sx mx ex)).","conclusion":"FIX_format radix2 0 (SF2R radix2 (S754_finite sx mx ex))","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (0 <= ex)%Z)","proofString":"exists (Float radix2 (cond_Zopp sx (Z.pos mx) * Z.pow 2 ex) 0); auto.\nsimpl.\nrewrite <-(Z.sub_0_r ex) at 2.\nnow apply F2R_change_exp."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' = fst (shr (shr_record_of_loc (Z.pos mx) loc_Exact) ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (rec : Z * Z) (loc : location) (z0 z1 : Z) (H1 : rec = (z0, z1)) (H0 : ((Z.pos mx / 2 ^ (- ex))%Z, (ex + - ex)%Z,\n new_location (2 ^ (- ex)) (Z.pos mx mod 2 ^ (- ex)) loc_Exact) =\n(z0, z1, loc)) (p0 : positive) (H2 : choice_mode md sx z0 loc = Z.neg p0) (H3 : (z0 <= Z.neg p0)%Z) (H4 : (Z.pos mx / 2 ^ (- ex))%Z = z0) : (0 <= z0)%Z.","conclusion":"(0 <= z0)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' = fst (shr (shr_record_of_loc (Z.pos mx) loc_Exact) ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (rec : Z * Z) (loc : location) (z0 z1 : Z) (H1 : rec = (z0, z1)) (H0 : ((Z.pos mx / 2 ^ (- ex))%Z, (ex + - ex)%Z,\n new_location (2 ^ (- ex)) (Z.pos mx mod 2 ^ (- ex)) loc_Exact) =\n(z0, z1, loc)) (p0 : positive) (H2 : choice_mode md sx z0 loc = Z.neg p0) (H3 : (z0 <= Z.neg p0)%Z) (H4 : (Z.pos mx / 2 ^ (- ex))%Z = z0)","proofString":"rewrite <- H4.\napply Z_div_pos.\napply Z.lt_gt, (Zpower_gt_0 radix2).\nlia.\neasy."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' = fst (shr (shr_record_of_loc (Z.pos mx) loc_Exact) ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (rec : Z * Z) (loc : location) (z0 z1 : Z) (H1 : rec = (z0, z1)) (H0 : ((Z.pos mx / 2 ^ (- ex))%Z, (ex + - ex)%Z,\n new_location (2 ^ (- ex)) (Z.pos mx mod 2 ^ (- ex)) loc_Exact) =\n(z0, z1, loc)) (p0 : positive) (H2 : choice_mode md sx z0 loc = Z.neg p0) (H3 : (z0 <= Z.neg p0)%Z) (H4 : (Z.pos mx / 2 ^ (- ex))%Z = z0) : (0 <= Z.pos mx / 2 ^ (- ex))%Z.","conclusion":"(0 <= Z.pos mx / 2 ^ (- ex))%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' = fst (shr (shr_record_of_loc (Z.pos mx) loc_Exact) ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (rec : Z * Z) (loc : location) (z0 z1 : Z) (H1 : rec = (z0, z1)) (H0 : ((Z.pos mx / 2 ^ (- ex))%Z, (ex + - ex)%Z,\n new_location (2 ^ (- ex)) (Z.pos mx mod 2 ^ (- ex)) loc_Exact) =\n(z0, z1, loc)) (p0 : positive) (H2 : choice_mode md sx z0 loc = Z.neg p0) (H3 : (z0 <= Z.neg p0)%Z) (H4 : (Z.pos mx / 2 ^ (- ex))%Z = z0)","proofString":"apply Z_div_pos.\napply Z.lt_gt, (Zpower_gt_0 radix2).\nlia.\neasy."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' = fst (shr (shr_record_of_loc (Z.pos mx) loc_Exact) ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (rec : Z * Z) (loc : location) (z0 z1 : Z) (H1 : rec = (z0, z1)) (H0 : ((Z.pos mx / 2 ^ (- ex))%Z, (ex + - ex)%Z,\n new_location (2 ^ (- ex)) (Z.pos mx mod 2 ^ (- ex)) loc_Exact) =\n(z0, z1, loc)) (p0 : positive) (H2 : choice_mode md sx z0 loc = Z.neg p0) (H3 : (z0 <= Z.neg p0)%Z) (H4 : (Z.pos mx / 2 ^ (- ex))%Z = z0) : (2 ^ (- ex) > 0)%Z.","conclusion":"(2 ^ (- ex) > 0)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' = fst (shr (shr_record_of_loc (Z.pos mx) loc_Exact) ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (rec : Z * Z) (loc : location) (z0 z1 : Z) (H1 : rec = (z0, z1)) (H0 : ((Z.pos mx / 2 ^ (- ex))%Z, (ex + - ex)%Z,\n new_location (2 ^ (- ex)) (Z.pos mx mod 2 ^ (- ex)) loc_Exact) =\n(z0, z1, loc)) (p0 : positive) (H2 : choice_mode md sx z0 loc = Z.neg p0) (H3 : (z0 <= Z.neg p0)%Z) (H4 : (Z.pos mx / 2 ^ (- ex))%Z = z0)","proofString":"apply Z.lt_gt, (Zpower_gt_0 radix2).\nlia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' = fst (shr (shr_record_of_loc (Z.pos mx) loc_Exact) ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (rec : Z * Z) (loc : location) (z0 z1 : Z) (H1 : rec = (z0, z1)) (H0 : ((Z.pos mx / 2 ^ (- ex))%Z, (ex + - ex)%Z,\n new_location (2 ^ (- ex)) (Z.pos mx mod 2 ^ (- ex)) loc_Exact) =\n(z0, z1, loc)) (p0 : positive) (H2 : choice_mode md sx z0 loc = Z.neg p0) (H3 : (z0 <= Z.neg p0)%Z) (H4 : (Z.pos mx / 2 ^ (- ex))%Z = z0) : (0 <= - ex)%Z.","conclusion":"(0 <= - ex)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' = fst (shr (shr_record_of_loc (Z.pos mx) loc_Exact) ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (rec : Z * Z) (loc : location) (z0 z1 : Z) (H1 : rec = (z0, z1)) (H0 : ((Z.pos mx / 2 ^ (- ex))%Z, (ex + - ex)%Z,\n new_location (2 ^ (- ex)) (Z.pos mx mod 2 ^ (- ex)) loc_Exact) =\n(z0, z1, loc)) (p0 : positive) (H2 : choice_mode md sx z0 loc = Z.neg p0) (H3 : (z0 <= Z.neg p0)%Z) (H4 : (Z.pos mx / 2 ^ (- ex))%Z = z0)","proofString":"lia."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' = fst (shr (shr_record_of_loc (Z.pos mx) loc_Exact) ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (rec : Z * Z) (loc : location) (z0 z1 : Z) (H1 : rec = (z0, z1)) (H0 : ((Z.pos mx / 2 ^ (- ex))%Z, (ex + - ex)%Z,\n new_location (2 ^ (- ex)) (Z.pos mx mod 2 ^ (- ex)) loc_Exact) =\n(z0, z1, loc)) (p0 : positive) (H2 : choice_mode md sx z0 loc = Z.neg p0) (H3 : (z0 <= Z.neg p0)%Z) (H4 : (Z.pos mx / 2 ^ (- ex))%Z = z0) : (0 <= Z.pos mx)%Z.","conclusion":"(0 <= Z.pos mx)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' = fst (shr (shr_record_of_loc (Z.pos mx) loc_Exact) ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (rec : Z * Z) (loc : location) (z0 z1 : Z) (H1 : rec = (z0, z1)) (H0 : ((Z.pos mx / 2 ^ (- ex))%Z, (ex + - ex)%Z,\n new_location (2 ^ (- ex)) (Z.pos mx mod 2 ^ (- ex)) loc_Exact) =\n(z0, z1, loc)) (p0 : positive) (H2 : choice_mode md sx z0 loc = Z.neg p0) (H3 : (z0 <= Z.neg p0)%Z) (H4 : (Z.pos mx / 2 ^ (- ex))%Z = z0)","proofString":"easy."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' = fst (shr (shr_record_of_loc (Z.pos mx) loc_Exact) ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (rec : Z * Z) (loc : location) (z0 z1 : Z) (H1 : rec = (z0, z1)) (H0 : ((Z.pos mx / 2 ^ (- ex))%Z, (ex + - ex)%Z,\n new_location (2 ^ (- ex)) (Z.pos mx mod 2 ^ (- ex)) loc_Exact) =\n(z0, z1, loc)) (p0 : positive) (H2 : choice_mode md sx z0 loc = Z.neg p0) (H3 : (z0 <= Z.neg p0)%Z) (H4 : (Z.pos mx / 2 ^ (- ex))%Z = z0) : (z0 < 0)%Z.","conclusion":"(z0 < 0)%Z","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' = fst (shr (shr_record_of_loc (Z.pos mx) loc_Exact) ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) (rec : Z * Z) (loc : location) (z0 z1 : Z) (H1 : rec = (z0, z1)) (H0 : ((Z.pos mx / 2 ^ (- ex))%Z, (ex + - ex)%Z,\n new_location (2 ^ (- ex)) (Z.pos mx mod 2 ^ (- ex)) loc_Exact) =\n(z0, z1, loc)) (p0 : positive) (H2 : choice_mode md sx z0 loc = Z.neg p0) (H3 : (z0 <= Z.neg p0)%Z) (H4 : (Z.pos mx / 2 ^ (- ex))%Z = z0)","proofString":"now apply Z.le_lt_trans with (1 := H3)."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) : Valid_exp (FIX_exp 0).","conclusion":"Valid_exp (FIX_exp 0)","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z)","proofString":"apply FIX_exp_valid."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) : Valid_rnd (round_mode md).","conclusion":"Valid_rnd (round_mode md)","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z)","proofString":"apply valid_rnd_round_mode."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) : forall (x : R) (m : Z) (l : location),\ninbetween_int m (Rabs x) l ->\nround_mode md x =\ncond_Zopp (Rlt_bool x 0) (choice_mode md (Rlt_bool x 0) m l).","conclusion":"forall (x : R) (m : Z) (l : location),\ninbetween_int m (Rabs x) l ->\nround_mode md x =\ncond_Zopp (Rlt_bool x 0) (choice_mode md (Rlt_bool x 0) m l)","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z)","proofString":"apply round_mode_choice_mode."},{"statement":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z) : (ex <= FIX_exp 0 (Zdigits radix2 (Z.pos mx) + ex))%Z \\/ loc_Exact = loc_Exact.","conclusion":"(ex <= FIX_exp 0 (Zdigits radix2 (Z.pos mx) + ex))%Z \\/ loc_Exact = loc_Exact","hypotheses":"(md : mode) (sx : bool) (mx : positive) (ex : Z) (Hmxex : bounded mx ex = true) (mrs' : shr_record) (mrs'_simpl : mrs' =\nfst (shr {| shr_m := Z.pos mx; shr_r := false; shr_s := false |} ex (- ex))) (mrs'_ge_0 : (ex < 0)%Z -> (0 <= shr_m mrs')%Z) (Hex0 : (ex < 0)%Z)","proofString":"auto."},{"statement":"(md : mode) : forall x : binary_float,\nB2R (Bnearbyint md x) = round radix2 (FIX_exp 0) (round_mode md) (B2R x) /\\\nis_finite (Bnearbyint md x) = is_finite x /\\\n(is_nan (Bnearbyint md x) = false -> Bsign (Bnearbyint md x) = Bsign x).","conclusion":"forall x : binary_float,\nB2R (Bnearbyint md x) = round radix2 (FIX_exp 0) (round_mode md) (B2R x) /\\\nis_finite (Bnearbyint md x) = is_finite x /\\\n(is_nan (Bnearbyint md x) = false -> Bsign (Bnearbyint md x) = Bsign x)","hypotheses":"(md : mode)","proofString":"assert (round_0_ : 0%R = (round radix2 (FIX_exp 0) (round_mode md) 0)).\nsymmetry.\napply round_0.\napply valid_rnd_round_mode.\nintros [sx | sx | | sx mx ex Hx]; try easy.\nunfold Bnearbyint.\ndestruct Bnearbyint_correct_aux as [H1 [H2 [H3 H4]]].\nrepeat split.\nrewrite B2R_SF2B.\neasy.\nrewrite is_finite_SF2B.\neasy.\nrewrite is_nan_SF2B.\nrewrite Bsign_SF2B.\neasy."},{"statement":"(md : mode) : 0%R = round radix2 (FIX_exp 0) (round_mode md) 0.","conclusion":"0%R = round radix2 (FIX_exp 0) (round_mode md) 0","hypotheses":"(md : mode)","proofString":"symmetry.\napply round_0.\napply valid_rnd_round_mode."},{"statement":"(md : mode) : round radix2 (FIX_exp 0) (round_mode md) 0 = 0%R.","conclusion":"round radix2 (FIX_exp 0) (round_mode md) 0 = 0%R","hypotheses":"(md : mode)","proofString":"apply round_0.\napply valid_rnd_round_mode."},{"statement":"(md : mode) : Valid_rnd (round_mode md).","conclusion":"Valid_rnd (round_mode md)","hypotheses":"(md : mode)","proofString":"apply valid_rnd_round_mode."},{"statement":"(md : mode) (round_0_ : 0%R = round radix2 (FIX_exp 0) (round_mode md) 0) : forall x : binary_float,\nB2R (Bnearbyint md x) = round radix2 (FIX_exp 0) (round_mode md) (B2R x) /\\\nis_finite (Bnearbyint md x) = is_finite x /\\\n(is_nan (Bnearbyint md x) = false -> Bsign (Bnearbyint md x) = Bsign x).","conclusion":"forall x : binary_float,\nB2R (Bnearbyint md x) = round radix2 (FIX_exp 0) (round_mode md) (B2R x) /\\\nis_finite (Bnearbyint md x) = is_finite x /\\\n(is_nan (Bnearbyint md x) = false -> Bsign (Bnearbyint md x) = Bsign x)","hypotheses":"(md : mode) (round_0_ : 0%R = round radix2 (FIX_exp 0) (round_mode md) 0)","proofString":"intros [sx | sx | | sx mx ex Hx]; try easy.\nunfold Bnearbyint.\ndestruct Bnearbyint_correct_aux as [H1 [H2 [H3 H4]]].\nrepeat split.\nrewrite B2R_SF2B.\neasy.\nrewrite is_finite_SF2B.\neasy.\nrewrite is_nan_SF2B.\nrewrite Bsign_SF2B.\neasy."},{"statement":"(md : mode) (round_0_ : 0%R = round radix2 (FIX_exp 0) (round_mode md) 0) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) : B2R (Bnearbyint md (B754_finite sx mx ex Hx)) =\nround radix2 (FIX_exp 0) (round_mode md) (B2R (B754_finite sx mx ex Hx)) /\\\nis_finite (Bnearbyint md (B754_finite sx mx ex Hx)) =\nis_finite (B754_finite sx mx ex Hx) /\\\n(is_nan (Bnearbyint md (B754_finite sx mx ex Hx)) = false ->\n Bsign (Bnearbyint md (B754_finite sx mx ex Hx)) =\n Bsign (B754_finite sx mx ex Hx)).","conclusion":"B2R (Bnearbyint md (B754_finite sx mx ex Hx)) =\nround radix2 (FIX_exp 0) (round_mode md) (B2R (B754_finite sx mx ex Hx)) /\\\nis_finite (Bnearbyint md (B754_finite sx mx ex Hx)) =\nis_finite (B754_finite sx mx ex Hx) /\\\n(is_nan (Bnearbyint md (B754_finite sx mx ex Hx)) = false ->\n Bsign (Bnearbyint md (B754_finite sx mx ex Hx)) =\n Bsign (B754_finite sx mx ex Hx))","hypotheses":"(md : mode) (round_0_ : 0%R = round radix2 (FIX_exp 0) (round_mode md) 0) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"unfold Bnearbyint.\ndestruct Bnearbyint_correct_aux as [H1 [H2 [H3 H4]]].\nrepeat split.\nrewrite B2R_SF2B.\neasy.\nrewrite is_finite_SF2B.\neasy.\nrewrite is_nan_SF2B.\nrewrite Bsign_SF2B.\neasy."},{"statement":"(md : mode) (round_0_ : 0%R = round radix2 (FIX_exp 0) (round_mode md) 0) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) : B2R\n  (SF2B (SFnearbyint_binary md sx mx ex)\n     (proj1 (Bnearbyint_correct_aux md sx mx ex Hx))) =\nround radix2 (FIX_exp 0) (round_mode md) (B2R (B754_finite sx mx ex Hx)) /\\\nis_finite\n  (SF2B (SFnearbyint_binary md sx mx ex)\n     (proj1 (Bnearbyint_correct_aux md sx mx ex Hx))) =\nis_finite (B754_finite sx mx ex Hx) /\\\n(is_nan\n   (SF2B (SFnearbyint_binary md sx mx ex)\n      (proj1 (Bnearbyint_correct_aux md sx mx ex Hx))) = false ->\n Bsign\n   (SF2B (SFnearbyint_binary md sx mx ex)\n      (proj1 (Bnearbyint_correct_aux md sx mx ex Hx))) =\n Bsign (B754_finite sx mx ex Hx)).","conclusion":"B2R\n  (SF2B (SFnearbyint_binary md sx mx ex)\n     (proj1 (Bnearbyint_correct_aux md sx mx ex Hx))) =\nround radix2 (FIX_exp 0) (round_mode md) (B2R (B754_finite sx mx ex Hx)) /\\\nis_finite\n  (SF2B (SFnearbyint_binary md sx mx ex)\n     (proj1 (Bnearbyint_correct_aux md sx mx ex Hx))) =\nis_finite (B754_finite sx mx ex Hx) /\\\n(is_nan\n   (SF2B (SFnearbyint_binary md sx mx ex)\n      (proj1 (Bnearbyint_correct_aux md sx mx ex Hx))) = false ->\n Bsign\n   (SF2B (SFnearbyint_binary md sx mx ex)\n      (proj1 (Bnearbyint_correct_aux md sx mx ex Hx))) =\n Bsign (B754_finite sx mx ex Hx))","hypotheses":"(md : mode) (round_0_ : 0%R = round radix2 (FIX_exp 0) (round_mode md) 0) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true)","proofString":"destruct Bnearbyint_correct_aux as [H1 [H2 [H3 H4]]].\nrepeat split.\nrewrite B2R_SF2B.\neasy.\nrewrite is_finite_SF2B.\neasy.\nrewrite is_nan_SF2B.\nrewrite Bsign_SF2B.\neasy."},{"statement":"B2R\n  (SF2B (binary_round mode_NE false 1 0)\n     (proj1 (binary_round_correct mode_NE false 1 0))) = 1%R.","conclusion":"B2R\n  (SF2B (binary_round mode_NE false 1 0)\n     (proj1 (binary_round_correct mode_NE false 1 0))) = 1%R","hypotheses":"","proofString":"set (Hr := binary_round_correct _ _ _ _).\nunfold Hr; rewrite B2R_SF2B.\ndestruct Hr as (Vz, Hr).\nrevert Hr.\nfold emin; simpl.\nrewrite round_generic; [|now apply valid_rnd_N|].\nunfold F2R; simpl; rewrite Rmult_1_r.\nrewrite Rlt_bool_true.\nnow intros (Hr, Hr'); rewrite Hr.\nrewrite Rabs_R1.\nchange 1%R with (bpow radix2 0); apply bpow_lt.\ngeneralize (prec_gt_0 prec) (prec_lt_emax prec emax).\nlia.\napply generic_format_F2R; intros _.\nunfold cexp, fexp, FLT_exp, F2R; simpl; rewrite Rmult_1_r, mag_1.\nunfold emin.\ngeneralize (prec_gt_0 prec) (prec_lt_emax prec emax).\nlia."},{"statement":"(Vz : valid_binary (binary_round mode_NE false 1 0) = true) : SF2R radix2 (binary_round mode_NE false 1 0) = 1%R /\\\nis_finite_SF (binary_round mode_NE false 1 0) = true /\\\nsign_SF (binary_round mode_NE false 1 0) = false ->\nSF2R radix2 (binary_round mode_NE false 1 0) = 1%R.","conclusion":"SF2R radix2 (binary_round mode_NE false 1 0) = 1%R /\\\nis_finite_SF (binary_round mode_NE false 1 0) = true /\\\nsign_SF (binary_round mode_NE false 1 0) = false ->\nSF2R radix2 (binary_round mode_NE false 1 0) = 1%R","hypotheses":"(Vz : valid_binary (binary_round mode_NE false 1 0) = true)","proofString":"now intros (Hr, Hr'); rewrite Hr."},{"statement":"(Vz : valid_binary (binary_round mode_NE false 1 0) = true) : (Z.max (1 - prec) emin <= 0)%Z.","conclusion":"(Z.max (1 - prec) emin <= 0)%Z","hypotheses":"(Vz : valid_binary (binary_round mode_NE false 1 0) = true)","proofString":"unfold emin.\ngeneralize (prec_gt_0 prec) (prec_lt_emax prec emax).\nlia."},{"statement":"(Vz : valid_binary (binary_round mode_NE false 1 0) = true) : (Z.max (1 - prec) (3 - emax - prec) <= 0)%Z.","conclusion":"(Z.max (1 - prec) (3 - emax - prec) <= 0)%Z","hypotheses":"(Vz : valid_binary (binary_round mode_NE false 1 0) = true)","proofString":"generalize (prec_gt_0 prec) (prec_lt_emax prec emax).\nlia."},{"statement":"(Vz : valid_binary (binary_round mode_NE false 1 0) = true) : (0 < prec)%Z ->\n(prec < emax)%Z -> (Z.max (1 - prec) (3 - emax - prec) <= 0)%Z.","conclusion":"(0 < prec)%Z ->\n(prec < emax)%Z -> (Z.max (1 - prec) (3 - emax - prec) <= 0)%Z","hypotheses":"(Vz : valid_binary (binary_round mode_NE false 1 0) = true)","proofString":"lia."},{"statement":"B2R Bone <> 0%R.","conclusion":"B2R Bone <> 0%R","hypotheses":"","proofString":"rewrite Bone_correct.\napply R1_neq_R0."},{"statement":"1%R <> 0%R.","conclusion":"1%R <> 0%R","hypotheses":"","proofString":"apply R1_neq_R0."},{"statement":"is_nan\n  (SF2B (binary_round mode_NE false 1 0)\n     (proj1 (binary_round_correct mode_NE false 1 0))) = false.","conclusion":"is_nan\n  (SF2B (binary_round mode_NE false 1 0)\n     (proj1 (binary_round_correct mode_NE false 1 0))) = false","hypotheses":"","proofString":"rewrite is_nan_SF2B.\napply is_nan_binary_round."},{"statement":"is_nan_SF (binary_round mode_NE false 1 0) = false.","conclusion":"is_nan_SF (binary_round mode_NE false 1 0) = false","hypotheses":"","proofString":"apply is_nan_binary_round."},{"statement":"is_finite_strict Bone = true -> is_finite Bone = true.","conclusion":"is_finite_strict Bone = true -> is_finite Bone = true","hypotheses":"","proofString":"now destruct Bone."},{"statement":"B2R Bone = 1%R -> is_finite_strict Bone = true -> Bsign Bone = false.","conclusion":"B2R Bone = 1%R -> is_finite_strict Bone = true -> Bsign Bone = false","hypotheses":"","proofString":"destruct Bone as [sx|sx| |[|] mx ex Bx] ; try easy.\nintros H _.\ncontradict H.\napply Rlt_not_eq, Rlt_trans with (2 := Rlt_0_1).\nnow apply F2R_lt_0."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) : B2R (B754_finite true mx ex Bx) = 1%R ->\nis_finite_strict (B754_finite true mx ex Bx) = true ->\nBsign (B754_finite true mx ex Bx) = false.","conclusion":"B2R (B754_finite true mx ex Bx) = 1%R ->\nis_finite_strict (B754_finite true mx ex Bx) = true ->\nBsign (B754_finite true mx ex Bx) = false","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"intros H _.\ncontradict H.\napply Rlt_not_eq, Rlt_trans with (2 := Rlt_0_1).\nnow apply F2R_lt_0."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (H : B2R (B754_finite true mx ex Bx) = 1%R) : Bsign (B754_finite true mx ex Bx) = false.","conclusion":"Bsign (B754_finite true mx ex Bx) = false","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) (H : B2R (B754_finite true mx ex Bx) = 1%R)","proofString":"contradict H.\napply Rlt_not_eq, Rlt_trans with (2 := Rlt_0_1).\nnow apply F2R_lt_0."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) : B2R (B754_finite true mx ex Bx) <> 1%R.","conclusion":"B2R (B754_finite true mx ex Bx) <> 1%R","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"apply Rlt_not_eq, Rlt_trans with (2 := Rlt_0_1).\nnow apply F2R_lt_0."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) : (B2R (B754_finite true mx ex Bx) < 0)%R.","conclusion":"(B2R (B754_finite true mx ex Bx) < 0)%R","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"now apply F2R_lt_0."},{"statement":"canonical_mantissa (shift_pos (Z.to_pos prec) 1 - 1) (emax - prec) = true.","conclusion":"canonical_mantissa (shift_pos (Z.to_pos prec) 1 - 1) (emax - prec) = true","hypotheses":"","proofString":"unfold canonical_mantissa; apply Zeq_bool_true.\nset (p := Z.pos (digits2_pos _)).\nassert (H : p = prec).\nunfold p; rewrite Zpos_digits2_pos, Pos2Z.inj_sub.\nrewrite shift_pos_correct, Z.mul_1_r.\nassert (P2pm1 : (0 <= 2 ^ prec - 1)%Z).\napply Z.lt_le_pred.\napply (Zpower_gt_0 radix2).\nnow apply Zlt_le_weak.\napply Zdigits_unique ;        rewrite Z.pow_pos_fold, Z2Pos.id; [|exact prec_gt_0_]; simpl; split.\nrewrite (Z.abs_eq _ P2pm1).\napply Z.lt_le_pred.\napply (Zpower_lt radix2).\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\nrewrite Z.abs_eq by easy.\napply Z.lt_pred_l.\nchange (Z.pos 1 < Z.pos (shift_pos (Z.to_pos prec) 1))%Z.\nrewrite shift_pos_correct, Z.mul_1_r, Z.pow_pos_fold.\nrewrite Z2Pos.id; [|exact prec_gt_0_].\nnow apply (Zpower_gt_1 radix2).\nrewrite H.\nring_simplify (prec + (emax - prec))%Z.\napply fexp_emax."},{"statement":"fexp (Z.pos (digits2_pos (shift_pos (Z.to_pos prec) 1 - 1)) + (emax - prec)) =\n(emax - prec)%Z.","conclusion":"fexp (Z.pos (digits2_pos (shift_pos (Z.to_pos prec) 1 - 1)) + (emax - prec)) =\n(emax - prec)%Z","hypotheses":"","proofString":"set (p := Z.pos (digits2_pos _)).\nassert (H : p = prec).\nunfold p; rewrite Zpos_digits2_pos, Pos2Z.inj_sub.\nrewrite shift_pos_correct, Z.mul_1_r.\nassert (P2pm1 : (0 <= 2 ^ prec - 1)%Z).\napply Z.lt_le_pred.\napply (Zpower_gt_0 radix2).\nnow apply Zlt_le_weak.\napply Zdigits_unique ;        rewrite Z.pow_pos_fold, Z2Pos.id; [|exact prec_gt_0_]; simpl; split.\nrewrite (Z.abs_eq _ P2pm1).\napply Z.lt_le_pred.\napply (Zpower_lt radix2).\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\nrewrite Z.abs_eq by easy.\napply Z.lt_pred_l.\nchange (Z.pos 1 < Z.pos (shift_pos (Z.to_pos prec) 1))%Z.\nrewrite shift_pos_correct, Z.mul_1_r, Z.pow_pos_fold.\nrewrite Z2Pos.id; [|exact prec_gt_0_].\nnow apply (Zpower_gt_1 radix2).\nrewrite H.\nring_simplify (prec + (emax - prec))%Z.\napply fexp_emax."},{"statement":"(p : Z) : Zdigits radix2 (Z.pos (shift_pos (Z.to_pos prec) 1) - 1) = prec.","conclusion":"Zdigits radix2 (Z.pos (shift_pos (Z.to_pos prec) 1) - 1) = prec","hypotheses":"(p : Z)","proofString":"rewrite shift_pos_correct, Z.mul_1_r.\nassert (P2pm1 : (0 <= 2 ^ prec - 1)%Z).\napply Z.lt_le_pred.\napply (Zpower_gt_0 radix2).\nnow apply Zlt_le_weak.\napply Zdigits_unique ;        rewrite Z.pow_pos_fold, Z2Pos.id; [|exact prec_gt_0_]; simpl; split.\nrewrite (Z.abs_eq _ P2pm1).\napply Z.lt_le_pred.\napply (Zpower_lt radix2).\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\nrewrite Z.abs_eq by easy.\napply Z.lt_pred_l."},{"statement":"(p : Z) : Zdigits radix2 (Z.pow_pos 2 (Z.to_pos prec) - 1) = prec.","conclusion":"Zdigits radix2 (Z.pow_pos 2 (Z.to_pos prec) - 1) = prec","hypotheses":"(p : Z)","proofString":"assert (P2pm1 : (0 <= 2 ^ prec - 1)%Z).\napply Z.lt_le_pred.\napply (Zpower_gt_0 radix2).\nnow apply Zlt_le_weak.\napply Zdigits_unique ;        rewrite Z.pow_pos_fold, Z2Pos.id; [|exact prec_gt_0_]; simpl; split.\nrewrite (Z.abs_eq _ P2pm1).\napply Z.lt_le_pred.\napply (Zpower_lt radix2).\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\nrewrite Z.abs_eq by easy.\napply Z.lt_pred_l."},{"statement":"(p : Z) : (0 <= 2 ^ prec - 1)%Z.","conclusion":"(0 <= 2 ^ prec - 1)%Z","hypotheses":"(p : Z)","proofString":"apply Z.lt_le_pred.\napply (Zpower_gt_0 radix2).\nnow apply Zlt_le_weak."},{"statement":"(p : Z) : (0 < 2 ^ prec)%Z.","conclusion":"(0 < 2 ^ prec)%Z","hypotheses":"(p : Z)","proofString":"apply (Zpower_gt_0 radix2).\nnow apply Zlt_le_weak."},{"statement":"(p : Z) : (0 <= prec)%Z.","conclusion":"(0 <= prec)%Z","hypotheses":"(p : Z)","proofString":"now apply Zlt_le_weak."},{"statement":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z) : Zdigits radix2 (Z.pow_pos 2 (Z.to_pos prec) - 1) = prec.","conclusion":"Zdigits radix2 (Z.pow_pos 2 (Z.to_pos prec) - 1) = prec","hypotheses":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z)","proofString":"apply Zdigits_unique ;        rewrite Z.pow_pos_fold, Z2Pos.id; [|exact prec_gt_0_]; simpl; split.\nrewrite (Z.abs_eq _ P2pm1).\napply Z.lt_le_pred.\napply (Zpower_lt radix2).\nnow apply Zlt_le_weak.\napply Z.lt_pred_l.\nrewrite Z.abs_eq by easy.\napply Z.lt_pred_l."},{"statement":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z) : (2 ^ (prec - 1) <= Z.abs (2 ^ prec - 1))%Z.","conclusion":"(2 ^ (prec - 1) <= Z.abs (2 ^ prec - 1))%Z","hypotheses":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z)","proofString":"rewrite (Z.abs_eq _ P2pm1).\napply Z.lt_le_pred.\napply (Zpower_lt radix2).\nnow apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z) : (2 ^ (prec - 1) <= 2 ^ prec - 1)%Z.","conclusion":"(2 ^ (prec - 1) <= 2 ^ prec - 1)%Z","hypotheses":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z)","proofString":"apply Z.lt_le_pred.\napply (Zpower_lt radix2).\nnow apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z) : (2 ^ (prec - 1) < 2 ^ prec)%Z.","conclusion":"(2 ^ (prec - 1) < 2 ^ prec)%Z","hypotheses":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z)","proofString":"apply (Zpower_lt radix2).\nnow apply Zlt_le_weak.\napply Z.lt_pred_l."},{"statement":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z) : (0 <= prec)%Z.","conclusion":"(0 <= prec)%Z","hypotheses":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z)","proofString":"now apply Zlt_le_weak."},{"statement":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z) : (prec - 1 < prec)%Z.","conclusion":"(prec - 1 < prec)%Z","hypotheses":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z)","proofString":"apply Z.lt_pred_l."},{"statement":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z) : (Z.abs (2 ^ prec - 1) < 2 ^ prec)%Z.","conclusion":"(Z.abs (2 ^ prec - 1) < 2 ^ prec)%Z","hypotheses":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z)","proofString":"rewrite Z.abs_eq by easy.\napply Z.lt_pred_l."},{"statement":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z) : (2 ^ prec - 1 < 2 ^ prec)%Z.","conclusion":"(2 ^ prec - 1 < 2 ^ prec)%Z","hypotheses":"(p : Z) (P2pm1 : (0 <= 2 ^ prec - 1)%Z)","proofString":"apply Z.lt_pred_l."},{"statement":"(p : Z) : (1 < shift_pos (Z.to_pos prec) 1)%positive.","conclusion":"(1 < shift_pos (Z.to_pos prec) 1)%positive","hypotheses":"(p : Z)","proofString":"change (Z.pos 1 < Z.pos (shift_pos (Z.to_pos prec) 1))%Z.\nrewrite shift_pos_correct, Z.mul_1_r, Z.pow_pos_fold.\nrewrite Z2Pos.id; [|exact prec_gt_0_].\nnow apply (Zpower_gt_1 radix2)."},{"statement":"(p : Z) : (1 < Z.pos (shift_pos (Z.to_pos prec) 1))%Z.","conclusion":"(1 < Z.pos (shift_pos (Z.to_pos prec) 1))%Z","hypotheses":"(p : Z)","proofString":"rewrite shift_pos_correct, Z.mul_1_r, Z.pow_pos_fold.\nrewrite Z2Pos.id; [|exact prec_gt_0_].\nnow apply (Zpower_gt_1 radix2)."},{"statement":"(p : Z) : (1 < 2 ^ Z.pos (Z.to_pos prec))%Z.","conclusion":"(1 < 2 ^ Z.pos (Z.to_pos prec))%Z","hypotheses":"(p : Z)","proofString":"rewrite Z2Pos.id; [|exact prec_gt_0_].\nnow apply (Zpower_gt_1 radix2)."},{"statement":"(p : Z) : (1 < 2 ^ prec)%Z.","conclusion":"(1 < 2 ^ prec)%Z","hypotheses":"(p : Z)","proofString":"now apply (Zpower_gt_1 radix2)."},{"statement":"(p : Z) (H : p = prec) : fexp (p + (emax - prec)) = (emax - prec)%Z.","conclusion":"fexp (p + (emax - prec)) = (emax - prec)%Z","hypotheses":"(p : Z) (H : p = prec)","proofString":"rewrite H.\nring_simplify (prec + (emax - prec))%Z.\napply fexp_emax."},{"statement":"(p : Z) (H : p = prec) : fexp (prec + (emax - prec)) = (emax - prec)%Z.","conclusion":"fexp (prec + (emax - prec)) = (emax - prec)%Z","hypotheses":"(p : Z) (H : p = prec)","proofString":"ring_simplify (prec + (emax - prec))%Z.\napply fexp_emax."},{"statement":"(p : Z) (H : p = prec) : fexp emax = (emax - prec)%Z.","conclusion":"fexp emax = (emax - prec)%Z","hypotheses":"(p : Z) (H : p = prec)","proofString":"apply fexp_emax."},{"statement":"(emax - prec <=? emax - prec)%Z = true.","conclusion":"(emax - prec <=? emax - prec)%Z = true","hypotheses":"","proofString":"apply Zle_bool_true, Z.le_refl."},{"statement":"(x : binary_float) : (/ 2 <= Rabs (B2R x) < 1)%R ->\nmatch x with\n| B754_finite _ m e _ =>\n    Bnormfr_mantissa x = N.pos m /\\\n    Z.pos (digits2_pos m) = prec /\\ e = (- prec)%Z\n| _ => False\nend.","conclusion":"(/ 2 <= Rabs (B2R x) < 1)%R ->\nmatch x with\n| B754_finite _ m e _ =>\n    Bnormfr_mantissa x = N.pos m /\\\n    Z.pos (digits2_pos m) = prec /\\ e = (- prec)%Z\n| _ => False\nend","hypotheses":"(x : binary_float)","proofString":"destruct x as [s|s| |s m e B]; [now simpl; rewrite Rabs_R0; lra..| ].\nunfold Bnormfr_mantissa, SFnormfr_mantissa; simpl.\nintro Hx.\ncut (e = -prec /\\ Z.pos (digits2_pos m) = prec)%Z.\nnow intros [-> ->]; rewrite Z.eqb_refl.\nrevert Hx.\nchange (/ 2)%R with (bpow radix2 (0 - 1)); change 1%R with (bpow radix2 0).\nintro H; generalize (mag_unique _ _ _ H); clear H.\nrewrite Float_prop.mag_F2R_Zdigits; [ |now case s].\nreplace (Digits.Zdigits _ _)  with (Digits.Zdigits radix2 (Z.pos m)); [ |now case s].\nclear s.\nrewrite <-Digits.Zpos_digits2_pos.\nintro He; replace e with (e - 0)%Z by ring; rewrite <-He.\ncut (Z.pos (digits2_pos m) = prec)%Z.\nnow intro H; split; [ |exact H]; ring_simplify; rewrite H.\nrevert B; unfold bounded, canonical_mantissa.\nintro H; generalize (andb_prop _ _ H); clear H; intros [H _]; revert H.\nintro H; generalize (Zeq_bool_eq _ _ H); clear H.\nunfold fexp, emin.\nunfold Prec_gt_0 in prec_gt_0_; unfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(s : bool) (m : positive) (e : Z) (B : bounded m e = true) : (/ 2 <= Rabs (B2R (B754_finite s m e B)) < 1)%R ->\nBnormfr_mantissa (B754_finite s m e B) = N.pos m /\\\nZ.pos (digits2_pos m) = prec /\\ e = (- prec)%Z.","conclusion":"(/ 2 <= Rabs (B2R (B754_finite s m e B)) < 1)%R ->\nBnormfr_mantissa (B754_finite s m e B) = N.pos m /\\\nZ.pos (digits2_pos m) = prec /\\ e = (- prec)%Z","hypotheses":"(s : bool) (m : positive) (e : Z) (B : bounded m e = true)","proofString":"unfold Bnormfr_mantissa, SFnormfr_mantissa; simpl.\nintro Hx.\ncut (e = -prec /\\ Z.pos (digits2_pos m) = prec)%Z.\nnow intros [-> ->]; rewrite Z.eqb_refl.\nrevert Hx.\nchange (/ 2)%R with (bpow radix2 (0 - 1)); change 1%R with (bpow radix2 0).\nintro H; generalize (mag_unique _ _ _ H); clear H.\nrewrite Float_prop.mag_F2R_Zdigits; [ |now case s].\nreplace (Digits.Zdigits _ _)  with (Digits.Zdigits radix2 (Z.pos m)); [ |now case s].\nclear s.\nrewrite <-Digits.Zpos_digits2_pos.\nintro He; replace e with (e - 0)%Z by ring; rewrite <-He.\ncut (Z.pos (digits2_pos m) = prec)%Z.\nnow intro H; split; [ |exact H]; ring_simplify; rewrite H.\nrevert B; unfold bounded, canonical_mantissa.\nintro H; generalize (andb_prop _ _ H); clear H; intros [H _]; revert H.\nintro H; generalize (Zeq_bool_eq _ _ H); clear H.\nunfold fexp, emin.\nunfold Prec_gt_0 in prec_gt_0_; unfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(s : bool) (m : positive) (e : Z) (B : bounded m e = true) : (Zdigits radix2 (cond_Zopp s (Z.pos m)) + e)%Z = 0%Z ->\ne = (- prec)%Z /\\ Z.pos (digits2_pos m) = prec.","conclusion":"(Zdigits radix2 (cond_Zopp s (Z.pos m)) + e)%Z = 0%Z ->\ne = (- prec)%Z /\\ Z.pos (digits2_pos m) = prec","hypotheses":"(s : bool) (m : positive) (e : Z) (B : bounded m e = true)","proofString":"replace (Digits.Zdigits _ _)  with (Digits.Zdigits radix2 (Z.pos m)); [ |now case s].\nclear s.\nrewrite <-Digits.Zpos_digits2_pos.\nintro He; replace e with (e - 0)%Z by ring; rewrite <-He.\ncut (Z.pos (digits2_pos m) = prec)%Z.\nnow intro H; split; [ |exact H]; ring_simplify; rewrite H.\nrevert B; unfold bounded, canonical_mantissa.\nintro H; generalize (andb_prop _ _ H); clear H; intros [H _]; revert H.\nintro H; generalize (Zeq_bool_eq _ _ H); clear H.\nunfold fexp, emin.\nunfold Prec_gt_0 in prec_gt_0_; unfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(s : bool) (m : positive) (e : Z) (B : bounded m e = true) : (Zdigits radix2 (Z.pos m) + e)%Z = 0%Z ->\ne = (- prec)%Z /\\ Z.pos (digits2_pos m) = prec.","conclusion":"(Zdigits radix2 (Z.pos m) + e)%Z = 0%Z ->\ne = (- prec)%Z /\\ Z.pos (digits2_pos m) = prec","hypotheses":"(s : bool) (m : positive) (e : Z) (B : bounded m e = true)","proofString":"clear s.\nrewrite <-Digits.Zpos_digits2_pos.\nintro He; replace e with (e - 0)%Z by ring; rewrite <-He.\ncut (Z.pos (digits2_pos m) = prec)%Z.\nnow intro H; split; [ |exact H]; ring_simplify; rewrite H.\nrevert B; unfold bounded, canonical_mantissa.\nintro H; generalize (andb_prop _ _ H); clear H; intros [H _]; revert H.\nintro H; generalize (Zeq_bool_eq _ _ H); clear H.\nunfold fexp, emin.\nunfold Prec_gt_0 in prec_gt_0_; unfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(m : positive) (e : Z) (B : bounded m e = true) : (Zdigits radix2 (Z.pos m) + e)%Z = 0%Z ->\ne = (- prec)%Z /\\ Z.pos (digits2_pos m) = prec.","conclusion":"(Zdigits radix2 (Z.pos m) + e)%Z = 0%Z ->\ne = (- prec)%Z /\\ Z.pos (digits2_pos m) = prec","hypotheses":"(m : positive) (e : Z) (B : bounded m e = true)","proofString":"rewrite <-Digits.Zpos_digits2_pos.\nintro He; replace e with (e - 0)%Z by ring; rewrite <-He.\ncut (Z.pos (digits2_pos m) = prec)%Z.\nnow intro H; split; [ |exact H]; ring_simplify; rewrite H.\nrevert B; unfold bounded, canonical_mantissa.\nintro H; generalize (andb_prop _ _ H); clear H; intros [H _]; revert H.\nintro H; generalize (Zeq_bool_eq _ _ H); clear H.\nunfold fexp, emin.\nunfold Prec_gt_0 in prec_gt_0_; unfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(m : positive) (e : Z) (B : bounded m e = true) : (Z.pos (digits2_pos m) + e)%Z = 0%Z ->\ne = (- prec)%Z /\\ Z.pos (digits2_pos m) = prec.","conclusion":"(Z.pos (digits2_pos m) + e)%Z = 0%Z ->\ne = (- prec)%Z /\\ Z.pos (digits2_pos m) = prec","hypotheses":"(m : positive) (e : Z) (B : bounded m e = true)","proofString":"intro He; replace e with (e - 0)%Z by ring; rewrite <-He.\ncut (Z.pos (digits2_pos m) = prec)%Z.\nnow intro H; split; [ |exact H]; ring_simplify; rewrite H.\nrevert B; unfold bounded, canonical_mantissa.\nintro H; generalize (andb_prop _ _ H); clear H; intros [H _]; revert H.\nintro H; generalize (Zeq_bool_eq _ _ H); clear H.\nunfold fexp, emin.\nunfold Prec_gt_0 in prec_gt_0_; unfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(m : positive) (e : Z) (B : bounded m e = true) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z) : (e - (Z.pos (digits2_pos m) + e))%Z = (- prec)%Z /\\\nZ.pos (digits2_pos m) = prec.","conclusion":"(e - (Z.pos (digits2_pos m) + e))%Z = (- prec)%Z /\\\nZ.pos (digits2_pos m) = prec","hypotheses":"(m : positive) (e : Z) (B : bounded m e = true) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z)","proofString":"cut (Z.pos (digits2_pos m) = prec)%Z.\nnow intro H; split; [ |exact H]; ring_simplify; rewrite H.\nrevert B; unfold bounded, canonical_mantissa.\nintro H; generalize (andb_prop _ _ H); clear H; intros [H _]; revert H.\nintro H; generalize (Zeq_bool_eq _ _ H); clear H.\nunfold fexp, emin.\nunfold Prec_gt_0 in prec_gt_0_; unfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(m : positive) (e : Z) (B : bounded m e = true) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z) : Z.pos (digits2_pos m) = prec ->\n(e - (Z.pos (digits2_pos m) + e))%Z = (- prec)%Z /\\\nZ.pos (digits2_pos m) = prec.","conclusion":"Z.pos (digits2_pos m) = prec ->\n(e - (Z.pos (digits2_pos m) + e))%Z = (- prec)%Z /\\\nZ.pos (digits2_pos m) = prec","hypotheses":"(m : positive) (e : Z) (B : bounded m e = true) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z)","proofString":"now intro H; split; [ |exact H]; ring_simplify; rewrite H."},{"statement":"(m : positive) (e : Z) (B : bounded m e = true) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z) : Z.pos (digits2_pos m) = prec.","conclusion":"Z.pos (digits2_pos m) = prec","hypotheses":"(m : positive) (e : Z) (B : bounded m e = true) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z)","proofString":"revert B; unfold bounded, canonical_mantissa.\nintro H; generalize (andb_prop _ _ H); clear H; intros [H _]; revert H.\nintro H; generalize (Zeq_bool_eq _ _ H); clear H.\nunfold fexp, emin.\nunfold Prec_gt_0 in prec_gt_0_; unfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(m : positive) (e : Z) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z) : (Zeq_bool (fexp (Z.pos (digits2_pos m) + e)) e && (e <=? emax - prec)%Z)%bool =\ntrue -> Z.pos (digits2_pos m) = prec.","conclusion":"(Zeq_bool (fexp (Z.pos (digits2_pos m) + e)) e && (e <=? emax - prec)%Z)%bool =\ntrue -> Z.pos (digits2_pos m) = prec","hypotheses":"(m : positive) (e : Z) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z)","proofString":"intro H; generalize (andb_prop _ _ H); clear H; intros [H _]; revert H.\nintro H; generalize (Zeq_bool_eq _ _ H); clear H.\nunfold fexp, emin.\nunfold Prec_gt_0 in prec_gt_0_; unfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(m : positive) (e : Z) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z) : Zeq_bool (fexp (Z.pos (digits2_pos m) + e)) e = true ->\nZ.pos (digits2_pos m) = prec.","conclusion":"Zeq_bool (fexp (Z.pos (digits2_pos m) + e)) e = true ->\nZ.pos (digits2_pos m) = prec","hypotheses":"(m : positive) (e : Z) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z)","proofString":"intro H; generalize (Zeq_bool_eq _ _ H); clear H.\nunfold fexp, emin.\nunfold Prec_gt_0 in prec_gt_0_; unfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(m : positive) (e : Z) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z) : fexp (Z.pos (digits2_pos m) + e) = e -> Z.pos (digits2_pos m) = prec.","conclusion":"fexp (Z.pos (digits2_pos m) + e) = e -> Z.pos (digits2_pos m) = prec","hypotheses":"(m : positive) (e : Z) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z)","proofString":"unfold fexp, emin.\nunfold Prec_gt_0 in prec_gt_0_; unfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(m : positive) (e : Z) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z) : Z.max (Z.pos (digits2_pos m) + e - prec) (3 - emax - prec) = e ->\nZ.pos (digits2_pos m) = prec.","conclusion":"Z.max (Z.pos (digits2_pos m) + e - prec) (3 - emax - prec) = e ->\nZ.pos (digits2_pos m) = prec","hypotheses":"(m : positive) (e : Z) (He : (Z.pos (digits2_pos m) + e)%Z = 0%Z)","proofString":"unfold Prec_gt_0 in prec_gt_0_; unfold Prec_lt_emax in prec_lt_emax_.\nlia."},{"statement":"(mode : Binary.mode) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (e : Z) : is_nan (Bldexp mode (B754_finite sx mx ex Bx) e) =\nis_nan (B754_finite sx mx ex Bx).","conclusion":"is_nan (Bldexp mode (B754_finite sx mx ex Bx) e) =\nis_nan (B754_finite sx mx ex Bx)","hypotheses":"(mode : Binary.mode) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (e : Z)","proofString":"unfold Bldexp.\nrewrite is_nan_SF2B.\napply is_nan_binary_round."},{"statement":"(mode : Binary.mode) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (e : Z) : is_nan\n  (SF2B (binary_round mode sx mx (ex + e))\n     (proj1 (binary_round_correct mode sx mx (ex + e)))) =\nis_nan (B754_finite sx mx ex Bx).","conclusion":"is_nan\n  (SF2B (binary_round mode sx mx (ex + e))\n     (proj1 (binary_round_correct mode sx mx (ex + e)))) =\nis_nan (B754_finite sx mx ex Bx)","hypotheses":"(mode : Binary.mode) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (e : Z)","proofString":"rewrite is_nan_SF2B.\napply is_nan_binary_round."},{"statement":"(mode : Binary.mode) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (e : Z) : is_nan_SF (binary_round mode sx mx (ex + e)) =\nis_nan (B754_finite sx mx ex Bx).","conclusion":"is_nan_SF (binary_round mode sx mx (ex + e)) =\nis_nan (B754_finite sx mx ex Bx)","hypotheses":"(mode : Binary.mode) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (e : Z)","proofString":"apply is_nan_binary_round."},{"statement":"(m : mode) (f : binary_float) (e : Z) : if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R f * bpow radix2 e)))\n   (bpow radix2 emax)\nthen\n B2R (Bldexp m f e) =\n round radix2 fexp (round_mode m) (B2R f * bpow radix2 e) /\\\n is_finite (Bldexp m f e) = is_finite f /\\ Bsign (Bldexp m f e) = Bsign f\nelse B2SF (Bldexp m f e) = binary_overflow m (Bsign f).","conclusion":"if\n Rlt_bool (Rabs (round radix2 fexp (round_mode m) (B2R f * bpow radix2 e)))\n   (bpow radix2 emax)\nthen\n B2R (Bldexp m f e) =\n round radix2 fexp (round_mode m) (B2R f * bpow radix2 e) /\\\n is_finite (Bldexp m f e) = is_finite f /\\ Bsign (Bldexp m f e) = Bsign f\nelse B2SF (Bldexp m f e) = binary_overflow m (Bsign f)","hypotheses":"(m : mode) (f : binary_float) (e : Z)","proofString":"case f.\nintro s; simpl; rewrite Rmult_0_l, round_0; [|apply valid_rnd_round_mode].\nnow rewrite Rabs_R0, Rlt_bool_true; [|now apply bpow_gt_0].\nintro s; simpl; rewrite Rmult_0_l, round_0; [|apply valid_rnd_round_mode].\nnow rewrite Rabs_R0, Rlt_bool_true; [|now apply bpow_gt_0].\nsimpl; rewrite Rmult_0_l, round_0; [|apply valid_rnd_round_mode].\nnow rewrite Rabs_R0, Rlt_bool_true; [|now apply bpow_gt_0].\nintros s mf ef Hmef.\ncase (Rlt_bool_spec _ _); intro Hover.\nunfold Bldexp; rewrite B2R_SF2B, is_finite_SF2B, Bsign_SF2B.\nsimpl; unfold F2R; simpl; rewrite Rmult_assoc, <-bpow_plus.\ndestruct (binary_round_correct m s mf (ef + e)) as (Hf, Hr).\nfold emin in Hr; simpl in Hr; rewrite Rlt_bool_true in Hr.\nnow destruct Hr as (Hr, (Hfr, Hsr)); rewrite Hr, Hfr, Hsr.\nnow revert Hover; unfold B2R, F2R; simpl; rewrite Rmult_assoc, bpow_plus.\nunfold Bldexp; rewrite B2SF_SF2B; simpl.\ndestruct (binary_round_correct m s mf (ef + e)) as (Hf, Hr).\nfold emin in Hr; simpl in Hr; rewrite Rlt_bool_false in Hr; [exact Hr|].\nnow revert Hover; unfold B2R, F2R; simpl; rewrite Rmult_assoc, bpow_plus."},{"statement":"(m : mode) (f : binary_float) (e : Z) : forall s : bool,\nif\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m) (B2R (B754_zero s) * bpow radix2 e)))\n   (bpow radix2 emax)\nthen\n B2R (Bldexp m (B754_zero s) e) =\n round radix2 fexp (round_mode m) (B2R (B754_zero s) * bpow radix2 e) /\\\n is_finite (Bldexp m (B754_zero s) e) = is_finite (B754_zero s) /\\\n Bsign (Bldexp m (B754_zero s) e) = Bsign (B754_zero s)\nelse\n B2SF (Bldexp m (B754_zero s) e) = binary_overflow m (Bsign (B754_zero s)).","conclusion":"forall s : bool,\nif\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m) (B2R (B754_zero s) * bpow radix2 e)))\n   (bpow radix2 emax)\nthen\n B2R (Bldexp m (B754_zero s) e) =\n round radix2 fexp (round_mode m) (B2R (B754_zero s) * bpow radix2 e) /\\\n is_finite (Bldexp m (B754_zero s) e) = is_finite (B754_zero s) /\\\n Bsign (Bldexp m (B754_zero s) e) = Bsign (B754_zero s)\nelse\n B2SF (Bldexp m (B754_zero s) e) = binary_overflow m (Bsign (B754_zero s))","hypotheses":"(m : mode) (f : binary_float) (e : Z)","proofString":"intro s; simpl; rewrite Rmult_0_l, round_0; [|apply valid_rnd_round_mode].\nnow rewrite Rabs_R0, Rlt_bool_true; [|now apply bpow_gt_0]."},{"statement":"(m : mode) (f : binary_float) (e : Z) (s : bool) : if Rlt_bool (Rabs 0) (bpow radix2 emax)\nthen 0%R = 0%R /\\ true = true /\\ s = s\nelse S754_zero s = binary_overflow m s.","conclusion":"if Rlt_bool (Rabs 0) (bpow radix2 emax)\nthen 0%R = 0%R /\\ true = true /\\ s = s\nelse S754_zero s = binary_overflow m s","hypotheses":"(m : mode) (f : binary_float) (e : Z) (s : bool)","proofString":"now rewrite Rabs_R0, Rlt_bool_true; [|now apply bpow_gt_0]."},{"statement":"(m : mode) (f : binary_float) (e : Z) : forall s : bool,\nif\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_infinity s) * bpow radix2 e))) \n   (bpow radix2 emax)\nthen\n B2R (Bldexp m (B754_infinity s) e) =\n round radix2 fexp (round_mode m) (B2R (B754_infinity s) * bpow radix2 e) /\\\n is_finite (Bldexp m (B754_infinity s) e) = is_finite (B754_infinity s) /\\\n Bsign (Bldexp m (B754_infinity s) e) = Bsign (B754_infinity s)\nelse\n B2SF (Bldexp m (B754_infinity s) e) =\n binary_overflow m (Bsign (B754_infinity s)).","conclusion":"forall s : bool,\nif\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_infinity s) * bpow radix2 e))) \n   (bpow radix2 emax)\nthen\n B2R (Bldexp m (B754_infinity s) e) =\n round radix2 fexp (round_mode m) (B2R (B754_infinity s) * bpow radix2 e) /\\\n is_finite (Bldexp m (B754_infinity s) e) = is_finite (B754_infinity s) /\\\n Bsign (Bldexp m (B754_infinity s) e) = Bsign (B754_infinity s)\nelse\n B2SF (Bldexp m (B754_infinity s) e) =\n binary_overflow m (Bsign (B754_infinity s))","hypotheses":"(m : mode) (f : binary_float) (e : Z)","proofString":"intro s; simpl; rewrite Rmult_0_l, round_0; [|apply valid_rnd_round_mode].\nnow rewrite Rabs_R0, Rlt_bool_true; [|now apply bpow_gt_0]."},{"statement":"(m : mode) (f : binary_float) (e : Z) (s : bool) : if Rlt_bool (Rabs 0) (bpow radix2 emax)\nthen 0%R = 0%R /\\ false = false /\\ s = s\nelse S754_infinity s = binary_overflow m s.","conclusion":"if Rlt_bool (Rabs 0) (bpow radix2 emax)\nthen 0%R = 0%R /\\ false = false /\\ s = s\nelse S754_infinity s = binary_overflow m s","hypotheses":"(m : mode) (f : binary_float) (e : Z) (s : bool)","proofString":"now rewrite Rabs_R0, Rlt_bool_true; [|now apply bpow_gt_0]."},{"statement":"(m : mode) (f : binary_float) (e : Z) : if\n Rlt_bool\n   (Rabs (round radix2 fexp (round_mode m) (B2R B754_nan * bpow radix2 e)))\n   (bpow radix2 emax)\nthen\n B2R (Bldexp m B754_nan e) =\n round radix2 fexp (round_mode m) (B2R B754_nan * bpow radix2 e) /\\\n is_finite (Bldexp m B754_nan e) = is_finite B754_nan /\\\n Bsign (Bldexp m B754_nan e) = Bsign B754_nan\nelse B2SF (Bldexp m B754_nan e) = binary_overflow m (Bsign B754_nan).","conclusion":"if\n Rlt_bool\n   (Rabs (round radix2 fexp (round_mode m) (B2R B754_nan * bpow radix2 e)))\n   (bpow radix2 emax)\nthen\n B2R (Bldexp m B754_nan e) =\n round radix2 fexp (round_mode m) (B2R B754_nan * bpow radix2 e) /\\\n is_finite (Bldexp m B754_nan e) = is_finite B754_nan /\\\n Bsign (Bldexp m B754_nan e) = Bsign B754_nan\nelse B2SF (Bldexp m B754_nan e) = binary_overflow m (Bsign B754_nan)","hypotheses":"(m : mode) (f : binary_float) (e : Z)","proofString":"simpl; rewrite Rmult_0_l, round_0; [|apply valid_rnd_round_mode].\nnow rewrite Rabs_R0, Rlt_bool_true; [|now apply bpow_gt_0]."},{"statement":"(m : mode) (f : binary_float) (e : Z) : if Rlt_bool (Rabs 0) (bpow radix2 emax)\nthen 0%R = 0%R /\\ false = false /\\ false = false\nelse S754_nan = binary_overflow m false.","conclusion":"if Rlt_bool (Rabs 0) (bpow radix2 emax)\nthen 0%R = 0%R /\\ false = false /\\ false = false\nelse S754_nan = binary_overflow m false","hypotheses":"(m : mode) (f : binary_float) (e : Z)","proofString":"now rewrite Rabs_R0, Rlt_bool_true; [|now apply bpow_gt_0]."},{"statement":"(m : mode) (f : binary_float) (e : Z) : forall (s : bool) (m0 : positive) (e0 : Z) (e1 : bounded m0 e0 = true),\nif\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_finite s m0 e0 e1) * bpow radix2 e))) \n   (bpow radix2 emax)\nthen\n B2R (Bldexp m (B754_finite s m0 e0 e1) e) =\n round radix2 fexp (round_mode m)\n   (B2R (B754_finite s m0 e0 e1) * bpow radix2 e) /\\\n is_finite (Bldexp m (B754_finite s m0 e0 e1) e) =\n is_finite (B754_finite s m0 e0 e1) /\\\n Bsign (Bldexp m (B754_finite s m0 e0 e1) e) = Bsign (B754_finite s m0 e0 e1)\nelse\n B2SF (Bldexp m (B754_finite s m0 e0 e1) e) =\n binary_overflow m (Bsign (B754_finite s m0 e0 e1)).","conclusion":"forall (s : bool) (m0 : positive) (e0 : Z) (e1 : bounded m0 e0 = true),\nif\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_finite s m0 e0 e1) * bpow radix2 e))) \n   (bpow radix2 emax)\nthen\n B2R (Bldexp m (B754_finite s m0 e0 e1) e) =\n round radix2 fexp (round_mode m)\n   (B2R (B754_finite s m0 e0 e1) * bpow radix2 e) /\\\n is_finite (Bldexp m (B754_finite s m0 e0 e1) e) =\n is_finite (B754_finite s m0 e0 e1) /\\\n Bsign (Bldexp m (B754_finite s m0 e0 e1) e) = Bsign (B754_finite s m0 e0 e1)\nelse\n B2SF (Bldexp m (B754_finite s m0 e0 e1) e) =\n binary_overflow m (Bsign (B754_finite s m0 e0 e1))","hypotheses":"(m : mode) (f : binary_float) (e : Z)","proofString":"intros s mf ef Hmef.\ncase (Rlt_bool_spec _ _); intro Hover.\nunfold Bldexp; rewrite B2R_SF2B, is_finite_SF2B, Bsign_SF2B.\nsimpl; unfold F2R; simpl; rewrite Rmult_assoc, <-bpow_plus.\ndestruct (binary_round_correct m s mf (ef + e)) as (Hf, Hr).\nfold emin in Hr; simpl in Hr; rewrite Rlt_bool_true in Hr.\nnow destruct Hr as (Hr, (Hfr, Hsr)); rewrite Hr, Hfr, Hsr.\nnow revert Hover; unfold B2R, F2R; simpl; rewrite Rmult_assoc, bpow_plus.\nunfold Bldexp; rewrite B2SF_SF2B; simpl.\ndestruct (binary_round_correct m s mf (ef + e)) as (Hf, Hr).\nfold emin in Hr; simpl in Hr; rewrite Rlt_bool_false in Hr; [exact Hr|].\nnow revert Hover; unfold B2R, F2R; simpl; rewrite Rmult_assoc, bpow_plus."},{"statement":"(m : mode) (f : binary_float) (e : Z) (s : bool) (mf : positive) (ef : Z) (Hmef : bounded mf ef = true) : if\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_finite s mf ef Hmef) * bpow radix2 e)))\n   (bpow radix2 emax)\nthen\n B2R (Bldexp m (B754_finite s mf ef Hmef) e) =\n round radix2 fexp (round_mode m)\n   (B2R (B754_finite s mf ef Hmef) * bpow radix2 e) /\\\n is_finite (Bldexp m (B754_finite s mf ef Hmef) e) =\n is_finite (B754_finite s mf ef Hmef) /\\\n Bsign (Bldexp m (B754_finite s mf ef Hmef) e) =\n Bsign (B754_finite s mf ef Hmef)\nelse\n B2SF (Bldexp m (B754_finite s mf ef Hmef) e) =\n binary_overflow m (Bsign (B754_finite s mf ef Hmef)).","conclusion":"if\n Rlt_bool\n   (Rabs\n      (round radix2 fexp (round_mode m)\n         (B2R (B754_finite s mf ef Hmef) * bpow radix2 e)))\n   (bpow radix2 emax)\nthen\n B2R (Bldexp m (B754_finite s mf ef Hmef) e) =\n round radix2 fexp (round_mode m)\n   (B2R (B754_finite s mf ef Hmef) * bpow radix2 e) /\\\n is_finite (Bldexp m (B754_finite s mf ef Hmef) e) =\n is_finite (B754_finite s mf ef Hmef) /\\\n Bsign (Bldexp m (B754_finite s mf ef Hmef) e) =\n Bsign (B754_finite s mf ef Hmef)\nelse\n B2SF (Bldexp m (B754_finite s mf ef Hmef) e) =\n binary_overflow m (Bsign (B754_finite s mf ef Hmef))","hypotheses":"(m : mode) (f : binary_float) (e : Z) (s : bool) (mf : positive) (ef : Z) (Hmef : bounded mf ef = true)","proofString":"case (Rlt_bool_spec _ _); intro Hover.\nunfold Bldexp; rewrite B2R_SF2B, is_finite_SF2B, Bsign_SF2B.\nsimpl; unfold F2R; simpl; rewrite Rmult_assoc, <-bpow_plus.\ndestruct (binary_round_correct m s mf (ef + e)) as (Hf, Hr).\nfold emin in Hr; simpl in Hr; rewrite Rlt_bool_true in Hr.\nnow destruct Hr as (Hr, (Hfr, Hsr)); rewrite Hr, Hfr, Hsr.\nnow revert Hover; unfold B2R, F2R; simpl; rewrite Rmult_assoc, bpow_plus.\nunfold Bldexp; rewrite B2SF_SF2B; simpl.\ndestruct (binary_round_correct m s mf (ef + e)) as (Hf, Hr).\nfold emin in Hr; simpl in Hr; rewrite Rlt_bool_false in Hr; [exact Hr|].\nnow revert Hover; unfold B2R, F2R; simpl; rewrite Rmult_assoc, bpow_plus."},{"statement":"(m : mode) (f : binary_float) (e : Z) (s : bool) (mf : positive) (ef : Z) (Hmef : bounded mf ef = true) (Hover : (Rabs\n   (round radix2 fexp (round_mode m)\n      (B2R (B754_finite s mf ef Hmef) * bpow radix2 e)) < \n bpow radix2 emax)%R) : B2R (Bldexp m (B754_finite s mf ef Hmef) e) =\nround radix2 fexp (round_mode m)\n  (B2R (B754_finite s mf ef Hmef) * bpow radix2 e) /\\\nis_finite (Bldexp m (B754_finite s mf ef Hmef) e) =\nis_finite (B754_finite s mf ef Hmef) /\\\nBsign (Bldexp m (B754_finite s mf ef Hmef) e) =\nBsign (B754_finite s mf ef Hmef).","conclusion":"B2R (Bldexp m (B754_finite s mf ef Hmef) e) =\nround radix2 fexp (round_mode m)\n  (B2R (B754_finite s mf ef Hmef) * bpow radix2 e) /\\\nis_finite (Bldexp m (B754_finite s mf ef Hmef) e) =\nis_finite (B754_finite s mf ef Hmef) /\\\nBsign (Bldexp m (B754_finite s mf ef Hmef) e) =\nBsign (B754_finite s mf ef Hmef)","hypotheses":"(m : mode) (f : binary_float) (e : Z) (s : bool) (mf : positive) (ef : Z) (Hmef : bounded mf ef = true) (Hover : (Rabs\n   (round radix2 fexp (round_mode m)\n      (B2R (B754_finite s mf ef Hmef) * bpow radix2 e)) < \n bpow radix2 emax)%R)","proofString":"unfold Bldexp; rewrite B2R_SF2B, is_finite_SF2B, Bsign_SF2B.\nsimpl; unfold F2R; simpl; rewrite Rmult_assoc, <-bpow_plus.\ndestruct (binary_round_correct m s mf (ef + e)) as (Hf, Hr).\nfold emin in Hr; simpl in Hr; rewrite Rlt_bool_true in Hr.\nnow destruct Hr as (Hr, (Hfr, Hsr)); rewrite Hr, Hfr, Hsr.\nnow revert Hover; unfold B2R, F2R; simpl; rewrite Rmult_assoc, bpow_plus."},{"statement":"(m : mode) (f : binary_float) (e : Z) (s : bool) (mf : positive) (ef : Z) (Hmef : bounded mf ef = true) (Hover : (Rabs\n   (round radix2 fexp (round_mode m)\n      (B2R (B754_finite s mf ef Hmef) * bpow radix2 e)) < \n bpow radix2 emax)%R) : SF2R radix2 (binary_round m s mf (ef + e)) =\nround radix2 fexp (round_mode m)\n  (B2R (B754_finite s mf ef Hmef) * bpow radix2 e) /\\\nis_finite_SF (binary_round m s mf (ef + e)) =\nis_finite (B754_finite s mf ef Hmef) /\\\nsign_SF (binary_round m s mf (ef + e)) = Bsign (B754_finite s mf ef Hmef).","conclusion":"SF2R radix2 (binary_round m s mf (ef + e)) =\nround radix2 fexp (round_mode m)\n  (B2R (B754_finite s mf ef Hmef) * bpow radix2 e) /\\\nis_finite_SF (binary_round m s mf (ef + e)) =\nis_finite (B754_finite s mf ef Hmef) /\\\nsign_SF (binary_round m s mf (ef + e)) = Bsign (B754_finite s mf ef Hmef)","hypotheses":"(m : mode) (f : binary_float) (e : Z) (s : bool) (mf : positive) (ef : Z) (Hmef : bounded mf ef = true) (Hover : (Rabs\n   (round radix2 fexp (round_mode m)\n      (B2R (B754_finite s mf ef Hmef) * bpow radix2 e)) < \n bpow radix2 emax)%R)","proofString":"simpl; unfold F2R; simpl; rewrite Rmult_assoc, <-bpow_plus.\ndestruct (binary_round_correct m s mf (ef + e)) as (Hf, Hr).\nfold emin in Hr; simpl in Hr; rewrite Rlt_bool_true in Hr.\nnow destruct Hr as (Hr, (Hfr, Hsr)); rewrite Hr, Hfr, Hsr.\nnow revert Hover; unfold B2R, F2R; simpl; rewrite Rmult_assoc, bpow_plus."},{"statement":"(m : mode) (f : binary_float) (e : Z) (s : bool) (mf : positive) (ef : Z) (Hmef : bounded mf ef = true) (Hover : (Rabs\n   (round radix2 fexp (round_mode m)\n      (B2R (B754_finite s mf ef Hmef) * bpow radix2 e)) < \n bpow radix2 emax)%R) : SF2R radix2 (binary_round m s mf (ef + e)) =\nround radix2 fexp (round_mode m)\n  (IZR (cond_Zopp s (Z.pos mf)) * bpow radix2 (ef + e)) /\\\nis_finite_SF (binary_round m s mf (ef + e)) = true /\\\nsign_SF (binary_round m s mf (ef + e)) = s.","conclusion":"SF2R radix2 (binary_round m s mf (ef + e)) =\nround radix2 fexp (round_mode m)\n  (IZR (cond_Zopp s (Z.pos mf)) * bpow radix2 (ef + e)) /\\\nis_finite_SF (binary_round m s mf (ef + e)) = true /\\\nsign_SF (binary_round m s mf (ef + e)) = s","hypotheses":"(m : mode) (f : binary_float) (e : Z) (s : bool) (mf : positive) (ef : Z) (Hmef : bounded mf ef = true) (Hover : (Rabs\n   (round radix2 fexp (round_mode m)\n      (B2R (B754_finite s mf ef Hmef) * bpow radix2 e)) < \n bpow radix2 emax)%R)","proofString":"destruct (binary_round_correct m s mf (ef + e)) as (Hf, Hr).\nfold emin in Hr; simpl in Hr; rewrite Rlt_bool_true in Hr.\nnow destruct Hr as (Hr, (Hfr, Hsr)); rewrite Hr, Hfr, Hsr.\nnow revert Hover; unfold B2R, F2R; simpl; rewrite Rmult_assoc, bpow_plus."},{"statement":"(m : mode) (f : binary_float) (e : Z) (s : bool) (mf : positive) (ef : Z) (Hmef : bounded mf ef = true) (Hover : (bpow radix2 emax <=\n Rabs\n   (round radix2 fexp (round_mode m)\n      (B2R (B754_finite s mf ef Hmef) * bpow radix2 e)))%R) : B2SF (Bldexp m (B754_finite s mf ef Hmef) e) =\nbinary_overflow m (Bsign (B754_finite s mf ef Hmef)).","conclusion":"B2SF (Bldexp m (B754_finite s mf ef Hmef) e) =\nbinary_overflow m (Bsign (B754_finite s mf ef Hmef))","hypotheses":"(m : mode) (f : binary_float) (e : Z) (s : bool) (mf : positive) (ef : Z) (Hmef : bounded mf ef = true) (Hover : (bpow radix2 emax <=\n Rabs\n   (round radix2 fexp (round_mode m)\n      (B2R (B754_finite s mf ef Hmef) * bpow radix2 e)))%R)","proofString":"unfold Bldexp; rewrite B2SF_SF2B; simpl.\ndestruct (binary_round_correct m s mf (ef + e)) as (Hf, Hr).\nfold emin in Hr; simpl in Hr; rewrite Rlt_bool_false in Hr; [exact Hr|].\nnow revert Hover; unfold B2R, F2R; simpl; rewrite Rmult_assoc, bpow_plus."},{"statement":"(m : mode) (f : binary_float) (e : Z) (s : bool) (mf : positive) (ef : Z) (Hmef : bounded mf ef = true) (Hover : (bpow radix2 emax <=\n Rabs\n   (round radix2 fexp (round_mode m)\n      (B2R (B754_finite s mf ef Hmef) * bpow radix2 e)))%R) : binary_round m s mf (ef + e) = binary_overflow m s.","conclusion":"binary_round m s mf (ef + e) = binary_overflow m s","hypotheses":"(m : mode) (f : binary_float) (e : Z) (s : bool) (mf : positive) (ef : Z) (Hmef : bounded mf ef = true) (Hover : (bpow radix2 emax <=\n Rabs\n   (round radix2 fexp (round_mode m)\n      (B2R (B754_finite s mf ef Hmef) * bpow radix2 e)))%R)","proofString":"destruct (binary_round_correct m s mf (ef + e)) as (Hf, Hr).\nfold emin in Hr; simpl in Hr; rewrite Rlt_bool_false in Hr; [exact Hr|].\nnow revert Hover; unfold B2R, F2R; simpl; rewrite Rmult_assoc, bpow_plus."},{"statement":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) : Bldexp mode_NE (Bopp (B754_finite s m e' B)) e =\nBopp (Bldexp mode_NE (B754_finite s m e' B) e).","conclusion":"Bldexp mode_NE (Bopp (B754_finite s m e' B)) e =\nBopp (Bldexp mode_NE (B754_finite s m e' B) e)","hypotheses":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z)","proofString":"apply B2SF_inj.\nreplace (B2SF (Bopp _)) with (SFopp (B2SF (Bldexp mode_NE (B754_finite s m e' B) e))).\nunfold Bldexp, Bopp; rewrite !B2SF_SF2B.\nunfold binary_round.\nset (shl := shl_align_fexp _ _); case shl; intros mz ez.\nunfold binary_round_aux.\nset (shr := shr_fexp _ _ _); case shr; intros mrs e''.\nunfold choice_mode.\nset (shr' := shr_fexp _ _ _); case shr'; intros mrs' e'''.\nunfold binary_fit_aux.\nnow case (shr_m mrs') as [|p|p]; [|case Z.leb|].\nnow case Bldexp as [s'|s'| |s' m' e'' B']."},{"statement":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) : B2SF (Bldexp mode_NE (Bopp (B754_finite s m e' B)) e) =\nB2SF (Bopp (Bldexp mode_NE (B754_finite s m e' B) e)).","conclusion":"B2SF (Bldexp mode_NE (Bopp (B754_finite s m e' B)) e) =\nB2SF (Bopp (Bldexp mode_NE (B754_finite s m e' B) e))","hypotheses":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z)","proofString":"replace (B2SF (Bopp _)) with (SFopp (B2SF (Bldexp mode_NE (B754_finite s m e' B) e))).\nunfold Bldexp, Bopp; rewrite !B2SF_SF2B.\nunfold binary_round.\nset (shl := shl_align_fexp _ _); case shl; intros mz ez.\nunfold binary_round_aux.\nset (shr := shr_fexp _ _ _); case shr; intros mrs e''.\nunfold choice_mode.\nset (shr' := shr_fexp _ _ _); case shr'; intros mrs' e'''.\nunfold binary_fit_aux.\nnow case (shr_m mrs') as [|p|p]; [|case Z.leb|].\nnow case Bldexp as [s'|s'| |s' m' e'' B']."},{"statement":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) : B2SF (Bldexp mode_NE (Bopp (B754_finite s m e' B)) e) =\nSFopp (B2SF (Bldexp mode_NE (B754_finite s m e' B) e)).","conclusion":"B2SF (Bldexp mode_NE (Bopp (B754_finite s m e' B)) e) =\nSFopp (B2SF (Bldexp mode_NE (B754_finite s m e' B) e))","hypotheses":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z)","proofString":"unfold Bldexp, Bopp; rewrite !B2SF_SF2B.\nunfold binary_round.\nset (shl := shl_align_fexp _ _); case shl; intros mz ez.\nunfold binary_round_aux.\nset (shr := shr_fexp _ _ _); case shr; intros mrs e''.\nunfold choice_mode.\nset (shr' := shr_fexp _ _ _); case shr'; intros mrs' e'''.\nunfold binary_fit_aux.\nnow case (shr_m mrs') as [|p|p]; [|case Z.leb|]."},{"statement":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) : binary_round mode_NE (negb s) m (e' + e) =\nSFopp (binary_round mode_NE s m (e' + e)).","conclusion":"binary_round mode_NE (negb s) m (e' + e) =\nSFopp (binary_round mode_NE s m (e' + e))","hypotheses":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z)","proofString":"unfold binary_round.\nset (shl := shl_align_fexp _ _); case shl; intros mz ez.\nunfold binary_round_aux.\nset (shr := shr_fexp _ _ _); case shr; intros mrs e''.\nunfold choice_mode.\nset (shr' := shr_fexp _ _ _); case shr'; intros mrs' e'''.\nunfold binary_fit_aux.\nnow case (shr_m mrs') as [|p|p]; [|case Z.leb|]."},{"statement":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) : (let\n '(mz, ez) := shl_align_fexp m (e' + e) in\n  binary_round_aux mode_NE (negb s) (Z.pos mz) ez loc_Exact) =\nSFopp\n  (let\n   '(mz, ez) := shl_align_fexp m (e' + e) in\n    binary_round_aux mode_NE s (Z.pos mz) ez loc_Exact).","conclusion":"(let\n '(mz, ez) := shl_align_fexp m (e' + e) in\n  binary_round_aux mode_NE (negb s) (Z.pos mz) ez loc_Exact) =\nSFopp\n  (let\n   '(mz, ez) := shl_align_fexp m (e' + e) in\n    binary_round_aux mode_NE s (Z.pos mz) ez loc_Exact)","hypotheses":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z)","proofString":"set (shl := shl_align_fexp _ _); case shl; intros mz ez.\nunfold binary_round_aux.\nset (shr := shr_fexp _ _ _); case shr; intros mrs e''.\nunfold choice_mode.\nset (shr' := shr_fexp _ _ _); case shr'; intros mrs' e'''.\nunfold binary_fit_aux.\nnow case (shr_m mrs') as [|p|p]; [|case Z.leb|]."},{"statement":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) (shl : positive * Z) (mz : positive) (ez : Z) : binary_round_aux mode_NE (negb s) (Z.pos mz) ez loc_Exact =\nSFopp (binary_round_aux mode_NE s (Z.pos mz) ez loc_Exact).","conclusion":"binary_round_aux mode_NE (negb s) (Z.pos mz) ez loc_Exact =\nSFopp (binary_round_aux mode_NE s (Z.pos mz) ez loc_Exact)","hypotheses":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) (shl : positive * Z) (mz : positive) (ez : Z)","proofString":"unfold binary_round_aux.\nset (shr := shr_fexp _ _ _); case shr; intros mrs e''.\nunfold choice_mode.\nset (shr' := shr_fexp _ _ _); case shr'; intros mrs' e'''.\nunfold binary_fit_aux.\nnow case (shr_m mrs') as [|p|p]; [|case Z.leb|]."},{"statement":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) (shl : positive * Z) (mz : positive) (ez : Z) : (let\n '(mrs', e'0) := shr_fexp (Z.pos mz) ez loc_Exact in\n  let\n  '(mrs'', e'') :=\n   shr_fexp\n     (choice_mode mode_NE (negb s) (shr_m mrs') (loc_of_shr_record mrs')) e'0\n     loc_Exact in\n   match shr_m mrs'' with\n   | 0%Z => S754_zero (negb s)\n   | Z.pos m0 => binary_fit_aux mode_NE (negb s) m0 e''\n   | Z.neg _ => S754_nan\n   end) =\nSFopp\n  (let\n   '(mrs', e'0) := shr_fexp (Z.pos mz) ez loc_Exact in\n    let\n    '(mrs'', e'') :=\n     shr_fexp (choice_mode mode_NE s (shr_m mrs') (loc_of_shr_record mrs'))\n       e'0 loc_Exact in\n     match shr_m mrs'' with\n     | 0%Z => S754_zero s\n     | Z.pos m0 => binary_fit_aux mode_NE s m0 e''\n     | Z.neg _ => S754_nan\n     end).","conclusion":"(let\n '(mrs', e'0) := shr_fexp (Z.pos mz) ez loc_Exact in\n  let\n  '(mrs'', e'') :=\n   shr_fexp\n     (choice_mode mode_NE (negb s) (shr_m mrs') (loc_of_shr_record mrs')) e'0\n     loc_Exact in\n   match shr_m mrs'' with\n   | 0%Z => S754_zero (negb s)\n   | Z.pos m0 => binary_fit_aux mode_NE (negb s) m0 e''\n   | Z.neg _ => S754_nan\n   end) =\nSFopp\n  (let\n   '(mrs', e'0) := shr_fexp (Z.pos mz) ez loc_Exact in\n    let\n    '(mrs'', e'') :=\n     shr_fexp (choice_mode mode_NE s (shr_m mrs') (loc_of_shr_record mrs'))\n       e'0 loc_Exact in\n     match shr_m mrs'' with\n     | 0%Z => S754_zero s\n     | Z.pos m0 => binary_fit_aux mode_NE s m0 e''\n     | Z.neg _ => S754_nan\n     end)","hypotheses":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) (shl : positive * Z) (mz : positive) (ez : Z)","proofString":"set (shr := shr_fexp _ _ _); case shr; intros mrs e''.\nunfold choice_mode.\nset (shr' := shr_fexp _ _ _); case shr'; intros mrs' e'''.\nunfold binary_fit_aux.\nnow case (shr_m mrs') as [|p|p]; [|case Z.leb|]."},{"statement":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) (shl : positive * Z) (mz : positive) (ez : Z) (shr : shr_record * Z) (mrs : shr_record) (e'' : Z) : (let\n '(mrs'', e''0) :=\n  shr_fexp (choice_mode mode_NE (negb s) (shr_m mrs) (loc_of_shr_record mrs))\n    e'' loc_Exact in\n  match shr_m mrs'' with\n  | 0%Z => S754_zero (negb s)\n  | Z.pos m0 => binary_fit_aux mode_NE (negb s) m0 e''0\n  | Z.neg _ => S754_nan\n  end) =\nSFopp\n  (let\n   '(mrs'', e''0) :=\n    shr_fexp (choice_mode mode_NE s (shr_m mrs) (loc_of_shr_record mrs)) e''\n      loc_Exact in\n    match shr_m mrs'' with\n    | 0%Z => S754_zero s\n    | Z.pos m0 => binary_fit_aux mode_NE s m0 e''0\n    | Z.neg _ => S754_nan\n    end).","conclusion":"(let\n '(mrs'', e''0) :=\n  shr_fexp (choice_mode mode_NE (negb s) (shr_m mrs) (loc_of_shr_record mrs))\n    e'' loc_Exact in\n  match shr_m mrs'' with\n  | 0%Z => S754_zero (negb s)\n  | Z.pos m0 => binary_fit_aux mode_NE (negb s) m0 e''0\n  | Z.neg _ => S754_nan\n  end) =\nSFopp\n  (let\n   '(mrs'', e''0) :=\n    shr_fexp (choice_mode mode_NE s (shr_m mrs) (loc_of_shr_record mrs)) e''\n      loc_Exact in\n    match shr_m mrs'' with\n    | 0%Z => S754_zero s\n    | Z.pos m0 => binary_fit_aux mode_NE s m0 e''0\n    | Z.neg _ => S754_nan\n    end)","hypotheses":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) (shl : positive * Z) (mz : positive) (ez : Z) (shr : shr_record * Z) (mrs : shr_record) (e'' : Z)","proofString":"unfold choice_mode.\nset (shr' := shr_fexp _ _ _); case shr'; intros mrs' e'''.\nunfold binary_fit_aux.\nnow case (shr_m mrs') as [|p|p]; [|case Z.leb|]."},{"statement":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) (shl : positive * Z) (mz : positive) (ez : Z) (shr : shr_record * Z) (mrs : shr_record) (e'' : Z) : (let\n '(mrs'', e''0) :=\n  shr_fexp\n    (cond_incr (round_N (negb (Z.even (shr_m mrs))) (loc_of_shr_record mrs))\n       (shr_m mrs)) e'' loc_Exact in\n  match shr_m mrs'' with\n  | 0%Z => S754_zero (negb s)\n  | Z.pos m0 => binary_fit_aux mode_NE (negb s) m0 e''0\n  | Z.neg _ => S754_nan\n  end) =\nSFopp\n  (let\n   '(mrs'', e''0) :=\n    shr_fexp\n      (cond_incr\n         (round_N (negb (Z.even (shr_m mrs))) (loc_of_shr_record mrs))\n         (shr_m mrs)) e'' loc_Exact in\n    match shr_m mrs'' with\n    | 0%Z => S754_zero s\n    | Z.pos m0 => binary_fit_aux mode_NE s m0 e''0\n    | Z.neg _ => S754_nan\n    end).","conclusion":"(let\n '(mrs'', e''0) :=\n  shr_fexp\n    (cond_incr (round_N (negb (Z.even (shr_m mrs))) (loc_of_shr_record mrs))\n       (shr_m mrs)) e'' loc_Exact in\n  match shr_m mrs'' with\n  | 0%Z => S754_zero (negb s)\n  | Z.pos m0 => binary_fit_aux mode_NE (negb s) m0 e''0\n  | Z.neg _ => S754_nan\n  end) =\nSFopp\n  (let\n   '(mrs'', e''0) :=\n    shr_fexp\n      (cond_incr\n         (round_N (negb (Z.even (shr_m mrs))) (loc_of_shr_record mrs))\n         (shr_m mrs)) e'' loc_Exact in\n    match shr_m mrs'' with\n    | 0%Z => S754_zero s\n    | Z.pos m0 => binary_fit_aux mode_NE s m0 e''0\n    | Z.neg _ => S754_nan\n    end)","hypotheses":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) (shl : positive * Z) (mz : positive) (ez : Z) (shr : shr_record * Z) (mrs : shr_record) (e'' : Z)","proofString":"set (shr' := shr_fexp _ _ _); case shr'; intros mrs' e'''.\nunfold binary_fit_aux.\nnow case (shr_m mrs') as [|p|p]; [|case Z.leb|]."},{"statement":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) (shl : positive * Z) (mz : positive) (ez : Z) (shr : shr_record * Z) (mrs : shr_record) (e'' : Z) (shr' : shr_record * Z) (mrs' : shr_record) (e''' : Z) : match shr_m mrs' with\n| 0%Z => S754_zero (negb s)\n| Z.pos m0 => binary_fit_aux mode_NE (negb s) m0 e'''\n| Z.neg _ => S754_nan\nend =\nSFopp\n  match shr_m mrs' with\n  | 0%Z => S754_zero s\n  | Z.pos m0 => binary_fit_aux mode_NE s m0 e'''\n  | Z.neg _ => S754_nan\n  end.","conclusion":"match shr_m mrs' with\n| 0%Z => S754_zero (negb s)\n| Z.pos m0 => binary_fit_aux mode_NE (negb s) m0 e'''\n| Z.neg _ => S754_nan\nend =\nSFopp\n  match shr_m mrs' with\n  | 0%Z => S754_zero s\n  | Z.pos m0 => binary_fit_aux mode_NE s m0 e'''\n  | Z.neg _ => S754_nan\n  end","hypotheses":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) (shl : positive * Z) (mz : positive) (ez : Z) (shr : shr_record * Z) (mrs : shr_record) (e'' : Z) (shr' : shr_record * Z) (mrs' : shr_record) (e''' : Z)","proofString":"unfold binary_fit_aux.\nnow case (shr_m mrs') as [|p|p]; [|case Z.leb|]."},{"statement":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) (shl : positive * Z) (mz : positive) (ez : Z) (shr : shr_record * Z) (mrs : shr_record) (e'' : Z) (shr' : shr_record * Z) (mrs' : shr_record) (e''' : Z) : match shr_m mrs' with\n| 0%Z => S754_zero (negb s)\n| Z.pos m0 =>\n    if (e''' <=? emax - prec)%Z\n    then S754_finite (negb s) m0 e'''\n    else binary_overflow mode_NE (negb s)\n| Z.neg _ => S754_nan\nend =\nSFopp\n  match shr_m mrs' with\n  | 0%Z => S754_zero s\n  | Z.pos m0 =>\n      if (e''' <=? emax - prec)%Z\n      then S754_finite s m0 e'''\n      else binary_overflow mode_NE s\n  | Z.neg _ => S754_nan\n  end.","conclusion":"match shr_m mrs' with\n| 0%Z => S754_zero (negb s)\n| Z.pos m0 =>\n    if (e''' <=? emax - prec)%Z\n    then S754_finite (negb s) m0 e'''\n    else binary_overflow mode_NE (negb s)\n| Z.neg _ => S754_nan\nend =\nSFopp\n  match shr_m mrs' with\n  | 0%Z => S754_zero s\n  | Z.pos m0 =>\n      if (e''' <=? emax - prec)%Z\n      then S754_finite s m0 e'''\n      else binary_overflow mode_NE s\n  | Z.neg _ => S754_nan\n  end","hypotheses":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) (shl : positive * Z) (mz : positive) (ez : Z) (shr : shr_record * Z) (mrs : shr_record) (e'' : Z) (shr' : shr_record * Z) (mrs' : shr_record) (e''' : Z)","proofString":"now case (shr_m mrs') as [|p|p]; [|case Z.leb|]."},{"statement":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z) : SFopp (B2SF (Bldexp mode_NE (B754_finite s m e' B) e)) =\nB2SF (Bopp (Bldexp mode_NE (B754_finite s m e' B) e)).","conclusion":"SFopp (B2SF (Bldexp mode_NE (B754_finite s m e' B) e)) =\nB2SF (Bopp (Bldexp mode_NE (B754_finite s m e' B) e))","hypotheses":"(s : bool) (m : positive) (e' : Z) (B : bounded m e' = true) (e : Z)","proofString":"now case Bldexp as [s'|s'| |s' m' e'' B']."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) : (digits2_pos mx <= Z.to_pos prec)%positive.","conclusion":"(digits2_pos mx <= Z.to_pos prec)%positive","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z)","proofString":"change (_ <= _)%positive    with (Z.pos (digits2_pos mx) <= Z.pos (Z.to_pos prec))%Z.\nnow rewrite Z2Pos.id; [|now apply prec_gt_0_]."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) : (Z.pos (digits2_pos mx) <= Z.pos (Z.to_pos prec))%Z.","conclusion":"(Z.pos (digits2_pos mx) <= Z.pos (Z.to_pos prec))%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z)","proofString":"now rewrite Z2Pos.id; [|now apply prec_gt_0_]."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (- prec < 3 - emax - prec)%Z) : (2 < emax)%Z ->\n(/ 2 <= Rabs (SF2R radix2 (fst (S754_finite sx mx ex, 0%Z))) < 1)%R.","conclusion":"(2 < emax)%Z ->\n(/ 2 <= Rabs (SF2R radix2 (fst (S754_finite sx mx ex, 0%Z))) < 1)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (- prec < 3 - emax - prec)%Z)","proofString":"clear -Hp ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) : digits2_pos mx = Z.to_pos prec.","conclusion":"digits2_pos mx = Z.to_pos prec","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive)","proofString":"now apply Pos.le_antisym."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) : Z.pos (digits2_pos mx) = prec.","conclusion":"Z.pos (digits2_pos mx) = prec","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec)","proofString":"now rewrite Dmx', Z2Pos.id; [|apply prec_gt_0_]."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (canonical_mantissa mx (- prec) && (- prec <=? emax - prec)%Z)%bool = true.","conclusion":"(canonical_mantissa mx (- prec) && (- prec <=? emax - prec)%Z)%bool = true","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"apply andb_true_intro.\nsplit ; cycle 1.\napply Zle_bool_true.\nclear -Hp ; lia.\napply Zeq_bool_true; unfold fexp, FLT_exp.\nrewrite Dmx', Z2Pos.id by apply prec_gt_0_.\nrewrite Z.max_l.\nring.\nclear -Hp.\nunfold emin ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : canonical_mantissa mx (- prec) = true /\\ (- prec <=? emax - prec)%Z = true.","conclusion":"canonical_mantissa mx (- prec) = true /\\ (- prec <=? emax - prec)%Z = true","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"split ; cycle 1.\napply Zle_bool_true.\nclear -Hp ; lia.\napply Zeq_bool_true; unfold fexp, FLT_exp.\nrewrite Dmx', Z2Pos.id by apply prec_gt_0_.\nrewrite Z.max_l.\nring.\nclear -Hp.\nunfold emin ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (- prec <=? emax - prec)%Z = true.","conclusion":"(- prec <=? emax - prec)%Z = true","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"apply Zle_bool_true.\nclear -Hp ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (- prec <= emax - prec)%Z.","conclusion":"(- prec <= emax - prec)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"clear -Hp ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : canonical_mantissa mx (- prec) = true.","conclusion":"canonical_mantissa mx (- prec) = true","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"apply Zeq_bool_true; unfold fexp, FLT_exp.\nrewrite Dmx', Z2Pos.id by apply prec_gt_0_.\nrewrite Z.max_l.\nring.\nclear -Hp.\nunfold emin ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : Z.max (Z.pos (digits2_pos mx) + - prec - prec) emin = (- prec)%Z.","conclusion":"Z.max (Z.pos (digits2_pos mx) + - prec - prec) emin = (- prec)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"rewrite Dmx', Z2Pos.id by apply prec_gt_0_.\nrewrite Z.max_l.\nring.\nclear -Hp.\nunfold emin ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : Z.max (prec + - prec - prec) emin = (- prec)%Z.","conclusion":"Z.max (prec + - prec - prec) emin = (- prec)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"rewrite Z.max_l.\nring.\nclear -Hp.\nunfold emin ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (prec + - prec - prec)%Z = (- prec)%Z.","conclusion":"(prec + - prec - prec)%Z = (- prec)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"ring."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (emin <= prec + - prec - prec)%Z.","conclusion":"(emin <= prec + - prec - prec)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"clear -Hp.\nunfold emin ; lia."},{"statement":"(Hp : (3 - emax - prec <= - prec)%Z) : (emin <= prec + - prec - prec)%Z.","conclusion":"(emin <= prec + - prec - prec)%Z","hypotheses":"(Hp : (3 - emax - prec <= - prec)%Z)","proofString":"unfold emin ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (2 < emax)%Z ->\n(/ 2 <= Rabs (IZR (cond_Zopp sx (Z.pos mx)) * bpow radix2 (- prec)) < 1)%R.","conclusion":"(2 < emax)%Z ->\n(/ 2 <= Rabs (IZR (cond_Zopp sx (Z.pos mx)) * bpow radix2 (- prec)) < 1)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"intros _.\nrewrite Rabs_mult, (Rabs_pos_eq (bpow _ _)) by now apply bpow_ge_0.\nrewrite <-abs_IZR, abs_cond_Zopp; simpl; split.\napply (Rmult_le_reg_r (bpow radix2 prec)); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <-bpow_plus, Z.add_opp_diag_l; simpl.\nrewrite Rmult_1_r.\nchange (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <-Dmx'', Z.add_comm, Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nnow apply bpow_mag_le, IZR_neq.\napply (Rmult_lt_reg_r (bpow radix2 prec)); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <-bpow_plus, Z.add_opp_diag_l; simpl.\nrewrite Rmult_1_l, Rmult_1_r.\nrewrite <-Dmx'', Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (/ 2 <= Rabs (IZR (cond_Zopp sx (Z.pos mx)) * bpow radix2 (- prec)) < 1)%R.","conclusion":"(/ 2 <= Rabs (IZR (cond_Zopp sx (Z.pos mx)) * bpow radix2 (- prec)) < 1)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"rewrite Rabs_mult, (Rabs_pos_eq (bpow _ _)) by now apply bpow_ge_0.\nrewrite <-abs_IZR, abs_cond_Zopp; simpl; split.\napply (Rmult_le_reg_r (bpow radix2 prec)); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <-bpow_plus, Z.add_opp_diag_l; simpl.\nrewrite Rmult_1_r.\nchange (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <-Dmx'', Z.add_comm, Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nnow apply bpow_mag_le, IZR_neq.\napply (Rmult_lt_reg_r (bpow radix2 prec)); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <-bpow_plus, Z.add_opp_diag_l; simpl.\nrewrite Rmult_1_l, Rmult_1_r.\nrewrite <-Dmx'', Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (/ 2 <= Rabs (IZR (cond_Zopp sx (Z.pos mx))) * bpow radix2 (- prec) < 1)%R.","conclusion":"(/ 2 <= Rabs (IZR (cond_Zopp sx (Z.pos mx))) * bpow radix2 (- prec) < 1)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"rewrite <-abs_IZR, abs_cond_Zopp; simpl; split.\napply (Rmult_le_reg_r (bpow radix2 prec)); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <-bpow_plus, Z.add_opp_diag_l; simpl.\nrewrite Rmult_1_r.\nchange (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <-Dmx'', Z.add_comm, Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nnow apply bpow_mag_le, IZR_neq.\napply (Rmult_lt_reg_r (bpow radix2 prec)); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <-bpow_plus, Z.add_opp_diag_l; simpl.\nrewrite Rmult_1_l, Rmult_1_r.\nrewrite <-Dmx'', Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (/ 2 <= IZR (Z.pos mx) * bpow radix2 (- prec))%R.","conclusion":"(/ 2 <= IZR (Z.pos mx) * bpow radix2 (- prec))%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"apply (Rmult_le_reg_r (bpow radix2 prec)); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <-bpow_plus, Z.add_opp_diag_l; simpl.\nrewrite Rmult_1_r.\nchange (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <-Dmx'', Z.add_comm, Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nnow apply bpow_mag_le, IZR_neq."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (/ 2 * bpow radix2 prec <=\n IZR (Z.pos mx) * bpow radix2 (- prec) * bpow radix2 prec)%R.","conclusion":"(/ 2 * bpow radix2 prec <=\n IZR (Z.pos mx) * bpow radix2 (- prec) * bpow radix2 prec)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"rewrite Rmult_assoc, <-bpow_plus, Z.add_opp_diag_l; simpl.\nrewrite Rmult_1_r.\nchange (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <-Dmx'', Z.add_comm, Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nnow apply bpow_mag_le, IZR_neq."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (/ 2 * bpow radix2 prec <= IZR (Z.pos mx) * 1)%R.","conclusion":"(/ 2 * bpow radix2 prec <= IZR (Z.pos mx) * 1)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"rewrite Rmult_1_r.\nchange (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <-Dmx'', Z.add_comm, Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nnow apply bpow_mag_le, IZR_neq."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (/ 2 * bpow radix2 prec <= IZR (Z.pos mx))%R.","conclusion":"(/ 2 * bpow radix2 prec <= IZR (Z.pos mx))%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"change (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <-Dmx'', Z.add_comm, Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nnow apply bpow_mag_le, IZR_neq."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (bpow radix2 (-1 + prec) <= IZR (Z.pos mx))%R.","conclusion":"(bpow radix2 (-1 + prec) <= IZR (Z.pos mx))%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"rewrite <-Dmx'', Z.add_comm, Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nnow apply bpow_mag_le, IZR_neq."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (bpow radix2 (mag radix2 (IZR (Z.pos mx)) + -1) <= IZR (Z.pos mx))%R.","conclusion":"(bpow radix2 (mag radix2 (IZR (Z.pos mx)) + -1) <= IZR (Z.pos mx))%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"set (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nnow apply bpow_mag_le, IZR_neq."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (IZR (Z.pos mx) * bpow radix2 (- prec) < 1)%R.","conclusion":"(IZR (Z.pos mx) * bpow radix2 (- prec) < 1)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"apply (Rmult_lt_reg_r (bpow radix2 prec)); [now apply bpow_gt_0|].\nrewrite Rmult_assoc, <-bpow_plus, Z.add_opp_diag_l; simpl.\nrewrite Rmult_1_l, Rmult_1_r.\nrewrite <-Dmx'', Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (IZR (Z.pos mx) * bpow radix2 (- prec) * bpow radix2 prec <\n 1 * bpow radix2 prec)%R.","conclusion":"(IZR (Z.pos mx) * bpow radix2 (- prec) * bpow radix2 prec <\n 1 * bpow radix2 prec)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"rewrite Rmult_assoc, <-bpow_plus, Z.add_opp_diag_l; simpl.\nrewrite Rmult_1_l, Rmult_1_r.\nrewrite <-Dmx'', Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (IZR (Z.pos mx) * 1 < 1 * bpow radix2 prec)%R.","conclusion":"(IZR (Z.pos mx) * 1 < 1 * bpow radix2 prec)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"rewrite Rmult_1_l, Rmult_1_r.\nrewrite <-Dmx'', Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (IZR (Z.pos mx) < bpow radix2 prec)%R.","conclusion":"(IZR (Z.pos mx) < bpow radix2 prec)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"rewrite <-Dmx'', Zpos_digits2_pos, Zdigits_mag; [|lia].\nset (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec) : (IZR (Z.pos mx) < bpow radix2 (mag radix2 (IZR (Z.pos mx))))%R.","conclusion":"(IZR (Z.pos mx) < bpow radix2 (mag radix2 (IZR (Z.pos mx))))%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (Z.to_pos prec <= digits2_pos mx)%positive) (Dmx' : digits2_pos mx = Z.to_pos prec) (Dmx'' : Z.pos (digits2_pos mx) = prec)","proofString":"set (b := bpow _ _).\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) : (Z.pos (digits2_pos mx) < prec)%Z.","conclusion":"(Z.pos (digits2_pos mx) < prec)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive)","proofString":"now rewrite <-(Z2Pos.id prec); [|now apply prec_gt_0_]."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : (canonical_mantissa (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx)\n   (- prec) && (- prec <=? emax - prec)%Z)%bool = true.","conclusion":"(canonical_mantissa (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx)\n   (- prec) && (- prec <=? emax - prec)%Z)%bool = true","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"unfold bounded; apply andb_true_intro.\nsplit ; cycle 1.\napply Zle_bool_true.\nclear -Hp ; lia.\napply Zeq_bool_true; unfold fexp, FLT_exp.\nrewrite Zpos_digits2_pos, shift_pos_correct, Z.pow_pos_fold.\nrewrite Z2Pos.id; [|lia].\nrewrite Z.mul_comm; change 2%Z with (radix2 : Z).\nrewrite Zdigits_mult_Zpower; [|lia|lia].\nrewrite Zpos_digits2_pos; replace (_ - _)%Z with (- prec)%Z by ring.\nnow apply Z.max_l."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : canonical_mantissa (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx)\n  (- prec) = true /\\ (- prec <=? emax - prec)%Z = true.","conclusion":"canonical_mantissa (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx)\n  (- prec) = true /\\ (- prec <=? emax - prec)%Z = true","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"split ; cycle 1.\napply Zle_bool_true.\nclear -Hp ; lia.\napply Zeq_bool_true; unfold fexp, FLT_exp.\nrewrite Zpos_digits2_pos, shift_pos_correct, Z.pow_pos_fold.\nrewrite Z2Pos.id; [|lia].\nrewrite Z.mul_comm; change 2%Z with (radix2 : Z).\nrewrite Zdigits_mult_Zpower; [|lia|lia].\nrewrite Zpos_digits2_pos; replace (_ - _)%Z with (- prec)%Z by ring.\nnow apply Z.max_l."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : (- prec <=? emax - prec)%Z = true.","conclusion":"(- prec <=? emax - prec)%Z = true","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"apply Zle_bool_true.\nclear -Hp ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : (- prec <= emax - prec)%Z.","conclusion":"(- prec <= emax - prec)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"clear -Hp ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : canonical_mantissa (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx)\n  (- prec) = true.","conclusion":"canonical_mantissa (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx)\n  (- prec) = true","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"apply Zeq_bool_true; unfold fexp, FLT_exp.\nrewrite Zpos_digits2_pos, shift_pos_correct, Z.pow_pos_fold.\nrewrite Z2Pos.id; [|lia].\nrewrite Z.mul_comm; change 2%Z with (radix2 : Z).\nrewrite Zdigits_mult_Zpower; [|lia|lia].\nrewrite Zpos_digits2_pos; replace (_ - _)%Z with (- prec)%Z by ring.\nnow apply Z.max_l."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : Z.max\n  (Z.pos\n     (digits2_pos (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx)) +\n   - prec - prec) emin = (- prec)%Z.","conclusion":"Z.max\n  (Z.pos\n     (digits2_pos (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx)) +\n   - prec - prec) emin = (- prec)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"rewrite Zpos_digits2_pos, shift_pos_correct, Z.pow_pos_fold.\nrewrite Z2Pos.id; [|lia].\nrewrite Z.mul_comm; change 2%Z with (radix2 : Z).\nrewrite Zdigits_mult_Zpower; [|lia|lia].\nrewrite Zpos_digits2_pos; replace (_ - _)%Z with (- prec)%Z by ring.\nnow apply Z.max_l."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : Z.max\n  (Zdigits radix2\n     (2 ^ Z.pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) * Z.pos mx) +\n   - prec - prec) emin = (- prec)%Z.","conclusion":"Z.max\n  (Zdigits radix2\n     (2 ^ Z.pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) * Z.pos mx) +\n   - prec - prec) emin = (- prec)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"rewrite Z2Pos.id; [|lia].\nrewrite Z.mul_comm; change 2%Z with (radix2 : Z).\nrewrite Zdigits_mult_Zpower; [|lia|lia].\nrewrite Zpos_digits2_pos; replace (_ - _)%Z with (- prec)%Z by ring.\nnow apply Z.max_l."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : Z.max\n  (Zdigits radix2 (2 ^ (prec - Z.pos (digits2_pos mx)) * Z.pos mx) + - prec -\n   prec) emin = (- prec)%Z.","conclusion":"Z.max\n  (Zdigits radix2 (2 ^ (prec - Z.pos (digits2_pos mx)) * Z.pos mx) + - prec -\n   prec) emin = (- prec)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"rewrite Z.mul_comm; change 2%Z with (radix2 : Z).\nrewrite Zdigits_mult_Zpower; [|lia|lia].\nrewrite Zpos_digits2_pos; replace (_ - _)%Z with (- prec)%Z by ring.\nnow apply Z.max_l."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : Z.max\n  (Zdigits radix2 (Z.pos mx * (radix2 : Z) ^ (prec - Z.pos (digits2_pos mx))) +\n   - prec - prec) emin = (- prec)%Z.","conclusion":"Z.max\n  (Zdigits radix2 (Z.pos mx * (radix2 : Z) ^ (prec - Z.pos (digits2_pos mx))) +\n   - prec - prec) emin = (- prec)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"rewrite Zdigits_mult_Zpower; [|lia|lia].\nrewrite Zpos_digits2_pos; replace (_ - _)%Z with (- prec)%Z by ring.\nnow apply Z.max_l."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : Z.max\n  (Zdigits radix2 (Z.pos mx) + (prec - Z.pos (digits2_pos mx)) + - prec -\n   prec) emin = (- prec)%Z.","conclusion":"Z.max\n  (Zdigits radix2 (Z.pos mx) + (prec - Z.pos (digits2_pos mx)) + - prec -\n   prec) emin = (- prec)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"rewrite Zpos_digits2_pos; replace (_ - _)%Z with (- prec)%Z by ring.\nnow apply Z.max_l."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : Z.max (- prec) emin = (- prec)%Z.","conclusion":"Z.max (- prec) emin = (- prec)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"now apply Z.max_l."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : (2 < emax)%Z ->\n(/ 2 <=\n Rabs\n   (IZR\n      (cond_Zopp sx\n         (Z.pos (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx))) *\n    bpow radix2 (- prec)) < 1)%R.","conclusion":"(2 < emax)%Z ->\n(/ 2 <=\n Rabs\n   (IZR\n      (cond_Zopp sx\n         (Z.pos (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx))) *\n    bpow radix2 (- prec)) < 1)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"rewrite Rabs_mult, (Rabs_pos_eq (bpow _ _)); [|now apply bpow_ge_0].\nrewrite <-abs_IZR, abs_cond_Zopp; simpl.\nrewrite shift_pos_correct, mult_IZR.\nchange (IZR (Z.pow_pos _ _))      with (bpow radix2 (Z.pos (Z.to_pos ((prec - Z.pos (digits2_pos mx)))))).\nrewrite Z2Pos.id; [|lia].\nrewrite Rmult_comm, <-Rmult_assoc, <-bpow_plus.\nset (d := Z.pos (digits2_pos mx)).\nreplace (_ + _)%Z with (- d)%Z by ring; split.\napply (Rmult_le_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l.\nchange (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\nnow apply bpow_mag_le, IZR_neq.\napply (Rmult_lt_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l, Rmult_1_r.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : (2 < emax)%Z ->\n(/ 2 <=\n Rabs\n   (IZR\n      (cond_Zopp sx\n         (Z.pos (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx)))) *\n bpow radix2 (- prec) < 1)%R.","conclusion":"(2 < emax)%Z ->\n(/ 2 <=\n Rabs\n   (IZR\n      (cond_Zopp sx\n         (Z.pos (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx)))) *\n bpow radix2 (- prec) < 1)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"rewrite <-abs_IZR, abs_cond_Zopp; simpl.\nrewrite shift_pos_correct, mult_IZR.\nchange (IZR (Z.pow_pos _ _))      with (bpow radix2 (Z.pos (Z.to_pos ((prec - Z.pos (digits2_pos mx)))))).\nrewrite Z2Pos.id; [|lia].\nrewrite Rmult_comm, <-Rmult_assoc, <-bpow_plus.\nset (d := Z.pos (digits2_pos mx)).\nreplace (_ + _)%Z with (- d)%Z by ring; split.\napply (Rmult_le_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l.\nchange (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\nnow apply bpow_mag_le, IZR_neq.\napply (Rmult_lt_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l, Rmult_1_r.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : (2 < emax)%Z ->\n(/ 2 <=\n IZR (Z.pos (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx)) *\n bpow radix2 (- prec) < 1)%R.","conclusion":"(2 < emax)%Z ->\n(/ 2 <=\n IZR (Z.pos (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx)) *\n bpow radix2 (- prec) < 1)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"rewrite shift_pos_correct, mult_IZR.\nchange (IZR (Z.pow_pos _ _))      with (bpow radix2 (Z.pos (Z.to_pos ((prec - Z.pos (digits2_pos mx)))))).\nrewrite Z2Pos.id; [|lia].\nrewrite Rmult_comm, <-Rmult_assoc, <-bpow_plus.\nset (d := Z.pos (digits2_pos mx)).\nreplace (_ + _)%Z with (- d)%Z by ring; split.\napply (Rmult_le_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l.\nchange (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\nnow apply bpow_mag_le, IZR_neq.\napply (Rmult_lt_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l, Rmult_1_r.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : (2 < emax)%Z ->\n(/ 2 <=\n IZR (Z.pow_pos 2 (Z.to_pos (prec - Z.pos (digits2_pos mx)))) *\n IZR (Z.pos mx) * bpow radix2 (- prec) < 1)%R.","conclusion":"(2 < emax)%Z ->\n(/ 2 <=\n IZR (Z.pow_pos 2 (Z.to_pos (prec - Z.pos (digits2_pos mx)))) *\n IZR (Z.pos mx) * bpow radix2 (- prec) < 1)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"change (IZR (Z.pow_pos _ _))      with (bpow radix2 (Z.pos (Z.to_pos ((prec - Z.pos (digits2_pos mx)))))).\nrewrite Z2Pos.id; [|lia].\nrewrite Rmult_comm, <-Rmult_assoc, <-bpow_plus.\nset (d := Z.pos (digits2_pos mx)).\nreplace (_ + _)%Z with (- d)%Z by ring; split.\napply (Rmult_le_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l.\nchange (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\nnow apply bpow_mag_le, IZR_neq.\napply (Rmult_lt_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l, Rmult_1_r.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : (2 < emax)%Z ->\n(/ 2 <=\n bpow radix2 (Z.pos (Z.to_pos (prec - Z.pos (digits2_pos mx)))) *\n IZR (Z.pos mx) * bpow radix2 (- prec) < 1)%R.","conclusion":"(2 < emax)%Z ->\n(/ 2 <=\n bpow radix2 (Z.pos (Z.to_pos (prec - Z.pos (digits2_pos mx)))) *\n IZR (Z.pos mx) * bpow radix2 (- prec) < 1)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"rewrite Z2Pos.id; [|lia].\nrewrite Rmult_comm, <-Rmult_assoc, <-bpow_plus.\nset (d := Z.pos (digits2_pos mx)).\nreplace (_ + _)%Z with (- d)%Z by ring; split.\napply (Rmult_le_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l.\nchange (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\nnow apply bpow_mag_le, IZR_neq.\napply (Rmult_lt_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l, Rmult_1_r.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : (2 < emax)%Z ->\n(/ 2 <=\n bpow radix2 (prec - Z.pos (digits2_pos mx)) * IZR (Z.pos mx) *\n bpow radix2 (- prec) < 1)%R.","conclusion":"(2 < emax)%Z ->\n(/ 2 <=\n bpow radix2 (prec - Z.pos (digits2_pos mx)) * IZR (Z.pos mx) *\n bpow radix2 (- prec) < 1)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"rewrite Rmult_comm, <-Rmult_assoc, <-bpow_plus.\nset (d := Z.pos (digits2_pos mx)).\nreplace (_ + _)%Z with (- d)%Z by ring; split.\napply (Rmult_le_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l.\nchange (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\nnow apply bpow_mag_le, IZR_neq.\napply (Rmult_lt_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l, Rmult_1_r.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) : (2 < emax)%Z ->\n(/ 2 <=\n bpow radix2 (- prec + (prec - Z.pos (digits2_pos mx))) * IZR (Z.pos mx) < 1)%R.","conclusion":"(2 < emax)%Z ->\n(/ 2 <=\n bpow radix2 (- prec + (prec - Z.pos (digits2_pos mx))) * IZR (Z.pos mx) < 1)%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z)","proofString":"set (d := Z.pos (digits2_pos mx)).\nreplace (_ + _)%Z with (- d)%Z by ring; split.\napply (Rmult_le_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l.\nchange (/ 2)%R with (bpow radix2 (- 1)); rewrite <-bpow_plus.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\nnow apply bpow_mag_le, IZR_neq.\napply (Rmult_lt_reg_l (bpow radix2 d)); [now apply bpow_gt_0|].\nrewrite <-Rmult_assoc, <-bpow_plus, Z.add_opp_diag_r.\nrewrite Rmult_1_l, Rmult_1_r.\nrewrite <- (Rabs_pos_eq (IZR _)) by now apply IZR_le.\nunfold d; rewrite Zpos_digits2_pos, Zdigits_mag; [|lia].\napply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) (d : Z) (H : (2 < emax)%Z) : (bpow radix2 (mag radix2 (IZR (Z.pos mx)) + -1) <= Rabs (IZR (Z.pos mx)))%R.","conclusion":"(bpow radix2 (mag radix2 (IZR (Z.pos mx)) + -1) <= Rabs (IZR (Z.pos mx)))%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) (d : Z) (H : (2 < emax)%Z)","proofString":"now apply bpow_mag_le, IZR_neq."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) (d : Z) (H : (2 < emax)%Z) : (Rabs (IZR (Z.pos mx)) < bpow radix2 (mag radix2 (IZR (Z.pos mx))))%R.","conclusion":"(Rabs (IZR (Z.pos mx)) < bpow radix2 (mag radix2 (IZR (Z.pos mx))))%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (x : R) (z : spec_float) (e : Z) (Dmx_le_prec : (Z.pos (digits2_pos mx) <= prec)%Z) (Dmx_le_prec' : (digits2_pos mx <= Z.to_pos prec)%positive) (Hp : (3 - emax - prec <= - prec)%Z) (Dmx : (digits2_pos mx < Z.to_pos prec)%positive) (Dmx' : (Z.pos (digits2_pos mx) < prec)%Z) (d : Z) (H : (2 < emax)%Z)","proofString":"apply bpow_mag_gt."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) : is_nan (fst (Bfrexp (B754_finite sx mx ex Bx))) =\nis_nan (B754_finite sx mx ex Bx).","conclusion":"is_nan (fst (Bfrexp (B754_finite sx mx ex Bx))) =\nis_nan (B754_finite sx mx ex Bx)","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"simpl.\nrewrite is_nan_SF2B.\nunfold Ffrexp_core_binary.\ndestruct Zlt_bool ; try easy.\nnow destruct Pos.leb."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) : is_nan\n  (SF2B (fst (Ffrexp_core_binary sx mx ex))\n     (proj1 (Bfrexp_correct_aux sx mx ex Bx))) = false.","conclusion":"is_nan\n  (SF2B (fst (Ffrexp_core_binary sx mx ex))\n     (proj1 (Bfrexp_correct_aux sx mx ex Bx))) = false","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"rewrite is_nan_SF2B.\nunfold Ffrexp_core_binary.\ndestruct Zlt_bool ; try easy.\nnow destruct Pos.leb."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) : is_nan_SF (fst (Ffrexp_core_binary sx mx ex)) = false.","conclusion":"is_nan_SF (fst (Ffrexp_core_binary sx mx ex)) = false","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"unfold Ffrexp_core_binary.\ndestruct Zlt_bool ; try easy.\nnow destruct Pos.leb."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) : is_nan_SF\n  (fst\n     (if (- prec <? emin)%Z\n      then (S754_finite sx mx ex, 0%Z)\n      else\n       if (Z.to_pos prec <=? digits2_pos mx)%positive\n       then (S754_finite sx mx (- prec), (ex + prec)%Z)\n       else\n        (S754_finite sx\n           (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx) \n           (- prec), (ex + prec - (prec - Z.pos (digits2_pos mx)))%Z))) =\nfalse.","conclusion":"is_nan_SF\n  (fst\n     (if (- prec <? emin)%Z\n      then (S754_finite sx mx ex, 0%Z)\n      else\n       if (Z.to_pos prec <=? digits2_pos mx)%positive\n       then (S754_finite sx mx (- prec), (ex + prec)%Z)\n       else\n        (S754_finite sx\n           (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx) \n           (- prec), (ex + prec - (prec - Z.pos (digits2_pos mx)))%Z))) =\nfalse","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"destruct Zlt_bool ; try easy.\nnow destruct Pos.leb."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) : is_nan_SF\n  (fst\n     (if (Z.to_pos prec <=? digits2_pos mx)%positive\n      then (S754_finite sx mx (- prec), (ex + prec)%Z)\n      else\n       (S754_finite sx\n          (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx) \n          (- prec), (ex + prec - (prec - Z.pos (digits2_pos mx)))%Z))) =\nfalse.","conclusion":"is_nan_SF\n  (fst\n     (if (Z.to_pos prec <=? digits2_pos mx)%positive\n      then (S754_finite sx mx (- prec), (ex + prec)%Z)\n      else\n       (S754_finite sx\n          (shift_pos (Z.to_pos (prec - Z.pos (digits2_pos mx))) mx) \n          (- prec), (ex + prec - (prec - Z.pos (digits2_pos mx)))%Z))) =\nfalse","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"now destruct Pos.leb."},{"statement":"(f : binary_float) (s : bool) (m : positive) (e : Z) (Hf : bounded m e = true) : let (z, e0) := Bfrexp (B754_finite s m e Hf) in\nB2R (B754_finite s m e Hf) = (B2R z * bpow radix2 e0)%R /\\\n((2 < emax)%Z ->\n (/ 2 <= Rabs (B2R z) < 1)%R /\\ e0 = mag radix2 (B2R (B754_finite s m e Hf))).","conclusion":"let (z, e0) := Bfrexp (B754_finite s m e Hf) in\nB2R (B754_finite s m e Hf) = (B2R z * bpow radix2 e0)%R /\\\n((2 < emax)%Z ->\n (/ 2 <= Rabs (B2R z) < 1)%R /\\ e0 = mag radix2 (B2R (B754_finite s m e Hf)))","hypotheses":"(f : binary_float) (s : bool) (m : positive) (e : Z) (Hf : bounded m e = true)","proofString":"generalize (Bfrexp_correct_aux s m e Hf).\nintros (_, (Hb, Heq)); simpl; rewrite B2R_SF2B.\nsplit.\neasy.\nintros Hp.\nspecialize (Hb Hp).\nsplit.\neasy.\nrewrite Heq, mag_mult_bpow.\napply (Z.add_reg_l (- (snd (Ffrexp_core_binary s m e)))).\nnow ring_simplify; symmetry; apply mag_unique.\nintro H; destruct Hb as (Hb, _); revert Hb; rewrite H, Rabs_R0; lra."},{"statement":"(Zeq_bool (fexp (Z.pos (digits2_pos 1) + emin)) emin &&\n (emin <=? emax - prec)%Z)%bool = true.","conclusion":"(Zeq_bool (fexp (Z.pos (digits2_pos 1) + emin)) emin &&\n (emin <=? emax - prec)%Z)%bool = true","hypotheses":"","proofString":"rewrite Zeq_bool_true.\napply Zle_bool_true.\napply Z.max_l_iff, fexp_emax.\napply Z.max_r.\nsimpl digits2_pos.\ngeneralize (prec_gt_0 prec).\nlia."},{"statement":"(true && (emin <=? emax - prec)%Z)%bool = true.","conclusion":"(true && (emin <=? emax - prec)%Z)%bool = true","hypotheses":"","proofString":"apply Zle_bool_true.\napply Z.max_l_iff, fexp_emax."},{"statement":"(emin <= emax - prec)%Z.","conclusion":"(emin <= emax - prec)%Z","hypotheses":"","proofString":"apply Z.max_l_iff, fexp_emax."},{"statement":"fexp (Z.pos (digits2_pos 1) + emin) = emin.","conclusion":"fexp (Z.pos (digits2_pos 1) + emin) = emin","hypotheses":"","proofString":"apply Z.max_r.\nsimpl digits2_pos.\ngeneralize (prec_gt_0 prec).\nlia."},{"statement":"(Z.pos (digits2_pos 1) + emin - prec <= emin)%Z.","conclusion":"(Z.pos (digits2_pos 1) + emin - prec <= emin)%Z","hypotheses":"","proofString":"simpl digits2_pos.\ngeneralize (prec_gt_0 prec).\nlia."},{"statement":"(1 + emin - prec <= emin)%Z.","conclusion":"(1 + emin - prec <= emin)%Z","hypotheses":"","proofString":"generalize (prec_gt_0 prec).\nlia."},{"statement":"(0 < prec)%Z -> (1 + emin - prec <= emin)%Z.","conclusion":"(0 < prec)%Z -> (1 + emin - prec <= emin)%Z","hypotheses":"","proofString":"lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) : is_nan (Bulp (B754_finite sx mx ex Bx)) = is_nan (B754_finite sx mx ex Bx).","conclusion":"is_nan (Bulp (B754_finite sx mx ex Bx)) = is_nan (B754_finite sx mx ex Bx)","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"unfold Bulp.\napply is_nan_binary_normalize."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) : is_nan (binary_normalize mode_ZR 1 ex false) =\nis_nan (B754_finite sx mx ex Bx).","conclusion":"is_nan (binary_normalize mode_ZR 1 ex false) =\nis_nan (B754_finite sx mx ex Bx)","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"apply is_nan_binary_normalize."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) (H2 : SF2R radix2 (binary_round mode_ZR false 1 ex) = bpow radix2 ex) (H3 : is_finite_SF (binary_round mode_ZR false 1 ex) = true) (H4 : sign_SF (binary_round mode_ZR false 1 ex) = false) : SF2R radix2 (binary_round mode_ZR false 1 ex) = bpow radix2 ex.","conclusion":"SF2R radix2 (binary_round mode_ZR false 1 ex) = bpow radix2 ex","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) (H2 : SF2R radix2 (binary_round mode_ZR false 1 ex) = bpow radix2 ex) (H3 : is_finite_SF (binary_round mode_ZR false 1 ex) = true) (H4 : sign_SF (binary_round mode_ZR false 1 ex) = false)","proofString":"exact H2."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) (H2 : SF2R radix2 (binary_round mode_ZR false 1 ex) = bpow radix2 ex) (H3 : is_finite_SF (binary_round mode_ZR false 1 ex) = true) (H4 : sign_SF (binary_round mode_ZR false 1 ex) = false) : cond_Zopp sx (Z.pos mx) <> 0%Z.","conclusion":"cond_Zopp sx (Z.pos mx) <> 0%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) (H2 : SF2R radix2 (binary_round mode_ZR false 1 ex) = bpow radix2 ex) (H3 : is_finite_SF (binary_round mode_ZR false 1 ex) = true) (H4 : sign_SF (binary_round mode_ZR false 1 ex) = false)","proofString":"now case sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) (H2 : SF2R radix2 (binary_round mode_ZR false 1 ex) = bpow radix2 ex) (H3 : is_finite_SF (binary_round mode_ZR false 1 ex) = true) (H4 : sign_SF (binary_round mode_ZR false 1 ex) = false) : canonical radix2 fexp {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}.","conclusion":"canonical radix2 fexp {| Fnum := cond_Zopp sx (Z.pos mx); Fexp := ex |}","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) (H2 : SF2R radix2 (binary_round mode_ZR false 1 ex) = bpow radix2 ex) (H3 : is_finite_SF (binary_round mode_ZR false 1 ex) = true) (H4 : sign_SF (binary_round mode_ZR false 1 ex) = false)","proofString":"now apply canonical_canonical_mantissa."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) (H2 : SF2R radix2 (binary_round mode_ZR false 1 ex) = bpow radix2 ex) (H3 : is_finite_SF (binary_round mode_ZR false 1 ex) = true) (H4 : sign_SF (binary_round mode_ZR false 1 ex) = false) : is_finite\n  (SF2B (binary_round mode_ZR false 1 ex)\n     (proj1 (conj H1 (conj H2 (conj H3 H4))))) = true.","conclusion":"is_finite\n  (SF2B (binary_round mode_ZR false 1 ex)\n     (proj1 (conj H1 (conj H2 (conj H3 H4))))) = true","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) (H2 : SF2R radix2 (binary_round mode_ZR false 1 ex) = bpow radix2 ex) (H3 : is_finite_SF (binary_round mode_ZR false 1 ex) = true) (H4 : sign_SF (binary_round mode_ZR false 1 ex) = false)","proofString":"now rewrite is_finite_SF2B."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) (H2 : SF2R radix2 (binary_round mode_ZR false 1 ex) = bpow radix2 ex) (H3 : is_finite_SF (binary_round mode_ZR false 1 ex) = true) (H4 : sign_SF (binary_round mode_ZR false 1 ex) = false) : Bsign\n  (SF2B (binary_round mode_ZR false 1 ex)\n     (proj1 (conj H1 (conj H2 (conj H3 H4))))) = false.","conclusion":"Bsign\n  (SF2B (binary_round mode_ZR false 1 ex)\n     (proj1 (conj H1 (conj H2 (conj H3 H4))))) = false","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) (H2 : SF2R radix2 (binary_round mode_ZR false 1 ex) = bpow radix2 ex) (H3 : is_finite_SF (binary_round mode_ZR false 1 ex) = true) (H4 : sign_SF (binary_round mode_ZR false 1 ex) = false)","proofString":"now rewrite Bsign_SF2B."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) : bpow radix2 ex = round radix2 fexp Ztrunc (bpow radix2 ex).","conclusion":"bpow radix2 ex = round radix2 fexp Ztrunc (bpow radix2 ex)","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true)","proofString":"apply sym_eq, round_generic.\ntypeclasses eauto.\napply generic_format_FLT_bpow.\neasy.\nrewrite (canonical_canonical_mantissa false _ _ H5).\napply Z.max_le_iff.\nnow right."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) : Valid_rnd Ztrunc.","conclusion":"Valid_rnd Ztrunc","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true)","proofString":"typeclasses eauto."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) : generic_format radix2 fexp (bpow radix2 ex).","conclusion":"generic_format radix2 fexp (bpow radix2 ex)","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true)","proofString":"apply generic_format_FLT_bpow.\neasy.\nrewrite (canonical_canonical_mantissa false _ _ H5).\napply Z.max_le_iff.\nnow right."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) : Prec_gt_0 prec.","conclusion":"Prec_gt_0 prec","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true)","proofString":"easy."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true) : (emin <= ex)%Z.","conclusion":"(emin <= ex)%Z","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (H1 : valid_binary (binary_round mode_ZR false 1 ex) = true) (H5 : canonical_mantissa mx ex = true) (H6 : (ex <=? emax - prec)%Z = true)","proofString":"rewrite (canonical_canonical_mantissa false _ _ H5).\napply Z.max_le_iff.\nnow right."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) : is_finite_strict (Bulp (B754_finite sx mx ex Bx)) =\nis_finite (B754_finite sx mx ex Bx).","conclusion":"is_finite_strict (Bulp (B754_finite sx mx ex Bx)) =\nis_finite (B754_finite sx mx ex Bx)","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"generalize (Bulp_correct (B754_finite sx mx ex Bx) eq_refl).\ndestruct Bulp as [sy| | |] ; try easy.\nintros [H _].\ncontradict H.\nrewrite ulp_neq_0.\napply Rlt_not_eq.\napply bpow_gt_0.\napply F2R_neq_0.\nnow destruct sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) : B2R (Bulp (B754_finite sx mx ex Bx)) =\nulp radix2 fexp (B2R (B754_finite sx mx ex Bx)) /\\\nis_finite (Bulp (B754_finite sx mx ex Bx)) = true /\\\nBsign (Bulp (B754_finite sx mx ex Bx)) = false ->\nis_finite_strict (Bulp (B754_finite sx mx ex Bx)) =\nis_finite (B754_finite sx mx ex Bx).","conclusion":"B2R (Bulp (B754_finite sx mx ex Bx)) =\nulp radix2 fexp (B2R (B754_finite sx mx ex Bx)) /\\\nis_finite (Bulp (B754_finite sx mx ex Bx)) = true /\\\nBsign (Bulp (B754_finite sx mx ex Bx)) = false ->\nis_finite_strict (Bulp (B754_finite sx mx ex Bx)) =\nis_finite (B754_finite sx mx ex Bx)","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"destruct Bulp as [sy| | |] ; try easy.\nintros [H _].\ncontradict H.\nrewrite ulp_neq_0.\napply Rlt_not_eq.\napply bpow_gt_0.\napply F2R_neq_0.\nnow destruct sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (sy : bool) : B2R (B754_zero sy) = ulp radix2 fexp (B2R (B754_finite sx mx ex Bx)) /\\\nis_finite (B754_zero sy) = true /\\ Bsign (B754_zero sy) = false ->\nis_finite_strict (B754_zero sy) = is_finite (B754_finite sx mx ex Bx).","conclusion":"B2R (B754_zero sy) = ulp radix2 fexp (B2R (B754_finite sx mx ex Bx)) /\\\nis_finite (B754_zero sy) = true /\\ Bsign (B754_zero sy) = false ->\nis_finite_strict (B754_zero sy) = is_finite (B754_finite sx mx ex Bx)","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (sy : bool)","proofString":"intros [H _].\ncontradict H.\nrewrite ulp_neq_0.\napply Rlt_not_eq.\napply bpow_gt_0.\napply F2R_neq_0.\nnow destruct sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (sy : bool) (H : B2R (B754_zero sy) = ulp radix2 fexp (B2R (B754_finite sx mx ex Bx))) : is_finite_strict (B754_zero sy) = is_finite (B754_finite sx mx ex Bx).","conclusion":"is_finite_strict (B754_zero sy) = is_finite (B754_finite sx mx ex Bx)","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (sy : bool) (H : B2R (B754_zero sy) = ulp radix2 fexp (B2R (B754_finite sx mx ex Bx)))","proofString":"contradict H.\nrewrite ulp_neq_0.\napply Rlt_not_eq.\napply bpow_gt_0.\napply F2R_neq_0.\nnow destruct sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (sy : bool) : B2R (B754_zero sy) <> ulp radix2 fexp (B2R (B754_finite sx mx ex Bx)).","conclusion":"B2R (B754_zero sy) <> ulp radix2 fexp (B2R (B754_finite sx mx ex Bx))","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (sy : bool)","proofString":"rewrite ulp_neq_0.\napply Rlt_not_eq.\napply bpow_gt_0.\napply F2R_neq_0.\nnow destruct sx."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (sy : bool) : B2R (B754_zero sy) <>\nbpow radix2 (cexp radix2 fexp (B2R (B754_finite sx mx ex Bx))).","conclusion":"B2R (B754_zero sy) <>\nbpow radix2 (cexp radix2 fexp (B2R (B754_finite sx mx ex Bx)))","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (sy : bool)","proofString":"apply Rlt_not_eq.\napply bpow_gt_0."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (sy : bool) : (B2R (B754_zero sy) <\n bpow radix2 (cexp radix2 fexp (B2R (B754_finite sx mx ex Bx))))%R.","conclusion":"(B2R (B754_zero sy) <\n bpow radix2 (cexp radix2 fexp (B2R (B754_finite sx mx ex Bx))))%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (sy : bool)","proofString":"apply bpow_gt_0."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (sy : bool) : B2R (B754_finite sx mx ex Bx) <> 0%R.","conclusion":"B2R (B754_finite sx mx ex Bx) <> 0%R","hypotheses":"(sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (sy : bool)","proofString":"apply F2R_neq_0.\nnow destruct sx."},{"statement":"(Hp : (2 < emax)%Z) (x : binary_float) (Fx : is_finite x = true) : Bulp' x = Bulp x.","conclusion":"Bulp' x = Bulp x","hypotheses":"(Hp : (2 < emax)%Z) (x : binary_float) (Fx : is_finite x = true)","proofString":"assert (B2R (Bulp' x) = ulp radix2 fexp (B2R x) /\\        is_finite (Bulp' x) = true /\\        Bsign (Bulp' x) = false) as [H1 [H2 H3]].\ndestruct x as [sx|sx| |sx mx ex Hx] ; unfold Bulp'.\nreplace (fexp _) with emin.\ngeneralize (Bldexp_correct mode_NE Bone emin).\nrewrite Bone_correct, Rmult_1_l, round_generic;      [|now apply valid_rnd_N|apply generic_format_bpow; unfold fexp, FLT_exp;        rewrite Z.max_r; unfold Prec_gt_0 in prec_gt_0_; lia].\nrewrite Rlt_bool_true.\nintros (Hr, (Hf, Hs)); rewrite Hr, Hf, Hs.\nsplit; [|now split; [apply is_finite_Bone|apply Bsign_Bone]].\nsimpl; unfold ulp; rewrite Req_bool_true; [|reflexivity].\ndestruct (negligible_exp_FLT emin prec) as (n, (Hn, Hn')).\nchange fexp with (FLT_exp emin prec); rewrite Hn.\nnow unfold FLT_exp; rewrite Z.max_r;        [|unfold Prec_gt_0 in prec_gt_0_; lia].\nrewrite Rabs_pos_eq; [|now apply bpow_ge_0]; apply bpow_lt.\napply emin_lt_emax.\nsimpl; change (fexp _) with (fexp (-2 * emax - prec)).\nunfold fexp, FLT_exp; rewrite Z.max_r; [reflexivity|].\nunfold emin; unfold Prec_gt_0 in prec_gt_0_; lia.\ndiscriminate.\ndiscriminate.\nunfold ulp, cexp.\nset (f := B754_finite _ _ _ _).\nrewrite Req_bool_false.\ndestruct (Bfrexp_correct f (eq_refl _)) as (Hfr1, (Hfr2, Hfr3)).\napply Hp.\nsimpl.\nrewrite Hfr3.\nset (e' := fexp _).\ngeneralize (Bldexp_correct mode_NE Bone e').\nrewrite Bone_correct, Rmult_1_l, round_generic; [|now apply valid_rnd_N|].\nrewrite Rlt_bool_true.\nintros (Hr, (Hf, Hs)); rewrite Hr, Hf, Hs.\nnow split; [|split; [apply is_finite_Bone|apply Bsign_Bone]].\nrewrite Rabs_pos_eq; [|now apply bpow_ge_0].\nunfold e', fexp, FLT_exp.\napply bpow_lt.\ncase (Z.max_spec (mag radix2 (B2R f) - prec) emin)          as [(_, Hm)|(_, Hm)]; rewrite Hm.\napply emin_lt_emax.\napply (Zplus_lt_reg_r _ _ prec); ring_simplify.\nassert (mag radix2 (B2R f) <= emax)%Z;          [|now unfold Prec_gt_0 in prec_gt_0_; lia].\napply mag_le_bpow; [|now apply abs_B2R_lt_emax].\nnow unfold f, B2R; apply F2R_neq_0; case sx.\napply generic_format_bpow, Z.max_lub.\nunfold Prec_gt_0 in prec_gt_0_; lia.\napply Z.le_max_r.\nnow unfold f, B2R; apply F2R_neq_0; case sx.\ndestruct (Bulp_correct x Fx) as [H4 [H5 H6]].\napply B2R_Bsign_inj ; try easy.\nnow rewrite H4.\nnow rewrite H3."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : (emin < emax)%Z.","conclusion":"(emin < emax)%Z","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"apply emin_lt_emax."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (f : binary_float) (Hfr1 : B2R f =\n(B2R\n   (SF2B (fst (Ffrexp_core_binary sx mx ex))\n      (proj1 (Bfrexp_correct_aux sx mx ex Hx))) *\n bpow radix2 (snd (Ffrexp_core_binary sx mx ex)))%R) : (2 < emax)%Z.","conclusion":"(2 < emax)%Z","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (f : binary_float) (Hfr1 : B2R f =\n(B2R\n   (SF2B (fst (Ffrexp_core_binary sx mx ex))\n      (proj1 (Bfrexp_correct_aux sx mx ex Hx))) *\n bpow radix2 (snd (Ffrexp_core_binary sx mx ex)))%R)","proofString":"apply Hp."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (f : binary_float) (Hfr1 : B2R f =\n(B2R\n   (SF2B (fst (Ffrexp_core_binary sx mx ex))\n      (proj1 (Bfrexp_correct_aux sx mx ex Hx))) *\n bpow radix2 (snd (Ffrexp_core_binary sx mx ex)))%R) (Hfr2 : (/ 2 <=\n Rabs\n   (B2R\n      (SF2B (fst (Ffrexp_core_binary sx mx ex))\n         (proj1 (Bfrexp_correct_aux sx mx ex Hx)))) < 1)%R) (Hfr3 : snd (Ffrexp_core_binary sx mx ex) = mag radix2 (B2R f)) (e' : Z) : B2R (Bldexp mode_NE Bone e') = bpow radix2 e' /\\\nis_finite (Bldexp mode_NE Bone e') = is_finite Bone /\\\nBsign (Bldexp mode_NE Bone e') = Bsign Bone ->\nB2R (Bldexp mode_NE Bone e') = bpow radix2 e' /\\\nis_finite (Bldexp mode_NE Bone e') = true /\\\nBsign (Bldexp mode_NE Bone e') = false.","conclusion":"B2R (Bldexp mode_NE Bone e') = bpow radix2 e' /\\\nis_finite (Bldexp mode_NE Bone e') = is_finite Bone /\\\nBsign (Bldexp mode_NE Bone e') = Bsign Bone ->\nB2R (Bldexp mode_NE Bone e') = bpow radix2 e' /\\\nis_finite (Bldexp mode_NE Bone e') = true /\\\nBsign (Bldexp mode_NE Bone e') = false","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (f : binary_float) (Hfr1 : B2R f =\n(B2R\n   (SF2B (fst (Ffrexp_core_binary sx mx ex))\n      (proj1 (Bfrexp_correct_aux sx mx ex Hx))) *\n bpow radix2 (snd (Ffrexp_core_binary sx mx ex)))%R) (Hfr2 : (/ 2 <=\n Rabs\n   (B2R\n      (SF2B (fst (Ffrexp_core_binary sx mx ex))\n         (proj1 (Bfrexp_correct_aux sx mx ex Hx)))) < 1)%R) (Hfr3 : snd (Ffrexp_core_binary sx mx ex) = mag radix2 (B2R f)) (e' : Z)","proofString":"intros (Hr, (Hf, Hs)); rewrite Hr, Hf, Hs.\nnow split; [|split; [apply is_finite_Bone|apply Bsign_Bone]]."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (f : binary_float) (Hfr1 : B2R f =\n(B2R\n   (SF2B (fst (Ffrexp_core_binary sx mx ex))\n      (proj1 (Bfrexp_correct_aux sx mx ex Hx))) *\n bpow radix2 (snd (Ffrexp_core_binary sx mx ex)))%R) (Hfr2 : (/ 2 <=\n Rabs\n   (B2R\n      (SF2B (fst (Ffrexp_core_binary sx mx ex))\n         (proj1 (Bfrexp_correct_aux sx mx ex Hx)))) < 1)%R) (Hfr3 : snd (Ffrexp_core_binary sx mx ex) = mag radix2 (B2R f)) (e' : Z) (Hr : B2R (Bldexp mode_NE Bone e') = bpow radix2 e') (Hf : is_finite (Bldexp mode_NE Bone e') = is_finite Bone) (Hs : Bsign (Bldexp mode_NE Bone e') = Bsign Bone) : bpow radix2 e' = bpow radix2 e' /\\\nis_finite Bone = true /\\ Bsign Bone = false.","conclusion":"bpow radix2 e' = bpow radix2 e' /\\\nis_finite Bone = true /\\ Bsign Bone = false","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (f : binary_float) (Hfr1 : B2R f =\n(B2R\n   (SF2B (fst (Ffrexp_core_binary sx mx ex))\n      (proj1 (Bfrexp_correct_aux sx mx ex Hx))) *\n bpow radix2 (snd (Ffrexp_core_binary sx mx ex)))%R) (Hfr2 : (/ 2 <=\n Rabs\n   (B2R\n      (SF2B (fst (Ffrexp_core_binary sx mx ex))\n         (proj1 (Bfrexp_correct_aux sx mx ex Hx)))) < 1)%R) (Hfr3 : snd (Ffrexp_core_binary sx mx ex) = mag radix2 (B2R f)) (e' : Z) (Hr : B2R (Bldexp mode_NE Bone e') = bpow radix2 e') (Hf : is_finite (Bldexp mode_NE Bone e') = is_finite Bone) (Hs : Bsign (Bldexp mode_NE Bone e') = Bsign Bone)","proofString":"now split; [|split; [apply is_finite_Bone|apply Bsign_Bone]]."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (f : binary_float) (Hfr1 : B2R f =\n(B2R\n   (SF2B (fst (Ffrexp_core_binary sx mx ex))\n      (proj1 (Bfrexp_correct_aux sx mx ex Hx))) *\n bpow radix2 (snd (Ffrexp_core_binary sx mx ex)))%R) (Hfr2 : (/ 2 <=\n Rabs\n   (B2R\n      (SF2B (fst (Ffrexp_core_binary sx mx ex))\n         (proj1 (Bfrexp_correct_aux sx mx ex Hx)))) < 1)%R) (Hfr3 : snd (Ffrexp_core_binary sx mx ex) = mag radix2 (B2R f)) (e' : Z) (Hm : Z.max (mag radix2 (B2R f) - prec) emin = emin) : (emin < emax)%Z.","conclusion":"(emin < emax)%Z","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (f : binary_float) (Hfr1 : B2R f =\n(B2R\n   (SF2B (fst (Ffrexp_core_binary sx mx ex))\n      (proj1 (Bfrexp_correct_aux sx mx ex Hx))) *\n bpow radix2 (snd (Ffrexp_core_binary sx mx ex)))%R) (Hfr2 : (/ 2 <=\n Rabs\n   (B2R\n      (SF2B (fst (Ffrexp_core_binary sx mx ex))\n         (proj1 (Bfrexp_correct_aux sx mx ex Hx)))) < 1)%R) (Hfr3 : snd (Ffrexp_core_binary sx mx ex) = mag radix2 (B2R f)) (e' : Z) (Hm : Z.max (mag radix2 (B2R f) - prec) emin = emin)","proofString":"apply emin_lt_emax."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (f : binary_float) (Hfr1 : B2R f =\n(B2R\n   (SF2B (fst (Ffrexp_core_binary sx mx ex))\n      (proj1 (Bfrexp_correct_aux sx mx ex Hx))) *\n bpow radix2 (snd (Ffrexp_core_binary sx mx ex)))%R) (Hfr2 : (/ 2 <=\n Rabs\n   (B2R\n      (SF2B (fst (Ffrexp_core_binary sx mx ex))\n         (proj1 (Bfrexp_correct_aux sx mx ex Hx)))) < 1)%R) (Hfr3 : snd (Ffrexp_core_binary sx mx ex) = mag radix2 (B2R f)) (e' : Z) : (e' + 1 - prec <= e')%Z.","conclusion":"(e' + 1 - prec <= e')%Z","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Hx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Hx) = true) (f : binary_float) (Hfr1 : B2R f =\n(B2R\n   (SF2B (fst (Ffrexp_core_binary sx mx ex))\n      (proj1 (Bfrexp_correct_aux sx mx ex Hx))) *\n bpow radix2 (snd (Ffrexp_core_binary sx mx ex)))%R) (Hfr2 : (/ 2 <=\n Rabs\n   (B2R\n      (SF2B (fst (Ffrexp_core_binary sx mx ex))\n         (proj1 (Bfrexp_correct_aux sx mx ex Hx)))) < 1)%R) (Hfr3 : snd (Ffrexp_core_binary sx mx ex) = mag radix2 (B2R f)) (e' : Z)","proofString":"unfold Prec_gt_0 in prec_gt_0_; lia."},{"statement":"(Hp : (2 < emax)%Z) (x : binary_float) (Fx : is_finite x = true) (H1 : B2R (Bulp' x) = ulp radix2 fexp (B2R x)) (H2 : is_finite (Bulp' x) = true) (H3 : Bsign (Bulp' x) = false) (H4 : B2R (Bulp x) = ulp radix2 fexp (B2R x)) (H5 : is_finite (Bulp x) = true) (H6 : Bsign (Bulp x) = false) : Bulp' x = Bulp x.","conclusion":"Bulp' x = Bulp x","hypotheses":"(Hp : (2 < emax)%Z) (x : binary_float) (Fx : is_finite x = true) (H1 : B2R (Bulp' x) = ulp radix2 fexp (B2R x)) (H2 : is_finite (Bulp' x) = true) (H3 : Bsign (Bulp' x) = false) (H4 : B2R (Bulp x) = ulp radix2 fexp (B2R x)) (H5 : is_finite (Bulp x) = true) (H6 : Bsign (Bulp x) = false)","proofString":"apply B2R_Bsign_inj ; try easy.\nnow rewrite H4.\nnow rewrite H3."},{"statement":"(Hp : (2 < emax)%Z) (x : binary_float) (Fx : is_finite x = true) (H1 : B2R (Bulp' x) = ulp radix2 fexp (B2R x)) (H2 : is_finite (Bulp' x) = true) (H3 : Bsign (Bulp' x) = false) (H4 : B2R (Bulp x) = ulp radix2 fexp (B2R x)) (H5 : is_finite (Bulp x) = true) (H6 : Bsign (Bulp x) = false) : B2R (Bulp' x) = B2R (Bulp x).","conclusion":"B2R (Bulp' x) = B2R (Bulp x)","hypotheses":"(Hp : (2 < emax)%Z) (x : binary_float) (Fx : is_finite x = true) (H1 : B2R (Bulp' x) = ulp radix2 fexp (B2R x)) (H2 : is_finite (Bulp' x) = true) (H3 : Bsign (Bulp' x) = false) (H4 : B2R (Bulp x) = ulp radix2 fexp (B2R x)) (H5 : is_finite (Bulp x) = true) (H6 : Bsign (Bulp x) = false)","proofString":"now rewrite H4."},{"statement":"(Hp : (2 < emax)%Z) (x : binary_float) (Fx : is_finite x = true) (H1 : B2R (Bulp' x) = ulp radix2 fexp (B2R x)) (H2 : is_finite (Bulp' x) = true) (H3 : Bsign (Bulp' x) = false) (H4 : B2R (Bulp x) = ulp radix2 fexp (B2R x)) (H5 : is_finite (Bulp x) = true) (H6 : Bsign (Bulp x) = false) : Bsign (Bulp' x) = Bsign (Bulp x).","conclusion":"Bsign (Bulp' x) = Bsign (Bulp x)","hypotheses":"(Hp : (2 < emax)%Z) (x : binary_float) (Fx : is_finite x = true) (H1 : B2R (Bulp' x) = ulp radix2 fexp (B2R x)) (H2 : is_finite (Bulp' x) = true) (H3 : Bsign (Bulp' x) = false) (H4 : B2R (Bulp x) = ulp radix2 fexp (B2R x)) (H5 : is_finite (Bulp x) = true) (H6 : Bsign (Bulp x) = false)","proofString":"now rewrite H3."},{"statement":"forall x : binary_float,\nis_nan\n  match x with\n  | B754_zero _ => B754_finite false 1 emin Bulp_correct_aux\n  | B754_infinity true => Bopp Bmax_float\n  | B754_infinity false => x\n  | B754_nan => B754_nan\n  | B754_finite true mx ex _ =>\n      SF2B (binary_round mode_ZR true (mx~0 - 1) (ex - 1))\n        (proj1 (binary_round_correct mode_ZR true (mx~0 - 1) (ex - 1)))\n  | B754_finite false mx ex _ =>\n      SF2B (binary_round mode_UP false (mx + 1) ex)\n        (proj1 (binary_round_correct mode_UP false (mx + 1) ex))\n  end = is_nan x.","conclusion":"forall x : binary_float,\nis_nan\n  match x with\n  | B754_zero _ => B754_finite false 1 emin Bulp_correct_aux\n  | B754_infinity true => Bopp Bmax_float\n  | B754_infinity false => x\n  | B754_nan => B754_nan\n  | B754_finite true mx ex _ =>\n      SF2B (binary_round mode_ZR true (mx~0 - 1) (ex - 1))\n        (proj1 (binary_round_correct mode_ZR true (mx~0 - 1) (ex - 1)))\n  | B754_finite false mx ex _ =>\n      SF2B (binary_round mode_UP false (mx + 1) ex)\n        (proj1 (binary_round_correct mode_UP false (mx + 1) ex))\n  end = is_nan x","hypotheses":"","proofString":"intros [sx|[|]| |[|] mx ex Bx] ; try easy.\nrewrite is_nan_SF2B.\napply is_nan_binary_round.\nrewrite is_nan_SF2B.\napply is_nan_binary_round."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) : is_nan\n  (SF2B (binary_round mode_ZR true (mx~0 - 1) (ex - 1))\n     (proj1 (binary_round_correct mode_ZR true (mx~0 - 1) (ex - 1)))) =\nis_nan (B754_finite true mx ex Bx).","conclusion":"is_nan\n  (SF2B (binary_round mode_ZR true (mx~0 - 1) (ex - 1))\n     (proj1 (binary_round_correct mode_ZR true (mx~0 - 1) (ex - 1)))) =\nis_nan (B754_finite true mx ex Bx)","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"rewrite is_nan_SF2B.\napply is_nan_binary_round."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) : is_nan_SF (binary_round mode_ZR true (mx~0 - 1) (ex - 1)) =\nis_nan (B754_finite true mx ex Bx).","conclusion":"is_nan_SF (binary_round mode_ZR true (mx~0 - 1) (ex - 1)) =\nis_nan (B754_finite true mx ex Bx)","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"apply is_nan_binary_round."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) : is_nan\n  (SF2B (binary_round mode_UP false (mx + 1) ex)\n     (proj1 (binary_round_correct mode_UP false (mx + 1) ex))) =\nis_nan (B754_finite false mx ex Bx).","conclusion":"is_nan\n  (SF2B (binary_round mode_UP false (mx + 1) ex)\n     (proj1 (binary_round_correct mode_UP false (mx + 1) ex))) =\nis_nan (B754_finite false mx ex Bx)","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"rewrite is_nan_SF2B.\napply is_nan_binary_round."},{"statement":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true) : is_nan_SF (binary_round mode_UP false (mx + 1) ex) =\nis_nan (B754_finite false mx ex Bx).","conclusion":"is_nan_SF (binary_round mode_UP false (mx + 1) ex) =\nis_nan (B754_finite false mx ex Bx)","hypotheses":"(mx : positive) (ex : Z) (Bx : bounded mx ex = true)","proofString":"apply is_nan_binary_round."},{"statement":"(x : binary_float) : is_nan (Bpred x) = is_nan x.","conclusion":"is_nan (Bpred x) = is_nan x","hypotheses":"(x : binary_float)","proofString":"unfold Bpred.\nrewrite is_nan_Bopp, is_nan_Bsucc.\napply is_nan_Bopp."},{"statement":"(x : binary_float) : is_nan (Bopp (Bsucc (Bopp x))) = is_nan x.","conclusion":"is_nan (Bopp (Bsucc (Bopp x))) = is_nan x","hypotheses":"(x : binary_float)","proofString":"rewrite is_nan_Bopp, is_nan_Bsucc.\napply is_nan_Bopp."},{"statement":"(x : binary_float) : is_nan (Bopp x) = is_nan x.","conclusion":"is_nan (Bopp x) = is_nan x","hypotheses":"(x : binary_float)","proofString":"apply is_nan_Bopp."},{"statement":"(x : binary_float) (Fx : is_finite x = true) : if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R x))\nthen\n B2R (Bpred x) = pred radix2 fexp (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2SF (Bpred x) = S754_infinity true.","conclusion":"if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R x))\nthen\n B2R (Bpred x) = pred radix2 fexp (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2SF (Bpred x) = S754_infinity true","hypotheses":"(x : binary_float) (Fx : is_finite x = true)","proofString":"assert (Fox : is_finite (Bopp x) = true).\nnow rewrite is_finite_Bopp.\nrewrite <-(Ropp_involutive (B2R x)), <-B2R_Bopp.\nrewrite pred_opp, Rlt_bool_opp.\ngeneralize (Bsucc_correct _ Fox).\ncase (Rlt_bool _ _).\nintros (HR, (HF, HS)); unfold Bpred.\nrewrite B2R_Bopp, HR, is_finite_Bopp.\nrewrite <-(Bool.negb_involutive (Bsign x)), <-Bool.negb_andb.\napply (conj eq_refl).\napply (conj HF).\nrewrite Bsign_Bopp, <-(Bsign_Bopp x), HS.\nnow rewrite is_finite_strict_Bopp.\nnow revert Fx; case x.\nnow revert HF; case (Bsucc _).\nnow unfold Bpred; case (Bsucc _); intro s; case s."},{"statement":"(x : binary_float) (Fx : is_finite x = true) : is_finite (Bopp x) = true.","conclusion":"is_finite (Bopp x) = true","hypotheses":"(x : binary_float) (Fx : is_finite x = true)","proofString":"now rewrite is_finite_Bopp."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) : if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R x))\nthen\n B2R (Bpred x) = pred radix2 fexp (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2SF (Bpred x) = S754_infinity true.","conclusion":"if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R x))\nthen\n B2R (Bpred x) = pred radix2 fexp (B2R x) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2SF (Bpred x) = S754_infinity true","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true)","proofString":"rewrite <-(Ropp_involutive (B2R x)), <-B2R_Bopp.\nrewrite pred_opp, Rlt_bool_opp.\ngeneralize (Bsucc_correct _ Fox).\ncase (Rlt_bool _ _).\nintros (HR, (HF, HS)); unfold Bpred.\nrewrite B2R_Bopp, HR, is_finite_Bopp.\nrewrite <-(Bool.negb_involutive (Bsign x)), <-Bool.negb_andb.\napply (conj eq_refl).\napply (conj HF).\nrewrite Bsign_Bopp, <-(Bsign_Bopp x), HS.\nnow rewrite is_finite_strict_Bopp.\nnow revert Fx; case x.\nnow revert HF; case (Bsucc _).\nnow unfold Bpred; case (Bsucc _); intro s; case s."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) : if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (- B2R (Bopp x)))\nthen\n B2R (Bpred x) = pred radix2 fexp (- B2R (Bopp x)) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2SF (Bpred x) = S754_infinity true.","conclusion":"if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (- B2R (Bopp x)))\nthen\n B2R (Bpred x) = pred radix2 fexp (- B2R (Bopp x)) /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2SF (Bpred x) = S754_infinity true","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true)","proofString":"rewrite pred_opp, Rlt_bool_opp.\ngeneralize (Bsucc_correct _ Fox).\ncase (Rlt_bool _ _).\nintros (HR, (HF, HS)); unfold Bpred.\nrewrite B2R_Bopp, HR, is_finite_Bopp.\nrewrite <-(Bool.negb_involutive (Bsign x)), <-Bool.negb_andb.\napply (conj eq_refl).\napply (conj HF).\nrewrite Bsign_Bopp, <-(Bsign_Bopp x), HS.\nnow rewrite is_finite_strict_Bopp.\nnow revert Fx; case x.\nnow revert HF; case (Bsucc _).\nnow unfold Bpred; case (Bsucc _); intro s; case s."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) : if Rlt_bool (succ radix2 fexp (B2R (Bopp x))) (bpow radix2 emax)\nthen\n B2R (Bpred x) = (- succ radix2 fexp (B2R (Bopp x)))%R /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2SF (Bpred x) = S754_infinity true.","conclusion":"if Rlt_bool (succ radix2 fexp (B2R (Bopp x))) (bpow radix2 emax)\nthen\n B2R (Bpred x) = (- succ radix2 fexp (B2R (Bopp x)))%R /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2SF (Bpred x) = S754_infinity true","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true)","proofString":"generalize (Bsucc_correct _ Fox).\ncase (Rlt_bool _ _).\nintros (HR, (HF, HS)); unfold Bpred.\nrewrite B2R_Bopp, HR, is_finite_Bopp.\nrewrite <-(Bool.negb_involutive (Bsign x)), <-Bool.negb_andb.\napply (conj eq_refl).\napply (conj HF).\nrewrite Bsign_Bopp, <-(Bsign_Bopp x), HS.\nnow rewrite is_finite_strict_Bopp.\nnow revert Fx; case x.\nnow revert HF; case (Bsucc _).\nnow unfold Bpred; case (Bsucc _); intro s; case s."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) : (if Rlt_bool (succ radix2 fexp (B2R (Bopp x))) (bpow radix2 emax)\n then\n  B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x)) /\\\n  is_finite (Bsucc (Bopp x)) = true /\\\n  Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool\n else B2SF (Bsucc (Bopp x)) = S754_infinity false) ->\nif Rlt_bool (succ radix2 fexp (B2R (Bopp x))) (bpow radix2 emax)\nthen\n B2R (Bpred x) = (- succ radix2 fexp (B2R (Bopp x)))%R /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2SF (Bpred x) = S754_infinity true.","conclusion":"(if Rlt_bool (succ radix2 fexp (B2R (Bopp x))) (bpow radix2 emax)\n then\n  B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x)) /\\\n  is_finite (Bsucc (Bopp x)) = true /\\\n  Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool\n else B2SF (Bsucc (Bopp x)) = S754_infinity false) ->\nif Rlt_bool (succ radix2 fexp (B2R (Bopp x))) (bpow radix2 emax)\nthen\n B2R (Bpred x) = (- succ radix2 fexp (B2R (Bopp x)))%R /\\\n is_finite (Bpred x) = true /\\\n Bsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool\nelse B2SF (Bpred x) = S754_infinity true","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true)","proofString":"case (Rlt_bool _ _).\nintros (HR, (HF, HS)); unfold Bpred.\nrewrite B2R_Bopp, HR, is_finite_Bopp.\nrewrite <-(Bool.negb_involutive (Bsign x)), <-Bool.negb_andb.\napply (conj eq_refl).\napply (conj HF).\nrewrite Bsign_Bopp, <-(Bsign_Bopp x), HS.\nnow rewrite is_finite_strict_Bopp.\nnow revert Fx; case x.\nnow revert HF; case (Bsucc _).\nnow unfold Bpred; case (Bsucc _); intro s; case s."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x)) /\\\nis_finite (Bsucc (Bopp x)) = true /\\\nBsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool ->\nB2R (Bpred x) = (- succ radix2 fexp (B2R (Bopp x)))%R /\\\nis_finite (Bpred x) = true /\\\nBsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool.","conclusion":"B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x)) /\\\nis_finite (Bsucc (Bopp x)) = true /\\\nBsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool ->\nB2R (Bpred x) = (- succ radix2 fexp (B2R (Bopp x)))%R /\\\nis_finite (Bpred x) = true /\\\nBsign (Bpred x) = (Bsign x || negb (is_finite_strict x))%bool","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true)","proofString":"intros (HR, (HF, HS)); unfold Bpred.\nrewrite B2R_Bopp, HR, is_finite_Bopp.\nrewrite <-(Bool.negb_involutive (Bsign x)), <-Bool.negb_andb.\napply (conj eq_refl).\napply (conj HF).\nrewrite Bsign_Bopp, <-(Bsign_Bopp x), HS.\nnow rewrite is_finite_strict_Bopp.\nnow revert Fx; case x.\nnow revert HF; case (Bsucc _)."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool) : B2R (Bopp (Bsucc (Bopp x))) = (- succ radix2 fexp (B2R (Bopp x)))%R /\\\nis_finite (Bopp (Bsucc (Bopp x))) = true /\\\nBsign (Bopp (Bsucc (Bopp x))) = (Bsign x || negb (is_finite_strict x))%bool.","conclusion":"B2R (Bopp (Bsucc (Bopp x))) = (- succ radix2 fexp (B2R (Bopp x)))%R /\\\nis_finite (Bopp (Bsucc (Bopp x))) = true /\\\nBsign (Bopp (Bsucc (Bopp x))) = (Bsign x || negb (is_finite_strict x))%bool","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool)","proofString":"rewrite B2R_Bopp, HR, is_finite_Bopp.\nrewrite <-(Bool.negb_involutive (Bsign x)), <-Bool.negb_andb.\napply (conj eq_refl).\napply (conj HF).\nrewrite Bsign_Bopp, <-(Bsign_Bopp x), HS.\nnow rewrite is_finite_strict_Bopp.\nnow revert Fx; case x.\nnow revert HF; case (Bsucc _)."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool) : (- succ radix2 fexp (B2R (Bopp x)))%R = (- succ radix2 fexp (B2R (Bopp x)))%R /\\\nis_finite (Bsucc (Bopp x)) = true /\\\nBsign (Bopp (Bsucc (Bopp x))) = (Bsign x || negb (is_finite_strict x))%bool.","conclusion":"(- succ radix2 fexp (B2R (Bopp x)))%R = (- succ radix2 fexp (B2R (Bopp x)))%R /\\\nis_finite (Bsucc (Bopp x)) = true /\\\nBsign (Bopp (Bsucc (Bopp x))) = (Bsign x || negb (is_finite_strict x))%bool","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool)","proofString":"rewrite <-(Bool.negb_involutive (Bsign x)), <-Bool.negb_andb.\napply (conj eq_refl).\napply (conj HF).\nrewrite Bsign_Bopp, <-(Bsign_Bopp x), HS.\nnow rewrite is_finite_strict_Bopp.\nnow revert Fx; case x.\nnow revert HF; case (Bsucc _)."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool) : (- succ radix2 fexp (B2R (Bopp x)))%R = (- succ radix2 fexp (B2R (Bopp x)))%R /\\\nis_finite (Bsucc (Bopp x)) = true /\\\nBsign (Bopp (Bsucc (Bopp x))) = negb (negb (Bsign x) && is_finite_strict x).","conclusion":"(- succ radix2 fexp (B2R (Bopp x)))%R = (- succ radix2 fexp (B2R (Bopp x)))%R /\\\nis_finite (Bsucc (Bopp x)) = true /\\\nBsign (Bopp (Bsucc (Bopp x))) = negb (negb (Bsign x) && is_finite_strict x)","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool)","proofString":"apply (conj eq_refl).\napply (conj HF).\nrewrite Bsign_Bopp, <-(Bsign_Bopp x), HS.\nnow rewrite is_finite_strict_Bopp.\nnow revert Fx; case x.\nnow revert HF; case (Bsucc _)."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool) : is_finite (Bsucc (Bopp x)) = true /\\\nBsign (Bopp (Bsucc (Bopp x))) = negb (negb (Bsign x) && is_finite_strict x).","conclusion":"is_finite (Bsucc (Bopp x)) = true /\\\nBsign (Bopp (Bsucc (Bopp x))) = negb (negb (Bsign x) && is_finite_strict x)","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool)","proofString":"apply (conj HF).\nrewrite Bsign_Bopp, <-(Bsign_Bopp x), HS.\nnow rewrite is_finite_strict_Bopp.\nnow revert Fx; case x.\nnow revert HF; case (Bsucc _)."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool) : Bsign (Bopp (Bsucc (Bopp x))) = negb (negb (Bsign x) && is_finite_strict x).","conclusion":"Bsign (Bopp (Bsucc (Bopp x))) = negb (negb (Bsign x) && is_finite_strict x)","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool)","proofString":"rewrite Bsign_Bopp, <-(Bsign_Bopp x), HS.\nnow rewrite is_finite_strict_Bopp.\nnow revert Fx; case x.\nnow revert HF; case (Bsucc _)."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool) : negb (Bsign (Bopp x) && is_finite_strict (Bopp x)) =\nnegb (Bsign (Bopp x) && is_finite_strict x).","conclusion":"negb (Bsign (Bopp x) && is_finite_strict (Bopp x)) =\nnegb (Bsign (Bopp x) && is_finite_strict x)","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool)","proofString":"now rewrite is_finite_strict_Bopp."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool) : is_nan x = false.","conclusion":"is_nan x = false","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool)","proofString":"now revert Fx; case x."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool) : is_nan (Bsucc (Bopp x)) = false.","conclusion":"is_nan (Bsucc (Bopp x)) = false","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) (HR : B2R (Bsucc (Bopp x)) = succ radix2 fexp (B2R (Bopp x))) (HF : is_finite (Bsucc (Bopp x)) = true) (HS : Bsign (Bsucc (Bopp x)) = (Bsign (Bopp x) && is_finite_strict (Bopp x))%bool)","proofString":"now revert HF; case (Bsucc _)."},{"statement":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true) : B2SF (Bsucc (Bopp x)) = S754_infinity false ->\nB2SF (Bpred x) = S754_infinity true.","conclusion":"B2SF (Bsucc (Bopp x)) = S754_infinity false ->\nB2SF (Bpred x) = S754_infinity true","hypotheses":"(x : binary_float) (Fx : is_finite x = true) (Fox : is_finite (Bopp x) = true)","proofString":"now unfold Bpred; case (Bsucc _); intro s; case s."},{"statement":"(Hp : (2 < emax)%Z) (x : binary_float) (Fx : is_finite x = true) : Bsucc' x = Bsucc x.","conclusion":"Bsucc' x = Bsucc x","hypotheses":"(Hp : (2 < emax)%Z) (x : binary_float) (Fx : is_finite x = true)","proofString":"destruct x as [sx|sx| |sx mx ex Bx] ; try easy.\ngeneralize (Bldexp_correct mode_NE Bone emin).\nrewrite Bone_correct, Rmult_1_l.\nrewrite round_generic.\nrewrite Rlt_bool_true.\nsimpl.\nintros [H1 [H2 H3]].\napply B2R_inj.\napply is_finite_strict_B2R.\nrewrite H1.\napply Rgt_not_eq.\napply bpow_gt_0.\neasy.\nrewrite H1.\napply eq_sym, F2R_bpow.\nrewrite Rabs_pos_eq by now apply bpow_ge_0.\napply bpow_lt, emin_lt_emax.\napply valid_rnd_N.\napply generic_format_bpow.\nunfold fexp.\nrewrite Z.max_r.\napply Z.le_refl.\ngeneralize (prec_gt_0 prec).\nlia.\nset (x := B754_finite sx mx ex Bx).\nassert (H:  if Rlt_bool (succ radix2 fexp (B2R x)) (bpow radix2 emax) then    B2R (Bsucc' x) = succ radix2 fexp (B2R x) /\\    is_finite (Bsucc' x) = true /\\    Bsign (Bsucc' x) = sx  else    B2SF (Bsucc' x) = S754_infinity false).\nassert (Hsucc : succ radix2 fexp 0 = bpow radix2 emin).\nrewrite succ_0.\nnow apply ulp_FLT_0.\nunfold Bsucc', x; destruct sx.\ncase Rlt_bool_spec; intro Hover.\nrewrite B2R_Bopp; simpl (Bopp (B754_finite _ _ _ _)).\nrewrite is_finite_Bopp.\nset (ox := B754_finite false mx ex Bx).\nassert (Hpred := Bpred_correct ox eq_refl).\nrewrite Bpred_pos'_correct ; cycle 1.\nexact Hp.\nnow apply F2R_gt_0.\nrewrite Rlt_bool_true in Hpred.\nrewrite (proj1 Hpred), (proj1 (proj2 Hpred)).\nsplit.\nrewrite <- succ_opp.\nsimpl.\nnow rewrite <- F2R_opp.\napply (conj eq_refl).\nrewrite Bsign_Bopp, (proj2 (proj2 Hpred)).\neasy.\ngeneralize (proj1 (proj2 Hpred)).\nnow case Bpred.\napply Rlt_le_trans with 0%R.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0.\napply pred_ge_0.\nnow apply FLT_exp_valid.\nnow apply F2R_gt_0.\napply generic_format_B2R.\nexfalso; revert Hover; apply Rlt_not_le.\napply (Rle_lt_trans _ (succ radix2 fexp 0)).\napply succ_le; [now apply FLT_exp_valid|apply generic_format_B2R|                        apply generic_format_0|].\nunfold B2R, F2R; simpl; change (Z.neg mx) with (- Z.pos mx)%Z.\nrewrite opp_IZR, <-Ropp_mult_distr_l, <-Ropp_0; apply Ropp_le_contravar.\nnow apply Rmult_le_pos; [apply IZR_le|apply bpow_ge_0].\nrewrite Hsucc; apply bpow_lt.\napply emin_lt_emax.\nfold x.\nassert (Hulp := Bulp_correct x (eq_refl _)).\nassert (Hplus := Bplus_correct mode_NE x (Bulp x) (eq_refl _)).\nrewrite (proj1 (proj2 Hulp)) in Hplus; specialize (Hplus (eq_refl _)).\nassert (Px : (0 <= B2R x)%R).\nnow apply F2R_ge_0.\nassert (Hsucc' : (succ radix2 fexp (B2R x)                      = B2R x + ulp radix2 fexp (B2R x))%R).\nnow unfold succ; rewrite (Rle_bool_true _ _ Px).\nrewrite (proj1 Hulp), <- Hsucc' in Hplus.\nrewrite round_generic in Hplus;      [|apply valid_rnd_N| now apply generic_format_succ;                           [apply FLT_exp_valid|apply generic_format_B2R]].\nrewrite Rabs_pos_eq in Hplus; [|apply (Rle_trans _ _ _ Px), succ_ge_id].\nrevert Hplus; case Rlt_bool_spec; intros Hover Hplus.\nsplit; [now simpl|split; [now simpl|]].\nrewrite (proj2 (proj2 Hplus)); case Rcompare_spec.\nintro H; exfalso; revert H.\napply Rle_not_lt, (Rle_trans _ _ _ Px), succ_ge_id.\nintro H; exfalso; revert H; apply Rgt_not_eq, Rlt_gt.\napply (Rlt_le_trans _ (B2R x)); [|apply succ_ge_id].\nnow apply Rmult_lt_0_compat; [apply IZR_lt|apply bpow_gt_0].\nnow simpl.\nnow rewrite (proj1 Hplus).\ngeneralize (Bsucc_correct x Fx).\nrevert H.\ncase Rlt_bool_spec ; intros H.\nintros [H1 [H2 H3]] [H4 [H5 H6]].\napply B2R_Bsign_inj ; try easy.\nnow rewrite H4.\nrewrite H3, H6.\nsimpl.\nnow case sx.\nintros H1 H2.\napply B2SF_inj.\nnow rewrite H1, H2."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : Bsucc' (B754_zero sx) = Bsucc (B754_zero sx).","conclusion":"Bsucc' (B754_zero sx) = Bsucc (B754_zero sx)","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"generalize (Bldexp_correct mode_NE Bone emin).\nrewrite Bone_correct, Rmult_1_l.\nrewrite round_generic.\nrewrite Rlt_bool_true.\nsimpl.\nintros [H1 [H2 H3]].\napply B2R_inj.\napply is_finite_strict_B2R.\nrewrite H1.\napply Rgt_not_eq.\napply bpow_gt_0.\neasy.\nrewrite H1.\napply eq_sym, F2R_bpow.\nrewrite Rabs_pos_eq by now apply bpow_ge_0.\napply bpow_lt, emin_lt_emax.\napply valid_rnd_N.\napply generic_format_bpow.\nunfold fexp.\nrewrite Z.max_r.\napply Z.le_refl.\ngeneralize (prec_gt_0 prec).\nlia."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : (if\n  Rlt_bool\n    (Rabs\n       (round radix2 fexp (round_mode mode_NE) (B2R Bone * bpow radix2 emin)))\n    (bpow radix2 emax)\n then\n  B2R (Bldexp mode_NE Bone emin) =\n  round radix2 fexp (round_mode mode_NE) (B2R Bone * bpow radix2 emin) /\\\n  is_finite (Bldexp mode_NE Bone emin) = is_finite Bone /\\\n  Bsign (Bldexp mode_NE Bone emin) = Bsign Bone\n else B2SF (Bldexp mode_NE Bone emin) = binary_overflow mode_NE (Bsign Bone)) ->\nBsucc' (B754_zero sx) = Bsucc (B754_zero sx).","conclusion":"(if\n  Rlt_bool\n    (Rabs\n       (round radix2 fexp (round_mode mode_NE) (B2R Bone * bpow radix2 emin)))\n    (bpow radix2 emax)\n then\n  B2R (Bldexp mode_NE Bone emin) =\n  round radix2 fexp (round_mode mode_NE) (B2R Bone * bpow radix2 emin) /\\\n  is_finite (Bldexp mode_NE Bone emin) = is_finite Bone /\\\n  Bsign (Bldexp mode_NE Bone emin) = Bsign Bone\n else B2SF (Bldexp mode_NE Bone emin) = binary_overflow mode_NE (Bsign Bone)) ->\nBsucc' (B754_zero sx) = Bsucc (B754_zero sx)","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"rewrite Bone_correct, Rmult_1_l.\nrewrite round_generic.\nrewrite Rlt_bool_true.\nsimpl.\nintros [H1 [H2 H3]].\napply B2R_inj.\napply is_finite_strict_B2R.\nrewrite H1.\napply Rgt_not_eq.\napply bpow_gt_0.\neasy.\nrewrite H1.\napply eq_sym, F2R_bpow.\nrewrite Rabs_pos_eq by now apply bpow_ge_0.\napply bpow_lt, emin_lt_emax.\napply valid_rnd_N.\napply generic_format_bpow.\nunfold fexp.\nrewrite Z.max_r.\napply Z.le_refl.\ngeneralize (prec_gt_0 prec).\nlia."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : (if\n  Rlt_bool (Rabs (round radix2 fexp (round_mode mode_NE) (bpow radix2 emin)))\n    (bpow radix2 emax)\n then\n  B2R (Bldexp mode_NE Bone emin) =\n  round radix2 fexp (round_mode mode_NE) (bpow radix2 emin) /\\\n  is_finite (Bldexp mode_NE Bone emin) = is_finite Bone /\\\n  Bsign (Bldexp mode_NE Bone emin) = Bsign Bone\n else B2SF (Bldexp mode_NE Bone emin) = binary_overflow mode_NE (Bsign Bone)) ->\nBsucc' (B754_zero sx) = Bsucc (B754_zero sx).","conclusion":"(if\n  Rlt_bool (Rabs (round radix2 fexp (round_mode mode_NE) (bpow radix2 emin)))\n    (bpow radix2 emax)\n then\n  B2R (Bldexp mode_NE Bone emin) =\n  round radix2 fexp (round_mode mode_NE) (bpow radix2 emin) /\\\n  is_finite (Bldexp mode_NE Bone emin) = is_finite Bone /\\\n  Bsign (Bldexp mode_NE Bone emin) = Bsign Bone\n else B2SF (Bldexp mode_NE Bone emin) = binary_overflow mode_NE (Bsign Bone)) ->\nBsucc' (B754_zero sx) = Bsucc (B754_zero sx)","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"rewrite round_generic.\nrewrite Rlt_bool_true.\nsimpl.\nintros [H1 [H2 H3]].\napply B2R_inj.\napply is_finite_strict_B2R.\nrewrite H1.\napply Rgt_not_eq.\napply bpow_gt_0.\neasy.\nrewrite H1.\napply eq_sym, F2R_bpow.\nrewrite Rabs_pos_eq by now apply bpow_ge_0.\napply bpow_lt, emin_lt_emax.\napply valid_rnd_N.\napply generic_format_bpow.\nunfold fexp.\nrewrite Z.max_r.\napply Z.le_refl.\ngeneralize (prec_gt_0 prec).\nlia."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : (if Rlt_bool (Rabs (bpow radix2 emin)) (bpow radix2 emax)\n then\n  B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin /\\\n  is_finite (Bldexp mode_NE Bone emin) = is_finite Bone /\\\n  Bsign (Bldexp mode_NE Bone emin) = Bsign Bone\n else B2SF (Bldexp mode_NE Bone emin) = binary_overflow mode_NE (Bsign Bone)) ->\nBsucc' (B754_zero sx) = Bsucc (B754_zero sx).","conclusion":"(if Rlt_bool (Rabs (bpow radix2 emin)) (bpow radix2 emax)\n then\n  B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin /\\\n  is_finite (Bldexp mode_NE Bone emin) = is_finite Bone /\\\n  Bsign (Bldexp mode_NE Bone emin) = Bsign Bone\n else B2SF (Bldexp mode_NE Bone emin) = binary_overflow mode_NE (Bsign Bone)) ->\nBsucc' (B754_zero sx) = Bsucc (B754_zero sx)","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"rewrite Rlt_bool_true.\nsimpl.\nintros [H1 [H2 H3]].\napply B2R_inj.\napply is_finite_strict_B2R.\nrewrite H1.\napply Rgt_not_eq.\napply bpow_gt_0.\neasy.\nrewrite H1.\napply eq_sym, F2R_bpow.\nrewrite Rabs_pos_eq by now apply bpow_ge_0.\napply bpow_lt, emin_lt_emax."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin /\\\nis_finite (Bldexp mode_NE Bone emin) = is_finite Bone /\\\nBsign (Bldexp mode_NE Bone emin) = Bsign Bone ->\nBsucc' (B754_zero sx) = Bsucc (B754_zero sx).","conclusion":"B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin /\\\nis_finite (Bldexp mode_NE Bone emin) = is_finite Bone /\\\nBsign (Bldexp mode_NE Bone emin) = Bsign Bone ->\nBsucc' (B754_zero sx) = Bsucc (B754_zero sx)","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"simpl.\nintros [H1 [H2 H3]].\napply B2R_inj.\napply is_finite_strict_B2R.\nrewrite H1.\napply Rgt_not_eq.\napply bpow_gt_0.\neasy.\nrewrite H1.\napply eq_sym, F2R_bpow."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin /\\\nis_finite (Bldexp mode_NE Bone emin) = is_finite Bone /\\\nBsign (Bldexp mode_NE Bone emin) = Bsign Bone ->\nBldexp mode_NE Bone emin = B754_finite false 1 emin Bulp_correct_aux.","conclusion":"B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin /\\\nis_finite (Bldexp mode_NE Bone emin) = is_finite Bone /\\\nBsign (Bldexp mode_NE Bone emin) = Bsign Bone ->\nBldexp mode_NE Bone emin = B754_finite false 1 emin Bulp_correct_aux","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"intros [H1 [H2 H3]].\napply B2R_inj.\napply is_finite_strict_B2R.\nrewrite H1.\napply Rgt_not_eq.\napply bpow_gt_0.\neasy.\nrewrite H1.\napply eq_sym, F2R_bpow."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone) : Bldexp mode_NE Bone emin = B754_finite false 1 emin Bulp_correct_aux.","conclusion":"Bldexp mode_NE Bone emin = B754_finite false 1 emin Bulp_correct_aux","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone)","proofString":"apply B2R_inj.\napply is_finite_strict_B2R.\nrewrite H1.\napply Rgt_not_eq.\napply bpow_gt_0.\neasy.\nrewrite H1.\napply eq_sym, F2R_bpow."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone) : is_finite_strict (Bldexp mode_NE Bone emin) = true.","conclusion":"is_finite_strict (Bldexp mode_NE Bone emin) = true","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone)","proofString":"apply is_finite_strict_B2R.\nrewrite H1.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone) : B2R (Bldexp mode_NE Bone emin) <> 0%R.","conclusion":"B2R (Bldexp mode_NE Bone emin) <> 0%R","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone)","proofString":"rewrite H1.\napply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone) : bpow radix2 emin <> 0%R.","conclusion":"bpow radix2 emin <> 0%R","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone)","proofString":"apply Rgt_not_eq.\napply bpow_gt_0."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone) : (bpow radix2 emin > 0)%R.","conclusion":"(bpow radix2 emin > 0)%R","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone)","proofString":"apply bpow_gt_0."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone) : is_finite_strict (B754_finite false 1 emin Bulp_correct_aux) = true.","conclusion":"is_finite_strict (B754_finite false 1 emin Bulp_correct_aux) = true","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone)","proofString":"easy."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone) : B2R (Bldexp mode_NE Bone emin) =\nB2R (B754_finite false 1 emin Bulp_correct_aux).","conclusion":"B2R (Bldexp mode_NE Bone emin) =\nB2R (B754_finite false 1 emin Bulp_correct_aux)","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone)","proofString":"rewrite H1.\napply eq_sym, F2R_bpow."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone) : bpow radix2 emin = B2R (B754_finite false 1 emin Bulp_correct_aux).","conclusion":"bpow radix2 emin = B2R (B754_finite false 1 emin Bulp_correct_aux)","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) (H1 : B2R (Bldexp mode_NE Bone emin) = bpow radix2 emin) (H2 : is_finite (Bldexp mode_NE Bone emin) = is_finite Bone) (H3 : Bsign (Bldexp mode_NE Bone emin) = Bsign Bone)","proofString":"apply eq_sym, F2R_bpow."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : (Rabs (bpow radix2 emin) < bpow radix2 emax)%R.","conclusion":"(Rabs (bpow radix2 emin) < bpow radix2 emax)%R","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"rewrite Rabs_pos_eq by now apply bpow_ge_0.\napply bpow_lt, emin_lt_emax."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : (bpow radix2 emin < bpow radix2 emax)%R.","conclusion":"(bpow radix2 emin < bpow radix2 emax)%R","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"apply bpow_lt, emin_lt_emax."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : Valid_rnd (round_mode mode_NE).","conclusion":"Valid_rnd (round_mode mode_NE)","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"apply valid_rnd_N."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : generic_format radix2 fexp (bpow radix2 emin).","conclusion":"generic_format radix2 fexp (bpow radix2 emin)","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"apply generic_format_bpow.\nunfold fexp.\nrewrite Z.max_r.\napply Z.le_refl.\ngeneralize (prec_gt_0 prec).\nlia."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : (fexp (emin + 1) <= emin)%Z.","conclusion":"(fexp (emin + 1) <= emin)%Z","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"unfold fexp.\nrewrite Z.max_r.\napply Z.le_refl.\ngeneralize (prec_gt_0 prec).\nlia."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : (Z.max (emin + 1 - prec) emin <= emin)%Z.","conclusion":"(Z.max (emin + 1 - prec) emin <= emin)%Z","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"rewrite Z.max_r.\napply Z.le_refl.\ngeneralize (prec_gt_0 prec).\nlia."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : (emin <= emin)%Z.","conclusion":"(emin <= emin)%Z","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"apply Z.le_refl."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : (emin + 1 - prec <= emin)%Z.","conclusion":"(emin + 1 - prec <= emin)%Z","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"generalize (prec_gt_0 prec).\nlia."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true) : (0 < prec)%Z -> (emin + 1 - prec <= emin)%Z.","conclusion":"(0 < prec)%Z -> (emin + 1 - prec <= emin)%Z","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (Fx : is_finite (B754_zero sx) = true)","proofString":"lia."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) : Bsucc' (B754_finite sx mx ex Bx) = Bsucc (B754_finite sx mx ex Bx).","conclusion":"Bsucc' (B754_finite sx mx ex Bx) = Bsucc (B754_finite sx mx ex Bx)","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true)","proofString":"set (x := B754_finite sx mx ex Bx).\nassert (H:  if Rlt_bool (succ radix2 fexp (B2R x)) (bpow radix2 emax) then    B2R (Bsucc' x) = succ radix2 fexp (B2R x) /\\    is_finite (Bsucc' x) = true /\\    Bsign (Bsucc' x) = sx  else    B2SF (Bsucc' x) = S754_infinity false).\nassert (Hsucc : succ radix2 fexp 0 = bpow radix2 emin).\nrewrite succ_0.\nnow apply ulp_FLT_0.\nunfold Bsucc', x; destruct sx.\ncase Rlt_bool_spec; intro Hover.\nrewrite B2R_Bopp; simpl (Bopp (B754_finite _ _ _ _)).\nrewrite is_finite_Bopp.\nset (ox := B754_finite false mx ex Bx).\nassert (Hpred := Bpred_correct ox eq_refl).\nrewrite Bpred_pos'_correct ; cycle 1.\nexact Hp.\nnow apply F2R_gt_0.\nrewrite Rlt_bool_true in Hpred.\nrewrite (proj1 Hpred), (proj1 (proj2 Hpred)).\nsplit.\nrewrite <- succ_opp.\nsimpl.\nnow rewrite <- F2R_opp.\napply (conj eq_refl).\nrewrite Bsign_Bopp, (proj2 (proj2 Hpred)).\neasy.\ngeneralize (proj1 (proj2 Hpred)).\nnow case Bpred.\napply Rlt_le_trans with 0%R.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0.\napply pred_ge_0.\nnow apply FLT_exp_valid.\nnow apply F2R_gt_0.\napply generic_format_B2R.\nexfalso; revert Hover; apply Rlt_not_le.\napply (Rle_lt_trans _ (succ radix2 fexp 0)).\napply succ_le; [now apply FLT_exp_valid|apply generic_format_B2R|                        apply generic_format_0|].\nunfold B2R, F2R; simpl; change (Z.neg mx) with (- Z.pos mx)%Z.\nrewrite opp_IZR, <-Ropp_mult_distr_l, <-Ropp_0; apply Ropp_le_contravar.\nnow apply Rmult_le_pos; [apply IZR_le|apply bpow_ge_0].\nrewrite Hsucc; apply bpow_lt.\napply emin_lt_emax.\nfold x.\nassert (Hulp := Bulp_correct x (eq_refl _)).\nassert (Hplus := Bplus_correct mode_NE x (Bulp x) (eq_refl _)).\nrewrite (proj1 (proj2 Hulp)) in Hplus; specialize (Hplus (eq_refl _)).\nassert (Px : (0 <= B2R x)%R).\nnow apply F2R_ge_0.\nassert (Hsucc' : (succ radix2 fexp (B2R x)                      = B2R x + ulp radix2 fexp (B2R x))%R).\nnow unfold succ; rewrite (Rle_bool_true _ _ Px).\nrewrite (proj1 Hulp), <- Hsucc' in Hplus.\nrewrite round_generic in Hplus;      [|apply valid_rnd_N| now apply generic_format_succ;                           [apply FLT_exp_valid|apply generic_format_B2R]].\nrewrite Rabs_pos_eq in Hplus; [|apply (Rle_trans _ _ _ Px), succ_ge_id].\nrevert Hplus; case Rlt_bool_spec; intros Hover Hplus.\nsplit; [now simpl|split; [now simpl|]].\nrewrite (proj2 (proj2 Hplus)); case Rcompare_spec.\nintro H; exfalso; revert H.\napply Rle_not_lt, (Rle_trans _ _ _ Px), succ_ge_id.\nintro H; exfalso; revert H; apply Rgt_not_eq, Rlt_gt.\napply (Rlt_le_trans _ (B2R x)); [|apply succ_ge_id].\nnow apply Rmult_lt_0_compat; [apply IZR_lt|apply bpow_gt_0].\nnow simpl.\nnow rewrite (proj1 Hplus).\ngeneralize (Bsucc_correct x Fx).\nrevert H.\ncase Rlt_bool_spec ; intros H.\nintros [H1 [H2 H3]] [H4 [H5 H6]].\napply B2R_Bsign_inj ; try easy.\nnow rewrite H4.\nrewrite H3, H6.\nsimpl.\nnow case sx.\nintros H1 H2.\napply B2SF_inj.\nnow rewrite H1, H2."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float) : succ radix2 fexp 0 = bpow radix2 emin.","conclusion":"succ radix2 fexp 0 = bpow radix2 emin","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float)","proofString":"rewrite succ_0.\nnow apply ulp_FLT_0."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float) : ulp radix2 fexp 0 = bpow radix2 emin.","conclusion":"ulp radix2 fexp 0 = bpow radix2 emin","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float)","proofString":"now apply ulp_FLT_0."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) : if\n Rlt_bool (succ radix2 fexp (B2R (B754_finite true mx ex Bx)))\n   (bpow radix2 emax)\nthen\n B2R (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) =\n succ radix2 fexp (B2R (B754_finite true mx ex Bx)) /\\\n is_finite (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) = true /\\\n Bsign (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) = true\nelse\n B2SF (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) =\n S754_infinity false.","conclusion":"if\n Rlt_bool (succ radix2 fexp (B2R (B754_finite true mx ex Bx)))\n   (bpow radix2 emax)\nthen\n B2R (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) =\n succ radix2 fexp (B2R (B754_finite true mx ex Bx)) /\\\n is_finite (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) = true /\\\n Bsign (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) = true\nelse\n B2SF (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) =\n S754_infinity false","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin)","proofString":"case Rlt_bool_spec; intro Hover.\nrewrite B2R_Bopp; simpl (Bopp (B754_finite _ _ _ _)).\nrewrite is_finite_Bopp.\nset (ox := B754_finite false mx ex Bx).\nassert (Hpred := Bpred_correct ox eq_refl).\nrewrite Bpred_pos'_correct ; cycle 1.\nexact Hp.\nnow apply F2R_gt_0.\nrewrite Rlt_bool_true in Hpred.\nrewrite (proj1 Hpred), (proj1 (proj2 Hpred)).\nsplit.\nrewrite <- succ_opp.\nsimpl.\nnow rewrite <- F2R_opp.\napply (conj eq_refl).\nrewrite Bsign_Bopp, (proj2 (proj2 Hpred)).\neasy.\ngeneralize (proj1 (proj2 Hpred)).\nnow case Bpred.\napply Rlt_le_trans with 0%R.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0.\napply pred_ge_0.\nnow apply FLT_exp_valid.\nnow apply F2R_gt_0.\napply generic_format_B2R.\nexfalso; revert Hover; apply Rlt_not_le.\napply (Rle_lt_trans _ (succ radix2 fexp 0)).\napply succ_le; [now apply FLT_exp_valid|apply generic_format_B2R|                        apply generic_format_0|].\nunfold B2R, F2R; simpl; change (Z.neg mx) with (- Z.pos mx)%Z.\nrewrite opp_IZR, <-Ropp_mult_distr_l, <-Ropp_0; apply Ropp_le_contravar.\nnow apply Rmult_le_pos; [apply IZR_le|apply bpow_ge_0].\nrewrite Hsucc; apply bpow_lt.\napply emin_lt_emax."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) : B2R (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) =\nsucc radix2 fexp (B2R (B754_finite true mx ex Bx)) /\\\nis_finite (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) = true /\\\nBsign (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) = true.","conclusion":"B2R (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) =\nsucc radix2 fexp (B2R (B754_finite true mx ex Bx)) /\\\nis_finite (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) = true /\\\nBsign (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) = true","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R)","proofString":"rewrite B2R_Bopp; simpl (Bopp (B754_finite _ _ _ _)).\nrewrite is_finite_Bopp.\nset (ox := B754_finite false mx ex Bx).\nassert (Hpred := Bpred_correct ox eq_refl).\nrewrite Bpred_pos'_correct ; cycle 1.\nexact Hp.\nnow apply F2R_gt_0.\nrewrite Rlt_bool_true in Hpred.\nrewrite (proj1 Hpred), (proj1 (proj2 Hpred)).\nsplit.\nrewrite <- succ_opp.\nsimpl.\nnow rewrite <- F2R_opp.\napply (conj eq_refl).\nrewrite Bsign_Bopp, (proj2 (proj2 Hpred)).\neasy.\ngeneralize (proj1 (proj2 Hpred)).\nnow case Bpred.\napply Rlt_le_trans with 0%R.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0.\napply pred_ge_0.\nnow apply FLT_exp_valid.\nnow apply F2R_gt_0.\napply generic_format_B2R."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) : (- B2R (Bpred_pos' (B754_finite false mx ex Bx)))%R =\nsucc radix2 fexp (B2R (B754_finite true mx ex Bx)) /\\\nis_finite (Bopp (Bpred_pos' (B754_finite false mx ex Bx))) = true /\\\nBsign (Bopp (Bpred_pos' (B754_finite false mx ex Bx))) = true.","conclusion":"(- B2R (Bpred_pos' (B754_finite false mx ex Bx)))%R =\nsucc radix2 fexp (B2R (B754_finite true mx ex Bx)) /\\\nis_finite (Bopp (Bpred_pos' (B754_finite false mx ex Bx))) = true /\\\nBsign (Bopp (Bpred_pos' (B754_finite false mx ex Bx))) = true","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R)","proofString":"rewrite is_finite_Bopp.\nset (ox := B754_finite false mx ex Bx).\nassert (Hpred := Bpred_correct ox eq_refl).\nrewrite Bpred_pos'_correct ; cycle 1.\nexact Hp.\nnow apply F2R_gt_0.\nrewrite Rlt_bool_true in Hpred.\nrewrite (proj1 Hpred), (proj1 (proj2 Hpred)).\nsplit.\nrewrite <- succ_opp.\nsimpl.\nnow rewrite <- F2R_opp.\napply (conj eq_refl).\nrewrite Bsign_Bopp, (proj2 (proj2 Hpred)).\neasy.\ngeneralize (proj1 (proj2 Hpred)).\nnow case Bpred.\napply Rlt_le_trans with 0%R.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0.\napply pred_ge_0.\nnow apply FLT_exp_valid.\nnow apply F2R_gt_0.\napply generic_format_B2R."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) : (- B2R (Bpred_pos' (B754_finite false mx ex Bx)))%R =\nsucc radix2 fexp (B2R (B754_finite true mx ex Bx)) /\\\nis_finite (Bpred_pos' (B754_finite false mx ex Bx)) = true /\\\nBsign (Bopp (Bpred_pos' (B754_finite false mx ex Bx))) = true.","conclusion":"(- B2R (Bpred_pos' (B754_finite false mx ex Bx)))%R =\nsucc radix2 fexp (B2R (B754_finite true mx ex Bx)) /\\\nis_finite (Bpred_pos' (B754_finite false mx ex Bx)) = true /\\\nBsign (Bopp (Bpred_pos' (B754_finite false mx ex Bx))) = true","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R)","proofString":"set (ox := B754_finite false mx ex Bx).\nassert (Hpred := Bpred_correct ox eq_refl).\nrewrite Bpred_pos'_correct ; cycle 1.\nexact Hp.\nnow apply F2R_gt_0.\nrewrite Rlt_bool_true in Hpred.\nrewrite (proj1 Hpred), (proj1 (proj2 Hpred)).\nsplit.\nrewrite <- succ_opp.\nsimpl.\nnow rewrite <- F2R_opp.\napply (conj eq_refl).\nrewrite Bsign_Bopp, (proj2 (proj2 Hpred)).\neasy.\ngeneralize (proj1 (proj2 Hpred)).\nnow case Bpred.\napply Rlt_le_trans with 0%R.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0.\napply pred_ge_0.\nnow apply FLT_exp_valid.\nnow apply F2R_gt_0.\napply generic_format_B2R."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R ox))\nthen\n B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\n is_finite (Bpred ox) = true /\\\n Bsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool\nelse B2SF (Bpred ox) = S754_infinity true) : (2 < emax)%Z.","conclusion":"(2 < emax)%Z","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R ox))\nthen\n B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\n is_finite (Bpred ox) = true /\\\n Bsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool\nelse B2SF (Bpred ox) = S754_infinity true)","proofString":"exact Hp."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\nis_finite (Bpred ox) = true /\\\nBsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool) : is_nan (Bpred ox) = false.","conclusion":"is_nan (Bpred ox) = false","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\nis_finite (Bpred ox) = true /\\\nBsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool)","proofString":"generalize (proj1 (proj2 Hpred)).\nnow case Bpred."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\nis_finite (Bpred ox) = true /\\\nBsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool) : is_finite (Bpred ox) = true -> is_nan (Bpred ox) = false.","conclusion":"is_finite (Bpred ox) = true -> is_nan (Bpred ox) = false","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\nis_finite (Bpred ox) = true /\\\nBsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool)","proofString":"now case Bpred."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R ox))\nthen\n B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\n is_finite (Bpred ox) = true /\\\n Bsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool\nelse B2SF (Bpred ox) = S754_infinity true) : (- bpow radix2 emax < 0)%R.","conclusion":"(- bpow radix2 emax < 0)%R","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R ox))\nthen\n B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\n is_finite (Bpred ox) = true /\\\n Bsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool\nelse B2SF (Bpred ox) = S754_infinity true)","proofString":"rewrite <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R ox))\nthen\n B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\n is_finite (Bpred ox) = true /\\\n Bsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool\nelse B2SF (Bpred ox) = S754_infinity true) : (- bpow radix2 emax < - 0)%R.","conclusion":"(- bpow radix2 emax < - 0)%R","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R ox))\nthen\n B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\n is_finite (Bpred ox) = true /\\\n Bsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool\nelse B2SF (Bpred ox) = S754_infinity true)","proofString":"apply Ropp_lt_contravar, bpow_gt_0."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R ox))\nthen\n B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\n is_finite (Bpred ox) = true /\\\n Bsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool\nelse B2SF (Bpred ox) = S754_infinity true) : Valid_exp fexp.","conclusion":"Valid_exp fexp","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R ox))\nthen\n B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\n is_finite (Bpred ox) = true /\\\n Bsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool\nelse B2SF (Bpred ox) = S754_infinity true)","proofString":"now apply FLT_exp_valid."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R ox))\nthen\n B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\n is_finite (Bpred ox) = true /\\\n Bsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool\nelse B2SF (Bpred ox) = S754_infinity true) : generic_format radix2 fexp (B2R ox).","conclusion":"generic_format radix2 fexp (B2R ox)","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R) (ox : binary_float) (Hpred : if Rlt_bool (- bpow radix2 emax) (pred radix2 fexp (B2R ox))\nthen\n B2R (Bpred ox) = pred radix2 fexp (B2R ox) /\\\n is_finite (Bpred ox) = true /\\\n Bsign (Bpred ox) = (Bsign ox || negb (is_finite_strict ox))%bool\nelse B2SF (Bpred ox) = S754_infinity true)","proofString":"apply generic_format_B2R."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (bpow radix2 emax <= succ radix2 fexp (B2R (B754_finite true mx ex Bx)))%R) : B2SF (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) =\nS754_infinity false.","conclusion":"B2SF (Bopp (Bpred_pos' (Bopp (B754_finite true mx ex Bx)))) =\nS754_infinity false","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hover : (bpow radix2 emax <= succ radix2 fexp (B2R (B754_finite true mx ex Bx)))%R)","proofString":"exfalso; revert Hover; apply Rlt_not_le.\napply (Rle_lt_trans _ (succ radix2 fexp 0)).\napply succ_le; [now apply FLT_exp_valid|apply generic_format_B2R|                        apply generic_format_0|].\nunfold B2R, F2R; simpl; change (Z.neg mx) with (- Z.pos mx)%Z.\nrewrite opp_IZR, <-Ropp_mult_distr_l, <-Ropp_0; apply Ropp_le_contravar.\nnow apply Rmult_le_pos; [apply IZR_le|apply bpow_ge_0].\nrewrite Hsucc; apply bpow_lt.\napply emin_lt_emax."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R.","conclusion":"(succ radix2 fexp (B2R (B754_finite true mx ex Bx)) < bpow radix2 emax)%R","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin)","proofString":"apply (Rle_lt_trans _ (succ radix2 fexp 0)).\napply succ_le; [now apply FLT_exp_valid|apply generic_format_B2R|                        apply generic_format_0|].\nunfold B2R, F2R; simpl; change (Z.neg mx) with (- Z.pos mx)%Z.\nrewrite opp_IZR, <-Ropp_mult_distr_l, <-Ropp_0; apply Ropp_le_contravar.\nnow apply Rmult_le_pos; [apply IZR_le|apply bpow_ge_0].\nrewrite Hsucc; apply bpow_lt.\napply emin_lt_emax."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) : (succ radix2 fexp (B2R (B754_finite true mx ex Bx)) <= succ radix2 fexp 0)%R.","conclusion":"(succ radix2 fexp (B2R (B754_finite true mx ex Bx)) <= succ radix2 fexp 0)%R","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin)","proofString":"apply succ_le; [now apply FLT_exp_valid|apply generic_format_B2R|                        apply generic_format_0|].\nunfold B2R, F2R; simpl; change (Z.neg mx) with (- Z.pos mx)%Z.\nrewrite opp_IZR, <-Ropp_mult_distr_l, <-Ropp_0; apply Ropp_le_contravar.\nnow apply Rmult_le_pos; [apply IZR_le|apply bpow_ge_0]."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) : (B2R (B754_finite true mx ex Bx) <= 0)%R.","conclusion":"(B2R (B754_finite true mx ex Bx) <= 0)%R","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin)","proofString":"unfold B2R, F2R; simpl; change (Z.neg mx) with (- Z.pos mx)%Z.\nrewrite opp_IZR, <-Ropp_mult_distr_l, <-Ropp_0; apply Ropp_le_contravar.\nnow apply Rmult_le_pos; [apply IZR_le|apply bpow_ge_0]."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) : (IZR (- Z.pos mx) * bpow radix2 ex <= 0)%R.","conclusion":"(IZR (- Z.pos mx) * bpow radix2 ex <= 0)%R","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin)","proofString":"rewrite opp_IZR, <-Ropp_mult_distr_l, <-Ropp_0; apply Ropp_le_contravar.\nnow apply Rmult_le_pos; [apply IZR_le|apply bpow_ge_0]."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) : (0 <= IZR (Z.pos mx) * bpow radix2 ex)%R.","conclusion":"(0 <= IZR (Z.pos mx) * bpow radix2 ex)%R","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin)","proofString":"now apply Rmult_le_pos; [apply IZR_le|apply bpow_ge_0]."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) : (succ radix2 fexp 0 < bpow radix2 emax)%R.","conclusion":"(succ radix2 fexp 0 < bpow radix2 emax)%R","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin)","proofString":"rewrite Hsucc; apply bpow_lt.\napply emin_lt_emax."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) : (emin < emax)%Z.","conclusion":"(emin < emax)%Z","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite true mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin)","proofString":"apply emin_lt_emax."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite false mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hulp : B2R (Bulp x) = ulp radix2 fexp (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false) (Hplus : if\n Rlt_bool\n   (Rabs (round radix2 fexp (round_mode mode_NE) (B2R x + B2R (Bulp x))))\n   (bpow radix2 emax)\nthen\n B2R (Bplus mode_NE x (Bulp x)) =\n round radix2 fexp (round_mode mode_NE) (B2R x + B2R (Bulp x)) /\\\n is_finite (Bplus mode_NE x (Bulp x)) = true /\\\n Bsign (Bplus mode_NE x (Bulp x)) =\n match Rcompare (B2R x + B2R (Bulp x)) 0 with\n | Eq => (Bsign x && Bsign (Bulp x))%bool\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus mode_NE x (Bulp x)) = binary_overflow mode_NE (Bsign x) /\\\n Bsign x = Bsign (Bulp x)) (Px : (0 <= B2R x)%R) : succ radix2 fexp (B2R x) = (B2R x + ulp radix2 fexp (B2R x))%R.","conclusion":"succ radix2 fexp (B2R x) = (B2R x + ulp radix2 fexp (B2R x))%R","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite false mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hulp : B2R (Bulp x) = ulp radix2 fexp (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false) (Hplus : if\n Rlt_bool\n   (Rabs (round radix2 fexp (round_mode mode_NE) (B2R x + B2R (Bulp x))))\n   (bpow radix2 emax)\nthen\n B2R (Bplus mode_NE x (Bulp x)) =\n round radix2 fexp (round_mode mode_NE) (B2R x + B2R (Bulp x)) /\\\n is_finite (Bplus mode_NE x (Bulp x)) = true /\\\n Bsign (Bplus mode_NE x (Bulp x)) =\n match Rcompare (B2R x + B2R (Bulp x)) 0 with\n | Eq => (Bsign x && Bsign (Bulp x))%bool\n | Lt => true\n | Gt => false\n end\nelse\n B2SF (Bplus mode_NE x (Bulp x)) = binary_overflow mode_NE (Bsign x) /\\\n Bsign x = Bsign (Bulp x)) (Px : (0 <= B2R x)%R)","proofString":"now unfold succ; rewrite (Rle_bool_true _ _ Px)."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite false mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hulp : B2R (Bulp x) = ulp radix2 fexp (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false) (Px : (0 <= B2R x)%R) (Hsucc' : succ radix2 fexp (B2R x) = (B2R x + ulp radix2 fexp (B2R x))%R) (Hover : (succ radix2 fexp (B2R x) < bpow radix2 emax)%R) (Hplus : B2R (Bplus mode_NE x (Bulp x)) = succ radix2 fexp (B2R x) /\\\nis_finite (Bplus mode_NE x (Bulp x)) = true /\\\nBsign (Bplus mode_NE x (Bulp x)) =\nmatch Rcompare (succ radix2 fexp (B2R x)) 0 with\n| Eq => (Bsign x && Bsign (Bulp x))%bool\n| Lt => true\n| Gt => false\nend) : (succ radix2 fexp (B2R x) < 0)%R -> true = false.","conclusion":"(succ radix2 fexp (B2R x) < 0)%R -> true = false","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite false mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hulp : B2R (Bulp x) = ulp radix2 fexp (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false) (Px : (0 <= B2R x)%R) (Hsucc' : succ radix2 fexp (B2R x) = (B2R x + ulp radix2 fexp (B2R x))%R) (Hover : (succ radix2 fexp (B2R x) < bpow radix2 emax)%R) (Hplus : B2R (Bplus mode_NE x (Bulp x)) = succ radix2 fexp (B2R x) /\\\nis_finite (Bplus mode_NE x (Bulp x)) = true /\\\nBsign (Bplus mode_NE x (Bulp x)) =\nmatch Rcompare (succ radix2 fexp (B2R x)) 0 with\n| Eq => (Bsign x && Bsign (Bulp x))%bool\n| Lt => true\n| Gt => false\nend)","proofString":"intro H; exfalso; revert H.\napply Rle_not_lt, (Rle_trans _ _ _ Px), succ_ge_id."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite false mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hulp : B2R (Bulp x) = ulp radix2 fexp (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false) (Px : (0 <= B2R x)%R) (Hsucc' : succ radix2 fexp (B2R x) = (B2R x + ulp radix2 fexp (B2R x))%R) (Hover : (succ radix2 fexp (B2R x) < bpow radix2 emax)%R) (Hplus : B2R (Bplus mode_NE x (Bulp x)) = succ radix2 fexp (B2R x) /\\\nis_finite (Bplus mode_NE x (Bulp x)) = true /\\\nBsign (Bplus mode_NE x (Bulp x)) =\nmatch Rcompare (succ radix2 fexp (B2R x)) 0 with\n| Eq => (Bsign x && Bsign (Bulp x))%bool\n| Lt => true\n| Gt => false\nend) : (succ radix2 fexp (B2R x) < 0)%R -> False.","conclusion":"(succ radix2 fexp (B2R x) < 0)%R -> False","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite false mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hulp : B2R (Bulp x) = ulp radix2 fexp (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false) (Px : (0 <= B2R x)%R) (Hsucc' : succ radix2 fexp (B2R x) = (B2R x + ulp radix2 fexp (B2R x))%R) (Hover : (succ radix2 fexp (B2R x) < bpow radix2 emax)%R) (Hplus : B2R (Bplus mode_NE x (Bulp x)) = succ radix2 fexp (B2R x) /\\\nis_finite (Bplus mode_NE x (Bulp x)) = true /\\\nBsign (Bplus mode_NE x (Bulp x)) =\nmatch Rcompare (succ radix2 fexp (B2R x)) 0 with\n| Eq => (Bsign x && Bsign (Bulp x))%bool\n| Lt => true\n| Gt => false\nend)","proofString":"apply Rle_not_lt, (Rle_trans _ _ _ Px), succ_ge_id."},{"statement":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite false mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hulp : B2R (Bulp x) = ulp radix2 fexp (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false) (Px : (0 <= B2R x)%R) (Hsucc' : succ radix2 fexp (B2R x) = (B2R x + ulp radix2 fexp (B2R x))%R) (Hover : (succ radix2 fexp (B2R x) < bpow radix2 emax)%R) (Hplus : B2R (Bplus mode_NE x (Bulp x)) = succ radix2 fexp (B2R x) /\\\nis_finite (Bplus mode_NE x (Bulp x)) = true /\\\nBsign (Bplus mode_NE x (Bulp x)) =\nmatch Rcompare (succ radix2 fexp (B2R x)) 0 with\n| Eq => (Bsign x && Bsign (Bulp x))%bool\n| Lt => true\n| Gt => false\nend) : (0 < succ radix2 fexp (B2R x))%R -> false = false.","conclusion":"(0 < succ radix2 fexp (B2R x))%R -> false = false","hypotheses":"(Hp : (2 < emax)%Z) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite false mx ex Bx) = true) (x : binary_float) (Hsucc : succ radix2 fexp 0 = bpow radix2 emin) (Hulp : B2R (Bulp x) = ulp radix2 fexp (B2R x) /\\\nis_finite (Bulp x) = true /\\ Bsign (Bulp x) = false) (Px : (0 <= B2R x)%R) (Hsucc' : succ radix2 fexp (B2R x) = (B2R x + ulp radix2 fexp (B2R x))%R) (Hover : (succ radix2 fexp (B2R x) < bpow radix2 emax)%R) (Hplus : B2R (Bplus mode_NE x (Bulp x)) = succ radix2 fexp (B2R x) /\\\nis_finite (Bplus mode_NE x (Bulp x)) = true /\\\nBsign (Bplus mode_NE x (Bulp x)) =\nmatch Rcompare (succ radix2 fexp (B2R x)) 0 with\n| Eq => (Bsign x && Bsign (Bulp x))%bool\n| Lt => true\n| Gt => false\nend)","proofString":"now simpl."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float) (H : (succ radix2 fexp (B2R x) < bpow radix2 emax)%R) (H1 : B2R (Bsucc' x) = succ radix2 fexp (B2R x)) (H2 : is_finite (Bsucc' x) = true) (H3 : Bsign (Bsucc' x) = sx) (H4 : B2R (Bsucc x) = succ radix2 fexp (B2R x)) (H5 : is_finite (Bsucc x) = true) (H6 : Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool) : B2R (Bsucc' x) = B2R (Bsucc x).","conclusion":"B2R (Bsucc' x) = B2R (Bsucc x)","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float) (H : (succ radix2 fexp (B2R x) < bpow radix2 emax)%R) (H1 : B2R (Bsucc' x) = succ radix2 fexp (B2R x)) (H2 : is_finite (Bsucc' x) = true) (H3 : Bsign (Bsucc' x) = sx) (H4 : B2R (Bsucc x) = succ radix2 fexp (B2R x)) (H5 : is_finite (Bsucc x) = true) (H6 : Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool)","proofString":"now rewrite H4."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float) (H : (succ radix2 fexp (B2R x) < bpow radix2 emax)%R) (H1 : B2R (Bsucc' x) = succ radix2 fexp (B2R x)) (H2 : is_finite (Bsucc' x) = true) (H3 : Bsign (Bsucc' x) = sx) (H4 : B2R (Bsucc x) = succ radix2 fexp (B2R x)) (H5 : is_finite (Bsucc x) = true) (H6 : Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool) : sx = (sx && true)%bool.","conclusion":"sx = (sx && true)%bool","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float) (H : (succ radix2 fexp (B2R x) < bpow radix2 emax)%R) (H1 : B2R (Bsucc' x) = succ radix2 fexp (B2R x)) (H2 : is_finite (Bsucc' x) = true) (H3 : Bsign (Bsucc' x) = sx) (H4 : B2R (Bsucc x) = succ radix2 fexp (B2R x)) (H5 : is_finite (Bsucc x) = true) (H6 : Bsign (Bsucc x) = (Bsign x && is_finite_strict x)%bool)","proofString":"now case sx."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float) (H : (bpow radix2 emax <= succ radix2 fexp (B2R x))%R) : B2SF (Bsucc' x) = S754_infinity false ->\nB2SF (Bsucc x) = S754_infinity false -> Bsucc' x = Bsucc x.","conclusion":"B2SF (Bsucc' x) = S754_infinity false ->\nB2SF (Bsucc x) = S754_infinity false -> Bsucc' x = Bsucc x","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float) (H : (bpow radix2 emax <= succ radix2 fexp (B2R x))%R)","proofString":"intros H1 H2.\napply B2SF_inj.\nnow rewrite H1, H2."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float) (H : (bpow radix2 emax <= succ radix2 fexp (B2R x))%R) (H1 : B2SF (Bsucc' x) = S754_infinity false) (H2 : B2SF (Bsucc x) = S754_infinity false) : Bsucc' x = Bsucc x.","conclusion":"Bsucc' x = Bsucc x","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float) (H : (bpow radix2 emax <= succ radix2 fexp (B2R x))%R) (H1 : B2SF (Bsucc' x) = S754_infinity false) (H2 : B2SF (Bsucc x) = S754_infinity false)","proofString":"apply B2SF_inj.\nnow rewrite H1, H2."},{"statement":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float) (H : (bpow radix2 emax <= succ radix2 fexp (B2R x))%R) (H1 : B2SF (Bsucc' x) = S754_infinity false) (H2 : B2SF (Bsucc x) = S754_infinity false) : B2SF (Bsucc' x) = B2SF (Bsucc x).","conclusion":"B2SF (Bsucc' x) = B2SF (Bsucc x)","hypotheses":"(Hp : (2 < emax)%Z) (sx : bool) (mx : positive) (ex : Z) (Bx : bounded mx ex = true) (Fx : is_finite (B754_finite sx mx ex Bx) = true) (x : binary_float) (H : (bpow radix2 emax <= succ radix2 fexp (B2R x))%R) (H1 : B2SF (Bsucc' x) = S754_infinity false) (H2 : B2SF (Bsucc x) = S754_infinity false)","proofString":"now rewrite H1, H2."}]}