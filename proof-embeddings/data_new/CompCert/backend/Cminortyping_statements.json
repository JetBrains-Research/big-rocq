{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Cminortyping.v","fileSamples":[{"statement":"(te : S.typassign) (e : S.typenv) (t1 t2 : typ) (e' : S.typenv) (H : (if typ_eq t1 t2 then OK e else Error (msg \"type mismatch\")) = OK e') (H0 : S.satisf te e') : S.satisf te e.","conclusion":"S.satisf te e","hypotheses":"(te : S.typassign) (e : S.typenv) (t1 t2 : typ) (e' : S.typenv) (H : (if typ_eq t1 t2 then OK e else Error (msg \"type mismatch\")) = OK e') (H0 : S.satisf te e')","proofString":"destruct (typ_eq t1 t2); inv H; auto."},{"statement":"(e : S.typenv) (t1 t2 : typ) (e' : S.typenv) (H : (if typ_eq t1 t2 then OK e else Error (msg \"type mismatch\")) = OK e') : t1 = t2.","conclusion":"t1 = t2","hypotheses":"(e : S.typenv) (t1 t2 : typ) (e' : S.typenv) (H : (if typ_eq t1 t2 then OK e else Error (msg \"type mismatch\")) = OK e')","proofString":"destruct (typ_eq t1 t2); inv H; auto."},{"statement":"(te : S.typassign) (u : unary_operation) (a : expr) (IHa : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a t0 = OK e'0 -> S.satisf te e'0 -> S.satisf te e0) (t : typ) (e e' : S.typenv) (T : (let\n '(targ1, tres) := type_unop u in\n  do e1 <- type_expr e a targ1; expect e1 tres t) = \nOK e') (SAT : S.satisf te e') : S.satisf te e.","conclusion":"S.satisf te e","hypotheses":"(te : S.typassign) (u : unary_operation) (a : expr) (IHa : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a t0 = OK e'0 -> S.satisf te e'0 -> S.satisf te e0) (t : typ) (e e' : S.typenv) (T : (let\n '(targ1, tres) := type_unop u in\n  do e1 <- type_expr e a targ1; expect e1 tres t) = \nOK e') (SAT : S.satisf te e')","proofString":"destruct (type_unop u) as [targ1 tres]; monadInv T; eauto with ty."},{"statement":"(te : S.typassign) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a1 t0 = OK e'0 -> S.satisf te e'0 -> S.satisf te e0) (IHa2 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a2 t0 = OK e'0 -> S.satisf te e'0 -> S.satisf te e0) (t : typ) (e e' : S.typenv) (T : (let\n '(targ1, targ2, tres) := type_binop b in\n  do e1 <- type_expr e a1 targ1;\n  do e2 <- type_expr e1 a2 targ2; expect e2 tres t) = \nOK e') (SAT : S.satisf te e') : S.satisf te e.","conclusion":"S.satisf te e","hypotheses":"(te : S.typassign) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a1 t0 = OK e'0 -> S.satisf te e'0 -> S.satisf te e0) (IHa2 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a2 t0 = OK e'0 -> S.satisf te e'0 -> S.satisf te e0) (t : typ) (e e' : S.typenv) (T : (let\n '(targ1, targ2, tres) := type_binop b in\n  do e1 <- type_expr e a1 targ1;\n  do e2 <- type_expr e1 a2 targ2; expect e2 tres t) = \nOK e') (SAT : S.satisf te e')","proofString":"destruct (type_binop b) as [[targ1 targ2] tres]; monadInv T; eauto with ty."},{"statement":"(te : S.typassign) (i : ident) (t : typ) (e e' : S.typenv) (T : S.set e i t = OK e') (SAT : S.satisf te e') : wt_expr te (Evar i) t.","conclusion":"wt_expr te (Evar i) t","hypotheses":"(te : S.typassign) (i : ident) (t : typ) (e e' : S.typenv) (T : S.set e i t = OK e') (SAT : S.satisf te e')","proofString":"erewrite <- S.set_sound by eauto.\nconstructor."},{"statement":"(te : S.typassign) (i : ident) (t : typ) (e e' : S.typenv) (T : S.set e i t = OK e') (SAT : S.satisf te e') : wt_expr te (Evar i) (te i).","conclusion":"wt_expr te (Evar i) (te i)","hypotheses":"(te : S.typassign) (i : ident) (t : typ) (e e' : S.typenv) (T : S.set e i t = OK e') (SAT : S.satisf te e')","proofString":"constructor."},{"statement":"(te : S.typassign) (c : constant) (t : typ) (e e' : S.typenv) (T : expect e (type_constant c) t = OK e') (SAT : S.satisf te e') : wt_expr te (Econst c) t.","conclusion":"wt_expr te (Econst c) t","hypotheses":"(te : S.typassign) (c : constant) (t : typ) (e e' : S.typenv) (T : expect e (type_constant c) t = OK e') (SAT : S.satisf te e')","proofString":"erewrite <- expect_sound by eauto.\nconstructor."},{"statement":"(te : S.typassign) (c : constant) (t : typ) (e e' : S.typenv) (T : expect e (type_constant c) t = OK e') (SAT : S.satisf te e') : wt_expr te (Econst c) (type_constant c).","conclusion":"wt_expr te (Econst c) (type_constant c)","hypotheses":"(te : S.typassign) (c : constant) (t : typ) (e e' : S.typenv) (T : expect e (type_constant c) t = OK e') (SAT : S.satisf te e')","proofString":"constructor."},{"statement":"(te : S.typassign) (u : unary_operation) (a : expr) (IHa : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a t0) (t : typ) (e e' : S.typenv) (T : (let\n '(targ1, tres) := type_unop u in\n  do e1 <- type_expr e a targ1; expect e1 tres t) = \nOK e') (SAT : S.satisf te e') : wt_expr te (Eunop u a) t.","conclusion":"wt_expr te (Eunop u a) t","hypotheses":"(te : S.typassign) (u : unary_operation) (a : expr) (IHa : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a t0) (t : typ) (e e' : S.typenv) (T : (let\n '(targ1, tres) := type_unop u in\n  do e1 <- type_expr e a targ1; expect e1 tres t) = \nOK e') (SAT : S.satisf te e')","proofString":"destruct (type_unop u) as [targ1 tres] eqn:TU; monadInv T.\nerewrite <- expect_sound by eauto.\neconstructor; eauto with ty."},{"statement":"(te : S.typassign) (u : unary_operation) (a : expr) (IHa : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a t0) (t : typ) (e e' : S.typenv) (targ1 tres : typ) (TU : type_unop u = (targ1, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a targ1 = OK x) (EQ0 : expect x tres t = OK e') : wt_expr te (Eunop u a) t.","conclusion":"wt_expr te (Eunop u a) t","hypotheses":"(te : S.typassign) (u : unary_operation) (a : expr) (IHa : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a t0) (t : typ) (e e' : S.typenv) (targ1 tres : typ) (TU : type_unop u = (targ1, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a targ1 = OK x) (EQ0 : expect x tres t = OK e')","proofString":"erewrite <- expect_sound by eauto.\neconstructor; eauto with ty."},{"statement":"(te : S.typassign) (u : unary_operation) (a : expr) (IHa : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a t0) (t : typ) (e e' : S.typenv) (targ1 tres : typ) (TU : type_unop u = (targ1, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a targ1 = OK x) (EQ0 : expect x tres t = OK e') : wt_expr te (Eunop u a) tres.","conclusion":"wt_expr te (Eunop u a) tres","hypotheses":"(te : S.typassign) (u : unary_operation) (a : expr) (IHa : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a t0) (t : typ) (e e' : S.typenv) (targ1 tres : typ) (TU : type_unop u = (targ1, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a targ1 = OK x) (EQ0 : expect x tres t = OK e')","proofString":"econstructor; eauto with ty."},{"statement":"(te : S.typassign) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a1 t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a1 t0) (IHa2 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a2 t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a2 t0) (t : typ) (e e' : S.typenv) (T : (let\n '(targ1, targ2, tres) := type_binop b in\n  do e1 <- type_expr e a1 targ1;\n  do e2 <- type_expr e1 a2 targ2; expect e2 tres t) = \nOK e') (SAT : S.satisf te e') : wt_expr te (Ebinop b a1 a2) t.","conclusion":"wt_expr te (Ebinop b a1 a2) t","hypotheses":"(te : S.typassign) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a1 t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a1 t0) (IHa2 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a2 t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a2 t0) (t : typ) (e e' : S.typenv) (T : (let\n '(targ1, targ2, tres) := type_binop b in\n  do e1 <- type_expr e a1 targ1;\n  do e2 <- type_expr e1 a2 targ2; expect e2 tres t) = \nOK e') (SAT : S.satisf te e')","proofString":"destruct (type_binop b) as [[targ1 targ2] tres] eqn:TB; monadInv T.\nerewrite <- expect_sound by eauto.\neconstructor; eauto with ty."},{"statement":"(te : S.typassign) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a1 t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a1 t0) (IHa2 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a2 t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a2 t0) (t : typ) (e e' : S.typenv) (targ1 targ2 tres : typ) (TB : type_binop b = (targ1, targ2, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a1 targ1 = OK x) (x0 : S.typenv) (EQ1 : type_expr x a2 targ2 = OK x0) (EQ2 : expect x0 tres t = OK e') : wt_expr te (Ebinop b a1 a2) t.","conclusion":"wt_expr te (Ebinop b a1 a2) t","hypotheses":"(te : S.typassign) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a1 t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a1 t0) (IHa2 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a2 t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a2 t0) (t : typ) (e e' : S.typenv) (targ1 targ2 tres : typ) (TB : type_binop b = (targ1, targ2, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a1 targ1 = OK x) (x0 : S.typenv) (EQ1 : type_expr x a2 targ2 = OK x0) (EQ2 : expect x0 tres t = OK e')","proofString":"erewrite <- expect_sound by eauto.\neconstructor; eauto with ty."},{"statement":"(te : S.typassign) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a1 t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a1 t0) (IHa2 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a2 t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a2 t0) (t : typ) (e e' : S.typenv) (targ1 targ2 tres : typ) (TB : type_binop b = (targ1, targ2, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a1 targ1 = OK x) (x0 : S.typenv) (EQ1 : type_expr x a2 targ2 = OK x0) (EQ2 : expect x0 tres t = OK e') : wt_expr te (Ebinop b a1 a2) tres.","conclusion":"wt_expr te (Ebinop b a1 a2) tres","hypotheses":"(te : S.typassign) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a1 t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a1 t0) (IHa2 : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a2 t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a2 t0) (t : typ) (e e' : S.typenv) (targ1 targ2 tres : typ) (TB : type_binop b = (targ1, targ2, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a1 targ1 = OK x) (x0 : S.typenv) (EQ1 : type_expr x a2 targ2 = OK x0) (EQ2 : expect x0 tres t = OK e')","proofString":"econstructor; eauto with ty."},{"statement":"(te : S.typassign) (m : memory_chunk) (a : expr) (IHa : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a t0) (t : typ) (e e' : S.typenv) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a Tptr = OK x) (EQ0 : expect x (type_of_chunk m) t = OK e') : wt_expr te (Eload m a) t.","conclusion":"wt_expr te (Eload m a) t","hypotheses":"(te : S.typassign) (m : memory_chunk) (a : expr) (IHa : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a t0) (t : typ) (e e' : S.typenv) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a Tptr = OK x) (EQ0 : expect x (type_of_chunk m) t = OK e')","proofString":"erewrite <- expect_sound by eauto.\neconstructor; eauto with ty."},{"statement":"(te : S.typassign) (m : memory_chunk) (a : expr) (IHa : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a t0) (t : typ) (e e' : S.typenv) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a Tptr = OK x) (EQ0 : expect x (type_of_chunk m) t = OK e') : wt_expr te (Eload m a) (type_of_chunk m).","conclusion":"wt_expr te (Eload m a) (type_of_chunk m)","hypotheses":"(te : S.typassign) (m : memory_chunk) (a : expr) (IHa : forall (t0 : typ) (e0 e'0 : S.typenv),\ntype_expr e0 a t0 = OK e'0 -> S.satisf te e'0 -> wt_expr te a t0) (t : typ) (e e' : S.typenv) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a Tptr = OK x) (EQ0 : expect x (type_of_chunk m) t = OK e')","proofString":"econstructor; eauto with ty."},{"statement":"(te : S.typassign) (e' : S.typenv) (SAT : S.satisf te e') : list_forall2 (wt_expr te) nil nil.","conclusion":"list_forall2 (wt_expr te) nil nil","hypotheses":"(te : S.typassign) (e' : S.typenv) (SAT : S.satisf te e')","proofString":"constructor."},{"statement":"(te : S.typassign) (a : expr) (al : list expr) (IHal : forall (tl0 : list typ) (e0 e'0 : S.typenv),\ntype_exprlist e0 al tl0 = OK e'0 ->\nS.satisf te e'0 -> list_forall2 (wt_expr te) al tl0) (t : typ) (tl : list typ) (e e' : S.typenv) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a t = OK x) (EQ0 : type_exprlist x al tl = OK e') : list_forall2 (wt_expr te) (a :: al) (t :: tl).","conclusion":"list_forall2 (wt_expr te) (a :: al) (t :: tl)","hypotheses":"(te : S.typassign) (a : expr) (al : list expr) (IHal : forall (tl0 : list typ) (e0 e'0 : S.typenv),\ntype_exprlist e0 al tl0 = OK e'0 ->\nS.satisf te e'0 -> list_forall2 (wt_expr te) al tl0) (t : typ) (tl : list typ) (e e' : S.typenv) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a t = OK x) (EQ0 : type_exprlist x al tl = OK e')","proofString":"constructor; eauto using type_expr_sound with ty."},{"statement":"(te : S.typassign) (id : ident) (u : unary_operation) (a : expr) (IHa : forall e0 e'0 : S.typenv,\ntype_assign e0 id a = OK e'0 -> S.satisf te e'0 -> S.satisf te e0) (e e' : S.typenv) (T : (let\n '(targ1, tres) := type_unop u in\n  do e1 <- type_expr e a targ1; S.set e1 id tres) = \nOK e') (SAT : S.satisf te e') : S.satisf te e.","conclusion":"S.satisf te e","hypotheses":"(te : S.typassign) (id : ident) (u : unary_operation) (a : expr) (IHa : forall e0 e'0 : S.typenv,\ntype_assign e0 id a = OK e'0 -> S.satisf te e'0 -> S.satisf te e0) (e e' : S.typenv) (T : (let\n '(targ1, tres) := type_unop u in\n  do e1 <- type_expr e a targ1; S.set e1 id tres) = \nOK e') (SAT : S.satisf te e')","proofString":"destruct (type_unop u) as [targ1 tres]; monadInv T; eauto with ty."},{"statement":"(te : S.typassign) (id : ident) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a1 = OK e'0 -> S.satisf te e'0 -> S.satisf te e0) (IHa2 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a2 = OK e'0 -> S.satisf te e'0 -> S.satisf te e0) (e e' : S.typenv) (T : (let\n '(targ1, targ2, tres) := type_binop b in\n  do e1 <- type_expr e a1 targ1;\n  do e2 <- type_expr e1 a2 targ2; S.set e2 id tres) = \nOK e') (SAT : S.satisf te e') : S.satisf te e.","conclusion":"S.satisf te e","hypotheses":"(te : S.typassign) (id : ident) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a1 = OK e'0 -> S.satisf te e'0 -> S.satisf te e0) (IHa2 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a2 = OK e'0 -> S.satisf te e'0 -> S.satisf te e0) (e e' : S.typenv) (T : (let\n '(targ1, targ2, tres) := type_binop b in\n  do e1 <- type_expr e a1 targ1;\n  do e2 <- type_expr e1 a2 targ2; S.set e2 id tres) = \nOK e') (SAT : S.satisf te e')","proofString":"destruct (type_binop b) as [[targ1 targ2] tres]; monadInv T; eauto with ty."},{"statement":"(te : S.typassign) (id i : ident) (e e' : S.typenv) (SAT : S.satisf te e') (x : bool) (EQ : S.move e id i = OK (x, e')) : wt_expr te (Evar i) (te id).","conclusion":"wt_expr te (Evar i) (te id)","hypotheses":"(te : S.typassign) (id i : ident) (e e' : S.typenv) (SAT : S.satisf te e') (x : bool) (EQ : S.move e id i = OK (x, e'))","proofString":"erewrite S.move_sound by eauto.\nconstructor."},{"statement":"(te : S.typassign) (id i : ident) (e e' : S.typenv) (SAT : S.satisf te e') (x : bool) (EQ : S.move e id i = OK (x, e')) : wt_expr te (Evar i) (te i).","conclusion":"wt_expr te (Evar i) (te i)","hypotheses":"(te : S.typassign) (id i : ident) (e e' : S.typenv) (SAT : S.satisf te e') (x : bool) (EQ : S.move e id i = OK (x, e'))","proofString":"constructor."},{"statement":"(te : S.typassign) (id : ident) (c : constant) (e e' : S.typenv) (T : S.set e id (type_constant c) = OK e') (SAT : S.satisf te e') : wt_expr te (Econst c) (te id).","conclusion":"wt_expr te (Econst c) (te id)","hypotheses":"(te : S.typassign) (id : ident) (c : constant) (e e' : S.typenv) (T : S.set e id (type_constant c) = OK e') (SAT : S.satisf te e')","proofString":"erewrite S.set_sound by eauto.\nconstructor."},{"statement":"(te : S.typassign) (id : ident) (c : constant) (e e' : S.typenv) (T : S.set e id (type_constant c) = OK e') (SAT : S.satisf te e') : wt_expr te (Econst c) (type_constant c).","conclusion":"wt_expr te (Econst c) (type_constant c)","hypotheses":"(te : S.typassign) (id : ident) (c : constant) (e e' : S.typenv) (T : S.set e id (type_constant c) = OK e') (SAT : S.satisf te e')","proofString":"constructor."},{"statement":"(te : S.typassign) (id : ident) (u : unary_operation) (a : expr) (IHa : forall e0 e'0 : S.typenv,\ntype_assign e0 id a = OK e'0 -> S.satisf te e'0 -> wt_expr te a (te id)) (e e' : S.typenv) (T : (let\n '(targ1, tres) := type_unop u in\n  do e1 <- type_expr e a targ1; S.set e1 id tres) = \nOK e') (SAT : S.satisf te e') : wt_expr te (Eunop u a) (te id).","conclusion":"wt_expr te (Eunop u a) (te id)","hypotheses":"(te : S.typassign) (id : ident) (u : unary_operation) (a : expr) (IHa : forall e0 e'0 : S.typenv,\ntype_assign e0 id a = OK e'0 -> S.satisf te e'0 -> wt_expr te a (te id)) (e e' : S.typenv) (T : (let\n '(targ1, tres) := type_unop u in\n  do e1 <- type_expr e a targ1; S.set e1 id tres) = \nOK e') (SAT : S.satisf te e')","proofString":"destruct (type_unop u) as [targ1 tres] eqn:TU; monadInv T.\nerewrite S.set_sound by eauto.\neconstructor; eauto using type_expr_sound with ty."},{"statement":"(te : S.typassign) (id : ident) (u : unary_operation) (a : expr) (IHa : forall e0 e'0 : S.typenv,\ntype_assign e0 id a = OK e'0 -> S.satisf te e'0 -> wt_expr te a (te id)) (e e' : S.typenv) (targ1 tres : typ) (TU : type_unop u = (targ1, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a targ1 = OK x) (EQ0 : S.set x id tres = OK e') : wt_expr te (Eunop u a) (te id).","conclusion":"wt_expr te (Eunop u a) (te id)","hypotheses":"(te : S.typassign) (id : ident) (u : unary_operation) (a : expr) (IHa : forall e0 e'0 : S.typenv,\ntype_assign e0 id a = OK e'0 -> S.satisf te e'0 -> wt_expr te a (te id)) (e e' : S.typenv) (targ1 tres : typ) (TU : type_unop u = (targ1, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a targ1 = OK x) (EQ0 : S.set x id tres = OK e')","proofString":"erewrite S.set_sound by eauto.\neconstructor; eauto using type_expr_sound with ty."},{"statement":"(te : S.typassign) (id : ident) (u : unary_operation) (a : expr) (IHa : forall e0 e'0 : S.typenv,\ntype_assign e0 id a = OK e'0 -> S.satisf te e'0 -> wt_expr te a (te id)) (e e' : S.typenv) (targ1 tres : typ) (TU : type_unop u = (targ1, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a targ1 = OK x) (EQ0 : S.set x id tres = OK e') : wt_expr te (Eunop u a) tres.","conclusion":"wt_expr te (Eunop u a) tres","hypotheses":"(te : S.typassign) (id : ident) (u : unary_operation) (a : expr) (IHa : forall e0 e'0 : S.typenv,\ntype_assign e0 id a = OK e'0 -> S.satisf te e'0 -> wt_expr te a (te id)) (e e' : S.typenv) (targ1 tres : typ) (TU : type_unop u = (targ1, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a targ1 = OK x) (EQ0 : S.set x id tres = OK e')","proofString":"econstructor; eauto using type_expr_sound with ty."},{"statement":"(te : S.typassign) (id : ident) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a1 = OK e'0 -> S.satisf te e'0 -> wt_expr te a1 (te id)) (IHa2 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a2 = OK e'0 -> S.satisf te e'0 -> wt_expr te a2 (te id)) (e e' : S.typenv) (T : (let\n '(targ1, targ2, tres) := type_binop b in\n  do e1 <- type_expr e a1 targ1;\n  do e2 <- type_expr e1 a2 targ2; S.set e2 id tres) = \nOK e') (SAT : S.satisf te e') : wt_expr te (Ebinop b a1 a2) (te id).","conclusion":"wt_expr te (Ebinop b a1 a2) (te id)","hypotheses":"(te : S.typassign) (id : ident) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a1 = OK e'0 -> S.satisf te e'0 -> wt_expr te a1 (te id)) (IHa2 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a2 = OK e'0 -> S.satisf te e'0 -> wt_expr te a2 (te id)) (e e' : S.typenv) (T : (let\n '(targ1, targ2, tres) := type_binop b in\n  do e1 <- type_expr e a1 targ1;\n  do e2 <- type_expr e1 a2 targ2; S.set e2 id tres) = \nOK e') (SAT : S.satisf te e')","proofString":"destruct (type_binop b) as [[targ1 targ2] tres] eqn:TB; monadInv T.\nerewrite S.set_sound by eauto.\neconstructor; eauto using type_expr_sound with ty."},{"statement":"(te : S.typassign) (id : ident) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a1 = OK e'0 -> S.satisf te e'0 -> wt_expr te a1 (te id)) (IHa2 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a2 = OK e'0 -> S.satisf te e'0 -> wt_expr te a2 (te id)) (e e' : S.typenv) (targ1 targ2 tres : typ) (TB : type_binop b = (targ1, targ2, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a1 targ1 = OK x) (x0 : S.typenv) (EQ1 : type_expr x a2 targ2 = OK x0) (EQ2 : S.set x0 id tres = OK e') : wt_expr te (Ebinop b a1 a2) (te id).","conclusion":"wt_expr te (Ebinop b a1 a2) (te id)","hypotheses":"(te : S.typassign) (id : ident) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a1 = OK e'0 -> S.satisf te e'0 -> wt_expr te a1 (te id)) (IHa2 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a2 = OK e'0 -> S.satisf te e'0 -> wt_expr te a2 (te id)) (e e' : S.typenv) (targ1 targ2 tres : typ) (TB : type_binop b = (targ1, targ2, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a1 targ1 = OK x) (x0 : S.typenv) (EQ1 : type_expr x a2 targ2 = OK x0) (EQ2 : S.set x0 id tres = OK e')","proofString":"erewrite S.set_sound by eauto.\neconstructor; eauto using type_expr_sound with ty."},{"statement":"(te : S.typassign) (id : ident) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a1 = OK e'0 -> S.satisf te e'0 -> wt_expr te a1 (te id)) (IHa2 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a2 = OK e'0 -> S.satisf te e'0 -> wt_expr te a2 (te id)) (e e' : S.typenv) (targ1 targ2 tres : typ) (TB : type_binop b = (targ1, targ2, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a1 targ1 = OK x) (x0 : S.typenv) (EQ1 : type_expr x a2 targ2 = OK x0) (EQ2 : S.set x0 id tres = OK e') : wt_expr te (Ebinop b a1 a2) tres.","conclusion":"wt_expr te (Ebinop b a1 a2) tres","hypotheses":"(te : S.typassign) (id : ident) (b : binary_operation) (a1 a2 : expr) (IHa1 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a1 = OK e'0 -> S.satisf te e'0 -> wt_expr te a1 (te id)) (IHa2 : forall e0 e'0 : S.typenv,\ntype_assign e0 id a2 = OK e'0 -> S.satisf te e'0 -> wt_expr te a2 (te id)) (e e' : S.typenv) (targ1 targ2 tres : typ) (TB : type_binop b = (targ1, targ2, tres)) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a1 targ1 = OK x) (x0 : S.typenv) (EQ1 : type_expr x a2 targ2 = OK x0) (EQ2 : S.set x0 id tres = OK e')","proofString":"econstructor; eauto using type_expr_sound with ty."},{"statement":"(te : S.typassign) (id : ident) (m : memory_chunk) (a : expr) (IHa : forall e0 e'0 : S.typenv,\ntype_assign e0 id a = OK e'0 -> S.satisf te e'0 -> wt_expr te a (te id)) (e e' : S.typenv) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a Tptr = OK x) (EQ0 : S.set x id (type_of_chunk m) = OK e') : wt_expr te (Eload m a) (te id).","conclusion":"wt_expr te (Eload m a) (te id)","hypotheses":"(te : S.typassign) (id : ident) (m : memory_chunk) (a : expr) (IHa : forall e0 e'0 : S.typenv,\ntype_assign e0 id a = OK e'0 -> S.satisf te e'0 -> wt_expr te a (te id)) (e e' : S.typenv) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a Tptr = OK x) (EQ0 : S.set x id (type_of_chunk m) = OK e')","proofString":"erewrite S.set_sound by eauto.\neconstructor; eauto using type_expr_sound with ty."},{"statement":"(te : S.typassign) (id : ident) (m : memory_chunk) (a : expr) (IHa : forall e0 e'0 : S.typenv,\ntype_assign e0 id a = OK e'0 -> S.satisf te e'0 -> wt_expr te a (te id)) (e e' : S.typenv) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a Tptr = OK x) (EQ0 : S.set x id (type_of_chunk m) = OK e') : wt_expr te (Eload m a) (type_of_chunk m).","conclusion":"wt_expr te (Eload m a) (type_of_chunk m)","hypotheses":"(te : S.typassign) (id : ident) (m : memory_chunk) (a : expr) (IHa : forall e0 e'0 : S.typenv,\ntype_assign e0 id a = OK e'0 -> S.satisf te e'0 -> wt_expr te a (te id)) (e e' : S.typenv) (SAT : S.satisf te e') (x : S.typenv) (EQ : type_expr e a Tptr = OK x) (EQ0 : S.set x id (type_of_chunk m) = OK e')","proofString":"econstructor; eauto using type_expr_sound with ty."},{"statement":"(te : S.typassign) (optid : option ident) (optty : typ) (e e' : S.typenv) (H : match optid with\n| Some id => S.set e id optty\n| None => OK e\nend = OK e') (H0 : S.satisf te e') : S.satisf te e.","conclusion":"S.satisf te e","hypotheses":"(te : S.typassign) (optid : option ident) (optty : typ) (e e' : S.typenv) (H : match optid with\n| Some id => S.set e id optty\n| None => OK e\nend = OK e') (H0 : S.satisf te e')","proofString":"destruct optid, optty; try (monadInv H); eauto with ty."},{"statement":"(te : S.typassign) (optid : option ident) (sg : signature) (e e' : S.typenv) (H : match optid with\n| Some id => S.set e id (proj_sig_res sg)\n| None => OK e\nend = OK e') (H0 : S.satisf te e') : match optid with\n| Some id => proj_xtype (sig_res sg) = te id\n| None => True\nend.","conclusion":"match optid with\n| Some id => proj_xtype (sig_res sg) = te id\n| None => True\nend","hypotheses":"(te : S.typassign) (optid : option ident) (sg : signature) (e e' : S.typenv) (H : match optid with\n| Some id => S.set e id (proj_sig_res sg)\n| None => OK e\nend = OK e') (H0 : S.satisf te e')","proofString":"destruct optid.\nerewrite S.set_sound by eauto.\nauto.\ninv H.\nauto."},{"statement":"(te : S.typassign) (i : ident) (sg : signature) (e e' : S.typenv) (H : S.set e i (proj_sig_res sg) = OK e') (H0 : S.satisf te e') : proj_xtype (sig_res sg) = te i.","conclusion":"proj_xtype (sig_res sg) = te i","hypotheses":"(te : S.typassign) (i : ident) (sg : signature) (e e' : S.typenv) (H : S.set e i (proj_sig_res sg) = OK e') (H0 : S.satisf te e')","proofString":"erewrite S.set_sound by eauto.\nauto."},{"statement":"(te : S.typassign) (i : ident) (sg : signature) (e e' : S.typenv) (H : S.set e i (proj_sig_res sg) = OK e') (H0 : S.satisf te e') : proj_xtype (sig_res sg) = proj_sig_res sg.","conclusion":"proj_xtype (sig_res sg) = proj_sig_res sg","hypotheses":"(te : S.typassign) (i : ident) (sg : signature) (e e' : S.typenv) (H : S.set e i (proj_sig_res sg) = OK e') (H0 : S.satisf te e')","proofString":"auto."},{"statement":"(te : S.typassign) (sg : signature) (e e' : S.typenv) (H : OK e = OK e') (H0 : S.satisf te e') : True.","conclusion":"True","hypotheses":"(te : S.typassign) (sg : signature) (e e' : S.typenv) (H : OK e = OK e') (H0 : S.satisf te e')","proofString":"inv H.\nauto."},{"statement":"(te : S.typassign) (sg : signature) (e' : S.typenv) (H0 : S.satisf te e') : True.","conclusion":"True","hypotheses":"(te : S.typassign) (sg : signature) (e' : S.typenv) (H0 : S.satisf te e')","proofString":"auto."},{"statement":"(te : S.typassign) (tret : xtype) (o : option expr) (e1 e2 : S.typenv) (T : match o with\n| Some a => type_expr e1 a (proj_xtype tret)\n| None => OK e1\nend = OK e2) (SAT : S.satisf te e2) : S.satisf te e1.","conclusion":"S.satisf te e1","hypotheses":"(te : S.typassign) (tret : xtype) (o : option expr) (e1 e2 : S.typenv) (T : match o with\n| Some a => type_expr e1 a (proj_xtype tret)\n| None => OK e1\nend = OK e2) (SAT : S.satisf te e2)","proofString":"destruct tret, o; try (monadInv T); eauto with ty."},{"statement":"(te : S.typassign) (tret : xtype) (e2 : S.typenv) (SAT : S.satisf te e2) : wt_stmt te tret Sskip.","conclusion":"wt_stmt te tret Sskip","hypotheses":"(te : S.typassign) (tret : xtype) (e2 : S.typenv) (SAT : S.satisf te e2)","proofString":"constructor."},{"statement":"(te : S.typassign) (tret : xtype) (i : ident) (e : expr) (e1 e2 : S.typenv) (T : type_assign e1 i e = OK e2) (SAT : S.satisf te e2) : wt_stmt te tret (Sassign i e).","conclusion":"wt_stmt te tret (Sassign i e)","hypotheses":"(te : S.typassign) (tret : xtype) (i : ident) (e : expr) (e1 e2 : S.typenv) (T : type_assign e1 i e = OK e2) (SAT : S.satisf te e2)","proofString":"constructor; eauto using type_assign_sound."},{"statement":"(te : S.typassign) (tret : xtype) (m : memory_chunk) (e e0 : expr) (e1 e2 : S.typenv) (SAT : S.satisf te e2) (x : S.typenv) (EQ : type_expr e1 e Tptr = OK x) (EQ0 : type_expr x e0 (type_of_chunk m) = OK e2) : wt_stmt te tret (Sstore m e e0).","conclusion":"wt_stmt te tret (Sstore m e e0)","hypotheses":"(te : S.typassign) (tret : xtype) (m : memory_chunk) (e e0 : expr) (e1 e2 : S.typenv) (SAT : S.satisf te e2) (x : S.typenv) (EQ : type_expr e1 e Tptr = OK x) (EQ0 : type_expr x e0 (type_of_chunk m) = OK e2)","proofString":"constructor; eauto using type_expr_sound with ty."},{"statement":"(te : S.typassign) (tret : xtype) (o : option ident) (s : signature) (e : expr) (l : list expr) (e1 e2 : S.typenv) (SAT : S.satisf te e2) (x : S.typenv) (EQ : type_expr e1 e Tptr = OK x) (x0 : S.typenv) (EQ1 : type_exprlist x l (proj_sig_args s) = OK x0) (EQ2 : opt_set x0 o (proj_sig_res s) = OK e2) : wt_stmt te tret (Scall o s e l).","conclusion":"wt_stmt te tret (Scall o s e l)","hypotheses":"(te : S.typassign) (tret : xtype) (o : option ident) (s : signature) (e : expr) (l : list expr) (e1 e2 : S.typenv) (SAT : S.satisf te e2) (x : S.typenv) (EQ : type_expr e1 e Tptr = OK x) (x0 : S.typenv) (EQ1 : type_exprlist x l (proj_sig_args s) = OK x0) (EQ2 : opt_set x0 o (proj_sig_res s) = OK e2)","proofString":"constructor; eauto using type_expr_sound, type_exprlist_sound, opt_set_sound with ty."},{"statement":"(te : S.typassign) (tret : xtype) (s : signature) (e : expr) (l : list expr) (e1 e2 : S.typenv) (e0 : sig_res s = tret) (SAT : S.satisf te e2) (x : S.typenv) (EQ : type_expr e1 e Tptr = OK x) (EQ0 : type_exprlist x l (proj_sig_args s) = OK e2) : wt_stmt te tret (Stailcall s e l).","conclusion":"wt_stmt te tret (Stailcall s e l)","hypotheses":"(te : S.typassign) (tret : xtype) (s : signature) (e : expr) (l : list expr) (e1 e2 : S.typenv) (e0 : sig_res s = tret) (SAT : S.satisf te e2) (x : S.typenv) (EQ : type_expr e1 e Tptr = OK x) (EQ0 : type_exprlist x l (proj_sig_args s) = OK e2)","proofString":"constructor; eauto using type_expr_sound, type_exprlist_sound with ty."},{"statement":"(te : S.typassign) (tret : xtype) (o : option ident) (e : external_function) (l : list expr) (e1 e2 : S.typenv) (SAT : S.satisf te e2) (x : S.typenv) (EQ : type_exprlist e1 l (proj_sig_args (ef_sig e)) = OK x) (EQ0 : opt_set x o (proj_sig_res (ef_sig e)) = OK e2) : wt_stmt te tret (Sbuiltin o e l).","conclusion":"wt_stmt te tret (Sbuiltin o e l)","hypotheses":"(te : S.typassign) (tret : xtype) (o : option ident) (e : external_function) (l : list expr) (e1 e2 : S.typenv) (SAT : S.satisf te e2) (x : S.typenv) (EQ : type_exprlist e1 l (proj_sig_args (ef_sig e)) = OK x) (EQ0 : opt_set x o (proj_sig_res (ef_sig e)) = OK e2)","proofString":"constructor; eauto using type_exprlist_sound, opt_set_sound with ty."},{"statement":"(te : S.typassign) (tret : xtype) (s1 s2 : stmt) (IHs1 : forall e e' : S.typenv,\ntype_stmt tret e s1 = OK e' -> S.satisf te e' -> wt_stmt te tret s1) (IHs2 : forall e e' : S.typenv,\ntype_stmt tret e s2 = OK e' -> S.satisf te e' -> wt_stmt te tret s2) (e1 e2 : S.typenv) (SAT : S.satisf te e2) (x : S.typenv) (EQ : type_stmt tret e1 s1 = OK x) (EQ0 : type_stmt tret x s2 = OK e2) : wt_stmt te tret (Sseq s1 s2).","conclusion":"wt_stmt te tret (Sseq s1 s2)","hypotheses":"(te : S.typassign) (tret : xtype) (s1 s2 : stmt) (IHs1 : forall e e' : S.typenv,\ntype_stmt tret e s1 = OK e' -> S.satisf te e' -> wt_stmt te tret s1) (IHs2 : forall e e' : S.typenv,\ntype_stmt tret e s2 = OK e' -> S.satisf te e' -> wt_stmt te tret s2) (e1 e2 : S.typenv) (SAT : S.satisf te e2) (x : S.typenv) (EQ : type_stmt tret e1 s1 = OK x) (EQ0 : type_stmt tret x s2 = OK e2)","proofString":"constructor; eauto with ty."},{"statement":"(te : S.typassign) (tret : xtype) (e : expr) (s1 s2 : stmt) (IHs1 : forall e0 e' : S.typenv,\ntype_stmt tret e0 s1 = OK e' -> S.satisf te e' -> wt_stmt te tret s1) (IHs2 : forall e0 e' : S.typenv,\ntype_stmt tret e0 s2 = OK e' -> S.satisf te e' -> wt_stmt te tret s2) (e1 e2 : S.typenv) (SAT : S.satisf te e2) (x : S.typenv) (EQ : type_expr e1 e Tint = OK x) (x0 : S.typenv) (EQ1 : type_stmt tret x s1 = OK x0) (EQ2 : type_stmt tret x0 s2 = OK e2) : wt_stmt te tret (Sifthenelse e s1 s2).","conclusion":"wt_stmt te tret (Sifthenelse e s1 s2)","hypotheses":"(te : S.typassign) (tret : xtype) (e : expr) (s1 s2 : stmt) (IHs1 : forall e0 e' : S.typenv,\ntype_stmt tret e0 s1 = OK e' -> S.satisf te e' -> wt_stmt te tret s1) (IHs2 : forall e0 e' : S.typenv,\ntype_stmt tret e0 s2 = OK e' -> S.satisf te e' -> wt_stmt te tret s2) (e1 e2 : S.typenv) (SAT : S.satisf te e2) (x : S.typenv) (EQ : type_expr e1 e Tint = OK x) (x0 : S.typenv) (EQ1 : type_stmt tret x s1 = OK x0) (EQ2 : type_stmt tret x0 s2 = OK e2)","proofString":"constructor; eauto using type_expr_sound with ty."},{"statement":"(te : S.typassign) (tret : xtype) (s : stmt) (IHs : forall e e' : S.typenv,\ntype_stmt tret e s = OK e' -> S.satisf te e' -> wt_stmt te tret s) (e1 e2 : S.typenv) (T : type_stmt tret e1 s = OK e2) (SAT : S.satisf te e2) : wt_stmt te tret (Sloop s).","conclusion":"wt_stmt te tret (Sloop s)","hypotheses":"(te : S.typassign) (tret : xtype) (s : stmt) (IHs : forall e e' : S.typenv,\ntype_stmt tret e s = OK e' -> S.satisf te e' -> wt_stmt te tret s) (e1 e2 : S.typenv) (T : type_stmt tret e1 s = OK e2) (SAT : S.satisf te e2)","proofString":"constructor; eauto."},{"statement":"(te : S.typassign) (tret : xtype) (s : stmt) (IHs : forall e e' : S.typenv,\ntype_stmt tret e s = OK e' -> S.satisf te e' -> wt_stmt te tret s) (e1 e2 : S.typenv) (T : type_stmt tret e1 s = OK e2) (SAT : S.satisf te e2) : wt_stmt te tret (Sblock s).","conclusion":"wt_stmt te tret (Sblock s)","hypotheses":"(te : S.typassign) (tret : xtype) (s : stmt) (IHs : forall e e' : S.typenv,\ntype_stmt tret e s = OK e' -> S.satisf te e' -> wt_stmt te tret s) (e1 e2 : S.typenv) (T : type_stmt tret e1 s = OK e2) (SAT : S.satisf te e2)","proofString":"constructor; eauto."},{"statement":"(te : S.typassign) (tret : xtype) (n : nat) (e2 : S.typenv) (SAT : S.satisf te e2) : wt_stmt te tret (Sexit n).","conclusion":"wt_stmt te tret (Sexit n)","hypotheses":"(te : S.typassign) (tret : xtype) (n : nat) (e2 : S.typenv) (SAT : S.satisf te e2)","proofString":"constructor."},{"statement":"(te : S.typassign) (tret : xtype) (b : bool) (e : expr) (l : list (Z * nat)) (n : nat) (e1 e2 : S.typenv) (T : type_expr e1 e (if b then Tlong else Tint) = OK e2) (SAT : S.satisf te e2) : wt_stmt te tret (Sswitch b e l n).","conclusion":"wt_stmt te tret (Sswitch b e l n)","hypotheses":"(te : S.typassign) (tret : xtype) (b : bool) (e : expr) (l : list (Z * nat)) (n : nat) (e1 e2 : S.typenv) (T : type_expr e1 e (if b then Tlong else Tint) = OK e2) (SAT : S.satisf te e2)","proofString":"constructor; eauto using type_expr_sound with ty."},{"statement":"(te : S.typassign) (tret : xtype) (o : option expr) (e1 e2 : S.typenv) (T : match o with\n| Some a => type_expr e1 a (proj_xtype tret)\n| None => OK e1\nend = OK e2) (SAT : S.satisf te e2) : wt_stmt te tret (Sreturn o).","conclusion":"wt_stmt te tret (Sreturn o)","hypotheses":"(te : S.typassign) (tret : xtype) (o : option expr) (e1 e2 : S.typenv) (T : match o with\n| Some a => type_expr e1 a (proj_xtype tret)\n| None => OK e1\nend = OK e2) (SAT : S.satisf te e2)","proofString":"destruct o; try (monadInv T); econstructor; eauto using type_expr_sound with ty."},{"statement":"(te : S.typassign) (tret : xtype) (l : label) (s : stmt) (IHs : forall e e' : S.typenv,\ntype_stmt tret e s = OK e' -> S.satisf te e' -> wt_stmt te tret s) (e1 e2 : S.typenv) (T : type_stmt tret e1 s = OK e2) (SAT : S.satisf te e2) : wt_stmt te tret (Slabel l s).","conclusion":"wt_stmt te tret (Slabel l s)","hypotheses":"(te : S.typassign) (tret : xtype) (l : label) (s : stmt) (IHs : forall e e' : S.typenv,\ntype_stmt tret e s = OK e' -> S.satisf te e' -> wt_stmt te tret s) (e1 e2 : S.typenv) (T : type_stmt tret e1 s = OK e2) (SAT : S.satisf te e2)","proofString":"constructor; eauto."},{"statement":"(te : S.typassign) (tret : xtype) (l : label) (e2 : S.typenv) (SAT : S.satisf te e2) : wt_stmt te tret (Sgoto l).","conclusion":"wt_stmt te tret (Sgoto l)","hypotheses":"(te : S.typassign) (tret : xtype) (l : label) (e2 : S.typenv) (SAT : S.satisf te e2)","proofString":"constructor."},{"statement":"(f : function) (env : typenv) (H : type_function f = OK env) : wt_function env f.","conclusion":"wt_function env f","hypotheses":"(f : function) (env : typenv) (H : type_function f = OK env)","proofString":"generalize H; unfold type_function; intros T; monadInv T.\nassert (S.satisf env x0) by (apply S.solve_sound; auto).\nconstructor; eauto using S.set_list_sound, type_stmt_sound with ty."},{"statement":"(f : function) (env : typenv) (H : type_function f = OK env) (x : S.typenv) (EQ : S.set_list S.initial (fn_params f) (proj_sig_args (fn_sig f)) = OK x) (x0 : S.typenv) (EQ1 : type_stmt (sig_res (fn_sig f)) x (fn_body f) = OK x0) (EQ2 : S.solve x0 = OK env) : wt_function env f.","conclusion":"wt_function env f","hypotheses":"(f : function) (env : typenv) (H : type_function f = OK env) (x : S.typenv) (EQ : S.set_list S.initial (fn_params f) (proj_sig_args (fn_sig f)) = OK x) (x0 : S.typenv) (EQ1 : type_stmt (sig_res (fn_sig f)) x (fn_body f) = OK x0) (EQ2 : S.solve x0 = OK env)","proofString":"assert (S.satisf env x0) by (apply S.solve_sound; auto).\nconstructor; eauto using S.set_list_sound, type_stmt_sound with ty."},{"statement":"(f : function) (env : typenv) (H : type_function f = OK env) (x : S.typenv) (EQ : S.set_list S.initial (fn_params f) (proj_sig_args (fn_sig f)) = OK x) (x0 : S.typenv) (EQ1 : type_stmt (sig_res (fn_sig f)) x (fn_body f) = OK x0) (EQ2 : S.solve x0 = OK env) (H0 : S.satisf env x0) : wt_function env f.","conclusion":"wt_function env f","hypotheses":"(f : function) (env : typenv) (H : type_function f = OK env) (x : S.typenv) (EQ : S.set_list S.initial (fn_params f) (proj_sig_args (fn_sig f)) = OK x) (x0 : S.typenv) (EQ1 : type_stmt (sig_res (fn_sig f)) x (fn_body f) = OK x0) (EQ2 : S.solve x0 = OK env) (H0 : S.satisf env x0)","proofString":"constructor; eauto using S.set_list_sound, type_stmt_sound with ty."},{"statement":"(env : typenv) (tret : xtype) (k : cont) (H : wt_cont_call k tret) : wt_cont_call (call_cont k) tret.","conclusion":"wt_cont_call (call_cont k) tret","hypotheses":"(env : typenv) (tret : xtype) (k : cont) (H : wt_cont_call k tret)","proofString":"inversion H; subst; auto."},{"statement":"(env : typenv) (id : ident) (e : Cminor.env) (v : val) (H : wt_env env e) (H0 : Val.has_type v (env id)) (id0 : positive) (v0 : val) (H1 : (PTree.set id v e) ! id0 = Some v0) : Val.has_type v0 (env id0).","conclusion":"Val.has_type v0 (env id0)","hypotheses":"(env : typenv) (id : ident) (e : Cminor.env) (v : val) (H : wt_env env e) (H0 : Val.has_type v (env id)) (id0 : positive) (v0 : val) (H1 : (PTree.set id v e) ! id0 = Some v0)","proofString":"rewrite PTree.gsspec in H1; destruct (peq id0 id).\ncongruence.\nauto."},{"statement":"(env : typenv) (id : ident) (e : Cminor.env) (v : val) (H : wt_env env e) (H0 : Val.has_type v (env id)) (id0 : positive) (v0 : val) (e0 : id0 = id) (H1 : Some v = Some v0) : Val.has_type v0 (env id0).","conclusion":"Val.has_type v0 (env id0)","hypotheses":"(env : typenv) (id : ident) (e : Cminor.env) (v : val) (H : wt_env env e) (H0 : Val.has_type v (env id)) (id0 : positive) (v0 : val) (e0 : id0 = id) (H1 : Some v = Some v0)","proofString":"congruence."},{"statement":"(env : typenv) (id : ident) (e : Cminor.env) (v : val) (H : wt_env env e) (H0 : Val.has_type v (env id)) (id0 : positive) (v0 : val) (n : id0 <> id) (H1 : e ! id0 = Some v0) : Val.has_type v0 (env id0).","conclusion":"Val.has_type v0 (env id0)","hypotheses":"(env : typenv) (id : ident) (e : Cminor.env) (v : val) (H : wt_env env e) (H0 : Val.has_type v (env id)) (id0 : positive) (v0 : val) (n : id0 <> id) (H1 : e ! id0 = Some v0)","proofString":"auto."},{"statement":"(f : function) (e : env) (id : positive) (v : val) (H : def_env f e) (i : ident) (IN : In i (fn_params f) \\/ In i (fn_vars f)) : exists v0 : val, (PTree.set id v e) ! i = Some v0.","conclusion":"exists v0 : val, (PTree.set id v e) ! i = Some v0","hypotheses":"(f : function) (e : env) (id : positive) (v : val) (H : def_env f e) (i : ident) (IN : In i (fn_params f) \\/ In i (fn_vars f))","proofString":"rewrite PTree.gsspec.\ndestruct (peq i id).\nexists v; auto.\nauto."},{"statement":"(f : function) (e : env) (id : positive) (v : val) (H : def_env f e) (i : ident) (IN : In i (fn_params f) \\/ In i (fn_vars f)) : exists v0 : val, (if peq i id then Some v else e ! i) = Some v0.","conclusion":"exists v0 : val, (if peq i id then Some v else e ! i) = Some v0","hypotheses":"(f : function) (e : env) (id : positive) (v : val) (H : def_env f e) (i : ident) (IN : In i (fn_params f) \\/ In i (fn_vars f))","proofString":"destruct (peq i id).\nexists v; auto.\nauto."},{"statement":"(f : function) (e : env) (id : positive) (v : val) (H : def_env f e) (i : ident) (IN : In i (fn_params f) \\/ In i (fn_vars f)) (e0 : i = id) : exists v0 : val, Some v = Some v0.","conclusion":"exists v0 : val, Some v = Some v0","hypotheses":"(f : function) (e : env) (id : positive) (v : val) (H : def_env f e) (i : ident) (IN : In i (fn_params f) \\/ In i (fn_vars f)) (e0 : i = id)","proofString":"exists v; auto."},{"statement":"(f : function) (e : env) (id : positive) (v : val) (H : def_env f e) (i : ident) (IN : In i (fn_params f) \\/ In i (fn_vars f)) (n : i <> id) : exists v0 : val, e ! i = Some v0.","conclusion":"exists v0 : val, e ! i = Some v0","hypotheses":"(f : function) (e : env) (id : positive) (v : val) (H : def_env f e) (i : ident) (IN : In i (fn_params f) \\/ In i (fn_vars f)) (n : i <> id)","proofString":"auto."},{"statement":"(env : ident -> typ) (H : True) : wt_env env (PTree.empty val).","conclusion":"wt_env env (PTree.empty val)","hypotheses":"(env : ident -> typ) (H : True)","proofString":"red; intros.\nrewrite PTree.gempty in H0; discriminate."},{"statement":"(env : ident -> typ) (H : True) (id : positive) (v : val) (H0 : (PTree.empty val) ! id = Some v) : Val.has_type v (env id).","conclusion":"Val.has_type v (env id)","hypotheses":"(env : ident -> typ) (H : True) (id : positive) (v : val) (H0 : (PTree.empty val) ! id = Some v)","proofString":"rewrite PTree.gempty in H0; discriminate."},{"statement":"(env : ident -> typ) (i : ident) (il : list ident) (IHil : forall vl1 : list val,\nVal.has_type_list vl1 (map env il) -> wt_env env (set_params vl1 il)) (vl : val) (vl0 : list val) (H : Val.has_type vl (env i) /\\ Val.has_type_list vl0 (map env il)) : wt_env env (PTree.set i vl (set_params vl0 il)).","conclusion":"wt_env env (PTree.set i vl (set_params vl0 il))","hypotheses":"(env : ident -> typ) (i : ident) (il : list ident) (IHil : forall vl1 : list val,\nVal.has_type_list vl1 (map env il) -> wt_env env (set_params vl1 il)) (vl : val) (vl0 : list val) (H : Val.has_type vl (env i) /\\ Val.has_type_list vl0 (map env il))","proofString":"destruct H.\napply wt_env_assign; auto."},{"statement":"(env : ident -> typ) (i : ident) (il : list ident) (IHil : forall vl1 : list val,\nVal.has_type_list vl1 (map env il) -> wt_env env (set_params vl1 il)) (vl : val) (vl0 : list val) (H : Val.has_type vl (env i)) (H0 : Val.has_type_list vl0 (map env il)) : wt_env env (PTree.set i vl (set_params vl0 il)).","conclusion":"wt_env env (PTree.set i vl (set_params vl0 il))","hypotheses":"(env : ident -> typ) (i : ident) (il : list ident) (IHil : forall vl1 : list val,\nVal.has_type_list vl1 (map env il) -> wt_env env (set_params vl1 il)) (vl : val) (vl0 : list val) (H : Val.has_type vl (env i)) (H0 : Val.has_type_list vl0 (map env il))","proofString":"apply wt_env_assign; auto."},{"statement":"(id : positive) (vl : list val) (H : False) : exists v : val, (PTree.empty val) ! id = Some v.","conclusion":"exists v : val, (PTree.empty val) ! id = Some v","hypotheses":"(id : positive) (vl : list val) (H : False)","proofString":"contradiction."},{"statement":"(id i : positive) (il : list positive) (IHil : forall vl0 : list val,\nIn id il -> exists v : val, (set_params vl0 il) ! id = Some v) (vl : list val) (H : i = id \\/ In id il) : exists v : val,\n  match vl with\n  | nil => PTree.set i Vundef (set_params nil il)\n  | v1 :: vs => PTree.set i v1 (set_params vs il)\n  end ! id = Some v.","conclusion":"exists v : val,\n  match vl with\n  | nil => PTree.set i Vundef (set_params nil il)\n  | v1 :: vs => PTree.set i v1 (set_params vs il)\n  end ! id = Some v","hypotheses":"(id i : positive) (il : list positive) (IHil : forall vl0 : list val,\nIn id il -> exists v : val, (set_params vl0 il) ! id = Some v) (vl : list val) (H : i = id \\/ In id il)","proofString":"destruct vl as [ | v vl]; rewrite PTree.gsspec; destruct (peq id i).\neconstructor; eauto.\napply IHil; intuition congruence.\neconstructor; eauto.\napply IHil; intuition congruence."},{"statement":"(id i : positive) (il : list positive) (IHil : forall vl : list val,\nIn id il -> exists v : val, (set_params vl il) ! id = Some v) (H : i = id \\/ In id il) (e : id = i) : exists v : val, Some Vundef = Some v.","conclusion":"exists v : val, Some Vundef = Some v","hypotheses":"(id i : positive) (il : list positive) (IHil : forall vl : list val,\nIn id il -> exists v : val, (set_params vl il) ! id = Some v) (H : i = id \\/ In id il) (e : id = i)","proofString":"econstructor; eauto."},{"statement":"(id i : positive) (il : list positive) (IHil : forall vl : list val,\nIn id il -> exists v : val, (set_params vl il) ! id = Some v) (H : i = id \\/ In id il) (n : id <> i) : exists v : val, (set_params nil il) ! id = Some v.","conclusion":"exists v : val, (set_params nil il) ! id = Some v","hypotheses":"(id i : positive) (il : list positive) (IHil : forall vl : list val,\nIn id il -> exists v : val, (set_params vl il) ! id = Some v) (H : i = id \\/ In id il) (n : id <> i)","proofString":"apply IHil; intuition congruence."},{"statement":"(id i : positive) (il : list positive) (IHil : forall vl0 : list val,\nIn id il -> exists v0 : val, (set_params vl0 il) ! id = Some v0) (v : val) (vl : list val) (H : i = id \\/ In id il) (e : id = i) : exists v0 : val, Some v = Some v0.","conclusion":"exists v0 : val, Some v = Some v0","hypotheses":"(id i : positive) (il : list positive) (IHil : forall vl0 : list val,\nIn id il -> exists v0 : val, (set_params vl0 il) ! id = Some v0) (v : val) (vl : list val) (H : i = id \\/ In id il) (e : id = i)","proofString":"econstructor; eauto."},{"statement":"(id i : positive) (il : list positive) (IHil : forall vl0 : list val,\nIn id il -> exists v0 : val, (set_params vl0 il) ! id = Some v0) (v : val) (vl : list val) (H : i = id \\/ In id il) (n : id <> i) : exists v0 : val, (set_params vl il) ! id = Some v0.","conclusion":"exists v0 : val, (set_params vl il) ! id = Some v0","hypotheses":"(id i : positive) (il : list positive) (IHil : forall vl0 : list val,\nIn id il -> exists v0 : val, (set_params vl0 il) ! id = Some v0) (v : val) (vl : list val) (H : i = id \\/ In id il) (n : id <> i)","proofString":"apply IHil; intuition congruence."},{"statement":"(env : typenv) (e : Cminor.env) (H : wt_env env e) : wt_env env e.","conclusion":"wt_env env e","hypotheses":"(env : typenv) (e : Cminor.env) (H : wt_env env e)","proofString":"auto."},{"statement":"(env : typenv) (i : ident) (il : list ident) (IHil : forall e0 : Cminor.env, wt_env env e0 -> wt_env env (set_locals il e0)) (e : Cminor.env) (H : wt_env env e) : wt_env env (PTree.set i Vundef (set_locals il e)).","conclusion":"wt_env env (PTree.set i Vundef (set_locals il e))","hypotheses":"(env : typenv) (i : ident) (il : list ident) (IHil : forall e0 : Cminor.env, wt_env env e0 -> wt_env env (set_locals il e0)) (e : Cminor.env) (H : wt_env env e)","proofString":"apply wt_env_assign; auto.\nexact I."},{"statement":"(env : typenv) (i : ident) (il : list ident) (IHil : forall e0 : Cminor.env, wt_env env e0 -> wt_env env (set_locals il e0)) (e : Cminor.env) (H : wt_env env e) : Val.has_type Vundef (env i).","conclusion":"Val.has_type Vundef (env i)","hypotheses":"(env : typenv) (i : ident) (il : list ident) (IHil : forall e0 : Cminor.env, wt_env env e0 -> wt_env env (set_locals il e0)) (e : Cminor.env) (H : wt_env env e)","proofString":"exact I."},{"statement":"(id : positive) (e : PTree.tree val) (H : (exists v : val, e ! id = Some v) \\/ False) : exists v : val, e ! id = Some v.","conclusion":"exists v : val, e ! id = Some v","hypotheses":"(id : positive) (e : PTree.tree val) (H : (exists v : val, e ! id = Some v) \\/ False)","proofString":"tauto."},{"statement":"(id i : positive) (il : list positive) (IHil : forall e0 : PTree.tree val,\n(exists v : val, e0 ! id = Some v) \\/ In id il ->\nexists v : val, (set_locals il e0) ! id = Some v) (e : PTree.tree val) (H : (exists v : val, e ! id = Some v) \\/ i = id \\/ In id il) : exists v : val, (PTree.set i Vundef (set_locals il e)) ! id = Some v.","conclusion":"exists v : val, (PTree.set i Vundef (set_locals il e)) ! id = Some v","hypotheses":"(id i : positive) (il : list positive) (IHil : forall e0 : PTree.tree val,\n(exists v : val, e0 ! id = Some v) \\/ In id il ->\nexists v : val, (set_locals il e0) ! id = Some v) (e : PTree.tree val) (H : (exists v : val, e ! id = Some v) \\/ i = id \\/ In id il)","proofString":"rewrite PTree.gsspec; destruct (peq id i).\neconstructor; eauto.\napply IHil; intuition congruence."},{"statement":"(id i : positive) (il : list positive) (IHil : forall e1 : PTree.tree val,\n(exists v : val, e1 ! id = Some v) \\/ In id il ->\nexists v : val, (set_locals il e1) ! id = Some v) (e : PTree.tree val) (H : (exists v : val, e ! id = Some v) \\/ i = id \\/ In id il) (e0 : id = i) : exists v : val, Some Vundef = Some v.","conclusion":"exists v : val, Some Vundef = Some v","hypotheses":"(id i : positive) (il : list positive) (IHil : forall e1 : PTree.tree val,\n(exists v : val, e1 ! id = Some v) \\/ In id il ->\nexists v : val, (set_locals il e1) ! id = Some v) (e : PTree.tree val) (H : (exists v : val, e ! id = Some v) \\/ i = id \\/ In id il) (e0 : id = i)","proofString":"econstructor; eauto."},{"statement":"(id i : positive) (il : list positive) (IHil : forall e0 : PTree.tree val,\n(exists v : val, e0 ! id = Some v) \\/ In id il ->\nexists v : val, (set_locals il e0) ! id = Some v) (e : PTree.tree val) (H : (exists v : val, e ! id = Some v) \\/ i = id \\/ In id il) (n : id <> i) : exists v : val, (set_locals il e) ! id = Some v.","conclusion":"exists v : val, (set_locals il e) ! id = Some v","hypotheses":"(id i : positive) (il : list positive) (IHil : forall e0 : PTree.tree val,\n(exists v : val, e0 ! id = Some v) \\/ In id il ->\nexists v : val, (set_locals il e0) ! id = Some v) (e : PTree.tree val) (H : (exists v : val, e ! id = Some v) \\/ i = id \\/ In id il) (n : id <> i)","proofString":"apply IHil; intuition congruence."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (s1 s2 : stmt) (IHs1 : forall k0 : cont,\nwt_stmt env tret s1 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s1 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Sseq s1 s2)) (WK : wt_cont env tret k) : match\n  match find_label lbl s1 (Kseq s2 k) with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match\n  match find_label lbl s1 (Kseq s2 k) with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (s1 s2 : stmt) (IHs1 : forall k0 : cont,\nwt_stmt env tret s1 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s1 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Sseq s1 s2)) (WK : wt_cont env tret k)","proofString":"inv WS.\nassert (wt_cont env tret (Kseq s2 k)) by (constructor; auto).\nspecialize (IHs1 _ H1 H).\ndestruct (find_label lbl s1 (Kseq s2 k)).\nauto.\napply IHs2; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (s1 s2 : stmt) (IHs1 : forall k0 : cont,\nwt_stmt env tret s1 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s1 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H1 : wt_stmt env tret s1) (H2 : wt_stmt env tret s2) : match\n  match find_label lbl s1 (Kseq s2 k) with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match\n  match find_label lbl s1 (Kseq s2 k) with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (s1 s2 : stmt) (IHs1 : forall k0 : cont,\nwt_stmt env tret s1 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s1 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H1 : wt_stmt env tret s1) (H2 : wt_stmt env tret s2)","proofString":"assert (wt_cont env tret (Kseq s2 k)) by (constructor; auto).\nspecialize (IHs1 _ H1 H).\ndestruct (find_label lbl s1 (Kseq s2 k)).\nauto.\napply IHs2; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (s1 s2 : stmt) (IHs1 : forall k0 : cont,\nwt_stmt env tret s1 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s1 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H1 : wt_stmt env tret s1) (H2 : wt_stmt env tret s2) (H : wt_cont env tret (Kseq s2 k)) : match\n  match find_label lbl s1 (Kseq s2 k) with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match\n  match find_label lbl s1 (Kseq s2 k) with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (s1 s2 : stmt) (IHs1 : forall k0 : cont,\nwt_stmt env tret s1 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s1 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H1 : wt_stmt env tret s1) (H2 : wt_stmt env tret s2) (H : wt_cont env tret (Kseq s2 k))","proofString":"specialize (IHs1 _ H1 H).\ndestruct (find_label lbl s1 (Kseq s2 k)).\nauto.\napply IHs2; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (s1 s2 : stmt) (k : cont) (IHs1 : match find_label lbl s1 (Kseq s2 k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (WK : wt_cont env tret k) (H1 : wt_stmt env tret s1) (H2 : wt_stmt env tret s2) (H : wt_cont env tret (Kseq s2 k)) : match\n  match find_label lbl s1 (Kseq s2 k) with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match\n  match find_label lbl s1 (Kseq s2 k) with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (s1 s2 : stmt) (k : cont) (IHs1 : match find_label lbl s1 (Kseq s2 k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (WK : wt_cont env tret k) (H1 : wt_stmt env tret s1) (H2 : wt_stmt env tret s2) (H : wt_cont env tret (Kseq s2 k))","proofString":"destruct (find_label lbl s1 (Kseq s2 k)).\nauto.\napply IHs2; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (s1 s2 : stmt) (k : cont) (p : stmt * cont) (IHs1 : let (s', k') := p in wt_stmt env tret s' /\\ wt_cont env tret k') (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (WK : wt_cont env tret k) (H1 : wt_stmt env tret s1) (H2 : wt_stmt env tret s2) (H : wt_cont env tret (Kseq s2 k)) : let (s', k') := p in wt_stmt env tret s' /\\ wt_cont env tret k'.","conclusion":"let (s', k') := p in wt_stmt env tret s' /\\ wt_cont env tret k'","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (s1 s2 : stmt) (k : cont) (p : stmt * cont) (IHs1 : let (s', k') := p in wt_stmt env tret s' /\\ wt_cont env tret k') (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (WK : wt_cont env tret k) (H1 : wt_stmt env tret s1) (H2 : wt_stmt env tret s2) (H : wt_cont env tret (Kseq s2 k))","proofString":"auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (s1 s2 : stmt) (k : cont) (IHs1 : True) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (WK : wt_cont env tret k) (H1 : wt_stmt env tret s1) (H2 : wt_stmt env tret s2) (H : wt_cont env tret (Kseq s2 k)) : match find_label lbl s2 k with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match find_label lbl s2 k with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (s1 s2 : stmt) (k : cont) (IHs1 : True) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (WK : wt_cont env tret k) (H1 : wt_stmt env tret s1) (H2 : wt_stmt env tret s2) (H : wt_cont env tret (Kseq s2 k))","proofString":"apply IHs2; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (e : expr) (s1 s2 : stmt) (IHs1 : forall k0 : cont,\nwt_stmt env tret s1 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s1 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Sifthenelse e s1 s2)) (WK : wt_cont env tret k) : match\n  match find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match\n  match find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (e : expr) (s1 s2 : stmt) (IHs1 : forall k0 : cont,\nwt_stmt env tret s1 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s1 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Sifthenelse e s1 s2)) (WK : wt_cont env tret k)","proofString":"inv WS.\nspecialize (IHs1 _ H3 WK).\ndestruct (find_label lbl s1 k).\nauto.\napply IHs2; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (e : expr) (s1 s2 : stmt) (IHs1 : forall k0 : cont,\nwt_stmt env tret s1 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s1 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H2 : wt_expr env e Tint) (H3 : wt_stmt env tret s1) (H4 : wt_stmt env tret s2) : match\n  match find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match\n  match find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (e : expr) (s1 s2 : stmt) (IHs1 : forall k0 : cont,\nwt_stmt env tret s1 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s1 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H2 : wt_expr env e Tint) (H3 : wt_stmt env tret s1) (H4 : wt_stmt env tret s2)","proofString":"specialize (IHs1 _ H3 WK).\ndestruct (find_label lbl s1 k).\nauto.\napply IHs2; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (e : expr) (s1 s2 : stmt) (k : cont) (IHs1 : match find_label lbl s1 k with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (WK : wt_cont env tret k) (H2 : wt_expr env e Tint) (H3 : wt_stmt env tret s1) (H4 : wt_stmt env tret s2) : match\n  match find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match\n  match find_label lbl s1 k with\n  | Some sk => Some sk\n  | None => find_label lbl s2 k\n  end\nwith\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (e : expr) (s1 s2 : stmt) (k : cont) (IHs1 : match find_label lbl s1 k with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (WK : wt_cont env tret k) (H2 : wt_expr env e Tint) (H3 : wt_stmt env tret s1) (H4 : wt_stmt env tret s2)","proofString":"destruct (find_label lbl s1 k).\nauto.\napply IHs2; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (e : expr) (s1 s2 : stmt) (k : cont) (p : stmt * cont) (IHs1 : let (s', k') := p in wt_stmt env tret s' /\\ wt_cont env tret k') (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (WK : wt_cont env tret k) (H2 : wt_expr env e Tint) (H3 : wt_stmt env tret s1) (H4 : wt_stmt env tret s2) : let (s', k') := p in wt_stmt env tret s' /\\ wt_cont env tret k'.","conclusion":"let (s', k') := p in wt_stmt env tret s' /\\ wt_cont env tret k'","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (e : expr) (s1 s2 : stmt) (k : cont) (p : stmt * cont) (IHs1 : let (s', k') := p in wt_stmt env tret s' /\\ wt_cont env tret k') (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (WK : wt_cont env tret k) (H2 : wt_expr env e Tint) (H3 : wt_stmt env tret s1) (H4 : wt_stmt env tret s2)","proofString":"auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (e : expr) (s1 s2 : stmt) (k : cont) (IHs1 : True) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (WK : wt_cont env tret k) (H2 : wt_expr env e Tint) (H3 : wt_stmt env tret s1) (H4 : wt_stmt env tret s2) : match find_label lbl s2 k with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match find_label lbl s2 k with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (e : expr) (s1 s2 : stmt) (k : cont) (IHs1 : True) (IHs2 : forall k0 : cont,\nwt_stmt env tret s2 ->\nwt_cont env tret k0 ->\nmatch find_label lbl s2 k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (WK : wt_cont env tret k) (H2 : wt_expr env e Tint) (H3 : wt_stmt env tret s1) (H4 : wt_stmt env tret s2)","proofString":"apply IHs2; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Sloop s)) (WK : wt_cont env tret k) : match find_label lbl s (Kseq (Sloop s) k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match find_label lbl s (Kseq (Sloop s) k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Sloop s)) (WK : wt_cont env tret k)","proofString":"inversion WS; subst.\napply IHs; auto.\nconstructor; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Sloop s)) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s) : match find_label lbl s (Kseq (Sloop s) k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match find_label lbl s (Kseq (Sloop s) k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Sloop s)) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s)","proofString":"apply IHs; auto.\nconstructor; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Sloop s)) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s) : wt_cont env tret (Kseq (Sloop s) k).","conclusion":"wt_cont env tret (Kseq (Sloop s) k)","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Sloop s)) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s)","proofString":"constructor; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Sblock s)) (WK : wt_cont env tret k) : match find_label lbl s (Kblock k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match find_label lbl s (Kblock k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Sblock s)) (WK : wt_cont env tret k)","proofString":"inv WS.\napply IHs; auto.\nconstructor; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s) : match find_label lbl s (Kblock k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match find_label lbl s (Kblock k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s)","proofString":"apply IHs; auto.\nconstructor; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s) : wt_cont env tret (Kblock k).","conclusion":"wt_cont env tret (Kblock k)","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s)","proofString":"constructor; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl l : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Slabel l s)) (WK : wt_cont env tret k) : match (if ident_eq lbl l then Some (s, k) else find_label lbl s k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match (if ident_eq lbl l then Some (s, k) else find_label lbl s k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl l : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WS : wt_stmt env tret (Slabel l s)) (WK : wt_cont env tret k)","proofString":"inv WS.\ndestruct (ident_eq lbl l).\nauto.\napply IHs; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl l : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s) : match (if ident_eq lbl l then Some (s, k) else find_label lbl s k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match (if ident_eq lbl l then Some (s, k) else find_label lbl s k) with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl l : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s)","proofString":"destruct (ident_eq lbl l).\nauto.\napply IHs; auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl l : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s) (e : lbl = l) : wt_stmt env tret s /\\ wt_cont env tret k.","conclusion":"wt_stmt env tret s /\\ wt_cont env tret k","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl l : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s) (e : lbl = l)","proofString":"auto."},{"statement":"(env : ident -> typ) (tret : xtype) (lbl l : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s) (n : lbl <> l) : match find_label lbl s k with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend.","conclusion":"match find_label lbl s k with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend","hypotheses":"(env : ident -> typ) (tret : xtype) (lbl l : label) (s : stmt) (IHs : forall k0 : cont,\nwt_stmt env tret s ->\nwt_cont env tret k0 ->\nmatch find_label lbl s k0 with\n| Some (s', k') => wt_stmt env tret s' /\\ wt_cont env tret k'\n| None => True\nend) (k : cont) (WK : wt_cont env tret k) (H0 : wt_stmt env tret s) (n : lbl <> l)","proofString":"apply IHs; auto."},{"statement":"(sp : val) (cst : constant) (v : val) (EV : eval_constant ge sp cst = Some v) : Val.has_type v (type_constant cst).","conclusion":"Val.has_type v (type_constant cst)","hypotheses":"(sp : val) (cst : constant) (v : val) (EV : eval_constant ge sp cst = Some v)","proofString":"destruct cst; simpl in *; inv EV; VHT."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (t : typ) (WT : wt_expr env (Evar id) t) (ENV : wt_env env e) : Val.has_type v t.","conclusion":"Val.has_type v t","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (t : typ) (WT : wt_expr env (Evar id) t) (ENV : wt_env env e)","proofString":"inv WT.\napply ENV; auto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (ENV : wt_env env e) : Val.has_type v (env id).","conclusion":"Val.has_type v (env id)","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (ENV : wt_env env e)","proofString":"apply ENV; auto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (cst : constant) (v : val) (H : eval_constant ge sp cst = Some v) (t : typ) (WT : wt_expr env (Econst cst) t) (ENV : wt_env env e) : Val.has_type v t.","conclusion":"Val.has_type v t","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (cst : constant) (v : val) (H : eval_constant ge sp cst = Some v) (t : typ) (WT : wt_expr env (Econst cst) t) (ENV : wt_env env e)","proofString":"inv WT.\neapply type_constant_sound; eauto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (cst : constant) (v : val) (H : eval_constant ge sp cst = Some v) (ENV : wt_env env e) : Val.has_type v (type_constant cst).","conclusion":"Val.has_type v (type_constant cst)","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (cst : constant) (v : val) (H : eval_constant ge sp cst = Some v) (ENV : wt_env env e)","proofString":"eapply type_constant_sound; eauto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (op : unary_operation) (a1 : expr) (v1 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall t0 : typ, wt_expr env a1 t0 -> wt_env env e -> Val.has_type v1 t0) (t : typ) (WT : wt_expr env (Eunop op a1) t) (ENV : wt_env env e) : Val.has_type v t.","conclusion":"Val.has_type v t","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (op : unary_operation) (a1 : expr) (v1 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall t0 : typ, wt_expr env a1 t0 -> wt_env env e -> Val.has_type v1 t0) (t : typ) (WT : wt_expr env (Eunop op a1) t) (ENV : wt_env env e)","proofString":"inv WT.\nreplace t with (snd (type_unop op)) by (rewrite H3; auto).\neapply type_unop_sound; eauto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (op : unary_operation) (a1 : expr) (v1 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall t0 : typ, wt_expr env a1 t0 -> wt_env env e -> Val.has_type v1 t0) (t : typ) (ENV : wt_env env e) (targ1 : typ) (H3 : type_unop op = (targ1, t)) (H5 : wt_expr env a1 targ1) : Val.has_type v t.","conclusion":"Val.has_type v t","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (op : unary_operation) (a1 : expr) (v1 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall t0 : typ, wt_expr env a1 t0 -> wt_env env e -> Val.has_type v1 t0) (t : typ) (ENV : wt_env env e) (targ1 : typ) (H3 : type_unop op = (targ1, t)) (H5 : wt_expr env a1 targ1)","proofString":"replace t with (snd (type_unop op)) by (rewrite H3; auto).\neapply type_unop_sound; eauto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (op : unary_operation) (a1 : expr) (v1 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall t0 : typ, wt_expr env a1 t0 -> wt_env env e -> Val.has_type v1 t0) (t : typ) (ENV : wt_env env e) (targ1 : typ) (H3 : type_unop op = (targ1, t)) (H5 : wt_expr env a1 targ1) : Val.has_type v (snd (type_unop op)).","conclusion":"Val.has_type v (snd (type_unop op))","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (op : unary_operation) (a1 : expr) (v1 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall t0 : typ, wt_expr env a1 t0 -> wt_env env e -> Val.has_type v1 t0) (t : typ) (ENV : wt_env env e) (targ1 : typ) (H3 : type_unop op = (targ1, t)) (H5 : wt_expr env a1 targ1)","proofString":"eapply type_unop_sound; eauto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall t0 : typ, wt_expr env a1 t0 -> wt_env env e -> Val.has_type v1 t0) (IHeval_expr2 : forall t0 : typ, wt_expr env a2 t0 -> wt_env env e -> Val.has_type v2 t0) (t : typ) (WT : wt_expr env (Ebinop op a1 a2) t) (ENV : wt_env env e) : Val.has_type v t.","conclusion":"Val.has_type v t","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall t0 : typ, wt_expr env a1 t0 -> wt_env env e -> Val.has_type v1 t0) (IHeval_expr2 : forall t0 : typ, wt_expr env a2 t0 -> wt_env env e -> Val.has_type v2 t0) (t : typ) (WT : wt_expr env (Ebinop op a1 a2) t) (ENV : wt_env env e)","proofString":"inv WT.\nreplace t with (snd (type_binop op)) by (rewrite H5; auto).\neapply type_binop_sound; eauto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall t0 : typ, wt_expr env a1 t0 -> wt_env env e -> Val.has_type v1 t0) (IHeval_expr2 : forall t0 : typ, wt_expr env a2 t0 -> wt_env env e -> Val.has_type v2 t0) (t : typ) (ENV : wt_env env e) (targ1 targ2 : typ) (H5 : type_binop op = (targ1, targ2, t)) (H7 : wt_expr env a1 targ1) (H8 : wt_expr env a2 targ2) : Val.has_type v t.","conclusion":"Val.has_type v t","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall t0 : typ, wt_expr env a1 t0 -> wt_env env e -> Val.has_type v1 t0) (IHeval_expr2 : forall t0 : typ, wt_expr env a2 t0 -> wt_env env e -> Val.has_type v2 t0) (t : typ) (ENV : wt_env env e) (targ1 targ2 : typ) (H5 : type_binop op = (targ1, targ2, t)) (H7 : wt_expr env a1 targ1) (H8 : wt_expr env a2 targ2)","proofString":"replace t with (snd (type_binop op)) by (rewrite H5; auto).\neapply type_binop_sound; eauto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall t0 : typ, wt_expr env a1 t0 -> wt_env env e -> Val.has_type v1 t0) (IHeval_expr2 : forall t0 : typ, wt_expr env a2 t0 -> wt_env env e -> Val.has_type v2 t0) (t : typ) (ENV : wt_env env e) (targ1 targ2 : typ) (H5 : type_binop op = (targ1, targ2, t)) (H7 : wt_expr env a1 targ1) (H8 : wt_expr env a2 targ2) : Val.has_type v (snd (type_binop op)).","conclusion":"Val.has_type v (snd (type_binop op))","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall t0 : typ, wt_expr env a1 t0 -> wt_env env e -> Val.has_type v1 t0) (IHeval_expr2 : forall t0 : typ, wt_expr env a2 t0 -> wt_env env e -> Val.has_type v2 t0) (t : typ) (ENV : wt_env env e) (targ1 targ2 : typ) (H5 : type_binop op = (targ1, targ2, t)) (H7 : wt_expr env a1 targ1) (H8 : wt_expr env a2 targ2)","proofString":"eapply type_binop_sound; eauto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (chunk : memory_chunk) (addr : expr) (vaddr v : val) (H : eval_expr ge sp e m addr vaddr) (H0 : Mem.loadv chunk m vaddr = Some v) (IHeval_expr : forall t0 : typ, wt_expr env addr t0 -> wt_env env e -> Val.has_type vaddr t0) (t : typ) (WT : wt_expr env (Eload chunk addr) t) (ENV : wt_env env e) : Val.has_type v t.","conclusion":"Val.has_type v t","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (chunk : memory_chunk) (addr : expr) (vaddr v : val) (H : eval_expr ge sp e m addr vaddr) (H0 : Mem.loadv chunk m vaddr = Some v) (IHeval_expr : forall t0 : typ, wt_expr env addr t0 -> wt_env env e -> Val.has_type vaddr t0) (t : typ) (WT : wt_expr env (Eload chunk addr) t) (ENV : wt_env env e)","proofString":"inv WT.\ndestruct vaddr; try discriminate.\neapply Mem.load_type; eauto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (chunk : memory_chunk) (addr : expr) (vaddr v : val) (H : eval_expr ge sp e m addr vaddr) (H0 : Mem.loadv chunk m vaddr = Some v) (IHeval_expr : forall t : typ, wt_expr env addr t -> wt_env env e -> Val.has_type vaddr t) (ENV : wt_env env e) (H4 : wt_expr env addr Tptr) : Val.has_type v (type_of_chunk chunk).","conclusion":"Val.has_type v (type_of_chunk chunk)","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (chunk : memory_chunk) (addr : expr) (vaddr v : val) (H : eval_expr ge sp e m addr vaddr) (H0 : Mem.loadv chunk m vaddr = Some v) (IHeval_expr : forall t : typ, wt_expr env addr t -> wt_env env e -> Val.has_type vaddr t) (ENV : wt_env env e) (H4 : wt_expr env addr Tptr)","proofString":"destruct vaddr; try discriminate.\neapply Mem.load_type; eauto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (chunk : memory_chunk) (addr : expr) (b : block) (i : ptrofs) (v : val) (H : eval_expr ge sp e m addr (Vptr b i)) (H0 : Mem.loadv chunk m (Vptr b i) = Some v) (IHeval_expr : forall t : typ,\nwt_expr env addr t -> wt_env env e -> Val.has_type (Vptr b i) t) (ENV : wt_env env e) (H4 : wt_expr env addr Tptr) : Val.has_type v (type_of_chunk chunk).","conclusion":"Val.has_type v (type_of_chunk chunk)","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (chunk : memory_chunk) (addr : expr) (b : block) (i : ptrofs) (v : val) (H : eval_expr ge sp e m addr (Vptr b i)) (H0 : Mem.loadv chunk m (Vptr b i) = Some v) (IHeval_expr : forall t : typ,\nwt_expr env addr t -> wt_env env e -> Val.has_type (Vptr b i) t) (ENV : wt_env env e) (H4 : wt_expr env addr Tptr)","proofString":"eapply Mem.load_type; eauto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (ENV : wt_env env e) : True.","conclusion":"True","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (ENV : wt_env env e)","proofString":"auto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (a1 : expr) (al : list expr) (v1 : val) (vl : list val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_exprlist ge sp e m al vl) (IHeval_exprlist : forall tl : list typ,\nlist_forall2 (wt_expr env) al tl -> wt_env env e -> Val.has_type_list vl tl) (ENV : wt_env env e) (b1 : typ) (bl : list typ) (H3 : wt_expr env a1 b1) (H5 : list_forall2 (wt_expr env) al bl) : Val.has_type v1 b1 /\\ Val.has_type_list vl bl.","conclusion":"Val.has_type v1 b1 /\\ Val.has_type_list vl bl","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (a1 : expr) (al : list expr) (v1 : val) (vl : list val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_exprlist ge sp e m al vl) (IHeval_exprlist : forall tl : list typ,\nlist_forall2 (wt_expr env) al tl -> wt_env env e -> Val.has_type_list vl tl) (ENV : wt_env env e) (b1 : typ) (bl : list typ) (H3 : wt_expr env a1 b1) (H5 : list_forall2 (wt_expr env) al bl)","proofString":"split.\neapply wt_eval_expr; eauto.\neauto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (a1 : expr) (al : list expr) (v1 : val) (vl : list val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_exprlist ge sp e m al vl) (IHeval_exprlist : forall tl : list typ,\nlist_forall2 (wt_expr env) al tl -> wt_env env e -> Val.has_type_list vl tl) (ENV : wt_env env e) (b1 : typ) (bl : list typ) (H3 : wt_expr env a1 b1) (H5 : list_forall2 (wt_expr env) al bl) : Val.has_type v1 b1.","conclusion":"Val.has_type v1 b1","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (a1 : expr) (al : list expr) (v1 : val) (vl : list val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_exprlist ge sp e m al vl) (IHeval_exprlist : forall tl : list typ,\nlist_forall2 (wt_expr env) al tl -> wt_env env e -> Val.has_type_list vl tl) (ENV : wt_env env e) (b1 : typ) (bl : list typ) (H3 : wt_expr env a1 b1) (H5 : list_forall2 (wt_expr env) al bl)","proofString":"eapply wt_eval_expr; eauto."},{"statement":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (a1 : expr) (al : list expr) (v1 : val) (vl : list val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_exprlist ge sp e m al vl) (IHeval_exprlist : forall tl : list typ,\nlist_forall2 (wt_expr env) al tl -> wt_env env e -> Val.has_type_list vl tl) (ENV : wt_env env e) (b1 : typ) (bl : list typ) (H3 : wt_expr env a1 b1) (H5 : list_forall2 (wt_expr env) al bl) : Val.has_type_list vl bl.","conclusion":"Val.has_type_list vl bl","hypotheses":"(env : ident -> typ) (sp : val) (e : Cminor.env) (m : mem) (a1 : expr) (al : list expr) (v1 : val) (vl : list val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_exprlist ge sp e m al vl) (IHeval_exprlist : forall tl : list typ,\nlist_forall2 (wt_expr env) al tl -> wt_env env e -> Val.has_type_list vl tl) (ENV : wt_env env e) (b1 : typ) (bl : list typ) (H3 : wt_expr env a1 b1) (H5 : list_forall2 (wt_expr env) al bl)","proofString":"eauto."},{"statement":"(v : val) (fd : fundef) (H : Genv.find_funct ge v = Some fd) : wt_fundef fd.","conclusion":"wt_fundef fd","hypotheses":"(v : val) (fd : fundef) (H : Genv.find_funct ge v = Some fd)","proofString":"eapply Genv.find_funct_prop; eauto."},{"statement":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_CONT : wt_cont env (sig_res (fn_sig f)) (Kseq s k)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f s k sp e m).","conclusion":"wt_state (State f s k sp e m)","hypotheses":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_CONT : wt_cont env (sig_res (fn_sig f)) (Kseq s k)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_CONT.\neconstructor; eauto.\ninv H."},{"statement":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : wt_stmt env (sig_res (fn_sig f)) s) (H4 : wt_cont env (sig_res (fn_sig f)) k) : wt_state (State f s k sp e m).","conclusion":"wt_state (State f s k sp e m)","hypotheses":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : wt_stmt env (sig_res (fn_sig f)) s) (H4 : wt_cont env (sig_res (fn_sig f)) k)","proofString":"econstructor; eauto."},{"statement":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H : wt_cont_call (Kseq s k) (sig_res (fn_sig f))) : wt_state (State f s k sp e m).","conclusion":"wt_state (State f s k sp e m)","hypotheses":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H : wt_cont_call (Kseq s k) (sig_res (fn_sig f)))","proofString":"inv H."},{"statement":"(f : function) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_CONT : wt_cont env (sig_res (fn_sig f)) (Kblock k)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f Sskip k sp e m).","conclusion":"wt_state (State f Sskip k sp e m)","hypotheses":"(f : function) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_CONT : wt_cont env (sig_res (fn_sig f)) (Kblock k)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_CONT.\neconstructor; eauto.\ninv H."},{"statement":"(f : function) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H2 : wt_cont env (sig_res (fn_sig f)) k) : wt_state (State f Sskip k sp e m).","conclusion":"wt_state (State f Sskip k sp e m)","hypotheses":"(f : function) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H2 : wt_cont env (sig_res (fn_sig f)) k)","proofString":"econstructor; eauto."},{"statement":"(f : function) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H : wt_cont_call (Kblock k) (sig_res (fn_sig f))) : wt_state (State f Sskip k sp e m).","conclusion":"wt_state (State f Sskip k sp e m)","hypotheses":"(f : function) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H : wt_cont_call (Kblock k) (sig_res (fn_sig f)))","proofString":"inv H."},{"statement":"(f : function) (k : cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (Returnstate Vundef k m').","conclusion":"wt_state (Returnstate Vundef k m')","hypotheses":"(f : function) (k : cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"econstructor; eauto using wt_is_call_cont.\nexact I."},{"statement":"(f : function) (k : cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : Val.has_type Vundef (proj_xtype (sig_res (fn_sig f))).","conclusion":"Val.has_type Vundef (proj_xtype (sig_res (fn_sig f)))","hypotheses":"(f : function) (k : cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : is_call_cont k) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) Sskip) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"exact I."},{"statement":"(f : function) (id : ident) (a : expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : eval_expr ge sp e m a v) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sassign id a)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f Sskip k sp (PTree.set id v e) m).","conclusion":"wt_state (State f Sskip k sp (PTree.set id v e) m)","hypotheses":"(f : function) (id : ident) (a : expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : eval_expr ge sp e m a v) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sassign id a)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_STMT.\neconstructor; eauto using wt_Sskip.\napply wt_env_assign; auto.\neapply wt_eval_expr; eauto.\napply def_env_assign; auto."},{"statement":"(f : function) (id : ident) (a : expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : eval_expr ge sp e m a v) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H1 : wt_expr env a (env id)) : wt_state (State f Sskip k sp (PTree.set id v e) m).","conclusion":"wt_state (State f Sskip k sp (PTree.set id v e) m)","hypotheses":"(f : function) (id : ident) (a : expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : eval_expr ge sp e m a v) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H1 : wt_expr env a (env id))","proofString":"econstructor; eauto using wt_Sskip.\napply wt_env_assign; auto.\neapply wt_eval_expr; eauto.\napply def_env_assign; auto."},{"statement":"(f : function) (id : ident) (a : expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : eval_expr ge sp e m a v) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H1 : wt_expr env a (env id)) : wt_env env (PTree.set id v e).","conclusion":"wt_env env (PTree.set id v e)","hypotheses":"(f : function) (id : ident) (a : expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : eval_expr ge sp e m a v) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H1 : wt_expr env a (env id))","proofString":"apply wt_env_assign; auto.\neapply wt_eval_expr; eauto."},{"statement":"(f : function) (id : ident) (a : expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : eval_expr ge sp e m a v) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H1 : wt_expr env a (env id)) : Val.has_type v (env id).","conclusion":"Val.has_type v (env id)","hypotheses":"(f : function) (id : ident) (a : expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : eval_expr ge sp e m a v) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H1 : wt_expr env a (env id))","proofString":"eapply wt_eval_expr; eauto."},{"statement":"(f : function) (id : ident) (a : expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : eval_expr ge sp e m a v) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H1 : wt_expr env a (env id)) : def_env f (PTree.set id v e).","conclusion":"def_env f (PTree.set id v e)","hypotheses":"(f : function) (id : ident) (a : expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (H : eval_expr ge sp e m a v) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H1 : wt_expr env a (env id))","proofString":"apply def_env_assign; auto."},{"statement":"(f : function) (chunk : memory_chunk) (addr a : expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vaddr v : val) (m' : mem) (H : eval_expr ge sp e m addr vaddr) (H0 : eval_expr ge sp e m a v) (H1 : Mem.storev chunk m vaddr v = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sstore chunk addr a)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f Sskip k sp e m').","conclusion":"wt_state (State f Sskip k sp e m')","hypotheses":"(f : function) (chunk : memory_chunk) (addr a : expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vaddr v : val) (m' : mem) (H : eval_expr ge sp e m addr vaddr) (H0 : eval_expr ge sp e m a v) (H1 : Mem.storev chunk m vaddr v = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sstore chunk addr a)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"econstructor; eauto using wt_Sskip."},{"statement":"(f : function) (optid : option ident) (a : expr) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Scall optid (funsig fd) a bl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (Callstate fd vargs (Kcall optid f sp e k) m).","conclusion":"wt_state (Callstate fd vargs (Kcall optid f sp e k) m)","hypotheses":"(f : function) (optid : option ident) (a : expr) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Scall optid (funsig fd) a bl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_STMT.\neconstructor; eauto.\neapply wt_find_funct; eauto.\neapply wt_eval_exprlist; eauto.\neconstructor; eauto."},{"statement":"(f : function) (optid : option ident) (a : expr) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H5 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : wt_opt_assign env optid (sig_res (funsig fd))) : wt_state (Callstate fd vargs (Kcall optid f sp e k) m).","conclusion":"wt_state (Callstate fd vargs (Kcall optid f sp e k) m)","hypotheses":"(f : function) (optid : option ident) (a : expr) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H5 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : wt_opt_assign env optid (sig_res (funsig fd)))","proofString":"econstructor; eauto.\neapply wt_find_funct; eauto.\neapply wt_eval_exprlist; eauto.\neconstructor; eauto."},{"statement":"(f : function) (optid : option ident) (a : expr) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H5 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : wt_opt_assign env optid (sig_res (funsig fd))) : wt_fundef fd.","conclusion":"wt_fundef fd","hypotheses":"(f : function) (optid : option ident) (a : expr) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H5 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : wt_opt_assign env optid (sig_res (funsig fd)))","proofString":"eapply wt_find_funct; eauto."},{"statement":"(f : function) (optid : option ident) (a : expr) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H5 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : wt_opt_assign env optid (sig_res (funsig fd))) : Val.has_type_list vargs (proj_sig_args (funsig fd)).","conclusion":"Val.has_type_list vargs (proj_sig_args (funsig fd))","hypotheses":"(f : function) (optid : option ident) (a : expr) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H5 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : wt_opt_assign env optid (sig_res (funsig fd)))","proofString":"eapply wt_eval_exprlist; eauto."},{"statement":"(f : function) (optid : option ident) (a : expr) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H5 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : wt_opt_assign env optid (sig_res (funsig fd))) : wt_cont_call (Kcall optid f sp e k) (sig_res (funsig fd)).","conclusion":"wt_cont_call (Kcall optid f sp e k) (sig_res (funsig fd))","hypotheses":"(f : function) (optid : option ident) (a : expr) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H5 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : wt_opt_assign env optid (sig_res (funsig fd)))","proofString":"econstructor; eauto."},{"statement":"(f : function) (a : expr) (bl : list expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Stailcall (funsig fd) a bl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (Callstate fd vargs (call_cont k) m').","conclusion":"wt_state (Callstate fd vargs (call_cont k) m')","hypotheses":"(f : function) (a : expr) (bl : list expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Stailcall (funsig fd) a bl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_STMT.\neconstructor; eauto.\neapply wt_find_funct; eauto.\neapply wt_eval_exprlist; eauto.\nrewrite H8; eapply call_cont_wt; eauto."},{"statement":"(f : function) (a : expr) (bl : list expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H6 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : sig_res (funsig fd) = sig_res (fn_sig f)) : wt_state (Callstate fd vargs (call_cont k) m').","conclusion":"wt_state (Callstate fd vargs (call_cont k) m')","hypotheses":"(f : function) (a : expr) (bl : list expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H6 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : sig_res (funsig fd) = sig_res (fn_sig f))","proofString":"econstructor; eauto.\neapply wt_find_funct; eauto.\neapply wt_eval_exprlist; eauto.\nrewrite H8; eapply call_cont_wt; eauto."},{"statement":"(f : function) (a : expr) (bl : list expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H6 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : sig_res (funsig fd) = sig_res (fn_sig f)) : wt_fundef fd.","conclusion":"wt_fundef fd","hypotheses":"(f : function) (a : expr) (bl : list expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H6 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : sig_res (funsig fd) = sig_res (fn_sig f))","proofString":"eapply wt_find_funct; eauto."},{"statement":"(f : function) (a : expr) (bl : list expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H6 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : sig_res (funsig fd) = sig_res (fn_sig f)) : Val.has_type_list vargs (proj_sig_args (funsig fd)).","conclusion":"Val.has_type_list vargs (proj_sig_args (funsig fd))","hypotheses":"(f : function) (a : expr) (bl : list expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H6 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : sig_res (funsig fd) = sig_res (fn_sig f))","proofString":"eapply wt_eval_exprlist; eauto."},{"statement":"(f : function) (a : expr) (bl : list expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H6 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : sig_res (funsig fd) = sig_res (fn_sig f)) : wt_cont_call (call_cont k) (sig_res (funsig fd)).","conclusion":"wt_cont_call (call_cont k) (sig_res (funsig fd))","hypotheses":"(f : function) (a : expr) (bl : list expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (vf : val) (vargs : list val) (fd : fundef) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H6 : wt_expr env a Tptr) (H7 : list_forall2 (wt_expr env) bl (proj_sig_args (funsig fd))) (H8 : sig_res (funsig fd) = sig_res (fn_sig f))","proofString":"rewrite H8; eapply call_cont_wt; eauto."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sbuiltin optid ef bl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f Sskip k sp (set_optvar optid vres e) m').","conclusion":"wt_state (State f Sskip k sp (set_optvar optid vres e) m')","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sbuiltin optid ef bl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_STMT.\nexploit external_call_well_typed; eauto.\nintros TRES.\neconstructor; eauto using wt_Sskip.\ndestruct optid; auto.\napply wt_env_assign; auto.\nrewrite <- H5; auto.\ndestruct optid; auto.\napply def_env_assign; auto."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env optid (sig_res (ef_sig ef))) : wt_state (State f Sskip k sp (set_optvar optid vres e) m').","conclusion":"wt_state (State f Sskip k sp (set_optvar optid vres e) m')","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env optid (sig_res (ef_sig ef)))","proofString":"exploit external_call_well_typed; eauto.\nintros TRES.\neconstructor; eauto using wt_Sskip.\ndestruct optid; auto.\napply wt_env_assign; auto.\nrewrite <- H5; auto.\ndestruct optid; auto.\napply def_env_assign; auto."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env optid (sig_res (ef_sig ef))) : Val.has_type vres (proj_sig_res (ef_sig ef)) ->\nwt_state (State f Sskip k sp (set_optvar optid vres e) m').","conclusion":"Val.has_type vres (proj_sig_res (ef_sig ef)) ->\nwt_state (State f Sskip k sp (set_optvar optid vres e) m')","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env optid (sig_res (ef_sig ef)))","proofString":"intros TRES.\neconstructor; eauto using wt_Sskip.\ndestruct optid; auto.\napply wt_env_assign; auto.\nrewrite <- H5; auto.\ndestruct optid; auto.\napply def_env_assign; auto."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env optid (sig_res (ef_sig ef))) (TRES : Val.has_type vres (proj_sig_res (ef_sig ef))) : wt_state (State f Sskip k sp (set_optvar optid vres e) m').","conclusion":"wt_state (State f Sskip k sp (set_optvar optid vres e) m')","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env optid (sig_res (ef_sig ef))) (TRES : Val.has_type vres (proj_sig_res (ef_sig ef)))","proofString":"econstructor; eauto using wt_Sskip.\ndestruct optid; auto.\napply wt_env_assign; auto.\nrewrite <- H5; auto.\ndestruct optid; auto.\napply def_env_assign; auto."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env optid (sig_res (ef_sig ef))) (TRES : Val.has_type vres (proj_sig_res (ef_sig ef))) : wt_env env (set_optvar optid vres e).","conclusion":"wt_env env (set_optvar optid vres e)","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env optid (sig_res (ef_sig ef))) (TRES : Val.has_type vres (proj_sig_res (ef_sig ef)))","proofString":"destruct optid; auto.\napply wt_env_assign; auto.\nrewrite <- H5; auto."},{"statement":"(f : function) (i : ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env (Some i) (sig_res (ef_sig ef))) (TRES : Val.has_type vres (proj_sig_res (ef_sig ef))) : wt_env env (set_optvar (Some i) vres e).","conclusion":"wt_env env (set_optvar (Some i) vres e)","hypotheses":"(f : function) (i : ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env (Some i) (sig_res (ef_sig ef))) (TRES : Val.has_type vres (proj_sig_res (ef_sig ef)))","proofString":"apply wt_env_assign; auto.\nrewrite <- H5; auto."},{"statement":"(f : function) (i : ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env (Some i) (sig_res (ef_sig ef))) (TRES : Val.has_type vres (proj_sig_res (ef_sig ef))) : Val.has_type vres (env i).","conclusion":"Val.has_type vres (env i)","hypotheses":"(f : function) (i : ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env (Some i) (sig_res (ef_sig ef))) (TRES : Val.has_type vres (proj_sig_res (ef_sig ef)))","proofString":"rewrite <- H5; auto."},{"statement":"(f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env optid (sig_res (ef_sig ef))) (TRES : Val.has_type vres (proj_sig_res (ef_sig ef))) : def_env f (set_optvar optid vres e).","conclusion":"def_env f (set_optvar optid vres e)","hypotheses":"(f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env optid (sig_res (ef_sig ef))) (TRES : Val.has_type vres (proj_sig_res (ef_sig ef)))","proofString":"destruct optid; auto.\napply def_env_assign; auto."},{"statement":"(f : function) (i : ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env (Some i) (sig_res (ef_sig ef))) (TRES : Val.has_type vres (proj_sig_res (ef_sig ef))) : def_env f (set_optvar (Some i) vres e).","conclusion":"def_env f (set_optvar (Some i) vres e)","hypotheses":"(f : function) (i : ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (vargs : list val) (t : trace) (vres : val) (m' : mem) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : list_forall2 (wt_expr env) bl (proj_sig_args (ef_sig ef))) (H5 : wt_opt_assign env (Some i) (sig_res (ef_sig ef))) (TRES : Val.has_type vres (proj_sig_res (ef_sig ef)))","proofString":"apply def_env_assign; auto."},{"statement":"(f : function) (s1 s2 : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sseq s1 s2)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f s1 (Kseq s2 k) sp e m).","conclusion":"wt_state (State f s1 (Kseq s2 k) sp e m)","hypotheses":"(f : function) (s1 s2 : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sseq s1 s2)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_STMT.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : function) (s1 s2 : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H1 : wt_stmt env (sig_res (fn_sig f)) s1) (H2 : wt_stmt env (sig_res (fn_sig f)) s2) : wt_state (State f s1 (Kseq s2 k) sp e m).","conclusion":"wt_state (State f s1 (Kseq s2 k) sp e m)","hypotheses":"(f : function) (s1 s2 : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H1 : wt_stmt env (sig_res (fn_sig f)) s1) (H2 : wt_stmt env (sig_res (fn_sig f)) s2)","proofString":"econstructor; eauto.\neconstructor; eauto."},{"statement":"(f : function) (s1 s2 : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H1 : wt_stmt env (sig_res (fn_sig f)) s1) (H2 : wt_stmt env (sig_res (fn_sig f)) s2) : wt_cont env (sig_res (fn_sig f)) (Kseq s2 k).","conclusion":"wt_cont env (sig_res (fn_sig f)) (Kseq s2 k)","hypotheses":"(f : function) (s1 s2 : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H1 : wt_stmt env (sig_res (fn_sig f)) s1) (H2 : wt_stmt env (sig_res (fn_sig f)) s2)","proofString":"econstructor; eauto."},{"statement":"(f : function) (a : expr) (s1 s2 : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sifthenelse a s1 s2)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f (if b then s1 else s2) k sp e m).","conclusion":"wt_state (State f (if b then s1 else s2) k sp e m)","hypotheses":"(f : function) (a : expr) (s1 s2 : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sifthenelse a s1 s2)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_STMT.\ndestruct b; econstructor; eauto."},{"statement":"(f : function) (a : expr) (s1 s2 : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H4 : wt_expr env a Tint) (H5 : wt_stmt env (sig_res (fn_sig f)) s1) (H6 : wt_stmt env (sig_res (fn_sig f)) s2) : wt_state (State f (if b then s1 else s2) k sp e m).","conclusion":"wt_state (State f (if b then s1 else s2) k sp e m)","hypotheses":"(f : function) (a : expr) (s1 s2 : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (b : bool) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H4 : wt_expr env a Tint) (H5 : wt_stmt env (sig_res (fn_sig f)) s1) (H6 : wt_stmt env (sig_res (fn_sig f)) s2)","proofString":"destruct b; econstructor; eauto."},{"statement":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sloop s)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f s (Kseq (Sloop s) k) sp e m).","conclusion":"wt_state (State f s (Kseq (Sloop s) k) sp e m)","hypotheses":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sloop s)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_STMT.\neconstructor; eauto.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : wt_stmt env (sig_res (fn_sig f)) s) : wt_state (State f s (Kseq (Sloop s) k) sp e m).","conclusion":"wt_state (State f s (Kseq (Sloop s) k) sp e m)","hypotheses":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : wt_stmt env (sig_res (fn_sig f)) s)","proofString":"econstructor; eauto.\neconstructor; eauto.\nconstructor; auto."},{"statement":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : wt_stmt env (sig_res (fn_sig f)) s) : wt_cont env (sig_res (fn_sig f)) (Kseq (Sloop s) k).","conclusion":"wt_cont env (sig_res (fn_sig f)) (Kseq (Sloop s) k)","hypotheses":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : wt_stmt env (sig_res (fn_sig f)) s)","proofString":"econstructor; eauto.\nconstructor; auto."},{"statement":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : wt_stmt env (sig_res (fn_sig f)) s) : wt_stmt env (sig_res (fn_sig f)) (Sloop s).","conclusion":"wt_stmt env (sig_res (fn_sig f)) (Sloop s)","hypotheses":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : wt_stmt env (sig_res (fn_sig f)) s)","proofString":"constructor; auto."},{"statement":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sblock s)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f s (Kblock k) sp e m).","conclusion":"wt_state (State f s (Kblock k) sp e m)","hypotheses":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sblock s)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_STMT.\neconstructor; eauto.\neconstructor; eauto."},{"statement":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : wt_stmt env (sig_res (fn_sig f)) s) : wt_state (State f s (Kblock k) sp e m).","conclusion":"wt_state (State f s (Kblock k) sp e m)","hypotheses":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : wt_stmt env (sig_res (fn_sig f)) s)","proofString":"econstructor; eauto.\neconstructor; eauto."},{"statement":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : wt_stmt env (sig_res (fn_sig f)) s) : wt_cont env (sig_res (fn_sig f)) (Kblock k).","conclusion":"wt_cont env (sig_res (fn_sig f)) (Kblock k)","hypotheses":"(f : function) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : wt_stmt env (sig_res (fn_sig f)) s)","proofString":"econstructor; eauto."},{"statement":"(f : function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit n)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) (Kseq s k)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f (Sexit n) k sp e m).","conclusion":"wt_state (State f (Sexit n) k sp e m)","hypotheses":"(f : function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit n)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) (Kseq s k)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_CONT.\neconstructor; eauto.\ninv H."},{"statement":"(f : function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit n)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : wt_stmt env (sig_res (fn_sig f)) s) (H4 : wt_cont env (sig_res (fn_sig f)) k) : wt_state (State f (Sexit n) k sp e m).","conclusion":"wt_state (State f (Sexit n) k sp e m)","hypotheses":"(f : function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit n)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H3 : wt_stmt env (sig_res (fn_sig f)) s) (H4 : wt_cont env (sig_res (fn_sig f)) k)","proofString":"econstructor; eauto."},{"statement":"(f : function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit n)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H : wt_cont_call (Kseq s k) (sig_res (fn_sig f))) : wt_state (State f (Sexit n) k sp e m).","conclusion":"wt_state (State f (Sexit n) k sp e m)","hypotheses":"(f : function) (n : nat) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit n)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H : wt_cont_call (Kseq s k) (sig_res (fn_sig f)))","proofString":"inv H."},{"statement":"(f : function) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit 0)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) (Kblock k)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f Sskip k sp e m).","conclusion":"wt_state (State f Sskip k sp e m)","hypotheses":"(f : function) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit 0)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) (Kblock k)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_CONT.\neconstructor; eauto using wt_Sskip.\ninv H."},{"statement":"(f : function) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit 0)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H2 : wt_cont env (sig_res (fn_sig f)) k) : wt_state (State f Sskip k sp e m).","conclusion":"wt_state (State f Sskip k sp e m)","hypotheses":"(f : function) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit 0)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H2 : wt_cont env (sig_res (fn_sig f)) k)","proofString":"econstructor; eauto using wt_Sskip."},{"statement":"(f : function) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit 0)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H : wt_cont_call (Kblock k) (sig_res (fn_sig f))) : wt_state (State f Sskip k sp e m).","conclusion":"wt_state (State f Sskip k sp e m)","hypotheses":"(f : function) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit 0)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H : wt_cont_call (Kblock k) (sig_res (fn_sig f)))","proofString":"inv H."},{"statement":"(f : function) (n : nat) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit (S n))) (WT_CONT : wt_cont env (sig_res (fn_sig f)) (Kblock k)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f (Sexit n) k sp e m).","conclusion":"wt_state (State f (Sexit n) k sp e m)","hypotheses":"(f : function) (n : nat) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit (S n))) (WT_CONT : wt_cont env (sig_res (fn_sig f)) (Kblock k)) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_CONT.\neconstructor; eauto using wt_Sexit.\ninv H."},{"statement":"(f : function) (n : nat) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit (S n))) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H2 : wt_cont env (sig_res (fn_sig f)) k) : wt_state (State f (Sexit n) k sp e m).","conclusion":"wt_state (State f (Sexit n) k sp e m)","hypotheses":"(f : function) (n : nat) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit (S n))) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H2 : wt_cont env (sig_res (fn_sig f)) k)","proofString":"econstructor; eauto using wt_Sexit."},{"statement":"(f : function) (n : nat) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit (S n))) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H : wt_cont_call (Kblock k) (sig_res (fn_sig f))) : wt_state (State f (Sexit n) k sp e m).","conclusion":"wt_state (State f (Sexit n) k sp e m)","hypotheses":"(f : function) (n : nat) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sexit (S n))) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H : wt_cont_call (Kblock k) (sig_res (fn_sig f)))","proofString":"inv H."},{"statement":"(f : function) (islong : bool) (a : expr) (cases : list (Z * nat)) (default : nat) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (n : Z) (H : eval_expr ge sp e m a v) (H0 : Switch.switch_argument islong v n) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sswitch islong a cases default)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f (Sexit (Switch.switch_target n default cases)) k sp e m).","conclusion":"wt_state (State f (Sexit (Switch.switch_target n default cases)) k sp e m)","hypotheses":"(f : function) (islong : bool) (a : expr) (cases : list (Z * nat)) (default : nat) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (v : val) (n : Z) (H : eval_expr ge sp e m a v) (H0 : Switch.switch_argument islong v n) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sswitch islong a cases default)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"econstructor; eauto using wt_Sexit."},{"statement":"(f : function) (k : cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sreturn None)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (Returnstate Vundef (call_cont k) m').","conclusion":"wt_state (Returnstate Vundef (call_cont k) m')","hypotheses":"(f : function) (k : cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sreturn None)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_STMT.\neconstructor; eauto using call_cont_wt.\nexact I."},{"statement":"(f : function) (k : cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (Returnstate Vundef (call_cont k) m').","conclusion":"wt_state (Returnstate Vundef (call_cont k) m')","hypotheses":"(f : function) (k : cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"econstructor; eauto using call_cont_wt.\nexact I."},{"statement":"(f : function) (k : cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : Val.has_type Vundef (proj_xtype (sig_res (fn_sig f))).","conclusion":"Val.has_type Vundef (proj_xtype (sig_res (fn_sig f)))","hypotheses":"(f : function) (k : cont) (sp : block) (e : Cminor.env) (m m' : mem) (H : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"exact I."},{"statement":"(f : function) (a : expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sreturn (Some a))) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (Returnstate v (call_cont k) m').","conclusion":"wt_state (Returnstate v (call_cont k) m')","hypotheses":"(f : function) (a : expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sreturn (Some a))) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_STMT.\neconstructor; eauto using call_cont_wt.\neapply wt_eval_expr; eauto."},{"statement":"(f : function) (a : expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H2 : wt_expr env a (proj_xtype (sig_res (fn_sig f)))) : wt_state (Returnstate v (call_cont k) m').","conclusion":"wt_state (Returnstate v (call_cont k) m')","hypotheses":"(f : function) (a : expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H2 : wt_expr env a (proj_xtype (sig_res (fn_sig f))))","proofString":"econstructor; eauto using call_cont_wt.\neapply wt_eval_expr; eauto."},{"statement":"(f : function) (a : expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H2 : wt_expr env a (proj_xtype (sig_res (fn_sig f)))) : Val.has_type v (proj_xtype (sig_res (fn_sig f))).","conclusion":"Val.has_type v (proj_xtype (sig_res (fn_sig f)))","hypotheses":"(f : function) (a : expr) (k : cont) (sp : block) (e : Cminor.env) (m : mem) (v : val) (m' : mem) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a v) (H0 : Mem.free m sp 0 (fn_stackspace f) = Some m') (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H2 : wt_expr env a (proj_xtype (sig_res (fn_sig f))))","proofString":"eapply wt_eval_expr; eauto."},{"statement":"(f : function) (lbl : label) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Slabel lbl s)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f s k sp e m).","conclusion":"wt_state (State f s k sp e m)","hypotheses":"(f : function) (lbl : label) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Slabel lbl s)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inv WT_STMT.\neconstructor; eauto."},{"statement":"(f : function) (lbl : label) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : wt_stmt env (sig_res (fn_sig f)) s) : wt_state (State f s k sp e m).","conclusion":"wt_state (State f s k sp e m)","hypotheses":"(f : function) (lbl : label) (s : stmt) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (env : typenv) (WT_FN : wt_function env f) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : wt_stmt env (sig_res (fn_sig f)) s)","proofString":"econstructor; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) : wt_state (State f s' k' sp e m).","conclusion":"wt_state (State f s' k' sp e m)","hypotheses":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e)","proofString":"inversion WT_FN; subst.\nassert (WT_CK: wt_cont env (sig_res (fn_sig f)) (call_cont k)).\nconstructor.\neapply call_cont_wt; eauto.\ngeneralize (wt_find_label _ _ lbl _ _ H2 WT_CK).\nrewrite H.\nintros [WT_STMT' WT_CONT'].\neconstructor; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) : wt_state (State f s' k' sp e m).","conclusion":"wt_state (State f s' k' sp e m)","hypotheses":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f))","proofString":"assert (WT_CK: wt_cont env (sig_res (fn_sig f)) (call_cont k)).\nconstructor.\neapply call_cont_wt; eauto.\ngeneralize (wt_find_label _ _ lbl _ _ H2 WT_CK).\nrewrite H.\nintros [WT_STMT' WT_CONT'].\neconstructor; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) : wt_cont env (sig_res (fn_sig f)) (call_cont k).","conclusion":"wt_cont env (sig_res (fn_sig f)) (call_cont k)","hypotheses":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f))","proofString":"constructor.\neapply call_cont_wt; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) : wt_cont_call (call_cont k) (sig_res (fn_sig f)).","conclusion":"wt_cont_call (call_cont k) (sig_res (fn_sig f))","hypotheses":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f))","proofString":"eapply call_cont_wt; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (WT_CK : wt_cont env (sig_res (fn_sig f)) (call_cont k)) : wt_state (State f s' k' sp e m).","conclusion":"wt_state (State f s' k' sp e m)","hypotheses":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (WT_CK : wt_cont env (sig_res (fn_sig f)) (call_cont k))","proofString":"generalize (wt_find_label _ _ lbl _ _ H2 WT_CK).\nrewrite H.\nintros [WT_STMT' WT_CONT'].\neconstructor; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (WT_CK : wt_cont env (sig_res (fn_sig f)) (call_cont k)) : match find_label lbl (fn_body f) (call_cont k) with\n| Some (s'0, k'0) =>\n    wt_stmt env (sig_res (fn_sig f)) s'0 /\\\n    wt_cont env (sig_res (fn_sig f)) k'0\n| None => True\nend -> wt_state (State f s' k' sp e m).","conclusion":"match find_label lbl (fn_body f) (call_cont k) with\n| Some (s'0, k'0) =>\n    wt_stmt env (sig_res (fn_sig f)) s'0 /\\\n    wt_cont env (sig_res (fn_sig f)) k'0\n| None => True\nend -> wt_state (State f s' k' sp e m)","hypotheses":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (WT_CK : wt_cont env (sig_res (fn_sig f)) (call_cont k))","proofString":"rewrite H.\nintros [WT_STMT' WT_CONT'].\neconstructor; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (WT_CK : wt_cont env (sig_res (fn_sig f)) (call_cont k)) : wt_stmt env (sig_res (fn_sig f)) s' /\\ wt_cont env (sig_res (fn_sig f)) k' ->\nwt_state (State f s' k' sp e m).","conclusion":"wt_stmt env (sig_res (fn_sig f)) s' /\\ wt_cont env (sig_res (fn_sig f)) k' ->\nwt_state (State f s' k' sp e m)","hypotheses":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (WT_CK : wt_cont env (sig_res (fn_sig f)) (call_cont k))","proofString":"intros [WT_STMT' WT_CONT'].\neconstructor; eauto."},{"statement":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (WT_CK : wt_cont env (sig_res (fn_sig f)) (call_cont k)) (WT_STMT' : wt_stmt env (sig_res (fn_sig f)) s') (WT_CONT' : wt_cont env (sig_res (fn_sig f)) k') : wt_state (State f s' k' sp e m).","conclusion":"wt_state (State f s' k' sp e m)","hypotheses":"(f : function) (lbl : label) (k : cont) (sp : val) (e : Cminor.env) (m : mem) (s' : stmt) (k' : cont) (H : find_label lbl (fn_body f) (call_cont k) = Some (s', k')) (env : typenv) (WT_FN : wt_function env f) (WT_STMT : wt_stmt env (sig_res (fn_sig f)) (Sgoto lbl)) (WT_CONT : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (H0 : type_function f = OK env) (H1 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H2 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (WT_CK : wt_cont env (sig_res (fn_sig f)) (call_cont k)) (WT_STMT' : wt_stmt env (sig_res (fn_sig f)) s') (WT_CONT' : wt_cont env (sig_res (fn_sig f)) k')","proofString":"econstructor; eauto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_FD : wt_fundef (Internal f)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) : wt_state\n  (State f (fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (fn_vars f) (set_params vargs (fn_params f))) m').","conclusion":"wt_state\n  (State f (fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (fn_vars f) (set_params vargs (fn_params f))) m')","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_FD : wt_fundef (Internal f)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f))))","proofString":"inv WT_FD.\ninversion H2; subst.\neconstructor; eauto.\nconstructor; auto.\napply wt_env_set_locals.\napply wt_env_set_params.\nrewrite H3; auto.\nred; intros.\napply def_set_locals.\ndestruct H5; auto.\nleft; apply def_set_params; auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) : wt_state\n  (State f (fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (fn_vars f) (set_params vargs (fn_params f))) m').","conclusion":"wt_state\n  (State f (fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (fn_vars f) (set_params vargs (fn_params f))) m')","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f)","proofString":"inversion H2; subst.\neconstructor; eauto.\nconstructor; auto.\napply wt_env_set_locals.\napply wt_env_set_params.\nrewrite H3; auto.\nred; intros.\napply def_set_locals.\ndestruct H5; auto.\nleft; apply def_set_params; auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) : wt_state\n  (State f (fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (fn_vars f) (set_params vargs (fn_params f))) m').","conclusion":"wt_state\n  (State f (fn_body f) k (Vptr sp Ptrofs.zero)\n     (set_locals (fn_vars f) (set_params vargs (fn_params f))) m')","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f))","proofString":"econstructor; eauto.\nconstructor; auto.\napply wt_env_set_locals.\napply wt_env_set_params.\nrewrite H3; auto.\nred; intros.\napply def_set_locals.\ndestruct H5; auto.\nleft; apply def_set_params; auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) : wt_cont env (sig_res (fn_sig f)) k.","conclusion":"wt_cont env (sig_res (fn_sig f)) k","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f))","proofString":"constructor; auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) : wt_env env (set_locals (fn_vars f) (set_params vargs (fn_params f))).","conclusion":"wt_env env (set_locals (fn_vars f) (set_params vargs (fn_params f)))","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f))","proofString":"apply wt_env_set_locals.\napply wt_env_set_params.\nrewrite H3; auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) : wt_env env (set_params vargs (fn_params f)).","conclusion":"wt_env env (set_params vargs (fn_params f))","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f))","proofString":"apply wt_env_set_params.\nrewrite H3; auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) : Val.has_type_list vargs (map env (fn_params f)).","conclusion":"Val.has_type_list vargs (map env (fn_params f))","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f))","proofString":"rewrite H3; auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) : def_env f (set_locals (fn_vars f) (set_params vargs (fn_params f))).","conclusion":"def_env f (set_locals (fn_vars f) (set_params vargs (fn_params f)))","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f))","proofString":"red; intros.\napply def_set_locals.\ndestruct H5; auto.\nleft; apply def_set_params; auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (id : ident) (H5 : In id (fn_params f) \\/ In id (fn_vars f)) : exists v : val,\n  (set_locals (fn_vars f) (set_params vargs (fn_params f))) ! id = Some v.","conclusion":"exists v : val,\n  (set_locals (fn_vars f) (set_params vargs (fn_params f))) ! id = Some v","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (id : ident) (H5 : In id (fn_params f) \\/ In id (fn_vars f))","proofString":"apply def_set_locals.\ndestruct H5; auto.\nleft; apply def_set_params; auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (id : ident) (H5 : In id (fn_params f) \\/ In id (fn_vars f)) : (exists v : val, (set_params vargs (fn_params f)) ! id = Some v) \\/\nIn id (fn_vars f).","conclusion":"(exists v : val, (set_params vargs (fn_params f)) ! id = Some v) \\/\nIn id (fn_vars f)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (id : ident) (H5 : In id (fn_params f) \\/ In id (fn_vars f))","proofString":"destruct H5; auto.\nleft; apply def_set_params; auto."},{"statement":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (id : ident) (H5 : In id (fn_params f)) : (exists v : val, (set_params vargs (fn_params f)) ! id = Some v) \\/\nIn id (fn_vars f).","conclusion":"(exists v : val, (set_params vargs (fn_params f)) ! id = Some v) \\/\nIn id (fn_vars f)","hypotheses":"(f : function) (vargs : list val) (k : cont) (m : mem) (m' : Mem.mem') (sp : block) (H : Val.has_argtype_list vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m', sp)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (Internal f)))) (WT_CONT : wt_cont_call k (sig_res (funsig (Internal f)))) (env : typenv) (H2 : wt_function env f) (H1 : type_function f = OK env) (H3 : map env (fn_params f) = proj_sig_args (fn_sig f)) (H4 : wt_stmt env (sig_res (fn_sig f)) (fn_body f)) (id : ident) (H5 : In id (fn_params f))","proofString":"left; apply def_set_params; auto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WT_FD : wt_fundef (External ef)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (External ef)))) (WT_CONT : wt_cont_call k (sig_res (funsig (External ef)))) : wt_state (Returnstate vres k m').","conclusion":"wt_state (Returnstate vres k m')","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WT_FD : wt_fundef (External ef)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (External ef)))) (WT_CONT : wt_cont_call k (sig_res (funsig (External ef))))","proofString":"exploit external_call_well_typed; eauto.\nintros.\neconstructor; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WT_FD : wt_fundef (External ef)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (External ef)))) (WT_CONT : wt_cont_call k (sig_res (funsig (External ef)))) : Val.has_type vres (proj_sig_res (ef_sig ef)) ->\nwt_state (Returnstate vres k m').","conclusion":"Val.has_type vres (proj_sig_res (ef_sig ef)) ->\nwt_state (Returnstate vres k m')","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WT_FD : wt_fundef (External ef)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (External ef)))) (WT_CONT : wt_cont_call k (sig_res (funsig (External ef))))","proofString":"intros.\neconstructor; eauto."},{"statement":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WT_FD : wt_fundef (External ef)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (External ef)))) (WT_CONT : wt_cont_call k (sig_res (funsig (External ef)))) (H0 : Val.has_type vres (proj_sig_res (ef_sig ef))) : wt_state (Returnstate vres k m').","conclusion":"wt_state (Returnstate vres k m')","hypotheses":"(ef : external_function) (vargs : list val) (k : cont) (m : mem) (t : trace) (vres : val) (m' : mem) (H : external_call ef ge vargs m t vres m') (WT_FD : wt_fundef (External ef)) (WT_ARGS : Val.has_type_list vargs (proj_sig_args (funsig (External ef)))) (WT_CONT : wt_cont_call k (sig_res (funsig (External ef)))) (H0 : Val.has_type vres (proj_sig_res (ef_sig ef)))","proofString":"econstructor; eauto."},{"statement":"(v : val) (optid : option ident) (f : function) (sp : val) (e : env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (WT_CONT : wt_cont_call (Kcall optid f sp e k) tret) : wt_state (State f Sskip k sp (set_optvar optid v e) m).","conclusion":"wt_state (State f Sskip k sp (set_optvar optid v e) m)","hypotheses":"(v : val) (optid : option ident) (f : function) (sp : val) (e : env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (WT_CONT : wt_cont_call (Kcall optid f sp e k) tret)","proofString":"inv WT_CONT.\neconstructor; eauto using wt_Sskip.\nred in WT_DEST.\ndestruct optid.\nrewrite WT_DEST in WT_RES.\napply wt_env_assign; auto.\nassumption.\ndestruct optid.\napply def_env_assign; auto.\nassumption."},{"statement":"(v : val) (optid : option ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : wt_opt_assign env optid tret) : wt_state (State f Sskip k sp (set_optvar optid v e) m).","conclusion":"wt_state (State f Sskip k sp (set_optvar optid v e) m)","hypotheses":"(v : val) (optid : option ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : wt_opt_assign env optid tret)","proofString":"econstructor; eauto using wt_Sskip.\nred in WT_DEST.\ndestruct optid.\nrewrite WT_DEST in WT_RES.\napply wt_env_assign; auto.\nassumption.\ndestruct optid.\napply def_env_assign; auto.\nassumption."},{"statement":"(v : val) (optid : option ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : wt_opt_assign env optid tret) : wt_env env (set_optvar optid v e).","conclusion":"wt_env env (set_optvar optid v e)","hypotheses":"(v : val) (optid : option ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : wt_opt_assign env optid tret)","proofString":"red in WT_DEST.\ndestruct optid.\nrewrite WT_DEST in WT_RES.\napply wt_env_assign; auto.\nassumption."},{"statement":"(v : val) (optid : option ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : match optid with\n| Some id => proj_xtype tret = env id\n| None => True\nend) : wt_env env (set_optvar optid v e).","conclusion":"wt_env env (set_optvar optid v e)","hypotheses":"(v : val) (optid : option ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : match optid with\n| Some id => proj_xtype tret = env id\n| None => True\nend)","proofString":"destruct optid.\nrewrite WT_DEST in WT_RES.\napply wt_env_assign; auto.\nassumption."},{"statement":"(v : val) (i : ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : proj_xtype tret = env i) : wt_env env (set_optvar (Some i) v e).","conclusion":"wt_env env (set_optvar (Some i) v e)","hypotheses":"(v : val) (i : ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : proj_xtype tret = env i)","proofString":"rewrite WT_DEST in WT_RES.\napply wt_env_assign; auto."},{"statement":"(v : val) (i : ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (env : typenv) (WT_RES : Val.has_type v (env i)) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : proj_xtype tret = env i) : wt_env env (set_optvar (Some i) v e).","conclusion":"wt_env env (set_optvar (Some i) v e)","hypotheses":"(v : val) (i : ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (env : typenv) (WT_RES : Val.has_type v (env i)) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : proj_xtype tret = env i)","proofString":"apply wt_env_assign; auto."},{"statement":"(v : val) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : True) : wt_env env (set_optvar None v e).","conclusion":"wt_env env (set_optvar None v e)","hypotheses":"(v : val) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : True)","proofString":"assumption."},{"statement":"(v : val) (optid : option ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : wt_opt_assign env optid tret) : def_env f (set_optvar optid v e).","conclusion":"def_env f (set_optvar optid v e)","hypotheses":"(v : val) (optid : option ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : wt_opt_assign env optid tret)","proofString":"destruct optid.\napply def_env_assign; auto.\nassumption."},{"statement":"(v : val) (i : ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : wt_opt_assign env (Some i) tret) : def_env f (set_optvar (Some i) v e).","conclusion":"def_env f (set_optvar (Some i) v e)","hypotheses":"(v : val) (i : ident) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : wt_opt_assign env (Some i) tret)","proofString":"apply def_env_assign; auto."},{"statement":"(v : val) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : wt_opt_assign env None tret) : def_env f (set_optvar None v e).","conclusion":"def_env f (set_optvar None v e)","hypotheses":"(v : val) (f : function) (sp : val) (e : Cminor.env) (k : cont) (m : mem) (tret : xtype) (WT_RES : Val.has_type v (proj_xtype tret)) (env : typenv) (WT_FN : wt_function env f) (WT_CONT0 : wt_cont env (sig_res (fn_sig f)) k) (WT_ENV : wt_env env e) (DEF_ENV : def_env f e) (WT_DEST : wt_opt_assign env None tret)","proofString":"assumption."},{"statement":"(S : state) (H : initial_state p S) : wt_state S.","conclusion":"wt_state S","hypotheses":"(S : state) (H : initial_state p S)","proofString":"inv H.\nconstructor.\neapply Genv.find_funct_ptr_prop; eauto.\nrewrite H3; constructor.\nrewrite H3; constructor."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) : Val.has_type_list nil (proj_sig_args (funsig f)).","conclusion":"Val.has_type_list nil (proj_sig_args (funsig f))","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main)","proofString":"rewrite H3; constructor."},{"statement":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) : wt_cont_call Kstop (sig_res (funsig f)).","conclusion":"wt_cont_call Kstop (sig_res (funsig f))","hypotheses":"(b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem p = Some m0) (H1 : Genv.find_symbol ge0 (prog_main p) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main)","proofString":"rewrite H3; constructor."},{"statement":"forall (f : function) (id : positive) (x : unit),\n(fold_left (fun (ki : known_idents) (id0 : ident) => PTree.set id0 tt ki)\n   (fn_vars f)\n   (fold_left (fun (ki : known_idents) (id0 : ident) => PTree.set id0 tt ki)\n      (fn_params f) (PTree.empty unit))) ! id = Some x ->\nIn id (fn_params f) \\/ In id (fn_vars f).","conclusion":"forall (f : function) (id : positive) (x : unit),\n(fold_left (fun (ki : known_idents) (id0 : ident) => PTree.set id0 tt ki)\n   (fn_vars f)\n   (fold_left (fun (ki : known_idents) (id0 : ident) => PTree.set id0 tt ki)\n      (fn_params f) (PTree.empty unit))) ! id = Some x ->\nIn id (fn_params f) \\/ In id (fn_vars f)","hypotheses":"","proofString":"set (add := fun (ki: known_idents) (id: ident) => PTree.set id tt ki).\nintros.\nassert (REC: forall l ki, (fold_left add l ki)!id = Some x -> In id l \\/ ki!id = Some x).\ninduction l as [ | i l ]; simpl; intros.\nauto.\napply IHl in H0.\ndestruct H0; auto.\nunfold add in H0; rewrite PTree.gsspec in H0.\ndestruct (peq id i); auto.\napply REC in H.\ndestruct H; auto.\napply REC in H.\ndestruct H; auto.\nrewrite PTree.gempty in H; discriminate."},{"statement":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : (fold_left add (fn_vars f) (fold_left add (fn_params f) (PTree.empty unit)))\n! id = Some x) (ki : known_idents) (H0 : ki ! id = Some x) : False \\/ ki ! id = Some x.","conclusion":"False \\/ ki ! id = Some x","hypotheses":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : (fold_left add (fn_vars f) (fold_left add (fn_params f) (PTree.empty unit)))\n! id = Some x) (ki : known_idents) (H0 : ki ! id = Some x)","proofString":"auto."},{"statement":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : (fold_left add (fn_vars f) (fold_left add (fn_params f) (PTree.empty unit)))\n! id = Some x) (i : ident) (l : list ident) (IHl : forall ki0 : known_idents,\n(fold_left add l ki0) ! id = Some x -> In id l \\/ ki0 ! id = Some x) (ki : known_idents) (H0 : (if peq id i then Some tt else ki ! id) = Some x) : (i = id \\/ In id l) \\/ ki ! id = Some x.","conclusion":"(i = id \\/ In id l) \\/ ki ! id = Some x","hypotheses":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : (fold_left add (fn_vars f) (fold_left add (fn_params f) (PTree.empty unit)))\n! id = Some x) (i : ident) (l : list ident) (IHl : forall ki0 : known_idents,\n(fold_left add l ki0) ! id = Some x -> In id l \\/ ki0 ! id = Some x) (ki : known_idents) (H0 : (if peq id i then Some tt else ki ! id) = Some x)","proofString":"destruct (peq id i); auto."},{"statement":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : (fold_left add (fn_vars f) (fold_left add (fn_params f) (PTree.empty unit)))\n! id = Some x) (REC : forall (l : list ident) (ki : known_idents),\n(fold_left add l ki) ! id = Some x -> In id l \\/ ki ! id = Some x) : In id (fn_params f) \\/ In id (fn_vars f).","conclusion":"In id (fn_params f) \\/ In id (fn_vars f)","hypotheses":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : (fold_left add (fn_vars f) (fold_left add (fn_params f) (PTree.empty unit)))\n! id = Some x) (REC : forall (l : list ident) (ki : known_idents),\n(fold_left add l ki) ! id = Some x -> In id l \\/ ki ! id = Some x)","proofString":"apply REC in H.\ndestruct H; auto.\napply REC in H.\ndestruct H; auto.\nrewrite PTree.gempty in H; discriminate."},{"statement":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : In id (fn_vars f) \\/\n(fold_left add (fn_params f) (PTree.empty unit)) ! id = Some x) (REC : forall (l : list ident) (ki : known_idents),\n(fold_left add l ki) ! id = Some x -> In id l \\/ ki ! id = Some x) : In id (fn_params f) \\/ In id (fn_vars f).","conclusion":"In id (fn_params f) \\/ In id (fn_vars f)","hypotheses":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : In id (fn_vars f) \\/\n(fold_left add (fn_params f) (PTree.empty unit)) ! id = Some x) (REC : forall (l : list ident) (ki : known_idents),\n(fold_left add l ki) ! id = Some x -> In id l \\/ ki ! id = Some x)","proofString":"destruct H; auto.\napply REC in H.\ndestruct H; auto.\nrewrite PTree.gempty in H; discriminate."},{"statement":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : (fold_left add (fn_params f) (PTree.empty unit)) ! id = Some x) (REC : forall (l : list ident) (ki : known_idents),\n(fold_left add l ki) ! id = Some x -> In id l \\/ ki ! id = Some x) : In id (fn_params f) \\/ In id (fn_vars f).","conclusion":"In id (fn_params f) \\/ In id (fn_vars f)","hypotheses":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : (fold_left add (fn_params f) (PTree.empty unit)) ! id = Some x) (REC : forall (l : list ident) (ki : known_idents),\n(fold_left add l ki) ! id = Some x -> In id l \\/ ki ! id = Some x)","proofString":"apply REC in H.\ndestruct H; auto.\nrewrite PTree.gempty in H; discriminate."},{"statement":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : In id (fn_params f) \\/ (PTree.empty unit) ! id = Some x) (REC : forall (l : list ident) (ki : known_idents),\n(fold_left add l ki) ! id = Some x -> In id l \\/ ki ! id = Some x) : In id (fn_params f) \\/ In id (fn_vars f).","conclusion":"In id (fn_params f) \\/ In id (fn_vars f)","hypotheses":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : In id (fn_params f) \\/ (PTree.empty unit) ! id = Some x) (REC : forall (l : list ident) (ki : known_idents),\n(fold_left add l ki) ! id = Some x -> In id l \\/ ki ! id = Some x)","proofString":"destruct H; auto.\nrewrite PTree.gempty in H; discriminate."},{"statement":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : (PTree.empty unit) ! id = Some x) (REC : forall (l : list ident) (ki : known_idents),\n(fold_left add l ki) ! id = Some x -> In id l \\/ ki ! id = Some x) : In id (fn_params f) \\/ In id (fn_vars f).","conclusion":"In id (fn_params f) \\/ In id (fn_vars f)","hypotheses":"(add : known_idents -> ident -> PTree.tree unit) (f : function) (id : positive) (x : unit) (H : (PTree.empty unit) ! id = Some x) (REC : forall (l : list ident) (ki : known_idents),\n(fold_left add l ki) ! id = Some x -> In id l \\/ ki ! id = Some x)","proofString":"rewrite PTree.gempty in H; discriminate."},{"statement":"(f : function) (id : ident) (H : match (known_id f) ! id with\n| Some _ => true\n| None => false\nend = true) : In id (fn_params f) \\/ In id (fn_vars f).","conclusion":"In id (fn_params f) \\/ In id (fn_vars f)","hypotheses":"(f : function) (id : ident) (H : match (known_id f) ! id with\n| Some _ => true\n| None => false\nend = true)","proofString":"destruct (known_id f)!id eqn:E; try discriminate.\neapply known_id_sound_1; eauto."},{"statement":"(f : function) (id : ident) (u : unit) (E : (known_id f) ! id = Some u) (H : true = true) : In id (fn_params f) \\/ In id (fn_vars f).","conclusion":"In id (fn_params f) \\/ In id (fn_vars f)","hypotheses":"(f : function) (id : ident) (u : unit) (E : (known_id f) ! id = Some u) (H : true = true)","proofString":"eapply known_id_sound_1; eauto."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (i : ident) (H : def_env f e) (H0 : is_known (known_id f) i = true) : exists v : val, eval_expr ge sp e m (Evar i) v.","conclusion":"exists v : val, eval_expr ge sp e m (Evar i) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (i : ident) (H : def_env f e) (H0 : is_known (known_id f) i = true)","proofString":"apply known_id_sound_2 in H0.\ndestruct (H i H0) as [v E].\nexists v; constructor; auto."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (i : ident) (H : def_env f e) (H0 : In i (fn_params f) \\/ In i (fn_vars f)) : exists v : val, eval_expr ge sp e m (Evar i) v.","conclusion":"exists v : val, eval_expr ge sp e m (Evar i) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (i : ident) (H : def_env f e) (H0 : In i (fn_params f) \\/ In i (fn_vars f))","proofString":"destruct (H i H0) as [v E].\nexists v; constructor; auto."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (i : ident) (H : def_env f e) (H0 : In i (fn_params f) \\/ In i (fn_vars f)) (v : val) (E : e ! i = Some v) : exists v0 : val, eval_expr ge sp e m (Evar i) v0.","conclusion":"exists v0 : val, eval_expr ge sp e m (Evar i) v0","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (i : ident) (H : def_env f e) (H0 : In i (fn_params f) \\/ In i (fn_vars f)) (v : val) (E : e ! i = Some v)","proofString":"exists v; constructor; auto."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (c : constant) (H : def_env f e) (H0 : true = true) : exists v : val, eval_expr ge sp e m (Econst c) v.","conclusion":"exists v : val, eval_expr ge sp e m (Econst c) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (c : constant) (H : def_env f e) (H0 : true = true)","proofString":"destruct (eval_constant ge sp c) as [v|] eqn:E.\nexists v; constructor; auto.\ndestruct c; discriminate."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (c : constant) (H : def_env f e) (H0 : true = true) (v : val) (E : eval_constant ge sp c = Some v) : exists v0 : val, eval_expr ge sp e m (Econst c) v0.","conclusion":"exists v0 : val, eval_expr ge sp e m (Econst c) v0","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (c : constant) (H : def_env f e) (H0 : true = true) (v : val) (E : eval_constant ge sp c = Some v)","proofString":"exists v; constructor; auto."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (c : constant) (H : def_env f e) (H0 : true = true) (E : eval_constant ge sp c = None) : exists v : val, eval_expr ge sp e m (Econst c) v.","conclusion":"exists v : val, eval_expr ge sp e m (Econst c) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (c : constant) (H : def_env f e) (H0 : true = true) (E : eval_constant ge sp c = None)","proofString":"destruct c; discriminate."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (u : unary_operation) (a : expr) (IHa : def_env f e ->\nsafe_expr (known_id f) a = true -> exists v : val, eval_expr ge sp e m a v) (H : def_env f e) (H0 : safe_unop u && safe_expr (known_id f) a = true) : exists v : val, eval_expr ge sp e m (Eunop u a) v.","conclusion":"exists v : val, eval_expr ge sp e m (Eunop u a) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (u : unary_operation) (a : expr) (IHa : def_env f e ->\nsafe_expr (known_id f) a = true -> exists v : val, eval_expr ge sp e m a v) (H : def_env f e) (H0 : safe_unop u && safe_expr (known_id f) a = true)","proofString":"InvBooleans.\ndestruct IHa as [v1 E1]; auto.\ndestruct (eval_unop u v1) as [v|] eqn:E.\nexists v; econstructor; eauto.\ndestruct u; discriminate."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (u : unary_operation) (a : expr) (IHa : def_env f e ->\nsafe_expr (known_id f) a = true -> exists v : val, eval_expr ge sp e m a v) (H : def_env f e) (H1 : safe_unop u = true) (H2 : safe_expr (known_id f) a = true) : exists v : val, eval_expr ge sp e m (Eunop u a) v.","conclusion":"exists v : val, eval_expr ge sp e m (Eunop u a) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (u : unary_operation) (a : expr) (IHa : def_env f e ->\nsafe_expr (known_id f) a = true -> exists v : val, eval_expr ge sp e m a v) (H : def_env f e) (H1 : safe_unop u = true) (H2 : safe_expr (known_id f) a = true)","proofString":"destruct IHa as [v1 E1]; auto.\ndestruct (eval_unop u v1) as [v|] eqn:E.\nexists v; econstructor; eauto.\ndestruct u; discriminate."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (u : unary_operation) (a : expr) (H : def_env f e) (H1 : safe_unop u = true) (H2 : safe_expr (known_id f) a = true) (v1 : val) (E1 : eval_expr ge sp e m a v1) : exists v : val, eval_expr ge sp e m (Eunop u a) v.","conclusion":"exists v : val, eval_expr ge sp e m (Eunop u a) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (u : unary_operation) (a : expr) (H : def_env f e) (H1 : safe_unop u = true) (H2 : safe_expr (known_id f) a = true) (v1 : val) (E1 : eval_expr ge sp e m a v1)","proofString":"destruct (eval_unop u v1) as [v|] eqn:E.\nexists v; econstructor; eauto.\ndestruct u; discriminate."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (u : unary_operation) (a : expr) (H : def_env f e) (H1 : safe_unop u = true) (H2 : safe_expr (known_id f) a = true) (v1 : val) (E1 : eval_expr ge sp e m a v1) (v : val) (E : eval_unop u v1 = Some v) : exists v0 : val, eval_expr ge sp e m (Eunop u a) v0.","conclusion":"exists v0 : val, eval_expr ge sp e m (Eunop u a) v0","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (u : unary_operation) (a : expr) (H : def_env f e) (H1 : safe_unop u = true) (H2 : safe_expr (known_id f) a = true) (v1 : val) (E1 : eval_expr ge sp e m a v1) (v : val) (E : eval_unop u v1 = Some v)","proofString":"exists v; econstructor; eauto."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (u : unary_operation) (a : expr) (H : def_env f e) (H1 : safe_unop u = true) (H2 : safe_expr (known_id f) a = true) (v1 : val) (E1 : eval_expr ge sp e m a v1) (E : eval_unop u v1 = None) : exists v : val, eval_expr ge sp e m (Eunop u a) v.","conclusion":"exists v : val, eval_expr ge sp e m (Eunop u a) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (u : unary_operation) (a : expr) (H : def_env f e) (H1 : safe_unop u = true) (H2 : safe_expr (known_id f) a = true) (v1 : val) (E1 : eval_expr ge sp e m a v1) (E : eval_unop u v1 = None)","proofString":"destruct u; discriminate."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (b : binary_operation) (a1 a2 : expr) (IHa1 : def_env f e ->\nsafe_expr (known_id f) a1 = true -> exists v : val, eval_expr ge sp e m a1 v) (IHa2 : def_env f e ->\nsafe_expr (known_id f) a2 = true -> exists v : val, eval_expr ge sp e m a2 v) (H : def_env f e) (H0 : safe_binop b && safe_expr (known_id f) a1 && safe_expr (known_id f) a2 = true) : exists v : val, eval_expr ge sp e m (Ebinop b a1 a2) v.","conclusion":"exists v : val, eval_expr ge sp e m (Ebinop b a1 a2) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (b : binary_operation) (a1 a2 : expr) (IHa1 : def_env f e ->\nsafe_expr (known_id f) a1 = true -> exists v : val, eval_expr ge sp e m a1 v) (IHa2 : def_env f e ->\nsafe_expr (known_id f) a2 = true -> exists v : val, eval_expr ge sp e m a2 v) (H : def_env f e) (H0 : safe_binop b && safe_expr (known_id f) a1 && safe_expr (known_id f) a2 = true)","proofString":"InvBooleans.\ndestruct IHa1 as [v1 E1]; auto.\ndestruct IHa2 as [v2 E2]; auto.\ndestruct (eval_binop b v1 v2 m) as [v|] eqn:E.\nexists v; econstructor; eauto.\ndestruct b; discriminate."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (b : binary_operation) (a1 a2 : expr) (IHa1 : def_env f e ->\nsafe_expr (known_id f) a1 = true -> exists v : val, eval_expr ge sp e m a1 v) (IHa2 : def_env f e ->\nsafe_expr (known_id f) a2 = true -> exists v : val, eval_expr ge sp e m a2 v) (H : def_env f e) (H2 : safe_expr (known_id f) a2 = true) (H0 : safe_binop b = true) (H3 : safe_expr (known_id f) a1 = true) : exists v : val, eval_expr ge sp e m (Ebinop b a1 a2) v.","conclusion":"exists v : val, eval_expr ge sp e m (Ebinop b a1 a2) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (b : binary_operation) (a1 a2 : expr) (IHa1 : def_env f e ->\nsafe_expr (known_id f) a1 = true -> exists v : val, eval_expr ge sp e m a1 v) (IHa2 : def_env f e ->\nsafe_expr (known_id f) a2 = true -> exists v : val, eval_expr ge sp e m a2 v) (H : def_env f e) (H2 : safe_expr (known_id f) a2 = true) (H0 : safe_binop b = true) (H3 : safe_expr (known_id f) a1 = true)","proofString":"destruct IHa1 as [v1 E1]; auto.\ndestruct IHa2 as [v2 E2]; auto.\ndestruct (eval_binop b v1 v2 m) as [v|] eqn:E.\nexists v; econstructor; eauto.\ndestruct b; discriminate."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (b : binary_operation) (a1 a2 : expr) (IHa2 : def_env f e ->\nsafe_expr (known_id f) a2 = true -> exists v : val, eval_expr ge sp e m a2 v) (H : def_env f e) (H2 : safe_expr (known_id f) a2 = true) (H0 : safe_binop b = true) (H3 : safe_expr (known_id f) a1 = true) (v1 : val) (E1 : eval_expr ge sp e m a1 v1) : exists v : val, eval_expr ge sp e m (Ebinop b a1 a2) v.","conclusion":"exists v : val, eval_expr ge sp e m (Ebinop b a1 a2) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (b : binary_operation) (a1 a2 : expr) (IHa2 : def_env f e ->\nsafe_expr (known_id f) a2 = true -> exists v : val, eval_expr ge sp e m a2 v) (H : def_env f e) (H2 : safe_expr (known_id f) a2 = true) (H0 : safe_binop b = true) (H3 : safe_expr (known_id f) a1 = true) (v1 : val) (E1 : eval_expr ge sp e m a1 v1)","proofString":"destruct IHa2 as [v2 E2]; auto.\ndestruct (eval_binop b v1 v2 m) as [v|] eqn:E.\nexists v; econstructor; eauto.\ndestruct b; discriminate."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (b : binary_operation) (a1 a2 : expr) (H : def_env f e) (H2 : safe_expr (known_id f) a2 = true) (H0 : safe_binop b = true) (H3 : safe_expr (known_id f) a1 = true) (v1 : val) (E1 : eval_expr ge sp e m a1 v1) (v2 : val) (E2 : eval_expr ge sp e m a2 v2) : exists v : val, eval_expr ge sp e m (Ebinop b a1 a2) v.","conclusion":"exists v : val, eval_expr ge sp e m (Ebinop b a1 a2) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (b : binary_operation) (a1 a2 : expr) (H : def_env f e) (H2 : safe_expr (known_id f) a2 = true) (H0 : safe_binop b = true) (H3 : safe_expr (known_id f) a1 = true) (v1 : val) (E1 : eval_expr ge sp e m a1 v1) (v2 : val) (E2 : eval_expr ge sp e m a2 v2)","proofString":"destruct (eval_binop b v1 v2 m) as [v|] eqn:E.\nexists v; econstructor; eauto.\ndestruct b; discriminate."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (b : binary_operation) (a1 a2 : expr) (H : def_env f e) (H2 : safe_expr (known_id f) a2 = true) (H0 : safe_binop b = true) (H3 : safe_expr (known_id f) a1 = true) (v1 : val) (E1 : eval_expr ge sp e m a1 v1) (v2 : val) (E2 : eval_expr ge sp e m a2 v2) (v : val) (E : eval_binop b v1 v2 m = Some v) : exists v0 : val, eval_expr ge sp e m (Ebinop b a1 a2) v0.","conclusion":"exists v0 : val, eval_expr ge sp e m (Ebinop b a1 a2) v0","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (b : binary_operation) (a1 a2 : expr) (H : def_env f e) (H2 : safe_expr (known_id f) a2 = true) (H0 : safe_binop b = true) (H3 : safe_expr (known_id f) a1 = true) (v1 : val) (E1 : eval_expr ge sp e m a1 v1) (v2 : val) (E2 : eval_expr ge sp e m a2 v2) (v : val) (E : eval_binop b v1 v2 m = Some v)","proofString":"exists v; econstructor; eauto."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (b : binary_operation) (a1 a2 : expr) (H : def_env f e) (H2 : safe_expr (known_id f) a2 = true) (H0 : safe_binop b = true) (H3 : safe_expr (known_id f) a1 = true) (v1 : val) (E1 : eval_expr ge sp e m a1 v1) (v2 : val) (E2 : eval_expr ge sp e m a2 v2) (E : eval_binop b v1 v2 m = None) : exists v : val, eval_expr ge sp e m (Ebinop b a1 a2) v.","conclusion":"exists v : val, eval_expr ge sp e m (Ebinop b a1 a2) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (b : binary_operation) (a1 a2 : expr) (H : def_env f e) (H2 : safe_expr (known_id f) a2 = true) (H0 : safe_binop b = true) (H3 : safe_expr (known_id f) a1 = true) (v1 : val) (E1 : eval_expr ge sp e m a1 v1) (v2 : val) (E2 : eval_expr ge sp e m a2 v2) (E : eval_binop b v1 v2 m = None)","proofString":"destruct b; discriminate."},{"statement":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (m0 : memory_chunk) (a : expr) (IHa : def_env f e ->\nsafe_expr (known_id f) a = true -> exists v : val, eval_expr ge sp e m a v) (H : def_env f e) (H0 : false = true) : exists v : val, eval_expr ge sp e m (Eload m0 a) v.","conclusion":"exists v : val, eval_expr ge sp e m (Eload m0 a) v","hypotheses":"(ge : genv) (f : function) (sp : val) (e : env) (m : mem) (m0 : memory_chunk) (a : expr) (IHa : def_env f e ->\nsafe_expr (known_id f) a = true -> exists v : val, eval_expr ge sp e m a v) (H : def_env f e) (H0 : false = true)","proofString":"discriminate."}]}