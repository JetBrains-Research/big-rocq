{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/promising2ToImm/src/cert_graph/Cert_co.v","fileSamples":[{"statement":"codom_rel (⦗cert_co_base⦘ ⨾ Grfi ⨾ Grmw)\n⊆₁ codom_rel (⦗I ∪₁ S ∩₁ Tid_ thread⦘ ⨾ (Grfi ⨾ Grmw)＊).","proofString":"rewrite <- rt_unit.\nunfold cert_co_base.\nunfolder.\nins.\ndesc.\nsubst.\ndo 2 eexists.\nsplit; [split; [|by eauto]|]; eauto."},{"statement":"codom_rel (⦗cert_co_base⦘ ⨾ Grfi ⨾ Grmw)\n⊆₁ codom_rel (⦗I ∪₁ S ∩₁ Tid_ thread⦘ ⨾ (Grfi ⨾ Grmw)＊ ⨾ Grfi ⨾ Grmw).","proofString":"unfold cert_co_base.\nunfolder.\nins.\ndesc.\nsubst.\ndo 2 eexists.\nsplit; [split; [|by eauto]|]; eauto."},{"statement":"codom_rel\n  (⦗codom_rel (⦗I ∪₁ S ∩₁ Tid_ thread⦘ ⨾ (Grfi ⨾ Grmw)＊)⦘ ⨾ Grfi ⨾ Grmw)\n⊆₁ codom_rel (⦗I ∪₁ S ∩₁ Tid_ thread⦘ ⨾ (Grfi ⨾ Grmw)＊ ⨾ Grfi ⨾ Grmw).","proofString":"unfolder.\nins.\ndesc.\nsubst.\ndo 2 eexists.\nsplit; [split; [|by eauto]|]; eauto."},{"statement":"forall x : actid,\n(exists x0 : actid,\n   (exists x1 z : actid,\n      (x1 = z /\\ (I x1 \\/ S x1 /\\ tid x1 = thread)) /\\\n      (fun x2 y : actid => exists z0 : actid, Grfi x2 z0 /\\ Grmw z0 y)＊ z x0) /\\\n   (exists z : actid, Grfi x0 z /\\ Grmw z x)) ->\nexists x0 z : actid,\n  (x0 = z /\\ (I x0 \\/ S x0 /\\ tid x0 = thread)) /\\\n  (exists z0 : actid,\n     (fun x1 y : actid => exists z1 : actid, Grfi x1 z1 /\\ Grmw z1 y)＊ z z0 /\\\n     (exists z1 : actid, Grfi z0 z1 /\\ Grmw z1 x)).","proofString":"ins.\ndesc.\nsubst.\ndo 2 eexists.\nsplit; [split; [|by eauto]|]; eauto."},{"statement":"(x : actid) (H : exists x0 : actid,\n  (exists x1 z : actid,\n     (x1 = z /\\ (I x1 \\/ S x1 /\\ tid x1 = thread)) /\\\n     (fun x2 y : actid => exists z0 : actid, Grfi x2 z0 /\\ Grmw z0 y)＊ z x0) /\\\n  (exists z : actid, Grfi x0 z /\\ Grmw z x)) : exists x0 z : actid,\n  (x0 = z /\\ (I x0 \\/ S x0 /\\ tid x0 = thread)) /\\\n  (exists z0 : actid,\n     (fun x1 y : actid => exists z1 : actid, Grfi x1 z1 /\\ Grmw z1 y)＊ z z0 /\\\n     (exists z1 : actid, Grfi z0 z1 /\\ Grmw z1 x)).","proofString":"desc.\nsubst.\ndo 2 eexists.\nsplit; [split; [|by eauto]|]; eauto."},{"statement":"(x x0 x1 z0 : actid) (H : x1 = z0) (H3 : I x1 \\/ S x1 /\\ tid x1 = thread) (H2 : (fun x2 y : actid => exists z1 : actid, Grfi x2 z1 /\\ Grmw z1 y)＊ z0 x0) (z : actid) (H0 : Grfi x0 z) (H1 : Grmw z x) : exists x2 z1 : actid,\n  (x2 = z1 /\\ (I x2 \\/ S x2 /\\ tid x2 = thread)) /\\\n  (exists z2 : actid,\n     (fun x3 y : actid => exists z3 : actid, Grfi x3 z3 /\\ Grmw z3 y)＊ z1 z2 /\\\n     (exists z3 : actid, Grfi z2 z3 /\\ Grmw z3 x)).","proofString":"subst.\ndo 2 eexists.\nsplit; [split; [|by eauto]|]; eauto."},{"statement":"(x x0 z0 : actid) (H3 : I z0 \\/ S z0 /\\ tid z0 = thread) (H2 : (fun x1 y : actid => exists z1 : actid, Grfi x1 z1 /\\ Grmw z1 y)＊ z0 x0) (z : actid) (H0 : Grfi x0 z) (H1 : Grmw z x) : exists x1 z1 : actid,\n  (x1 = z1 /\\ (I x1 \\/ S x1 /\\ tid x1 = thread)) /\\\n  (exists z2 : actid,\n     (fun x2 y : actid => exists z3 : actid, Grfi x2 z3 /\\ Grmw z3 y)＊ z1 z2 /\\\n     (exists z3 : actid, Grfi z2 z3 /\\ Grmw z3 x)).","proofString":"do 2 eexists.\nsplit; [split; [|by eauto]|]; eauto."},{"statement":"I ⊆₁ codom_rel (⦗I ∪₁ S ∩₁ Tid_ thread⦘ ⨾ (Grfi ⨾ Grmw)＊).","proofString":"rewrite rtE.\nbasic_solver 10."},{"statement":"I\n⊆₁ codom_rel\n     (⦗I ∪₁ S ∩₁ Tid_ thread⦘ ⨾ (⦗fun _ : actid => True⦘ ∪ (Grfi ⨾ Grmw)⁺)).","proofString":"basic_solver 10."},{"statement":"I ∪₁ S ∩₁ Tid_ thread ⊆₁ codom_rel (⦗I ∪₁ S ∩₁ Tid_ thread⦘ ⨾ (Grfi ⨾ Grmw)＊).","proofString":"clear.\nrewrite rtE.\nbasic_solver 10."},{"statement":"I ∪₁ S ∩₁ Tid_ thread ⊆₁ codom_rel (⦗I ∪₁ S ∩₁ Tid_ thread⦘ ⨾ (Grfi ⨾ Grmw)＊).","proofString":"rewrite rtE.\nbasic_solver 10."},{"statement":"I ∪₁ S ∩₁ Tid_ thread\n⊆₁ codom_rel\n     (⦗I ∪₁ S ∩₁ Tid_ thread⦘ ⨾ (⦗fun _ : actid => True⦘ ∪ (Grfi ⨾ Grmw)⁺)).","proofString":"basic_solver 10."},{"statement":"immediate cert_co\n⊆ ⦗cert_co_base ∪₁ set_compl cert_co_base⦘ ⨾ immediate cert_co.","proofString":"rewrite set_compl_union_id.\nunfold set_full.\nby rewrite seq_id_l."},{"statement":"immediate cert_co ⊆ ⦗⊤₁⦘ ⨾ immediate cert_co.","proofString":"unfold set_full.\nby rewrite seq_id_l."},{"statement":"immediate cert_co ⊆ ⦗fun _ : actid => True⦘ ⨾ immediate cert_co.","proofString":"by rewrite seq_id_l."},{"statement":"⦗set_compl cert_co_base⦘ ⨾ Gsb ⊆ Gsb.","proofString":"clear.\nbasic_solver."},{"statement":"⦗set_compl cert_co_base⦘ ⨾ Gsb ⊆ Gsb.","proofString":"basic_solver."},{"statement":"(⦗set_compl cert_co_base⦘ ⨾ ⦗cert_co_base⦘) ⨾ immediate cert_co ⊆ Gsb.","proofString":"rewrite <- id_inter.\nrewrite set_interC.\nrewrite <- set_minusE.\nclear; basic_solver."},{"statement":"⦗set_compl cert_co_base ∩₁ cert_co_base⦘ ⨾ immediate cert_co ⊆ Gsb.","proofString":"rewrite set_interC.\nrewrite <- set_minusE.\nclear; basic_solver."},{"statement":"⦗cert_co_base ∩₁ set_compl cert_co_base⦘ ⨾ immediate cert_co ⊆ Gsb.","proofString":"rewrite <- set_minusE.\nclear; basic_solver."},{"statement":"⦗cert_co_base \\₁ cert_co_base⦘ ⨾ immediate cert_co ⊆ Gsb.","proofString":"clear; basic_solver."},{"statement":"I \\₁ Tid_ thread\n⊆₁ codom_rel\n     (⦗I ∪₁ S ∩₁ Tid_ thread⦘ ⨾ (⦗fun _ : actid => True⦘ ∪ (Grfi ⨾ Grmw)⁺)) \\₁\n   E ∩₁ W ∩₁ Tid_ thread.","proofString":"clear.\nintros x [HH BB].\nsplit; [basic_solver 10|].\nunfolder.\nintros AA.\ndesf."},{"statement":"I \\₁ Tid_ thread\n⊆₁ codom_rel\n     (⦗I ∪₁ S ∩₁ Tid_ thread⦘ ⨾ (⦗fun _ : actid => True⦘ ∪ (Grfi ⨾ Grmw)⁺)) \\₁\n   E ∩₁ W ∩₁ Tid_ thread.","proofString":"intros x [HH BB].\nsplit; [basic_solver 10|].\nunfolder.\nintros AA.\ndesf."},{"statement":"(x : actid) (HH : I x) (BB : tid x <> thread) : (codom_rel\n   (⦗I ∪₁ S ∩₁ Tid_ thread⦘ ⨾ (⦗fun _ : actid => True⦘ ∪ (Grfi ⨾ Grmw)⁺)) \\₁\n E ∩₁ W ∩₁ Tid_ thread) x.","proofString":"split; [basic_solver 10|].\nunfolder.\nintros AA.\ndesf."},{"statement":"(x : actid) (HH : I x) (BB : tid x <> thread) : ~ (E ∩₁ W ∩₁ Tid_ thread) x.","proofString":"unfolder.\nintros AA.\ndesf."},{"statement":"(x : actid) (HH : I x) (BB : tid x <> thread) : ~ ((E x /\\ is_w Glab x) /\\ tid x = thread).","proofString":"intros AA.\ndesf."},{"statement":"(x : actid) (HH : I x) (BB : tid x <> thread) (AA : (E x /\\ is_w Glab x) /\\ tid x = thread) : False.","proofString":"desf."},{"statement":"(x : actid) (HH : codom_rel (⦗I ∪₁ S ∩₁ Tid_ thread⦘ ⨾ (Grfi ⨾ Grmw)＊) x) (AA : ~ (E ∩₁ W ∩₁ Tid_ thread) x) : (I \\₁ Tid_ thread) x.","proofString":"apply cert_co_base_in_E_W in HH.\ndestruct (classic (I x)).\nsplit; auto.\nintros BB.\napply AA.\nsplit; auto.\nexfalso.\napply IT_new_co in HH.\ndestruct HH; desf."},{"statement":"(x : actid) (HH : (E ∩₁ W) x) (AA : ~ (E ∩₁ W ∩₁ Tid_ thread) x) : (I \\₁ Tid_ thread) x.","proofString":"destruct (classic (I x)).\nsplit; auto.\nintros BB.\napply AA.\nsplit; auto.\nexfalso.\napply IT_new_co in HH.\ndestruct HH; desf."},{"statement":"(x : actid) (HH : (E ∩₁ W) x) (AA : ~ (E ∩₁ W ∩₁ Tid_ thread) x) (H : I x) : (I \\₁ Tid_ thread) x.","proofString":"split; auto.\nintros BB.\napply AA.\nsplit; auto."},{"statement":"(x : actid) (HH : (E ∩₁ W) x) (AA : ~ (E ∩₁ W ∩₁ Tid_ thread) x) (H : I x) : tid x <> thread.","proofString":"intros BB.\napply AA.\nsplit; auto."},{"statement":"(x : actid) (HH : (E ∩₁ W) x) (AA : ~ (E ∩₁ W ∩₁ Tid_ thread) x) (H : I x) (BB : tid x = thread) : False.","proofString":"apply AA.\nsplit; auto."},{"statement":"(x : actid) (HH : (E ∩₁ W) x) (AA : ~ (E ∩₁ W ∩₁ Tid_ thread) x) (H : I x) (BB : tid x = thread) : (E ∩₁ W ∩₁ Tid_ thread) x.","proofString":"split; auto."},{"statement":"(x : actid) (HH : (E ∩₁ W) x) (AA : ~ (E ∩₁ W ∩₁ Tid_ thread) x) (H : ~ I x) : (I \\₁ Tid_ thread) x.","proofString":"exfalso.\napply IT_new_co in HH.\ndestruct HH; desf."},{"statement":"(x : actid) (HH : (E ∩₁ W) x) (AA : ~ (E ∩₁ W ∩₁ Tid_ thread) x) (H : ~ I x) : False.","proofString":"apply IT_new_co in HH.\ndestruct HH; desf."},{"statement":"(x : actid) (HH : (I ∪₁ E ∩₁ W ∩₁ Tid_ thread) x) (AA : ~ (E ∩₁ W ∩₁ Tid_ thread) x) (H : ~ I x) : False.","proofString":"destruct HH; desf."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : I x.","proofString":"red.\nexists (mkTL ta_issue x).\nrepeat split; auto.\napply T_INIT.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : (event ↑₁ (T ∩₁ action ↓₁ eq ta_issue)) x.","proofString":"exists (mkTL ta_issue x).\nrepeat split; auto.\napply T_INIT.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : (T ∩₁ action ↓₁ eq ta_issue) (mkTL ta_issue x) /\\ event (mkTL ta_issue x) = x.","proofString":"repeat split; auto.\napply T_INIT.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : T (mkTL ta_issue x).","proofString":"apply T_INIT.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : init_tls G (mkTL ta_issue x).","proofString":"red.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : ((eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n (E ∩₁ Init)) (mkTL ta_issue x).","proofString":"split; basic_solver."},{"statement":"(FAIR : mem_fair G) : set_finite (E ∩₁ set_compl Init).","proofString":"by rewrite <- set_minusE."},{"statement":"(FAIR : mem_fair G) (y : actid) (LOC : Gloc y = None) (x : actid) (REL : (⦗E ∩₁ Init⦘ ⨾ Gsame_loc ⨾ ⦗W⦘) x y) : False.","proofString":"apply seq_eqv_lr in REL.\ndesc.\nforward eapply is_w_loc as ?; eauto.\ndesc.\ncongruence."},{"statement":"(FAIR : mem_fair G) (y : actid) (LOC : Gloc y = None) (x : actid) (REL : (E ∩₁ Init) x /\\ Gsame_loc x y /\\ is_w Glab y) : False.","proofString":"desc.\nforward eapply is_w_loc as ?; eauto.\ndesc.\ncongruence."},{"statement":"(FAIR : mem_fair G) (y : actid) (LOC : Gloc y = None) (x : actid) (REL : (E ∩₁ Init) x) (REL0 : Gsame_loc x y) (REL1 : is_w Glab y) : False.","proofString":"forward eapply is_w_loc as ?; eauto.\ndesc.\ncongruence."},{"statement":"(FAIR : mem_fair G) (y : actid) (LOC : Gloc y = None) (x : actid) (REL : (E ∩₁ Init) x) (REL0 : Gsame_loc x y) (REL1 : is_w Glab y) (H : exists l : location, Gloc y = Some l) : False.","proofString":"desc.\ncongruence."},{"statement":"(FAIR : mem_fair G) (y : actid) (LOC : Gloc y = None) (x : actid) (REL : (E ∩₁ Init) x) (REL0 : Gsame_loc x y) (REL1 : is_w Glab y) (l : location) (H : Gloc y = Some l) : False.","proofString":"congruence."},{"statement":"(FAIR : mem_fair G) (y : actid) (l : location) (LOC : Gloc y = Some l) (x : actid) (REL : (⦗E ∩₁ Init⦘ ⨾ Gsame_loc ⨾ ⦗W⦘) x y) : InitEvent l = x \\/ False.","proofString":"left.\napply seq_eqv_lr in REL.\ndesc.\ndestruct x; [| type_solver].\nred in REL0.\nrewrite LOC in REL0.\nunfold \"Gloc\" in REL0.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(FAIR : mem_fair G) (y : actid) (l : location) (LOC : Gloc y = Some l) (x : actid) (REL : (⦗E ∩₁ Init⦘ ⨾ Gsame_loc ⨾ ⦗W⦘) x y) : InitEvent l = x.","proofString":"apply seq_eqv_lr in REL.\ndesc.\ndestruct x; [| type_solver].\nred in REL0.\nrewrite LOC in REL0.\nunfold \"Gloc\" in REL0.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(FAIR : mem_fair G) (y : actid) (l : location) (LOC : Gloc y = Some l) (x : actid) (REL : (E ∩₁ Init) x /\\ Gsame_loc x y /\\ is_w Glab y) : InitEvent l = x.","proofString":"desc.\ndestruct x; [| type_solver].\nred in REL0.\nrewrite LOC in REL0.\nunfold \"Gloc\" in REL0.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(FAIR : mem_fair G) (y : actid) (l : location) (LOC : Gloc y = Some l) (x : actid) (REL : (E ∩₁ Init) x) (REL0 : Gsame_loc x y) (REL1 : is_w Glab y) : InitEvent l = x.","proofString":"destruct x; [| type_solver].\nred in REL0.\nrewrite LOC in REL0.\nunfold \"Gloc\" in REL0.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(FAIR : mem_fair G) (y : actid) (l : location) (LOC : Gloc y = Some l) (l0 : location) (REL : (E ∩₁ Init) (InitEvent l0)) (REL0 : Gsame_loc (InitEvent l0) y) (REL1 : is_w Glab y) : InitEvent l = InitEvent l0.","proofString":"red in REL0.\nrewrite LOC in REL0.\nunfold \"Gloc\" in REL0.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(FAIR : mem_fair G) (y : actid) (l : location) (LOC : Gloc y = Some l) (l0 : location) (REL : (E ∩₁ Init) (InitEvent l0)) (REL0 : Gloc (InitEvent l0) = Gloc y) (REL1 : is_w Glab y) : InitEvent l = InitEvent l0.","proofString":"rewrite LOC in REL0.\nunfold \"Gloc\" in REL0.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(FAIR : mem_fair G) (y : actid) (l : location) (LOC : Gloc y = Some l) (l0 : location) (REL : (E ∩₁ Init) (InitEvent l0)) (REL0 : Gloc (InitEvent l0) = Some l) (REL1 : is_w Glab y) : InitEvent l = InitEvent l0.","proofString":"unfold \"Gloc\" in REL0.\nrewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(FAIR : mem_fair G) (y : actid) (l : location) (LOC : Gloc y = Some l) (l0 : location) (REL : (E ∩₁ Init) (InitEvent l0)) (REL0 : match Glab (InitEvent l0) with\n| Aload _ _ l1 _ | Astore _ _ l1 _ => Some l1\n| Afence _ => None\nend = Some l) (REL1 : is_w Glab y) : InitEvent l = InitEvent l0.","proofString":"rewrite wf_init_lab in REL0; auto.\ncongruence."},{"statement":"(FAIR : mem_fair G) (y : actid) (l : location) (LOC : Gloc y = Some l) (l0 : location) (REL : (E ∩₁ Init) (InitEvent l0)) (REL0 : Some l0 = Some l) (REL1 : is_w Glab y) : InitEvent l = InitEvent l0.","proofString":"congruence."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : (E x /\\ is_w Glab x) /\\ ~ is_init x) : exists x0 : actid,\n  cert_co x0 x /\\ (forall c : actid, cert_co x0 c -> cert_co c x -> False).","proofString":"ins; eapply fsupp_immediate_pred.\nby apply fsupp_cert_co.\neapply cert_co_irr.\neapply cert_co_trans.\nunfolder; intro HH.\nedestruct is_w_loc as [l LL]; eauto; ins; desf.\neapply HH with (b := InitEvent l).\neapply tot_ex.\napply wf_cert_co_total.\nbasic_solver.\nunfolder; splits; try edone.\neapply (wf_init WF); exists x; splits; eauto.\nby unfold is_w; rewrite (wf_init_lab WF) in *.\nrewrite LL.\nby unfold loc; rewrite (wf_init_lab WF) in *.\nintro A.\neapply cert_co_sb_irr; eauto.\nunfolder; eexists; splits; eauto.\neapply init_ninit_sb; eauto.\nby apply (wf_init WF); eexists; splits; eauto.\nunfold is_init in *; desf."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : (E x /\\ is_w Glab x) /\\ ~ is_init x) : fsupp cert_co.","proofString":"by apply fsupp_cert_co."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : (E x /\\ is_w Glab x) /\\ ~ is_init x) : irreflexive cert_co.","proofString":"eapply cert_co_irr."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : (E x /\\ is_w Glab x) /\\ ~ is_init x) : transitive cert_co.","proofString":"eapply cert_co_trans."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : (E x /\\ is_w Glab x) /\\ ~ is_init x) : ~ min_elt cert_co x.","proofString":"unfolder; intro HH.\nedestruct is_w_loc as [l LL]; eauto; ins; desf.\neapply HH with (b := InitEvent l).\neapply tot_ex.\napply wf_cert_co_total.\nbasic_solver.\nunfolder; splits; try edone.\neapply (wf_init WF); exists x; splits; eauto.\nby unfold is_w; rewrite (wf_init_lab WF) in *.\nrewrite LL.\nby unfold loc; rewrite (wf_init_lab WF) in *.\nintro A.\neapply cert_co_sb_irr; eauto.\nunfolder; eexists; splits; eauto.\neapply init_ninit_sb; eauto.\nby apply (wf_init WF); eexists; splits; eauto.\nunfold is_init in *; desf."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : (E x /\\ is_w Glab x) /\\ ~ is_init x) (HH : forall b : actid, cert_co b x -> False) : False.","proofString":"edestruct is_w_loc as [l LL]; eauto; ins; desf.\neapply HH with (b := InitEvent l).\neapply tot_ex.\napply wf_cert_co_total.\nbasic_solver.\nunfolder; splits; try edone.\neapply (wf_init WF); exists x; splits; eauto.\nby unfold is_w; rewrite (wf_init_lab WF) in *.\nrewrite LL.\nby unfold loc; rewrite (wf_init_lab WF) in *.\nintro A.\neapply cert_co_sb_irr; eauto.\nunfolder; eexists; splits; eauto.\neapply init_ninit_sb; eauto.\nby apply (wf_init WF); eexists; splits; eauto.\nunfold is_init in *; desf."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : E x) (H1 : is_w Glab x) (H0 : ~ is_init x) (HH : forall b : actid, cert_co b x -> False) (l : location) (LL : Gloc x = Some l) : False.","proofString":"eapply HH with (b := InitEvent l).\neapply tot_ex.\napply wf_cert_co_total.\nbasic_solver.\nunfolder; splits; try edone.\neapply (wf_init WF); exists x; splits; eauto.\nby unfold is_w; rewrite (wf_init_lab WF) in *.\nrewrite LL.\nby unfold loc; rewrite (wf_init_lab WF) in *.\nintro A.\neapply cert_co_sb_irr; eauto.\nunfolder; eexists; splits; eauto.\neapply init_ninit_sb; eauto.\nby apply (wf_init WF); eexists; splits; eauto.\nunfold is_init in *; desf."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : E x) (H1 : is_w Glab x) (H0 : ~ is_init x) (HH : forall b : actid, cert_co b x -> False) (l : location) (LL : Gloc x = Some l) : cert_co (InitEvent l) x.","proofString":"eapply tot_ex.\napply wf_cert_co_total.\nbasic_solver.\nunfolder; splits; try edone.\neapply (wf_init WF); exists x; splits; eauto.\nby unfold is_w; rewrite (wf_init_lab WF) in *.\nrewrite LL.\nby unfold loc; rewrite (wf_init_lab WF) in *.\nintro A.\neapply cert_co_sb_irr; eauto.\nunfolder; eexists; splits; eauto.\neapply init_ninit_sb; eauto.\nby apply (wf_init WF); eexists; splits; eauto.\nunfold is_init in *; desf."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : E x) (H1 : is_w Glab x) (H0 : ~ is_init x) (HH : forall b : actid, cert_co b x -> False) (l : location) (LL : Gloc x = Some l) : E (InitEvent l).","proofString":"eapply (wf_init WF); exists x; splits; eauto."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : E x) (H1 : is_w Glab x) (H0 : ~ is_init x) (HH : forall b : actid, cert_co b x -> False) (l : location) (LL : Gloc x = Some l) : is_w Glab (InitEvent l).","proofString":"by unfold is_w; rewrite (wf_init_lab WF) in *."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : E x) (H1 : is_w Glab x) (H0 : ~ is_init x) (HH : forall b : actid, cert_co b x -> False) (l : location) (LL : Gloc x = Some l) : Gloc (InitEvent l) = Gloc x.","proofString":"rewrite LL.\nby unfold loc; rewrite (wf_init_lab WF) in *."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : E x) (H1 : is_w Glab x) (H0 : ~ is_init x) (HH : forall b : actid, cert_co b x -> False) (l : location) (LL : Gloc x = Some l) : Gloc (InitEvent l) = Some l.","proofString":"by unfold loc; rewrite (wf_init_lab WF) in *."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : E x) (H1 : is_w Glab x) (H0 : ~ is_init x) (HH : forall b : actid, cert_co b x -> False) (l : location) (LL : Gloc x = Some l) : ~ cert_co x (InitEvent l).","proofString":"intro A.\neapply cert_co_sb_irr; eauto.\nunfolder; eexists; splits; eauto.\neapply init_ninit_sb; eauto.\nby apply (wf_init WF); eexists; splits; eauto."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : E x) (H1 : is_w Glab x) (H0 : ~ is_init x) (HH : forall b : actid, cert_co b x -> False) (l : location) (LL : Gloc x = Some l) (A : cert_co x (InitEvent l)) : False.","proofString":"eapply cert_co_sb_irr; eauto.\nunfolder; eexists; splits; eauto.\neapply init_ninit_sb; eauto.\nby apply (wf_init WF); eexists; splits; eauto."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : E x) (H1 : is_w Glab x) (H0 : ~ is_init x) (HH : forall b : actid, cert_co b x -> False) (l : location) (LL : Gloc x = Some l) (A : cert_co x (InitEvent l)) : Gsb (InitEvent l) x.","proofString":"eapply init_ninit_sb; eauto.\nby apply (wf_init WF); eexists; splits; eauto."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : E x) (H1 : is_w Glab x) (H0 : ~ is_init x) (HH : forall b : actid, cert_co b x -> False) (l : location) (LL : Gloc x = Some l) (A : cert_co x (InitEvent l)) : E (InitEvent l).","proofString":"by apply (wf_init WF); eexists; splits; eauto."},{"statement":"(FAIR : mem_fair G) (x : actid) (H : E x) (H1 : is_w Glab x) (H0 : ~ is_init x) (HH : forall b : actid, cert_co b x -> False) (l : location) (LL : Gloc x = Some l) : x <> InitEvent l.","proofString":"unfold is_init in *; desf."},{"statement":"(immediate cert_co)⁻¹ ⨾ ⦗E⦘ ⨾ cert_co ⨾ ⦗E⦘ ⊆ cert_co^?.","proofString":"rewrite wf_cert_coD at 2.\nunfolder; ins; desf.\ncut (x = y \\/ cert_co y x \\/ cert_co x y).\nby ins; desf; eauto 21; exfalso; eauto.\ncut (x <> y -> cert_co y x \\/ cert_co x y).\ntauto.\nins.\neapply wf_cert_co_total; eauto.\nby unfolder; ins; desf.\nhahn_rewrite wf_cert_coE in H; unfolder in H; desf.\nhahn_rewrite wf_cert_coD in H7; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H9; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H1; unfolder in H1; desf.\nunfold same_loc in *; desf.\nunfolder; splits; eauto.\ncongruence."},{"statement":"(immediate cert_co)⁻¹ ⨾ ⦗E⦘ ⨾ (⦗W⦘ ⨾ cert_co ⨾ ⦗W⦘) ⨾ ⦗E⦘ ⊆ cert_co^?.","proofString":"unfolder; ins; desf.\ncut (x = y \\/ cert_co y x \\/ cert_co x y).\nby ins; desf; eauto 21; exfalso; eauto.\ncut (x <> y -> cert_co y x \\/ cert_co x y).\ntauto.\nins.\neapply wf_cert_co_total; eauto.\nby unfolder; ins; desf.\nhahn_rewrite wf_cert_coE in H; unfolder in H; desf.\nhahn_rewrite wf_cert_coD in H7; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H9; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H1; unfolder in H1; desf.\nunfold same_loc in *; desf.\nunfolder; splits; eauto.\ncongruence."},{"statement":"(x y z : actid) (H : cert_co z x) (H5 : forall c : actid, cert_co z c -> cert_co c x -> False) (H0 : E z) (H4 : is_w Glab z) (H1 : cert_co z y) (H2 : is_w Glab y) (H3 : E y) : x = y \\/ cert_co x y.","proofString":"cut (x = y \\/ cert_co y x \\/ cert_co x y).\nby ins; desf; eauto 21; exfalso; eauto.\ncut (x <> y -> cert_co y x \\/ cert_co x y).\ntauto.\nins.\neapply wf_cert_co_total; eauto.\nby unfolder; ins; desf.\nhahn_rewrite wf_cert_coE in H; unfolder in H; desf.\nhahn_rewrite wf_cert_coD in H7; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H9; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H1; unfolder in H1; desf.\nunfold same_loc in *; desf.\nunfolder; splits; eauto.\ncongruence."},{"statement":"(x y z : actid) (H : cert_co z x) (H5 : forall c : actid, cert_co z c -> cert_co c x -> False) (H0 : E z) (H4 : is_w Glab z) (H1 : cert_co z y) (H2 : is_w Glab y) (H3 : E y) : x = y \\/ cert_co y x \\/ cert_co x y -> x = y \\/ cert_co x y.","proofString":"by ins; desf; eauto 21; exfalso; eauto."},{"statement":"(x y z : actid) (H : cert_co z x) (H5 : forall c : actid, cert_co z c -> cert_co c x -> False) (H0 : E z) (H4 : is_w Glab z) (H1 : cert_co z y) (H2 : is_w Glab y) (H3 : E y) : x = y \\/ cert_co y x \\/ cert_co x y.","proofString":"cut (x <> y -> cert_co y x \\/ cert_co x y).\ntauto.\nins.\neapply wf_cert_co_total; eauto.\nby unfolder; ins; desf.\nhahn_rewrite wf_cert_coE in H; unfolder in H; desf.\nhahn_rewrite wf_cert_coD in H7; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H9; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H1; unfolder in H1; desf.\nunfold same_loc in *; desf.\nunfolder; splits; eauto.\ncongruence."},{"statement":"(x y z : actid) (H : cert_co z x) (H5 : forall c : actid, cert_co z c -> cert_co c x -> False) (H0 : E z) (H4 : is_w Glab z) (H1 : cert_co z y) (H2 : is_w Glab y) (H3 : E y) : (x <> y -> cert_co y x \\/ cert_co x y) -> x = y \\/ cert_co y x \\/ cert_co x y.","proofString":"tauto."},{"statement":"(x y z : actid) (H : cert_co z x) (H5 : forall c : actid, cert_co z c -> cert_co c x -> False) (H0 : E z) (H4 : is_w Glab z) (H1 : cert_co z y) (H2 : is_w Glab y) (H3 : E y) : x <> y -> cert_co y x \\/ cert_co x y.","proofString":"ins.\neapply wf_cert_co_total; eauto.\nby unfolder; ins; desf.\nhahn_rewrite wf_cert_coE in H; unfolder in H; desf.\nhahn_rewrite wf_cert_coD in H7; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H9; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H1; unfolder in H1; desf.\nunfold same_loc in *; desf.\nunfolder; splits; eauto.\ncongruence."},{"statement":"(x y z : actid) (H : cert_co z x) (H5 : forall c : actid, cert_co z c -> cert_co c x -> False) (H0 : E z) (H4 : is_w Glab z) (H1 : cert_co z y) (H2 : is_w Glab y) (H3 : E y) (H6 : x <> y) : cert_co y x \\/ cert_co x y.","proofString":"eapply wf_cert_co_total; eauto.\nby unfolder; ins; desf.\nhahn_rewrite wf_cert_coE in H; unfolder in H; desf.\nhahn_rewrite wf_cert_coD in H7; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H9; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H1; unfolder in H1; desf.\nunfold same_loc in *; desf.\nunfolder; splits; eauto.\ncongruence."},{"statement":"(x y z : actid) (H5 : forall c : actid, cert_co z c -> cert_co c x -> False) (H0 : E z) (H4 : is_w Glab z) (H1 : cert_co z y) (H2 : is_w Glab y) (H3 : E y) (H6 : x <> y) (H : E z) (H7 : cert_co z x) (H8 : E x) : (E ∩₁ W ∩₁ (fun x0 : actid => Gloc x0 = Gloc y)) x.","proofString":"hahn_rewrite wf_cert_coD in H7; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H9; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H1; unfolder in H1; desf.\nunfold same_loc in *; desf.\nunfolder; splits; eauto.\ncongruence."},{"statement":"(x y z : actid) (H5 : forall c : actid, cert_co z c -> cert_co c x -> False) (H0 : E z) (H4 : is_w Glab z) (H1 : cert_co z y) (H2 : is_w Glab y) (H3 : E y) (H6 : x <> y) (H : E z) (H8 : E x) (H7 : true) (H9 : cert_co z x) (H10 : is_w Glab x) : (E ∩₁ W ∩₁ (fun x0 : actid => Gloc x0 = Gloc y)) x.","proofString":"hahn_rewrite wf_cert_col in H9; unfolder in H7; desf.\nhahn_rewrite wf_cert_col in H1; unfolder in H1; desf.\nunfold same_loc in *; desf.\nunfolder; splits; eauto.\ncongruence."},{"statement":"(x y z : actid) (H5 : forall c : actid, cert_co z c -> cert_co c x -> False) (H0 : E z) (H4 : is_w Glab z) (H1 : cert_co z y) (H2 : is_w Glab y) (H3 : E y) (H6 : x <> y) (H : E z) (H8 : E x) (H7 : true) (H10 : is_w Glab x) (H9 : Gsame_loc z x) : (E ∩₁ W ∩₁ (fun x0 : actid => Gloc x0 = Gloc y)) x.","proofString":"hahn_rewrite wf_cert_col in H1; unfolder in H1; desf.\nunfold same_loc in *; desf.\nunfolder; splits; eauto.\ncongruence."},{"statement":"(x y z : actid) (H5 : forall c : actid, cert_co z c -> cert_co c x -> False) (H0 : E z) (H4 : is_w Glab z) (H2 : is_w Glab y) (H3 : E y) (H6 : x <> y) (H : E z) (H8 : E x) (H7 : true) (H10 : is_w Glab x) (H9 : Gsame_loc z x) (H1 : Gsame_loc z y) : (E ∩₁ W ∩₁ (fun x0 : actid => Gloc x0 = Gloc y)) x.","proofString":"unfold same_loc in *; desf.\nunfolder; splits; eauto.\ncongruence."},{"statement":"(x y z : actid) (H5 : forall c : actid, cert_co z c -> cert_co c x -> False) (H0 : E z) (H4 : is_w Glab z) (H2 : is_w Glab y) (H3 : E y) (H6 : x <> y) (H : E z) (H8 : E x) (H7 : true) (H10 : is_w Glab x) (H9 : Gloc z = Gloc x) (H1 : Gloc z = Gloc y) : (E ∩₁ W ∩₁ (fun x0 : actid => Gloc x0 = Gloc y)) x.","proofString":"unfolder; splits; eauto.\ncongruence."},{"statement":"(x y z : actid) (H5 : forall c : actid, cert_co z c -> cert_co c x -> False) (H0 : E z) (H4 : is_w Glab z) (H2 : is_w Glab y) (H3 : E y) (H6 : x <> y) (H : E z) (H8 : E x) (H7 : true) (H10 : is_w Glab x) (H9 : Gloc z = Gloc x) (H1 : Gloc z = Gloc y) : Gloc x = Gloc y.","proofString":"congruence."},{"statement":"(cert_co⁻¹ ⨾ immediate cert_co)⁻¹ ⊆ ((cert_co⁻¹)^?)⁻¹.","proofString":"rewrite transp_seq, transp_cr.\nrels.\napply transp_cert_co_imm_cert_co."},{"statement":"(immediate cert_co)⁻¹ ⨾ (cert_co⁻¹)⁻¹ ⊆ ((cert_co⁻¹)⁻¹)^?.","proofString":"rels.\napply transp_cert_co_imm_cert_co."},{"statement":"(immediate cert_co)⁻¹ ⨾ cert_co ⊆ cert_co^?.","proofString":"apply transp_cert_co_imm_cert_co."}]}