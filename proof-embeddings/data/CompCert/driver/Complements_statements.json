{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/driver/Complements.v","fileSamples":[{"statement":"(p : Csyntax.program) (tp : program) (beh : program_behavior) (H : transf_c_program p = OK tp) (H0 : program_behaves (semantics tp) beh) : exists beh' : program_behavior,\n  program_behaves (Csem.semantics p) beh' /\\ behavior_improves beh' beh.","proofString":"eapply backward_simulation_behavior_improves; eauto.\napply transf_c_program_correct; auto."},{"statement":"(p : Csyntax.program) (tp : program) (beh : program_behavior) (H : transf_c_program p = OK tp) (H0 : program_behaves (semantics tp) beh) : backward_simulation (Csem.semantics p) (semantics tp).","proofString":"apply transf_c_program_correct; auto."},{"statement":"(p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (H0 : forall beh0 : program_behavior,\nprogram_behaves (Csem.semantics p) beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves (semantics tp) beh) : program_behaves (Csem.semantics p) beh.","proofString":"eapply backward_simulation_same_safe_behavior; eauto.\napply transf_c_program_correct; auto."},{"statement":"(p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (H0 : forall beh0 : program_behavior,\nprogram_behaves (Csem.semantics p) beh0 -> not_wrong beh0) (beh : program_behavior) (H1 : program_behaves (semantics tp) beh) : backward_simulation (Csem.semantics p) (semantics tp).","proofString":"apply transf_c_program_correct; auto."},{"statement":"forall p : Csyntax.program, well_behaved_traces (Cstrategy.semantics p).","proofString":"intros.\neapply ssr_well_behaved.\napply Cstrategy.semantics_strongly_receptive."},{"statement":"(p : Csyntax.program) : well_behaved_traces (Cstrategy.semantics p).","proofString":"eapply ssr_well_behaved.\napply Cstrategy.semantics_strongly_receptive."},{"statement":"(p : Csyntax.program) : strongly_receptive (Cstrategy.semantics p).","proofString":"apply Cstrategy.semantics_strongly_receptive."},{"statement":"(WBT : forall p : Csyntax.program, well_behaved_traces (Cstrategy.semantics p)) : forall (p : Csyntax.program) (tp : program),\ntransf_c_program p = OK tp ->\n(forall beh : program_behavior,\n program_behaves (Cstrategy.semantics p) beh ->\n exists beh' : program_behavior,\n   program_behaves (semantics tp) beh' /\\ behavior_improves beh beh') /\\\n(forall beh : program_behavior,\n program_behaves (semantics tp) beh ->\n exists beh' : program_behavior,\n   program_behaves (Cstrategy.semantics p) beh' /\\ behavior_improves beh' beh) /\\\n(forall beh : program_behavior,\n not_wrong beh ->\n program_behaves (Cstrategy.semantics p) beh ->\n program_behaves (semantics tp) beh) /\\\n(forall beh : program_behavior,\n (forall beh' : program_behavior,\n  program_behaves (Cstrategy.semantics p) beh' -> not_wrong beh') ->\n program_behaves (semantics tp) beh ->\n program_behaves (Cstrategy.semantics p) beh).","proofString":"intros.\nassert (MATCH: match_prog p tp) by (apply transf_c_program_match; auto).\nintuition auto.\neapply forward_simulation_behavior_improves; eauto.\napply (proj1 (cstrategy_semantic_preservation _ _ MATCH)).\nexploit backward_simulation_behavior_improves.\napply (proj2 (cstrategy_semantic_preservation _ _ MATCH)).\neauto.\nintros [beh1 [A B]].\nexists beh1; split; auto.\nrewrite atomic_behaviors; auto.\neapply forward_simulation_same_safe_behavior; eauto.\napply (proj1 (cstrategy_semantic_preservation _ _ MATCH)).\nexploit backward_simulation_same_safe_behavior.\napply (proj2 (cstrategy_semantic_preservation _ _ MATCH)).\nintros.\nrewrite <- atomic_behaviors in H2; eauto.\neauto.\nintros.\nrewrite atomic_behaviors; auto."},{"statement":"(WBT : forall p0 : Csyntax.program, well_behaved_traces (Cstrategy.semantics p0)) (p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) : (forall beh : program_behavior,\n program_behaves (Cstrategy.semantics p) beh ->\n exists beh' : program_behavior,\n   program_behaves (semantics tp) beh' /\\ behavior_improves beh beh') /\\\n(forall beh : program_behavior,\n program_behaves (semantics tp) beh ->\n exists beh' : program_behavior,\n   program_behaves (Cstrategy.semantics p) beh' /\\ behavior_improves beh' beh) /\\\n(forall beh : program_behavior,\n not_wrong beh ->\n program_behaves (Cstrategy.semantics p) beh ->\n program_behaves (semantics tp) beh) /\\\n(forall beh : program_behavior,\n (forall beh' : program_behavior,\n  program_behaves (Cstrategy.semantics p) beh' -> not_wrong beh') ->\n program_behaves (semantics tp) beh ->\n program_behaves (Cstrategy.semantics p) beh).","proofString":"assert (MATCH: match_prog p tp) by (apply transf_c_program_match; auto).\nintuition auto.\neapply forward_simulation_behavior_improves; eauto.\napply (proj1 (cstrategy_semantic_preservation _ _ MATCH)).\nexploit backward_simulation_behavior_improves.\napply (proj2 (cstrategy_semantic_preservation _ _ MATCH)).\neauto.\nintros [beh1 [A B]].\nexists beh1; split; auto.\nrewrite atomic_behaviors; auto.\neapply forward_simulation_same_safe_behavior; eauto.\napply (proj1 (cstrategy_semantic_preservation _ _ MATCH)).\nexploit backward_simulation_same_safe_behavior.\napply (proj2 (cstrategy_semantic_preservation _ _ MATCH)).\nintros.\nrewrite <- atomic_behaviors in H2; eauto.\neauto.\nintros.\nrewrite atomic_behaviors; auto."},{"statement":"(WBT : forall p0 : Csyntax.program, well_behaved_traces (Cstrategy.semantics p0)) (p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (MATCH : match_prog p tp) : (forall beh : program_behavior,\n program_behaves (Cstrategy.semantics p) beh ->\n exists beh' : program_behavior,\n   program_behaves (semantics tp) beh' /\\ behavior_improves beh beh') /\\\n(forall beh : program_behavior,\n program_behaves (semantics tp) beh ->\n exists beh' : program_behavior,\n   program_behaves (Cstrategy.semantics p) beh' /\\ behavior_improves beh' beh) /\\\n(forall beh : program_behavior,\n not_wrong beh ->\n program_behaves (Cstrategy.semantics p) beh ->\n program_behaves (semantics tp) beh) /\\\n(forall beh : program_behavior,\n (forall beh' : program_behavior,\n  program_behaves (Cstrategy.semantics p) beh' -> not_wrong beh') ->\n program_behaves (semantics tp) beh ->\n program_behaves (Cstrategy.semantics p) beh).","proofString":"intuition auto.\neapply forward_simulation_behavior_improves; eauto.\napply (proj1 (cstrategy_semantic_preservation _ _ MATCH)).\nexploit backward_simulation_behavior_improves.\napply (proj2 (cstrategy_semantic_preservation _ _ MATCH)).\neauto.\nintros [beh1 [A B]].\nexists beh1; split; auto.\nrewrite atomic_behaviors; auto.\neapply forward_simulation_same_safe_behavior; eauto.\napply (proj1 (cstrategy_semantic_preservation _ _ MATCH)).\nexploit backward_simulation_same_safe_behavior.\napply (proj2 (cstrategy_semantic_preservation _ _ MATCH)).\nintros.\nrewrite <- atomic_behaviors in H2; eauto.\neauto.\nintros.\nrewrite atomic_behaviors; auto."},{"statement":"(WBT : forall p0 : Csyntax.program, well_behaved_traces (Cstrategy.semantics p0)) (p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (MATCH : match_prog p tp) (beh : program_behavior) (H0 : program_behaves (Cstrategy.semantics p) beh) : exists beh' : program_behavior,\n  program_behaves (semantics tp) beh' /\\ behavior_improves beh beh'.","proofString":"eapply forward_simulation_behavior_improves; eauto.\napply (proj1 (cstrategy_semantic_preservation _ _ MATCH))."},{"statement":"(WBT : forall p0 : Csyntax.program, well_behaved_traces (Cstrategy.semantics p0)) (p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (MATCH : match_prog p tp) (beh : program_behavior) (H0 : program_behaves (Cstrategy.semantics p) beh) : forward_simulation (Cstrategy.semantics p) (semantics tp).","proofString":"apply (proj1 (cstrategy_semantic_preservation _ _ MATCH))."},{"statement":"(WBT : forall p0 : Csyntax.program, well_behaved_traces (Cstrategy.semantics p0)) (p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (MATCH : match_prog p tp) (beh : program_behavior) (H0 : program_behaves (semantics tp) beh) : exists beh' : program_behavior,\n  program_behaves (Cstrategy.semantics p) beh' /\\ behavior_improves beh' beh.","proofString":"exploit backward_simulation_behavior_improves.\napply (proj2 (cstrategy_semantic_preservation _ _ MATCH)).\neauto.\nintros [beh1 [A B]].\nexists beh1; split; auto.\nrewrite atomic_behaviors; auto."},{"statement":"(WBT : forall p0 : Csyntax.program, well_behaved_traces (Cstrategy.semantics p0)) (p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (MATCH : match_prog p tp) (beh : program_behavior) (H0 : program_behaves (semantics tp) beh) (beh1 : program_behavior) (A : program_behaves (atomic (Cstrategy.semantics p)) beh1) (B : behavior_improves beh1 beh) : exists beh' : program_behavior,\n  program_behaves (Cstrategy.semantics p) beh' /\\ behavior_improves beh' beh.","proofString":"exists beh1; split; auto.\nrewrite atomic_behaviors; auto."},{"statement":"(WBT : forall p0 : Csyntax.program, well_behaved_traces (Cstrategy.semantics p0)) (p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (MATCH : match_prog p tp) (beh : program_behavior) (H0 : program_behaves (semantics tp) beh) (beh1 : program_behavior) (A : program_behaves (atomic (Cstrategy.semantics p)) beh1) (B : behavior_improves beh1 beh) : program_behaves (Cstrategy.semantics p) beh1.","proofString":"rewrite atomic_behaviors; auto."},{"statement":"(WBT : forall p0 : Csyntax.program, well_behaved_traces (Cstrategy.semantics p0)) (p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (MATCH : match_prog p tp) (beh : program_behavior) (H0 : not_wrong beh) (H1 : program_behaves (Cstrategy.semantics p) beh) : program_behaves (semantics tp) beh.","proofString":"eapply forward_simulation_same_safe_behavior; eauto.\napply (proj1 (cstrategy_semantic_preservation _ _ MATCH))."},{"statement":"(WBT : forall p0 : Csyntax.program, well_behaved_traces (Cstrategy.semantics p0)) (p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (MATCH : match_prog p tp) (beh : program_behavior) (H0 : not_wrong beh) (H1 : program_behaves (Cstrategy.semantics p) beh) : forward_simulation (Cstrategy.semantics p) (semantics tp).","proofString":"apply (proj1 (cstrategy_semantic_preservation _ _ MATCH))."},{"statement":"(WBT : forall p0 : Csyntax.program, well_behaved_traces (Cstrategy.semantics p0)) (p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (MATCH : match_prog p tp) (beh : program_behavior) (H0 : forall beh' : program_behavior,\nprogram_behaves (Cstrategy.semantics p) beh' -> not_wrong beh') (H1 : program_behaves (semantics tp) beh) : program_behaves (Cstrategy.semantics p) beh.","proofString":"exploit backward_simulation_same_safe_behavior.\napply (proj2 (cstrategy_semantic_preservation _ _ MATCH)).\nintros.\nrewrite <- atomic_behaviors in H2; eauto.\neauto.\nintros.\nrewrite atomic_behaviors; auto."},{"statement":"(WBT : forall p0 : Csyntax.program, well_behaved_traces (Cstrategy.semantics p0)) (p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (MATCH : match_prog p tp) (beh : program_behavior) (H0 : forall beh' : program_behavior,\nprogram_behaves (Cstrategy.semantics p) beh' -> not_wrong beh') (H1 : program_behaves (semantics tp) beh) (beh0 : program_behavior) (H2 : program_behaves (atomic (Cstrategy.semantics p)) beh0) : not_wrong beh0.","proofString":"rewrite <- atomic_behaviors in H2; eauto."},{"statement":"(WBT : forall p0 : Csyntax.program, well_behaved_traces (Cstrategy.semantics p0)) (p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (MATCH : match_prog p tp) (beh : program_behavior) (H0 : forall beh' : program_behavior,\nprogram_behaves (Cstrategy.semantics p) beh' -> not_wrong beh') (H1 : program_behaves (semantics tp) beh) (H2 : program_behaves (atomic (Cstrategy.semantics p)) beh) : program_behaves (Cstrategy.semantics p) beh.","proofString":"rewrite atomic_behaviors; auto."},{"statement":"(p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (t : trace) (r : Integers.Int.int) (H0 : bigstep_program_terminates p t r) : program_behaves (semantics tp) (Terminates t r).","proofString":"apply transf_cstrategy_program_preservation with p; auto.\nred; auto.\napply behavior_bigstep_terminates with (Cstrategy.bigstep_semantics p); auto.\napply Cstrategy.bigstep_semantics_sound."},{"statement":"(p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (t : trace) (r : Integers.Int.int) (H0 : bigstep_program_terminates p t r) : not_wrong (Terminates t r).","proofString":"red; auto."},{"statement":"(p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (t : trace) (r : Integers.Int.int) (H0 : bigstep_program_terminates p t r) : program_behaves (Cstrategy.semantics p) (Terminates t r).","proofString":"apply behavior_bigstep_terminates with (Cstrategy.bigstep_semantics p); auto.\napply Cstrategy.bigstep_semantics_sound."},{"statement":"(p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (t : trace) (r : Integers.Int.int) (H0 : bigstep_program_terminates p t r) : bigstep_sound (bigstep_semantics p) (Cstrategy.semantics p).","proofString":"apply Cstrategy.bigstep_semantics_sound."},{"statement":"(p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (T : traceinf) (H0 : bigstep_program_diverges p T) : program_behaves (semantics tp) (Reacts T) \\/\n(exists t : trace,\n   program_behaves (semantics tp) (Diverges t) /\\ traceinf_prefix t T).","proofString":"exploit (behavior_bigstep_diverges (Cstrategy.bigstep_semantics_sound p)).\neassumption.\nintros [A | [t [A B]]].\nleft.\napply transf_cstrategy_program_preservation with p; auto.\nred; auto.\nright; exists t; split; auto.\napply transf_cstrategy_program_preservation with p; auto.\nred; auto."},{"statement":"(p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (T : traceinf) (H0 : bigstep_program_diverges p T) (A : program_behaves (Cstrategy.semantics p) (Reacts T)) : program_behaves (semantics tp) (Reacts T) \\/\n(exists t : trace,\n   program_behaves (semantics tp) (Diverges t) /\\ traceinf_prefix t T).","proofString":"left.\napply transf_cstrategy_program_preservation with p; auto.\nred; auto."},{"statement":"(p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (T : traceinf) (H0 : bigstep_program_diverges p T) (A : program_behaves (Cstrategy.semantics p) (Reacts T)) : program_behaves (semantics tp) (Reacts T).","proofString":"apply transf_cstrategy_program_preservation with p; auto.\nred; auto."},{"statement":"(p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (T : traceinf) (H0 : bigstep_program_diverges p T) (A : program_behaves (Cstrategy.semantics p) (Reacts T)) : not_wrong (Reacts T).","proofString":"red; auto."},{"statement":"(p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (T : traceinf) (H0 : bigstep_program_diverges p T) (t : trace) (A : program_behaves (Cstrategy.semantics p) (Diverges t)) (B : traceinf_prefix t T) : program_behaves (semantics tp) (Reacts T) \\/\n(exists t0 : trace,\n   program_behaves (semantics tp) (Diverges t0) /\\ traceinf_prefix t0 T).","proofString":"right; exists t; split; auto.\napply transf_cstrategy_program_preservation with p; auto.\nred; auto."},{"statement":"(p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (T : traceinf) (H0 : bigstep_program_diverges p T) (t : trace) (A : program_behaves (Cstrategy.semantics p) (Diverges t)) (B : traceinf_prefix t T) : program_behaves (semantics tp) (Diverges t).","proofString":"apply transf_cstrategy_program_preservation with p; auto.\nred; auto."},{"statement":"(p : Csyntax.program) (tp : program) (H : transf_c_program p = OK tp) (T : traceinf) (H0 : bigstep_program_diverges p T) (t : trace) (A : program_behaves (Cstrategy.semantics p) (Diverges t)) (B : traceinf_prefix t T) : not_wrong (Diverges t).","proofString":"red; auto."},{"statement":"(p : Csyntax.program) (tp : program) (spec : specification) (TRANSF : transf_c_program p = OK tp) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec p spec) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) : spec beh.","proofString":"exploit transf_c_program_preservation; eauto.\nintros (beh' & CEXEC & IMPR).\napply CSAT in CEXEC.\ndestruct IMPR as [EQ | [t [A B]]].\ncongruence.\nsubst beh'.\napply SES in CEXEC.\ncontradiction."},{"statement":"(p : Csyntax.program) (tp : program) (spec : specification) (TRANSF : transf_c_program p = OK tp) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec p spec) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) : (exists beh' : program_behavior,\n   program_behaves (Csem.semantics p) beh' /\\ behavior_improves beh' beh) ->\nspec beh.","proofString":"intros (beh' & CEXEC & IMPR).\napply CSAT in CEXEC.\ndestruct IMPR as [EQ | [t [A B]]].\ncongruence.\nsubst beh'.\napply SES in CEXEC.\ncontradiction."},{"statement":"(p : Csyntax.program) (tp : program) (spec : specification) (TRANSF : transf_c_program p = OK tp) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec p spec) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) (beh' : program_behavior) (CEXEC : program_behaves (Csem.semantics p) beh') (IMPR : behavior_improves beh' beh) : spec beh.","proofString":"apply CSAT in CEXEC.\ndestruct IMPR as [EQ | [t [A B]]].\ncongruence.\nsubst beh'.\napply SES in CEXEC.\ncontradiction."},{"statement":"(p : Csyntax.program) (tp : program) (spec : specification) (TRANSF : transf_c_program p = OK tp) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec p spec) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) (beh' : program_behavior) (CEXEC : spec beh') (IMPR : behavior_improves beh' beh) : spec beh.","proofString":"destruct IMPR as [EQ | [t [A B]]].\ncongruence.\nsubst beh'.\napply SES in CEXEC.\ncontradiction."},{"statement":"(p : Csyntax.program) (tp : program) (spec : specification) (TRANSF : transf_c_program p = OK tp) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec p spec) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) (beh' : program_behavior) (CEXEC : spec beh') (EQ : beh' = beh) : spec beh.","proofString":"congruence."},{"statement":"(p : Csyntax.program) (tp : program) (spec : specification) (TRANSF : transf_c_program p = OK tp) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec p spec) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) (beh' : program_behavior) (CEXEC : spec beh') (t : trace) (A : beh' = Goes_wrong t) (B : behavior_prefix t beh) : spec beh.","proofString":"subst beh'.\napply SES in CEXEC.\ncontradiction."},{"statement":"(p : Csyntax.program) (tp : program) (spec : specification) (TRANSF : transf_c_program p = OK tp) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec p spec) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) (t : trace) (CEXEC : spec (Goes_wrong t)) (B : behavior_prefix t beh) : spec beh.","proofString":"apply SES in CEXEC.\ncontradiction."},{"statement":"(p : Csyntax.program) (tp : program) (spec : specification) (TRANSF : transf_c_program p = OK tp) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec p spec) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) (t : trace) (CEXEC : not_wrong (Goes_wrong t)) (B : behavior_prefix t beh) : spec beh.","proofString":"contradiction."},{"statement":"(p : Csyntax.program) (tp : program) (t : trace) (TRANSF : transf_c_program p = OK tp) (CTRACE : c_program_has_initial_trace p t) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) : behavior_prefix t beh.","proofString":"exploit transf_c_program_preservation; eauto.\nintros (beh' & CEXEC & IMPR).\napply CTRACE in CEXEC.\ndestruct IMPR as [EQ | [t' [A B]]].\ncongruence.\ndestruct CEXEC as (beh1' & EQ').\ndestruct B as (beh1 & EQ).\nsubst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(p : Csyntax.program) (tp : program) (t : trace) (TRANSF : transf_c_program p = OK tp) (CTRACE : c_program_has_initial_trace p t) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) : (exists beh' : program_behavior,\n   program_behaves (Csem.semantics p) beh' /\\ behavior_improves beh' beh) ->\nbehavior_prefix t beh.","proofString":"intros (beh' & CEXEC & IMPR).\napply CTRACE in CEXEC.\ndestruct IMPR as [EQ | [t' [A B]]].\ncongruence.\ndestruct CEXEC as (beh1' & EQ').\ndestruct B as (beh1 & EQ).\nsubst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(p : Csyntax.program) (tp : program) (t : trace) (TRANSF : transf_c_program p = OK tp) (CTRACE : c_program_has_initial_trace p t) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) (beh' : program_behavior) (CEXEC : program_behaves (Csem.semantics p) beh') (IMPR : behavior_improves beh' beh) : behavior_prefix t beh.","proofString":"apply CTRACE in CEXEC.\ndestruct IMPR as [EQ | [t' [A B]]].\ncongruence.\ndestruct CEXEC as (beh1' & EQ').\ndestruct B as (beh1 & EQ).\nsubst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(p : Csyntax.program) (tp : program) (t : trace) (TRANSF : transf_c_program p = OK tp) (CTRACE : c_program_has_initial_trace p t) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) (beh' : program_behavior) (CEXEC : behavior_prefix t beh') (IMPR : behavior_improves beh' beh) : behavior_prefix t beh.","proofString":"destruct IMPR as [EQ | [t' [A B]]].\ncongruence.\ndestruct CEXEC as (beh1' & EQ').\ndestruct B as (beh1 & EQ).\nsubst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(p : Csyntax.program) (tp : program) (t : trace) (TRANSF : transf_c_program p = OK tp) (CTRACE : c_program_has_initial_trace p t) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) (beh' : program_behavior) (CEXEC : behavior_prefix t beh') (EQ : beh' = beh) : behavior_prefix t beh.","proofString":"congruence."},{"statement":"(p : Csyntax.program) (tp : program) (t : trace) (TRANSF : transf_c_program p = OK tp) (CTRACE : c_program_has_initial_trace p t) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) (beh' : program_behavior) (CEXEC : behavior_prefix t beh') (t' : trace) (A : beh' = Goes_wrong t') (B : behavior_prefix t' beh) : behavior_prefix t beh.","proofString":"destruct CEXEC as (beh1' & EQ').\ndestruct B as (beh1 & EQ).\nsubst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(p : Csyntax.program) (tp : program) (t : trace) (TRANSF : transf_c_program p = OK tp) (CTRACE : c_program_has_initial_trace p t) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) (beh' beh1' : program_behavior) (EQ' : beh' = behavior_app t beh1') (t' : trace) (A : beh' = Goes_wrong t') (B : behavior_prefix t' beh) : behavior_prefix t beh.","proofString":"destruct B as (beh1 & EQ).\nsubst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(p : Csyntax.program) (tp : program) (t : trace) (TRANSF : transf_c_program p = OK tp) (CTRACE : c_program_has_initial_trace p t) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) (beh' beh1' : program_behavior) (EQ' : beh' = behavior_app t beh1') (t' : trace) (A : beh' = Goes_wrong t') (beh1 : program_behavior) (EQ : beh = behavior_app t' beh1) : behavior_prefix t beh.","proofString":"subst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(p : Csyntax.program) (tp : program) (t : trace) (TRANSF : transf_c_program p = OK tp) (CTRACE : c_program_has_initial_trace p t) (beh : program_behavior) (AEXEC : program_behaves (semantics tp) beh) (beh1' : program_behavior) (t' : trace) (A : behavior_app t beh1' = Goes_wrong t') (beh1 : program_behavior) (EQ : beh = behavior_app t' beh1) : behavior_prefix t beh.","proofString":"destruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(p : Csyntax.program) (tp : program) (t : trace) (TRANSF : transf_c_program p = OK tp) (CTRACE : c_program_has_initial_trace p t) (beh1 : program_behavior) (t0 : trace) (AEXEC : program_behaves (semantics tp) (behavior_app (t ** t0) beh1)) : behavior_prefix t (behavior_app (t ** t0) beh1).","proofString":"exists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(p : Csyntax.program) (tp : program) (t : trace) (TRANSF : transf_c_program p = OK tp) (CTRACE : c_program_has_initial_trace p t) (beh1 : program_behavior) (t0 : trace) (AEXEC : program_behaves (semantics tp) (behavior_app (t ** t0) beh1)) : behavior_app (t ** t0) beh1 = behavior_app t (behavior_app t0 beh1).","proofString":"apply behavior_app_assoc."},{"statement":"(p : program) (E : link_list asm_units = Some p) : {asm_program : program | Some p = Some asm_program}.","proofString":"exists p; auto."},{"statement":"(E : link_list asm_units = None) : {asm_program : program | None = Some asm_program}.","proofString":"exfalso.\nexploit separate_transf_c_program_correct; eauto.\nintros (a & P & Q).\ncongruence."},{"statement":"(E : link_list asm_units = None) : False.","proofString":"exploit separate_transf_c_program_correct; eauto.\nintros (a & P & Q).\ncongruence."},{"statement":"(E : link_list asm_units = None) : (exists asm_program : program,\n   link_list asm_units = Some asm_program /\\\n   backward_simulation (Csem.semantics c_program) (semantics asm_program)) ->\nFalse.","proofString":"intros (a & P & Q).\ncongruence."},{"statement":"(E : link_list asm_units = None) (a : program) (P : link_list asm_units = Some a) (Q : backward_simulation (Csem.semantics c_program) (semantics a)) : False.","proofString":"congruence."},{"statement":"(beh : program_behavior) (H : program_behaves (semantics asm_program) beh) : exists beh' : program_behavior,\n  program_behaves (Csem.semantics c_program) beh' /\\\n  behavior_improves beh' beh.","proofString":"exploit separate_transf_c_program_correct; eauto.\nintros (a & P & Q).\nassert (a = asm_program) by congruence.\nsubst a.\neapply backward_simulation_behavior_improves; eauto."},{"statement":"(beh : program_behavior) (H : program_behaves (semantics asm_program) beh) : (exists asm_program0 : program,\n   link_list asm_units = Some asm_program0 /\\\n   backward_simulation (Csem.semantics c_program) (semantics asm_program0)) ->\nexists beh' : program_behavior,\n  program_behaves (Csem.semantics c_program) beh' /\\\n  behavior_improves beh' beh.","proofString":"intros (a & P & Q).\nassert (a = asm_program) by congruence.\nsubst a.\neapply backward_simulation_behavior_improves; eauto."},{"statement":"(beh : program_behavior) (H : program_behaves (semantics asm_program) beh) (a : program) (P : link_list asm_units = Some a) (Q : backward_simulation (Csem.semantics c_program) (semantics a)) : exists beh' : program_behavior,\n  program_behaves (Csem.semantics c_program) beh' /\\\n  behavior_improves beh' beh.","proofString":"assert (a = asm_program) by congruence.\nsubst a.\neapply backward_simulation_behavior_improves; eauto."},{"statement":"(beh : program_behavior) (H : program_behaves (semantics asm_program) beh) (a : program) (P : link_list asm_units = Some a) (Q : backward_simulation (Csem.semantics c_program) (semantics a)) (H0 : a = asm_program) : exists beh' : program_behavior,\n  program_behaves (Csem.semantics c_program) beh' /\\\n  behavior_improves beh' beh.","proofString":"subst a.\neapply backward_simulation_behavior_improves; eauto."},{"statement":"(beh : program_behavior) (H : program_behaves (semantics asm_program) beh) (Q : backward_simulation (Csem.semantics c_program) (semantics asm_program)) (P : link_list asm_units = Some asm_program) : exists beh' : program_behavior,\n  program_behaves (Csem.semantics c_program) beh' /\\\n  behavior_improves beh' beh.","proofString":"eapply backward_simulation_behavior_improves; eauto."},{"statement":"(H : forall beh0 : program_behavior,\nprogram_behaves (Csem.semantics c_program) beh0 -> not_wrong beh0) (beh : program_behavior) (H0 : program_behaves (semantics asm_program) beh) : program_behaves (Csem.semantics c_program) beh.","proofString":"exploit separate_transf_c_program_preservation; eauto.\nintros (beh' & P & Q).\nassert (not_wrong beh') by auto.\ninv Q.\nauto.\ndestruct H2 as (t & U & V).\nsubst beh'.\nelim H1."},{"statement":"(H : forall beh0 : program_behavior,\nprogram_behaves (Csem.semantics c_program) beh0 -> not_wrong beh0) (beh : program_behavior) (H0 : program_behaves (semantics asm_program) beh) : (exists beh' : program_behavior,\n   program_behaves (Csem.semantics c_program) beh' /\\\n   behavior_improves beh' beh) ->\nprogram_behaves (Csem.semantics c_program) beh.","proofString":"intros (beh' & P & Q).\nassert (not_wrong beh') by auto.\ninv Q.\nauto.\ndestruct H2 as (t & U & V).\nsubst beh'.\nelim H1."},{"statement":"(H : forall beh0 : program_behavior,\nprogram_behaves (Csem.semantics c_program) beh0 -> not_wrong beh0) (beh : program_behavior) (H0 : program_behaves (semantics asm_program) beh) (beh' : program_behavior) (P : program_behaves (Csem.semantics c_program) beh') (Q : behavior_improves beh' beh) : program_behaves (Csem.semantics c_program) beh.","proofString":"assert (not_wrong beh') by auto.\ninv Q.\nauto.\ndestruct H2 as (t & U & V).\nsubst beh'.\nelim H1."},{"statement":"(H : forall beh0 : program_behavior,\nprogram_behaves (Csem.semantics c_program) beh0 -> not_wrong beh0) (beh : program_behavior) (H0 : program_behaves (semantics asm_program) beh) (beh' : program_behavior) (P : program_behaves (Csem.semantics c_program) beh') (Q : behavior_improves beh' beh) (H1 : not_wrong beh') : program_behaves (Csem.semantics c_program) beh.","proofString":"inv Q.\nauto.\ndestruct H2 as (t & U & V).\nsubst beh'.\nelim H1."},{"statement":"(H : forall beh0 : program_behavior,\nprogram_behaves (Csem.semantics c_program) beh0 -> not_wrong beh0) (beh : program_behavior) (H0 : program_behaves (semantics asm_program) beh) (H1 : not_wrong beh) (P : program_behaves (Csem.semantics c_program) beh) : program_behaves (Csem.semantics c_program) beh.","proofString":"auto."},{"statement":"(H : forall beh0 : program_behavior,\nprogram_behaves (Csem.semantics c_program) beh0 -> not_wrong beh0) (beh : program_behavior) (H0 : program_behaves (semantics asm_program) beh) (beh' : program_behavior) (P : program_behaves (Csem.semantics c_program) beh') (H1 : not_wrong beh') (H2 : exists t : trace, beh' = Goes_wrong t /\\ behavior_prefix t beh) : program_behaves (Csem.semantics c_program) beh.","proofString":"destruct H2 as (t & U & V).\nsubst beh'.\nelim H1."},{"statement":"(H : forall beh0 : program_behavior,\nprogram_behaves (Csem.semantics c_program) beh0 -> not_wrong beh0) (beh : program_behavior) (H0 : program_behaves (semantics asm_program) beh) (beh' : program_behavior) (P : program_behaves (Csem.semantics c_program) beh') (H1 : not_wrong beh') (t : trace) (U : beh' = Goes_wrong t) (V : behavior_prefix t beh) : program_behaves (Csem.semantics c_program) beh.","proofString":"subst beh'.\nelim H1."},{"statement":"(H : forall beh0 : program_behavior,\nprogram_behaves (Csem.semantics c_program) beh0 -> not_wrong beh0) (beh : program_behavior) (H0 : program_behaves (semantics asm_program) beh) (t : trace) (H1 : not_wrong (Goes_wrong t)) (P : program_behaves (Csem.semantics c_program) (Goes_wrong t)) (V : behavior_prefix t beh) : program_behaves (Csem.semantics c_program) beh.","proofString":"elim H1."},{"statement":"(spec : specification) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec c_program spec) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) : spec beh.","proofString":"exploit separate_transf_c_program_preservation; eauto.\nintros (beh' & CEXEC & IMPR).\napply CSAT in CEXEC.\ndestruct IMPR as [EQ | [t [A B]]].\ncongruence.\nsubst beh'.\napply SES in CEXEC.\ncontradiction."},{"statement":"(spec : specification) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec c_program spec) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) : (exists beh' : program_behavior,\n   program_behaves (Csem.semantics c_program) beh' /\\\n   behavior_improves beh' beh) -> spec beh.","proofString":"intros (beh' & CEXEC & IMPR).\napply CSAT in CEXEC.\ndestruct IMPR as [EQ | [t [A B]]].\ncongruence.\nsubst beh'.\napply SES in CEXEC.\ncontradiction."},{"statement":"(spec : specification) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec c_program spec) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) (beh' : program_behavior) (CEXEC : program_behaves (Csem.semantics c_program) beh') (IMPR : behavior_improves beh' beh) : spec beh.","proofString":"apply CSAT in CEXEC.\ndestruct IMPR as [EQ | [t [A B]]].\ncongruence.\nsubst beh'.\napply SES in CEXEC.\ncontradiction."},{"statement":"(spec : specification) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec c_program spec) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) (beh' : program_behavior) (CEXEC : spec beh') (IMPR : behavior_improves beh' beh) : spec beh.","proofString":"destruct IMPR as [EQ | [t [A B]]].\ncongruence.\nsubst beh'.\napply SES in CEXEC.\ncontradiction."},{"statement":"(spec : specification) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec c_program spec) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) (beh' : program_behavior) (CEXEC : spec beh') (EQ : beh' = beh) : spec beh.","proofString":"congruence."},{"statement":"(spec : specification) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec c_program spec) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) (beh' : program_behavior) (CEXEC : spec beh') (t : trace) (A : beh' = Goes_wrong t) (B : behavior_prefix t beh) : spec beh.","proofString":"subst beh'.\napply SES in CEXEC.\ncontradiction."},{"statement":"(spec : specification) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec c_program spec) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) (t : trace) (CEXEC : spec (Goes_wrong t)) (B : behavior_prefix t beh) : spec beh.","proofString":"apply SES in CEXEC.\ncontradiction."},{"statement":"(spec : specification) (SES : safety_enforcing_specification spec) (CSAT : c_program_satisfies_spec c_program spec) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) (t : trace) (CEXEC : not_wrong (Goes_wrong t)) (B : behavior_prefix t beh) : spec beh.","proofString":"contradiction."},{"statement":"(t : trace) (CTRACE : c_program_has_initial_trace c_program t) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) : behavior_prefix t beh.","proofString":"exploit separate_transf_c_program_preservation; eauto.\nintros (beh' & CEXEC & IMPR).\napply CTRACE in CEXEC.\ndestruct IMPR as [EQ | [t' [A B]]].\ncongruence.\ndestruct CEXEC as (beh1' & EQ').\ndestruct B as (beh1 & EQ).\nsubst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(t : trace) (CTRACE : c_program_has_initial_trace c_program t) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) : (exists beh' : program_behavior,\n   program_behaves (Csem.semantics c_program) beh' /\\\n   behavior_improves beh' beh) -> behavior_prefix t beh.","proofString":"intros (beh' & CEXEC & IMPR).\napply CTRACE in CEXEC.\ndestruct IMPR as [EQ | [t' [A B]]].\ncongruence.\ndestruct CEXEC as (beh1' & EQ').\ndestruct B as (beh1 & EQ).\nsubst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(t : trace) (CTRACE : c_program_has_initial_trace c_program t) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) (beh' : program_behavior) (CEXEC : program_behaves (Csem.semantics c_program) beh') (IMPR : behavior_improves beh' beh) : behavior_prefix t beh.","proofString":"apply CTRACE in CEXEC.\ndestruct IMPR as [EQ | [t' [A B]]].\ncongruence.\ndestruct CEXEC as (beh1' & EQ').\ndestruct B as (beh1 & EQ).\nsubst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(t : trace) (CTRACE : c_program_has_initial_trace c_program t) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) (beh' : program_behavior) (CEXEC : behavior_prefix t beh') (IMPR : behavior_improves beh' beh) : behavior_prefix t beh.","proofString":"destruct IMPR as [EQ | [t' [A B]]].\ncongruence.\ndestruct CEXEC as (beh1' & EQ').\ndestruct B as (beh1 & EQ).\nsubst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(t : trace) (CTRACE : c_program_has_initial_trace c_program t) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) (beh' : program_behavior) (CEXEC : behavior_prefix t beh') (EQ : beh' = beh) : behavior_prefix t beh.","proofString":"congruence."},{"statement":"(t : trace) (CTRACE : c_program_has_initial_trace c_program t) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) (beh' : program_behavior) (CEXEC : behavior_prefix t beh') (t' : trace) (A : beh' = Goes_wrong t') (B : behavior_prefix t' beh) : behavior_prefix t beh.","proofString":"destruct CEXEC as (beh1' & EQ').\ndestruct B as (beh1 & EQ).\nsubst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(t : trace) (CTRACE : c_program_has_initial_trace c_program t) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) (beh' beh1' : program_behavior) (EQ' : beh' = behavior_app t beh1') (t' : trace) (A : beh' = Goes_wrong t') (B : behavior_prefix t' beh) : behavior_prefix t beh.","proofString":"destruct B as (beh1 & EQ).\nsubst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(t : trace) (CTRACE : c_program_has_initial_trace c_program t) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) (beh' beh1' : program_behavior) (EQ' : beh' = behavior_app t beh1') (t' : trace) (A : beh' = Goes_wrong t') (beh1 : program_behavior) (EQ : beh = behavior_app t' beh1) : behavior_prefix t beh.","proofString":"subst beh'.\ndestruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(t : trace) (CTRACE : c_program_has_initial_trace c_program t) (beh : program_behavior) (AEXEC : program_behaves (semantics asm_program) beh) (beh1' : program_behavior) (t' : trace) (A : behavior_app t beh1' = Goes_wrong t') (beh1 : program_behavior) (EQ : beh = behavior_app t' beh1) : behavior_prefix t beh.","proofString":"destruct beh1'; simpl in A; inv A.\nexists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(t : trace) (CTRACE : c_program_has_initial_trace c_program t) (beh1 : program_behavior) (t0 : trace) (AEXEC : program_behaves (semantics asm_program) (behavior_app (t ** t0) beh1)) : behavior_prefix t (behavior_app (t ** t0) beh1).","proofString":"exists (behavior_app t0 beh1).\napply behavior_app_assoc."},{"statement":"(t : trace) (CTRACE : c_program_has_initial_trace c_program t) (beh1 : program_behavior) (t0 : trace) (AEXEC : program_behaves (semantics asm_program) (behavior_app (t ** t0) beh1)) : behavior_app (t ** t0) beh1 = behavior_app t (behavior_app t0 beh1).","proofString":"apply behavior_app_assoc."}]}