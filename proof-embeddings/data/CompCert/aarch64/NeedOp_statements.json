{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/aarch64/NeedOp.v","fileSamples":[{"statement":"(v w : val) (a : amount32) (x : nval) (H : vagree v w (shlimm x a)) : vagree (Val.shl v (Vint a)) (Val.shl w (Vint a)) x.","proofString":"apply shlimm_sound; auto."},{"statement":"(v w : val) (a : amount32) (x : nval) (H : vagree v w (shruimm x a)) : vagree (Val.shru v (Vint a)) (Val.shru w (Vint a)) x.","proofString":"apply shruimm_sound; auto."},{"statement":"(v w : val) (a : amount32) (x : nval) (H : vagree v w (shrimm x a)) : vagree (Val.shr v (Vint a)) (Val.shr w (Vint a)) x.","proofString":"apply shrimm_sound; auto."},{"statement":"(v w : val) (a : amount32) (x : nval) (H : vagree v w (ror x a)) : vagree (Val.ror v (Vint a)) (Val.ror w (Vint a)) x.","proofString":"apply ror_sound; auto."},{"statement":"(v w : val) (a : amount64) (x : nval) (H : vagree v w (shllimm x a)) : vagree (Val.shll v (Vint a)) (Val.shll w (Vint a)) x.","proofString":"apply shllimm_sound; auto."},{"statement":"(v w : val) (a : amount64) (x : nval) (H : vagree v w (shrluimm x a)) : vagree (Val.shrlu v (Vint a)) (Val.shrlu w (Vint a)) x.","proofString":"apply shrluimm_sound; auto."},{"statement":"(v w : val) (a : amount64) (x : nval) (H : vagree v w (shrlimm x a)) : vagree (Val.shrl v (Vint a)) (Val.shrl w (Vint a)) x.","proofString":"apply shrlimm_sound; auto."},{"statement":"(v w : val) (a : amount64) (x : nval) (H : vagree v w (rorl x a)) : vagree (Val.rorl v (Vint a)) (Val.rorl w (Vint a)) x.","proofString":"apply rorl_sound; auto."},{"statement":"(v w : val) (ext : extension) (a : amount64) (x : nval) (H : vagree v w\n  match ext with\n  | Xsgn32 => longofint (shllimm x a)\n  | Xuns32 => longofintu (shllimm x a)\n  end) : vagree\n  (Val.shll\n     match ext with\n     | Xsgn32 => Val.longofint v\n     | Xuns32 => Val.longofintu v\n     end (Vint a))\n  (Val.shll\n     match ext with\n     | Xsgn32 => Val.longofint w\n     | Xuns32 => Val.longofintu w\n     end (Vint a)) x.","proofString":"destruct ext; auto using longofint_sound, longofintu_sound, shllimm_sound."},{"statement":"(v w : val) (x : nval) (n : Z) (H : vagree v w (if zle 0 n then zero_ext n x else default x)) : vagree (Val.zero_ext n v) (Val.zero_ext n w) x.","proofString":"destruct (zle 0 n).\napply zero_ext_sound; auto.\nassert (E: x = Nothing \\/ Val.lessdef v w) by (destruct x; auto).\ndestruct E.\nsubst x; simpl; auto.\napply vagree_lessdef; apply Val.zero_ext_lessdef; auto."},{"statement":"(v w : val) (x : nval) (n : Z) (l : 0 <= n) (H : vagree v w (zero_ext n x)) : vagree (Val.zero_ext n v) (Val.zero_ext n w) x.","proofString":"apply zero_ext_sound; auto."},{"statement":"(v w : val) (x : nval) (n : Z) (g : 0 > n) (H : vagree v w (default x)) : vagree (Val.zero_ext n v) (Val.zero_ext n w) x.","proofString":"assert (E: x = Nothing \\/ Val.lessdef v w) by (destruct x; auto).\ndestruct E.\nsubst x; simpl; auto.\napply vagree_lessdef; apply Val.zero_ext_lessdef; auto."},{"statement":"(v w : val) (x : nval) (n : Z) (g : 0 > n) (H : vagree v w (default x)) (E : x = Nothing \\/ Val.lessdef v w) : vagree (Val.zero_ext n v) (Val.zero_ext n w) x.","proofString":"destruct E.\nsubst x; simpl; auto.\napply vagree_lessdef; apply Val.zero_ext_lessdef; auto."},{"statement":"(v w : val) (x : nval) (n : Z) (g : 0 > n) (H : vagree v w (default x)) (H0 : x = Nothing) : vagree (Val.zero_ext n v) (Val.zero_ext n w) x.","proofString":"subst x; simpl; auto."},{"statement":"(v w : val) (x : nval) (n : Z) (g : 0 > n) (H : vagree v w (default x)) (H0 : Val.lessdef v w) : vagree (Val.zero_ext n v) (Val.zero_ext n w) x.","proofString":"apply vagree_lessdef; apply Val.zero_ext_lessdef; auto."},{"statement":"(v w : val) (x : nval) (n : Z) (H : vagree v w (if zlt 0 n then sign_ext n x else default x)) : vagree (Val.sign_ext n v) (Val.sign_ext n w) x.","proofString":"destruct (zlt 0 n).\napply sign_ext_sound; auto.\nassert (E: x = Nothing \\/ Val.lessdef v w) by (destruct x; auto).\ndestruct E.\nsubst x; simpl; auto.\napply vagree_lessdef; apply Val.sign_ext_lessdef; auto."},{"statement":"(v w : val) (x : nval) (n : Z) (l : 0 < n) (H : vagree v w (sign_ext n x)) : vagree (Val.sign_ext n v) (Val.sign_ext n w) x.","proofString":"apply sign_ext_sound; auto."},{"statement":"(v w : val) (x : nval) (n : Z) (g : 0 >= n) (H : vagree v w (default x)) : vagree (Val.sign_ext n v) (Val.sign_ext n w) x.","proofString":"assert (E: x = Nothing \\/ Val.lessdef v w) by (destruct x; auto).\ndestruct E.\nsubst x; simpl; auto.\napply vagree_lessdef; apply Val.sign_ext_lessdef; auto."},{"statement":"(v w : val) (x : nval) (n : Z) (g : 0 >= n) (H : vagree v w (default x)) (E : x = Nothing \\/ Val.lessdef v w) : vagree (Val.sign_ext n v) (Val.sign_ext n w) x.","proofString":"destruct E.\nsubst x; simpl; auto.\napply vagree_lessdef; apply Val.sign_ext_lessdef; auto."},{"statement":"(v w : val) (x : nval) (n : Z) (g : 0 >= n) (H : vagree v w (default x)) (H0 : x = Nothing) : vagree (Val.sign_ext n v) (Val.sign_ext n w) x.","proofString":"subst x; simpl; auto."},{"statement":"(v w : val) (x : nval) (n : Z) (g : 0 >= n) (H : vagree v w (default x)) (H0 : Val.lessdef v w) : vagree (Val.sign_ext n v) (Val.sign_ext n w) x.","proofString":"apply vagree_lessdef; apply Val.sign_ext_lessdef; auto."},{"statement":"(cond : condition) (args : list val) (b : bool) (args' : list val) (H : eval_condition cond args m = Some b) (H0 : vagree_list args args' (needs_of_condition cond)) : eval_condition cond args' m' = Some b.","proofString":"unfold needs_of_condition in H0.\neapply default_needs_of_condition_sound; eauto."},{"statement":"(cond : condition) (args : list val) (b : bool) (args' : list val) (H : eval_condition cond args m = Some b) (H0 : vagree_list args args' nil) : eval_condition cond args' m' = Some b.","proofString":"eapply default_needs_of_condition_sound; eauto."},{"statement":"(s : shift) (a : amount32) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (needs_of_shift s a nv)) : vagree (eval_shift s v0 a) (eval_shift s v2 a) nv.","proofString":"apply shift_sound; auto."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (modarith nv)) (v4 : val) (H4 : vagree v1 v4 (modarith nv)) : vagree (Val.add v0 v1) (Val.add v3 v4) nv.","proofString":"apply add_sound; auto."},{"statement":"(s : shift) (a : amount32) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (modarith nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shift s a (modarith nv))) : vagree (Val.add v0 (eval_shift s v1 a)) (Val.add v3 (eval_shift s v4 a)) nv.","proofString":"apply add_sound; auto using shift_sound."},{"statement":"(n : int) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (modarith nv)) : vagree (Val.add v0 (Vint n)) (Val.add v2 (Vint n)) nv.","proofString":"apply add_sound; auto with na."},{"statement":"(v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (modarith nv)) : vagree (Val.neg v0) (Val.neg v2) nv.","proofString":"apply neg_sound; auto."},{"statement":"(s : shift) (a : amount32) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (needs_of_shift s a (modarith nv))) : vagree (Val.neg (eval_shift s v0 a)) (Val.neg (eval_shift s v2 a)) nv.","proofString":"apply neg_sound; auto using shift_sound."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (modarith nv)) (v4 : val) (H4 : vagree v1 v4 (modarith nv)) : vagree (Val.sub v0 v1) (Val.sub v3 v4) nv.","proofString":"apply sub_sound; auto."},{"statement":"(s : shift) (a : amount32) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (modarith nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shift s a (modarith nv))) : vagree (Val.sub v0 (eval_shift s v1 a)) (Val.sub v3 (eval_shift s v4 a)) nv.","proofString":"apply sub_sound; auto using shift_sound."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (modarith nv)) (v4 : val) (H4 : vagree v1 v4 (modarith nv)) : vagree (Val.mul v0 v1) (Val.mul v3 v4) nv.","proofString":"apply mul_sound; auto."},{"statement":"(v0 v1 v2 : val) (nv : nval) (H1 : nv <> Nothing) (v4 : val) (H6 : vagree v0 v4 (modarith nv)) (v5 : val) (H4 : vagree v1 v5 (modarith nv)) (v6 : val) (H5 : vagree v2 v6 (modarith nv)) : vagree (Val.add v0 (Val.mul v1 v2)) (Val.add v4 (Val.mul v5 v6)) nv.","proofString":"apply add_sound; auto.\napply mul_sound; rewrite modarith_idem; auto."},{"statement":"(v0 v1 v2 : val) (nv : nval) (H1 : nv <> Nothing) (v4 : val) (H6 : vagree v0 v4 (modarith nv)) (v5 : val) (H4 : vagree v1 v5 (modarith nv)) (v6 : val) (H5 : vagree v2 v6 (modarith nv)) : vagree (Val.mul v1 v2) (Val.mul v5 v6) (modarith nv).","proofString":"apply mul_sound; rewrite modarith_idem; auto."},{"statement":"(v0 v1 v2 : val) (nv : nval) (H1 : nv <> Nothing) (v4 : val) (H6 : vagree v0 v4 (modarith nv)) (v5 : val) (H4 : vagree v1 v5 (modarith nv)) (v6 : val) (H5 : vagree v2 v6 (modarith nv)) : vagree (Val.sub v0 (Val.mul v1 v2)) (Val.sub v4 (Val.mul v5 v6)) nv.","proofString":"apply sub_sound; auto.\napply mul_sound; rewrite modarith_idem; auto."},{"statement":"(v0 v1 v2 : val) (nv : nval) (H1 : nv <> Nothing) (v4 : val) (H6 : vagree v0 v4 (modarith nv)) (v5 : val) (H4 : vagree v1 v5 (modarith nv)) (v6 : val) (H5 : vagree v2 v6 (modarith nv)) : vagree (Val.mul v1 v2) (Val.mul v5 v6) (modarith nv).","proofString":"apply mul_sound; rewrite modarith_idem; auto."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise nv)) : vagree (Val.and v0 v1) (Val.and v3 v4) nv.","proofString":"apply and_sound; auto."},{"statement":"(s : shift) (a : amount32) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shift s a (bitwise nv))) : vagree (Val.and v0 (eval_shift s v1 a)) (Val.and v3 (eval_shift s v4 a)) nv.","proofString":"apply and_sound; auto using shift_sound."},{"statement":"(n : int) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (andimm nv n)) : vagree (Val.and v0 (Vint n)) (Val.and v2 (Vint n)) nv.","proofString":"apply andimm_sound; auto."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise nv)) : vagree (Val.or v0 v1) (Val.or v3 v4) nv.","proofString":"apply or_sound; auto."},{"statement":"(s : shift) (a : amount32) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shift s a (bitwise nv))) : vagree (Val.or v0 (eval_shift s v1 a)) (Val.or v3 (eval_shift s v4 a)) nv.","proofString":"apply or_sound; auto using shift_sound."},{"statement":"(n : int) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (orimm nv n)) : vagree (Val.or v0 (Vint n)) (Val.or v2 (Vint n)) nv.","proofString":"apply orimm_sound; auto."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise nv)) : vagree (Val.xor v0 v1) (Val.xor v3 v4) nv.","proofString":"apply xor_sound; auto."},{"statement":"(s : shift) (a : amount32) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shift s a (bitwise nv))) : vagree (Val.xor v0 (eval_shift s v1 a)) (Val.xor v3 (eval_shift s v4 a)) nv.","proofString":"apply xor_sound; auto using shift_sound."},{"statement":"(n : int) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (bitwise nv)) : vagree (Val.xor v0 (Vint n)) (Val.xor v2 (Vint n)) nv.","proofString":"apply xor_sound; auto with na."},{"statement":"(v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (bitwise nv)) : vagree (Val.notint v0) (Val.notint v2) nv.","proofString":"apply notint_sound; auto."},{"statement":"(s : shift) (a : amount32) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (needs_of_shift s a (bitwise nv))) : vagree (Val.notint (eval_shift s v0 a)) (Val.notint (eval_shift s v2 a)) nv.","proofString":"apply notint_sound; auto using shift_sound."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise (bitwise nv))) : vagree (Val.and v0 (Val.notint v1)) (Val.and v3 (Val.notint v4)) nv.","proofString":"apply and_sound; auto.\napply notint_sound; rewrite bitwise_idem; auto."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise (bitwise nv))) : vagree (Val.notint v1) (Val.notint v4) (bitwise nv).","proofString":"apply notint_sound; rewrite bitwise_idem; auto."},{"statement":"(s : shift) (a : amount32) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shift s a (bitwise (bitwise nv)))) : vagree (Val.and v0 (Val.notint (eval_shift s v1 a)))\n  (Val.and v3 (Val.notint (eval_shift s v4 a))) nv.","proofString":"apply and_sound; auto.\napply notint_sound; rewrite bitwise_idem; auto using shift_sound."},{"statement":"(s : shift) (a : amount32) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shift s a (bitwise (bitwise nv)))) : vagree (Val.notint (eval_shift s v1 a)) (Val.notint (eval_shift s v4 a))\n  (bitwise nv).","proofString":"apply notint_sound; rewrite bitwise_idem; auto using shift_sound."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise (bitwise nv))) : vagree (Val.or v0 (Val.notint v1)) (Val.or v3 (Val.notint v4)) nv.","proofString":"apply or_sound; auto.\napply notint_sound; rewrite bitwise_idem; auto."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise (bitwise nv))) : vagree (Val.notint v1) (Val.notint v4) (bitwise nv).","proofString":"apply notint_sound; rewrite bitwise_idem; auto."},{"statement":"(s : shift) (a : amount32) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shift s a (bitwise (bitwise nv)))) : vagree (Val.or v0 (Val.notint (eval_shift s v1 a)))\n  (Val.or v3 (Val.notint (eval_shift s v4 a))) nv.","proofString":"apply or_sound; auto.\napply notint_sound; rewrite bitwise_idem; auto using shift_sound."},{"statement":"(s : shift) (a : amount32) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shift s a (bitwise (bitwise nv)))) : vagree (Val.notint (eval_shift s v1 a)) (Val.notint (eval_shift s v4 a))\n  (bitwise nv).","proofString":"apply notint_sound; rewrite bitwise_idem; auto using shift_sound."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise (bitwise nv))) : vagree (Val.xor v0 (Val.notint v1)) (Val.xor v3 (Val.notint v4)) nv.","proofString":"apply xor_sound; auto.\napply notint_sound; rewrite bitwise_idem; auto."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise (bitwise nv))) : vagree (Val.notint v1) (Val.notint v4) (bitwise nv).","proofString":"apply notint_sound; rewrite bitwise_idem; auto."},{"statement":"(s : shift) (a : amount32) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shift s a (bitwise (bitwise nv)))) : vagree (Val.xor v0 (Val.notint (eval_shift s v1 a)))\n  (Val.xor v3 (Val.notint (eval_shift s v4 a))) nv.","proofString":"apply xor_sound; auto.\napply notint_sound; rewrite bitwise_idem; auto using shift_sound."},{"statement":"(s : shift) (a : amount32) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shift s a (bitwise (bitwise nv)))) : vagree (Val.notint (eval_shift s v1 a)) (Val.notint (eval_shift s v4 a))\n  (bitwise nv).","proofString":"apply notint_sound; rewrite bitwise_idem; auto using shift_sound."},{"statement":"(s : Z) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (zero_ext' s nv)) : vagree (Val.zero_ext s v0) (Val.zero_ext s v2) nv.","proofString":"apply zero_ext'_sound; auto."},{"statement":"(s : Z) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (sign_ext' s nv)) : vagree (Val.sign_ext s v0) (Val.sign_ext s v2) nv.","proofString":"apply sign_ext'_sound; auto."},{"statement":"(s : Z) (a : amount32) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (zero_ext' s (shlimm nv a))) : vagree (Val.shl (Val.zero_ext s v0) (Vint a))\n  (Val.shl (Val.zero_ext s v2) (Vint a)) nv.","proofString":"apply shlimm_sound; apply zero_ext'_sound; auto."},{"statement":"(s : Z) (a : amount32) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (sign_ext' s (shlimm nv a))) : vagree (Val.shl (Val.sign_ext s v0) (Vint a))\n  (Val.shl (Val.sign_ext s v2) (Vint a)) nv.","proofString":"apply shlimm_sound; apply sign_ext'_sound; auto."},{"statement":"(a : amount32) (s : Z) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (shruimm (zero_ext' s nv) a)) : vagree (Val.zero_ext s (Val.shru v0 (Vint a)))\n  (Val.zero_ext s (Val.shru v2 (Vint a))) nv.","proofString":"apply zero_ext'_sound; apply shruimm_sound; auto."},{"statement":"(a : amount32) (s : Z) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (shrimm (sign_ext' s nv) a)) : vagree (Val.sign_ext s (Val.shr v0 (Vint a)))\n  (Val.sign_ext s (Val.shr v2 (Vint a))) nv.","proofString":"apply sign_ext'_sound; apply shrimm_sound; auto."},{"statement":"(s : shift) (a : amount64) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (needs_of_shiftl s a nv)) : vagree (eval_shiftl s v0 a) (eval_shiftl s v2 a) nv.","proofString":"apply shiftl_sound; auto."},{"statement":"(x : extension) (a : amount64) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (needs_of_extend x a nv)) : vagree (eval_extend x v0 a) (eval_extend x v2 a) nv.","proofString":"apply extend_sound; auto."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (makelong_hi nv)) (v4 : val) (H4 : vagree v1 v4 (makelong_lo nv)) : vagree (Val.longofwords v0 v1) (Val.longofwords v3 v4) nv.","proofString":"apply makelong_sound; auto."},{"statement":"(v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (loword nv)) : vagree (Val.loword v0) (Val.loword v2) nv.","proofString":"apply loword_sound; auto."},{"statement":"(v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (hiword nv)) : vagree (Val.hiword v0) (Val.hiword v2) nv.","proofString":"apply hiword_sound; auto."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (modarith nv)) (v4 : val) (H4 : vagree v1 v4 (modarith nv)) : vagree (Val.addl v0 v1) (Val.addl v3 v4) nv.","proofString":"apply addl_sound; auto."},{"statement":"(s : shift) (a : amount64) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (modarith nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shiftl s a (modarith nv))) : vagree (Val.addl v0 (eval_shiftl s v1 a)) (Val.addl v3 (eval_shiftl s v4 a))\n  nv.","proofString":"apply addl_sound; auto using shiftl_sound."},{"statement":"(x : extension) (a : amount64) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (modarith nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_extend x a (modarith nv))) : vagree (Val.addl v0 (eval_extend x v1 a)) (Val.addl v3 (eval_extend x v4 a))\n  nv.","proofString":"apply addl_sound; auto using extend_sound."},{"statement":"(n : int64) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (modarith nv)) : vagree (Val.addl v0 (Vlong n)) (Val.addl v2 (Vlong n)) nv.","proofString":"apply addl_sound; auto with na."},{"statement":"(v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (modarith nv)) : vagree (Val.negl v0) (Val.negl v2) nv.","proofString":"apply negl_sound; auto."},{"statement":"(s : shift) (a : amount64) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (needs_of_shiftl s a (modarith nv))) : vagree (Val.negl (eval_shiftl s v0 a)) (Val.negl (eval_shiftl s v2 a)) nv.","proofString":"apply negl_sound; auto using shiftl_sound."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (modarith nv)) (v4 : val) (H4 : vagree v1 v4 (modarith nv)) : vagree (Val.mull v0 v1) (Val.mull v3 v4) nv.","proofString":"apply mull_sound; auto."},{"statement":"(v0 v1 v2 : val) (nv : nval) (H1 : nv <> Nothing) (v4 : val) (H6 : vagree v0 v4 (modarith nv)) (v5 : val) (H4 : vagree v1 v5 (modarith nv)) (v6 : val) (H5 : vagree v2 v6 (modarith nv)) : vagree (Val.addl v0 (Val.mull v1 v2)) (Val.addl v4 (Val.mull v5 v6)) nv.","proofString":"apply addl_sound; auto.\napply mull_sound; rewrite modarith_idem; auto."},{"statement":"(v0 v1 v2 : val) (nv : nval) (H1 : nv <> Nothing) (v4 : val) (H6 : vagree v0 v4 (modarith nv)) (v5 : val) (H4 : vagree v1 v5 (modarith nv)) (v6 : val) (H5 : vagree v2 v6 (modarith nv)) : vagree (Val.mull v1 v2) (Val.mull v5 v6) (modarith nv).","proofString":"apply mull_sound; rewrite modarith_idem; auto."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise nv)) : vagree (Val.andl v0 v1) (Val.andl v3 v4) nv.","proofString":"apply andl_sound; auto."},{"statement":"(s : shift) (a : amount64) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shiftl s a (bitwise nv))) : vagree (Val.andl v0 (eval_shiftl s v1 a)) (Val.andl v3 (eval_shiftl s v4 a))\n  nv.","proofString":"apply andl_sound; auto using shiftl_sound."},{"statement":"(n : int64) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (andlimm nv n)) : vagree (Val.andl v0 (Vlong n)) (Val.andl v2 (Vlong n)) nv.","proofString":"apply andlimm_sound; auto."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise nv)) : vagree (Val.orl v0 v1) (Val.orl v3 v4) nv.","proofString":"apply orl_sound; auto."},{"statement":"(s : shift) (a : amount64) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shiftl s a (bitwise nv))) : vagree (Val.orl v0 (eval_shiftl s v1 a)) (Val.orl v3 (eval_shiftl s v4 a)) nv.","proofString":"apply orl_sound; auto using shiftl_sound."},{"statement":"(n : int64) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (orlimm nv n)) : vagree (Val.orl v0 (Vlong n)) (Val.orl v2 (Vlong n)) nv.","proofString":"apply orlimm_sound; auto."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise nv)) : vagree (Val.xorl v0 v1) (Val.xorl v3 v4) nv.","proofString":"apply xorl_sound; auto."},{"statement":"(s : shift) (a : amount64) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shiftl s a (bitwise nv))) : vagree (Val.xorl v0 (eval_shiftl s v1 a)) (Val.xorl v3 (eval_shiftl s v4 a))\n  nv.","proofString":"apply xorl_sound; auto using shiftl_sound."},{"statement":"(n : int64) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (bitwise nv)) : vagree (Val.xorl v0 (Vlong n)) (Val.xorl v2 (Vlong n)) nv.","proofString":"apply xorl_sound; auto with na."},{"statement":"(v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (bitwise nv)) : vagree (Val.notl v0) (Val.notl v2) nv.","proofString":"apply notl_sound; auto."},{"statement":"(s : shift) (a : amount64) (v0 : val) (nv : nval) (H1 : nv <> Nothing) (v2 : val) (H6 : vagree v0 v2 (needs_of_shiftl s a (bitwise nv))) : vagree (Val.notl (eval_shiftl s v0 a)) (Val.notl (eval_shiftl s v2 a)) nv.","proofString":"apply notl_sound; auto using shiftl_sound."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise nv)) : vagree (Val.andl v0 (Val.notl v1)) (Val.andl v3 (Val.notl v4)) nv.","proofString":"apply andl_sound; auto using notl_sound."},{"statement":"(s : shift) (a : amount64) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shiftl s a (bitwise (bitwise nv)))) : vagree (Val.andl v0 (Val.notl (eval_shiftl s v1 a)))\n  (Val.andl v3 (Val.notl (eval_shiftl s v4 a))) nv.","proofString":"apply andl_sound; auto using notl_sound, shiftl_sound."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise nv)) : vagree (Val.orl v0 (Val.notl v1)) (Val.orl v3 (Val.notl v4)) nv.","proofString":"apply orl_sound; auto using notl_sound."},{"statement":"(s : shift) (a : amount64) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shiftl s a (bitwise (bitwise nv)))) : vagree (Val.orl v0 (Val.notl (eval_shiftl s v1 a)))\n  (Val.orl v3 (Val.notl (eval_shiftl s v4 a))) nv.","proofString":"apply orl_sound; auto using notl_sound, shiftl_sound."},{"statement":"(v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (bitwise nv)) : vagree (Val.xorl v0 (Val.notl v1)) (Val.xorl v3 (Val.notl v4)) nv.","proofString":"apply xorl_sound; auto using notl_sound."},{"statement":"(s : shift) (a : amount64) (v0 v1 : val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 (bitwise nv)) (v4 : val) (H4 : vagree v1 v4 (needs_of_shiftl s a (bitwise (bitwise nv)))) : vagree (Val.xorl v0 (Val.notl (eval_shiftl s v1 a)))\n  (Val.xorl v3 (Val.notl (eval_shiftl s v4 a))) nv.","proofString":"apply xorl_sound; auto using notl_sound, shiftl_sound."},{"statement":"(cond : condition) (ty : typ) (v0 v1 : val) (args : list val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 nv) (v4 : val) (vl0 : list val) (H4 : vagree v1 v4 nv) (H7 : vagree_list args vl0 (needs_of_condition cond)) : vagree (Val.select (eval_condition cond args m) v0 v1 ty)\n  (Val.select (eval_condition cond vl0 m') v3 v4 ty) nv.","proofString":"destruct (eval_condition cond args m) as [b|] eqn:EC.\nerewrite needs_of_condition_sound by eauto.\napply select_sound; auto.\nsimpl; auto with na."},{"statement":"(cond : condition) (ty : typ) (v0 v1 : val) (args : list val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 nv) (v4 : val) (vl0 : list val) (H4 : vagree v1 v4 nv) (H7 : vagree_list args vl0 (needs_of_condition cond)) (b : bool) (EC : eval_condition cond args m = Some b) : vagree (Val.select (Some b) v0 v1 ty)\n  (Val.select (eval_condition cond vl0 m') v3 v4 ty) nv.","proofString":"erewrite needs_of_condition_sound by eauto.\napply select_sound; auto."},{"statement":"(cond : condition) (ty : typ) (v0 v1 : val) (args : list val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 nv) (v4 : val) (vl0 : list val) (H4 : vagree v1 v4 nv) (H7 : vagree_list args vl0 (needs_of_condition cond)) (b : bool) (EC : eval_condition cond args m = Some b) : vagree (Val.select (Some b) v0 v1 ty) (Val.select (Some b) v3 v4 ty) nv.","proofString":"apply select_sound; auto."},{"statement":"(cond : condition) (ty : typ) (v0 v1 : val) (args : list val) (nv : nval) (H1 : nv <> Nothing) (v3 : val) (H6 : vagree v0 v3 nv) (v4 : val) (vl0 : list val) (H4 : vagree v1 v4 nv) (H7 : vagree_list args vl0 (needs_of_condition cond)) (EC : eval_condition cond args m = None) : vagree (Val.select None v0 v1 ty)\n  (Val.select (eval_condition cond vl0 m') v3 v4 ty) nv.","proofString":"simpl; auto with na."},{"statement":"(op : operation) (nv : nval) (arg1 : val) (args : list val) (v arg1' : val) (args' : list val) (H : operation_is_redundant op nv = true) (H0 : eval_operation ge (Vptr sp Ptrofs.zero) op (arg1 :: args) m = Some v) (H1 : vagree_list (arg1 :: args) (arg1' :: args') (needs_of_operation op nv)) : vagree v arg1' nv.","proofString":"destruct op; simpl in *; try discriminate; inv H1; FuncInv; subst.\napply andimm_redundant_sound; auto.\napply orimm_redundant_sound; auto.\nInvBooleans.\nunfold zero_ext' in H5; rewrite zle_true in H5 by auto.\napply zero_ext_redundant_sound; auto.\nInvBooleans.\nunfold sign_ext' in H5; rewrite zlt_true in H5 by auto.\napply sign_ext_redundant_sound; auto.\napply andlimm_redundant_sound; auto.\napply orlimm_redundant_sound; auto."},{"statement":"(n : int) (nv : nval) (arg1 arg1' : val) (args' : list val) (H : andimm_redundant nv n = true) (H5 : vagree arg1 arg1' (andimm nv n)) (H9 : vagree_list nil args' nil) : vagree (Val.and arg1 (Vint n)) arg1' nv.","proofString":"apply andimm_redundant_sound; auto."},{"statement":"(n : int) (nv : nval) (arg1 arg1' : val) (args' : list val) (H : orimm_redundant nv n = true) (H5 : vagree arg1 arg1' (orimm nv n)) (H9 : vagree_list nil args' nil) : vagree (Val.or arg1 (Vint n)) arg1' nv.","proofString":"apply orimm_redundant_sound; auto."},{"statement":"(s : Z) (nv : nval) (arg1 arg1' : val) (args' : list val) (H : zle 0 s && zero_ext_redundant s nv = true) (H5 : vagree arg1 arg1' (zero_ext' s nv)) (H9 : vagree_list nil args' nil) : vagree (Val.zero_ext s arg1) arg1' nv.","proofString":"InvBooleans.\nunfold zero_ext' in H5; rewrite zle_true in H5 by auto.\napply zero_ext_redundant_sound; auto."},{"statement":"(s : Z) (nv : nval) (arg1 arg1' : val) (args' : list val) (H5 : vagree arg1 arg1' (zero_ext' s nv)) (H9 : vagree_list nil args' nil) (H1 : zero_ext_redundant s nv = true) (H : 0 <= s) : vagree (Val.zero_ext s arg1) arg1' nv.","proofString":"unfold zero_ext' in H5; rewrite zle_true in H5 by auto.\napply zero_ext_redundant_sound; auto."},{"statement":"(s : Z) (nv : nval) (arg1 arg1' : val) (args' : list val) (H5 : vagree arg1 arg1' (zero_ext s nv)) (H9 : vagree_list nil args' nil) (H1 : zero_ext_redundant s nv = true) (H : 0 <= s) : vagree (Val.zero_ext s arg1) arg1' nv.","proofString":"apply zero_ext_redundant_sound; auto."},{"statement":"(s : Z) (nv : nval) (arg1 arg1' : val) (args' : list val) (H : zlt 0 s && sign_ext_redundant s nv = true) (H5 : vagree arg1 arg1' (sign_ext' s nv)) (H9 : vagree_list nil args' nil) : vagree (Val.sign_ext s arg1) arg1' nv.","proofString":"InvBooleans.\nunfold sign_ext' in H5; rewrite zlt_true in H5 by auto.\napply sign_ext_redundant_sound; auto."},{"statement":"(s : Z) (nv : nval) (arg1 arg1' : val) (args' : list val) (H5 : vagree arg1 arg1' (sign_ext' s nv)) (H9 : vagree_list nil args' nil) (H1 : sign_ext_redundant s nv = true) (H : 0 < s) : vagree (Val.sign_ext s arg1) arg1' nv.","proofString":"unfold sign_ext' in H5; rewrite zlt_true in H5 by auto.\napply sign_ext_redundant_sound; auto."},{"statement":"(s : Z) (nv : nval) (arg1 arg1' : val) (args' : list val) (H5 : vagree arg1 arg1' (sign_ext s nv)) (H9 : vagree_list nil args' nil) (H1 : sign_ext_redundant s nv = true) (H : 0 < s) : vagree (Val.sign_ext s arg1) arg1' nv.","proofString":"apply sign_ext_redundant_sound; auto."},{"statement":"(n : int64) (nv : nval) (arg1 arg1' : val) (args' : list val) (H : andlimm_redundant nv n = true) (H5 : vagree arg1 arg1' (andlimm nv n)) (H9 : vagree_list nil args' nil) : vagree (Val.andl arg1 (Vlong n)) arg1' nv.","proofString":"apply andlimm_redundant_sound; auto."},{"statement":"(n : int64) (nv : nval) (arg1 arg1' : val) (args' : list val) (H : orlimm_redundant nv n = true) (H5 : vagree arg1 arg1' (orlimm nv n)) (H9 : vagree_list nil args' nil) : vagree (Val.orl arg1 (Vlong n)) arg1' nv.","proofString":"apply orlimm_redundant_sound; auto."}]}