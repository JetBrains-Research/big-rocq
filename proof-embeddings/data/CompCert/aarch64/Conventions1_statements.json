{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/aarch64/Conventions1.v","fileSamples":[{"statement":"(sig : signature) : subtype (proj_sig_res sig) (typ_rpair mreg_type (loc_result sig)) = true.","proofString":"unfold loc_result.\ndestruct (proj_sig_res sig); auto."},{"statement":"(sig : signature) : subtype (proj_sig_res sig)\n  (typ_rpair mreg_type\n     match proj_sig_res sig with\n     | Tfloat | Tsingle => One F0\n     | _ => One R0\n     end) = true.","proofString":"destruct (proj_sig_res sig); auto."},{"statement":"(s : signature) : forall_rpair (fun r : mreg => is_callee_save r = false) (loc_result s).","proofString":"unfold loc_result.\ndestruct (proj_sig_res s); simpl; auto."},{"statement":"(s : signature) : forall_rpair (fun r : mreg => is_callee_save r = false)\n  match proj_sig_res s with\n  | Tfloat | Tsingle => One F0\n  | _ => One R0\n  end.","proofString":"destruct (proj_sig_res s); simpl; auto."},{"statement":"(s1 s2 : signature) (H : sig_res s1 = sig_res s2) : loc_result s1 = loc_result s2.","proofString":"unfold loc_result, proj_sig_res.\nrewrite H; auto."},{"statement":"(s1 s2 : signature) (H : sig_res s1 = sig_res s2) : match proj_xtype (sig_res s1) with\n| Tfloat | Tsingle => One F0\n| _ => One R0\nend =\nmatch proj_xtype (sig_res s2) with\n| Tfloat | Tsingle => One F0\n| _ => One R0\nend.","proofString":"rewrite H; auto."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) : forall r : mreg, In r int_param_regs -> is_callee_save r = false.","proofString":"decide_goal."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) : forall r : mreg, In r float_param_regs -> is_callee_save r = false.","proofString":"decide_goal."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) : forall (ofs : Z) (ty : typ), ofs >= 0 -> align ofs (typesize ty) >= 0.","proofString":"intros.\nassert (ofs <= align ofs (typesize ty)) by (apply align_le; apply typesize_pos).\nlia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ofs : Z) (ty : typ) (H : ofs >= 0) : align ofs (typesize ty) >= 0.","proofString":"assert (ofs <= align ofs (typesize ty)) by (apply align_le; apply typesize_pos).\nlia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ofs : Z) (ty : typ) (H : ofs >= 0) (H0 : ofs <= align ofs (typesize ty)) : align ofs (typesize ty) >= 0.","proofString":"lia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs : Z) (ty : typ), ofs >= 0 -> align ofs (typesize ty) >= 0) : forall (ofs : Z) (ty : typ),\nofs >= 0 -> (typealign ty | align ofs (typesize ty)).","proofString":"intros.\napply Z.divide_trans with (typesize ty).\napply typealign_typesize.\napply align_divides.\napply typesize_pos."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ofs : Z) (ty : typ) (H : ofs >= 0) : (typealign ty | align ofs (typesize ty)).","proofString":"apply Z.divide_trans with (typesize ty).\napply typealign_typesize.\napply align_divides.\napply typesize_pos."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ofs : Z) (ty : typ) (H : ofs >= 0) : (typealign ty | typesize ty).","proofString":"apply typealign_typesize."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ofs : Z) (ty : typ) (H : ofs >= 0) : (typesize ty | align ofs (typesize ty)).","proofString":"apply align_divides.\napply typesize_pos."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ofs : Z) (ty : typ) (H : ofs >= 0) : typesize ty > 0.","proofString":"apply typesize_pos."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs : Z) (ty : typ), ofs >= 0 -> align ofs (typesize ty) >= 0) (ALD : forall (ofs : Z) (ty : typ),\nofs >= 0 -> (typealign ty | align ofs (typesize ty))) : forall ofs : Z, ofs >= 0 -> align ofs 2 >= 0.","proofString":"intros.\nassert (ofs <= align ofs 2) by (apply align_le; lia).\nlia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty : typ), ofs0 >= 0 -> align ofs0 (typesize ty) >= 0) (ALD : forall (ofs0 : Z) (ty : typ),\nofs0 >= 0 -> (typealign ty | align ofs0 (typesize ty))) (ofs : Z) (H : ofs >= 0) : align ofs 2 >= 0.","proofString":"assert (ofs <= align ofs 2) by (apply align_le; lia).\nlia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty : typ), ofs0 >= 0 -> align ofs0 (typesize ty) >= 0) (ALD : forall (ofs0 : Z) (ty : typ),\nofs0 >= 0 -> (typealign ty | align ofs0 (typesize ty))) (ofs : Z) (H : ofs >= 0) (H0 : ofs <= align ofs 2) : align ofs 2 >= 0.","proofString":"lia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs : Z) (ty : typ), ofs >= 0 -> align ofs (typesize ty) >= 0) (ALD : forall (ofs : Z) (ty : typ),\nofs >= 0 -> (typealign ty | align ofs (typesize ty))) (ALP2 : forall ofs : Z, ofs >= 0 -> align ofs 2 >= 0) : forall (ofs : Z) (ty : typ), ofs >= 0 -> (typealign ty | align ofs 2).","proofString":"intros.\neapply Z.divide_trans with 2.\nexists (2 / typealign ty).\ndestruct ty; reflexivity.\napply align_divides.\nlia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ofs : Z) (ty : typ) (H : ofs >= 0) : (typealign ty | align ofs 2).","proofString":"eapply Z.divide_trans with 2.\nexists (2 / typealign ty).\ndestruct ty; reflexivity.\napply align_divides.\nlia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ofs : Z) (ty : typ) (H : ofs >= 0) : (typealign ty | 2).","proofString":"exists (2 / typealign ty).\ndestruct ty; reflexivity."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ofs : Z) (ty : typ) (H : ofs >= 0) : 2 = 2 / typealign ty * typealign ty.","proofString":"destruct ty; reflexivity."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ofs : Z) (ty : typ) (H : ofs >= 0) : (2 | align ofs 2).","proofString":"apply align_divides.\nlia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ofs : Z) (ty : typ) (H : ofs >= 0) : 2 > 0.","proofString":"lia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty : typ), ofs0 >= 0 -> align ofs0 (typesize ty) >= 0) (ALD : forall (ofs0 : Z) (ty : typ),\nofs0 >= 0 -> (typealign ty | align ofs0 (typesize ty))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty : typ), ofs0 >= 0 -> (typealign ty | align ofs0 2)) (ofs : Z) (OO : ofs >= 0) (p : rpair loc) (H : False) : forall_rpair loc_argument_acceptable p.","proofString":"contradiction."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (ty : typ) (tyl : list typ) (IHtyl : forall ofs0 : Z, ofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ofs : Z) (OO : ofs >= 0) (p : rpair loc) (H : One (S Outgoing ofs Tany64) = p) : forall_rpair loc_argument_acceptable p.","proofString":"subst p.\nsplit.\nauto.\nsimpl.\napply Z.divide_1_l."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (ty : typ) (tyl : list typ) (IHtyl : forall ofs0 : Z, ofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ofs : Z) (OO : ofs >= 0) : forall_rpair loc_argument_acceptable (One (S Outgoing ofs Tany64)).","proofString":"split.\nauto.\nsimpl.\napply Z.divide_1_l."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (ty : typ) (tyl : list typ) (IHtyl : forall ofs0 : Z, ofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ofs : Z) (OO : ofs >= 0) : ofs >= 0.","proofString":"auto."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (ty : typ) (tyl : list typ) (IHtyl : forall ofs0 : Z, ofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ofs : Z) (OO : ofs >= 0) : (typealign Tany64 | ofs).","proofString":"simpl.\napply Z.divide_1_l."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (ty : typ) (tyl : list typ) (IHtyl : forall ofs0 : Z, ofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ofs : Z) (OO : ofs >= 0) : (1 | ofs).","proofString":"apply Z.divide_1_l."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (ty : typ) (tyl : list typ) (IHtyl : forall ofs0 : Z, ofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ofs : Z) (OO : ofs >= 0) (p : rpair loc) (H : In p (loc_arguments_stack tyl (ofs + 2))) : ofs + 2 >= 0.","proofString":"lia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (ty : typ) (tyl : list typ) (IHtyl : forall ofs0 : Z, ofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ofs : Z) (OO : ofs >= 0) (p : rpair loc) (H : In p (loc_arguments_stack tyl (ofs + 2))) : In p (loc_arguments_stack tyl (ofs + 2)).","proofString":"auto."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (STK : forall (tyl : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)) (OF : OKF f) (OO : ofs >= 0) (p : rpair loc) (H : One (S Outgoing (align ofs 2) ty) = p) : forall_rpair loc_argument_acceptable p.","proofString":"subst p; simpl; auto."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (STK : forall (tyl : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)) (OF : OKF f) (OO : ofs >= 0) (p : rpair loc) (H : In p (f ri rf (align ofs 2 + 2))) : align ofs 2 + 2 >= 0.","proofString":"apply ALP2 in OO.\nlia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (STK : forall (tyl : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)) (OF : OKF f) (OO : align ofs 2 >= 0) (p : rpair loc) (H : In p (f ri rf (align ofs 2 + 2))) : align ofs 2 + 2 >= 0.","proofString":"lia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (STK : forall (tyl : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)) (OF : OKF f) (OO : ofs >= 0) (p : rpair loc) (H : One (S Outgoing (align ofs (typesize ty)) ty) = p) : forall_rpair loc_argument_acceptable p.","proofString":"subst p; simpl; auto."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (STK : forall (tyl : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)) (OF : OKF f) (OO : ofs >= 0) (p : rpair loc) (H : In p (f ri rf (align ofs (typesize ty) + typesize ty))) : align ofs (typesize ty) + typesize ty >= 0.","proofString":"apply (ALP ofs ty) in OO.\ngeneralize (typesize_pos ty).\nlia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (STK : forall (tyl : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)) (OF : OKF f) (OO : align ofs (typesize ty) >= 0) (p : rpair loc) (H : In p (f ri rf (align ofs (typesize ty) + typesize ty))) : align ofs (typesize ty) + typesize ty >= 0.","proofString":"generalize (typesize_pos ty).\nlia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (STK : forall (tyl : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)) (OF : OKF f) (OO : align ofs (typesize ty) >= 0) (p : rpair loc) (H : In p (f ri rf (align ofs (typesize ty) + typesize ty))) : typesize ty > 0 -> align ofs (typesize ty) + typesize ty >= 0.","proofString":"lia."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r0 : mreg, In r0 int_param_regs -> is_callee_save r0 = false) (CSF : forall r0 : mreg, In r0 float_param_regs -> is_callee_save r0 = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (STK : forall (tyl : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (A : forall (ty0 : typ) (ri0 rf0 ofs0 : Z) (f0 : Z -> Z -> Z -> list (rpair loc)),\nOKF f0 -> ofs0 >= 0 -> OK (stack_arg ty0 ri0 rf0 ofs0 f0)) (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)) (OF : OKF f) (OO : ofs >= 0) (p : rpair loc) (r : mreg) (NTH : list_nth_z int_param_regs ri = Some r) (H : One (R r) = p) : forall_rpair loc_argument_acceptable p.","proofString":"subst p; simpl.\napply CSI.\neapply list_nth_z_in; eauto."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r0 : mreg, In r0 int_param_regs -> is_callee_save r0 = false) (CSF : forall r0 : mreg, In r0 float_param_regs -> is_callee_save r0 = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (STK : forall (tyl : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (A : forall (ty0 : typ) (ri0 rf0 ofs0 : Z) (f0 : Z -> Z -> Z -> list (rpair loc)),\nOKF f0 -> ofs0 >= 0 -> OK (stack_arg ty0 ri0 rf0 ofs0 f0)) (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)) (OF : OKF f) (OO : ofs >= 0) (r : mreg) (NTH : list_nth_z int_param_regs ri = Some r) : is_callee_save r = false.","proofString":"apply CSI.\neapply list_nth_z_in; eauto."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r0 : mreg, In r0 int_param_regs -> is_callee_save r0 = false) (CSF : forall r0 : mreg, In r0 float_param_regs -> is_callee_save r0 = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (STK : forall (tyl : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (A : forall (ty0 : typ) (ri0 rf0 ofs0 : Z) (f0 : Z -> Z -> Z -> list (rpair loc)),\nOKF f0 -> ofs0 >= 0 -> OK (stack_arg ty0 ri0 rf0 ofs0 f0)) (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)) (OF : OKF f) (OO : ofs >= 0) (r : mreg) (NTH : list_nth_z int_param_regs ri = Some r) : In r int_param_regs.","proofString":"eapply list_nth_z_in; eauto."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r0 : mreg, In r0 int_param_regs -> is_callee_save r0 = false) (CSF : forall r0 : mreg, In r0 float_param_regs -> is_callee_save r0 = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (STK : forall (tyl : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (A : forall (ty0 : typ) (ri0 rf0 ofs0 : Z) (f0 : Z -> Z -> Z -> list (rpair loc)),\nOKF f0 -> ofs0 >= 0 -> OK (stack_arg ty0 ri0 rf0 ofs0 f0)) (B : forall (ty0 : typ) (ri0 rf0 ofs0 : Z) (f0 : Z -> Z -> Z -> list (rpair loc)),\nOKF f0 -> ofs0 >= 0 -> OK (int_arg ty0 ri0 rf0 ofs0 f0)) (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)) (OF : OKF f) (OO : ofs >= 0) (p : rpair loc) (r : mreg) (NTH : list_nth_z float_param_regs rf = Some r) (H : One (R r) = p) : forall_rpair loc_argument_acceptable p.","proofString":"subst p; simpl.\napply CSF.\neapply list_nth_z_in; eauto."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r0 : mreg, In r0 int_param_regs -> is_callee_save r0 = false) (CSF : forall r0 : mreg, In r0 float_param_regs -> is_callee_save r0 = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (STK : forall (tyl : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (A : forall (ty0 : typ) (ri0 rf0 ofs0 : Z) (f0 : Z -> Z -> Z -> list (rpair loc)),\nOKF f0 -> ofs0 >= 0 -> OK (stack_arg ty0 ri0 rf0 ofs0 f0)) (B : forall (ty0 : typ) (ri0 rf0 ofs0 : Z) (f0 : Z -> Z -> Z -> list (rpair loc)),\nOKF f0 -> ofs0 >= 0 -> OK (int_arg ty0 ri0 rf0 ofs0 f0)) (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)) (OF : OKF f) (OO : ofs >= 0) (r : mreg) (NTH : list_nth_z float_param_regs rf = Some r) : is_callee_save r = false.","proofString":"apply CSF.\neapply list_nth_z_in; eauto."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r0 : mreg, In r0 int_param_regs -> is_callee_save r0 = false) (CSF : forall r0 : mreg, In r0 float_param_regs -> is_callee_save r0 = false) (ALP : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> align ofs0 (typesize ty0) >= 0) (ALD : forall (ofs0 : Z) (ty0 : typ),\nofs0 >= 0 -> (typealign ty0 | align ofs0 (typesize ty0))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty0 : typ), ofs0 >= 0 -> (typealign ty0 | align ofs0 2)) (STK : forall (tyl : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl ofs0)) (A : forall (ty0 : typ) (ri0 rf0 ofs0 : Z) (f0 : Z -> Z -> Z -> list (rpair loc)),\nOKF f0 -> ofs0 >= 0 -> OK (stack_arg ty0 ri0 rf0 ofs0 f0)) (B : forall (ty0 : typ) (ri0 rf0 ofs0 : Z) (f0 : Z -> Z -> Z -> list (rpair loc)),\nOKF f0 -> ofs0 >= 0 -> OK (int_arg ty0 ri0 rf0 ofs0 f0)) (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)) (OF : OKF f) (OO : ofs >= 0) (r : mreg) (NTH : list_nth_z float_param_regs rf = Some r) : In r float_param_regs.","proofString":"eapply list_nth_z_in; eauto."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs : Z) (ty : typ), ofs >= 0 -> align ofs (typesize ty) >= 0) (ALD : forall (ofs : Z) (ty : typ),\nofs >= 0 -> (typealign ty | align ofs (typesize ty))) (ALP2 : forall ofs : Z, ofs >= 0 -> align ofs 2 >= 0) (ALD2 : forall (ofs : Z) (ty : typ), ofs >= 0 -> (typealign ty | align ofs 2)) (STK : forall (tyl : list typ) (ofs : Z),\nofs >= 0 -> OK (loc_arguments_stack tyl ofs)) (A : forall (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)),\nOKF f -> ofs >= 0 -> OK (stack_arg ty ri rf ofs f)) (B : forall (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)),\nOKF f -> ofs >= 0 -> OK (int_arg ty ri rf ofs f)) (C : forall (ty : typ) (ri rf ofs : Z) (f : Z -> Z -> Z -> list (rpair loc)),\nOKF f -> ofs >= 0 -> OK (float_arg ty ri rf ofs f)) : (forall (tyl : list typ) (fixed ri rf ofs : Z),\n ofs >= 0 ->\n forall p : rpair loc,\n In p (loc_arguments_rec tyl fixed ri rf ofs) ->\n forall_rpair loc_argument_acceptable p) ->\nforall (tyl : list typ) (fixed ri rf ofs : Z) (p : rpair loc),\nofs >= 0 ->\nIn p (loc_arguments_rec tyl fixed ri rf ofs) ->\nforall_rpair loc_argument_acceptable p.","proofString":"eauto."},{"statement":"(OK : list (rpair loc) -> Prop) (OKF : (Z -> Z -> Z -> list (rpair loc)) -> Prop) (CSI : forall r : mreg, In r int_param_regs -> is_callee_save r = false) (CSF : forall r : mreg, In r float_param_regs -> is_callee_save r = false) (ALP : forall (ofs0 : Z) (ty : typ), ofs0 >= 0 -> align ofs0 (typesize ty) >= 0) (ALD : forall (ofs0 : Z) (ty : typ),\nofs0 >= 0 -> (typealign ty | align ofs0 (typesize ty))) (ALP2 : forall ofs0 : Z, ofs0 >= 0 -> align ofs0 2 >= 0) (ALD2 : forall (ofs0 : Z) (ty : typ), ofs0 >= 0 -> (typealign ty | align ofs0 2)) (STK : forall (tyl0 : list typ) (ofs0 : Z),\nofs0 >= 0 -> OK (loc_arguments_stack tyl0 ofs0)) (A : forall (ty : typ) (ri0 rf0 ofs0 : Z) (f : Z -> Z -> Z -> list (rpair loc)),\nOKF f -> ofs0 >= 0 -> OK (stack_arg ty ri0 rf0 ofs0 f)) (B : forall (ty : typ) (ri0 rf0 ofs0 : Z) (f : Z -> Z -> Z -> list (rpair loc)),\nOKF f -> ofs0 >= 0 -> OK (int_arg ty ri0 rf0 ofs0 f)) (C : forall (ty : typ) (ri0 rf0 ofs0 : Z) (f : Z -> Z -> Z -> list (rpair loc)),\nOKF f -> ofs0 >= 0 -> OK (float_arg ty ri0 rf0 ofs0 f)) (ty1 : typ) (tyl : list typ) (IHtyl : forall fixed0 ri0 rf0 ofs0 : Z,\nofs0 >= 0 -> OK (loc_arguments_rec tyl fixed0 ri0 rf0 ofs0)) (fixed ri rf ofs : Z) (OO : ofs >= 0) (l : fixed <= 0) : OK\n  (One (S Outgoing (align ofs 2) Tany64)\n   :: loc_arguments_stack tyl (align ofs 2 + 2)).","proofString":"apply (STK (ty1 :: tyl)); auto."},{"statement":"(s : signature) (p : rpair loc) (H : In p (loc_arguments_rec (proj_sig_args s) (fixed_arguments s) 0 0 0)) : forall_rpair loc_argument_acceptable p.","proofString":"eapply loc_arguments_rec_charact; eauto.\nlia."},{"statement":"(s : signature) (p : rpair loc) (H : In p (loc_arguments_rec (proj_sig_args s) (fixed_arguments s) 0 0 0)) : 0 >= 0.","proofString":"lia."}]}