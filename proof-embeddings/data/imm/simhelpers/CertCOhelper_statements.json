{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/bigRocq/dataset/imm/src/simhelpers/CertCOhelper.v","fileSamples":[{"statement":"(x y : actid) (H : co x y) : exists (l : location) (z : actid),\n  (x = z /\\ loc x = Some l) /\\\n  (exists z0 : actid, co z z0 /\\ z0 = y /\\ loc z0 = Some l).","proofString":"hahn_rewrite (dom_l wf_coD) in H; unfolder in H; desc.\ngeneralize (is_w_loc lab x H); ins; desf.\neexists; splits; eauto.\neexists; splits; eauto.\neexists; splits; eauto.\napply wf_col in H0; unfold Events.same_loc in H0; congruence."},{"statement":"(x y : actid) (H : is_w lab x) (H0 : co x y) : exists (l : location) (z : actid),\n  (x = z /\\ loc x = Some l) /\\\n  (exists z0 : actid, co z z0 /\\ z0 = y /\\ loc z0 = Some l).","proofString":"generalize (is_w_loc lab x H); ins; desf.\neexists; splits; eauto.\neexists; splits; eauto.\neexists; splits; eauto.\napply wf_col in H0; unfold Events.same_loc in H0; congruence."},{"statement":"(x y : actid) (H : is_w lab x) (H0 : co x y) (l : location) (H1 : loc x = Some l) : exists (l0 : location) (z : actid),\n  (x = z /\\ loc x = Some l0) /\\\n  (exists z0 : actid, co z z0 /\\ z0 = y /\\ loc z0 = Some l0).","proofString":"eexists; splits; eauto.\neexists; splits; eauto.\neexists; splits; eauto.\napply wf_col in H0; unfold Events.same_loc in H0; congruence."},{"statement":"(x y : actid) (H : is_w lab x) (H0 : co x y) (l : location) (H1 : loc x = Some l) : exists z : actid, co x z /\\ z = y /\\ loc z = Some l.","proofString":"eexists; splits; eauto.\napply wf_col in H0; unfold Events.same_loc in H0; congruence."},{"statement":"(x y : actid) (H : is_w lab x) (H0 : co x y) (l : location) (H1 : loc x = Some l) : loc y = Some l.","proofString":"apply wf_col in H0; unfold Events.same_loc in H0; congruence."},{"statement":"(l : location) : transitive (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘).","proofString":"rewrite <- restr_relE.\nby apply transitive_restr."},{"statement":"(l : location) : transitive (restr_rel Loc_ l co).","proofString":"by apply transitive_restr."},{"statement":"(l : location) : is_total (E ∩₁ W ∩₁ Loc_ l) (⦗W_ l⦘ ⨾ (⦗E⦘ ⨾ col l ⨾ ⦗E⦘) ⨾ ⦗W_ l⦘).","proofString":"unfold col; rewrite !seqA.\narewrite (⦗W_ l⦘ ⨾ ⦗E⦘ ⨾ ⦗Loc_ l⦘ ≡ ⦗E ∩₁ W ∩₁ Loc_ l⦘) by basic_solver.\narewrite (⦗Loc_ l⦘ ⨾ ⦗E⦘ ⨾ ⦗W_ l⦘ ≡ ⦗E ∩₁ W ∩₁ Loc_ l⦘) by basic_solver.\nrewrite <- restr_relE.\napply is_total_restr.\napply wf_co_total."},{"statement":"(l : location) : is_total (E ∩₁ W ∩₁ Loc_ l)\n  (⦗W_ l⦘ ⨾ ⦗E⦘ ⨾ ⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘ ⨾ ⦗E⦘ ⨾ ⦗W_ l⦘).","proofString":"arewrite (⦗W_ l⦘ ⨾ ⦗E⦘ ⨾ ⦗Loc_ l⦘ ≡ ⦗E ∩₁ W ∩₁ Loc_ l⦘) by basic_solver.\narewrite (⦗Loc_ l⦘ ⨾ ⦗E⦘ ⨾ ⦗W_ l⦘ ≡ ⦗E ∩₁ W ∩₁ Loc_ l⦘) by basic_solver.\nrewrite <- restr_relE.\napply is_total_restr.\napply wf_co_total."},{"statement":"(l : location) : is_total (E ∩₁ W ∩₁ Loc_ l)\n  (⦗E ∩₁ W ∩₁ Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘ ⨾ ⦗E⦘ ⨾ ⦗W_ l⦘).","proofString":"arewrite (⦗Loc_ l⦘ ⨾ ⦗E⦘ ⨾ ⦗W_ l⦘ ≡ ⦗E ∩₁ W ∩₁ Loc_ l⦘) by basic_solver.\nrewrite <- restr_relE.\napply is_total_restr.\napply wf_co_total."},{"statement":"(l : location) : is_total (E ∩₁ W ∩₁ Loc_ l) (⦗E ∩₁ W ∩₁ Loc_ l⦘ ⨾ co ⨾ ⦗E ∩₁ W ∩₁ Loc_ l⦘).","proofString":"rewrite <- restr_relE.\napply is_total_restr.\napply wf_co_total."},{"statement":"(l : location) : is_total (E ∩₁ W ∩₁ Loc_ l) (restr_rel (E ∩₁ W ∩₁ Loc_ l) co).","proofString":"apply is_total_restr.\napply wf_co_total."},{"statement":"(l : location) : is_total (E ∩₁ W ∩₁ Loc_ l) co.","proofString":"apply wf_co_total."},{"statement":"(l : location) : irreflexive (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘).","proofString":"rewrite <- restr_relE.\nby apply irreflexive_restr."},{"statement":"(l : location) : irreflexive (restr_rel Loc_ l co).","proofString":"by apply irreflexive_restr."},{"statement":"(l : location) : irreflexive (col0 l).","proofString":"unfold col0.\narewrite_id ⦗I⦘.\narewrite_id ⦗T⦘.\nrelsf.\ngeneralize (@col_trans l); ins; relsf; apply col_irr."},{"statement":"(l : location) : irreflexive (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘)⁺.","proofString":"arewrite_id ⦗I⦘.\narewrite_id ⦗T⦘.\nrelsf.\ngeneralize (@col_trans l); ins; relsf; apply col_irr."},{"statement":"(l : location) : irreflexive\n  (⦗fun _ : actid => True⦘ ⨾ col l ⨾ ⦗fun _ : actid => True⦘\n   ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗fun _ : actid => True⦘ ⨾ col l ⨾ ⦗T⦘)⁺.","proofString":"arewrite_id ⦗T⦘.\nrelsf.\ngeneralize (@col_trans l); ins; relsf; apply col_irr."},{"statement":"(l : location) : irreflexive\n  (⦗fun _ : actid => True⦘ ⨾ col l ⨾ ⦗fun _ : actid => True⦘\n   ∪ ⦗fun _ : actid => True⦘ ⨾ col l ⨾ ⦗fun _ : actid => True⦘\n   ∪ ⦗fun _ : actid => True⦘ ⨾ col l ⨾ ⦗fun _ : actid => True⦘)⁺.","proofString":"relsf.\ngeneralize (@col_trans l); ins; relsf; apply col_irr."},{"statement":"(l : location) : irreflexive (col l)⁺.","proofString":"generalize (@col_trans l); ins; relsf; apply col_irr."},{"statement":"(l : location) : transitive (col0 l).","proofString":"unfold col0; relsf."},{"statement":"(l : location) : is_total (I ∩₁ Loc_ l) (col0 l).","proofString":"assert (XX: restr_rel (I ∩₁ Loc_ l) (col l) ⊆ col0 l).\nby unfold col0; rewrite <- ct_step; basic_solver 21.\nrewrite <- XX.\napply is_total_restr.\nrewrite IN_I.\neapply wf_col_total."},{"statement":"(l : location) : restr_rel (I ∩₁ Loc_ l) (col l) ⊆ col0 l.","proofString":"by unfold col0; rewrite <- ct_step; basic_solver 21."},{"statement":"(l : location) (XX : restr_rel (I ∩₁ Loc_ l) (col l) ⊆ col0 l) : is_total (I ∩₁ Loc_ l) (col0 l).","proofString":"rewrite <- XX.\napply is_total_restr.\nrewrite IN_I.\neapply wf_col_total."},{"statement":"(l : location) (XX : restr_rel (I ∩₁ Loc_ l) (col l) ⊆ col0 l) : is_total (I ∩₁ Loc_ l) (restr_rel (I ∩₁ Loc_ l) (col l)).","proofString":"apply is_total_restr.\nrewrite IN_I.\neapply wf_col_total."},{"statement":"(l : location) (XX : restr_rel (I ∩₁ Loc_ l) (col l) ⊆ col0 l) : is_total (I ∩₁ Loc_ l) (col l).","proofString":"rewrite IN_I.\neapply wf_col_total."},{"statement":"(l : location) (XX : restr_rel (I ∩₁ Loc_ l) (col l) ⊆ col0 l) : is_total (E ∩₁ W ∩₁ Loc_ l) (col l).","proofString":"eapply wf_col_total."},{"statement":"(l : location) : forall x y : actid,\n((I ∩₁ Loc_ l) × (E ∩₁ W ∩₁ Loc_ l \\₁ I)) x y ->\n(I ∩₁ Loc_ l) x /\\ ~ (I ∩₁ Loc_ l) y.","proofString":"unfolder; ins; desf; splits; eauto; intro; desf."},{"statement":"(l : location) : ⦗W_ l⦘ ⨾ new_col l ⨾ ⦗W_ l⦘ ⊆ (fun x y : actid => loc x = loc y).","proofString":"unfolder; ins; desf; congruence."},{"statement":"(l : location) : is_total (E ∩₁ W ∩₁ Loc_ l)\n  (fun x y : actid =>\n   col0 l x y \\/\n   ((I ∩₁ Loc_ l) × (E ∩₁ W ∩₁ Loc_ l \\₁ I)) x y /\\ ~ col0 l y x).","proofString":"unfolder; ins; desf.\ndestruct (classic (col0 l a b)) as [|X]; eauto 8.\ndestruct (classic (col0 l b a)) as [|Y]; eauto 8.\nassert (XX: ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b).\nby intro; eapply X; vauto.\nassert (YY: ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a).\nby intro; eapply Y; vauto.\nassert (Ta: ~ I a -> T a).\nby assert (S: (E ∩₁ W) a) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (Tb: ~ I b -> T b).\nby assert (S: (E ∩₁ W) b) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (TOT: col l a b \\/ col l b a).\nby apply wf_col_total; basic_solver.\ndestruct (classic (I a)), (classic (I b)); desf.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\neauto 20.\neauto 20.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"destruct (classic (col0 l a b)) as [|X]; eauto 8.\ndestruct (classic (col0 l b a)) as [|Y]; eauto 8.\nassert (XX: ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b).\nby intro; eapply X; vauto.\nassert (YY: ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a).\nby intro; eapply Y; vauto.\nassert (Ta: ~ I a -> T a).\nby assert (S: (E ∩₁ W) a) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (Tb: ~ I b -> T b).\nby assert (S: (E ∩₁ W) b) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (TOT: col l a b \\/ col l b a).\nby apply wf_col_total; basic_solver.\ndestruct (classic (I a)), (classic (I b)); desf.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\neauto 20.\neauto 20.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"destruct (classic (col0 l b a)) as [|Y]; eauto 8.\nassert (XX: ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b).\nby intro; eapply X; vauto.\nassert (YY: ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a).\nby intro; eapply Y; vauto.\nassert (Ta: ~ I a -> T a).\nby assert (S: (E ∩₁ W) a) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (Tb: ~ I b -> T b).\nby assert (S: (E ∩₁ W) b) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (TOT: col l a b \\/ col l b a).\nby apply wf_col_total; basic_solver.\ndestruct (classic (I a)), (classic (I b)); desf.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\neauto 20.\neauto 20.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"assert (XX: ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b).\nby intro; eapply X; vauto.\nassert (YY: ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a).\nby intro; eapply Y; vauto.\nassert (Ta: ~ I a -> T a).\nby assert (S: (E ∩₁ W) a) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (Tb: ~ I b -> T b).\nby assert (S: (E ∩₁ W) b) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (TOT: col l a b \\/ col l b a).\nby apply wf_col_total; basic_solver.\ndestruct (classic (I a)), (classic (I b)); desf.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\neauto 20.\neauto 20.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b.","proofString":"by intro; eapply X; vauto."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"assert (YY: ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a).\nby intro; eapply Y; vauto.\nassert (Ta: ~ I a -> T a).\nby assert (S: (E ∩₁ W) a) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (Tb: ~ I b -> T b).\nby assert (S: (E ∩₁ W) b) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (TOT: col l a b \\/ col l b a).\nby apply wf_col_total; basic_solver.\ndestruct (classic (I a)), (classic (I b)); desf.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\neauto 20.\neauto 20.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a.","proofString":"by intro; eapply Y; vauto."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"assert (Ta: ~ I a -> T a).\nby assert (S: (E ∩₁ W) a) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (Tb: ~ I b -> T b).\nby assert (S: (E ∩₁ W) b) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (TOT: col l a b \\/ col l b a).\nby apply wf_col_total; basic_solver.\ndestruct (classic (I a)), (classic (I b)); desf.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\neauto 20.\neauto 20.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) : ~ I a -> T a.","proofString":"by assert (S: (E ∩₁ W) a) by basic_solver; apply IT in S; unfolder in S; ins; desf."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) (Ta : ~ I a -> T a) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"assert (Tb: ~ I b -> T b).\nby assert (S: (E ∩₁ W) b) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nassert (TOT: col l a b \\/ col l b a).\nby apply wf_col_total; basic_solver.\ndestruct (classic (I a)), (classic (I b)); desf.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\neauto 20.\neauto 20.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) (Ta : ~ I a -> T a) : ~ I b -> T b.","proofString":"by assert (S: (E ∩₁ W) b) by basic_solver; apply IT in S; unfolder in S; ins; desf."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) (Ta : ~ I a -> T a) (Tb : ~ I b -> T b) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"assert (TOT: col l a b \\/ col l b a).\nby apply wf_col_total; basic_solver.\ndestruct (classic (I a)), (classic (I b)); desf.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\neauto 20.\neauto 20.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) (Ta : ~ I a -> T a) (Tb : ~ I b -> T b) : col l a b \\/ col l b a.","proofString":"by apply wf_col_total; basic_solver."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) (Ta : ~ I a -> T a) (Tb : ~ I b -> T b) (TOT : col l a b \\/ col l b a) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"destruct (classic (I a)), (classic (I b)); desf.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\neauto 20.\neauto 20.\nexfalso; unfolder in YY; basic_solver 22.\nexfalso; unfolder in XX; basic_solver 22.\nexfalso; unfolder in YY; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) (Ta : ~ I a -> T a) (Tb : ~ I b -> T b) (TOT : col l a b) (H : I a) (H0 : I b) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"exfalso; unfolder in XX; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) (Ta : ~ I a -> T a) (Tb : ~ I b -> T b) (TOT : col l b a) (H : I a) (H0 : I b) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"exfalso; unfolder in YY; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) (Ta : ~ I a -> T a) (Tb : ~ I b -> T b) (TOT : col l a b) (H : I a) (H0 : ~ I b) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"exfalso; unfolder in XX; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) (Ta : ~ I a -> T a) (Tb : ~ I b -> T b) (TOT : col l b a) (H : I a) (H0 : ~ I b) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"eauto 20."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) (Ta : ~ I a -> T a) (Tb : ~ I b -> T b) (TOT : col l a b) (H : ~ I a) (H0 : I b) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"eauto 20."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) (Ta : ~ I a -> T a) (Tb : ~ I b -> T b) (TOT : col l b a) (H : ~ I a) (H0 : I b) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"exfalso; unfolder in YY; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) (Ta : ~ I a -> T a) (Tb : ~ I b -> T b) (TOT : col l a b) (H : ~ I a) (H0 : ~ I b) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"exfalso; unfolder in XX; basic_solver 22."},{"statement":"(l : location) (a : actid) (IWa : E a) (IWa1 : is_w lab a) (IWa0 : loc a = Some l) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = Some l) (NEQ : a <> b) (X : ~ col0 l a b) (Y : ~ col0 l b a) (XX : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) a b) (YY : ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) b a) (Ta : ~ I a -> T a) (Tb : ~ I b -> T b) (TOT : col l b a) (H : ~ I a) (H0 : ~ I b) : (col0 l a b \\/\n ((I a /\\ loc a = Some l) /\\ ((E b /\\ true) /\\ loc b = Some l) /\\ ~ I b) /\\\n ~ col0 l b a) \\/\ncol0 l b a \\/\n((I b /\\ loc b = Some l) /\\ ((E a /\\ true) /\\ loc a = Some l) /\\ ~ I a) /\\\n~ col0 l a b.","proofString":"exfalso; unfolder in YY; basic_solver 22."},{"statement":"(l : location) (x y z : actid) (H : new_col l x z) (H0 : new_col l z y) : new_col l x y.","proofString":"eapply tot_ex.\napply wf_new_col_total.\nhahn_rewrite wf_new_colE in H0.\nhahn_rewrite wf_new_colD in H0.\nunfolder in H0; basic_solver 21.\nhahn_rewrite wf_new_colE in H.\nhahn_rewrite wf_new_colD in H.\nunfolder in H; basic_solver 21.\nintro.\neapply acyclic_new_col.\neapply t_trans, t_trans; vauto.\nintro.\neapply acyclic_new_col.\neapply t_trans; vauto."},{"statement":"(l : location) (x y z : actid) (H : new_col l x z) (H0 : (⦗E⦘ ⨾ new_col l ⨾ ⦗E⦘) z y) : (E ∩₁ W ∩₁ Loc_ l) y.","proofString":"hahn_rewrite wf_new_colD in H0.\nunfolder in H0; basic_solver 21."},{"statement":"(l : location) (x y z : actid) (H : new_col l x z) (H0 : (⦗E⦘ ⨾ (⦗W_ l⦘ ⨾ new_col l ⨾ ⦗W_ l⦘) ⨾ ⦗E⦘) z y) : (E ∩₁ W ∩₁ Loc_ l) y.","proofString":"unfolder in H0; basic_solver 21."},{"statement":"(l : location) (x y z : actid) (H0 : new_col l z y) (H : (⦗E⦘ ⨾ new_col l ⨾ ⦗E⦘) x z) : (E ∩₁ W ∩₁ Loc_ l) x.","proofString":"hahn_rewrite wf_new_colD in H.\nunfolder in H; basic_solver 21."},{"statement":"(l : location) (x y z : actid) (H0 : new_col l z y) (H : (⦗E⦘ ⨾ (⦗W_ l⦘ ⨾ new_col l ⨾ ⦗W_ l⦘) ⨾ ⦗E⦘) x z) : (E ∩₁ W ∩₁ Loc_ l) x.","proofString":"unfolder in H; basic_solver 21."},{"statement":"(l : location) (x y z : actid) (H : new_col l x z) (H0 : new_col l z y) : ~ new_col l y x.","proofString":"intro.\neapply acyclic_new_col.\neapply t_trans, t_trans; vauto."},{"statement":"(l : location) (x y z : actid) (H : new_col l x z) (H0 : new_col l z y) (H1 : new_col l y x) : False.","proofString":"eapply acyclic_new_col.\neapply t_trans, t_trans; vauto."},{"statement":"(l : location) (x y z : actid) (H : new_col l x z) (H0 : new_col l z y) : y <> x.","proofString":"intro.\neapply acyclic_new_col.\neapply t_trans; vauto."},{"statement":"(l : location) (x y z : actid) (H : new_col l x z) (H0 : new_col l z y) (H1 : y = x) : False.","proofString":"eapply acyclic_new_col.\neapply t_trans; vauto."},{"statement":"(x y : actid) (l : location) (H : new_col l x y) : E x /\\ (exists l0 : location, new_col l0 x y) /\\ E y.","proofString":"apply (wf_new_colE l) in H; unfolder in H; desf; eauto."},{"statement":"(x y : actid) (l : location) (H : new_col l x y) : is_w lab x /\\ (exists l0 : location, new_col l0 x y) /\\ is_w lab y.","proofString":"apply (wf_new_colD l) in H; unfolder in H; desf; eauto."},{"statement":"(x y : actid) (l : location) (H : new_col l x y) : same_loc x y.","proofString":"apply (@wf_new_coll l) in H; unfolder in H; desf; eauto."},{"statement":"(x y z : actid) (l0 : location) (H : new_col l0 x y) (l : location) (H0 : new_col l y z) : exists l1 : location, new_col l1 x z.","proofString":"hahn_rewrite wf_new_colD in H0.\nhahn_rewrite wf_new_colD in H.\nunfolder in H0; unfolder in H; desf.\nexists l; eapply new_col_trans; eauto."},{"statement":"(x y z : actid) (l0 : location) (H : new_col l0 x y) (l : location) (H0 : (⦗W_ l⦘ ⨾ new_col l ⨾ ⦗W_ l⦘) y z) : exists l1 : location, new_col l1 x z.","proofString":"hahn_rewrite wf_new_colD in H.\nunfolder in H0; unfolder in H; desf.\nexists l; eapply new_col_trans; eauto."},{"statement":"(x y z : actid) (l0 l : location) (H0 : (⦗W_ l⦘ ⨾ new_col l ⨾ ⦗W_ l⦘) y z) (H : (⦗W_ l0⦘ ⨾ new_col l0 ⨾ ⦗W_ l0⦘) x y) : exists l1 : location, new_col l1 x z.","proofString":"unfolder in H0; unfolder in H; desf.\nexists l; eapply new_col_trans; eauto."},{"statement":"(x y z : actid) (l : location) (H0 : true) (H5 : new_col l y z) (H6 : is_w lab z) (H7 : loc z = Some l) (H : is_w lab x) (H1 : new_col l x y) (H4 : loc x = Some l) (H2 : is_w lab y) (H3 : loc y = Some l) : exists l0 : location, new_col l0 x z.","proofString":"exists l; eapply new_col_trans; eauto."},{"statement":"(a : actid) (IWa : E a) (IWa1 : is_w lab a) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = loc a) (NEQ : a <> b) : (exists l : location, new_col l a b) \\/ (exists l : location, new_col l b a).","proofString":"generalize (is_w_loc lab a IWa1); ins; desf.\ncut (new_col l a b \\/ new_col l b a); [by basic_solver 21|].\napply wf_new_col_total; auto.\nbasic_solver.\nunfolder; splits; ins; desf; congruence."},{"statement":"(a : actid) (IWa : E a) (IWa1 : is_w lab a) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = loc a) (NEQ : a <> b) (l : location) (H : loc a = Some l) : (exists l0 : location, new_col l0 a b) \\/\n(exists l0 : location, new_col l0 b a).","proofString":"cut (new_col l a b \\/ new_col l b a); [by basic_solver 21|].\napply wf_new_col_total; auto.\nbasic_solver.\nunfolder; splits; ins; desf; congruence."},{"statement":"(a : actid) (IWa : E a) (IWa1 : is_w lab a) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = loc a) (NEQ : a <> b) (l : location) (H : loc a = Some l) : new_col l a b \\/ new_col l b a.","proofString":"apply wf_new_col_total; auto.\nbasic_solver.\nunfolder; splits; ins; desf; congruence."},{"statement":"(a : actid) (IWa : E a) (IWa1 : is_w lab a) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = loc a) (NEQ : a <> b) (l : location) (H : loc a = Some l) : (E ∩₁ W ∩₁ Loc_ l) a.","proofString":"basic_solver."},{"statement":"(a : actid) (IWa : E a) (IWa1 : is_w lab a) (b : actid) (IWb : E b) (IWb1 : is_w lab b) (IWb0 : loc b = loc a) (NEQ : a <> b) (l : location) (H : loc a = Some l) : (E ∩₁ W ∩₁ Loc_ l) b.","proofString":"unfolder; splits; ins; desf; congruence."},{"statement":"(x : actid) (l : location) (H : new_col l x x) : False.","proofString":"eapply new_col_irr; eauto."},{"statement":"(x y : actid) (R : new_co x y) (K : I y) : co x y /\\ I y.","proofString":"unfold new_co in R; desc.\nhahn_rewrite wf_new_colE in R.\nhahn_rewrite wf_new_colD in R.\nunfolder in R; desf; splits; auto.\neapply tot_ex.\napply wf_co_total.\nbasic_solver.\nunfolder; splits; eauto; congruence.\nintro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\nintro; subst.\neby eapply new_col_irr."},{"statement":"(x y : actid) (l : location) (R : new_col l x y) (K : I y) : co x y /\\ I y.","proofString":"hahn_rewrite wf_new_colE in R.\nhahn_rewrite wf_new_colD in R.\nunfolder in R; desf; splits; auto.\neapply tot_ex.\napply wf_co_total.\nbasic_solver.\nunfolder; splits; eauto; congruence.\nintro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\nintro; subst.\neby eapply new_col_irr."},{"statement":"(x y : actid) (l : location) (K : I y) (R : (⦗E⦘ ⨾ new_col l ⨾ ⦗E⦘) x y) : co x y /\\ I y.","proofString":"hahn_rewrite wf_new_colD in R.\nunfolder in R; desf; splits; auto.\neapply tot_ex.\napply wf_co_total.\nbasic_solver.\nunfolder; splits; eauto; congruence.\nintro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\nintro; subst.\neby eapply new_col_irr."},{"statement":"(x y : actid) (l : location) (K : I y) (R : (⦗E⦘ ⨾ (⦗W_ l⦘ ⨾ new_col l ⨾ ⦗W_ l⦘) ⨾ ⦗E⦘) x y) : co x y /\\ I y.","proofString":"unfolder in R; desf; splits; auto.\neapply tot_ex.\napply wf_co_total.\nbasic_solver.\nunfolder; splits; eauto; congruence.\nintro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\nintro; subst.\neby eapply new_col_irr."},{"statement":"(y : actid) (l : location) (K : I y) (z : actid) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) : co z y.","proofString":"eapply tot_ex.\napply wf_co_total.\nbasic_solver.\nunfolder; splits; eauto; congruence.\nintro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\nintro; subst.\neby eapply new_col_irr."},{"statement":"(y : actid) (l : location) (K : I y) (z : actid) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) : ~ co y z.","proofString":"intro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12."},{"statement":"(y : actid) (l : location) (K : I y) (z : actid) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) : False.","proofString":"assert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12."},{"statement":"(y : actid) (l : location) (K : I y) (z : actid) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : (E ∩₁ W) z) : False.","proofString":"apply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12."},{"statement":"(y : actid) (l : location) (K : I y) (z : actid) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : I z) : False.","proofString":"eapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12."},{"statement":"(y : actid) (l : location) (K : I y) (z : actid) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : I z) : new_col l y z.","proofString":"red; red; unfold col0, col; left; apply t_step; basic_solver 12."},{"statement":"(y : actid) (l : location) (K : I y) (z : actid) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : T z) : False.","proofString":"eapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step; basic_solver 12."},{"statement":"(y : actid) (l : location) (K : I y) (z : actid) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : T z) : new_col l y z.","proofString":"red; red; unfold col0, col; left; apply t_step; basic_solver 12."},{"statement":"(y : actid) (l : location) (K : I y) (z : actid) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) : y <> z.","proofString":"intro; subst.\neby eapply new_col_irr."},{"statement":"(l : location) (z : actid) (K : I z) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R1 : E z) (R4 : is_w lab z) (R5 : loc z = Some l) (R2 : new_col l z z) : False.","proofString":"eby eapply new_col_irr."},{"statement":"(x y : actid) (K1 : T x) (R : new_co x y) : T x /\\ co x y.","proofString":"unfold new_co in R; desc.\nhahn_rewrite wf_new_colE in R.\nhahn_rewrite wf_new_colD in R.\nunfolder in R; desf; splits; auto.\neapply tot_ex.\napply wf_co_total.\nbasic_solver.\nunfolder; splits; eauto; congruence.\nintro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col.\nleft; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\nintro; subst.\neby eapply new_col_irr."},{"statement":"(x y : actid) (K1 : T x) (l : location) (R : new_col l x y) : T x /\\ co x y.","proofString":"hahn_rewrite wf_new_colE in R.\nhahn_rewrite wf_new_colD in R.\nunfolder in R; desf; splits; auto.\neapply tot_ex.\napply wf_co_total.\nbasic_solver.\nunfolder; splits; eauto; congruence.\nintro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col.\nleft; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\nintro; subst.\neby eapply new_col_irr."},{"statement":"(x y : actid) (K1 : T x) (l : location) (R : (⦗E⦘ ⨾ new_col l ⨾ ⦗E⦘) x y) : T x /\\ co x y.","proofString":"hahn_rewrite wf_new_colD in R.\nunfolder in R; desf; splits; auto.\neapply tot_ex.\napply wf_co_total.\nbasic_solver.\nunfolder; splits; eauto; congruence.\nintro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col.\nleft; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\nintro; subst.\neby eapply new_col_irr."},{"statement":"(x y : actid) (K1 : T x) (l : location) (R : (⦗E⦘ ⨾ (⦗W_ l⦘ ⨾ new_col l ⨾ ⦗W_ l⦘) ⨾ ⦗E⦘) x y) : T x /\\ co x y.","proofString":"unfolder in R; desf; splits; auto.\neapply tot_ex.\napply wf_co_total.\nbasic_solver.\nunfolder; splits; eauto; congruence.\nintro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col.\nleft; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\nintro; subst.\neby eapply new_col_irr."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) : co z y.","proofString":"eapply tot_ex.\napply wf_co_total.\nbasic_solver.\nunfolder; splits; eauto; congruence.\nintro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col.\nleft; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\nintro; subst.\neby eapply new_col_irr."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) : ~ co y z.","proofString":"intro.\nassert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col.\nleft; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) : False.","proofString":"assert (S: (E ∩₁ W) z) by basic_solver.\napply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col.\nleft; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : (E ∩₁ W) z) : False.","proofString":"apply IT in S; unfolder in S; ins; desf.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col.\nleft; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12.\neapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : I z) : False.","proofString":"eapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col.\nleft; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : I z) : new_col l y z.","proofString":"red; red; unfold col0, col.\nleft; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : I z) : (⦗I⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗I⦘\n ∪ ⦗T⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗T⦘\n ∪ ⦗I⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗T⦘)⁺ y z \\/\n((I ∩₁ Loc_ l) × (E ∩₁ W ∩₁ Loc_ l \\₁ I)) y z /\\\n~\n(⦗I⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗I⦘\n ∪ ⦗T⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗T⦘\n ∪ ⦗I⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗T⦘)⁺ z y.","proofString":"left; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : I z) : (⦗I⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗I⦘\n ∪ ⦗T⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗T⦘\n ∪ ⦗I⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗T⦘) y z.","proofString":"assert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : I z) (H0 : I y \\/ T y) : (⦗I⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗I⦘\n ∪ ⦗T⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗T⦘\n ∪ ⦗I⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗T⦘) y z.","proofString":"desf; basic_solver 12."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : T z) : False.","proofString":"eapply new_col_irr, new_col_trans; try edone.\nred; red; unfold col0, col; left; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : T z) : new_col l y z.","proofString":"red; red; unfold col0, col; left; apply t_step.\nassert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : T z) : (⦗I⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗I⦘\n ∪ ⦗T⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗T⦘\n ∪ ⦗I⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗T⦘) y z.","proofString":"assert (I y \\/ T y) by (apply IT; basic_solver).\ndesf; basic_solver 12."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) (H : co y z) (S : T z) (H0 : I y \\/ T y) : (⦗I⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗I⦘\n ∪ ⦗T⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗T⦘\n ∪ ⦗I⦘ ⨾ (⦗Loc_ l⦘ ⨾ co ⨾ ⦗Loc_ l⦘) ⨾ ⦗T⦘) y z.","proofString":"desf; basic_solver 12."},{"statement":"(y z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R2 : new_col l z y) (R5 : loc y = Some l) (R4 : is_w lab y) (R1 : E y) : y <> z.","proofString":"intro; subst.\neby eapply new_col_irr."},{"statement":"(z : actid) (K1 : T z) (l : location) (R : E z) (R7 : loc z = Some l) (R6 : is_w lab z) (R1 : E z) (R4 : is_w lab z) (R5 : loc z = Some l) (R2 : new_col l z z) : False.","proofString":"eby eapply new_col_irr."},{"statement":"⦗W⦘ ⨾ (⦗E⦘ ⨾ new_co ⨾ ⦗E⦘) ⨾ ⦗W⦘\n⊆ co ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ co ∪ ⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘.","proofString":"rewrite !seqA.\narewrite (⦗W⦘ ⨾ ⦗E⦘ ⊆ ⦗E ∩₁ W⦘) by basic_solver.\narewrite (⦗E⦘ ⨾ ⦗W⦘ ⊆ ⦗E ∩₁ W⦘) by basic_solver.\nrewrite <- IT.\narewrite (I ∪₁ T ⊆₁ (I \\₁ T) ∪₁ T) at 1.\nunfolder; ins; desf; tauto.\narewrite (I ∪₁ T ⊆₁ (T \\₁ I) ∪₁ I) at 1.\nunfolder; ins; desf; tauto.\nrewrite !id_union; relsf.\nsin_rewrite !T_new_co.\nsin_rewrite new_co_I.\nbasic_solver 21."},{"statement":"⦗W⦘ ⨾ ⦗E⦘ ⨾ new_co ⨾ ⦗E⦘ ⨾ ⦗W⦘\n⊆ co ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ co ∪ ⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘.","proofString":"arewrite (⦗W⦘ ⨾ ⦗E⦘ ⊆ ⦗E ∩₁ W⦘) by basic_solver.\narewrite (⦗E⦘ ⨾ ⦗W⦘ ⊆ ⦗E ∩₁ W⦘) by basic_solver.\nrewrite <- IT.\narewrite (I ∪₁ T ⊆₁ (I \\₁ T) ∪₁ T) at 1.\nunfolder; ins; desf; tauto.\narewrite (I ∪₁ T ⊆₁ (T \\₁ I) ∪₁ I) at 1.\nunfolder; ins; desf; tauto.\nrewrite !id_union; relsf.\nsin_rewrite !T_new_co.\nsin_rewrite new_co_I.\nbasic_solver 21."},{"statement":"⦗E ∩₁ W⦘ ⨾ new_co ⨾ ⦗E⦘ ⨾ ⦗W⦘\n⊆ co ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ co ∪ ⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘.","proofString":"arewrite (⦗E⦘ ⨾ ⦗W⦘ ⊆ ⦗E ∩₁ W⦘) by basic_solver.\nrewrite <- IT.\narewrite (I ∪₁ T ⊆₁ (I \\₁ T) ∪₁ T) at 1.\nunfolder; ins; desf; tauto.\narewrite (I ∪₁ T ⊆₁ (T \\₁ I) ∪₁ I) at 1.\nunfolder; ins; desf; tauto.\nrewrite !id_union; relsf.\nsin_rewrite !T_new_co.\nsin_rewrite new_co_I.\nbasic_solver 21."},{"statement":"⦗E ∩₁ W⦘ ⨾ new_co ⨾ ⦗E ∩₁ W⦘\n⊆ co ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ co ∪ ⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘.","proofString":"rewrite <- IT.\narewrite (I ∪₁ T ⊆₁ (I \\₁ T) ∪₁ T) at 1.\nunfolder; ins; desf; tauto.\narewrite (I ∪₁ T ⊆₁ (T \\₁ I) ∪₁ I) at 1.\nunfolder; ins; desf; tauto.\nrewrite !id_union; relsf.\nsin_rewrite !T_new_co.\nsin_rewrite new_co_I.\nbasic_solver 21."},{"statement":"⦗I ∪₁ T⦘ ⨾ new_co ⨾ ⦗I ∪₁ T⦘\n⊆ co ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ co ∪ ⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘.","proofString":"arewrite (I ∪₁ T ⊆₁ (I \\₁ T) ∪₁ T) at 1.\nunfolder; ins; desf; tauto.\narewrite (I ∪₁ T ⊆₁ (T \\₁ I) ∪₁ I) at 1.\nunfolder; ins; desf; tauto.\nrewrite !id_union; relsf.\nsin_rewrite !T_new_co.\nsin_rewrite new_co_I.\nbasic_solver 21."},{"statement":"I ∪₁ T ⊆₁ I \\₁ T ∪₁ T.","proofString":"unfolder; ins; desf; tauto."},{"statement":"⦗I \\₁ T ∪₁ T⦘ ⨾ new_co ⨾ ⦗I ∪₁ T⦘\n⊆ co ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ co ∪ ⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘.","proofString":"arewrite (I ∪₁ T ⊆₁ (T \\₁ I) ∪₁ I) at 1.\nunfolder; ins; desf; tauto.\nrewrite !id_union; relsf.\nsin_rewrite !T_new_co.\nsin_rewrite new_co_I.\nbasic_solver 21."},{"statement":"I ∪₁ T ⊆₁ T \\₁ I ∪₁ I.","proofString":"unfolder; ins; desf; tauto."},{"statement":"⦗I \\₁ T ∪₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I ∪₁ I⦘\n⊆ co ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ co ∪ ⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘.","proofString":"rewrite !id_union; relsf.\nsin_rewrite !T_new_co.\nsin_rewrite new_co_I.\nbasic_solver 21."},{"statement":"⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘ ∪ ⦗T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘\n∪ (⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ new_co ⨾ ⦗I⦘)\n⊆ co ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ co ∪ ⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘.","proofString":"sin_rewrite !T_new_co.\nsin_rewrite new_co_I.\nbasic_solver 21."},{"statement":"⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘ ∪ (⦗T⦘ ⨾ co) ⨾ ⦗T \\₁ I⦘\n∪ (⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗I⦘ ∪ (⦗T⦘ ⨾ co) ⨾ ⦗I⦘)\n⊆ co ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ co ∪ ⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘.","proofString":"sin_rewrite new_co_I.\nbasic_solver 21."},{"statement":"⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘ ∪ (⦗T⦘ ⨾ co) ⨾ ⦗T \\₁ I⦘\n∪ (⦗I \\₁ T⦘ ⨾ co ⨾ ⦗I⦘ ∪ (⦗T⦘ ⨾ co) ⨾ ⦗I⦘)\n⊆ co ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ co ∪ ⦗I \\₁ T⦘ ⨾ new_co ⨾ ⦗T \\₁ I⦘.","proofString":"basic_solver 21."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘)⁺ ⨾ ⦗I \\₁ T⦘\n⊆ ⦗T \\₁ I⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ col l ⨾ ⦗I \\₁ T⦘.","proofString":"arewrite (⦗T⦘ ⊆ ⦗T \\₁ I⦘ ∪ ⦗I ∩₁ T⦘) at 2.\nunfolder; ins ;desf; tauto.\nrelsf.\nrewrite <- !unionA.\nrewrite unionC.\nrewrite <- !unionA.\nrewrite path_ut_first; relsf; unionL.\ntransitivity (∅₂ : actid -> actid -> Prop); [|basic_solver].\nrewrite path_ut_last; relsf; unionL.\nrewrite ct_begin; basic_solver.\nrewrite (rtE (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)).\nrelsf; unionL.\nbasic_solver.\nrewrite ct_begin; basic_solver.\narewrite (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘ ⊆ col l).\nbasic_solver.\narewrite (col l ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⊆ col l).\nbasic_solver.\ngeneralize (@col_trans l); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) : ⦗T⦘ ⊆ ⦗T \\₁ I⦘ ∪ ⦗I ∩₁ T⦘.","proofString":"unfolder; ins ;desf; tauto."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ (⦗T \\₁ I⦘ ∪ ⦗I ∩₁ T⦘)\n   ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘)⁺ ⨾ ⦗I \\₁ T⦘\n⊆ ⦗T \\₁ I⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ col l ⨾ ⦗I \\₁ T⦘.","proofString":"relsf.\nrewrite <- !unionA.\nrewrite unionC.\nrewrite <- !unionA.\nrewrite path_ut_first; relsf; unionL.\ntransitivity (∅₂ : actid -> actid -> Prop); [|basic_solver].\nrewrite path_ut_last; relsf; unionL.\nrewrite ct_begin; basic_solver.\nrewrite (rtE (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)).\nrelsf; unionL.\nbasic_solver.\nrewrite ct_begin; basic_solver.\narewrite (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘ ⊆ col l).\nbasic_solver.\narewrite (col l ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⊆ col l).\nbasic_solver.\ngeneralize (@col_trans l); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ (⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘)\n   ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘)⁺ ⨾ ⦗I \\₁ T⦘\n⊆ ⦗T \\₁ I⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ col l ⨾ ⦗I \\₁ T⦘.","proofString":"rewrite <- !unionA.\nrewrite unionC.\nrewrite <- !unionA.\nrewrite path_ut_first; relsf; unionL.\ntransitivity (∅₂ : actid -> actid -> Prop); [|basic_solver].\nrewrite path_ut_last; relsf; unionL.\nrewrite ct_begin; basic_solver.\nrewrite (rtE (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)).\nrelsf; unionL.\nbasic_solver.\nrewrite ct_begin; basic_solver.\narewrite (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘ ⊆ col l).\nbasic_solver.\narewrite (col l ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⊆ col l).\nbasic_solver.\ngeneralize (@col_trans l); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘\n   ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘)⁺ ⨾ ⦗I \\₁ T⦘\n⊆ ⦗T \\₁ I⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ col l ⨾ ⦗I \\₁ T⦘.","proofString":"rewrite unionC.\nrewrite <- !unionA.\nrewrite path_ut_first; relsf; unionL.\ntransitivity (∅₂ : actid -> actid -> Prop); [|basic_solver].\nrewrite path_ut_last; relsf; unionL.\nrewrite ct_begin; basic_solver.\nrewrite (rtE (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)).\nrelsf; unionL.\nbasic_solver.\nrewrite ct_begin; basic_solver.\narewrite (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘ ⊆ col l).\nbasic_solver.\narewrite (col l ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⊆ col l).\nbasic_solver.\ngeneralize (@col_trans l); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ (⦗I⦘ ⨾ col l ⨾ ⦗T⦘\n   ∪ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘))⁺\n  ⨾ ⦗I \\₁ T⦘ ⊆ ⦗T \\₁ I⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ col l ⨾ ⦗I \\₁ T⦘.","proofString":"rewrite <- !unionA.\nrewrite path_ut_first; relsf; unionL.\ntransitivity (∅₂ : actid -> actid -> Prop); [|basic_solver].\nrewrite path_ut_last; relsf; unionL.\nrewrite ct_begin; basic_solver.\nrewrite (rtE (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)).\nrelsf; unionL.\nbasic_solver.\nrewrite ct_begin; basic_solver.\narewrite (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘ ⊆ col l).\nbasic_solver.\narewrite (col l ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⊆ col l).\nbasic_solver.\ngeneralize (@col_trans l); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘\n   ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘)⁺ ⨾ ⦗I \\₁ T⦘\n⊆ ⦗T \\₁ I⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ col l ⨾ ⦗I \\₁ T⦘.","proofString":"rewrite path_ut_first; relsf; unionL.\ntransitivity (∅₂ : actid -> actid -> Prop); [|basic_solver].\nrewrite path_ut_last; relsf; unionL.\nrewrite ct_begin; basic_solver.\nrewrite (rtE (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)).\nrelsf; unionL.\nbasic_solver.\nrewrite ct_begin; basic_solver.\narewrite (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘ ⊆ col l).\nbasic_solver.\narewrite (col l ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⊆ col l).\nbasic_solver.\ngeneralize (@col_trans l); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘)⁺\n  ⨾ ⦗I \\₁ T⦘ ⊆ ⦗T \\₁ I⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ col l ⨾ ⦗I \\₁ T⦘.","proofString":"transitivity (∅₂ : actid -> actid -> Prop); [|basic_solver].\nrewrite path_ut_last; relsf; unionL.\nrewrite ct_begin; basic_solver.\nrewrite (rtE (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)).\nrelsf; unionL.\nbasic_solver.\nrewrite ct_begin; basic_solver."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘)⁺\n  ⨾ ⦗I \\₁ T⦘ ⊆ ∅₂.","proofString":"rewrite path_ut_last; relsf; unionL.\nrewrite ct_begin; basic_solver.\nrewrite (rtE (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)).\nrelsf; unionL.\nbasic_solver.\nrewrite ct_begin; basic_solver."},{"statement":"(l : location) : ⦗T \\₁ I⦘ ⨾ (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)⁺ ⨾ ⦗I \\₁ T⦘ ⊆ ∅₂.","proofString":"rewrite ct_begin; basic_solver."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ ((⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘)＊\n   ⨾ (⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘) ⨾ (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)＊)\n  ⨾ ⦗I \\₁ T⦘ ⊆ ∅₂.","proofString":"rewrite (rtE (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)).\nrelsf; unionL.\nbasic_solver.\nrewrite ct_begin; basic_solver."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ ((⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘)＊\n   ⨾ (⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘)\n     ⨾ (⦗fun _ : actid => True⦘ ∪ (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)⁺))\n  ⨾ ⦗I \\₁ T⦘ ⊆ ∅₂.","proofString":"relsf; unionL.\nbasic_solver.\nrewrite ct_begin; basic_solver."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ ((⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘)＊\n   ⨾ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘) ⨾ ⦗I \\₁ T⦘ ⊆ ∅₂.","proofString":"basic_solver."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ ((⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘)＊\n   ⨾ (⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘) ⨾ (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘)⁺)\n  ⨾ ⦗I \\₁ T⦘ ⊆ ∅₂.","proofString":"rewrite ct_begin; basic_solver."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ ((⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘)＊\n   ⨾ (⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘)\n     ⨾ (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘\n        ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘)＊) ⨾ ⦗I \\₁ T⦘\n⊆ ⦗T \\₁ I⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ col l ⨾ ⦗I \\₁ T⦘.","proofString":"arewrite (⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘ ⊆ col l).\nbasic_solver.\narewrite (col l ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⊆ col l).\nbasic_solver.\ngeneralize (@col_trans l); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) : ⦗I⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T \\₁ I⦘ ⊆ col l.","proofString":"basic_solver."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ (col l)＊\n  ⨾ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ (col l ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘)＊ ⨾ ⦗I \\₁ T⦘\n⊆ ⦗T \\₁ I⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ col l ⨾ ⦗I \\₁ T⦘.","proofString":"arewrite (col l ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⊆ col l).\nbasic_solver.\ngeneralize (@col_trans l); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) : col l ∪ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⊆ col l.","proofString":"basic_solver."},{"statement":"(l : location) : ⦗T \\₁ I⦘ ⨾ (col l)＊ ⨾ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ (col l)＊ ⨾ ⦗I \\₁ T⦘\n⊆ ⦗T \\₁ I⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ col l ⨾ ⦗I \\₁ T⦘.","proofString":"generalize (@col_trans l); ins; relsf.\nbasic_solver 21."},{"statement":"(l : location) (H : transitive (col l)) : ⦗T \\₁ I⦘ ⨾ (col l)^? ⨾ ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ (col l)^? ⨾ ⦗I \\₁ T⦘\n⊆ ⦗T \\₁ I⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ col l ⨾ ⦗I \\₁ T⦘.","proofString":"basic_solver 21."},{"statement":"(l : location) : ⦗T \\₁ I⦘\n⨾ (fun x y : actid =>\n   col0 l x y \\/\n   ((I ∩₁ Loc_ l) × (E ∩₁ W ∩₁ Loc_ l \\₁ I)) x y /\\ ~ col0 l y x) ⨾ ⦗\n  I \\₁ T⦘ ⊆ col l ⨾ ⦗I ∩₁ T⦘ ⨾ col l.","proofString":"unfolder; ins; desf.\nassert (A: (⦗ T \\₁ I ⦘ ⨾ col0 l ⨾ ⦗ I \\₁ T ⦘) x y) by basic_solver.\napply T_I_col0_I_T in A; unfolder in A; basic_solver 10."},{"statement":"(l : location) (x y : actid) (H : T x) (H3 : ~ I x) (H0 : col0 l x y) (H1 : I y) (H2 : ~ T y) : exists z : actid, col l x z /\\ (I z /\\ T z) /\\ col l z y.","proofString":"assert (A: (⦗ T \\₁ I ⦘ ⨾ col0 l ⨾ ⦗ I \\₁ T ⦘) x y) by basic_solver.\napply T_I_col0_I_T in A; unfolder in A; basic_solver 10."},{"statement":"(l : location) (x y : actid) (H : T x) (H3 : ~ I x) (H0 : col0 l x y) (H1 : I y) (H2 : ~ T y) (A : (⦗T \\₁ I⦘ ⨾ col0 l ⨾ ⦗I \\₁ T⦘) x y) : exists z : actid, col l x z /\\ (I z /\\ T z) /\\ col l z y.","proofString":"apply T_I_col0_I_T in A; unfolder in A; basic_solver 10."},{"statement":"⦗T \\₁ I⦘ ⨾ new_co ⨾ ⦗I \\₁ T⦘ ⊆ co ⨾ ⦗I ∩₁ T⦘ ⨾ co.","proofString":"unfold new_co.\nunfolder; ins; desf.\nassert (A: (⦗ T \\₁ I ⦘ ⨾ new_col l ⨾ ⦗ I \\₁ T ⦘) x y) by basic_solver.\napply T_I_new_col_I_T in A; unfolder in A; desf.\nunfold col in *; unfolder in *; desf; eauto 10."},{"statement":"⦗T \\₁ I⦘ ⨾ (fun x y : actid => exists l : location, new_col l x y) ⨾ ⦗I \\₁ T⦘\n⊆ co ⨾ ⦗I ∩₁ T⦘ ⨾ co.","proofString":"unfolder; ins; desf.\nassert (A: (⦗ T \\₁ I ⦘ ⨾ new_col l ⨾ ⦗ I \\₁ T ⦘) x y) by basic_solver.\napply T_I_new_col_I_T in A; unfolder in A; desf.\nunfold col in *; unfolder in *; desf; eauto 10."},{"statement":"(x y : actid) (H : T x) (H3 : ~ I x) (l : location) (H0 : new_col l x y) (H1 : I y) (H2 : ~ T y) : exists z : actid, co x z /\\ (I z /\\ T z) /\\ co z y.","proofString":"assert (A: (⦗ T \\₁ I ⦘ ⨾ new_col l ⨾ ⦗ I \\₁ T ⦘) x y) by basic_solver.\napply T_I_new_col_I_T in A; unfolder in A; desf.\nunfold col in *; unfolder in *; desf; eauto 10."},{"statement":"(x y : actid) (H : T x) (H3 : ~ I x) (l : location) (H0 : new_col l x y) (H1 : I y) (H2 : ~ T y) (A : (⦗T \\₁ I⦘ ⨾ new_col l ⨾ ⦗I \\₁ T⦘) x y) : exists z : actid, co x z /\\ (I z /\\ T z) /\\ co z y.","proofString":"apply T_I_new_col_I_T in A; unfolder in A; desf.\nunfold col in *; unfolder in *; desf; eauto 10."},{"statement":"(x y : actid) (H : T x) (H3 : ~ I x) (l : location) (H0 : new_col l x y) (H1 : I y) (H2 : ~ T y) (z : actid) (A : col l x z) (A0 : I z) (A2 : T z) (A1 : col l z y) : exists z0 : actid, co x z0 /\\ (I z0 /\\ T z0) /\\ co z0 y.","proofString":"unfold col in *; unfolder in *; desf; eauto 10."},{"statement":"(x x0 : actid) (H : ~ I x0) (H0 : new_co x0 x) (H1 : forall c : actid, new_co x0 c -> new_co c x -> False) : T x.","proofString":"destruct (classic (T x)) as [|X]; auto.\nexfalso.\nhahn_rewrite wf_new_coE in H0.\nhahn_rewrite wf_new_coD in H0.\nunfolder in H0; desf.\nassert (Ix: I x).\nby assert (S: (E ∩₁ W) x) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nunfold new_co, new_col, pref_union in *; desc.\ndestruct H4 as [K|]; cycle 1.\nby unfolder in H2; basic_solver 21.\nunfold col0 in *.\ndestruct K.\nunfolder in H2; basic_solver 21.\neauto 12."},{"statement":"(x x0 : actid) (H : ~ I x0) (H0 : new_co x0 x) (H1 : forall c : actid, new_co x0 c -> new_co c x -> False) (X : ~ T x) : T x.","proofString":"exfalso.\nhahn_rewrite wf_new_coE in H0.\nhahn_rewrite wf_new_coD in H0.\nunfolder in H0; desf.\nassert (Ix: I x).\nby assert (S: (E ∩₁ W) x) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nunfold new_co, new_col, pref_union in *; desc.\ndestruct H4 as [K|]; cycle 1.\nby unfolder in H2; basic_solver 21.\nunfold col0 in *.\ndestruct K.\nunfolder in H2; basic_solver 21.\neauto 12."},{"statement":"(x x0 : actid) (H : ~ I x0) (H0 : new_co x0 x) (H1 : forall c : actid, new_co x0 c -> new_co c x -> False) (X : ~ T x) : False.","proofString":"hahn_rewrite wf_new_coE in H0.\nhahn_rewrite wf_new_coD in H0.\nunfolder in H0; desf.\nassert (Ix: I x).\nby assert (S: (E ∩₁ W) x) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nunfold new_co, new_col, pref_union in *; desc.\ndestruct H4 as [K|]; cycle 1.\nby unfolder in H2; basic_solver 21.\nunfold col0 in *.\ndestruct K.\nunfolder in H2; basic_solver 21.\neauto 12."},{"statement":"(x x0 : actid) (H : ~ I x0) (H1 : forall c : actid, new_co x0 c -> new_co c x -> False) (X : ~ T x) (H0 : (⦗E⦘ ⨾ new_co ⨾ ⦗E⦘) x0 x) : False.","proofString":"hahn_rewrite wf_new_coD in H0.\nunfolder in H0; desf.\nassert (Ix: I x).\nby assert (S: (E ∩₁ W) x) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nunfold new_co, new_col, pref_union in *; desc.\ndestruct H4 as [K|]; cycle 1.\nby unfolder in H2; basic_solver 21.\nunfold col0 in *.\ndestruct K.\nunfolder in H2; basic_solver 21.\neauto 12."},{"statement":"(x x0 : actid) (H : ~ I x0) (H1 : forall c : actid, new_co x0 c -> new_co c x -> False) (X : ~ T x) (H0 : (⦗E⦘ ⨾ (⦗W⦘ ⨾ new_co ⨾ ⦗W⦘) ⨾ ⦗E⦘) x0 x) : False.","proofString":"unfolder in H0; desf.\nassert (Ix: I x).\nby assert (S: (E ∩₁ W) x) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nunfold new_co, new_col, pref_union in *; desc.\ndestruct H4 as [K|]; cycle 1.\nby unfolder in H2; basic_solver 21.\nunfold col0 in *.\ndestruct K.\nunfolder in H2; basic_solver 21.\neauto 12."},{"statement":"(x z : actid) (H1 : forall c : actid, new_co z c -> new_co c x -> False) (H : ~ I z) (X : ~ T x) (H0 : E z) (H7 : is_w lab z) (H4 : new_co z x) (H6 : is_w lab x) (H3 : E x) : False.","proofString":"assert (Ix: I x).\nby assert (S: (E ∩₁ W) x) by basic_solver; apply IT in S; unfolder in S; ins; desf.\nunfold new_co, new_col, pref_union in *; desc.\ndestruct H4 as [K|]; cycle 1.\nby unfolder in H2; basic_solver 21.\nunfold col0 in *.\ndestruct K.\nunfolder in H2; basic_solver 21.\neauto 12."},{"statement":"(x z : actid) (H1 : forall c : actid, new_co z c -> new_co c x -> False) (H : ~ I z) (X : ~ T x) (H0 : E z) (H7 : is_w lab z) (H4 : new_co z x) (H6 : is_w lab x) (H3 : E x) : I x.","proofString":"by assert (S: (E ∩₁ W) x) by basic_solver; apply IT in S; unfolder in S; ins; desf."},{"statement":"(x z : actid) (H1 : forall c : actid, new_co z c -> new_co c x -> False) (H : ~ I z) (X : ~ T x) (H0 : E z) (H7 : is_w lab z) (H4 : new_co z x) (H6 : is_w lab x) (H3 : E x) (Ix : I x) : False.","proofString":"unfold new_co, new_col, pref_union in *; desc.\ndestruct H4 as [K|]; cycle 1.\nby unfolder in H2; basic_solver 21.\nunfold col0 in *.\ndestruct K.\nunfolder in H2; basic_solver 21.\neauto 12."},{"statement":"(x z : actid) (H1 : forall c : actid,\n(exists l0 : location,\n   col0 l0 z c \\/\n   ((I ∩₁ Loc_ l0) × (E ∩₁ W ∩₁ Loc_ l0 \\₁ I)) z c /\\ ~ col0 l0 c z) ->\n(exists l0 : location,\n   col0 l0 c x \\/\n   ((I ∩₁ Loc_ l0) × (E ∩₁ W ∩₁ Loc_ l0 \\₁ I)) c x /\\ ~ col0 l0 x c) -> False) (H : ~ I z) (X : ~ T x) (H0 : E z) (H7 : is_w lab z) (l : location) (H4 : col0 l z x \\/ ((I ∩₁ Loc_ l) × (E ∩₁ W ∩₁ Loc_ l \\₁ I)) z x /\\ ~ col0 l x z) (H6 : is_w lab x) (H3 : E x) (Ix : I x) : False.","proofString":"destruct H4 as [K|]; cycle 1.\nby unfolder in H2; basic_solver 21.\nunfold col0 in *.\ndestruct K.\nunfolder in H2; basic_solver 21.\neauto 12."},{"statement":"(x z : actid) (H1 : forall c : actid,\n(exists l0 : location,\n   col0 l0 z c \\/\n   ((I ∩₁ Loc_ l0) × (E ∩₁ W ∩₁ Loc_ l0 \\₁ I)) z c /\\ ~ col0 l0 c z) ->\n(exists l0 : location,\n   col0 l0 c x \\/\n   ((I ∩₁ Loc_ l0) × (E ∩₁ W ∩₁ Loc_ l0 \\₁ I)) c x /\\ ~ col0 l0 x c) -> False) (H : ~ I z) (X : ~ T x) (H0 : E z) (H7 : is_w lab z) (l : location) (H2 : ((I ∩₁ Loc_ l) × (E ∩₁ W ∩₁ Loc_ l \\₁ I)) z x /\\ ~ col0 l x z) (H6 : is_w lab x) (H3 : E x) (Ix : I x) : False.","proofString":"by unfolder in H2; basic_solver 21."},{"statement":"(x z : actid) (H1 : forall c : actid,\n(exists l0 : location,\n   col0 l0 z c \\/\n   ((I ∩₁ Loc_ l0) × (E ∩₁ W ∩₁ Loc_ l0 \\₁ I)) z c /\\ ~ col0 l0 c z) ->\n(exists l0 : location,\n   col0 l0 c x \\/\n   ((I ∩₁ Loc_ l0) × (E ∩₁ W ∩₁ Loc_ l0 \\₁ I)) c x /\\ ~ col0 l0 x c) -> False) (H : ~ I z) (X : ~ T x) (H0 : E z) (H7 : is_w lab z) (l : location) (K : col0 l z x) (H6 : is_w lab x) (H3 : E x) (Ix : I x) : False.","proofString":"unfold col0 in *.\ndestruct K.\nunfolder in H2; basic_solver 21.\neauto 12."},{"statement":"(x z : actid) (H1 : forall c : actid,\n(exists l0 : location,\n   (⦗I⦘ ⨾ col l0 ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l0 ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l0 ⨾ ⦗T⦘)⁺ z c \\/\n   ((I ∩₁ Loc_ l0) × (E ∩₁ W ∩₁ Loc_ l0 \\₁ I)) z c /\\\n   ~ (⦗I⦘ ⨾ col l0 ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l0 ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l0 ⨾ ⦗T⦘)⁺ c z) ->\n(exists l0 : location,\n   (⦗I⦘ ⨾ col l0 ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l0 ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l0 ⨾ ⦗T⦘)⁺ c x \\/\n   ((I ∩₁ Loc_ l0) × (E ∩₁ W ∩₁ Loc_ l0 \\₁ I)) c x /\\\n   ~ (⦗I⦘ ⨾ col l0 ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l0 ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l0 ⨾ ⦗T⦘)⁺ x c) ->\nFalse) (H : ~ I z) (X : ~ T x) (H0 : E z) (H7 : is_w lab z) (l : location) (K : (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘)⁺ z x) (H6 : is_w lab x) (H3 : E x) (Ix : I x) : False.","proofString":"destruct K.\nunfolder in H2; basic_solver 21.\neauto 12."},{"statement":"(z y : actid) (H1 : forall c : actid,\n(exists l0 : location,\n   (⦗I⦘ ⨾ col l0 ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l0 ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l0 ⨾ ⦗T⦘)⁺ z c \\/\n   ((I ∩₁ Loc_ l0) × (E ∩₁ W ∩₁ Loc_ l0 \\₁ I)) z c /\\\n   ~ (⦗I⦘ ⨾ col l0 ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l0 ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l0 ⨾ ⦗T⦘)⁺ c z) ->\n(exists l0 : location,\n   (⦗I⦘ ⨾ col l0 ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l0 ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l0 ⨾ ⦗T⦘)⁺ c y \\/\n   ((I ∩₁ Loc_ l0) × (E ∩₁ W ∩₁ Loc_ l0 \\₁ I)) c y /\\\n   ~ (⦗I⦘ ⨾ col l0 ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l0 ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l0 ⨾ ⦗T⦘)⁺ y c) ->\nFalse) (H : ~ I z) (X : ~ T y) (H0 : E z) (H7 : is_w lab z) (l : location) (H2 : (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) z y) (H6 : is_w lab y) (H3 : E y) (Ix : I y) : False.","proofString":"unfolder in H2; basic_solver 21."},{"statement":"(z z0 : actid) (H1 : forall c : actid,\n(exists l0 : location,\n   (⦗I⦘ ⨾ col l0 ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l0 ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l0 ⨾ ⦗T⦘)⁺ z c \\/\n   ((I ∩₁ Loc_ l0) × (E ∩₁ W ∩₁ Loc_ l0 \\₁ I)) z c /\\\n   ~ (⦗I⦘ ⨾ col l0 ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l0 ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l0 ⨾ ⦗T⦘)⁺ c z) ->\n(exists l0 : location,\n   (⦗I⦘ ⨾ col l0 ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l0 ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l0 ⨾ ⦗T⦘)⁺ c z0 \\/\n   ((I ∩₁ Loc_ l0) × (E ∩₁ W ∩₁ Loc_ l0 \\₁ I)) c z0 /\\\n   ~ (⦗I⦘ ⨾ col l0 ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l0 ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l0 ⨾ ⦗T⦘)⁺ z0 c) ->\nFalse) (H : ~ I z) (X : ~ T z0) (H0 : E z) (H7 : is_w lab z) (l : location) (y : actid) (K1 : (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘)⁺ z y) (K2 : (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘)⁺ y z0) (H6 : is_w lab z0) (H3 : E z0) (Ix : I z0) : False.","proofString":"eauto 12."},{"statement":"(l : location) : ⦗T⦘ ⨾ col l ⨾ ⦗I ∩₁ T⦘ ⨾ col l ⨾ ⦗I⦘\n⊆ (fun x y : actid =>\n   (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘)⁺ x y \\/\n   ((I ∩₁ Loc_ l) × (E ∩₁ W ∩₁ Loc_ l \\₁ I)) x y /\\\n   ~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘)⁺ y x).","proofString":"unfolder; ins; left; desf.\neapply t_trans; apply t_step; eauto 15."},{"statement":"(l : location) (x y : actid) (H : T x) (z : actid) (H0 : col l x z) (H1 : I z) (H4 : T z) (H2 : col l z y) (H3 : I y) : (fun x0 y0 : actid =>\n ((exists z0 : actid,\n     (x0 = z0 /\\ I x0) /\\ (exists z1 : actid, col l z0 z1 /\\ z1 = y0 /\\ I z1)) \\/\n  (exists z0 : actid,\n     (x0 = z0 /\\ T x0) /\\ (exists z1 : actid, col l z0 z1 /\\ z1 = y0 /\\ T z1))) \\/\n (exists z0 : actid,\n    (x0 = z0 /\\ I x0) /\\ (exists z1 : actid, col l z0 z1 /\\ z1 = y0 /\\ T z1)))⁺\n  x y.","proofString":"eapply t_trans; apply t_step; eauto 15."},{"statement":"⦗T⦘ ⨾ co ⨾ ⦗I ∩₁ T⦘ ⨾ co ⨾ ⦗I⦘ ⊆ new_co.","proofString":"unfold new_co.\nunfolder; ins; desf.\napply co_in_col in H0.\napply co_in_col in H2.\ndesf.\nassert (l = l0); subst.\nhahn_rewrite wf_colD in H0.\nhahn_rewrite wf_colD in H2.\nunfolder in *; desf.\nexists l0.\napply new_col_helper.\nbasic_solver 12."},{"statement":"⦗T⦘ ⨾ co ⨾ ⦗I ∩₁ T⦘ ⨾ co ⨾ ⦗I⦘\n⊆ (fun x y : actid => exists l : location, new_col l x y).","proofString":"unfolder; ins; desf.\napply co_in_col in H0.\napply co_in_col in H2.\ndesf.\nassert (l = l0); subst.\nhahn_rewrite wf_colD in H0.\nhahn_rewrite wf_colD in H2.\nunfolder in *; desf.\nexists l0.\napply new_col_helper.\nbasic_solver 12."},{"statement":"(x y : actid) (H : T x) (z : actid) (H0 : co x z) (H1 : I z) (H4 : T z) (H2 : co z y) (H3 : I y) : exists l : location, new_col l x y.","proofString":"apply co_in_col in H0.\napply co_in_col in H2.\ndesf.\nassert (l = l0); subst.\nhahn_rewrite wf_colD in H0.\nhahn_rewrite wf_colD in H2.\nunfolder in *; desf.\nexists l0.\napply new_col_helper.\nbasic_solver 12."},{"statement":"(x y : actid) (H : T x) (z : actid) (H0 : exists l : location, col l x z) (H1 : I z) (H4 : T z) (H2 : co z y) (H3 : I y) : exists l : location, new_col l x y.","proofString":"apply co_in_col in H2.\ndesf.\nassert (l = l0); subst.\nhahn_rewrite wf_colD in H0.\nhahn_rewrite wf_colD in H2.\nunfolder in *; desf.\nexists l0.\napply new_col_helper.\nbasic_solver 12."},{"statement":"(x y : actid) (H : T x) (z : actid) (H0 : exists l : location, col l x z) (H1 : I z) (H4 : T z) (H2 : exists l : location, col l z y) (H3 : I y) : exists l : location, new_col l x y.","proofString":"desf.\nassert (l = l0); subst.\nhahn_rewrite wf_colD in H0.\nhahn_rewrite wf_colD in H2.\nunfolder in *; desf.\nexists l0.\napply new_col_helper.\nbasic_solver 12."},{"statement":"(x y : actid) (H : T x) (z : actid) (l0 : location) (H0 : col l0 x z) (H1 : I z) (H4 : T z) (l : location) (H2 : col l z y) (H3 : I y) : exists l1 : location, new_col l1 x y.","proofString":"assert (l = l0); subst.\nhahn_rewrite wf_colD in H0.\nhahn_rewrite wf_colD in H2.\nunfolder in *; desf.\nexists l0.\napply new_col_helper.\nbasic_solver 12."},{"statement":"(x y : actid) (H : T x) (z : actid) (l0 : location) (H0 : col l0 x z) (H1 : I z) (H4 : T z) (l : location) (H2 : col l z y) (H3 : I y) : l = l0.","proofString":"hahn_rewrite wf_colD in H0.\nhahn_rewrite wf_colD in H2.\nunfolder in *; desf."},{"statement":"(x y : actid) (H : T x) (z : actid) (l0 : location) (H1 : I z) (H4 : T z) (l : location) (H2 : col l z y) (H3 : I y) (H0 : (⦗W_ l0⦘ ⨾ col l0 ⨾ ⦗W_ l0⦘) x z) : l = l0.","proofString":"hahn_rewrite wf_colD in H2.\nunfolder in *; desf."},{"statement":"(x y : actid) (H : T x) (z : actid) (l0 : location) (H1 : I z) (H4 : T z) (l : location) (H3 : I y) (H0 : (⦗W_ l0⦘ ⨾ col l0 ⨾ ⦗W_ l0⦘) x z) (H2 : (⦗W_ l⦘ ⨾ col l ⨾ ⦗W_ l⦘) z y) : l = l0.","proofString":"unfolder in *; desf."},{"statement":"(x y : actid) (H : T x) (z : actid) (l0 : location) (H0 : col l0 x z) (H1 : I z) (H4 : T z) (H2 : col l0 z y) (H3 : I y) : exists l : location, new_col l x y.","proofString":"exists l0.\napply new_col_helper.\nbasic_solver 12."},{"statement":"(x y : actid) (H : T x) (z : actid) (l0 : location) (H0 : col l0 x z) (H1 : I z) (H4 : T z) (H2 : col l0 z y) (H3 : I y) : new_col l0 x y.","proofString":"apply new_col_helper.\nbasic_solver 12."},{"statement":"(x y : actid) (H : T x) (z : actid) (l0 : location) (H0 : col l0 x z) (H1 : I z) (H4 : T z) (H2 : col l0 z y) (H3 : I y) : (⦗T⦘ ⨾ col l0 ⨾ ⦗I ∩₁ T⦘ ⨾ col l0 ⨾ ⦗I⦘) x y.","proofString":"basic_solver 12."},{"statement":"⦗I⦘ ⨾ co ⊆ (fun x y : actid => exists l : location, new_col l x y).","proofString":"unfolder; ins; desf.\napply co_in_col in H0.\ndesf.\nexists l.\nunfold new_col, pref_union, col0.\nleft.\napply t_step.\ndestruct (classic (I y)).\nbasic_solver 11.\nright; unfolder; splits; eauto.\nhahn_rewrite (wf_colE) in H0.\nhahn_rewrite (wf_colD) in H0.\nunfolder in H0; desf.\nassert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf."},{"statement":"(x y : actid) (H : I x) (H0 : co x y) : exists l : location, new_col l x y.","proofString":"apply co_in_col in H0.\ndesf.\nexists l.\nunfold new_col, pref_union, col0.\nleft.\napply t_step.\ndestruct (classic (I y)).\nbasic_solver 11.\nright; unfolder; splits; eauto.\nhahn_rewrite (wf_colE) in H0.\nhahn_rewrite (wf_colD) in H0.\nunfolder in H0; desf.\nassert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf."},{"statement":"(x y : actid) (H : I x) (H0 : exists l : location, col l x y) : exists l : location, new_col l x y.","proofString":"desf.\nexists l.\nunfold new_col, pref_union, col0.\nleft.\napply t_step.\ndestruct (classic (I y)).\nbasic_solver 11.\nright; unfolder; splits; eauto.\nhahn_rewrite (wf_colE) in H0.\nhahn_rewrite (wf_colD) in H0.\nunfolder in H0; desf.\nassert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf."},{"statement":"(x y : actid) (H : I x) (l : location) (H0 : col l x y) : exists l0 : location, new_col l0 x y.","proofString":"exists l.\nunfold new_col, pref_union, col0.\nleft.\napply t_step.\ndestruct (classic (I y)).\nbasic_solver 11.\nright; unfolder; splits; eauto.\nhahn_rewrite (wf_colE) in H0.\nhahn_rewrite (wf_colD) in H0.\nunfolder in H0; desf.\nassert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf."},{"statement":"(x y : actid) (H : I x) (l : location) (H0 : col l x y) : new_col l x y.","proofString":"unfold new_col, pref_union, col0.\nleft.\napply t_step.\ndestruct (classic (I y)).\nbasic_solver 11.\nright; unfolder; splits; eauto.\nhahn_rewrite (wf_colE) in H0.\nhahn_rewrite (wf_colD) in H0.\nunfolder in H0; desf.\nassert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf."},{"statement":"(x y : actid) (H : I x) (l : location) (H0 : col l x y) : (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘)⁺ x y \\/\n((I ∩₁ Loc_ l) × (E ∩₁ W ∩₁ Loc_ l \\₁ I)) x y /\\\n~ (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘)⁺ y x.","proofString":"left.\napply t_step.\ndestruct (classic (I y)).\nbasic_solver 11.\nright; unfolder; splits; eauto.\nhahn_rewrite (wf_colE) in H0.\nhahn_rewrite (wf_colD) in H0.\nunfolder in H0; desf.\nassert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf."},{"statement":"(x y : actid) (H : I x) (l : location) (H0 : col l x y) : (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘)⁺ x y.","proofString":"apply t_step.\ndestruct (classic (I y)).\nbasic_solver 11.\nright; unfolder; splits; eauto.\nhahn_rewrite (wf_colE) in H0.\nhahn_rewrite (wf_colD) in H0.\nunfolder in H0; desf.\nassert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf."},{"statement":"(x y : actid) (H : I x) (l : location) (H0 : col l x y) : (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) x y.","proofString":"destruct (classic (I y)).\nbasic_solver 11.\nright; unfolder; splits; eauto.\nhahn_rewrite (wf_colE) in H0.\nhahn_rewrite (wf_colD) in H0.\nunfolder in H0; desf.\nassert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf."},{"statement":"(x y : actid) (H : I x) (l : location) (H0 : col l x y) (H1 : I y) : (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) x y.","proofString":"basic_solver 11."},{"statement":"(x y : actid) (H : I x) (l : location) (H0 : col l x y) (H1 : ~ I y) : (⦗I⦘ ⨾ col l ⨾ ⦗I⦘ ∪ ⦗T⦘ ⨾ col l ⨾ ⦗T⦘ ∪ ⦗I⦘ ⨾ col l ⨾ ⦗T⦘) x y.","proofString":"right; unfolder; splits; eauto.\nhahn_rewrite (wf_colE) in H0.\nhahn_rewrite (wf_colD) in H0.\nunfolder in H0; desf.\nassert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf."},{"statement":"(x y : actid) (H : I x) (l : location) (H0 : col l x y) (H1 : ~ I y) : T y.","proofString":"hahn_rewrite (wf_colE) in H0.\nhahn_rewrite (wf_colD) in H0.\nunfolder in H0; desf.\nassert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf."},{"statement":"(x y : actid) (H : I x) (l : location) (H1 : ~ I y) (H0 : (⦗E⦘ ⨾ col l ⨾ ⦗E⦘) x y) : T y.","proofString":"hahn_rewrite (wf_colD) in H0.\nunfolder in H0; desf.\nassert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf."},{"statement":"(x y : actid) (H : I x) (l : location) (H1 : ~ I y) (H0 : (⦗E⦘ ⨾ (⦗W_ l⦘ ⨾ col l ⨾ ⦗W_ l⦘) ⨾ ⦗E⦘) x y) : T y.","proofString":"unfolder in H0; desf.\nassert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf."},{"statement":"(y z : actid) (H : I z) (l : location) (H1 : ~ I y) (H0 : E z) (H9 : loc z = Some l) (H8 : is_w lab z) (H4 : col l z y) (H7 : loc y = Some l) (H6 : is_w lab y) (H3 : E y) : T y.","proofString":"assert ((I ∪₁ T) y).\neapply IT; basic_solver.\nunfolder in *; desf."},{"statement":"(y z : actid) (H : I z) (l : location) (H1 : ~ I y) (H0 : E z) (H9 : loc z = Some l) (H8 : is_w lab z) (H4 : col l z y) (H7 : loc y = Some l) (H6 : is_w lab y) (H3 : E y) : (I ∪₁ T) y.","proofString":"eapply IT; basic_solver."},{"statement":"(y z : actid) (H : I z) (l : location) (H1 : ~ I y) (H0 : E z) (H9 : loc z = Some l) (H8 : is_w lab z) (H4 : col l z y) (H7 : loc y = Some l) (H6 : is_w lab y) (H3 : E y) (H2 : (I ∪₁ T) y) : T y.","proofString":"unfolder in *; desf."}]}