{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/MenhirLib/Validator_complete.v","fileSamples":[{"statement":"(st : state) (prod : production) (pos : nat) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (H : TerminalSet.In lookahead lset) (HSS : TerminalSet.Subset lset (find_items_map (items_map ()) st prod pos)) : state_has_future st prod (future_of_prod prod pos) lookahead.","proofString":"exists pos.\nsplit=>//.\nby apply HSS."},{"statement":"(st : state) (prod : production) (pos : nat) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (H : TerminalSet.In lookahead lset) (HSS : TerminalSet.Subset lset (find_items_map (items_map ()) st prod pos)) : future_of_prod prod pos = future_of_prod prod pos /\\\nTerminalSet.In lookahead (find_items_map (items_map ()) st prod pos).","proofString":"split=>//.\nby apply HSS."},{"statement":"(st : state) (prod : production) (pos : nat) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (H : TerminalSet.In lookahead lset) (HSS : TerminalSet.Subset lset (find_items_map (items_map ()) st prod pos)) : TerminalSet.In lookahead (find_items_map (items_map ()) st prod pos).","proofString":"by apply HSS."},{"statement":"(P : Prop) (b : TerminalSet.elt -> bool) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (Hlset : SetoidList.InA\n  (fun x y : TerminalOrderedType.Alt.t =>\n   TerminalOrderedType.Alt.compare x y = Eq) lookahead\n  (TerminalSet.elements lset)) (Hval : IsValidator P (b lookahead)) (Val : TerminalSet.fold\n  (fun (lookahead0 : TerminalSet.elt) (acc : bool) =>\n   if acc then b lookahead0 else false) lset true = true) : P.","proofString":"apply Hval.\nrevert Val.\nrewrite TerminalSet.fold_1.\ngeneralize true at 1.\nclear -Hlset.\ninduction Hlset as [? l <-%compare_eq|? l ? IH]=> /= b' Val.\ndestruct (b lookahead).\nby destruct b'.\nexfalso.\nby induction l; destruct b'.\neauto."},{"statement":"(P : Prop) (b : TerminalSet.elt -> bool) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (Hlset : SetoidList.InA\n  (fun x y : TerminalOrderedType.Alt.t =>\n   TerminalOrderedType.Alt.compare x y = Eq) lookahead\n  (TerminalSet.elements lset)) (Hval : IsValidator P (b lookahead)) (Val : TerminalSet.fold\n  (fun (lookahead0 : TerminalSet.elt) (acc : bool) =>\n   if acc then b lookahead0 else false) lset true = true) : b lookahead = true.","proofString":"revert Val.\nrewrite TerminalSet.fold_1.\ngeneralize true at 1.\nclear -Hlset.\ninduction Hlset as [? l <-%compare_eq|? l ? IH]=> /= b' Val.\ndestruct (b lookahead).\nby destruct b'.\nexfalso.\nby induction l; destruct b'.\neauto."},{"statement":"(P : Prop) (b : TerminalSet.elt -> bool) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (Hlset : SetoidList.InA\n  (fun x y : TerminalOrderedType.Alt.t =>\n   TerminalOrderedType.Alt.compare x y = Eq) lookahead\n  (TerminalSet.elements lset)) (Hval : IsValidator P (b lookahead)) : TerminalSet.fold\n  (fun (lookahead0 : TerminalSet.elt) (acc : bool) =>\n   if acc then b lookahead0 else false) lset true = true ->\nb lookahead = true.","proofString":"rewrite TerminalSet.fold_1.\ngeneralize true at 1.\nclear -Hlset.\ninduction Hlset as [? l <-%compare_eq|? l ? IH]=> /= b' Val.\ndestruct (b lookahead).\nby destruct b'.\nexfalso.\nby induction l; destruct b'.\neauto."},{"statement":"(P : Prop) (b : TerminalSet.elt -> bool) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (Hlset : SetoidList.InA\n  (fun x y : TerminalOrderedType.Alt.t =>\n   TerminalOrderedType.Alt.compare x y = Eq) lookahead\n  (TerminalSet.elements lset)) (Hval : IsValidator P (b lookahead)) : fold_left (fun (a : bool) (e : TerminalSet.elt) => if a then b e else false)\n  (TerminalSet.elements lset) true = true -> b lookahead = true.","proofString":"generalize true at 1.\nclear -Hlset.\ninduction Hlset as [? l <-%compare_eq|? l ? IH]=> /= b' Val.\ndestruct (b lookahead).\nby destruct b'.\nexfalso.\nby induction l; destruct b'.\neauto."},{"statement":"(P : Prop) (b : TerminalSet.elt -> bool) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (Hlset : SetoidList.InA\n  (fun x y : TerminalOrderedType.Alt.t =>\n   TerminalOrderedType.Alt.compare x y = Eq) lookahead\n  (TerminalSet.elements lset)) (Hval : IsValidator P (b lookahead)) : forall b0 : bool,\nfold_left (fun (a : bool) (e : TerminalSet.elt) => if a then b e else false)\n  (TerminalSet.elements lset) b0 = true -> b lookahead = true.","proofString":"clear -Hlset.\ninduction Hlset as [? l <-%compare_eq|? l ? IH]=> /= b' Val.\ndestruct (b lookahead).\nby destruct b'.\nexfalso.\nby induction l; destruct b'.\neauto."},{"statement":"(b : TerminalSet.elt -> bool) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (Hlset : SetoidList.InA\n  (fun x y : TerminalOrderedType.Alt.t =>\n   TerminalOrderedType.Alt.compare x y = Eq) lookahead\n  (TerminalSet.elements lset)) : forall b0 : bool,\nfold_left (fun (a : bool) (e : TerminalSet.elt) => if a then b e else false)\n  (TerminalSet.elements lset) b0 = true -> b lookahead = true.","proofString":"induction Hlset as [? l <-%compare_eq|? l ? IH]=> /= b' Val.\ndestruct (b lookahead).\nby destruct b'.\nexfalso.\nby induction l; destruct b'.\neauto."},{"statement":"(b : TerminalSet.elt -> bool) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (l : list TerminalOrderedType.Alt.t) (b' : bool) (Val : fold_left (fun (a : bool) (e : TerminalSet.elt) => if a then b e else false)\n  l (if b' then b lookahead else false) = true) : b lookahead = true.","proofString":"destruct (b lookahead).\nby destruct b'.\nexfalso.\nby induction l; destruct b'."},{"statement":"(b : TerminalSet.elt -> bool) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (l : list TerminalOrderedType.Alt.t) (b' : bool) (Val : fold_left (fun (a : bool) (e : TerminalSet.elt) => if a then b e else false)\n  l (if b' then true else false) = true) : true = true.","proofString":"by destruct b'."},{"statement":"(b : TerminalSet.elt -> bool) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (l : list TerminalOrderedType.Alt.t) (b' : bool) (Val : fold_left (fun (a : bool) (e : TerminalSet.elt) => if a then b e else false)\n  l (if b' then false else false) = true) : false = true.","proofString":"exfalso.\nby induction l; destruct b'."},{"statement":"(b : TerminalSet.elt -> bool) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (l : list TerminalOrderedType.Alt.t) (b' : bool) (Val : fold_left (fun (a : bool) (e : TerminalSet.elt) => if a then b e else false)\n  l (if b' then false else false) = true) : False.","proofString":"by induction l; destruct b'."},{"statement":"(b : TerminalSet.elt -> bool) (lookahead : TerminalSet.elt) (lset : TerminalSet.t) (y : TerminalOrderedType.Alt.t) (l : list TerminalOrderedType.Alt.t) (Hlset : SetoidList.InA\n  (fun x y0 : TerminalOrderedType.Alt.t =>\n   TerminalOrderedType.Alt.compare x y0 = Eq) lookahead l) (IH : forall b0 : bool,\nfold_left (fun (a : bool) (e : TerminalSet.elt) => if a then b e else false)\n  l b0 = true -> b lookahead = true) (b' : bool) (Val : fold_left (fun (a : bool) (e : TerminalSet.elt) => if a then b e else false)\n  l (if b' then b y else false) = true) : b lookahead = true.","proofString":"eauto."},{"statement":"(P1 : state -> production -> TerminalSet.elt -> Prop) (b1 : state -> production -> nat -> TerminalSet.t -> bool) (P2 : state -> production -> TerminalSet.elt -> symbol -> list symbol -> Prop) (b2 : state -> production -> nat -> TerminalSet.t -> symbol -> list symbol -> bool) (Hval1 : forall (st0 : state) (prod0 : production) (lookahead0 : TerminalSet.elt)\n  (lset : TerminalSet.t) (pos0 : nat),\nTerminalSet.In lookahead0 lset ->\n[] = future_of_prod prod0 pos0 ->\nIsValidator (P1 st0 prod0 lookahead0) (b1 st0 prod0 pos0 lset)) (Hval2 : forall (st0 : state) (prod0 : production) (pos0 : nat)\n  (lookahead0 : TerminalSet.elt) (lset : TerminalSet.t) \n  (s : symbol) (fut' : list symbol),\nTerminalSet.In lookahead0 lset ->\nfut' = future_of_prod prod0 (S pos0) ->\nIsValidator (P2 st0 prod0 lookahead0 s fut') (b2 st0 prod0 pos0 lset s fut')) (st : state) (prod : production) (lookahead : terminal) (pos : nat) (Hlookahead : TerminalSet.In lookahead (find_items_map (items_map ()) st prod pos)) (Val : fold_left\n  (fun (a : bool) (p : StateProdPosMap.key * TerminalSet.t) =>\n   let (p0, pos0) := fst p in\n   let (st0, p1) := p0 in\n   (a &&\n    match future_of_prod p1 pos0 with\n    | [] => b1 st0 p1 pos0 (snd p)\n    | s :: fut' => b2 st0 p1 pos0 (snd p) s fut'\n    end)%bool) (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))\n  true = true) : match future_of_prod prod pos with\n| [] => b1 st prod pos (find_items_map (items_map ()) st prod pos)\n| s :: fut' =>\n    b2 st prod pos (find_items_map (items_map ()) st prod pos) s fut'\nend = true.","proofString":"unfold find_items_map in *.\nassert (Hfind := @StateProdPosMap.find_2 _ (items_map ()) (st, prod, pos)).\ndestruct StateProdPosMap.find as [lset|]; [|by edestruct (TerminalSet.empty_1); eauto].\nspecialize (Hfind _ eq_refl).\napply StateProdPosMap.elements_1 in Hfind.\nrevert Val.\ngeneralize true at 1.\ninduction Hfind as [[? ?] l [?%compare_eq ?]|??? IH]=>?.\nsimpl in *; subst.\nmatch goal with |- _ -> ?X = true => destruct X end; [done|].\nrewrite Bool.andb_false_r.\nclear.\ninduction l as [|[[[??]?]?] l IH]=>//.\napply IH."},{"statement":"(P1 : state -> production -> TerminalSet.elt -> Prop) (b1 : state -> production -> nat -> TerminalSet.t -> bool) (P2 : state -> production -> TerminalSet.elt -> symbol -> list symbol -> Prop) (b2 : state -> production -> nat -> TerminalSet.t -> symbol -> list symbol -> bool) (Hval1 : forall (st0 : state) (prod0 : production) (lookahead0 : TerminalSet.elt)\n  (lset : TerminalSet.t) (pos0 : nat),\nTerminalSet.In lookahead0 lset ->\n[] = future_of_prod prod0 pos0 ->\nIsValidator (P1 st0 prod0 lookahead0) (b1 st0 prod0 pos0 lset)) (Hval2 : forall (st0 : state) (prod0 : production) (pos0 : nat)\n  (lookahead0 : TerminalSet.elt) (lset : TerminalSet.t) \n  (s : symbol) (fut' : list symbol),\nTerminalSet.In lookahead0 lset ->\nfut' = future_of_prod prod0 (S pos0) ->\nIsValidator (P2 st0 prod0 lookahead0 s fut') (b2 st0 prod0 pos0 lset s fut')) (st : state) (prod : production) (lookahead : terminal) (pos : nat) (Hlookahead : TerminalSet.In lookahead\n  match\n    StateProdPosMap.find (elt:=TerminalSet.t) (st, prod, pos) (items_map ())\n  with\n  | Some x => x\n  | None => TerminalSet.empty\n  end) (Val : fold_left\n  (fun (a : bool) (p : StateProdPosMap.key * TerminalSet.t) =>\n   let (p0, pos0) := fst p in\n   let (st0, p1) := p0 in\n   (a &&\n    match future_of_prod p1 pos0 with\n    | [] => b1 st0 p1 pos0 (snd p)\n    | s :: fut' => b2 st0 p1 pos0 (snd p) s fut'\n    end)%bool) (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))\n  true = true) : match future_of_prod prod pos with\n| [] =>\n    b1 st prod pos\n      match\n        StateProdPosMap.find (elt:=TerminalSet.t) (\n          st, prod, pos) (items_map ())\n      with\n      | Some x => x\n      | None => TerminalSet.empty\n      end\n| s :: fut' =>\n    b2 st prod pos\n      match\n        StateProdPosMap.find (elt:=TerminalSet.t) (\n          st, prod, pos) (items_map ())\n      with\n      | Some x => x\n      | None => TerminalSet.empty\n      end s fut'\nend = true.","proofString":"assert (Hfind := @StateProdPosMap.find_2 _ (items_map ()) (st, prod, pos)).\ndestruct StateProdPosMap.find as [lset|]; [|by edestruct (TerminalSet.empty_1); eauto].\nspecialize (Hfind _ eq_refl).\napply StateProdPosMap.elements_1 in Hfind.\nrevert Val.\ngeneralize true at 1.\ninduction Hfind as [[? ?] l [?%compare_eq ?]|??? IH]=>?.\nsimpl in *; subst.\nmatch goal with |- _ -> ?X = true => destruct X end; [done|].\nrewrite Bool.andb_false_r.\nclear.\ninduction l as [|[[[??]?]?] l IH]=>//.\napply IH."},{"statement":"(P1 : state -> production -> TerminalSet.elt -> Prop) (b1 : state -> production -> nat -> TerminalSet.t -> bool) (P2 : state -> production -> TerminalSet.elt -> symbol -> list symbol -> Prop) (b2 : state -> production -> nat -> TerminalSet.t -> symbol -> list symbol -> bool) (Hval1 : forall (st0 : state) (prod0 : production) (lookahead0 : TerminalSet.elt)\n  (lset : TerminalSet.t) (pos0 : nat),\nTerminalSet.In lookahead0 lset ->\n[] = future_of_prod prod0 pos0 ->\nIsValidator (P1 st0 prod0 lookahead0) (b1 st0 prod0 pos0 lset)) (Hval2 : forall (st0 : state) (prod0 : production) (pos0 : nat)\n  (lookahead0 : TerminalSet.elt) (lset : TerminalSet.t) \n  (s : symbol) (fut' : list symbol),\nTerminalSet.In lookahead0 lset ->\nfut' = future_of_prod prod0 (S pos0) ->\nIsValidator (P2 st0 prod0 lookahead0 s fut') (b2 st0 prod0 pos0 lset s fut')) (st : state) (prod : production) (lookahead : terminal) (pos : nat) (Hlookahead : TerminalSet.In lookahead\n  match\n    StateProdPosMap.find (elt:=TerminalSet.t) (st, prod, pos) (items_map ())\n  with\n  | Some x => x\n  | None => TerminalSet.empty\n  end) (Val : fold_left\n  (fun (a : bool) (p : StateProdPosMap.key * TerminalSet.t) =>\n   let (p0, pos0) := fst p in\n   let (st0, p1) := p0 in\n   (a &&\n    match future_of_prod p1 pos0 with\n    | [] => b1 st0 p1 pos0 (snd p)\n    | s :: fut' => b2 st0 p1 pos0 (snd p) s fut'\n    end)%bool) (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))\n  true = true) (Hfind : forall e : TerminalSet.t,\nStateProdPosMap.find (elt:=TerminalSet.t) (st, prod, pos) (items_map ()) =\nSome e -> StateProdPosMap.MapsTo (st, prod, pos) e (items_map ())) : match future_of_prod prod pos with\n| [] =>\n    b1 st prod pos\n      match\n        StateProdPosMap.find (elt:=TerminalSet.t) (\n          st, prod, pos) (items_map ())\n      with\n      | Some x => x\n      | None => TerminalSet.empty\n      end\n| s :: fut' =>\n    b2 st prod pos\n      match\n        StateProdPosMap.find (elt:=TerminalSet.t) (\n          st, prod, pos) (items_map ())\n      with\n      | Some x => x\n      | None => TerminalSet.empty\n      end s fut'\nend = true.","proofString":"destruct StateProdPosMap.find as [lset|]; [|by edestruct (TerminalSet.empty_1); eauto].\nspecialize (Hfind _ eq_refl).\napply StateProdPosMap.elements_1 in Hfind.\nrevert Val.\ngeneralize true at 1.\ninduction Hfind as [[? ?] l [?%compare_eq ?]|??? IH]=>?.\nsimpl in *; subst.\nmatch goal with |- _ -> ?X = true => destruct X end; [done|].\nrewrite Bool.andb_false_r.\nclear.\ninduction l as [|[[[??]?]?] l IH]=>//.\napply IH."},{"statement":"(P1 : state -> production -> TerminalSet.elt -> Prop) (b1 : state -> production -> nat -> TerminalSet.t -> bool) (P2 : state -> production -> TerminalSet.elt -> symbol -> list symbol -> Prop) (b2 : state -> production -> nat -> TerminalSet.t -> symbol -> list symbol -> bool) (Hval1 : forall (st0 : state) (prod0 : production) (lookahead0 : TerminalSet.elt)\n  (lset0 : TerminalSet.t) (pos0 : nat),\nTerminalSet.In lookahead0 lset0 ->\n[] = future_of_prod prod0 pos0 ->\nIsValidator (P1 st0 prod0 lookahead0) (b1 st0 prod0 pos0 lset0)) (Hval2 : forall (st0 : state) (prod0 : production) (pos0 : nat)\n  (lookahead0 : TerminalSet.elt) (lset0 : TerminalSet.t) \n  (s : symbol) (fut' : list symbol),\nTerminalSet.In lookahead0 lset0 ->\nfut' = future_of_prod prod0 (S pos0) ->\nIsValidator (P2 st0 prod0 lookahead0 s fut') (b2 st0 prod0 pos0 lset0 s fut')) (st : state) (prod : production) (lookahead : terminal) (pos : nat) (lset : TerminalSet.t) (Hlookahead : TerminalSet.In lookahead lset) (Val : fold_left\n  (fun (a : bool) (p : StateProdPosMap.key * TerminalSet.t) =>\n   let (p0, pos0) := fst p in\n   let (st0, p1) := p0 in\n   (a &&\n    match future_of_prod p1 pos0 with\n    | [] => b1 st0 p1 pos0 (snd p)\n    | s :: fut' => b2 st0 p1 pos0 (snd p) s fut'\n    end)%bool) (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))\n  true = true) (Hfind : forall e : TerminalSet.t,\nSome lset = Some e -> StateProdPosMap.MapsTo (st, prod, pos) e (items_map ())) : match future_of_prod prod pos with\n| [] => b1 st prod pos lset\n| s :: fut' => b2 st prod pos lset s fut'\nend = true.","proofString":"specialize (Hfind _ eq_refl).\napply StateProdPosMap.elements_1 in Hfind.\nrevert Val.\ngeneralize true at 1.\ninduction Hfind as [[? ?] l [?%compare_eq ?]|??? IH]=>?.\nsimpl in *; subst.\nmatch goal with |- _ -> ?X = true => destruct X end; [done|].\nrewrite Bool.andb_false_r.\nclear.\ninduction l as [|[[[??]?]?] l IH]=>//.\napply IH."},{"statement":"(P1 : state -> production -> TerminalSet.elt -> Prop) (b1 : state -> production -> nat -> TerminalSet.t -> bool) (P2 : state -> production -> TerminalSet.elt -> symbol -> list symbol -> Prop) (b2 : state -> production -> nat -> TerminalSet.t -> symbol -> list symbol -> bool) (Hval1 : forall (st0 : state) (prod0 : production) (lookahead0 : TerminalSet.elt)\n  (lset0 : TerminalSet.t) (pos0 : nat),\nTerminalSet.In lookahead0 lset0 ->\n[] = future_of_prod prod0 pos0 ->\nIsValidator (P1 st0 prod0 lookahead0) (b1 st0 prod0 pos0 lset0)) (Hval2 : forall (st0 : state) (prod0 : production) (pos0 : nat)\n  (lookahead0 : TerminalSet.elt) (lset0 : TerminalSet.t) \n  (s : symbol) (fut' : list symbol),\nTerminalSet.In lookahead0 lset0 ->\nfut' = future_of_prod prod0 (S pos0) ->\nIsValidator (P2 st0 prod0 lookahead0 s fut') (b2 st0 prod0 pos0 lset0 s fut')) (st : state) (prod : production) (lookahead : terminal) (pos : nat) (lset : TerminalSet.t) (Hlookahead : TerminalSet.In lookahead lset) (Val : fold_left\n  (fun (a : bool) (p : StateProdPosMap.key * TerminalSet.t) =>\n   let (p0, pos0) := fst p in\n   let (st0, p1) := p0 in\n   (a &&\n    match future_of_prod p1 pos0 with\n    | [] => b1 st0 p1 pos0 (snd p)\n    | s :: fut' => b2 st0 p1 pos0 (snd p) s fut'\n    end)%bool) (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))\n  true = true) (Hfind : StateProdPosMap.MapsTo (st, prod, pos) lset (items_map ())) : match future_of_prod prod pos with\n| [] => b1 st prod pos lset\n| s :: fut' => b2 st prod pos lset s fut'\nend = true.","proofString":"apply StateProdPosMap.elements_1 in Hfind.\nrevert Val.\ngeneralize true at 1.\ninduction Hfind as [[? ?] l [?%compare_eq ?]|??? IH]=>?.\nsimpl in *; subst.\nmatch goal with |- _ -> ?X = true => destruct X end; [done|].\nrewrite Bool.andb_false_r.\nclear.\ninduction l as [|[[[??]?]?] l IH]=>//.\napply IH."},{"statement":"(P1 : state -> production -> TerminalSet.elt -> Prop) (b1 : state -> production -> nat -> TerminalSet.t -> bool) (P2 : state -> production -> TerminalSet.elt -> symbol -> list symbol -> Prop) (b2 : state -> production -> nat -> TerminalSet.t -> symbol -> list symbol -> bool) (Hval1 : forall (st0 : state) (prod0 : production) (lookahead0 : TerminalSet.elt)\n  (lset0 : TerminalSet.t) (pos0 : nat),\nTerminalSet.In lookahead0 lset0 ->\n[] = future_of_prod prod0 pos0 ->\nIsValidator (P1 st0 prod0 lookahead0) (b1 st0 prod0 pos0 lset0)) (Hval2 : forall (st0 : state) (prod0 : production) (pos0 : nat)\n  (lookahead0 : TerminalSet.elt) (lset0 : TerminalSet.t) \n  (s : symbol) (fut' : list symbol),\nTerminalSet.In lookahead0 lset0 ->\nfut' = future_of_prod prod0 (S pos0) ->\nIsValidator (P2 st0 prod0 lookahead0 s fut') (b2 st0 prod0 pos0 lset0 s fut')) (st : state) (prod : production) (lookahead : terminal) (pos : nat) (lset : TerminalSet.t) (Hlookahead : TerminalSet.In lookahead lset) (Val : fold_left\n  (fun (a : bool) (p : StateProdPosMap.key * TerminalSet.t) =>\n   let (p0, pos0) := fst p in\n   let (st0, p1) := p0 in\n   (a &&\n    match future_of_prod p1 pos0 with\n    | [] => b1 st0 p1 pos0 (snd p)\n    | s :: fut' => b2 st0 p1 pos0 (snd p) s fut'\n    end)%bool) (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))\n  true = true) (Hfind : SetoidList.InA (StateProdPosMap.eq_key_elt (elt:=TerminalSet.t))\n  (st, prod, pos, lset)\n  (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))) : match future_of_prod prod pos with\n| [] => b1 st prod pos lset\n| s :: fut' => b2 st prod pos lset s fut'\nend = true.","proofString":"revert Val.\ngeneralize true at 1.\ninduction Hfind as [[? ?] l [?%compare_eq ?]|??? IH]=>?.\nsimpl in *; subst.\nmatch goal with |- _ -> ?X = true => destruct X end; [done|].\nrewrite Bool.andb_false_r.\nclear.\ninduction l as [|[[[??]?]?] l IH]=>//.\napply IH."},{"statement":"(P1 : state -> production -> TerminalSet.elt -> Prop) (b1 : state -> production -> nat -> TerminalSet.t -> bool) (P2 : state -> production -> TerminalSet.elt -> symbol -> list symbol -> Prop) (b2 : state -> production -> nat -> TerminalSet.t -> symbol -> list symbol -> bool) (Hval1 : forall (st0 : state) (prod0 : production) (lookahead0 : TerminalSet.elt)\n  (lset0 : TerminalSet.t) (pos0 : nat),\nTerminalSet.In lookahead0 lset0 ->\n[] = future_of_prod prod0 pos0 ->\nIsValidator (P1 st0 prod0 lookahead0) (b1 st0 prod0 pos0 lset0)) (Hval2 : forall (st0 : state) (prod0 : production) (pos0 : nat)\n  (lookahead0 : TerminalSet.elt) (lset0 : TerminalSet.t) \n  (s : symbol) (fut' : list symbol),\nTerminalSet.In lookahead0 lset0 ->\nfut' = future_of_prod prod0 (S pos0) ->\nIsValidator (P2 st0 prod0 lookahead0 s fut') (b2 st0 prod0 pos0 lset0 s fut')) (st : state) (prod : production) (lookahead : terminal) (pos : nat) (lset : TerminalSet.t) (Hlookahead : TerminalSet.In lookahead lset) (Hfind : SetoidList.InA (StateProdPosMap.eq_key_elt (elt:=TerminalSet.t))\n  (st, prod, pos, lset)\n  (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))) : fold_left\n  (fun (a : bool) (p : StateProdPosMap.key * TerminalSet.t) =>\n   let (p0, pos0) := fst p in\n   let (st0, p1) := p0 in\n   (a &&\n    match future_of_prod p1 pos0 with\n    | [] => b1 st0 p1 pos0 (snd p)\n    | s :: fut' => b2 st0 p1 pos0 (snd p) s fut'\n    end)%bool) (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))\n  true = true ->\nmatch future_of_prod prod pos with\n| [] => b1 st prod pos lset\n| s :: fut' => b2 st prod pos lset s fut'\nend = true.","proofString":"generalize true at 1.\ninduction Hfind as [[? ?] l [?%compare_eq ?]|??? IH]=>?.\nsimpl in *; subst.\nmatch goal with |- _ -> ?X = true => destruct X end; [done|].\nrewrite Bool.andb_false_r.\nclear.\ninduction l as [|[[[??]?]?] l IH]=>//.\napply IH."},{"statement":"(P1 : state -> production -> TerminalSet.elt -> Prop) (b1 : state -> production -> nat -> TerminalSet.t -> bool) (P2 : state -> production -> TerminalSet.elt -> symbol -> list symbol -> Prop) (b2 : state -> production -> nat -> TerminalSet.t -> symbol -> list symbol -> bool) (Hval1 : forall (st0 : state) (prod0 : production) (lookahead0 : TerminalSet.elt)\n  (lset0 : TerminalSet.t) (pos0 : nat),\nTerminalSet.In lookahead0 lset0 ->\n[] = future_of_prod prod0 pos0 ->\nIsValidator (P1 st0 prod0 lookahead0) (b1 st0 prod0 pos0 lset0)) (Hval2 : forall (st0 : state) (prod0 : production) (pos0 : nat)\n  (lookahead0 : TerminalSet.elt) (lset0 : TerminalSet.t) \n  (s : symbol) (fut' : list symbol),\nTerminalSet.In lookahead0 lset0 ->\nfut' = future_of_prod prod0 (S pos0) ->\nIsValidator (P2 st0 prod0 lookahead0 s fut') (b2 st0 prod0 pos0 lset0 s fut')) (st : state) (prod : production) (lookahead : terminal) (pos : nat) (lset : TerminalSet.t) (Hlookahead : TerminalSet.In lookahead lset) (Hfind : SetoidList.InA (StateProdPosMap.eq_key_elt (elt:=TerminalSet.t))\n  (st, prod, pos, lset)\n  (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))) : forall b : bool,\nfold_left\n  (fun (a : bool) (p : StateProdPosMap.key * TerminalSet.t) =>\n   let (p0, pos0) := fst p in\n   let (st0, p1) := p0 in\n   (a &&\n    match future_of_prod p1 pos0 with\n    | [] => b1 st0 p1 pos0 (snd p)\n    | s :: fut' => b2 st0 p1 pos0 (snd p) s fut'\n    end)%bool) (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))\n  b = true ->\nmatch future_of_prod prod pos with\n| [] => b1 st prod pos lset\n| s :: fut' => b2 st prod pos lset s fut'\nend = true.","proofString":"induction Hfind as [[? ?] l [?%compare_eq ?]|??? IH]=>?.\nsimpl in *; subst.\nmatch goal with |- _ -> ?X = true => destruct X end; [done|].\nrewrite Bool.andb_false_r.\nclear.\ninduction l as [|[[[??]?]?] l IH]=>//.\napply IH."},{"statement":"(b1 : state -> production -> nat -> TerminalSet.t -> bool) (b2 : state -> production -> nat -> TerminalSet.t -> symbol -> list symbol -> bool) (l : list (StateProdPosMap.key * TerminalSet.t)) : fold_left\n  (fun (a : bool) (p : StateProdPosMap.key * TerminalSet.t) =>\n   let (p0, pos) := fst p in\n   let (st, p1) := p0 in\n   (a &&\n    match future_of_prod p1 pos with\n    | [] => b1 st p1 pos (snd p)\n    | s :: fut' => b2 st p1 pos (snd p) s fut'\n    end)%bool) l false = true -> false = true.","proofString":"induction l as [|[[[??]?]?] l IH]=>//."},{"statement":"(P1 : state -> production -> TerminalSet.elt -> Prop) (b1 : state -> production -> nat -> TerminalSet.t -> bool) (P2 : state -> production -> TerminalSet.elt -> symbol -> list symbol -> Prop) (b2 : state -> production -> nat -> TerminalSet.t -> symbol -> list symbol -> bool) (Hval1 : forall (st0 : state) (prod0 : production) (lookahead0 : TerminalSet.elt)\n  (lset : TerminalSet.t) (pos0 : nat),\nTerminalSet.In lookahead0 lset ->\n[] = future_of_prod prod0 pos0 ->\nIsValidator (P1 st0 prod0 lookahead0) (b1 st0 prod0 pos0 lset)) (Hval2 : forall (st0 : state) (prod0 : production) (pos0 : nat)\n  (lookahead0 : TerminalSet.elt) (lset : TerminalSet.t) \n  (s : symbol) (fut' : list symbol),\nTerminalSet.In lookahead0 lset ->\nfut' = future_of_prod prod0 (S pos0) ->\nIsValidator (P2 st0 prod0 lookahead0 s fut') (b2 st0 prod0 pos0 lset s fut')) (st : state) (prod : production) (lookahead : terminal) (pos : nat) (Hlookahead : TerminalSet.In lookahead (find_items_map (items_map ()) st prod pos)) (Val : fold_left\n  (fun (a : bool) (p : StateProdPosMap.key * TerminalSet.t) =>\n   let (p0, pos0) := fst p in\n   let (st0, p1) := p0 in\n   (a &&\n    match future_of_prod p1 pos0 with\n    | [] => b1 st0 p1 pos0 (snd p)\n    | s :: fut' => b2 st0 p1 pos0 (snd p) s fut'\n    end)%bool) (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))\n  true = true) (EQ : future_of_prod prod pos = []) (H : b1 st prod pos (find_items_map (items_map ()) st prod pos) = true) : P1 st prod lookahead.","proofString":"by eapply Hval1; eauto."},{"statement":"(P1 : state -> production -> TerminalSet.elt -> Prop) (b1 : state -> production -> nat -> TerminalSet.t -> bool) (P2 : state -> production -> TerminalSet.elt -> symbol -> list symbol -> Prop) (b2 : state -> production -> nat -> TerminalSet.t -> symbol -> list symbol -> bool) (Hval1 : forall (st0 : state) (prod0 : production) (lookahead0 : TerminalSet.elt)\n  (lset : TerminalSet.t) (pos0 : nat),\nTerminalSet.In lookahead0 lset ->\n[] = future_of_prod prod0 pos0 ->\nIsValidator (P1 st0 prod0 lookahead0) (b1 st0 prod0 pos0 lset)) (Hval2 : forall (st0 : state) (prod0 : production) (pos0 : nat)\n  (lookahead0 : TerminalSet.elt) (lset : TerminalSet.t) \n  (s0 : symbol) (fut' : list symbol),\nTerminalSet.In lookahead0 lset ->\nfut' = future_of_prod prod0 (S pos0) ->\nIsValidator (P2 st0 prod0 lookahead0 s0 fut')\n  (b2 st0 prod0 pos0 lset s0 fut')) (st : state) (prod : production) (lookahead : terminal) (pos : nat) (Hlookahead : TerminalSet.In lookahead (find_items_map (items_map ()) st prod pos)) (Val : fold_left\n  (fun (a : bool) (p : StateProdPosMap.key * TerminalSet.t) =>\n   let (p0, pos0) := fst p in\n   let (st0, p1) := p0 in\n   (a &&\n    match future_of_prod p1 pos0 with\n    | [] => b1 st0 p1 pos0 (snd p)\n    | s0 :: fut' => b2 st0 p1 pos0 (snd p) s0 fut'\n    end)%bool) (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))\n  true = true) (s : symbol) (l : list symbol) (EQ : future_of_prod prod pos = s :: l) (H : b2 st prod pos (find_items_map (items_map ()) st prod pos) s l = true) : l = future_of_prod prod (S pos).","proofString":"revert EQ.\nunfold future_of_prod=>-> //."},{"statement":"(P1 : state -> production -> TerminalSet.elt -> Prop) (b1 : state -> production -> nat -> TerminalSet.t -> bool) (P2 : state -> production -> TerminalSet.elt -> symbol -> list symbol -> Prop) (b2 : state -> production -> nat -> TerminalSet.t -> symbol -> list symbol -> bool) (Hval1 : forall (st0 : state) (prod0 : production) (lookahead0 : TerminalSet.elt)\n  (lset : TerminalSet.t) (pos0 : nat),\nTerminalSet.In lookahead0 lset ->\n[] = future_of_prod prod0 pos0 ->\nIsValidator (P1 st0 prod0 lookahead0) (b1 st0 prod0 pos0 lset)) (Hval2 : forall (st0 : state) (prod0 : production) (pos0 : nat)\n  (lookahead0 : TerminalSet.elt) (lset : TerminalSet.t) \n  (s0 : symbol) (fut' : list symbol),\nTerminalSet.In lookahead0 lset ->\nfut' = future_of_prod prod0 (S pos0) ->\nIsValidator (P2 st0 prod0 lookahead0 s0 fut')\n  (b2 st0 prod0 pos0 lset s0 fut')) (st : state) (prod : production) (lookahead : terminal) (pos : nat) (Hlookahead : TerminalSet.In lookahead (find_items_map (items_map ()) st prod pos)) (Val : fold_left\n  (fun (a : bool) (p : StateProdPosMap.key * TerminalSet.t) =>\n   let (p0, pos0) := fst p in\n   let (st0, p1) := p0 in\n   (a &&\n    match future_of_prod p1 pos0 with\n    | [] => b1 st0 p1 pos0 (snd p)\n    | s0 :: fut' => b2 st0 p1 pos0 (snd p) s0 fut'\n    end)%bool) (StateProdPosMap.elements (elt:=TerminalSet.t) (items_map ()))\n  true = true) (s : symbol) (l : list symbol) (H : b2 st prod pos (find_items_map (items_map ()) st prod pos) s l = true) : future_of_prod prod pos = s :: l -> l = future_of_prod prod (S pos).","proofString":"unfold future_of_prod=>-> //."}]}