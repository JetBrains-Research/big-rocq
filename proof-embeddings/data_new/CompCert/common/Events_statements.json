{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Events.v","fileSamples":[{"statement":"(t : trace) : t ** E0 = t.","conclusion":"t ** E0 = t","hypotheses":"(t : trace)","proofString":"unfold E0, Eapp.\nrewrite app_nil_r.\nauto."},{"statement":"(t : trace) : t ++ nil = t.","conclusion":"t ++ nil = t","hypotheses":"(t : trace)","proofString":"rewrite app_nil_r.\nauto."},{"statement":"(t : trace) : t = t.","conclusion":"t = t","hypotheses":"(t : trace)","proofString":"auto."},{"statement":"(t1 t2 t3 : trace) : (t1 ** t2) ** t3 = t1 ** t2 ** t3.","conclusion":"(t1 ** t2) ** t3 = t1 ** t2 ** t3","hypotheses":"(t1 t2 t3 : trace)","proofString":"unfold Eapp, trace.\napply app_ass."},{"statement":"(t1 t2 t3 : trace) : (t1 ++ t2) ++ t3 = t1 ++ t2 ++ t3.","conclusion":"(t1 ++ t2) ++ t3 = t1 ++ t2 ++ t3","hypotheses":"(t1 t2 t3 : trace)","proofString":"apply app_ass."},{"statement":"(t2 : trace) (T : traceinf) : t2 *** T = t2 *** T.","conclusion":"t2 *** T = t2 *** T","hypotheses":"(t2 : trace) (T : traceinf)","proofString":"auto."},{"statement":"(a : event) (t1 : list event) (IHt1 : forall (t0 : trace) (T0 : traceinf), (t1 ** t0) *** T0 = t1 *** t0 *** T0) (t2 : trace) (T : traceinf) : Econsinf a ((t1 ** t2) *** T) = Econsinf a (t1 *** t2 *** T).","conclusion":"Econsinf a ((t1 ** t2) *** T) = Econsinf a (t1 *** t2 *** T)","hypotheses":"(a : event) (t1 : list event) (IHt1 : forall (t0 : trace) (T0 : traceinf), (t1 ** t0) *** T0 = t1 *** t0 *** T0) (t2 : trace) (T : traceinf)","proofString":"decEq; auto."},{"statement":"(COINDHYP : forall T0 : traceinf, traceinf_sim T0 T0) (T : traceinf) : traceinf_sim T T.","conclusion":"traceinf_sim T T","hypotheses":"(COINDHYP : forall T0 : traceinf, traceinf_sim T0 T0) (T : traceinf)","proofString":"destruct T.\nconstructor.\napply COINDHYP."},{"statement":"(COINDHYP : forall T0 : traceinf, traceinf_sim T0 T0) (e : event) (T : traceinf) : traceinf_sim (Econsinf e T) (Econsinf e T).","conclusion":"traceinf_sim (Econsinf e T) (Econsinf e T)","hypotheses":"(COINDHYP : forall T0 : traceinf, traceinf_sim T0 T0) (e : event) (T : traceinf)","proofString":"constructor.\napply COINDHYP."},{"statement":"(COINDHYP : forall T0 : traceinf, traceinf_sim T0 T0) (e : event) (T : traceinf) : traceinf_sim T T.","conclusion":"traceinf_sim T T","hypotheses":"(COINDHYP : forall T0 : traceinf, traceinf_sim T0 T0) (e : event) (T : traceinf)","proofString":"apply COINDHYP."},{"statement":"(COINDHYP : forall T0 T3 : traceinf, traceinf_sim T0 T3 -> traceinf_sim T3 T0) (T1 T2 : traceinf) (H : traceinf_sim T1 T2) : traceinf_sim T2 T1.","conclusion":"traceinf_sim T2 T1","hypotheses":"(COINDHYP : forall T0 T3 : traceinf, traceinf_sim T0 T3 -> traceinf_sim T3 T0) (T1 T2 : traceinf) (H : traceinf_sim T1 T2)","proofString":"inv H; constructor; auto."},{"statement":"(COINDHYP : forall T0 T4 T5 : traceinf,\ntraceinf_sim T0 T4 -> traceinf_sim T4 T5 -> traceinf_sim T0 T5) (T1 T2 T3 : traceinf) (H : traceinf_sim T1 T2) (H0 : traceinf_sim T2 T3) : traceinf_sim T1 T3.","conclusion":"traceinf_sim T1 T3","hypotheses":"(COINDHYP : forall T0 T4 T5 : traceinf,\ntraceinf_sim T0 T4 -> traceinf_sim T4 T5 -> traceinf_sim T0 T5) (T1 T2 T3 : traceinf) (H : traceinf_sim T1 T2) (H0 : traceinf_sim T2 T3)","proofString":"inv H; inv H0; constructor; eauto."},{"statement":"(T : traceinf') : T = match T with\n    | Econsinf' t T' NE => Econsinf' t T' NE\n    end.","conclusion":"T = match T with\n    | Econsinf' t T' NE => Econsinf' t T' NE\n    end","hypotheses":"(T : traceinf')","proofString":"destruct T; auto."},{"statement":"(T : traceinf) : T = match T with\n    | Econsinf t T' => Econsinf t T'\n    end.","conclusion":"T = match T with\n    | Econsinf t T' => Econsinf t T'\n    end","hypotheses":"(T : traceinf)","proofString":"destruct T; auto."},{"statement":"(t1 t2 t : trace) (H : trace_prefix t1 t2) : trace_prefix (t ** t1) (t ** t2).","conclusion":"trace_prefix (t ** t1) (t ** t2)","hypotheses":"(t1 t2 t : trace) (H : trace_prefix t1 t2)","proofString":"destruct H as [t3 EQ].\nexists t3.\ntraceEq."},{"statement":"(t1 t2 t t3 : trace) (EQ : t2 = t1 ** t3) : trace_prefix (t ** t1) (t ** t2).","conclusion":"trace_prefix (t ** t1) (t ** t2)","hypotheses":"(t1 t2 t t3 : trace) (EQ : t2 = t1 ** t3)","proofString":"exists t3.\ntraceEq."},{"statement":"(t1 t2 t t3 : trace) (EQ : t2 = t1 ** t3) : t ** t2 = (t ** t1) ** t3.","conclusion":"t ** t2 = (t ** t1) ** t3","hypotheses":"(t1 t2 t t3 : trace) (EQ : t2 = t1 ** t3)","proofString":"traceEq."},{"statement":"(t1 : trace) (T2 : traceinf) (t : trace) (H : traceinf_prefix t1 T2) : traceinf_prefix (t ** t1) (t *** T2).","conclusion":"traceinf_prefix (t ** t1) (t *** T2)","hypotheses":"(t1 : trace) (T2 : traceinf) (t : trace) (H : traceinf_prefix t1 T2)","proofString":"destruct H as [T3 EQ].\nexists T3.\nsubst T2.\ntraceEq."},{"statement":"(t1 : trace) (T2 : traceinf) (t : trace) (T3 : traceinf) (EQ : T2 = t1 *** T3) : traceinf_prefix (t ** t1) (t *** T2).","conclusion":"traceinf_prefix (t ** t1) (t *** T2)","hypotheses":"(t1 : trace) (T2 : traceinf) (t : trace) (T3 : traceinf) (EQ : T2 = t1 *** T3)","proofString":"exists T3.\nsubst T2.\ntraceEq."},{"statement":"(t1 : trace) (T2 : traceinf) (t : trace) (T3 : traceinf) (EQ : T2 = t1 *** T3) : t *** T2 = (t ** t1) *** T3.","conclusion":"t *** T2 = (t ** t1) *** T3","hypotheses":"(t1 : trace) (T2 : traceinf) (t : trace) (T3 : traceinf) (EQ : T2 = t1 *** T3)","proofString":"subst T2.\ntraceEq."},{"statement":"(t1 t : trace) (T3 : traceinf) : t *** t1 *** T3 = (t ** t1) *** T3.","conclusion":"t *** t1 *** T3 = (t ** t1) *** T3","hypotheses":"(t1 t : trace) (T3 : traceinf)","proofString":"traceEq."},{"statement":"(ev : eventval) (ty : typ) (v : val) (H : eventval_match ev ty v) : Val.has_type v ty.","conclusion":"Val.has_type v ty","hypotheses":"(ev : eventval) (ty : typ) (v : val) (H : eventval_match ev ty v)","proofString":"inv H; simpl; auto.\nunfold Tptr; destruct Archi.ptr64; auto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge id = true) (H1 : Senv.find_symbol ge id = Some b) : match Tptr with\n| Tlong => Archi.ptr64 = true\n| Tfloat | Tsingle => False\n| Tany64 => True\n| _ => Archi.ptr64 = false\nend.","conclusion":"match Tptr with\n| Tlong => Archi.ptr64 = true\n| Tfloat | Tsingle => False\n| Tany64 => True\n| _ => Archi.ptr64 = false\nend","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge id = true) (H1 : Senv.find_symbol ge id = Some b)","proofString":"unfold Tptr; destruct Archi.ptr64; auto."},{"statement":"(ev : eventval) (ty : typ) (v1 v2 : val) (H : eventval_match ev ty v1) (H0 : Val.lessdef v1 v2) : eventval_match ev ty v2.","conclusion":"eventval_match ev ty v2","hypotheses":"(ev : eventval) (ty : typ) (v1 v2 : val) (H : eventval_match ev ty v1) (H0 : Val.lessdef v1 v2)","proofString":"inv H; inv H0; constructor; auto."},{"statement":"(vl2 : list val) (H : Val.lessdef_list nil vl2) : eventval_list_match nil nil vl2.","conclusion":"eventval_list_match nil nil vl2","hypotheses":"(vl2 : list val) (H : Val.lessdef_list nil vl2)","proofString":"inv H; constructor."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall vl0 : list val,\nVal.lessdef_list vl vl0 -> eventval_list_match evl tyl vl0) (vl2 : list val) (H1 : Val.lessdef_list (v1 :: vl) vl2) : eventval_list_match (ev1 :: evl) (ty1 :: tyl) vl2.","conclusion":"eventval_list_match (ev1 :: evl) (ty1 :: tyl) vl2","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall vl0 : list val,\nVal.lessdef_list vl vl0 -> eventval_list_match evl tyl vl0) (vl2 : list val) (H1 : Val.lessdef_list (v1 :: vl) vl2)","proofString":"inv H1.\nconstructor.\neapply eventval_match_lessdef; eauto.\neauto."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall vl2 : list val,\nVal.lessdef_list vl vl2 -> eventval_list_match evl tyl vl2) (v2 : val) (vl0 : list val) (H4 : Val.lessdef v1 v2) (H6 : Val.lessdef_list vl vl0) : eventval_list_match (ev1 :: evl) (ty1 :: tyl) (v2 :: vl0).","conclusion":"eventval_list_match (ev1 :: evl) (ty1 :: tyl) (v2 :: vl0)","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall vl2 : list val,\nVal.lessdef_list vl vl2 -> eventval_list_match evl tyl vl2) (v2 : val) (vl0 : list val) (H4 : Val.lessdef v1 v2) (H6 : Val.lessdef_list vl vl0)","proofString":"constructor.\neapply eventval_match_lessdef; eauto.\neauto."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall vl2 : list val,\nVal.lessdef_list vl vl2 -> eventval_list_match evl tyl vl2) (v2 : val) (vl0 : list val) (H4 : Val.lessdef v1 v2) (H6 : Val.lessdef_list vl vl0) : eventval_match ev1 ty1 v2.","conclusion":"eventval_match ev1 ty1 v2","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall vl2 : list val,\nVal.lessdef_list vl vl2 -> eventval_list_match evl tyl vl2) (v2 : val) (vl0 : list val) (H4 : Val.lessdef v1 v2) (H6 : Val.lessdef_list vl vl0)","proofString":"eapply eventval_match_lessdef; eauto."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall vl2 : list val,\nVal.lessdef_list vl vl2 -> eventval_list_match evl tyl vl2) (v2 : val) (vl0 : list val) (H4 : Val.lessdef v1 v2) (H6 : Val.lessdef_list vl vl0) : eventval_list_match evl tyl vl0.","conclusion":"eventval_list_match evl tyl vl0","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall vl2 : list val,\nVal.lessdef_list vl vl2 -> eventval_list_match evl tyl vl2) (v2 : val) (vl0 : list val) (H4 : Val.lessdef v1 v2) (H6 : Val.lessdef_list vl vl0)","proofString":"eauto."},{"statement":"(ev : eventval) (ty : typ) (v1 v2 : val) (H : eventval_match ev ty v1) (H0 : eventval_match ev ty v2) : v1 = v2.","conclusion":"v1 = v2","hypotheses":"(ev : eventval) (ty : typ) (v1 v2 : val) (H : eventval_match ev ty v1) (H0 : eventval_match ev ty v2)","proofString":"inv H; inv H0; auto.\ncongruence."},{"statement":"(id : ident) (ofs : ptrofs) (b : block) (H1 : Senv.public_symbol ge id = true) (H2 : Senv.find_symbol ge id = Some b) (b0 : block) (H4 : Senv.public_symbol ge id = true) (H5 : Senv.find_symbol ge id = Some b0) : Vptr b ofs = Vptr b0 ofs.","conclusion":"Vptr b ofs = Vptr b0 ofs","hypotheses":"(id : ident) (ofs : ptrofs) (b : block) (H1 : Senv.public_symbol ge id = true) (H2 : Senv.find_symbol ge id = Some b) (b0 : block) (H4 : Senv.public_symbol ge id = true) (H5 : Senv.find_symbol ge id = Some b0)","proofString":"congruence."},{"statement":"(ev1 ev2 : eventval) (ty : typ) (v : val) (H : eventval_match ev1 ty v) (H0 : eventval_match ev2 ty v) : ev1 = ev2.","conclusion":"ev1 = ev2","hypotheses":"(ev1 ev2 : eventval) (ty : typ) (v : val) (H : eventval_match ev1 ty v) (H0 : eventval_match ev2 ty v)","proofString":"inv H; inv H0; auto.\ndecEq.\neapply Senv.find_symbol_injective; eauto."},{"statement":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge id = true) (H2 : Senv.find_symbol ge id = Some b) (id0 : ident) (H5 : Senv.public_symbol ge id0 = true) (H6 : Senv.find_symbol ge id0 = Some b) : EVptr_global id ofs = EVptr_global id0 ofs.","conclusion":"EVptr_global id ofs = EVptr_global id0 ofs","hypotheses":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge id = true) (H2 : Senv.find_symbol ge id = Some b) (id0 : ident) (H5 : Senv.public_symbol ge id0 = true) (H6 : Senv.find_symbol ge id0 = Some b)","proofString":"decEq.\neapply Senv.find_symbol_injective; eauto."},{"statement":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge id = true) (H2 : Senv.find_symbol ge id = Some b) (id0 : ident) (H5 : Senv.public_symbol ge id0 = true) (H6 : Senv.find_symbol ge id0 = Some b) : id = id0.","conclusion":"id = id0","hypotheses":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge id = true) (H2 : Senv.find_symbol ge id = Some b) (id0 : ident) (H5 : Senv.public_symbol ge id0 = true) (H6 : Senv.find_symbol ge id0 = Some b)","proofString":"eapply Senv.find_symbol_injective; eauto."},{"statement":"(evl2 : list eventval) (H : eventval_list_match evl2 nil nil) : nil = evl2.","conclusion":"nil = evl2","hypotheses":"(evl2 : list eventval) (H : eventval_list_match evl2 nil nil)","proofString":"inv H.\nauto."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall evl0 : list eventval, eventval_list_match evl0 tyl vl -> evl = evl0) (evl2 : list eventval) (H1 : eventval_list_match evl2 (ty1 :: tyl) (v1 :: vl)) : ev1 :: evl = evl2.","conclusion":"ev1 :: evl = evl2","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall evl0 : list eventval, eventval_list_match evl0 tyl vl -> evl = evl0) (evl2 : list eventval) (H1 : eventval_list_match evl2 (ty1 :: tyl) (v1 :: vl))","proofString":"inv H1.\nf_equal; eauto.\neapply eventval_match_determ_2; eauto."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall evl2 : list eventval, eventval_list_match evl2 tyl vl -> evl = evl2) (ev0 : eventval) (evl0 : list eventval) (H6 : eventval_match ev0 ty1 v1) (H8 : eventval_list_match evl0 tyl vl) : ev1 :: evl = ev0 :: evl0.","conclusion":"ev1 :: evl = ev0 :: evl0","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall evl2 : list eventval, eventval_list_match evl2 tyl vl -> evl = evl2) (ev0 : eventval) (evl0 : list eventval) (H6 : eventval_match ev0 ty1 v1) (H8 : eventval_list_match evl0 tyl vl)","proofString":"f_equal; eauto.\neapply eventval_match_determ_2; eauto."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall evl2 : list eventval, eventval_list_match evl2 tyl vl -> evl = evl2) (ev0 : eventval) (evl0 : list eventval) (H6 : eventval_match ev0 ty1 v1) (H8 : eventval_list_match evl0 tyl vl) : ev1 = ev0.","conclusion":"ev1 = ev0","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ev1 ty1 v1) (H0 : eventval_list_match evl tyl vl) (IHeventval_list_match : forall evl2 : list eventval, eventval_list_match evl2 tyl vl -> evl = evl2) (ev0 : eventval) (evl0 : list eventval) (H6 : eventval_match ev0 ty1 v1) (H8 : eventval_list_match evl0 tyl vl)","proofString":"eapply eventval_match_determ_2; eauto."},{"statement":"(ev1 : eventval) (ty : typ) (v1 : val) (ev2 : eventval) (H : eventval_match ev1 ty v1) (H0 : eventval_valid ev1) (H1 : eventval_valid ev2) (H2 : eventval_type ev1 = eventval_type ev2) : exists v2 : val, eventval_match ev2 ty v2.","conclusion":"exists v2 : val, eventval_match ev2 ty v2","hypotheses":"(ev1 : eventval) (ty : typ) (v1 : val) (ev2 : eventval) (H : eventval_match ev1 ty v1) (H0 : eventval_valid ev1) (H1 : eventval_valid ev2) (H2 : eventval_type ev1 = eventval_type ev2)","proofString":"unfold eventval_type, Tptr in H2.\nremember Archi.ptr64 as ptr64.\ninversion H; subst ev1 ty v1; clear H; destruct ev2; simpl in H2; inv H2.\nexists (Vint i0); constructor.\nsimpl in H1; exploit Senv.public_symbol_exists; eauto.\nintros [b FS].\nexists (Vptr b i1); rewrite H3.\nconstructor; auto.\nexists (Vlong i0); constructor.\nsimpl in H1; exploit Senv.public_symbol_exists; eauto.\nintros [b FS].\nexists (Vptr b i1); rewrite H3; constructor; auto.\nexists (Vfloat f0); constructor.\ndestruct Archi.ptr64; discriminate.\nexists (Vsingle f0); constructor; auto.\ndestruct Archi.ptr64; discriminate.\nexists (Vint i); unfold Tptr; rewrite H5; constructor.\nexists (Vlong i); unfold Tptr; rewrite H5; constructor.\ndestruct Archi.ptr64; discriminate.\ndestruct Archi.ptr64; discriminate.\nexploit Senv.public_symbol_exists.\neexact H1.\nintros [b' FS].\nexists (Vptr b' i0); constructor; auto."},{"statement":"(ev1 : eventval) (ty : typ) (v1 : val) (ev2 : eventval) (H : eventval_match ev1 ty v1) (H0 : eventval_valid ev1) (H1 : eventval_valid ev2) (H2 : match ev1 with\n| EVint _ => Tint\n| EVlong _ => Tlong\n| EVfloat _ => Tfloat\n| EVsingle _ => Tsingle\n| EVptr_global _ _ => if Archi.ptr64 then Tlong else Tint\nend =\nmatch ev2 with\n| EVint _ => Tint\n| EVlong _ => Tlong\n| EVfloat _ => Tfloat\n| EVsingle _ => Tsingle\n| EVptr_global _ _ => if Archi.ptr64 then Tlong else Tint\nend) : exists v2 : val, eventval_match ev2 ty v2.","conclusion":"exists v2 : val, eventval_match ev2 ty v2","hypotheses":"(ev1 : eventval) (ty : typ) (v1 : val) (ev2 : eventval) (H : eventval_match ev1 ty v1) (H0 : eventval_valid ev1) (H1 : eventval_valid ev2) (H2 : match ev1 with\n| EVint _ => Tint\n| EVlong _ => Tlong\n| EVfloat _ => Tfloat\n| EVsingle _ => Tsingle\n| EVptr_global _ _ => if Archi.ptr64 then Tlong else Tint\nend =\nmatch ev2 with\n| EVint _ => Tint\n| EVlong _ => Tlong\n| EVfloat _ => Tfloat\n| EVsingle _ => Tsingle\n| EVptr_global _ _ => if Archi.ptr64 then Tlong else Tint\nend)","proofString":"remember Archi.ptr64 as ptr64.\ninversion H; subst ev1 ty v1; clear H; destruct ev2; simpl in H2; inv H2.\nexists (Vint i0); constructor.\nsimpl in H1; exploit Senv.public_symbol_exists; eauto.\nintros [b FS].\nexists (Vptr b i1); rewrite H3.\nconstructor; auto.\nexists (Vlong i0); constructor.\nsimpl in H1; exploit Senv.public_symbol_exists; eauto.\nintros [b FS].\nexists (Vptr b i1); rewrite H3; constructor; auto.\nexists (Vfloat f0); constructor.\ndestruct Archi.ptr64; discriminate.\nexists (Vsingle f0); constructor; auto.\ndestruct Archi.ptr64; discriminate.\nexists (Vint i); unfold Tptr; rewrite H5; constructor.\nexists (Vlong i); unfold Tptr; rewrite H5; constructor.\ndestruct Archi.ptr64; discriminate.\ndestruct Archi.ptr64; discriminate.\nexploit Senv.public_symbol_exists.\neexact H1.\nintros [b' FS].\nexists (Vptr b' i0); constructor; auto."},{"statement":"(ev1 : eventval) (ty : typ) (v1 : val) (ev2 : eventval) (H : eventval_match ev1 ty v1) (H0 : eventval_valid ev1) (H1 : eventval_valid ev2) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (H2 : match ev1 with\n| EVint _ => Tint\n| EVlong _ => Tlong\n| EVfloat _ => Tfloat\n| EVsingle _ => Tsingle\n| EVptr_global _ _ => if ptr64 then Tlong else Tint\nend =\nmatch ev2 with\n| EVint _ => Tint\n| EVlong _ => Tlong\n| EVfloat _ => Tfloat\n| EVsingle _ => Tsingle\n| EVptr_global _ _ => if ptr64 then Tlong else Tint\nend) : exists v2 : val, eventval_match ev2 ty v2.","conclusion":"exists v2 : val, eventval_match ev2 ty v2","hypotheses":"(ev1 : eventval) (ty : typ) (v1 : val) (ev2 : eventval) (H : eventval_match ev1 ty v1) (H0 : eventval_valid ev1) (H1 : eventval_valid ev2) (ptr64 : bool) (Heqptr64 : ptr64 = Archi.ptr64) (H2 : match ev1 with\n| EVint _ => Tint\n| EVlong _ => Tlong\n| EVfloat _ => Tfloat\n| EVsingle _ => Tsingle\n| EVptr_global _ _ => if ptr64 then Tlong else Tint\nend =\nmatch ev2 with\n| EVint _ => Tint\n| EVlong _ => Tlong\n| EVfloat _ => Tfloat\n| EVsingle _ => Tsingle\n| EVptr_global _ _ => if ptr64 then Tlong else Tint\nend)","proofString":"inversion H; subst ev1 ty v1; clear H; destruct ev2; simpl in H2; inv H2.\nexists (Vint i0); constructor.\nsimpl in H1; exploit Senv.public_symbol_exists; eauto.\nintros [b FS].\nexists (Vptr b i1); rewrite H3.\nconstructor; auto.\nexists (Vlong i0); constructor.\nsimpl in H1; exploit Senv.public_symbol_exists; eauto.\nintros [b FS].\nexists (Vptr b i1); rewrite H3; constructor; auto.\nexists (Vfloat f0); constructor.\ndestruct Archi.ptr64; discriminate.\nexists (Vsingle f0); constructor; auto.\ndestruct Archi.ptr64; discriminate.\nexists (Vint i); unfold Tptr; rewrite H5; constructor.\nexists (Vlong i); unfold Tptr; rewrite H5; constructor.\ndestruct Archi.ptr64; discriminate.\ndestruct Archi.ptr64; discriminate.\nexploit Senv.public_symbol_exists.\neexact H1.\nintros [b' FS].\nexists (Vptr b' i0); constructor; auto."},{"statement":"(i0 i : int) (H0 : eventval_valid (EVint i)) (H1 : eventval_valid (EVint i0)) : exists v2 : val, eventval_match (EVint i0) Tint v2.","conclusion":"exists v2 : val, eventval_match (EVint i0) Tint v2","hypotheses":"(i0 i : int) (H0 : eventval_valid (EVint i)) (H1 : eventval_valid (EVint i0))","proofString":"exists (Vint i0); constructor."},{"statement":"(i0 : ident) (i1 : ptrofs) (i : int) (H0 : eventval_valid (EVint i)) (H1 : eventval_valid (EVptr_global i0 i1)) (H3 : Tint = (if Archi.ptr64 then Tlong else Tint)) : exists v2 : val, eventval_match (EVptr_global i0 i1) Tint v2.","conclusion":"exists v2 : val, eventval_match (EVptr_global i0 i1) Tint v2","hypotheses":"(i0 : ident) (i1 : ptrofs) (i : int) (H0 : eventval_valid (EVint i)) (H1 : eventval_valid (EVptr_global i0 i1)) (H3 : Tint = (if Archi.ptr64 then Tlong else Tint))","proofString":"simpl in H1; exploit Senv.public_symbol_exists; eauto.\nintros [b FS].\nexists (Vptr b i1); rewrite H3.\nconstructor; auto."},{"statement":"(i0 : ident) (i1 : ptrofs) (i : int) (H0 : eventval_valid (EVint i)) (H1 : Senv.public_symbol ge i0 = true) (H3 : Tint = (if Archi.ptr64 then Tlong else Tint)) : (exists b : block, Senv.find_symbol ge i0 = Some b) ->\nexists v2 : val, eventval_match (EVptr_global i0 i1) Tint v2.","conclusion":"(exists b : block, Senv.find_symbol ge i0 = Some b) ->\nexists v2 : val, eventval_match (EVptr_global i0 i1) Tint v2","hypotheses":"(i0 : ident) (i1 : ptrofs) (i : int) (H0 : eventval_valid (EVint i)) (H1 : Senv.public_symbol ge i0 = true) (H3 : Tint = (if Archi.ptr64 then Tlong else Tint))","proofString":"intros [b FS].\nexists (Vptr b i1); rewrite H3.\nconstructor; auto."},{"statement":"(i0 : ident) (i1 : ptrofs) (i : int) (H0 : eventval_valid (EVint i)) (H1 : Senv.public_symbol ge i0 = true) (H3 : Tint = (if Archi.ptr64 then Tlong else Tint)) (b : block) (FS : Senv.find_symbol ge i0 = Some b) : exists v2 : val, eventval_match (EVptr_global i0 i1) Tint v2.","conclusion":"exists v2 : val, eventval_match (EVptr_global i0 i1) Tint v2","hypotheses":"(i0 : ident) (i1 : ptrofs) (i : int) (H0 : eventval_valid (EVint i)) (H1 : Senv.public_symbol ge i0 = true) (H3 : Tint = (if Archi.ptr64 then Tlong else Tint)) (b : block) (FS : Senv.find_symbol ge i0 = Some b)","proofString":"exists (Vptr b i1); rewrite H3.\nconstructor; auto."},{"statement":"(i0 : ident) (i1 : ptrofs) (i : int) (H0 : eventval_valid (EVint i)) (H1 : Senv.public_symbol ge i0 = true) (H3 : Tint = (if Archi.ptr64 then Tlong else Tint)) (b : block) (FS : Senv.find_symbol ge i0 = Some b) : eventval_match (EVptr_global i0 i1) (if Archi.ptr64 then Tlong else Tint)\n  (Vptr b i1).","conclusion":"eventval_match (EVptr_global i0 i1) (if Archi.ptr64 then Tlong else Tint)\n  (Vptr b i1)","hypotheses":"(i0 : ident) (i1 : ptrofs) (i : int) (H0 : eventval_valid (EVint i)) (H1 : Senv.public_symbol ge i0 = true) (H3 : Tint = (if Archi.ptr64 then Tlong else Tint)) (b : block) (FS : Senv.find_symbol ge i0 = Some b)","proofString":"constructor; auto."},{"statement":"(i0 i : int64) (H0 : eventval_valid (EVlong i)) (H1 : eventval_valid (EVlong i0)) : exists v2 : val, eventval_match (EVlong i0) Tlong v2.","conclusion":"exists v2 : val, eventval_match (EVlong i0) Tlong v2","hypotheses":"(i0 i : int64) (H0 : eventval_valid (EVlong i)) (H1 : eventval_valid (EVlong i0))","proofString":"exists (Vlong i0); constructor."},{"statement":"(i0 : ident) (i1 : ptrofs) (i : int64) (H0 : eventval_valid (EVlong i)) (H1 : eventval_valid (EVptr_global i0 i1)) (H3 : Tlong = (if Archi.ptr64 then Tlong else Tint)) : exists v2 : val, eventval_match (EVptr_global i0 i1) Tlong v2.","conclusion":"exists v2 : val, eventval_match (EVptr_global i0 i1) Tlong v2","hypotheses":"(i0 : ident) (i1 : ptrofs) (i : int64) (H0 : eventval_valid (EVlong i)) (H1 : eventval_valid (EVptr_global i0 i1)) (H3 : Tlong = (if Archi.ptr64 then Tlong else Tint))","proofString":"simpl in H1; exploit Senv.public_symbol_exists; eauto.\nintros [b FS].\nexists (Vptr b i1); rewrite H3; constructor; auto."},{"statement":"(i0 : ident) (i1 : ptrofs) (i : int64) (H0 : eventval_valid (EVlong i)) (H1 : Senv.public_symbol ge i0 = true) (H3 : Tlong = (if Archi.ptr64 then Tlong else Tint)) : (exists b : block, Senv.find_symbol ge i0 = Some b) ->\nexists v2 : val, eventval_match (EVptr_global i0 i1) Tlong v2.","conclusion":"(exists b : block, Senv.find_symbol ge i0 = Some b) ->\nexists v2 : val, eventval_match (EVptr_global i0 i1) Tlong v2","hypotheses":"(i0 : ident) (i1 : ptrofs) (i : int64) (H0 : eventval_valid (EVlong i)) (H1 : Senv.public_symbol ge i0 = true) (H3 : Tlong = (if Archi.ptr64 then Tlong else Tint))","proofString":"intros [b FS].\nexists (Vptr b i1); rewrite H3; constructor; auto."},{"statement":"(i0 : ident) (i1 : ptrofs) (i : int64) (H0 : eventval_valid (EVlong i)) (H1 : Senv.public_symbol ge i0 = true) (H3 : Tlong = (if Archi.ptr64 then Tlong else Tint)) (b : block) (FS : Senv.find_symbol ge i0 = Some b) : exists v2 : val, eventval_match (EVptr_global i0 i1) Tlong v2.","conclusion":"exists v2 : val, eventval_match (EVptr_global i0 i1) Tlong v2","hypotheses":"(i0 : ident) (i1 : ptrofs) (i : int64) (H0 : eventval_valid (EVlong i)) (H1 : Senv.public_symbol ge i0 = true) (H3 : Tlong = (if Archi.ptr64 then Tlong else Tint)) (b : block) (FS : Senv.find_symbol ge i0 = Some b)","proofString":"exists (Vptr b i1); rewrite H3; constructor; auto."},{"statement":"(f0 f : float) (H0 : eventval_valid (EVfloat f)) (H1 : eventval_valid (EVfloat f0)) : exists v2 : val, eventval_match (EVfloat f0) Tfloat v2.","conclusion":"exists v2 : val, eventval_match (EVfloat f0) Tfloat v2","hypotheses":"(f0 f : float) (H0 : eventval_valid (EVfloat f)) (H1 : eventval_valid (EVfloat f0))","proofString":"exists (Vfloat f0); constructor."},{"statement":"(i : ident) (i0 : ptrofs) (f : float) (H0 : eventval_valid (EVfloat f)) (H1 : eventval_valid (EVptr_global i i0)) (H3 : Tfloat = (if Archi.ptr64 then Tlong else Tint)) : exists v2 : val, eventval_match (EVptr_global i i0) Tfloat v2.","conclusion":"exists v2 : val, eventval_match (EVptr_global i i0) Tfloat v2","hypotheses":"(i : ident) (i0 : ptrofs) (f : float) (H0 : eventval_valid (EVfloat f)) (H1 : eventval_valid (EVptr_global i i0)) (H3 : Tfloat = (if Archi.ptr64 then Tlong else Tint))","proofString":"destruct Archi.ptr64; discriminate."},{"statement":"(f0 f : float32) (H0 : eventval_valid (EVsingle f)) (H1 : eventval_valid (EVsingle f0)) : exists v2 : val, eventval_match (EVsingle f0) Tsingle v2.","conclusion":"exists v2 : val, eventval_match (EVsingle f0) Tsingle v2","hypotheses":"(f0 f : float32) (H0 : eventval_valid (EVsingle f)) (H1 : eventval_valid (EVsingle f0))","proofString":"exists (Vsingle f0); constructor; auto."},{"statement":"(i : ident) (i0 : ptrofs) (f : float32) (H0 : eventval_valid (EVsingle f)) (H1 : eventval_valid (EVptr_global i i0)) (H3 : Tsingle = (if Archi.ptr64 then Tlong else Tint)) : exists v2 : val, eventval_match (EVptr_global i i0) Tsingle v2.","conclusion":"exists v2 : val, eventval_match (EVptr_global i i0) Tsingle v2","hypotheses":"(i : ident) (i0 : ptrofs) (f : float32) (H0 : eventval_valid (EVsingle f)) (H1 : eventval_valid (EVptr_global i i0)) (H3 : Tsingle = (if Archi.ptr64 then Tlong else Tint))","proofString":"destruct Archi.ptr64; discriminate."},{"statement":"(i : int) (id : ident) (ofs : ptrofs) (H0 : eventval_valid (EVptr_global id ofs)) (b : block) (H1 : eventval_valid (EVint i)) (H3 : Senv.public_symbol ge id = true) (H4 : Senv.find_symbol ge id = Some b) (H5 : (if Archi.ptr64 then Tlong else Tint) = Tint) : exists v2 : val, eventval_match (EVint i) Tptr v2.","conclusion":"exists v2 : val, eventval_match (EVint i) Tptr v2","hypotheses":"(i : int) (id : ident) (ofs : ptrofs) (H0 : eventval_valid (EVptr_global id ofs)) (b : block) (H1 : eventval_valid (EVint i)) (H3 : Senv.public_symbol ge id = true) (H4 : Senv.find_symbol ge id = Some b) (H5 : (if Archi.ptr64 then Tlong else Tint) = Tint)","proofString":"exists (Vint i); unfold Tptr; rewrite H5; constructor."},{"statement":"(i : int64) (id : ident) (ofs : ptrofs) (H0 : eventval_valid (EVptr_global id ofs)) (b : block) (H1 : eventval_valid (EVlong i)) (H3 : Senv.public_symbol ge id = true) (H4 : Senv.find_symbol ge id = Some b) (H5 : (if Archi.ptr64 then Tlong else Tint) = Tlong) : exists v2 : val, eventval_match (EVlong i) Tptr v2.","conclusion":"exists v2 : val, eventval_match (EVlong i) Tptr v2","hypotheses":"(i : int64) (id : ident) (ofs : ptrofs) (H0 : eventval_valid (EVptr_global id ofs)) (b : block) (H1 : eventval_valid (EVlong i)) (H3 : Senv.public_symbol ge id = true) (H4 : Senv.find_symbol ge id = Some b) (H5 : (if Archi.ptr64 then Tlong else Tint) = Tlong)","proofString":"exists (Vlong i); unfold Tptr; rewrite H5; constructor."},{"statement":"(f : float) (id : ident) (ofs : ptrofs) (H0 : eventval_valid (EVptr_global id ofs)) (b : block) (H1 : eventval_valid (EVfloat f)) (H3 : Senv.public_symbol ge id = true) (H4 : Senv.find_symbol ge id = Some b) (H5 : (if Archi.ptr64 then Tlong else Tint) = Tfloat) : exists v2 : val, eventval_match (EVfloat f) Tptr v2.","conclusion":"exists v2 : val, eventval_match (EVfloat f) Tptr v2","hypotheses":"(f : float) (id : ident) (ofs : ptrofs) (H0 : eventval_valid (EVptr_global id ofs)) (b : block) (H1 : eventval_valid (EVfloat f)) (H3 : Senv.public_symbol ge id = true) (H4 : Senv.find_symbol ge id = Some b) (H5 : (if Archi.ptr64 then Tlong else Tint) = Tfloat)","proofString":"destruct Archi.ptr64; discriminate."},{"statement":"(f : float32) (id : ident) (ofs : ptrofs) (H0 : eventval_valid (EVptr_global id ofs)) (b : block) (H1 : eventval_valid (EVsingle f)) (H3 : Senv.public_symbol ge id = true) (H4 : Senv.find_symbol ge id = Some b) (H5 : (if Archi.ptr64 then Tlong else Tint) = Tsingle) : exists v2 : val, eventval_match (EVsingle f) Tptr v2.","conclusion":"exists v2 : val, eventval_match (EVsingle f) Tptr v2","hypotheses":"(f : float32) (id : ident) (ofs : ptrofs) (H0 : eventval_valid (EVptr_global id ofs)) (b : block) (H1 : eventval_valid (EVsingle f)) (H3 : Senv.public_symbol ge id = true) (H4 : Senv.find_symbol ge id = Some b) (H5 : (if Archi.ptr64 then Tlong else Tint) = Tsingle)","proofString":"destruct Archi.ptr64; discriminate."},{"statement":"(i : ident) (i0 : ptrofs) (id : ident) (ofs : ptrofs) (H0 : eventval_valid (EVptr_global id ofs)) (b : block) (H1 : eventval_valid (EVptr_global i i0)) (H3 : Senv.public_symbol ge id = true) (H4 : Senv.find_symbol ge id = Some b) : exists v2 : val, eventval_match (EVptr_global i i0) Tptr v2.","conclusion":"exists v2 : val, eventval_match (EVptr_global i i0) Tptr v2","hypotheses":"(i : ident) (i0 : ptrofs) (id : ident) (ofs : ptrofs) (H0 : eventval_valid (EVptr_global id ofs)) (b : block) (H1 : eventval_valid (EVptr_global i i0)) (H3 : Senv.public_symbol ge id = true) (H4 : Senv.find_symbol ge id = Some b)","proofString":"exploit Senv.public_symbol_exists.\neexact H1.\nintros [b' FS].\nexists (Vptr b' i0); constructor; auto."},{"statement":"(i : ident) (i0 : ptrofs) (id : ident) (ofs : ptrofs) (H0 : eventval_valid (EVptr_global id ofs)) (b : block) (H1 : eventval_valid (EVptr_global i i0)) (H3 : Senv.public_symbol ge id = true) (H4 : Senv.find_symbol ge id = Some b) (b' : block) (FS : Senv.find_symbol ge i = Some b') : exists v2 : val, eventval_match (EVptr_global i i0) Tptr v2.","conclusion":"exists v2 : val, eventval_match (EVptr_global i i0) Tptr v2","hypotheses":"(i : ident) (i0 : ptrofs) (id : ident) (ofs : ptrofs) (H0 : eventval_valid (EVptr_global id ofs)) (b : block) (H1 : eventval_valid (EVptr_global i i0)) (H3 : Senv.public_symbol ge id = true) (H4 : Senv.find_symbol ge id = Some b) (b' : block) (FS : Senv.find_symbol ge i = Some b')","proofString":"exists (Vptr b' i0); constructor; auto."},{"statement":"(ev : eventval) (H : eventval_valid ge1 ev) : eventval_valid ge2 ev.","conclusion":"eventval_valid ge2 ev","hypotheses":"(ev : eventval) (H : eventval_valid ge1 ev)","proofString":"destruct ev; simpl in *; auto.\nrewrite <- H; auto."},{"statement":"(i : ident) (i0 : ptrofs) (H : Senv.public_symbol ge1 i = true) : Senv.public_symbol ge2 i = true.","conclusion":"Senv.public_symbol ge2 i = true","hypotheses":"(i : ident) (i0 : ptrofs) (H : Senv.public_symbol ge1 i = true)","proofString":"rewrite <- H; auto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H : Senv.public_symbol ge1 id = true) (H0 : Senv.find_symbol ge1 id = Some b) : Senv.public_symbol ge2 id = true.","conclusion":"Senv.public_symbol ge2 id = true","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H : Senv.public_symbol ge1 id = true) (H0 : Senv.find_symbol ge1 id = Some b)","proofString":"rewrite public_preserved; auto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H : Senv.public_symbol ge1 id = true) (H0 : Senv.find_symbol ge1 id = Some b) : Senv.find_symbol ge2 id = Some b.","conclusion":"Senv.find_symbol ge2 id = Some b","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H : Senv.public_symbol ge1 id = true) (H0 : Senv.find_symbol ge1 id = Some b)","proofString":"rewrite symbols_preserved; auto."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge1 ev1 ty1 v1) (H0 : eventval_list_match ge1 evl tyl vl) (IHeventval_list_match : eventval_list_match ge2 evl tyl vl) : eventval_match ge2 ev1 ty1 v1.","conclusion":"eventval_match ge2 ev1 ty1 v1","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge1 ev1 ty1 v1) (H0 : eventval_list_match ge1 evl tyl vl) (IHeventval_list_match : eventval_list_match ge2 evl tyl vl)","proofString":"eapply eventval_match_preserved; eauto."},{"statement":"(ev : eventval) (ty : typ) (v1 v2 : val) (H : eventval_match ge1 ev ty v1) (H0 : Val.inject f v1 v2) : eventval_match ge2 ev ty v2.","conclusion":"eventval_match ge2 ev ty v2","hypotheses":"(ev : eventval) (ty : typ) (v1 v2 : val) (H : eventval_match ge1 ev ty v1) (H0 : Val.inject f v1 v2)","proofString":"inv H; inv H0; try constructor; auto.\ndestruct symb_inj as (A & B & C & D).\nexploit C; eauto.\nintros [b3 [EQ FS]].\nrewrite H4 in EQ; inv EQ.\nrewrite Ptrofs.add_zero.\nconstructor; auto.\nrewrite A; auto."},{"statement":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b2 : block) (delta : Z) (H4 : f b = Some (b2, delta)) : eventval_match ge2 (EVptr_global id ofs) Tptr\n  (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta))).","conclusion":"eventval_match ge2 (EVptr_global id ofs) Tptr\n  (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))","hypotheses":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b2 : block) (delta : Z) (H4 : f b = Some (b2, delta))","proofString":"destruct symb_inj as (A & B & C & D).\nexploit C; eauto.\nintros [b3 [EQ FS]].\nrewrite H4 in EQ; inv EQ.\nrewrite Ptrofs.add_zero.\nconstructor; auto.\nrewrite A; auto."},{"statement":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b2 : block) (delta : Z) (H4 : f b = Some (b2, delta)) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta0 : Z),\nf b1 = Some (b0, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta0 : Z),\nf b1 = Some (b0, delta0) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1) : eventval_match ge2 (EVptr_global id ofs) Tptr\n  (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta))).","conclusion":"eventval_match ge2 (EVptr_global id ofs) Tptr\n  (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))","hypotheses":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b2 : block) (delta : Z) (H4 : f b = Some (b2, delta)) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta0 : Z),\nf b1 = Some (b0, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta0 : Z),\nf b1 = Some (b0, delta0) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1)","proofString":"exploit C; eauto.\nintros [b3 [EQ FS]].\nrewrite H4 in EQ; inv EQ.\nrewrite Ptrofs.add_zero.\nconstructor; auto.\nrewrite A; auto."},{"statement":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b2 : block) (delta : Z) (H4 : f b = Some (b2, delta)) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta0 : Z),\nf b1 = Some (b0, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta0 : Z),\nf b1 = Some (b0, delta0) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1) : (exists b3 : block, f b = Some (b3, 0) /\\ Senv.find_symbol ge2 id = Some b3) ->\neventval_match ge2 (EVptr_global id ofs) Tptr\n  (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta))).","conclusion":"(exists b3 : block, f b = Some (b3, 0) /\\ Senv.find_symbol ge2 id = Some b3) ->\neventval_match ge2 (EVptr_global id ofs) Tptr\n  (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))","hypotheses":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b2 : block) (delta : Z) (H4 : f b = Some (b2, delta)) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta0 : Z),\nf b1 = Some (b0, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta0 : Z),\nf b1 = Some (b0, delta0) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1)","proofString":"intros [b3 [EQ FS]].\nrewrite H4 in EQ; inv EQ.\nrewrite Ptrofs.add_zero.\nconstructor; auto.\nrewrite A; auto."},{"statement":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b2 : block) (delta : Z) (H4 : f b = Some (b2, delta)) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta0 : Z),\nf b1 = Some (b0, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta0 : Z),\nf b1 = Some (b0, delta0) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1) (b3 : block) (EQ : f b = Some (b3, 0)) (FS : Senv.find_symbol ge2 id = Some b3) : eventval_match ge2 (EVptr_global id ofs) Tptr\n  (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta))).","conclusion":"eventval_match ge2 (EVptr_global id ofs) Tptr\n  (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))","hypotheses":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b2 : block) (delta : Z) (H4 : f b = Some (b2, delta)) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta0 : Z),\nf b1 = Some (b0, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta0 : Z),\nf b1 = Some (b0, delta0) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1) (b3 : block) (EQ : f b = Some (b3, 0)) (FS : Senv.find_symbol ge2 id = Some b3)","proofString":"rewrite H4 in EQ; inv EQ.\nrewrite Ptrofs.add_zero.\nconstructor; auto.\nrewrite A; auto."},{"statement":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b3 : block) (H4 : f b = Some (b3, 0)) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (FS : Senv.find_symbol ge2 id = Some b3) : eventval_match ge2 (EVptr_global id ofs) Tptr\n  (Vptr b3 (Ptrofs.add ofs (Ptrofs.repr 0))).","conclusion":"eventval_match ge2 (EVptr_global id ofs) Tptr\n  (Vptr b3 (Ptrofs.add ofs (Ptrofs.repr 0)))","hypotheses":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b3 : block) (H4 : f b = Some (b3, 0)) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (FS : Senv.find_symbol ge2 id = Some b3)","proofString":"rewrite Ptrofs.add_zero.\nconstructor; auto.\nrewrite A; auto."},{"statement":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b3 : block) (H4 : f b = Some (b3, 0)) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (FS : Senv.find_symbol ge2 id = Some b3) : eventval_match ge2 (EVptr_global id ofs) Tptr (Vptr b3 ofs).","conclusion":"eventval_match ge2 (EVptr_global id ofs) Tptr (Vptr b3 ofs)","hypotheses":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b3 : block) (H4 : f b = Some (b3, 0)) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (FS : Senv.find_symbol ge2 id = Some b3)","proofString":"constructor; auto.\nrewrite A; auto."},{"statement":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b3 : block) (H4 : f b = Some (b3, 0)) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (FS : Senv.find_symbol ge2 id = Some b3) : Senv.public_symbol ge2 id = true.","conclusion":"Senv.public_symbol ge2 id = true","hypotheses":"(b : block) (ofs : ptrofs) (id : ident) (H1 : Senv.public_symbol ge1 id = true) (H2 : Senv.find_symbol ge1 id = Some b) (b3 : block) (H4 : f b = Some (b3, 0)) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (FS : Senv.find_symbol ge2 id = Some b3)","proofString":"rewrite A; auto."},{"statement":"(ev : eventval) (ty : typ) (v1 : val) (H : eventval_match ge1 ev ty v1) : exists v2 : val, eventval_match ge2 ev ty v2 /\\ Val.inject f v1 v2.","conclusion":"exists v2 : val, eventval_match ge2 ev ty v2 /\\ Val.inject f v1 v2","hypotheses":"(ev : eventval) (ty : typ) (v1 : val) (H : eventval_match ge1 ev ty v1)","proofString":"inv H; try (econstructor; split; eauto; constructor; fail).\ndestruct symb_inj as (A & B & C & D).\nexploit C; eauto.\nintros [b2 [EQ FS]].\nexists (Vptr b2 ofs); split.\neconstructor; eauto.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b) : exists v2 : val,\n  eventval_match ge2 (EVptr_global id ofs) Tptr v2 /\\\n  Val.inject f (Vptr b ofs) v2.","conclusion":"exists v2 : val,\n  eventval_match ge2 (EVptr_global id ofs) Tptr v2 /\\\n  Val.inject f (Vptr b ofs) v2","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b)","proofString":"destruct symb_inj as (A & B & C & D).\nexploit C; eauto.\nintros [b2 [EQ FS]].\nexists (Vptr b2 ofs); split.\neconstructor; eauto.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) : exists v2 : val,\n  eventval_match ge2 (EVptr_global id ofs) Tptr v2 /\\\n  Val.inject f (Vptr b ofs) v2.","conclusion":"exists v2 : val,\n  eventval_match ge2 (EVptr_global id ofs) Tptr v2 /\\\n  Val.inject f (Vptr b ofs) v2","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1)","proofString":"exploit C; eauto.\nintros [b2 [EQ FS]].\nexists (Vptr b2 ofs); split.\neconstructor; eauto.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) : (exists b2 : block, f b = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) ->\nexists v2 : val,\n  eventval_match ge2 (EVptr_global id ofs) Tptr v2 /\\\n  Val.inject f (Vptr b ofs) v2.","conclusion":"(exists b2 : block, f b = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) ->\nexists v2 : val,\n  eventval_match ge2 (EVptr_global id ofs) Tptr v2 /\\\n  Val.inject f (Vptr b ofs) v2","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1)","proofString":"intros [b2 [EQ FS]].\nexists (Vptr b2 ofs); split.\neconstructor; eauto.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1) (b2 : block) (EQ : f b = Some (b2, 0)) (FS : Senv.find_symbol ge2 id = Some b2) : exists v2 : val,\n  eventval_match ge2 (EVptr_global id ofs) Tptr v2 /\\\n  Val.inject f (Vptr b ofs) v2.","conclusion":"exists v2 : val,\n  eventval_match ge2 (EVptr_global id ofs) Tptr v2 /\\\n  Val.inject f (Vptr b ofs) v2","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1) (b2 : block) (EQ : f b = Some (b2, 0)) (FS : Senv.find_symbol ge2 id = Some b2)","proofString":"exists (Vptr b2 ofs); split.\neconstructor; eauto.\neconstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1) (b2 : block) (EQ : f b = Some (b2, 0)) (FS : Senv.find_symbol ge2 id = Some b2) : eventval_match ge2 (EVptr_global id ofs) Tptr (Vptr b2 ofs).","conclusion":"eventval_match ge2 (EVptr_global id ofs) Tptr (Vptr b2 ofs)","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1) (b2 : block) (EQ : f b = Some (b2, 0)) (FS : Senv.find_symbol ge2 id = Some b2)","proofString":"econstructor; eauto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1) (b2 : block) (EQ : f b = Some (b2, 0)) (FS : Senv.find_symbol ge2 id = Some b2) : Val.inject f (Vptr b ofs) (Vptr b2 ofs).","conclusion":"Val.inject f (Vptr b ofs) (Vptr b2 ofs)","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1) (b2 : block) (EQ : f b = Some (b2, 0)) (FS : Senv.find_symbol ge2 id = Some b2)","proofString":"econstructor; eauto.\nrewrite Ptrofs.add_zero; auto."},{"statement":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1) (b2 : block) (EQ : f b = Some (b2, 0)) (FS : Senv.find_symbol ge2 id = Some b2) : ofs = Ptrofs.add ofs (Ptrofs.repr 0).","conclusion":"ofs = Ptrofs.add ofs (Ptrofs.repr 0)","hypotheses":"(id : ident) (b : block) (ofs : ptrofs) (H0 : Senv.public_symbol ge1 id = true) (H1 : Senv.find_symbol ge1 id = Some b) (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b0) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b0 : block, f b1 = Some (b0, 0) /\\ Senv.find_symbol ge2 id0 = Some b0) (D : forall (b1 b0 : block) (delta : Z),\nf b1 = Some (b0, delta) ->\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b1) (b2 : block) (EQ : f b = Some (b2, 0)) (FS : Senv.find_symbol ge2 id = Some b2)","proofString":"rewrite Ptrofs.add_zero; auto."},{"statement":"(vl2 : list val) (H : Val.inject_list f nil vl2) : eventval_list_match ge2 nil nil vl2.","conclusion":"eventval_list_match ge2 nil nil vl2","hypotheses":"(vl2 : list val) (H : Val.inject_list f nil vl2)","proofString":"inv H; constructor."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge1 ev1 ty1 v1) (H0 : eventval_list_match ge1 evl tyl vl) (IHeventval_list_match : forall vl0 : list val,\nVal.inject_list f vl vl0 -> eventval_list_match ge2 evl tyl vl0) (vl2 : list val) (H1 : Val.inject_list f (v1 :: vl) vl2) : eventval_list_match ge2 (ev1 :: evl) (ty1 :: tyl) vl2.","conclusion":"eventval_list_match ge2 (ev1 :: evl) (ty1 :: tyl) vl2","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge1 ev1 ty1 v1) (H0 : eventval_list_match ge1 evl tyl vl) (IHeventval_list_match : forall vl0 : list val,\nVal.inject_list f vl vl0 -> eventval_list_match ge2 evl tyl vl0) (vl2 : list val) (H1 : Val.inject_list f (v1 :: vl) vl2)","proofString":"inv H1.\nconstructor.\neapply eventval_match_inject; eauto.\neauto."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge1 ev1 ty1 v1) (H0 : eventval_list_match ge1 evl tyl vl) (IHeventval_list_match : forall vl2 : list val,\nVal.inject_list f vl vl2 -> eventval_list_match ge2 evl tyl vl2) (v' : val) (vl' : list val) (H4 : Val.inject f v1 v') (H6 : Val.inject_list f vl vl') : eventval_list_match ge2 (ev1 :: evl) (ty1 :: tyl) (v' :: vl').","conclusion":"eventval_list_match ge2 (ev1 :: evl) (ty1 :: tyl) (v' :: vl')","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge1 ev1 ty1 v1) (H0 : eventval_list_match ge1 evl tyl vl) (IHeventval_list_match : forall vl2 : list val,\nVal.inject_list f vl vl2 -> eventval_list_match ge2 evl tyl vl2) (v' : val) (vl' : list val) (H4 : Val.inject f v1 v') (H6 : Val.inject_list f vl vl')","proofString":"constructor.\neapply eventval_match_inject; eauto.\neauto."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge1 ev1 ty1 v1) (H0 : eventval_list_match ge1 evl tyl vl) (IHeventval_list_match : forall vl2 : list val,\nVal.inject_list f vl vl2 -> eventval_list_match ge2 evl tyl vl2) (v' : val) (vl' : list val) (H4 : Val.inject f v1 v') (H6 : Val.inject_list f vl vl') : eventval_match ge2 ev1 ty1 v'.","conclusion":"eventval_match ge2 ev1 ty1 v'","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge1 ev1 ty1 v1) (H0 : eventval_list_match ge1 evl tyl vl) (IHeventval_list_match : forall vl2 : list val,\nVal.inject_list f vl vl2 -> eventval_list_match ge2 evl tyl vl2) (v' : val) (vl' : list val) (H4 : Val.inject f v1 v') (H6 : Val.inject_list f vl vl')","proofString":"eapply eventval_match_inject; eauto."},{"statement":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge1 ev1 ty1 v1) (H0 : eventval_list_match ge1 evl tyl vl) (IHeventval_list_match : forall vl2 : list val,\nVal.inject_list f vl vl2 -> eventval_list_match ge2 evl tyl vl2) (v' : val) (vl' : list val) (H4 : Val.inject f v1 v') (H6 : Val.inject_list f vl vl') : eventval_list_match ge2 evl tyl vl'.","conclusion":"eventval_list_match ge2 evl tyl vl'","hypotheses":"(ev1 : eventval) (evl : list eventval) (ty1 : typ) (tyl : list typ) (v1 : val) (vl : list val) (H : eventval_match ge1 ev1 ty1 v1) (H0 : eventval_list_match ge1 evl tyl vl) (IHeventval_list_match : forall vl2 : list val,\nVal.inject_list f vl vl2 -> eventval_list_match ge2 evl tyl vl2) (v' : val) (vl' : list val) (H4 : Val.inject f v1 v') (H6 : Val.inject_list f vl vl')","proofString":"eauto."},{"statement":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (H : Senv.equiv ge1 ge2) (H0 : volatile_load ge1 chunk m b ofs t v) : volatile_load ge2 chunk m b ofs t v.","conclusion":"volatile_load ge2 chunk m b ofs t v","hypotheses":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (H : Senv.equiv ge1 ge2) (H0 : volatile_load ge1 chunk m b ofs t v)","proofString":"destruct H as (A & B & C).\ninv H0; constructor; auto.\nrewrite C; auto.\nrewrite A; auto.\neapply eventval_match_preserved; eauto.\nrewrite C; auto."},{"statement":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (H0 : volatile_load ge1 chunk m b ofs t v) : volatile_load ge2 chunk m b ofs t v.","conclusion":"volatile_load ge2 chunk m b ofs t v","hypotheses":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (H0 : volatile_load ge1 chunk m b ofs t v)","proofString":"inv H0; constructor; auto.\nrewrite C; auto.\nrewrite A; auto.\neapply eventval_match_preserved; eauto.\nrewrite C; auto."},{"statement":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (A : forall id0 : ident, Senv.find_symbol ge2 id0 = Senv.find_symbol ge1 id0) (B : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H1 : Senv.find_symbol ge1 id = Some b) (H2 : eventval_match ge1 ev (type_of_chunk chunk) v0) : Senv.block_is_volatile ge2 b = true.","conclusion":"Senv.block_is_volatile ge2 b = true","hypotheses":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (A : forall id0 : ident, Senv.find_symbol ge2 id0 = Senv.find_symbol ge1 id0) (B : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H1 : Senv.find_symbol ge1 id = Some b) (H2 : eventval_match ge1 ev (type_of_chunk chunk) v0)","proofString":"rewrite C; auto."},{"statement":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (A : forall id0 : ident, Senv.find_symbol ge2 id0 = Senv.find_symbol ge1 id0) (B : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H1 : Senv.find_symbol ge1 id = Some b) (H2 : eventval_match ge1 ev (type_of_chunk chunk) v0) : Senv.find_symbol ge2 id = Some b.","conclusion":"Senv.find_symbol ge2 id = Some b","hypotheses":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (A : forall id0 : ident, Senv.find_symbol ge2 id0 = Senv.find_symbol ge1 id0) (B : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H1 : Senv.find_symbol ge1 id = Some b) (H2 : eventval_match ge1 ev (type_of_chunk chunk) v0)","proofString":"rewrite A; auto."},{"statement":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (A : forall id0 : ident, Senv.find_symbol ge2 id0 = Senv.find_symbol ge1 id0) (B : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H1 : Senv.find_symbol ge1 id = Some b) (H2 : eventval_match ge1 ev (type_of_chunk chunk) v0) : eventval_match ge2 ev (type_of_chunk chunk) v0.","conclusion":"eventval_match ge2 ev (type_of_chunk chunk) v0","hypotheses":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (A : forall id0 : ident, Senv.find_symbol ge2 id0 = Senv.find_symbol ge1 id0) (B : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H1 : Senv.find_symbol ge1 id = Some b) (H2 : eventval_match ge1 ev (type_of_chunk chunk) v0)","proofString":"eapply eventval_match_preserved; eauto."},{"statement":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (H : Senv.block_is_volatile ge1 b = false) (H1 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : Senv.block_is_volatile ge2 b = false.","conclusion":"Senv.block_is_volatile ge2 b = false","hypotheses":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (H : Senv.block_is_volatile ge1 b = false) (H1 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"rewrite C; auto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (m' : mem) (H : volatile_load ge chunk m b ofs t v) (H0 : Mem.extends m m') : exists v' : val, volatile_load ge chunk m' b ofs t v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, volatile_load ge chunk m' b ofs t v' /\\ Val.lessdef v v'","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (m' : mem) (H : volatile_load ge chunk m b ofs t v) (H0 : Mem.extends m m')","proofString":"inv H.\neconstructor; split; eauto.\neconstructor; eauto.\nexploit Mem.load_extends; eauto.\nintros [v' [A B]].\nexists v'; split; auto.\nconstructor; auto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H0 : Mem.extends m m') (id : ident) (ev : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H2 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) : exists v' : val,\n  volatile_load ge chunk m' b ofs (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.lessdef (Val.load_result chunk v0) v'.","conclusion":"exists v' : val,\n  volatile_load ge chunk m' b ofs (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.lessdef (Val.load_result chunk v0) v'","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H0 : Mem.extends m m') (id : ident) (ev : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H2 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0)","proofString":"econstructor; split; eauto.\neconstructor; eauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H0 : Mem.extends m m') (id : ident) (ev : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H2 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0) : volatile_load ge chunk m' b ofs (Event_vload chunk id ofs ev :: nil)\n  (Val.load_result chunk v0).","conclusion":"volatile_load ge chunk m' b ofs (Event_vload chunk id ofs ev :: nil)\n  (Val.load_result chunk v0)","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (m' : mem) (H0 : Mem.extends m m') (id : ident) (ev : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H2 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v0)","proofString":"econstructor; eauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (H0 : Mem.extends m m') (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : exists v' : val, volatile_load ge chunk m' b ofs E0 v' /\\ Val.lessdef v v'.","conclusion":"exists v' : val, volatile_load ge chunk m' b ofs E0 v' /\\ Val.lessdef v v'","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (H0 : Mem.extends m m') (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"exploit Mem.load_extends; eauto.\nintros [v' [A B]].\nexists v'; split; auto.\nconstructor; auto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (H0 : Mem.extends m m') (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : (exists v2 : val,\n   Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v2 /\\ Val.lessdef v v2) ->\nexists v' : val, volatile_load ge chunk m' b ofs E0 v' /\\ Val.lessdef v v'.","conclusion":"(exists v2 : val,\n   Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v2 /\\ Val.lessdef v v2) ->\nexists v' : val, volatile_load ge chunk m' b ofs E0 v' /\\ Val.lessdef v v'","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (H0 : Mem.extends m m') (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"intros [v' [A B]].\nexists v'; split; auto.\nconstructor; auto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (H0 : Mem.extends m m') (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (v' : val) (A : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v') (B : Val.lessdef v v') : exists v'0 : val, volatile_load ge chunk m' b ofs E0 v'0 /\\ Val.lessdef v v'0.","conclusion":"exists v'0 : val, volatile_load ge chunk m' b ofs E0 v'0 /\\ Val.lessdef v v'0","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (H0 : Mem.extends m m') (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (v' : val) (A : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v') (B : Val.lessdef v v')","proofString":"exists v'; split; auto.\nconstructor; auto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (H0 : Mem.extends m m') (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (v' : val) (A : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v') (B : Val.lessdef v v') : volatile_load ge chunk m' b ofs E0 v'.","conclusion":"volatile_load ge chunk m' b ofs E0 v'","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (m' : mem) (H0 : Mem.extends m m') (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (v' : val) (A : Mem.load chunk m' b (Ptrofs.unsigned ofs) = Some v') (B : Val.lessdef v v')","proofString":"constructor; auto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VL : volatile_load ge1 chunk m b ofs t v) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m') : exists v' : val, volatile_load ge2 chunk m' b' ofs' t v' /\\ Val.inject f v v'.","conclusion":"exists v' : val, volatile_load ge2 chunk m' b' ofs' t v' /\\ Val.inject f v v'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VL : volatile_load ge1 chunk m b ofs t v) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m')","proofString":"generalize SI; intros (A & B & C & D).\ninv VL.\ninv VI.\nexploit B; eauto.\nintros [U V].\nsubst delta.\nexploit eventval_match_inject_2; eauto.\nintros (v2 & X & Y).\nrewrite Ptrofs.add_zero.\nexists (Val.load_result chunk v2); split.\nconstructor; auto.\nerewrite D; eauto.\napply Val.load_result_inject.\nauto.\nexploit Mem.loadv_inject; eauto.\nsimpl; eauto.\nsimpl; intros (v2 & X & Y).\nexists v2; split; auto.\nconstructor; auto.\ninv VI.\nerewrite D; eauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VL : volatile_load ge1 chunk m b ofs t v) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m') (A : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (B : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (C : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) : exists v' : val, volatile_load ge2 chunk m' b' ofs' t v' /\\ Val.inject f v v'.","conclusion":"exists v' : val, volatile_load ge2 chunk m' b' ofs' t v' /\\ Val.inject f v v'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (t : trace) (v : val) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VL : volatile_load ge1 chunk m b ofs t v) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m') (A : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (B : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (C : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1)","proofString":"inv VL.\ninv VI.\nexploit B; eauto.\nintros [U V].\nsubst delta.\nexploit eventval_match_inject_2; eauto.\nintros (v2 & X & Y).\nrewrite Ptrofs.add_zero.\nexists (Val.load_result chunk v2); split.\nconstructor; auto.\nerewrite D; eauto.\napply Val.load_result_inject.\nauto.\nexploit Mem.loadv_inject; eauto.\nsimpl; eauto.\nsimpl; intros (v2 & X & Y).\nexists v2; split; auto.\nconstructor; auto.\ninv VI.\nerewrite D; eauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) : exists v' : val,\n  volatile_load ge2 chunk m' b' ofs' (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'.","conclusion":"exists v' : val,\n  volatile_load ge2 chunk m' b' ofs' (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0)","proofString":"inv VI.\nexploit B; eauto.\nintros [U V].\nsubst delta.\nexploit eventval_match_inject_2; eauto.\nintros (v2 & X & Y).\nrewrite Ptrofs.add_zero.\nexists (Val.load_result chunk v2); split.\nconstructor; auto.\nerewrite D; eauto.\napply Val.load_result_inject.\nauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (delta : Z) (H5 : f b = Some (b', delta)) : exists v' : val,\n  volatile_load ge2 chunk m' b' (Ptrofs.add ofs (Ptrofs.repr delta))\n    (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'.","conclusion":"exists v' : val,\n  volatile_load ge2 chunk m' b' (Ptrofs.add ofs (Ptrofs.repr delta))\n    (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (delta : Z) (H5 : f b = Some (b', delta))","proofString":"exploit B; eauto.\nintros [U V].\nsubst delta.\nexploit eventval_match_inject_2; eauto.\nintros (v2 & X & Y).\nrewrite Ptrofs.add_zero.\nexists (Val.load_result chunk v2); split.\nconstructor; auto.\nerewrite D; eauto.\napply Val.load_result_inject.\nauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (delta : Z) (H5 : f b = Some (b', delta)) : delta = 0 /\\ Senv.find_symbol ge2 id = Some b' ->\nexists v' : val,\n  volatile_load ge2 chunk m' b' (Ptrofs.add ofs (Ptrofs.repr delta))\n    (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'.","conclusion":"delta = 0 /\\ Senv.find_symbol ge2 id = Some b' ->\nexists v' : val,\n  volatile_load ge2 chunk m' b' (Ptrofs.add ofs (Ptrofs.repr delta))\n    (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (delta : Z) (H5 : f b = Some (b', delta))","proofString":"intros [U V].\nsubst delta.\nexploit eventval_match_inject_2; eauto.\nintros (v2 & X & Y).\nrewrite Ptrofs.add_zero.\nexists (Val.load_result chunk v2); split.\nconstructor; auto.\nerewrite D; eauto.\napply Val.load_result_inject.\nauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (delta : Z) (H5 : f b = Some (b', delta)) (U : delta = 0) (V : Senv.find_symbol ge2 id = Some b') : exists v' : val,\n  volatile_load ge2 chunk m' b' (Ptrofs.add ofs (Ptrofs.repr delta))\n    (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'.","conclusion":"exists v' : val,\n  volatile_load ge2 chunk m' b' (Ptrofs.add ofs (Ptrofs.repr delta))\n    (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (delta : Z) (H5 : f b = Some (b', delta)) (U : delta = 0) (V : Senv.find_symbol ge2 id = Some b')","proofString":"subst delta.\nexploit eventval_match_inject_2; eauto.\nintros (v2 & X & Y).\nrewrite Ptrofs.add_zero.\nexists (Val.load_result chunk v2); split.\nconstructor; auto.\nerewrite D; eauto.\napply Val.load_result_inject.\nauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') : exists v' : val,\n  volatile_load ge2 chunk m' b' (Ptrofs.add ofs (Ptrofs.repr 0))\n    (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'.","conclusion":"exists v' : val,\n  volatile_load ge2 chunk m' b' (Ptrofs.add ofs (Ptrofs.repr 0))\n    (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b')","proofString":"exploit eventval_match_inject_2; eauto.\nintros (v2 & X & Y).\nrewrite Ptrofs.add_zero.\nexists (Val.load_result chunk v2); split.\nconstructor; auto.\nerewrite D; eauto.\napply Val.load_result_inject.\nauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') : (exists v2 : val,\n   eventval_match ge2 ev (type_of_chunk chunk) v2 /\\ Val.inject f v0 v2) ->\nexists v' : val,\n  volatile_load ge2 chunk m' b' (Ptrofs.add ofs (Ptrofs.repr 0))\n    (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'.","conclusion":"(exists v2 : val,\n   eventval_match ge2 ev (type_of_chunk chunk) v2 /\\ Val.inject f v0 v2) ->\nexists v' : val,\n  volatile_load ge2 chunk m' b' (Ptrofs.add ofs (Ptrofs.repr 0))\n    (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b')","proofString":"intros (v2 & X & Y).\nrewrite Ptrofs.add_zero.\nexists (Val.load_result chunk v2); split.\nconstructor; auto.\nerewrite D; eauto.\napply Val.load_result_inject.\nauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') (v2 : val) (X : eventval_match ge2 ev (type_of_chunk chunk) v2) (Y : Val.inject f v0 v2) : exists v' : val,\n  volatile_load ge2 chunk m' b' (Ptrofs.add ofs (Ptrofs.repr 0))\n    (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'.","conclusion":"exists v' : val,\n  volatile_load ge2 chunk m' b' (Ptrofs.add ofs (Ptrofs.repr 0))\n    (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') (v2 : val) (X : eventval_match ge2 ev (type_of_chunk chunk) v2) (Y : Val.inject f v0 v2)","proofString":"rewrite Ptrofs.add_zero.\nexists (Val.load_result chunk v2); split.\nconstructor; auto.\nerewrite D; eauto.\napply Val.load_result_inject.\nauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') (v2 : val) (X : eventval_match ge2 ev (type_of_chunk chunk) v2) (Y : Val.inject f v0 v2) : exists v' : val,\n  volatile_load ge2 chunk m' b' ofs (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'.","conclusion":"exists v' : val,\n  volatile_load ge2 chunk m' b' ofs (Event_vload chunk id ofs ev :: nil) v' /\\\n  Val.inject f (Val.load_result chunk v0) v'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') (v2 : val) (X : eventval_match ge2 ev (type_of_chunk chunk) v2) (Y : Val.inject f v0 v2)","proofString":"exists (Val.load_result chunk v2); split.\nconstructor; auto.\nerewrite D; eauto.\napply Val.load_result_inject.\nauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') (v2 : val) (X : eventval_match ge2 ev (type_of_chunk chunk) v2) (Y : Val.inject f v0 v2) : volatile_load ge2 chunk m' b' ofs (Event_vload chunk id ofs ev :: nil)\n  (Val.load_result chunk v2).","conclusion":"volatile_load ge2 chunk m' b' ofs (Event_vload chunk id ofs ev :: nil)\n  (Val.load_result chunk v2)","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') (v2 : val) (X : eventval_match ge2 ev (type_of_chunk chunk) v2) (Y : Val.inject f v0 v2)","proofString":"constructor; auto.\nerewrite D; eauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') (v2 : val) (X : eventval_match ge2 ev (type_of_chunk chunk) v2) (Y : Val.inject f v0 v2) : Senv.block_is_volatile ge2 b' = true.","conclusion":"Senv.block_is_volatile ge2 b' = true","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') (v2 : val) (X : eventval_match ge2 ev (type_of_chunk chunk) v2) (Y : Val.inject f v0 v2)","proofString":"erewrite D; eauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') (v2 : val) (X : eventval_match ge2 ev (type_of_chunk chunk) v2) (Y : Val.inject f v0 v2) : Val.inject f (Val.load_result chunk v0) (Val.load_result chunk v2).","conclusion":"Val.inject f (Val.load_result chunk v0) (Val.load_result chunk v2)","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') (v2 : val) (X : eventval_match ge2 ev (type_of_chunk chunk) v2) (Y : Val.inject f v0 v2)","proofString":"apply Val.load_result_inject.\nauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') (v2 : val) (X : eventval_match ge2 ev (type_of_chunk chunk) v2) (Y : Val.inject f v0 v2) : Val.inject f v0 v2.","conclusion":"Val.inject f v0 v2","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (B : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (C : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (v0 : val) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) v0) (H5 : f b = Some (b', 0)) (V : Senv.find_symbol ge2 id = Some b') (v2 : val) (X : eventval_match ge2 ev (type_of_chunk chunk) v2) (Y : Val.inject f v0 v2)","proofString":"auto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m') (A : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (B : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (C : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) : exists v' : val,\n  volatile_load ge2 chunk m' b' ofs' E0 v' /\\ Val.inject f v v'.","conclusion":"exists v' : val,\n  volatile_load ge2 chunk m' b' ofs' E0 v' /\\ Val.inject f v v'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m') (A : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (B : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (C : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v)","proofString":"exploit Mem.loadv_inject; eauto.\nsimpl; eauto.\nsimpl; intros (v2 & X & Y).\nexists v2; split; auto.\nconstructor; auto.\ninv VI.\nerewrite D; eauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m') (A : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (B : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (C : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (v2 : val) (X : Mem.load chunk m' b' (Ptrofs.unsigned ofs') = Some v2) (Y : Val.inject f v v2) : exists v' : val,\n  volatile_load ge2 chunk m' b' ofs' E0 v' /\\ Val.inject f v v'.","conclusion":"exists v' : val,\n  volatile_load ge2 chunk m' b' ofs' E0 v' /\\ Val.inject f v v'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m') (A : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (B : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (C : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (v2 : val) (X : Mem.load chunk m' b' (Ptrofs.unsigned ofs') = Some v2) (Y : Val.inject f v v2)","proofString":"exists v2; split; auto.\nconstructor; auto.\ninv VI.\nerewrite D; eauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m') (A : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (B : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (C : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (v2 : val) (X : Mem.load chunk m' b' (Ptrofs.unsigned ofs') = Some v2) (Y : Val.inject f v v2) : volatile_load ge2 chunk m' b' ofs' E0 v2.","conclusion":"volatile_load ge2 chunk m' b' ofs' E0 v2","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m') (A : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (B : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (C : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (v2 : val) (X : Mem.load chunk m' b' (Ptrofs.unsigned ofs') = Some v2) (Y : Val.inject f v v2)","proofString":"constructor; auto.\ninv VI.\nerewrite D; eauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m') (A : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (B : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (C : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (v2 : val) (X : Mem.load chunk m' b' (Ptrofs.unsigned ofs') = Some v2) (Y : Val.inject f v v2) : Senv.block_is_volatile ge2 b' = false.","conclusion":"Senv.block_is_volatile ge2 b' = false","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (b' : block) (ofs' : ptrofs) (m' : mem) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (MI : Mem.inject f m m') (A : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (B : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (C : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (D : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (v2 : val) (X : Mem.load chunk m' b' (Ptrofs.unsigned ofs') = Some v2) (Y : Val.inject f v v2)","proofString":"inv VI.\nerewrite D; eauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (B : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (C : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (D : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (v2 : val) (delta : Z) (X : Mem.load chunk m' b' (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) =\nSome v2) (Y : Val.inject f v v2) (H4 : f b = Some (b', delta)) : Senv.block_is_volatile ge2 b' = false.","conclusion":"Senv.block_is_volatile ge2 b' = false","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (b' : block) (m' : mem) (SI : symbols_inject f ge1 ge2) (MI : Mem.inject f m m') (A : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (B : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (C : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (D : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v) (v2 : val) (delta : Z) (X : Mem.load chunk m' b' (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) =\nSome v2) (Y : Val.inject f v v2) (H4 : f b = Some (b', delta))","proofString":"erewrite D; eauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (t1 t2 : trace) (v1 : val) (H : volatile_load ge chunk m b ofs t1 v1) (H0 : match_traces ge t1 t2) : exists v2 : val, volatile_load ge chunk m b ofs t2 v2.","conclusion":"exists v2 : val, volatile_load ge chunk m b ofs t2 v2","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (t1 t2 : trace) (v1 : val) (H : volatile_load ge chunk m b ofs t1 v1) (H0 : match_traces ge t1 t2)","proofString":"inv H; inv H0.\nexploit eventval_match_receptive; eauto.\nintros [v' EM].\nexists (Val.load_result chunk v').\nconstructor; auto.\nexists v1; constructor; auto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H1 : Senv.block_is_volatile ge b = true) (H2 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v) (res2 : eventval) (H8 : eventval_valid ge ev) (H9 : eventval_valid ge res2) (H10 : eventval_type ev = eventval_type res2) : exists v2 : val,\n  volatile_load ge chunk m b ofs (Event_vload chunk id ofs res2 :: nil) v2.","conclusion":"exists v2 : val,\n  volatile_load ge chunk m b ofs (Event_vload chunk id ofs res2 :: nil) v2","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H1 : Senv.block_is_volatile ge b = true) (H2 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v) (res2 : eventval) (H8 : eventval_valid ge ev) (H9 : eventval_valid ge res2) (H10 : eventval_type ev = eventval_type res2)","proofString":"exploit eventval_match_receptive; eauto.\nintros [v' EM].\nexists (Val.load_result chunk v').\nconstructor; auto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H1 : Senv.block_is_volatile ge b = true) (H2 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v) (res2 : eventval) (H8 : eventval_valid ge ev) (H9 : eventval_valid ge res2) (H10 : eventval_type ev = eventval_type res2) : (exists v2 : val, eventval_match ge res2 (type_of_chunk chunk) v2) ->\nexists v2 : val,\n  volatile_load ge chunk m b ofs (Event_vload chunk id ofs res2 :: nil) v2.","conclusion":"(exists v2 : val, eventval_match ge res2 (type_of_chunk chunk) v2) ->\nexists v2 : val,\n  volatile_load ge chunk m b ofs (Event_vload chunk id ofs res2 :: nil) v2","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H1 : Senv.block_is_volatile ge b = true) (H2 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v) (res2 : eventval) (H8 : eventval_valid ge ev) (H9 : eventval_valid ge res2) (H10 : eventval_type ev = eventval_type res2)","proofString":"intros [v' EM].\nexists (Val.load_result chunk v').\nconstructor; auto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H1 : Senv.block_is_volatile ge b = true) (H2 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v) (res2 : eventval) (H8 : eventval_valid ge ev) (H9 : eventval_valid ge res2) (H10 : eventval_type ev = eventval_type res2) (v' : val) (EM : eventval_match ge res2 (type_of_chunk chunk) v') : exists v2 : val,\n  volatile_load ge chunk m b ofs (Event_vload chunk id ofs res2 :: nil) v2.","conclusion":"exists v2 : val,\n  volatile_load ge chunk m b ofs (Event_vload chunk id ofs res2 :: nil) v2","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H1 : Senv.block_is_volatile ge b = true) (H2 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v) (res2 : eventval) (H8 : eventval_valid ge ev) (H9 : eventval_valid ge res2) (H10 : eventval_type ev = eventval_type res2) (v' : val) (EM : eventval_match ge res2 (type_of_chunk chunk) v')","proofString":"exists (Val.load_result chunk v').\nconstructor; auto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H1 : Senv.block_is_volatile ge b = true) (H2 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v) (res2 : eventval) (H8 : eventval_valid ge ev) (H9 : eventval_valid ge res2) (H10 : eventval_type ev = eventval_type res2) (v' : val) (EM : eventval_match ge res2 (type_of_chunk chunk) v') : volatile_load ge chunk m b ofs (Event_vload chunk id ofs res2 :: nil)\n  (Val.load_result chunk v').","conclusion":"volatile_load ge chunk m b ofs (Event_vload chunk id ofs res2 :: nil)\n  (Val.load_result chunk v')","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H1 : Senv.block_is_volatile ge b = true) (H2 : Senv.find_symbol ge id = Some b) (H3 : eventval_match ge ev (type_of_chunk chunk) v) (res2 : eventval) (H8 : eventval_valid ge ev) (H9 : eventval_valid ge res2) (H10 : eventval_type ev = eventval_type res2) (v' : val) (EM : eventval_match ge res2 (type_of_chunk chunk) v')","proofString":"constructor; auto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v1 : val) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v1) : exists v2 : val, volatile_load ge chunk m b ofs nil v2.","conclusion":"exists v2 : val, volatile_load ge chunk m b ofs nil v2","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v1 : val) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m b (Ptrofs.unsigned ofs) = Some v1)","proofString":"exists v1; constructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : volatile_load_sem chunk ge vargs m1 t vres m2) : Val.has_rettype vres (sig_res [Xptr ---> xtype_of_chunk chunk]).","conclusion":"Val.has_rettype vres (sig_res [Xptr ---> xtype_of_chunk chunk])","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : volatile_load_sem chunk ge vargs m1 t vres m2)","proofString":"inv H.\ninv H0.\napply Val.load_result_xtype.\neapply Mem.load_xtype; eauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : ptrofs) (H0 : volatile_load ge chunk m2 b ofs t vres) : Val.has_rettype vres (sig_res [Xptr ---> xtype_of_chunk chunk]).","conclusion":"Val.has_rettype vres (sig_res [Xptr ---> xtype_of_chunk chunk])","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : ptrofs) (H0 : volatile_load ge chunk m2 b ofs t vres)","proofString":"inv H0.\napply Val.load_result_xtype.\neapply Mem.load_xtype; eauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) : Val.has_rettype (Val.load_result chunk v)\n  (sig_res [Xptr ---> xtype_of_chunk chunk]).","conclusion":"Val.has_rettype (Val.load_result chunk v)\n  (sig_res [Xptr ---> xtype_of_chunk chunk])","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H1 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v)","proofString":"apply Val.load_result_xtype."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vres : val) (m2 : mem) (b : block) (ofs : ptrofs) (H : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres) : Val.has_rettype vres (sig_res [Xptr ---> xtype_of_chunk chunk]).","conclusion":"Val.has_rettype vres (sig_res [Xptr ---> xtype_of_chunk chunk])","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vres : val) (m2 : mem) (b : block) (ofs : ptrofs) (H : Senv.block_is_volatile ge b = false) (H1 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres)","proofString":"eapply Mem.load_xtype; eauto."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : volatile_load_sem chunk ge1 vargs m1 t vres m2) : volatile_load_sem chunk ge2 vargs m1 t vres m2.","conclusion":"volatile_load_sem chunk ge2 vargs m1 t vres m2","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : volatile_load_sem chunk ge1 vargs m1 t vres m2)","proofString":"inv H0.\nconstructor.\neapply volatile_load_preserved; eauto."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (b : block) (ofs : ptrofs) (H1 : volatile_load ge1 chunk m2 b ofs t vres) : volatile_load_sem chunk ge2 (Vptr b ofs :: nil) m2 t vres m2.","conclusion":"volatile_load_sem chunk ge2 (Vptr b ofs :: nil) m2 t vres m2","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (b : block) (ofs : ptrofs) (H1 : volatile_load ge1 chunk m2 b ofs t vres)","proofString":"constructor.\neapply volatile_load_preserved; eauto."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (b : block) (ofs : ptrofs) (H1 : volatile_load ge1 chunk m2 b ofs t vres) : volatile_load ge2 chunk m2 b ofs t vres.","conclusion":"volatile_load ge2 chunk m2 b ofs t vres","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (b : block) (ofs : ptrofs) (H1 : volatile_load ge1 chunk m2 b ofs t vres)","proofString":"eapply volatile_load_preserved; eauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : volatile_load_sem chunk ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : volatile_load_sem chunk ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b)","proofString":"inv H; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : volatile_load_sem chunk ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) : Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : volatile_load_sem chunk ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p)","proofString":"inv H; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : volatile_load_sem chunk ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) : Mem.loadbytes m1 b ofs n = Some bytes.","conclusion":"Mem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : volatile_load_sem chunk ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable)","proofString":"inv H; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : volatile_load_sem chunk ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs') : exists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : volatile_load_sem chunk ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs')","proofString":"inv H.\ninv H1.\ninv H6.\ninv H4.\nexploit volatile_load_extends; eauto.\nintros [v' [A B]].\nexists v'; exists m1'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H1 : Val.lessdef_list (Vptr b ofs :: nil) vargs') (H2 : volatile_load ge chunk m2 b ofs t vres) : exists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H1 : Val.lessdef_list (Vptr b ofs :: nil) vargs') (H2 : volatile_load ge chunk m2 b ofs t vres)","proofString":"inv H1.\ninv H6.\ninv H4.\nexploit volatile_load_extends; eauto.\nintros [v' [A B]].\nexists v'; exists m1'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H2 : volatile_load ge chunk m2 b ofs t vres) (v2 : val) (vl2 : list val) (H4 : Val.lessdef (Vptr b ofs) v2) (H6 : Val.lessdef_list nil vl2) : exists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge (v2 :: vl2) m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge (v2 :: vl2) m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H2 : volatile_load ge chunk m2 b ofs t vres) (v2 : val) (vl2 : list val) (H4 : Val.lessdef (Vptr b ofs) v2) (H6 : Val.lessdef_list nil vl2)","proofString":"inv H6.\ninv H4.\nexploit volatile_load_extends; eauto.\nintros [v' [A B]].\nexists v'; exists m1'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H2 : volatile_load ge chunk m2 b ofs t vres) (v2 : val) (H4 : Val.lessdef (Vptr b ofs) v2) : exists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge (v2 :: nil) m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge (v2 :: nil) m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H2 : volatile_load ge chunk m2 b ofs t vres) (v2 : val) (H4 : Val.lessdef (Vptr b ofs) v2)","proofString":"inv H4.\nexploit volatile_load_extends; eauto.\nintros [v' [A B]].\nexists v'; exists m1'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H2 : volatile_load ge chunk m2 b ofs t vres) : exists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge (Vptr b ofs :: nil) m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge (Vptr b ofs :: nil) m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H2 : volatile_load ge chunk m2 b ofs t vres)","proofString":"exploit volatile_load_extends; eauto.\nintros [v' [A B]].\nexists v'; exists m1'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H2 : volatile_load ge chunk m2 b ofs t vres) : (exists v' : val,\n   volatile_load ge chunk m1' b ofs t v' /\\ Val.lessdef vres v') ->\nexists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge (Vptr b ofs :: nil) m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"(exists v' : val,\n   volatile_load ge chunk m1' b ofs t v' /\\ Val.lessdef vres v') ->\nexists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge (Vptr b ofs :: nil) m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H2 : volatile_load ge chunk m2 b ofs t vres)","proofString":"intros [v' [A B]].\nexists v'; exists m1'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H2 : volatile_load ge chunk m2 b ofs t vres) (v' : val) (A : volatile_load ge chunk m1' b ofs t v') (B : Val.lessdef vres v') : exists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge (Vptr b ofs :: nil) m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge (Vptr b ofs :: nil) m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H2 : volatile_load ge chunk m2 b ofs t vres) (v' : val) (A : volatile_load ge chunk m1' b ofs t v') (B : Val.lessdef vres v')","proofString":"exists v'; exists m1'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H2 : volatile_load ge chunk m2 b ofs t vres) (v' : val) (A : volatile_load ge chunk m1' b ofs t v') (B : Val.lessdef vres v') : volatile_load_sem chunk ge (Vptr b ofs :: nil) m1' t v' m1'.","conclusion":"volatile_load_sem chunk ge (Vptr b ofs :: nil) m1' t v' m1'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (t : trace) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (b : block) (ofs : ptrofs) (H2 : volatile_load ge chunk m2 b ofs t vres) (v' : val) (A : volatile_load ge chunk m1' b ofs t v') (B : Val.lessdef vres v')","proofString":"constructor; auto."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : volatile_load_sem chunk ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : volatile_load_sem chunk ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"inv H0.\ninv H2.\ninv H7.\ninversion H5; subst.\nexploit volatile_load_inject; eauto.\nintros [v' [A B]].\nexists f; exists v'; exists m1'; intuition auto with mem.\nconstructor; auto.\nred; intros.\ncongruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H2 : Val.inject_list f (Vptr b ofs :: nil) vargs') (H3 : volatile_load ge1 chunk m2 b ofs t vres) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H2 : Val.inject_list f (Vptr b ofs :: nil) vargs') (H3 : volatile_load ge1 chunk m2 b ofs t vres)","proofString":"inv H2.\ninv H7.\ninversion H5; subst.\nexploit volatile_load_inject; eauto.\nintros [v' [A B]].\nexists f; exists v'; exists m1'; intuition auto with mem.\nconstructor; auto.\nred; intros.\ncongruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (v' : val) (vl' : list val) (H5 : Val.inject f (Vptr b ofs) v') (H7 : Val.inject_list f nil vl') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2 (v' :: vl') m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2 (v' :: vl') m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (v' : val) (vl' : list val) (H5 : Val.inject f (Vptr b ofs) v') (H7 : Val.inject_list f nil vl')","proofString":"inv H7.\ninversion H5; subst.\nexploit volatile_load_inject; eauto.\nintros [v' [A B]].\nexists f; exists v'; exists m1'; intuition auto with mem.\nconstructor; auto.\nred; intros.\ncongruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (v' : val) (H5 : Val.inject f (Vptr b ofs) v') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2 (v' :: nil) m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2 (v' :: nil) m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (v' : val) (H5 : Val.inject f (Vptr b ofs) v')","proofString":"inversion H5; subst.\nexploit volatile_load_inject; eauto.\nintros [v' [A B]].\nexists f; exists v'; exists m1'; intuition auto with mem.\nconstructor; auto.\nred; intros.\ncongruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (H4 : f b = Some (b2, delta)) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2\n    (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: nil) m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2\n    (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: nil) m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (H4 : f b = Some (b2, delta))","proofString":"exploit volatile_load_inject; eauto.\nintros [v' [A B]].\nexists f; exists v'; exists m1'; intuition auto with mem.\nconstructor; auto.\nred; intros.\ncongruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (H4 : f b = Some (b2, delta)) : (exists v' : val,\n   volatile_load ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) t v' /\\\n   Val.inject f vres v') ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2\n    (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: nil) m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"(exists v' : val,\n   volatile_load ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) t v' /\\\n   Val.inject f vres v') ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2\n    (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: nil) m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (H4 : f b = Some (b2, delta))","proofString":"intros [v' [A B]].\nexists f; exists v'; exists m1'; intuition auto with mem.\nconstructor; auto.\nred; intros.\ncongruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (H4 : f b = Some (b2, delta)) (v' : val) (A : volatile_load ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) t v') (B : Val.inject f vres v') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2\n    (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: nil) m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_load_sem chunk ge2\n    (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: nil) m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (H4 : f b = Some (b2, delta)) (v' : val) (A : volatile_load ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) t v') (B : Val.inject f vres v')","proofString":"exists f; exists v'; exists m1'; intuition auto with mem.\nconstructor; auto.\nred; intros.\ncongruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (H4 : f b = Some (b2, delta)) (v' : val) (A : volatile_load ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) t v') (B : Val.inject f vres v') : volatile_load_sem chunk ge2\n  (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: nil) m1' t v' m1'.","conclusion":"volatile_load_sem chunk ge2\n  (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: nil) m1' t v' m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (H4 : f b = Some (b2, delta)) (v' : val) (A : volatile_load ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) t v') (B : Val.inject f vres v')","proofString":"constructor; auto."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (H4 : f b = Some (b2, delta)) (v' : val) (A : volatile_load ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) t v') (B : Val.inject f vres v') : inject_separated f f m2 m1'.","conclusion":"inject_separated f f m2 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (H4 : f b = Some (b2, delta)) (v' : val) (A : volatile_load ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) t v') (B : Val.inject f vres v')","proofString":"red; intros.\ncongruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (H4 : f b = Some (b2, delta)) (v' : val) (A : volatile_load ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) t v') (B : Val.inject f vres v') (b1 b0 : block) (delta0 : Z) (H0 : f b1 = None) (H2 : f b1 = Some (b0, delta0)) : ~ Mem.valid_block m2 b1 /\\ ~ Mem.valid_block m1' b0.","conclusion":"~ Mem.valid_block m2 b1 /\\ ~ Mem.valid_block m1' b0","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (b : block) (ofs : ptrofs) (H3 : volatile_load ge1 chunk m2 b ofs t vres) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (H4 : f b = Some (b2, delta)) (v' : val) (A : volatile_load ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) t v') (B : Val.inject f vres v') (b1 b0 : block) (delta0 : Z) (H0 : f b1 = None) (H2 : f b1 = Some (b0, delta0))","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : volatile_load_sem chunk ge vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : volatile_load_sem chunk ge vargs m t vres m')","proofString":"inv H; inv H0; simpl; lia."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : volatile_load_sem chunk ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : exists (vres2 : val) (m2 : mem),\n  volatile_load_sem chunk ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  volatile_load_sem chunk ge vargs m t2 vres2 m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : volatile_load_sem chunk ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"inv H.\nexploit volatile_load_receptive; eauto.\nintros [v2 A].\nexists v2; exists m1; constructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H0 : match_traces ge t1 t2) (b : block) (ofs : ptrofs) (H1 : volatile_load ge chunk m1 b ofs t1 vres1) : exists (vres2 : val) (m2 : mem),\n  volatile_load_sem chunk ge (Vptr b ofs :: nil) m1 t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  volatile_load_sem chunk ge (Vptr b ofs :: nil) m1 t2 vres2 m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H0 : match_traces ge t1 t2) (b : block) (ofs : ptrofs) (H1 : volatile_load ge chunk m1 b ofs t1 vres1)","proofString":"exploit volatile_load_receptive; eauto.\nintros [v2 A].\nexists v2; exists m1; constructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H0 : match_traces ge t1 t2) (b : block) (ofs : ptrofs) (H1 : volatile_load ge chunk m1 b ofs t1 vres1) : (exists v2 : val, volatile_load ge chunk m1 b ofs t2 v2) ->\nexists (vres2 : val) (m2 : mem),\n  volatile_load_sem chunk ge (Vptr b ofs :: nil) m1 t2 vres2 m2.","conclusion":"(exists v2 : val, volatile_load ge chunk m1 b ofs t2 v2) ->\nexists (vres2 : val) (m2 : mem),\n  volatile_load_sem chunk ge (Vptr b ofs :: nil) m1 t2 vres2 m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H0 : match_traces ge t1 t2) (b : block) (ofs : ptrofs) (H1 : volatile_load ge chunk m1 b ofs t1 vres1)","proofString":"intros [v2 A].\nexists v2; exists m1; constructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H0 : match_traces ge t1 t2) (b : block) (ofs : ptrofs) (H1 : volatile_load ge chunk m1 b ofs t1 vres1) (v2 : val) (A : volatile_load ge chunk m1 b ofs t2 v2) : exists (vres2 : val) (m2 : mem),\n  volatile_load_sem chunk ge (Vptr b ofs :: nil) m1 t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  volatile_load_sem chunk ge (Vptr b ofs :: nil) m1 t2 vres2 m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H0 : match_traces ge t1 t2) (b : block) (ofs : ptrofs) (H1 : volatile_load ge chunk m1 b ofs t1 vres1) (v2 : val) (A : volatile_load ge chunk m1 b ofs t2 v2)","proofString":"exists v2; exists m1; constructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : volatile_load_sem chunk ge vargs m t1 vres1 m1) (H0 : volatile_load_sem chunk ge vargs m t2 vres2 m2) : match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2).","conclusion":"match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : volatile_load_sem chunk ge vargs m t1 vres1 m1) (H0 : volatile_load_sem chunk ge vargs m t2 vres2 m2)","proofString":"inv H; inv H0.\ninv H1; inv H7; try congruence.\nassert (id = id0) by (eapply Senv.find_symbol_injective; eauto).\nsubst id0.\nsplit.\nconstructor.\neapply eventval_match_valid; eauto.\neapply eventval_match_valid; eauto.\neapply eventval_match_same_type; eauto.\nintros EQ; inv EQ.\nassert (v = v0) by (eapply eventval_match_determ_1; eauto).\nsubst v0.\nauto.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (t1 : trace) (vres1 : val) (t2 : trace) (vres2 : val) (m2 : mem) (b : block) (ofs : ptrofs) (H1 : volatile_load ge chunk m2 b ofs t1 vres1) (H7 : volatile_load ge chunk m2 b ofs t2 vres2) : match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m2 = m2).","conclusion":"match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m2 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (t1 : trace) (vres1 : val) (t2 : trace) (vres2 : val) (m2 : mem) (b : block) (ofs : ptrofs) (H1 : volatile_load ge chunk m2 b ofs t1 vres1) (H7 : volatile_load ge chunk m2 b ofs t2 vres2)","proofString":"inv H1; inv H7; try congruence.\nassert (id = id0) by (eapply Senv.find_symbol_injective; eauto).\nsubst id0.\nsplit.\nconstructor.\neapply eventval_match_valid; eauto.\neapply eventval_match_valid; eauto.\neapply eventval_match_same_type; eauto.\nintros EQ; inv EQ.\nassert (v = v0) by (eapply eventval_match_determ_1; eauto).\nsubst v0.\nauto.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (id0 : ident) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id0 = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0) : match_traces ge (Event_vload chunk id ofs ev :: nil)\n  (Event_vload chunk id0 ofs ev0 :: nil) /\\\n(Event_vload chunk id ofs ev :: nil = Event_vload chunk id0 ofs ev0 :: nil ->\n Val.load_result chunk v = Val.load_result chunk v0 /\\ m2 = m2).","conclusion":"match_traces ge (Event_vload chunk id ofs ev :: nil)\n  (Event_vload chunk id0 ofs ev0 :: nil) /\\\n(Event_vload chunk id ofs ev :: nil = Event_vload chunk id0 ofs ev0 :: nil ->\n Val.load_result chunk v = Val.load_result chunk v0 /\\ m2 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (id0 : ident) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id0 = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0)","proofString":"assert (id = id0) by (eapply Senv.find_symbol_injective; eauto).\nsubst id0.\nsplit.\nconstructor.\neapply eventval_match_valid; eauto.\neapply eventval_match_valid; eauto.\neapply eventval_match_same_type; eauto.\nintros EQ; inv EQ.\nassert (v = v0) by (eapply eventval_match_determ_1; eauto).\nsubst v0.\nauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (id0 : ident) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id0 = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0) (H5 : id = id0) : match_traces ge (Event_vload chunk id ofs ev :: nil)\n  (Event_vload chunk id0 ofs ev0 :: nil) /\\\n(Event_vload chunk id ofs ev :: nil = Event_vload chunk id0 ofs ev0 :: nil ->\n Val.load_result chunk v = Val.load_result chunk v0 /\\ m2 = m2).","conclusion":"match_traces ge (Event_vload chunk id ofs ev :: nil)\n  (Event_vload chunk id0 ofs ev0 :: nil) /\\\n(Event_vload chunk id ofs ev :: nil = Event_vload chunk id0 ofs ev0 :: nil ->\n Val.load_result chunk v = Val.load_result chunk v0 /\\ m2 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (id0 : ident) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id0 = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0) (H5 : id = id0)","proofString":"subst id0.\nsplit.\nconstructor.\neapply eventval_match_valid; eauto.\neapply eventval_match_valid; eauto.\neapply eventval_match_same_type; eauto.\nintros EQ; inv EQ.\nassert (v = v0) by (eapply eventval_match_determ_1; eauto).\nsubst v0.\nauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0) : match_traces ge (Event_vload chunk id ofs ev :: nil)\n  (Event_vload chunk id ofs ev0 :: nil) /\\\n(Event_vload chunk id ofs ev :: nil = Event_vload chunk id ofs ev0 :: nil ->\n Val.load_result chunk v = Val.load_result chunk v0 /\\ m2 = m2).","conclusion":"match_traces ge (Event_vload chunk id ofs ev :: nil)\n  (Event_vload chunk id ofs ev0 :: nil) /\\\n(Event_vload chunk id ofs ev :: nil = Event_vload chunk id ofs ev0 :: nil ->\n Val.load_result chunk v = Val.load_result chunk v0 /\\ m2 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0)","proofString":"split.\nconstructor.\neapply eventval_match_valid; eauto.\neapply eventval_match_valid; eauto.\neapply eventval_match_same_type; eauto.\nintros EQ; inv EQ.\nassert (v = v0) by (eapply eventval_match_determ_1; eauto).\nsubst v0.\nauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0) : match_traces ge (Event_vload chunk id ofs ev :: nil)\n  (Event_vload chunk id ofs ev0 :: nil).","conclusion":"match_traces ge (Event_vload chunk id ofs ev :: nil)\n  (Event_vload chunk id ofs ev0 :: nil)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0)","proofString":"constructor.\neapply eventval_match_valid; eauto.\neapply eventval_match_valid; eauto.\neapply eventval_match_same_type; eauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0) : eventval_valid ge ev.","conclusion":"eventval_valid ge ev","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0)","proofString":"eapply eventval_match_valid; eauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0) : eventval_valid ge ev0.","conclusion":"eventval_valid ge ev0","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0)","proofString":"eapply eventval_match_valid; eauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0) : eventval_type ev = eventval_type ev0.","conclusion":"eventval_type ev = eventval_type ev0","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0)","proofString":"eapply eventval_match_same_type; eauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0) : Event_vload chunk id ofs ev :: nil = Event_vload chunk id ofs ev0 :: nil ->\nVal.load_result chunk v = Val.load_result chunk v0 /\\ m2 = m2.","conclusion":"Event_vload chunk id ofs ev :: nil = Event_vload chunk id ofs ev0 :: nil ->\nVal.load_result chunk v = Val.load_result chunk v0 /\\ m2 = m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (ev : eventval) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) v) (ev0 : eventval) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0)","proofString":"intros EQ; inv EQ.\nassert (v = v0) by (eapply eventval_match_determ_1; eauto).\nsubst v0.\nauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (ev0 : eventval) (H2 : eventval_match ge ev0 (type_of_chunk chunk) v) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0) : Val.load_result chunk v = Val.load_result chunk v0 /\\ m2 = m2.","conclusion":"Val.load_result chunk v = Val.load_result chunk v0 /\\ m2 = m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (ev0 : eventval) (H2 : eventval_match ge ev0 (type_of_chunk chunk) v) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0)","proofString":"assert (v = v0) by (eapply eventval_match_determ_1; eauto).\nsubst v0.\nauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (ev0 : eventval) (H2 : eventval_match ge ev0 (type_of_chunk chunk) v) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0) (H5 : v = v0) : Val.load_result chunk v = Val.load_result chunk v0 /\\ m2 = m2.","conclusion":"Val.load_result chunk v = Val.load_result chunk v0 /\\ m2 = m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (ev0 : eventval) (H2 : eventval_match ge ev0 (type_of_chunk chunk) v) (v0 : val) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v0) (H5 : v = v0)","proofString":"subst v0.\nauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (ev0 : eventval) (H2 : eventval_match ge ev0 (type_of_chunk chunk) v) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v) : Val.load_result chunk v = Val.load_result chunk v /\\ m2 = m2.","conclusion":"Val.load_result chunk v = Val.load_result chunk v /\\ m2 = m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (id : ident) (v : val) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (ev0 : eventval) (H2 : eventval_match ge ev0 (type_of_chunk chunk) v) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) v)","proofString":"auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vres1 vres2 : val) (m2 : mem) (b : block) (ofs : ptrofs) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres1) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres2) : match_traces ge E0 E0 /\\ (E0 = E0 -> vres1 = vres2 /\\ m2 = m2).","conclusion":"match_traces ge E0 E0 /\\ (E0 = E0 -> vres1 = vres2 /\\ m2 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vres1 vres2 : val) (m2 : mem) (b : block) (ofs : ptrofs) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres1) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres2)","proofString":"split.\nconstructor.\nintuition congruence."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vres1 vres2 : val) (m2 : mem) (b : block) (ofs : ptrofs) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres1) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres2) : match_traces ge E0 E0.","conclusion":"match_traces ge E0 E0","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vres1 vres2 : val) (m2 : mem) (b : block) (ofs : ptrofs) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres1) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres2)","proofString":"constructor."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vres1 vres2 : val) (m2 : mem) (b : block) (ofs : ptrofs) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres1) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres2) : E0 = E0 -> vres1 = vres2 /\\ m2 = m2.","conclusion":"E0 = E0 -> vres1 = vres2 /\\ m2 = m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vres1 vres2 : val) (m2 : mem) (b : block) (ofs : ptrofs) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres1) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.load chunk m2 b (Ptrofs.unsigned ofs) = Some vres2)","proofString":"intuition congruence."},{"statement":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (t : trace) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : volatile_store ge1 chunk m1 b ofs v t m2) : volatile_store ge2 chunk m1 b ofs v t m2.","conclusion":"volatile_store ge2 chunk m1 b ofs v t m2","hypotheses":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (t : trace) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : volatile_store ge1 chunk m1 b ofs v t m2)","proofString":"destruct H as (A & B & C).\ninv H0; constructor; auto.\nrewrite C; auto.\nrewrite A; auto.\neapply eventval_match_preserved; eauto.\nrewrite C; auto."},{"statement":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (t : trace) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (H0 : volatile_store ge1 chunk m1 b ofs v t m2) : volatile_store ge2 chunk m1 b ofs v t m2.","conclusion":"volatile_store ge2 chunk m1 b ofs v t m2","hypotheses":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (t : trace) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (H0 : volatile_store ge1 chunk m1 b ofs v t m2)","proofString":"inv H0; constructor; auto.\nrewrite C; auto.\nrewrite A; auto.\neapply eventval_match_preserved; eauto.\nrewrite C; auto."},{"statement":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 : mem) (A : forall id0 : ident, Senv.find_symbol ge2 id0 = Senv.find_symbol ge1 id0) (B : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H1 : Senv.find_symbol ge1 id = Some b) (H2 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) : Senv.block_is_volatile ge2 b = true.","conclusion":"Senv.block_is_volatile ge2 b = true","hypotheses":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 : mem) (A : forall id0 : ident, Senv.find_symbol ge2 id0 = Senv.find_symbol ge1 id0) (B : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H1 : Senv.find_symbol ge1 id = Some b) (H2 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"rewrite C; auto."},{"statement":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 : mem) (A : forall id0 : ident, Senv.find_symbol ge2 id0 = Senv.find_symbol ge1 id0) (B : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H1 : Senv.find_symbol ge1 id = Some b) (H2 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) : Senv.find_symbol ge2 id = Some b.","conclusion":"Senv.find_symbol ge2 id = Some b","hypotheses":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 : mem) (A : forall id0 : ident, Senv.find_symbol ge2 id0 = Senv.find_symbol ge1 id0) (B : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H1 : Senv.find_symbol ge1 id = Some b) (H2 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"rewrite A; auto."},{"statement":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 : mem) (A : forall id0 : ident, Senv.find_symbol ge2 id0 = Senv.find_symbol ge1 id0) (B : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H1 : Senv.find_symbol ge1 id = Some b) (H2 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) : eventval_match ge2 ev (type_of_chunk chunk) (Val.load_result chunk v).","conclusion":"eventval_match ge2 ev (type_of_chunk chunk) (Val.load_result chunk v)","hypotheses":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 : mem) (A : forall id0 : ident, Senv.find_symbol ge2 id0 = Senv.find_symbol ge1 id0) (B : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H1 : Senv.find_symbol ge1 id = Some b) (H2 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"eapply eventval_match_preserved; eauto."},{"statement":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (H : Senv.block_is_volatile ge1 b = false) (H1 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) : Senv.block_is_volatile ge2 b = false.","conclusion":"Senv.block_is_volatile ge2 b = false","hypotheses":"(ge1 ge2 : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b0 : block,\nSenv.block_is_volatile ge2 b0 = Senv.block_is_volatile ge1 b0) (H : Senv.block_is_volatile ge1 b = false) (H1 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2)","proofString":"rewrite C; auto."},{"statement":"(m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : Mem.unchanged_on (loc_not_writable m1) m1 m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) : Mem.loadbytes m1 b ofs n = Some bytes.","conclusion":"Mem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : Mem.unchanged_on (loc_not_writable m1) m1 m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable)","proofString":"rewrite <- H1.\nsymmetry.\napply Mem.loadbytes_unchanged_on_1 with (P := loc_not_writable m1); auto."},{"statement":"(m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : Mem.unchanged_on (loc_not_writable m1) m1 m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) : Mem.loadbytes m1 b ofs n = Mem.loadbytes m2 b ofs n.","conclusion":"Mem.loadbytes m1 b ofs n = Mem.loadbytes m2 b ofs n","hypotheses":"(m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : Mem.unchanged_on (loc_not_writable m1) m1 m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable)","proofString":"symmetry.\napply Mem.loadbytes_unchanged_on_1 with (P := loc_not_writable m1); auto."},{"statement":"(m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : Mem.unchanged_on (loc_not_writable m1) m1 m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) : Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n.","conclusion":"Mem.loadbytes m2 b ofs n = Mem.loadbytes m1 b ofs n","hypotheses":"(m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : Mem.unchanged_on (loc_not_writable m1) m1 m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable)","proofString":"apply Mem.loadbytes_unchanged_on_1 with (P := loc_not_writable m1); auto."},{"statement":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (t : trace) (m2 : mem) (H : volatile_store ge chunk1 m1 b1 ofs1 v t m2) : Mem.unchanged_on (loc_not_writable m1) m1 m2.","conclusion":"Mem.unchanged_on (loc_not_writable m1) m1 m2","hypotheses":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (t : trace) (m2 : mem) (H : volatile_store ge chunk1 m1 b1 ofs1 v t m2)","proofString":"inv H.\napply Mem.unchanged_on_refl.\neapply Mem.store_unchanged_on; eauto.\nexploit Mem.store_valid_access_3; eauto.\nintros [P Q].\nintros.\nunfold loc_not_writable.\nred; intros.\nelim H2.\napply Mem.perm_cur_max.\napply P.\nauto."},{"statement":"(ge : Senv.t) (chunk1 : memory_chunk) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (id : ident) (ev : eventval) (H0 : Senv.block_is_volatile ge b1 = true) (H1 : Senv.find_symbol ge id = Some b1) (H2 : eventval_match ge ev (type_of_chunk chunk1) (Val.load_result chunk1 v)) : Mem.unchanged_on (loc_not_writable m2) m2 m2.","conclusion":"Mem.unchanged_on (loc_not_writable m2) m2 m2","hypotheses":"(ge : Senv.t) (chunk1 : memory_chunk) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (id : ident) (ev : eventval) (H0 : Senv.block_is_volatile ge b1 = true) (H1 : Senv.find_symbol ge id = Some b1) (H2 : eventval_match ge ev (type_of_chunk chunk1) (Val.load_result chunk1 v))","proofString":"apply Mem.unchanged_on_refl."},{"statement":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) : Mem.unchanged_on (loc_not_writable m1) m1 m2.","conclusion":"Mem.unchanged_on (loc_not_writable m1) m1 m2","hypotheses":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2)","proofString":"eapply Mem.store_unchanged_on; eauto.\nexploit Mem.store_valid_access_3; eauto.\nintros [P Q].\nintros.\nunfold loc_not_writable.\nred; intros.\nelim H2.\napply Mem.perm_cur_max.\napply P.\nauto."},{"statement":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) : forall i : Z,\nPtrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1 ->\n~ loc_not_writable m1 b1 i.","conclusion":"forall i : Z,\nPtrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1 ->\n~ loc_not_writable m1 b1 i","hypotheses":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2)","proofString":"exploit Mem.store_valid_access_3; eauto.\nintros [P Q].\nintros.\nunfold loc_not_writable.\nred; intros.\nelim H2.\napply Mem.perm_cur_max.\napply P.\nauto."},{"statement":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) : Mem.valid_access m1 chunk1 b1 (Ptrofs.unsigned ofs1) Writable ->\nforall i : Z,\nPtrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1 ->\n~ loc_not_writable m1 b1 i.","conclusion":"Mem.valid_access m1 chunk1 b1 (Ptrofs.unsigned ofs1) Writable ->\nforall i : Z,\nPtrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1 ->\n~ loc_not_writable m1 b1 i","hypotheses":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2)","proofString":"intros [P Q].\nintros.\nunfold loc_not_writable.\nred; intros.\nelim H2.\napply Mem.perm_cur_max.\napply P.\nauto."},{"statement":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1)) : forall i : Z,\nPtrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1 ->\n~ loc_not_writable m1 b1 i.","conclusion":"forall i : Z,\nPtrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1 ->\n~ loc_not_writable m1 b1 i","hypotheses":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1))","proofString":"intros.\nunfold loc_not_writable.\nred; intros.\nelim H2.\napply Mem.perm_cur_max.\napply P.\nauto."},{"statement":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1)) (i : Z) (H : Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1) : ~ loc_not_writable m1 b1 i.","conclusion":"~ loc_not_writable m1 b1 i","hypotheses":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1)) (i : Z) (H : Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1)","proofString":"unfold loc_not_writable.\nred; intros.\nelim H2.\napply Mem.perm_cur_max.\napply P.\nauto."},{"statement":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1)) (i : Z) (H : Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1) : ~ ~ Mem.perm m1 b1 i Max Writable.","conclusion":"~ ~ Mem.perm m1 b1 i Max Writable","hypotheses":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1)) (i : Z) (H : Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1)","proofString":"red; intros.\nelim H2.\napply Mem.perm_cur_max.\napply P.\nauto."},{"statement":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1)) (i : Z) (H : Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1) (H2 : ~ Mem.perm m1 b1 i Max Writable) : False.","conclusion":"False","hypotheses":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1)) (i : Z) (H : Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1) (H2 : ~ Mem.perm m1 b1 i Max Writable)","proofString":"elim H2.\napply Mem.perm_cur_max.\napply P.\nauto."},{"statement":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1)) (i : Z) (H : Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1) (H2 : ~ Mem.perm m1 b1 i Max Writable) : Mem.perm m1 b1 i Max Writable.","conclusion":"Mem.perm m1 b1 i Max Writable","hypotheses":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1)) (i : Z) (H : Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1) (H2 : ~ Mem.perm m1 b1 i Max Writable)","proofString":"apply Mem.perm_cur_max.\napply P.\nauto."},{"statement":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1)) (i : Z) (H : Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1) (H2 : ~ Mem.perm m1 b1 i Max Writable) : Mem.perm m1 b1 i Cur Writable.","conclusion":"Mem.perm m1 b1 i Cur Writable","hypotheses":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1)) (i : Z) (H : Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1) (H2 : ~ Mem.perm m1 b1 i Max Writable)","proofString":"apply P.\nauto."},{"statement":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1)) (i : Z) (H : Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1) (H2 : ~ Mem.perm m1 b1 i Max Writable) : Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1.","conclusion":"Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1","hypotheses":"(ge : Senv.t) (chunk1 : memory_chunk) (m1 : mem) (b1 : block) (ofs1 : ptrofs) (v : val) (m2 : mem) (H0 : Senv.block_is_volatile ge b1 = false) (H1 : Mem.store chunk1 m1 b1 (Ptrofs.unsigned ofs1) v = Some m2) (P : Mem.range_perm m1 b1 (Ptrofs.unsigned ofs1)\n  (Ptrofs.unsigned ofs1 + size_chunk chunk1) Cur Writable) (Q : (align_chunk chunk1 | Ptrofs.unsigned ofs1)) (i : Z) (H : Ptrofs.unsigned ofs1 <= i < Ptrofs.unsigned ofs1 + size_chunk chunk1) (H2 : ~ Mem.perm m1 b1 i Max Writable)","proofString":"auto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (t : trace) (m2 m1' : mem) (v' : val) (H : volatile_store ge chunk m1 b ofs v t m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') : exists m2' : mem,\n  volatile_store ge chunk m1' b ofs v' t m2' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists m2' : mem,\n  volatile_store ge chunk m1' b ofs v' t m2' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (t : trace) (m2 m1' : mem) (v' : val) (H : volatile_store ge chunk m1 b ofs v t m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v')","proofString":"inv H.\neconstructor; split.\neconstructor; eauto.\neapply eventval_match_lessdef; eauto.\napply Val.load_result_lessdef; auto.\nauto with mem.\nexploit Mem.store_within_extends; eauto.\nintros [m2' [A B]].\nexists m2'; intuition auto with mem.\neconstructor; eauto.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\nexploit Mem.store_valid_access_3.\neexact H3.\nintros [P Q].\neauto.\ntauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef v v') (id : ident) (ev : eventval) (H2 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) : exists m2' : mem,\n  volatile_store ge chunk m1' b ofs v' (Event_vstore chunk id ofs ev :: nil)\n    m2' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists m2' : mem,\n  volatile_store ge chunk m1' b ofs v' (Event_vstore chunk id ofs ev :: nil)\n    m2' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef v v') (id : ident) (ev : eventval) (H2 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"econstructor; split.\neconstructor; eauto.\neapply eventval_match_lessdef; eauto.\napply Val.load_result_lessdef; auto.\nauto with mem."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef v v') (id : ident) (ev : eventval) (H2 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v').","conclusion":"eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v')","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef v v') (id : ident) (ev : eventval) (H2 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"eapply eventval_match_lessdef; eauto.\napply Val.load_result_lessdef; auto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef v v') (id : ident) (ev : eventval) (H2 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) : Val.lessdef (Val.load_result chunk v) (Val.load_result chunk v').","conclusion":"Val.lessdef (Val.load_result chunk v) (Val.load_result chunk v')","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef v v') (id : ident) (ev : eventval) (H2 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"apply Val.load_result_lessdef; auto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) : exists m2' : mem,\n  volatile_store ge chunk m1' b ofs v' E0 m2' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists m2' : mem,\n  volatile_store ge chunk m1' b ofs v' E0 m2' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2)","proofString":"exploit Mem.store_within_extends; eauto.\nintros [m2' [A B]].\nexists m2'; intuition auto with mem.\neconstructor; eauto.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\nexploit Mem.store_valid_access_3.\neexact H3.\nintros [P Q].\neauto.\ntauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) : (exists m2' : mem,\n   Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2' /\\\n   Mem.extends m2 m2') ->\nexists m2' : mem,\n  volatile_store ge chunk m1' b ofs v' E0 m2' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"(exists m2' : mem,\n   Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2' /\\\n   Mem.extends m2 m2') ->\nexists m2' : mem,\n  volatile_store ge chunk m1' b ofs v' E0 m2' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2)","proofString":"intros [m2' [A B]].\nexists m2'; intuition auto with mem.\neconstructor; eauto.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\nexploit Mem.store_valid_access_3.\neexact H3.\nintros [P Q].\neauto.\ntauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') : exists m2'0 : mem,\n  volatile_store ge chunk m1' b ofs v' E0 m2'0 /\\\n  Mem.extends m2 m2'0 /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'0.","conclusion":"exists m2'0 : mem,\n  volatile_store ge chunk m1' b ofs v' E0 m2'0 /\\\n  Mem.extends m2 m2'0 /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'0","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2')","proofString":"exists m2'; intuition auto with mem.\neconstructor; eauto.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\nexploit Mem.store_valid_access_3.\neexact H3.\nintros [P Q].\neauto.\ntauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') : volatile_store ge chunk m1' b ofs v' E0 m2'.","conclusion":"volatile_store ge chunk m1' b ofs v' E0 m2'","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2')","proofString":"econstructor; eauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') : Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2')","proofString":"eapply Mem.store_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\nexploit Mem.store_valid_access_3.\neexact H3.\nintros [P Q].\neauto.\ntauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') : forall i : Z,\nPtrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk ->\n~ loc_out_of_bounds m1 b i.","conclusion":"forall i : Z,\nPtrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk ->\n~ loc_out_of_bounds m1 b i","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2')","proofString":"unfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\nexploit Mem.store_valid_access_3.\neexact H3.\nintros [P Q].\neauto.\ntauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) : ~ ~ Mem.perm m1 b i Max Nonempty.","conclusion":"~ ~ Mem.perm m1 b i Max Nonempty","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk)","proofString":"assert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\nexploit Mem.store_valid_access_3.\neexact H3.\nintros [P Q].\neauto.\ntauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) : Mem.perm m1 b i Max Nonempty.","conclusion":"Mem.perm m1 b i Max Nonempty","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk)","proofString":"apply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\nexploit Mem.store_valid_access_3.\neexact H3.\nintros [P Q].\neauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) : Mem.perm m1 b i Cur Nonempty.","conclusion":"Mem.perm m1 b i Cur Nonempty","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk)","proofString":"apply Mem.perm_implies with Writable; auto with mem.\nexploit Mem.store_valid_access_3.\neexact H3.\nintros [P Q].\neauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) : Mem.perm m1 b i Cur Writable.","conclusion":"Mem.perm m1 b i Cur Writable","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk)","proofString":"exploit Mem.store_valid_access_3.\neexact H3.\nintros [P Q].\neauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) (P : Mem.range_perm m1 b (Ptrofs.unsigned ofs)\n  (Ptrofs.unsigned ofs + size_chunk chunk) Cur Writable) (Q : (align_chunk chunk | Ptrofs.unsigned ofs)) : Mem.perm m1 b i Cur Writable.","conclusion":"Mem.perm m1 b i Cur Writable","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) (P : Mem.range_perm m1 b (Ptrofs.unsigned ofs)\n  (Ptrofs.unsigned ofs + size_chunk chunk) Cur Writable) (Q : (align_chunk chunk | Ptrofs.unsigned ofs))","proofString":"eauto."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) (H4 : Mem.perm m1 b i Max Nonempty) : ~ ~ Mem.perm m1 b i Max Nonempty.","conclusion":"~ ~ Mem.perm m1 b i Max Nonempty","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (v' : val) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef v v') (H2 : Senv.block_is_volatile ge b = false) (H3 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b (Ptrofs.unsigned ofs) v' = Some m2') (B : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) (H4 : Mem.perm m1 b i Max Nonempty)","proofString":"tauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (t : trace) (m2 m1' : mem) (b' : block) (ofs' : ptrofs) (v' : val) (SI : symbols_inject f ge1 ge2) (VS : volatile_store ge1 chunk m1 b ofs v t m2) (AI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') : exists m2' : mem,\n  volatile_store ge2 chunk m1' b' ofs' v' t m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'.","conclusion":"exists m2' : mem,\n  volatile_store ge2 chunk m1' b' ofs' v' t m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (t : trace) (m2 m1' : mem) (b' : block) (ofs' : ptrofs) (v' : val) (SI : symbols_inject f ge1 ge2) (VS : volatile_store ge1 chunk m1 b ofs v t m2) (AI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1')","proofString":"generalize SI; intros (P & Q & R & S).\ninv VS.\ninv AI.\nexploit Q; eauto.\nintros [A B].\nsubst delta.\nrewrite Ptrofs.add_zero.\nexists m1'; split.\nconstructor; auto.\nerewrite S; eauto.\neapply eventval_match_inject; eauto.\napply Val.load_result_inject.\nauto.\nintuition auto with mem.\ninversion AI; subst.\nassert (Mem.storev chunk m1 (Vptr b ofs) v = Some m2).\nsimpl; auto.\nexploit Mem.storev_mapped_inject; eauto.\nintros [m2' [A B]].\nexists m2'; intuition auto.\nconstructor; auto.\nerewrite S; eauto.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ninv AI; congruence.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\nsimpl in A.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) = Ptrofs.unsigned ofs + delta)  by (eapply Mem.address_inject; eauto with mem).\nrewrite EQ in *.\neelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (t : trace) (m2 m1' : mem) (b' : block) (ofs' : ptrofs) (v' : val) (SI : symbols_inject f ge1 ge2) (VS : volatile_store ge1 chunk m1 b ofs v t m2) (AI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) : exists m2' : mem,\n  volatile_store ge2 chunk m1' b' ofs' v' t m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'.","conclusion":"exists m2' : mem,\n  volatile_store ge2 chunk m1' b' ofs' v' t m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (t : trace) (m2 m1' : mem) (b' : block) (ofs' : ptrofs) (v' : val) (SI : symbols_inject f ge1 ge2) (VS : volatile_store ge1 chunk m1 b ofs v t m2) (AI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1)","proofString":"inv VS.\ninv AI.\nexploit Q; eauto.\nintros [A B].\nsubst delta.\nrewrite Ptrofs.add_zero.\nexists m1'; split.\nconstructor; auto.\nerewrite S; eauto.\neapply eventval_match_inject; eauto.\napply Val.load_result_inject.\nauto.\nintuition auto with mem.\ninversion AI; subst.\nassert (Mem.storev chunk m1 (Vptr b ofs) v = Some m2).\nsimpl; auto.\nexploit Mem.storev_mapped_inject; eauto.\nintros [m2' [A B]].\nexists m2'; intuition auto.\nconstructor; auto.\nerewrite S; eauto.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ninv AI; congruence.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\nsimpl in A.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) = Ptrofs.unsigned ofs + delta)  by (eapply Mem.address_inject; eauto with mem).\nrewrite EQ in *.\neelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (ofs' : ptrofs) (v' : val) (SI : symbols_inject f ge1 ge2) (AI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) : exists m2' : mem,\n  volatile_store ge2 chunk m1' b' ofs' v'\n    (Event_vstore chunk id ofs ev :: nil) m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2'.","conclusion":"exists m2' : mem,\n  volatile_store ge2 chunk m1' b' ofs' v'\n    (Event_vstore chunk id ofs ev :: nil) m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (ofs' : ptrofs) (v' : val) (SI : symbols_inject f ge1 ge2) (AI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"inv AI.\nexploit Q; eauto.\nintros [A B].\nsubst delta.\nrewrite Ptrofs.add_zero.\nexists m1'; split.\nconstructor; auto.\nerewrite S; eauto.\neapply eventval_match_inject; eauto.\napply Val.load_result_inject.\nauto.\nintuition auto with mem."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (delta : Z) (H5 : f b = Some (b', delta)) : exists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v'\n    (Event_vstore chunk id ofs ev :: nil) m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2'.","conclusion":"exists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v'\n    (Event_vstore chunk id ofs ev :: nil) m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (delta : Z) (H5 : f b = Some (b', delta))","proofString":"exploit Q; eauto.\nintros [A B].\nsubst delta.\nrewrite Ptrofs.add_zero.\nexists m1'; split.\nconstructor; auto.\nerewrite S; eauto.\neapply eventval_match_inject; eauto.\napply Val.load_result_inject.\nauto.\nintuition auto with mem."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (delta : Z) (H5 : f b = Some (b', delta)) : delta = 0 /\\ Senv.find_symbol ge2 id = Some b' ->\nexists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v'\n    (Event_vstore chunk id ofs ev :: nil) m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2'.","conclusion":"delta = 0 /\\ Senv.find_symbol ge2 id = Some b' ->\nexists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v'\n    (Event_vstore chunk id ofs ev :: nil) m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (delta : Z) (H5 : f b = Some (b', delta))","proofString":"intros [A B].\nsubst delta.\nrewrite Ptrofs.add_zero.\nexists m1'; split.\nconstructor; auto.\nerewrite S; eauto.\neapply eventval_match_inject; eauto.\napply Val.load_result_inject.\nauto.\nintuition auto with mem."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (delta : Z) (H5 : f b = Some (b', delta)) (A : delta = 0) (B : Senv.find_symbol ge2 id = Some b') : exists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v'\n    (Event_vstore chunk id ofs ev :: nil) m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2'.","conclusion":"exists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v'\n    (Event_vstore chunk id ofs ev :: nil) m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (delta : Z) (H5 : f b = Some (b', delta)) (A : delta = 0) (B : Senv.find_symbol ge2 id = Some b')","proofString":"subst delta.\nrewrite Ptrofs.add_zero.\nexists m1'; split.\nconstructor; auto.\nerewrite S; eauto.\neapply eventval_match_inject; eauto.\napply Val.load_result_inject.\nauto.\nintuition auto with mem."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b') : exists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr 0)) v'\n    (Event_vstore chunk id ofs ev :: nil) m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2'.","conclusion":"exists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr 0)) v'\n    (Event_vstore chunk id ofs ev :: nil) m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b')","proofString":"rewrite Ptrofs.add_zero.\nexists m1'; split.\nconstructor; auto.\nerewrite S; eauto.\neapply eventval_match_inject; eauto.\napply Val.load_result_inject.\nauto.\nintuition auto with mem."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b') : exists m2' : mem,\n  volatile_store ge2 chunk m1' b' ofs v'\n    (Event_vstore chunk id ofs ev :: nil) m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2'.","conclusion":"exists m2' : mem,\n  volatile_store ge2 chunk m1' b' ofs v'\n    (Event_vstore chunk id ofs ev :: nil) m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b')","proofString":"exists m1'; split.\nconstructor; auto.\nerewrite S; eauto.\neapply eventval_match_inject; eauto.\napply Val.load_result_inject.\nauto.\nintuition auto with mem."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b') : volatile_store ge2 chunk m1' b' ofs v' (Event_vstore chunk id ofs ev :: nil)\n  m1'.","conclusion":"volatile_store ge2 chunk m1' b' ofs v' (Event_vstore chunk id ofs ev :: nil)\n  m1'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b')","proofString":"constructor; auto.\nerewrite S; eauto.\neapply eventval_match_inject; eauto.\napply Val.load_result_inject.\nauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b') : Senv.block_is_volatile ge2 b' = true.","conclusion":"Senv.block_is_volatile ge2 b' = true","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b')","proofString":"erewrite S; eauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b') : eventval_match ge2 ev (type_of_chunk chunk) (Val.load_result chunk v').","conclusion":"eventval_match ge2 ev (type_of_chunk chunk) (Val.load_result chunk v')","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b')","proofString":"eapply eventval_match_inject; eauto.\napply Val.load_result_inject.\nauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b') : Val.inject f (Val.load_result chunk v) (Val.load_result chunk v').","conclusion":"Val.inject f (Val.load_result chunk v) (Val.load_result chunk v')","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b')","proofString":"apply Val.load_result_inject.\nauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b') : Val.inject f v v'.","conclusion":"Val.inject f v v'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b')","proofString":"auto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b') : Mem.inject f m2 m1' /\\\nMem.unchanged_on (loc_unmapped f) m2 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m2) m1' m1'.","conclusion":"Mem.inject f m2 m1' /\\\nMem.unchanged_on (loc_unmapped f) m2 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m2) m1' m1'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (VI : Val.inject f v v') (MI : Mem.inject f m2 m1') (P : forall id0 : ident, Senv.public_symbol ge2 id0 = Senv.public_symbol ge1 id0) (Q : forall (id0 : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id0 = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id0 = Some b2) (R : forall (id0 : ident) (b1 : block),\nSenv.public_symbol ge1 id0 = true ->\nSenv.find_symbol ge1 id0 = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id0 = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge1 b = true) (H0 : Senv.find_symbol ge1 id = Some b) (H1 : eventval_match ge1 ev (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : f b = Some (b', 0)) (B : Senv.find_symbol ge2 id = Some b')","proofString":"intuition auto with mem."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (ofs' : ptrofs) (v' : val) (SI : symbols_inject f ge1 ge2) (AI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) : exists m2' : mem,\n  volatile_store ge2 chunk m1' b' ofs' v' E0 m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'.","conclusion":"exists m2' : mem,\n  volatile_store ge2 chunk m1' b' ofs' v' E0 m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (ofs' : ptrofs) (v' : val) (SI : symbols_inject f ge1 ge2) (AI : Val.inject f (Vptr b ofs) (Vptr b' ofs')) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta : Z),\nf b1 = Some (b2, delta) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2)","proofString":"inversion AI; subst.\nassert (Mem.storev chunk m1 (Vptr b ofs) v = Some m2).\nsimpl; auto.\nexploit Mem.storev_mapped_inject; eauto.\nintros [m2' [A B]].\nexists m2'; intuition auto.\nconstructor; auto.\nerewrite S; eauto.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ninv AI; congruence.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\nsimpl in A.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) = Ptrofs.unsigned ofs + delta)  by (eapply Mem.address_inject; eauto with mem).\nrewrite EQ in *.\neelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) : exists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v' E0\n    m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'.","conclusion":"exists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v' E0\n    m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta))","proofString":"assert (Mem.storev chunk m1 (Vptr b ofs) v = Some m2).\nsimpl; auto.\nexploit Mem.storev_mapped_inject; eauto.\nintros [m2' [A B]].\nexists m2'; intuition auto.\nconstructor; auto.\nerewrite S; eauto.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ninv AI; congruence.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\nsimpl in A.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) = Ptrofs.unsigned ofs + delta)  by (eapply Mem.address_inject; eauto with mem).\nrewrite EQ in *.\neelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) : Mem.storev chunk m1 (Vptr b ofs) v = Some m2.","conclusion":"Mem.storev chunk m1 (Vptr b ofs) v = Some m2","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta))","proofString":"simpl; auto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) : exists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v' E0\n    m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'.","conclusion":"exists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v' E0\n    m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2)","proofString":"exploit Mem.storev_mapped_inject; eauto.\nintros [m2' [A B]].\nexists m2'; intuition auto.\nconstructor; auto.\nerewrite S; eauto.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ninv AI; congruence.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\nsimpl in A.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) = Ptrofs.unsigned ofs + delta)  by (eapply Mem.address_inject; eauto with mem).\nrewrite EQ in *.\neelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) : (exists n2 : mem,\n   Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\n   Some n2 /\\ Mem.inject f m2 n2) ->\nexists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v' E0\n    m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'.","conclusion":"(exists n2 : mem,\n   Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\n   Some n2 /\\ Mem.inject f m2 n2) ->\nexists m2' : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v' E0\n    m2' /\\\n  Mem.inject f m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2)","proofString":"intros [m2' [A B]].\nexists m2'; intuition auto.\nconstructor; auto.\nerewrite S; eauto.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ninv AI; congruence.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\nsimpl in A.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) = Ptrofs.unsigned ofs + delta)  by (eapply Mem.address_inject; eauto with mem).\nrewrite EQ in *.\neelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2') : exists m2'0 : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v' E0\n    m2'0 /\\\n  Mem.inject f m2 m2'0 /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'0.","conclusion":"exists m2'0 : mem,\n  volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v' E0\n    m2'0 /\\\n  Mem.inject f m2 m2'0 /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'0","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2')","proofString":"exists m2'; intuition auto.\nconstructor; auto.\nerewrite S; eauto.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ninv AI; congruence.\neapply Mem.store_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\nsimpl in A.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) = Ptrofs.unsigned ofs + delta)  by (eapply Mem.address_inject; eauto with mem).\nrewrite EQ in *.\neelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2') : volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v' E0\n  m2'.","conclusion":"volatile_store ge2 chunk m1' b' (Ptrofs.add ofs (Ptrofs.repr delta)) v' E0\n  m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2')","proofString":"constructor; auto.\nerewrite S; eauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2') : Senv.block_is_volatile ge2 b' = false.","conclusion":"Senv.block_is_volatile ge2 b' = false","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2')","proofString":"erewrite S; eauto."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2') : Mem.unchanged_on (loc_unmapped f) m1 m2.","conclusion":"Mem.unchanged_on (loc_unmapped f) m1 m2","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2')","proofString":"eapply Mem.store_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ninv AI; congruence."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2') : forall i : Z,\nPtrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk ->\n~ loc_unmapped f b i.","conclusion":"forall i : Z,\nPtrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk ->\n~ loc_unmapped f b i","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2')","proofString":"unfold loc_unmapped; intros.\ninv AI; congruence."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk) : f b <> None.","conclusion":"f b <> None","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs <= i < Ptrofs.unsigned ofs + size_chunk chunk)","proofString":"inv AI; congruence."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2') : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'.","conclusion":"Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2')","proofString":"eapply Mem.store_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\nsimpl in A.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) = Ptrofs.unsigned ofs + delta)  by (eapply Mem.address_inject; eauto with mem).\nrewrite EQ in *.\neelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2') : forall i : Z,\nPtrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) + size_chunk chunk ->\n~ loc_out_of_reach f m1 b' i.","conclusion":"forall i : Z,\nPtrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) + size_chunk chunk ->\n~ loc_out_of_reach f m1 b' i","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2')","proofString":"unfold loc_out_of_reach; intros.\nred; intros.\nsimpl in A.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) = Ptrofs.unsigned ofs + delta)  by (eapply Mem.address_inject; eauto with mem).\nrewrite EQ in *.\neelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) + size_chunk chunk) : ~\n(forall (b0 : block) (delta0 : Z),\n f b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty).","conclusion":"~\n(forall (b0 : block) (delta0 : Z),\n f b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty)","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) + size_chunk chunk)","proofString":"red; intros.\nsimpl in A.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) = Ptrofs.unsigned ofs + delta)  by (eapply Mem.address_inject; eauto with mem).\nrewrite EQ in *.\neelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) : False.","conclusion":"False","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.storev chunk m1' (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta))) v' =\nSome m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty)","proofString":"simpl in A.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) = Ptrofs.unsigned ofs + delta)  by (eapply Mem.address_inject; eauto with mem).\nrewrite EQ in *.\neelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))\n  v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) : False.","conclusion":"False","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))\n  v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty)","proofString":"assert (EQ: Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) = Ptrofs.unsigned ofs + delta)  by (eapply Mem.address_inject; eauto with mem).\nrewrite EQ in *.\neelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))\n  v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta) : False.","conclusion":"False","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)))\n  v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) <= i <\nPtrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta)","proofString":"rewrite EQ in *.\neelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned ofs + delta) v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs + delta <= i <\nPtrofs.unsigned ofs + delta + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta) : False.","conclusion":"False","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned ofs + delta) v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs + delta <= i <\nPtrofs.unsigned ofs + delta + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta)","proofString":"eelim H3; eauto.\nexploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned ofs + delta) v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs + delta <= i <\nPtrofs.unsigned ofs + delta + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta) : Mem.perm m1 b (i - delta) Max Nonempty.","conclusion":"Mem.perm m1 b (i - delta) Max Nonempty","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned ofs + delta) v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs + delta <= i <\nPtrofs.unsigned ofs + delta + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta)","proofString":"exploit Mem.store_valid_access_3.\neexact H0.\nintros [X Y].\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned ofs + delta) v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs + delta <= i <\nPtrofs.unsigned ofs + delta + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta) (X : Mem.range_perm m1 b (Ptrofs.unsigned ofs)\n  (Ptrofs.unsigned ofs + size_chunk chunk) Cur Writable) (Y : (align_chunk chunk | Ptrofs.unsigned ofs)) : Mem.perm m1 b (i - delta) Max Nonempty.","conclusion":"Mem.perm m1 b (i - delta) Max Nonempty","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned ofs + delta) v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs + delta <= i <\nPtrofs.unsigned ofs + delta + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta) (X : Mem.range_perm m1 b (Ptrofs.unsigned ofs)\n  (Ptrofs.unsigned ofs + size_chunk chunk) Cur Writable) (Y : (align_chunk chunk | Ptrofs.unsigned ofs))","proofString":"apply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned ofs + delta) v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs + delta <= i <\nPtrofs.unsigned ofs + delta + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta) (X : Mem.range_perm m1 b (Ptrofs.unsigned ofs)\n  (Ptrofs.unsigned ofs + size_chunk chunk) Cur Writable) (Y : (align_chunk chunk | Ptrofs.unsigned ofs)) : Mem.perm m1 b (i - delta) Cur Nonempty.","conclusion":"Mem.perm m1 b (i - delta) Cur Nonempty","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned ofs + delta) v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs + delta <= i <\nPtrofs.unsigned ofs + delta + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta) (X : Mem.range_perm m1 b (Ptrofs.unsigned ofs)\n  (Ptrofs.unsigned ofs + size_chunk chunk) Cur Writable) (Y : (align_chunk chunk | Ptrofs.unsigned ofs))","proofString":"apply Mem.perm_implies with Writable; auto with mem.\napply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned ofs + delta) v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs + delta <= i <\nPtrofs.unsigned ofs + delta + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta) (X : Mem.range_perm m1 b (Ptrofs.unsigned ofs)\n  (Ptrofs.unsigned ofs + size_chunk chunk) Cur Writable) (Y : (align_chunk chunk | Ptrofs.unsigned ofs)) : Mem.perm m1 b (i - delta) Cur Writable.","conclusion":"Mem.perm m1 b (i - delta) Cur Writable","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned ofs + delta) v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs + delta <= i <\nPtrofs.unsigned ofs + delta + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta) (X : Mem.range_perm m1 b (Ptrofs.unsigned ofs)\n  (Ptrofs.unsigned ofs + size_chunk chunk) Cur Writable) (Y : (align_chunk chunk | Ptrofs.unsigned ofs))","proofString":"apply X.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned ofs + delta) v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs + delta <= i <\nPtrofs.unsigned ofs + delta + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta) (X : Mem.range_perm m1 b (Ptrofs.unsigned ofs)\n  (Ptrofs.unsigned ofs + size_chunk chunk) Cur Writable) (Y : (align_chunk chunk | Ptrofs.unsigned ofs)) : Ptrofs.unsigned ofs <= i - delta < Ptrofs.unsigned ofs + size_chunk chunk.","conclusion":"Ptrofs.unsigned ofs <= i - delta < Ptrofs.unsigned ofs + size_chunk chunk","hypotheses":"(ge1 ge2 : Senv.t) (f : block -> option (block * Z)) (chunk : memory_chunk) (m1 : mem) (b : block) (ofs : ptrofs) (v : val) (m2 m1' : mem) (b' : block) (v' : val) (SI : symbols_inject f ge1 ge2) (delta : Z) (AI : Val.inject f (Vptr b ofs) (Vptr b' (Ptrofs.add ofs (Ptrofs.repr delta)))) (VI : Val.inject f v v') (MI : Mem.inject f m1 m1') (P : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (Q : forall (id : ident) (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.find_symbol ge1 id = Some b1 ->\ndelta0 = 0 /\\ Senv.find_symbol ge2 id = Some b2) (R : forall (id : ident) (b1 : block),\nSenv.public_symbol ge1 id = true ->\nSenv.find_symbol ge1 id = Some b1 ->\nexists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge2 id = Some b2) (S : forall (b1 b2 : block) (delta0 : Z),\nf b1 = Some (b2, delta0) ->\nSenv.block_is_volatile ge2 b2 = Senv.block_is_volatile ge1 b1) (H : Senv.block_is_volatile ge1 b = false) (H0 : Mem.store chunk m1 b (Ptrofs.unsigned ofs) v = Some m2) (H4 : f b = Some (b', delta)) (H1 : Mem.storev chunk m1 (Vptr b ofs) v = Some m2) (m2' : mem) (A : Mem.store chunk m1' b' (Ptrofs.unsigned ofs + delta) v' = Some m2') (B : Mem.inject f m2 m2') (i : Z) (H2 : Ptrofs.unsigned ofs + delta <= i <\nPtrofs.unsigned ofs + delta + size_chunk chunk) (H3 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b', delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) (EQ : Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta)) =\nPtrofs.unsigned ofs + delta) (X : Mem.range_perm m1 b (Ptrofs.unsigned ofs)\n  (Ptrofs.unsigned ofs + size_chunk chunk) Cur Writable) (Y : (align_chunk chunk | Ptrofs.unsigned ofs))","proofString":"lia."},{"statement":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (t1 : trace) (m1 : mem) (t2 : trace) (H : volatile_store ge chunk m b ofs v t1 m1) (H0 : match_traces ge t1 t2) : t1 = t2.","conclusion":"t1 = t2","hypotheses":"(ge : Senv.t) (chunk : memory_chunk) (m : mem) (b : block) (ofs : ptrofs) (v : val) (t1 : trace) (m1 : mem) (t2 : trace) (H : volatile_store ge chunk m b ofs v t1 m1) (H0 : match_traces ge t1 t2)","proofString":"inv H; inv H0; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : volatile_store_sem chunk ge vargs m1 t vres m2) : Val.has_rettype vres (sig_res [Xptr; xtype_of_chunk chunk ---> Xvoid]).","conclusion":"Val.has_rettype vres (sig_res [Xptr; xtype_of_chunk chunk ---> Xvoid])","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : volatile_store_sem chunk ge vargs m1 t vres m2)","proofString":"unfold proj_sig_res; simpl.\ninv H; constructor."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : volatile_store_sem chunk ge vargs m1 t vres m2) : match vres with\n| Vundef => True\n| _ => False\nend.","conclusion":"match vres with\n| Vundef => True\n| _ => False\nend","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : volatile_store_sem chunk ge vargs m1 t vres m2)","proofString":"inv H; constructor."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : volatile_store_sem chunk ge1 vargs m1 t vres m2) : volatile_store_sem chunk ge2 vargs m1 t vres m2.","conclusion":"volatile_store_sem chunk ge2 vargs m1 t vres m2","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : volatile_store_sem chunk ge1 vargs m1 t vres m2)","proofString":"inv H0.\nconstructor.\neapply volatile_store_preserved; eauto."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (H : Senv.equiv ge1 ge2) (b : block) (ofs : ptrofs) (v : val) (H1 : volatile_store ge1 chunk m1 b ofs v t m2) : volatile_store_sem chunk ge2 (Vptr b ofs :: v :: nil) m1 t Vundef m2.","conclusion":"volatile_store_sem chunk ge2 (Vptr b ofs :: v :: nil) m1 t Vundef m2","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (H : Senv.equiv ge1 ge2) (b : block) (ofs : ptrofs) (v : val) (H1 : volatile_store ge1 chunk m1 b ofs v t m2)","proofString":"constructor.\neapply volatile_store_preserved; eauto."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (H : Senv.equiv ge1 ge2) (b : block) (ofs : ptrofs) (v : val) (H1 : volatile_store ge1 chunk m1 b ofs v t m2) : volatile_store ge2 chunk m1 b ofs v t m2.","conclusion":"volatile_store ge2 chunk m1 b ofs v t m2","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (H : Senv.equiv ge1 ge2) (b : block) (ofs : ptrofs) (v : val) (H1 : volatile_store ge1 chunk m1 b ofs v t m2)","proofString":"eapply volatile_store_preserved; eauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : volatile_store_sem chunk ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : volatile_store_sem chunk ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b)","proofString":"inv H.\ninv H1.\nauto.\neauto with mem."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (b : block) (H0 : Mem.valid_block m1 b) (b0 : block) (ofs : ptrofs) (v : val) (H1 : volatile_store ge chunk m1 b0 ofs v t m2) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (b : block) (H0 : Mem.valid_block m1 b) (b0 : block) (ofs : ptrofs) (v : val) (H1 : volatile_store ge chunk m1 b0 ofs v t m2)","proofString":"inv H1.\nauto.\neauto with mem."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (H0 : Mem.valid_block m2 b) (b0 : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b0 = true) (H2 : Senv.find_symbol ge id = Some b0) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (H0 : Mem.valid_block m2 b) (b0 : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b0 = true) (H2 : Senv.find_symbol ge id = Some b0) (H3 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 m2 : mem) (b : block) (H0 : Mem.valid_block m1 b) (b0 : block) (ofs : ptrofs) (v : val) (H : Senv.block_is_volatile ge b0 = false) (H2 : Mem.store chunk m1 b0 (Ptrofs.unsigned ofs) v = Some m2) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 m2 : mem) (b : block) (H0 : Mem.valid_block m1 b) (b0 : block) (ofs : ptrofs) (v : val) (H : Senv.block_is_volatile ge b0 = false) (H2 : Mem.store chunk m1 b0 (Ptrofs.unsigned ofs) v = Some m2)","proofString":"eauto with mem."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : volatile_store_sem chunk ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) : Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : volatile_store_sem chunk ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p)","proofString":"inv H.\ninv H2.\nauto.\neauto with mem."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) (b0 : block) (ofs0 : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b0 ofs0 v t m2) : Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) (b0 : block) (ofs0 : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b0 ofs0 v t m2)","proofString":"inv H2.\nauto.\neauto with mem."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m2 b) (H1 : Mem.perm m2 b ofs Max p) (b0 : block) (ofs0 : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b0 = true) (H3 : Senv.find_symbol ge id = Some b0) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) : Mem.perm m2 b ofs Max p.","conclusion":"Mem.perm m2 b ofs Max p","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m2 b) (H1 : Mem.perm m2 b ofs Max p) (b0 : block) (ofs0 : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b0 = true) (H3 : Senv.find_symbol ge id = Some b0) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) (b0 : block) (ofs0 : ptrofs) (v : val) (H : Senv.block_is_volatile ge b0 = false) (H3 : Mem.store chunk m1 b0 (Ptrofs.unsigned ofs0) v = Some m2) : Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) (b0 : block) (ofs0 : ptrofs) (v : val) (H : Senv.block_is_volatile ge b0 = false) (H3 : Mem.store chunk m1 b0 (Ptrofs.unsigned ofs0) v = Some m2)","proofString":"eauto with mem."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : volatile_store_sem chunk ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) : Mem.loadbytes m1 b ofs n = Some bytes.","conclusion":"Mem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : volatile_store_sem chunk ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable)","proofString":"inv H.\neapply unchanged_on_readonly; eauto.\neapply volatile_store_readonly; eauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (b0 : block) (ofs0 : ptrofs) (v : val) (H3 : volatile_store ge chunk m1 b0 ofs0 v t m2) : Mem.loadbytes m1 b ofs n = Some bytes.","conclusion":"Mem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (b0 : block) (ofs0 : ptrofs) (v : val) (H3 : volatile_store ge chunk m1 b0 ofs0 v t m2)","proofString":"eapply unchanged_on_readonly; eauto.\neapply volatile_store_readonly; eauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (b0 : block) (ofs0 : ptrofs) (v : val) (H3 : volatile_store ge chunk m1 b0 ofs0 v t m2) : Mem.unchanged_on (loc_not_writable m1) m1 m2.","conclusion":"Mem.unchanged_on (loc_not_writable m1) m1 m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (b0 : block) (ofs0 : ptrofs) (v : val) (H3 : volatile_store ge chunk m1 b0 ofs0 v t m2)","proofString":"eapply volatile_store_readonly; eauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : volatile_store_sem chunk ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs') : exists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : volatile_store_sem chunk ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs')","proofString":"inv H.\ninv H1.\ninv H6.\ninv H7.\ninv H4.\nexploit volatile_store_extends; eauto.\nintros [m2' [A [B C]]].\nexists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H1 : Val.lessdef_list (Vptr b ofs :: v :: nil) vargs') (H2 : volatile_store ge chunk m1 b ofs v t m2) : exists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge vargs' m1' t vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge vargs' m1' t vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H1 : Val.lessdef_list (Vptr b ofs :: v :: nil) vargs') (H2 : volatile_store ge chunk m1 b ofs v t m2)","proofString":"inv H1.\ninv H6.\ninv H7.\ninv H4.\nexploit volatile_store_extends; eauto.\nintros [m2' [A [B C]]].\nexists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v2 : val) (vl2 : list val) (H4 : Val.lessdef (Vptr b ofs) v2) (H6 : Val.lessdef_list (v :: nil) vl2) : exists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge (v2 :: vl2) m1' t vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge (v2 :: vl2) m1' t vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v2 : val) (vl2 : list val) (H4 : Val.lessdef (Vptr b ofs) v2) (H6 : Val.lessdef_list (v :: nil) vl2)","proofString":"inv H6.\ninv H7.\ninv H4.\nexploit volatile_store_extends; eauto.\nintros [m2' [A [B C]]].\nexists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v2 : val) (H4 : Val.lessdef (Vptr b ofs) v2) (v0 : val) (vl0 : list val) (H3 : Val.lessdef v v0) (H7 : Val.lessdef_list nil vl0) : exists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge (v2 :: v0 :: vl0) m1' t vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge (v2 :: v0 :: vl0) m1' t vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v2 : val) (H4 : Val.lessdef (Vptr b ofs) v2) (v0 : val) (vl0 : list val) (H3 : Val.lessdef v v0) (H7 : Val.lessdef_list nil vl0)","proofString":"inv H7.\ninv H4.\nexploit volatile_store_extends; eauto.\nintros [m2' [A [B C]]].\nexists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v2 : val) (H4 : Val.lessdef (Vptr b ofs) v2) (v0 : val) (H3 : Val.lessdef v v0) : exists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge (v2 :: v0 :: nil) m1' t vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge (v2 :: v0 :: nil) m1' t vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v2 : val) (H4 : Val.lessdef (Vptr b ofs) v2) (v0 : val) (H3 : Val.lessdef v v0)","proofString":"inv H4.\nexploit volatile_store_extends; eauto.\nintros [m2' [A [B C]]].\nexists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v0 : val) (H3 : Val.lessdef v v0) : exists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge (Vptr b ofs :: v0 :: nil) m1' t vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge (Vptr b ofs :: v0 :: nil) m1' t vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v0 : val) (H3 : Val.lessdef v v0)","proofString":"exploit volatile_store_extends; eauto.\nintros [m2' [A [B C]]].\nexists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v0 : val) (H3 : Val.lessdef v v0) : (exists m2' : mem,\n   volatile_store ge chunk m1' b ofs v0 t m2' /\\\n   Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2') ->\nexists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge (Vptr b ofs :: v0 :: nil) m1' t vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"(exists m2' : mem,\n   volatile_store ge chunk m1' b ofs v0 t m2' /\\\n   Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2') ->\nexists (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge (Vptr b ofs :: v0 :: nil) m1' t vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v0 : val) (H3 : Val.lessdef v v0)","proofString":"intros [m2' [A [B C]]].\nexists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v0 : val) (H3 : Val.lessdef v v0) (m2' : mem) (A : volatile_store ge chunk m1' b ofs v0 t m2') (B : Mem.extends m2 m2') (C : Mem.unchanged_on (loc_out_of_bounds m1) m1' m2') : exists (vres' : val) (m2'0 : mem),\n  volatile_store_sem chunk ge (Vptr b ofs :: v0 :: nil) m1' t vres' m2'0 /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2'0 /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'0.","conclusion":"exists (vres' : val) (m2'0 : mem),\n  volatile_store_sem chunk ge (Vptr b ofs :: v0 :: nil) m1' t vres' m2'0 /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2'0 /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'0","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v0 : val) (H3 : Val.lessdef v v0) (m2' : mem) (A : volatile_store ge chunk m1' b ofs v0 t m2') (B : Mem.extends m2 m2') (C : Mem.unchanged_on (loc_out_of_bounds m1) m1' m2')","proofString":"exists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v0 : val) (H3 : Val.lessdef v v0) (m2' : mem) (A : volatile_store ge chunk m1' b ofs v0 t m2') (B : Mem.extends m2 m2') (C : Mem.unchanged_on (loc_out_of_bounds m1) m1' m2') : volatile_store_sem chunk ge (Vptr b ofs :: v0 :: nil) m1' t Vundef m2'.","conclusion":"volatile_store_sem chunk ge (Vptr b ofs :: v0 :: nil) m1' t Vundef m2'","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m1 : mem) (t : trace) (m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : volatile_store ge chunk m1 b ofs v t m2) (v0 : val) (H3 : Val.lessdef v v0) (m2' : mem) (A : volatile_store ge chunk m1' b ofs v0 t m2') (B : Mem.extends m2 m2') (C : Mem.unchanged_on (loc_out_of_bounds m1) m1' m2')","proofString":"constructor; auto."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : volatile_store_sem chunk ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : volatile_store_sem chunk ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"inv H0.\ninv H2.\ninv H7.\ninv H8.\ninversion H5; subst.\nexploit volatile_store_inject; eauto.\nintros [m2' [A [B [C D]]]].\nexists f; exists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto.\nred; intros; congruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : Val.inject_list f (Vptr b ofs :: v :: nil) vargs') (H3 : volatile_store ge1 chunk m1 b ofs v t m2) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H2 : Val.inject_list f (Vptr b ofs :: v :: nil) vargs') (H3 : volatile_store ge1 chunk m1 b ofs v t m2)","proofString":"inv H2.\ninv H7.\ninv H8.\ninversion H5; subst.\nexploit volatile_store_inject; eauto.\nintros [m2' [A [B [C D]]]].\nexists f; exists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto.\nred; intros; congruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (v' : val) (vl' : list val) (H5 : Val.inject f (Vptr b ofs) v') (H7 : Val.inject_list f (v :: nil) vl') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2 (v' :: vl') m1' t vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2 (v' :: vl') m1' t vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (v' : val) (vl' : list val) (H5 : Val.inject f (Vptr b ofs) v') (H7 : Val.inject_list f (v :: nil) vl')","proofString":"inv H7.\ninv H8.\ninversion H5; subst.\nexploit volatile_store_inject; eauto.\nintros [m2' [A [B [C D]]]].\nexists f; exists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto.\nred; intros; congruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (v' : val) (H5 : Val.inject f (Vptr b ofs) v') (v'0 : val) (vl'0 : list val) (H4 : Val.inject f v v'0) (H8 : Val.inject_list f nil vl'0) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2 (v' :: v'0 :: vl'0) m1' t vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2 (v' :: v'0 :: vl'0) m1' t vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (v' : val) (H5 : Val.inject f (Vptr b ofs) v') (v'0 : val) (vl'0 : list val) (H4 : Val.inject f v v'0) (H8 : Val.inject_list f nil vl'0)","proofString":"inv H8.\ninversion H5; subst.\nexploit volatile_store_inject; eauto.\nintros [m2' [A [B [C D]]]].\nexists f; exists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto.\nred; intros; congruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (v' : val) (H5 : Val.inject f (Vptr b ofs) v') (v'0 : val) (H4 : Val.inject f v v'0) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2 (v' :: v'0 :: nil) m1' t vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2 (v' :: v'0 :: nil) m1' t vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (v' : val) (H5 : Val.inject f (Vptr b ofs) v') (v'0 : val) (H4 : Val.inject f v v'0)","proofString":"inversion H5; subst.\nexploit volatile_store_inject; eauto.\nintros [m2' [A [B [C D]]]].\nexists f; exists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto.\nred; intros; congruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (v'0 : val) (H4 : Val.inject f v v'0) (H6 : f b = Some (b2, delta)) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2\n    (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: v'0 :: nil) m1' t vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2\n    (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: v'0 :: nil) m1' t vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (v'0 : val) (H4 : Val.inject f v v'0) (H6 : f b = Some (b2, delta))","proofString":"exploit volatile_store_inject; eauto.\nintros [m2' [A [B [C D]]]].\nexists f; exists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto.\nred; intros; congruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (v'0 : val) (H4 : Val.inject f v v'0) (H6 : f b = Some (b2, delta)) : (exists m2' : mem,\n   volatile_store ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) v'0 t\n     m2' /\\\n   Mem.inject f m2 m2' /\\\n   Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n   Mem.unchanged_on (loc_out_of_reach f m1) m1' m2') ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2\n    (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: v'0 :: nil) m1' t vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"(exists m2' : mem,\n   volatile_store ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) v'0 t\n     m2' /\\\n   Mem.inject f m2 m2' /\\\n   Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n   Mem.unchanged_on (loc_out_of_reach f m1) m1' m2') ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  volatile_store_sem chunk ge2\n    (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: v'0 :: nil) m1' t vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (v'0 : val) (H4 : Val.inject f v v'0) (H6 : f b = Some (b2, delta))","proofString":"intros [m2' [A [B [C D]]]].\nexists f; exists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto.\nred; intros; congruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (v'0 : val) (H4 : Val.inject f v v'0) (H6 : f b = Some (b2, delta)) (m2' : mem) (A : volatile_store ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) v'0 t\n  m2') (B : Mem.inject f m2 m2') (C : Mem.unchanged_on (loc_unmapped f) m1 m2) (D : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2') : exists (f' : meminj) (vres' : val) (m2'0 : mem),\n  volatile_store_sem chunk ge2\n    (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: v'0 :: nil) m1' t vres'\n    m2'0 /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2'0 /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'0 /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2'0 : mem),\n  volatile_store_sem chunk ge2\n    (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: v'0 :: nil) m1' t vres'\n    m2'0 /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2'0 /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'0 /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (v'0 : val) (H4 : Val.inject f v v'0) (H6 : f b = Some (b2, delta)) (m2' : mem) (A : volatile_store ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) v'0 t\n  m2') (B : Mem.inject f m2 m2') (C : Mem.unchanged_on (loc_unmapped f) m1 m2) (D : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2')","proofString":"exists f; exists Vundef; exists m2'; intuition auto with mem.\nconstructor; auto.\nred; intros; congruence."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (v'0 : val) (H4 : Val.inject f v v'0) (H6 : f b = Some (b2, delta)) (m2' : mem) (A : volatile_store ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) v'0 t\n  m2') (B : Mem.inject f m2 m2') (C : Mem.unchanged_on (loc_unmapped f) m1 m2) (D : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2') : volatile_store_sem chunk ge2\n  (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: v'0 :: nil) m1' t Vundef\n  m2'.","conclusion":"volatile_store_sem chunk ge2\n  (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)) :: v'0 :: nil) m1' t Vundef\n  m2'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (v'0 : val) (H4 : Val.inject f v v'0) (H6 : f b = Some (b2, delta)) (m2' : mem) (A : volatile_store ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) v'0 t\n  m2') (B : Mem.inject f m2 m2') (C : Mem.unchanged_on (loc_unmapped f) m1 m2) (D : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2')","proofString":"constructor; auto."},{"statement":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (v'0 : val) (H4 : Val.inject f v v'0) (H6 : f b = Some (b2, delta)) (m2' : mem) (A : volatile_store ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) v'0 t\n  m2') (B : Mem.inject f m2 m2') (C : Mem.unchanged_on (loc_unmapped f) m1 m2) (D : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2') : inject_separated f f m1 m1'.","conclusion":"inject_separated f f m1 m1'","hypotheses":"(chunk : memory_chunk) (ge1 ge2 : Senv.t) (m1 : mem) (t : trace) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (ofs : ptrofs) (v : val) (H3 : volatile_store ge1 chunk m1 b ofs v t m2) (b2 : block) (delta : Z) (H5 : Val.inject f (Vptr b ofs) (Vptr b2 (Ptrofs.add ofs (Ptrofs.repr delta)))) (v'0 : val) (H4 : Val.inject f v v'0) (H6 : f b = Some (b2, delta)) (m2' : mem) (A : volatile_store ge2 chunk m1' b2 (Ptrofs.add ofs (Ptrofs.repr delta)) v'0 t\n  m2') (B : Mem.inject f m2 m2') (C : Mem.unchanged_on (loc_unmapped f) m1 m2) (D : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2')","proofString":"red; intros; congruence."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : volatile_store_sem chunk ge vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : volatile_store_sem chunk ge vargs m t vres m')","proofString":"inv H; inv H0; simpl; lia."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : volatile_store_sem chunk ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : exists (vres2 : val) (m2 : mem),\n  volatile_store_sem chunk ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  volatile_store_sem chunk ge vargs m t2 vres2 m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : volatile_store_sem chunk ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"assert (t1 = t2).\ninv H.\neapply volatile_store_receptive; eauto.\nsubst t2; exists vres1; exists m1; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : volatile_store_sem chunk ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : t1 = t2.","conclusion":"t1 = t2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : volatile_store_sem chunk ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"inv H.\neapply volatile_store_receptive; eauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m : mem) (t1 : trace) (m1 : mem) (t2 : trace) (H0 : match_traces ge t1 t2) (b : block) (ofs : ptrofs) (v : val) (H1 : volatile_store ge chunk m b ofs v t1 m1) : t1 = t2.","conclusion":"t1 = t2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m : mem) (t1 : trace) (m1 : mem) (t2 : trace) (H0 : match_traces ge t1 t2) (b : block) (ofs : ptrofs) (v : val) (H1 : volatile_store ge chunk m b ofs v t1 m1)","proofString":"eapply volatile_store_receptive; eauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : volatile_store_sem chunk ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) (H1 : t1 = t2) : exists (vres2 : val) (m2 : mem),\n  volatile_store_sem chunk ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  volatile_store_sem chunk ge vargs m t2 vres2 m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : volatile_store_sem chunk ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) (H1 : t1 = t2)","proofString":"subst t2; exists vres1; exists m1; auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : volatile_store_sem chunk ge vargs m t1 vres1 m1) (H0 : volatile_store_sem chunk ge vargs m t2 vres2 m2) : match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2).","conclusion":"match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : volatile_store_sem chunk ge vargs m t1 vres1 m1) (H0 : volatile_store_sem chunk ge vargs m t2 vres2 m2)","proofString":"inv H; inv H0.\ninv H1; inv H8; try congruence.\nassert (id = id0) by (eapply Senv.find_symbol_injective; eauto).\nsubst id0.\nassert (ev = ev0) by (eapply eventval_match_determ_2; eauto).\nsubst ev0.\nsplit.\nconstructor.\nauto.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m : mem) (t1 : trace) (m1 : mem) (t2 : trace) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (H1 : volatile_store ge chunk m b ofs v t1 m1) (H8 : volatile_store ge chunk m b ofs v t2 m2) : match_traces ge t1 t2 /\\ (t1 = t2 -> Vundef = Vundef /\\ m1 = m2).","conclusion":"match_traces ge t1 t2 /\\ (t1 = t2 -> Vundef = Vundef /\\ m1 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m : mem) (t1 : trace) (m1 : mem) (t2 : trace) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (H1 : volatile_store ge chunk m b ofs v t1 m1) (H8 : volatile_store ge chunk m b ofs v t2 m2)","proofString":"inv H1; inv H8; try congruence.\nassert (id = id0) by (eapply Senv.find_symbol_injective; eauto).\nsubst id0.\nassert (ev = ev0) by (eapply eventval_match_determ_2; eauto).\nsubst ev0.\nsplit.\nconstructor.\nauto.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (id0 : ident) (ev0 : eventval) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id0 = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) (Val.load_result chunk v)) : match_traces ge (Event_vstore chunk id ofs ev :: nil)\n  (Event_vstore chunk id0 ofs ev0 :: nil) /\\\n(Event_vstore chunk id ofs ev :: nil = Event_vstore chunk id0 ofs ev0 :: nil ->\n Vundef = Vundef /\\ m2 = m2).","conclusion":"match_traces ge (Event_vstore chunk id ofs ev :: nil)\n  (Event_vstore chunk id0 ofs ev0 :: nil) /\\\n(Event_vstore chunk id ofs ev :: nil = Event_vstore chunk id0 ofs ev0 :: nil ->\n Vundef = Vundef /\\ m2 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (id0 : ident) (ev0 : eventval) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id0 = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"assert (id = id0) by (eapply Senv.find_symbol_injective; eauto).\nsubst id0.\nassert (ev = ev0) by (eapply eventval_match_determ_2; eauto).\nsubst ev0.\nsplit.\nconstructor.\nauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (id0 : ident) (ev0 : eventval) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id0 = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : id = id0) : match_traces ge (Event_vstore chunk id ofs ev :: nil)\n  (Event_vstore chunk id0 ofs ev0 :: nil) /\\\n(Event_vstore chunk id ofs ev :: nil = Event_vstore chunk id0 ofs ev0 :: nil ->\n Vundef = Vundef /\\ m2 = m2).","conclusion":"match_traces ge (Event_vstore chunk id ofs ev :: nil)\n  (Event_vstore chunk id0 ofs ev0 :: nil) /\\\n(Event_vstore chunk id ofs ev :: nil = Event_vstore chunk id0 ofs ev0 :: nil ->\n Vundef = Vundef /\\ m2 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (id0 : ident) (ev0 : eventval) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id0 = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : id = id0)","proofString":"subst id0.\nassert (ev = ev0) by (eapply eventval_match_determ_2; eauto).\nsubst ev0.\nsplit.\nconstructor.\nauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (ev0 : eventval) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) (Val.load_result chunk v)) : match_traces ge (Event_vstore chunk id ofs ev :: nil)\n  (Event_vstore chunk id ofs ev0 :: nil) /\\\n(Event_vstore chunk id ofs ev :: nil = Event_vstore chunk id ofs ev0 :: nil ->\n Vundef = Vundef /\\ m2 = m2).","conclusion":"match_traces ge (Event_vstore chunk id ofs ev :: nil)\n  (Event_vstore chunk id ofs ev0 :: nil) /\\\n(Event_vstore chunk id ofs ev :: nil = Event_vstore chunk id ofs ev0 :: nil ->\n Vundef = Vundef /\\ m2 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (ev0 : eventval) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"assert (ev = ev0) by (eapply eventval_match_determ_2; eauto).\nsubst ev0.\nsplit.\nconstructor.\nauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (ev0 : eventval) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : ev = ev0) : match_traces ge (Event_vstore chunk id ofs ev :: nil)\n  (Event_vstore chunk id ofs ev0 :: nil) /\\\n(Event_vstore chunk id ofs ev :: nil = Event_vstore chunk id ofs ev0 :: nil ->\n Vundef = Vundef /\\ m2 = m2).","conclusion":"match_traces ge (Event_vstore chunk id ofs ev :: nil)\n  (Event_vstore chunk id ofs ev0 :: nil) /\\\n(Event_vstore chunk id ofs ev :: nil = Event_vstore chunk id ofs ev0 :: nil ->\n Vundef = Vundef /\\ m2 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (ev0 : eventval) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev0 (type_of_chunk chunk) (Val.load_result chunk v)) (H5 : ev = ev0)","proofString":"subst ev0.\nsplit.\nconstructor.\nauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) : match_traces ge (Event_vstore chunk id ofs ev :: nil)\n  (Event_vstore chunk id ofs ev :: nil) /\\\n(Event_vstore chunk id ofs ev :: nil = Event_vstore chunk id ofs ev :: nil ->\n Vundef = Vundef /\\ m2 = m2).","conclusion":"match_traces ge (Event_vstore chunk id ofs ev :: nil)\n  (Event_vstore chunk id ofs ev :: nil) /\\\n(Event_vstore chunk id ofs ev :: nil = Event_vstore chunk id ofs ev :: nil ->\n Vundef = Vundef /\\ m2 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"split.\nconstructor.\nauto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) : match_traces ge (Event_vstore chunk id ofs ev :: nil)\n  (Event_vstore chunk id ofs ev :: nil).","conclusion":"match_traces ge (Event_vstore chunk id ofs ev :: nil)\n  (Event_vstore chunk id ofs ev :: nil)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"constructor."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) : Event_vstore chunk id ofs ev :: nil = Event_vstore chunk id ofs ev :: nil ->\nVundef = Vundef /\\ m2 = m2.","conclusion":"Event_vstore chunk id ofs ev :: nil = Event_vstore chunk id ofs ev :: nil ->\nVundef = Vundef /\\ m2 = m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m2 : mem) (b : block) (ofs : ptrofs) (v : val) (id : ident) (ev : eventval) (H : Senv.block_is_volatile ge b = true) (H0 : Senv.find_symbol ge id = Some b) (H2 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v)) (H1 : Senv.block_is_volatile ge b = true) (H3 : Senv.find_symbol ge id = Some b) (H4 : eventval_match ge ev (type_of_chunk chunk) (Val.load_result chunk v))","proofString":"auto."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m m1 m2 : mem) (b : block) (ofs : ptrofs) (v : val) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m1) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m2) : match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m1 = m2).","conclusion":"match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m1 = m2)","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m m1 m2 : mem) (b : block) (ofs : ptrofs) (v : val) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m1) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m2)","proofString":"split.\nconstructor.\nintuition congruence."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m m1 m2 : mem) (b : block) (ofs : ptrofs) (v : val) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m1) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m2) : match_traces ge E0 E0.","conclusion":"match_traces ge E0 E0","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m m1 m2 : mem) (b : block) (ofs : ptrofs) (v : val) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m1) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m2)","proofString":"constructor."},{"statement":"(chunk : memory_chunk) (ge : Senv.t) (m m1 m2 : mem) (b : block) (ofs : ptrofs) (v : val) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m1) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m2) : E0 = E0 -> Vundef = Vundef /\\ m1 = m2.","conclusion":"E0 = E0 -> Vundef = Vundef /\\ m1 = m2","hypotheses":"(chunk : memory_chunk) (ge : Senv.t) (m m1 m2 : mem) (b : block) (ofs : ptrofs) (v : val) (H : Senv.block_is_volatile ge b = false) (H0 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m1) (H1 : Senv.block_is_volatile ge b = false) (H2 : Mem.store chunk m b (Ptrofs.unsigned ofs) v = Some m2)","proofString":"intuition congruence."},{"statement":"forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m m''.","conclusion":"forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m m''","hypotheses":"","proofString":"intros.\napply Mem.unchanged_on_implies with (fun b1 ofs1 => b1 <> b).\napply Mem.unchanged_on_trans with m'.\neapply Mem.alloc_unchanged_on; eauto.\neapply Mem.store_unchanged_on; eauto.\nintros.\neapply Mem.valid_not_valid_diff; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m : mem) (lo hi : Z) (v : val) (m' : Mem.mem') (b : block) (m'' : mem) (H : Mem.alloc m lo hi = (m', b)) (H0 : Mem.store Mptr m' b lo v = Some m'') : Mem.unchanged_on P m m''.","conclusion":"Mem.unchanged_on P m m''","hypotheses":"(P : block -> Z -> Prop) (m : mem) (lo hi : Z) (v : val) (m' : Mem.mem') (b : block) (m'' : mem) (H : Mem.alloc m lo hi = (m', b)) (H0 : Mem.store Mptr m' b lo v = Some m'')","proofString":"apply Mem.unchanged_on_implies with (fun b1 ofs1 => b1 <> b).\napply Mem.unchanged_on_trans with m'.\neapply Mem.alloc_unchanged_on; eauto.\neapply Mem.store_unchanged_on; eauto.\nintros.\neapply Mem.valid_not_valid_diff; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m : mem) (lo hi : Z) (v : val) (m' : Mem.mem') (b : block) (m'' : mem) (H : Mem.alloc m lo hi = (m', b)) (H0 : Mem.store Mptr m' b lo v = Some m'') : Mem.unchanged_on (fun (b1 : block) (_ : Z) => b1 <> b) m m''.","conclusion":"Mem.unchanged_on (fun (b1 : block) (_ : Z) => b1 <> b) m m''","hypotheses":"(P : block -> Z -> Prop) (m : mem) (lo hi : Z) (v : val) (m' : Mem.mem') (b : block) (m'' : mem) (H : Mem.alloc m lo hi = (m', b)) (H0 : Mem.store Mptr m' b lo v = Some m'')","proofString":"apply Mem.unchanged_on_trans with m'.\neapply Mem.alloc_unchanged_on; eauto.\neapply Mem.store_unchanged_on; eauto."},{"statement":"(P : block -> Z -> Prop) (m : mem) (lo hi : Z) (v : val) (m' : Mem.mem') (b : block) (m'' : mem) (H : Mem.alloc m lo hi = (m', b)) (H0 : Mem.store Mptr m' b lo v = Some m'') : Mem.unchanged_on (fun (b1 : block) (_ : Z) => b1 <> b) m m'.","conclusion":"Mem.unchanged_on (fun (b1 : block) (_ : Z) => b1 <> b) m m'","hypotheses":"(P : block -> Z -> Prop) (m : mem) (lo hi : Z) (v : val) (m' : Mem.mem') (b : block) (m'' : mem) (H : Mem.alloc m lo hi = (m', b)) (H0 : Mem.store Mptr m' b lo v = Some m'')","proofString":"eapply Mem.alloc_unchanged_on; eauto."},{"statement":"(P : block -> Z -> Prop) (m : mem) (lo hi : Z) (v : val) (m' : Mem.mem') (b : block) (m'' : mem) (H : Mem.alloc m lo hi = (m', b)) (H0 : Mem.store Mptr m' b lo v = Some m'') : Mem.unchanged_on (fun (b1 : block) (_ : Z) => b1 <> b) m' m''.","conclusion":"Mem.unchanged_on (fun (b1 : block) (_ : Z) => b1 <> b) m' m''","hypotheses":"(P : block -> Z -> Prop) (m : mem) (lo hi : Z) (v : val) (m' : Mem.mem') (b : block) (m'' : mem) (H : Mem.alloc m lo hi = (m', b)) (H0 : Mem.store Mptr m' b lo v = Some m'')","proofString":"eapply Mem.store_unchanged_on; eauto."},{"statement":"(P : block -> Z -> Prop) (m : mem) (lo hi : Z) (v : val) (m' : Mem.mem') (b : block) (m'' : mem) (H : Mem.alloc m lo hi = (m', b)) (H0 : Mem.store Mptr m' b lo v = Some m'') : forall (b0 : block) (ofs : Z), P b0 ofs -> Mem.valid_block m b0 -> b0 <> b.","conclusion":"forall (b0 : block) (ofs : Z), P b0 ofs -> Mem.valid_block m b0 -> b0 <> b","hypotheses":"(P : block -> Z -> Prop) (m : mem) (lo hi : Z) (v : val) (m' : Mem.mem') (b : block) (m'' : mem) (H : Mem.alloc m lo hi = (m', b)) (H0 : Mem.store Mptr m' b lo v = Some m'')","proofString":"intros.\neapply Mem.valid_not_valid_diff; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m : mem) (lo hi : Z) (v : val) (m' : Mem.mem') (b : block) (m'' : mem) (H : Mem.alloc m lo hi = (m', b)) (H0 : Mem.store Mptr m' b lo v = Some m'') (b0 : block) (ofs : Z) (H1 : P b0 ofs) (H2 : Mem.valid_block m b0) : b0 <> b.","conclusion":"b0 <> b","hypotheses":"(P : block -> Z -> Prop) (m : mem) (lo hi : Z) (v : val) (m' : Mem.mem') (b : block) (m'' : mem) (H : Mem.alloc m lo hi = (m', b)) (H0 : Mem.store Mptr m' b lo v = Some m'') (b0 : block) (ofs : Z) (H1 : P b0 ofs) (H2 : Mem.valid_block m b0)","proofString":"eapply Mem.valid_not_valid_diff; eauto with mem."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m m'') : extcall_properties extcall_malloc_sem [Xsize_t ---> Xptr].","conclusion":"extcall_properties extcall_malloc_sem [Xsize_t ---> Xptr]","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m m'')","proofString":"constructor; intros.\ninv H.\nsimpl.\nunfold Tptr; destruct Archi.ptr64; auto.\ninv H0; econstructor; eauto.\ninv H.\neauto with mem.\ninv H.\nexploit Mem.perm_alloc_inv.\neauto.\neapply Mem.perm_store_2; eauto.\nrewrite dec_eq_false.\nauto.\napply Mem.valid_not_valid_diff with m1; eauto with mem.\ninv H.\neapply unchanged_on_readonly; eauto.\ninv H.\ninv H1.\ninv H7.\nassert (SZ: v2 = Vptrofs sz).\nunfold Vptrofs in *.\ndestruct Archi.ptr64; inv H5; auto.\nsubst v2.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [m3' [A B]].\nexploit Mem.store_within_extends.\neexact B.\neauto.\neauto.\nintros [m2' [C D]].\nexists (Vptr b Ptrofs.zero); exists m2'; intuition auto with mem.\neconstructor; eauto.\neapply UNCHANGED; eauto.\ninv H0.\ninv H2.\ninv H8.\nassert (SZ: v' = Vptrofs sz).\nunfold Vptrofs in *.\ndestruct Archi.ptr64; inv H6; auto.\nsubst v'.\nexploit Mem.alloc_parallel_inject; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [f' [m3' [b' [ALLOC [A [B [C D]]]]]]].\nexploit Mem.store_mapped_inject.\neexact A.\neauto.\neauto.\ninstantiate (1 := Vptrofs sz).\nunfold Vptrofs; destruct Archi.ptr64; constructor.\nrewrite Z.add_0_r.\nintros [m2' [E G]].\nexists f'; exists (Vptr b' Ptrofs.zero); exists m2'; intuition auto.\neconstructor; eauto.\neconstructor.\neauto.\nauto.\neapply UNCHANGED; eauto.\neapply UNCHANGED; eauto.\nred; intros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite C in H2.\ninv H2.\neauto with mem.\nrewrite D in H2 by auto.\ncongruence.\ninv H; simpl; lia.\nassert (t1 = t2).\ninv H; inv H0; auto.\nsubst t2.\nexists vres1; exists m1; auto.\ninv H.\nsimple inversion H0.\nassert (EQ2: sz0 = sz).\nunfold Vptrofs in H4; destruct Archi.ptr64 eqn:SF.\nrewrite <- (Ptrofs.of_int64_to_int64 SF sz0), <- (Ptrofs.of_int64_to_int64 SF sz).\ncongruence.\nrewrite <- (Ptrofs.of_int_to_int SF sz0), <- (Ptrofs.of_int_to_int SF sz).\ncongruence.\nsubst.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : extcall_malloc_sem ge vargs m1 t vres m2) : Val.has_rettype vres (sig_res [Xsize_t ---> Xptr]).","conclusion":"Val.has_rettype vres (sig_res [Xsize_t ---> Xptr])","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : extcall_malloc_sem ge vargs m1 t vres m2)","proofString":"inv H.\nsimpl.\nunfold Tptr; destruct Archi.ptr64; auto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (sz : ptrofs) (m' : Mem.mem') (b : block) (H0 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H1 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) : Val.has_rettype (Vptr b Ptrofs.zero) (sig_res [Xsize_t ---> Xptr]).","conclusion":"Val.has_rettype (Vptr b Ptrofs.zero) (sig_res [Xsize_t ---> Xptr])","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (sz : ptrofs) (m' : Mem.mem') (b : block) (H0 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H1 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2)","proofString":"simpl.\nunfold Tptr; destruct Archi.ptr64; auto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (sz : ptrofs) (m' : Mem.mem') (b : block) (H0 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H1 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) : True.","conclusion":"True","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (sz : ptrofs) (m' : Mem.mem') (b : block) (H0 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H1 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2)","proofString":"unfold Tptr; destruct Archi.ptr64; auto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : extcall_malloc_sem ge1 vargs m1 t vres m2) : extcall_malloc_sem ge2 vargs m1 t vres m2.","conclusion":"extcall_malloc_sem ge2 vargs m1 t vres m2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : extcall_malloc_sem ge1 vargs m1 t vres m2)","proofString":"inv H0; econstructor; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m', b0) ->\nMem.store Mptr m' b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : extcall_malloc_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m', b0) ->\nMem.store Mptr m' b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : extcall_malloc_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b)","proofString":"inv H.\neauto with mem."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b1) ->\nMem.store Mptr m'0 b1 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (b : block) (H0 : Mem.valid_block m1 b) (sz : ptrofs) (m' : Mem.mem') (b0 : block) (H1 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b0)) (H2 : Mem.store Mptr m' b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b1) ->\nMem.store Mptr m'0 b1 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (b : block) (H0 : Mem.valid_block m1 b) (sz : ptrofs) (m' : Mem.mem') (b0 : block) (H1 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b0)) (H2 : Mem.store Mptr m' b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2)","proofString":"eauto with mem."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m', b0) ->\nMem.store Mptr m' b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : extcall_malloc_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) : Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m', b0) ->\nMem.store Mptr m' b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : extcall_malloc_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p)","proofString":"inv H.\nexploit Mem.perm_alloc_inv.\neauto.\neapply Mem.perm_store_2; eauto.\nrewrite dec_eq_false.\nauto.\napply Mem.valid_not_valid_diff with m1; eauto with mem."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b1) ->\nMem.store Mptr m'0 b1 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) (sz : ptrofs) (m' : Mem.mem') (b0 : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b0)) (H3 : Mem.store Mptr m' b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2) : Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b1) ->\nMem.store Mptr m'0 b1 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) (sz : ptrofs) (m' : Mem.mem') (b0 : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b0)) (H3 : Mem.store Mptr m' b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2)","proofString":"exploit Mem.perm_alloc_inv.\neauto.\neapply Mem.perm_store_2; eauto.\nrewrite dec_eq_false.\nauto.\napply Mem.valid_not_valid_diff with m1; eauto with mem."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b1) ->\nMem.store Mptr m'0 b1 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) (sz : ptrofs) (m' : Mem.mem') (b0 : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b0)) (H3 : Mem.store Mptr m' b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2) : Mem.perm m1 b ofs Max p -> Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p -> Mem.perm m1 b ofs Max p","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b1) ->\nMem.store Mptr m'0 b1 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) (sz : ptrofs) (m' : Mem.mem') (b0 : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b0)) (H3 : Mem.store Mptr m' b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2)","proofString":"auto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b1) ->\nMem.store Mptr m'0 b1 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) (sz : ptrofs) (m' : Mem.mem') (b0 : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b0)) (H3 : Mem.store Mptr m' b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2) : b <> b0.","conclusion":"b <> b0","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b1) ->\nMem.store Mptr m'0 b1 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) (sz : ptrofs) (m' : Mem.mem') (b0 : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b0)) (H3 : Mem.store Mptr m' b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2)","proofString":"apply Mem.valid_not_valid_diff with m1; eauto with mem."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m', b0) ->\nMem.store Mptr m' b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_malloc_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) : Mem.loadbytes m1 b ofs n = Some bytes.","conclusion":"Mem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m', b0) ->\nMem.store Mptr m' b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_malloc_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable)","proofString":"inv H.\neapply unchanged_on_readonly; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b1) ->\nMem.store Mptr m'0 b1 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (sz : ptrofs) (m' : Mem.mem') (b0 : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b0)) (H4 : Mem.store Mptr m' b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2) : Mem.loadbytes m1 b ofs n = Some bytes.","conclusion":"Mem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b1) ->\nMem.store Mptr m'0 b1 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (sz : ptrofs) (m' : Mem.mem') (b0 : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b0)) (H4 : Mem.store Mptr m' b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2)","proofString":"eapply unchanged_on_readonly; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : extcall_malloc_sem ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs') : exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : extcall_malloc_sem ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs')","proofString":"inv H.\ninv H1.\ninv H7.\nassert (SZ: v2 = Vptrofs sz).\nunfold Vptrofs in *.\ndestruct Archi.ptr64; inv H5; auto.\nsubst v2.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [m3' [A B]].\nexploit Mem.store_within_extends.\neexact B.\neauto.\neauto.\nintros [m2' [C D]].\nexists (Vptr b Ptrofs.zero); exists m2'; intuition auto with mem.\neconstructor; eauto.\neapply UNCHANGED; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m1 m1') (sz : ptrofs) (H1 : Val.lessdef_list (Vptrofs sz :: nil) vargs') (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) : exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge vargs' m1' E0 vres' m2' /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge vargs' m1' E0 vres' m2' /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m1 m1') (sz : ptrofs) (H1 : Val.lessdef_list (Vptrofs sz :: nil) vargs') (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2)","proofString":"inv H1.\ninv H7.\nassert (SZ: v2 = Vptrofs sz).\nunfold Vptrofs in *.\ndestruct Archi.ptr64; inv H5; auto.\nsubst v2.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [m3' [A B]].\nexploit Mem.store_within_extends.\neexact B.\neauto.\neauto.\nintros [m2' [C D]].\nexists (Vptr b Ptrofs.zero); exists m2'; intuition auto with mem.\neconstructor; eauto.\neapply UNCHANGED; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v2 : val) (vl2 : list val) (H5 : Val.lessdef (Vptrofs sz) v2) (H7 : Val.lessdef_list nil vl2) : exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge (v2 :: vl2) m1' E0 vres' m2' /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge (v2 :: vl2) m1' E0 vres' m2' /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v2 : val) (vl2 : list val) (H5 : Val.lessdef (Vptrofs sz) v2) (H7 : Val.lessdef_list nil vl2)","proofString":"inv H7.\nassert (SZ: v2 = Vptrofs sz).\nunfold Vptrofs in *.\ndestruct Archi.ptr64; inv H5; auto.\nsubst v2.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [m3' [A B]].\nexploit Mem.store_within_extends.\neexact B.\neauto.\neauto.\nintros [m2' [C D]].\nexists (Vptr b Ptrofs.zero); exists m2'; intuition auto with mem.\neconstructor; eauto.\neapply UNCHANGED; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v2 : val) (H5 : Val.lessdef (Vptrofs sz) v2) : exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge (v2 :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge (v2 :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v2 : val) (H5 : Val.lessdef (Vptrofs sz) v2)","proofString":"assert (SZ: v2 = Vptrofs sz).\nunfold Vptrofs in *.\ndestruct Archi.ptr64; inv H5; auto.\nsubst v2.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [m3' [A B]].\nexploit Mem.store_within_extends.\neexact B.\neauto.\neauto.\nintros [m2' [C D]].\nexists (Vptr b Ptrofs.zero); exists m2'; intuition auto with mem.\neconstructor; eauto.\neapply UNCHANGED; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v2 : val) (H5 : Val.lessdef (Vptrofs sz) v2) : v2 = Vptrofs sz.","conclusion":"v2 = Vptrofs sz","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v2 : val) (H5 : Val.lessdef (Vptrofs sz) v2)","proofString":"unfold Vptrofs in *.\ndestruct Archi.ptr64; inv H5; auto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr)\n  (if Archi.ptr64\n   then Vlong (Ptrofs.to_int64 sz)\n   else Vint (Ptrofs.to_int sz)) = Some m2) (v2 : val) (H5 : Val.lessdef\n  (if Archi.ptr64\n   then Vlong (Ptrofs.to_int64 sz)\n   else Vint (Ptrofs.to_int sz)) v2) : v2 =\n(if Archi.ptr64 then Vlong (Ptrofs.to_int64 sz) else Vint (Ptrofs.to_int sz)).","conclusion":"v2 =\n(if Archi.ptr64 then Vlong (Ptrofs.to_int64 sz) else Vint (Ptrofs.to_int sz))","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr)\n  (if Archi.ptr64\n   then Vlong (Ptrofs.to_int64 sz)\n   else Vint (Ptrofs.to_int sz)) = Some m2) (v2 : val) (H5 : Val.lessdef\n  (if Archi.ptr64\n   then Vlong (Ptrofs.to_int64 sz)\n   else Vint (Ptrofs.to_int sz)) v2)","proofString":"destruct Archi.ptr64; inv H5; auto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v2 : val) (H5 : Val.lessdef (Vptrofs sz) v2) (SZ : v2 = Vptrofs sz) : exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge (v2 :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge (v2 :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v2 : val) (H5 : Val.lessdef (Vptrofs sz) v2) (SZ : v2 = Vptrofs sz)","proofString":"subst v2.\nexploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [m3' [A B]].\nexploit Mem.store_within_extends.\neexact B.\neauto.\neauto.\nintros [m2' [C D]].\nexists (Vptr b Ptrofs.zero); exists m2'; intuition auto with mem.\neconstructor; eauto.\neapply UNCHANGED; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H5 : Val.lessdef (Vptrofs sz) (Vptrofs sz)) : exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge (Vptrofs sz :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge (Vptrofs sz :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H5 : Val.lessdef (Vptrofs sz) (Vptrofs sz))","proofString":"exploit Mem.alloc_extends; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [m3' [A B]].\nexploit Mem.store_within_extends.\neexact B.\neauto.\neauto.\nintros [m2' [C D]].\nexists (Vptr b Ptrofs.zero); exists m2'; intuition auto with mem.\neconstructor; eauto.\neapply UNCHANGED; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H5 : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (m3' : Mem.mem') (A : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b)) (B : Mem.extends m' m3') : exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge (Vptrofs sz :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge (Vptrofs sz :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H5 : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (m3' : Mem.mem') (A : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b)) (B : Mem.extends m' m3')","proofString":"exploit Mem.store_within_extends.\neexact B.\neauto.\neauto.\nintros [m2' [C D]].\nexists (Vptr b Ptrofs.zero); exists m2'; intuition auto with mem.\neconstructor; eauto.\neapply UNCHANGED; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H5 : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (m3' : Mem.mem') (A : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b)) (B : Mem.extends m' m3') (m2' : mem) (C : Mem.store Mptr m3' b (- size_chunk Mptr) (Vptrofs sz) = Some m2') (D : Mem.extends m2 m2') : exists (vres' : val) (m2'0 : mem),\n  extcall_malloc_sem ge (Vptrofs sz :: nil) m1' E0 vres' m2'0 /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2'0 /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'0.","conclusion":"exists (vres' : val) (m2'0 : mem),\n  extcall_malloc_sem ge (Vptrofs sz :: nil) m1' E0 vres' m2'0 /\\\n  Val.lessdef (Vptr b Ptrofs.zero) vres' /\\\n  Mem.extends m2 m2'0 /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'0","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H5 : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (m3' : Mem.mem') (A : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b)) (B : Mem.extends m' m3') (m2' : mem) (C : Mem.store Mptr m3' b (- size_chunk Mptr) (Vptrofs sz) = Some m2') (D : Mem.extends m2 m2')","proofString":"exists (Vptr b Ptrofs.zero); exists m2'; intuition auto with mem.\neconstructor; eauto.\neapply UNCHANGED; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H5 : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (m3' : Mem.mem') (A : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b)) (B : Mem.extends m' m3') (m2' : mem) (C : Mem.store Mptr m3' b (- size_chunk Mptr) (Vptrofs sz) = Some m2') (D : Mem.extends m2 m2') : extcall_malloc_sem ge (Vptrofs sz :: nil) m1' E0 (Vptr b Ptrofs.zero) m2'.","conclusion":"extcall_malloc_sem ge (Vptrofs sz :: nil) m1' E0 (Vptr b Ptrofs.zero) m2'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H5 : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (m3' : Mem.mem') (A : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b)) (B : Mem.extends m' m3') (m2' : mem) (C : Mem.store Mptr m3' b (- size_chunk Mptr) (Vptrofs sz) = Some m2') (D : Mem.extends m2 m2')","proofString":"econstructor; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H5 : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (m3' : Mem.mem') (A : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b)) (B : Mem.extends m' m3') (m2' : mem) (C : Mem.store Mptr m3' b (- size_chunk Mptr) (Vptrofs sz) = Some m2') (D : Mem.extends m2 m2') : Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H2 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H3 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H5 : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (m3' : Mem.mem') (A : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b)) (B : Mem.extends m' m3') (m2' : mem) (C : Mem.store Mptr m3' b (- size_chunk Mptr) (Vptrofs sz) = Some m2') (D : Mem.extends m2 m2')","proofString":"eapply UNCHANGED; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : extcall_malloc_sem ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : extcall_malloc_sem ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"inv H0.\ninv H2.\ninv H8.\nassert (SZ: v' = Vptrofs sz).\nunfold Vptrofs in *.\ndestruct Archi.ptr64; inv H6; auto.\nsubst v'.\nexploit Mem.alloc_parallel_inject; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [f' [m3' [b' [ALLOC [A [B [C D]]]]]]].\nexploit Mem.store_mapped_inject.\neexact A.\neauto.\neauto.\ninstantiate (1 := Vptrofs sz).\nunfold Vptrofs; destruct Archi.ptr64; constructor.\nrewrite Z.add_0_r.\nintros [m2' [E G]].\nexists f'; exists (Vptr b' Ptrofs.zero); exists m2'; intuition auto.\neconstructor; eauto.\neconstructor.\neauto.\nauto.\neapply UNCHANGED; eauto.\neapply UNCHANGED; eauto.\nred; intros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite C in H2.\ninv H2.\neauto with mem.\nrewrite D in H2 by auto.\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (H2 : Val.inject_list f (Vptrofs sz :: nil) vargs') (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 vargs' m1' E0 vres' m2' /\\\n  Val.inject f' (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 vargs' m1' E0 vres' m2' /\\\n  Val.inject f' (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (H2 : Val.inject_list f (Vptrofs sz :: nil) vargs') (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2)","proofString":"inv H2.\ninv H8.\nassert (SZ: v' = Vptrofs sz).\nunfold Vptrofs in *.\ndestruct Archi.ptr64; inv H6; auto.\nsubst v'.\nexploit Mem.alloc_parallel_inject; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [f' [m3' [b' [ALLOC [A [B [C D]]]]]]].\nexploit Mem.store_mapped_inject.\neexact A.\neauto.\neauto.\ninstantiate (1 := Vptrofs sz).\nunfold Vptrofs; destruct Archi.ptr64; constructor.\nrewrite Z.add_0_r.\nintros [m2' [E G]].\nexists f'; exists (Vptr b' Ptrofs.zero); exists m2'; intuition auto.\neconstructor; eauto.\neconstructor.\neauto.\nauto.\neapply UNCHANGED; eauto.\neapply UNCHANGED; eauto.\nred; intros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite C in H2.\ninv H2.\neauto with mem.\nrewrite D in H2 by auto.\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v' : val) (vl' : list val) (H6 : Val.inject f (Vptrofs sz) v') (H8 : Val.inject_list f nil vl') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 (v' :: vl') m1' E0 vres' m2' /\\\n  Val.inject f' (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 (v' :: vl') m1' E0 vres' m2' /\\\n  Val.inject f' (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v' : val) (vl' : list val) (H6 : Val.inject f (Vptrofs sz) v') (H8 : Val.inject_list f nil vl')","proofString":"inv H8.\nassert (SZ: v' = Vptrofs sz).\nunfold Vptrofs in *.\ndestruct Archi.ptr64; inv H6; auto.\nsubst v'.\nexploit Mem.alloc_parallel_inject; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [f' [m3' [b' [ALLOC [A [B [C D]]]]]]].\nexploit Mem.store_mapped_inject.\neexact A.\neauto.\neauto.\ninstantiate (1 := Vptrofs sz).\nunfold Vptrofs; destruct Archi.ptr64; constructor.\nrewrite Z.add_0_r.\nintros [m2' [E G]].\nexists f'; exists (Vptr b' Ptrofs.zero); exists m2'; intuition auto.\neconstructor; eauto.\neconstructor.\neauto.\nauto.\neapply UNCHANGED; eauto.\neapply UNCHANGED; eauto.\nred; intros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite C in H2.\ninv H2.\neauto with mem.\nrewrite D in H2 by auto.\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v' : val) (H6 : Val.inject f (Vptrofs sz) v') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 (v' :: nil) m1' E0 vres' m2' /\\\n  Val.inject f' (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 (v' :: nil) m1' E0 vres' m2' /\\\n  Val.inject f' (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v' : val) (H6 : Val.inject f (Vptrofs sz) v')","proofString":"assert (SZ: v' = Vptrofs sz).\nunfold Vptrofs in *.\ndestruct Archi.ptr64; inv H6; auto.\nsubst v'.\nexploit Mem.alloc_parallel_inject; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [f' [m3' [b' [ALLOC [A [B [C D]]]]]]].\nexploit Mem.store_mapped_inject.\neexact A.\neauto.\neauto.\ninstantiate (1 := Vptrofs sz).\nunfold Vptrofs; destruct Archi.ptr64; constructor.\nrewrite Z.add_0_r.\nintros [m2' [E G]].\nexists f'; exists (Vptr b' Ptrofs.zero); exists m2'; intuition auto.\neconstructor; eauto.\neconstructor.\neauto.\nauto.\neapply UNCHANGED; eauto.\neapply UNCHANGED; eauto.\nred; intros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite C in H2.\ninv H2.\neauto with mem.\nrewrite D in H2 by auto.\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v' : val) (H6 : Val.inject f (Vptrofs sz) v') : v' = Vptrofs sz.","conclusion":"v' = Vptrofs sz","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v' : val) (H6 : Val.inject f (Vptrofs sz) v')","proofString":"unfold Vptrofs in *.\ndestruct Archi.ptr64; inv H6; auto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr)\n  (if Archi.ptr64\n   then Vlong (Ptrofs.to_int64 sz)\n   else Vint (Ptrofs.to_int sz)) = Some m2) (v' : val) (H6 : Val.inject f\n  (if Archi.ptr64\n   then Vlong (Ptrofs.to_int64 sz)\n   else Vint (Ptrofs.to_int sz)) v') : v' =\n(if Archi.ptr64 then Vlong (Ptrofs.to_int64 sz) else Vint (Ptrofs.to_int sz)).","conclusion":"v' =\n(if Archi.ptr64 then Vlong (Ptrofs.to_int64 sz) else Vint (Ptrofs.to_int sz))","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr)\n  (if Archi.ptr64\n   then Vlong (Ptrofs.to_int64 sz)\n   else Vint (Ptrofs.to_int sz)) = Some m2) (v' : val) (H6 : Val.inject f\n  (if Archi.ptr64\n   then Vlong (Ptrofs.to_int64 sz)\n   else Vint (Ptrofs.to_int sz)) v')","proofString":"destruct Archi.ptr64; inv H6; auto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v' : val) (H6 : Val.inject f (Vptrofs sz) v') (SZ : v' = Vptrofs sz) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 (v' :: nil) m1' E0 vres' m2' /\\\n  Val.inject f' (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 (v' :: nil) m1' E0 vres' m2' /\\\n  Val.inject f' (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (v' : val) (H6 : Val.inject f (Vptrofs sz) v') (SZ : v' = Vptrofs sz)","proofString":"subst v'.\nexploit Mem.alloc_parallel_inject; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [f' [m3' [b' [ALLOC [A [B [C D]]]]]]].\nexploit Mem.store_mapped_inject.\neexact A.\neauto.\neauto.\ninstantiate (1 := Vptrofs sz).\nunfold Vptrofs; destruct Archi.ptr64; constructor.\nrewrite Z.add_0_r.\nintros [m2' [E G]].\nexists f'; exists (Vptr b' Ptrofs.zero); exists m2'; intuition auto.\neconstructor; eauto.\neconstructor.\neauto.\nauto.\neapply UNCHANGED; eauto.\neapply UNCHANGED; eauto.\nred; intros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite C in H2.\ninv H2.\neauto with mem.\nrewrite D in H2 by auto.\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 (Vptrofs sz :: nil) m1' E0 vres' m2' /\\\n  Val.inject f' (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 (Vptrofs sz :: nil) m1' E0 vres' m2' /\\\n  Val.inject f' (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz))","proofString":"exploit Mem.alloc_parallel_inject; eauto.\napply Z.le_refl.\napply Z.le_refl.\nintros [f' [m3' [b' [ALLOC [A [B [C D]]]]]]].\nexploit Mem.store_mapped_inject.\neexact A.\neauto.\neauto.\ninstantiate (1 := Vptrofs sz).\nunfold Vptrofs; destruct Archi.ptr64; constructor.\nrewrite Z.add_0_r.\nintros [m2' [E G]].\nexists f'; exists (Vptr b' Ptrofs.zero); exists m2'; intuition auto.\neconstructor; eauto.\neconstructor.\neauto.\nauto.\neapply UNCHANGED; eauto.\neapply UNCHANGED; eauto.\nred; intros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite C in H2.\ninv H2.\neauto with mem.\nrewrite D in H2 by auto.\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, b0 <> b -> f' b0 = f b0) : exists (f'0 : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 (Vptrofs sz :: nil) m1' E0 vres' m2' /\\\n  Val.inject f'0 (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f'0 m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f'0 /\\ inject_separated f f'0 m1 m1'.","conclusion":"exists (f'0 : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 (Vptrofs sz :: nil) m1' E0 vres' m2' /\\\n  Val.inject f'0 (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f'0 m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f'0 /\\ inject_separated f f'0 m1 m1'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, b0 <> b -> f' b0 = f b0)","proofString":"exploit Mem.store_mapped_inject.\neexact A.\neauto.\neauto.\ninstantiate (1 := Vptrofs sz).\nunfold Vptrofs; destruct Archi.ptr64; constructor.\nrewrite Z.add_0_r.\nintros [m2' [E G]].\nexists f'; exists (Vptr b' Ptrofs.zero); exists m2'; intuition auto.\neconstructor; eauto.\neconstructor.\neauto.\nauto.\neapply UNCHANGED; eauto.\neapply UNCHANGED; eauto.\nred; intros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite C in H2.\ninv H2.\neauto with mem.\nrewrite D in H2 by auto.\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, b0 <> b -> f' b0 = f b0) : Val.inject f' (Vptrofs sz) (Vptrofs sz).","conclusion":"Val.inject f' (Vptrofs sz) (Vptrofs sz)","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, b0 <> b -> f' b0 = f b0)","proofString":"unfold Vptrofs; destruct Archi.ptr64; constructor."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, b0 <> b -> f' b0 = f b0) : (exists n2 : mem,\n   Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some n2 /\\\n   Mem.inject f' m2 n2) ->\nexists (f'0 : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 (Vptrofs sz :: nil) m1' E0 vres' m2' /\\\n  Val.inject f'0 (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f'0 m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f'0 /\\ inject_separated f f'0 m1 m1'.","conclusion":"(exists n2 : mem,\n   Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some n2 /\\\n   Mem.inject f' m2 n2) ->\nexists (f'0 : meminj) (vres' : val) (m2' : mem),\n  extcall_malloc_sem ge2 (Vptrofs sz :: nil) m1' E0 vres' m2' /\\\n  Val.inject f'0 (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f'0 m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f'0 /\\ inject_separated f f'0 m1 m1'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, b0 <> b -> f' b0 = f b0)","proofString":"intros [m2' [E G]].\nexists f'; exists (Vptr b' Ptrofs.zero); exists m2'; intuition auto.\neconstructor; eauto.\neconstructor.\neauto.\nauto.\neapply UNCHANGED; eauto.\neapply UNCHANGED; eauto.\nred; intros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite C in H2.\ninv H2.\neauto with mem.\nrewrite D in H2 by auto.\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, b0 <> b -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') : exists (f'0 : meminj) (vres' : val) (m2'0 : mem),\n  extcall_malloc_sem ge2 (Vptrofs sz :: nil) m1' E0 vres' m2'0 /\\\n  Val.inject f'0 (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f'0 m2 m2'0 /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'0 /\\\n  inject_incr f f'0 /\\ inject_separated f f'0 m1 m1'.","conclusion":"exists (f'0 : meminj) (vres' : val) (m2'0 : mem),\n  extcall_malloc_sem ge2 (Vptrofs sz :: nil) m1' E0 vres' m2'0 /\\\n  Val.inject f'0 (Vptr b Ptrofs.zero) vres' /\\\n  Mem.inject f'0 m2 m2'0 /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'0 /\\\n  inject_incr f f'0 /\\ inject_separated f f'0 m1 m1'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, b0 <> b -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2')","proofString":"exists f'; exists (Vptr b' Ptrofs.zero); exists m2'; intuition auto.\neconstructor; eauto.\neconstructor.\neauto.\nauto.\neapply UNCHANGED; eauto.\neapply UNCHANGED; eauto.\nred; intros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite C in H2.\ninv H2.\neauto with mem.\nrewrite D in H2 by auto.\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') : extcall_malloc_sem ge2 (Vptrofs sz :: nil) m1' E0 (Vptr b' Ptrofs.zero) m2'.","conclusion":"extcall_malloc_sem ge2 (Vptrofs sz :: nil) m1' E0 (Vptr b' Ptrofs.zero) m2'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2')","proofString":"econstructor; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') : Val.inject f' (Vptr b Ptrofs.zero) (Vptr b' Ptrofs.zero).","conclusion":"Val.inject f' (Vptr b Ptrofs.zero) (Vptr b' Ptrofs.zero)","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2')","proofString":"econstructor.\neauto.\nauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') : Mem.unchanged_on (loc_unmapped f) m1 m2.","conclusion":"Mem.unchanged_on (loc_unmapped f) m1 m2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2')","proofString":"eapply UNCHANGED; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'.","conclusion":"Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2')","proofString":"eapply UNCHANGED; eauto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') : inject_separated f f' m1 m1'.","conclusion":"inject_separated f f' m1 m1'","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2')","proofString":"red; intros.\ndestruct (eq_block b1 b).\nsubst b1.\nrewrite C in H2.\ninv H2.\neauto with mem.\nrewrite D in H2 by auto.\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (b1 b2 : block) (delta : Z) (H0 : f b1 = None) (H2 : f' b1 = Some (b2, delta)) : ~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2.","conclusion":"~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (b1 b2 : block) (delta : Z) (H0 : f b1 = None) (H2 : f' b1 = Some (b2, delta))","proofString":"destruct (eq_block b1 b).\nsubst b1.\nrewrite C in H2.\ninv H2.\neauto with mem.\nrewrite D in H2 by auto.\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (b1 b2 : block) (delta : Z) (H0 : f b1 = None) (H2 : f' b1 = Some (b2, delta)) (e : b1 = b) : ~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2.","conclusion":"~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (b1 b2 : block) (delta : Z) (H0 : f b1 = None) (H2 : f' b1 = Some (b2, delta)) (e : b1 = b)","proofString":"subst b1.\nrewrite C in H2.\ninv H2.\neauto with mem."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (b2 : block) (delta : Z) (H2 : f' b = Some (b2, delta)) (H0 : f b = None) : ~ Mem.valid_block m1 b /\\ ~ Mem.valid_block m1' b2.","conclusion":"~ Mem.valid_block m1 b /\\ ~ Mem.valid_block m1' b2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (b2 : block) (delta : Z) (H2 : f' b = Some (b2, delta)) (H0 : f b = None)","proofString":"rewrite C in H2.\ninv H2.\neauto with mem."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (b2 : block) (delta : Z) (H2 : Some (b', 0) = Some (b2, delta)) (H0 : f b = None) : ~ Mem.valid_block m1 b /\\ ~ Mem.valid_block m1' b2.","conclusion":"~ Mem.valid_block m1 b /\\ ~ Mem.valid_block m1' b2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (b2 : block) (delta : Z) (H2 : Some (b', 0) = Some (b2, delta)) (H0 : f b = None)","proofString":"inv H2.\neauto with mem."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b2 : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b2)) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b2, 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b2 (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (H0 : f b = None) : ~ Mem.valid_block m1 b /\\ ~ Mem.valid_block m1' b2.","conclusion":"~ Mem.valid_block m1 b /\\ ~ Mem.valid_block m1' b2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b2 : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b2)) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b2, 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b2 (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (H0 : f b = None)","proofString":"eauto with mem."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (b1 b2 : block) (delta : Z) (H0 : f b1 = None) (H2 : f' b1 = Some (b2, delta)) (n : b1 <> b) : ~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2.","conclusion":"~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (b1 b2 : block) (delta : Z) (H0 : f b1 = None) (H2 : f' b1 = Some (b2, delta)) (n : b1 <> b)","proofString":"rewrite D in H2 by auto.\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (b1 b2 : block) (delta : Z) (H0 : f b1 = None) (H2 : f b1 = Some (b2, delta)) (n : b1 <> b) : ~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2.","conclusion":"~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m m'') (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (sz : ptrofs) (m' : Mem.mem') (b : block) (H3 : Mem.alloc m1 (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H4 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m2) (H6 : Val.inject f (Vptrofs sz) (Vptrofs sz)) (f' : meminj) (m3' : Mem.mem') (b' : block) (ALLOC : Mem.alloc m1' (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m3', b')) (A : Mem.inject f' m' m3') (B : inject_incr f f') (C : f' b = Some (b', 0)) (D : forall b0 : block, (b0 = b -> False) -> f' b0 = f b0) (m2' : mem) (E : Mem.store Mptr m3' b' (- size_chunk Mptr) (Vptrofs sz) = Some m2') (G : Mem.inject f' m2 m2') (b1 b2 : block) (delta : Z) (H0 : f b1 = None) (H2 : f b1 = Some (b2, delta)) (n : b1 <> b)","proofString":"congruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m0 lo hi = (m'0, b) ->\nMem.store Mptr m'0 b lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : extcall_malloc_sem ge vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m0 lo hi = (m'0, b) ->\nMem.store Mptr m'0 b lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : extcall_malloc_sem ge vargs m t vres m')","proofString":"inv H; simpl; lia."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m0 lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_malloc_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : exists (vres2 : val) (m2 : mem), extcall_malloc_sem ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem), extcall_malloc_sem ge vargs m t2 vres2 m2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m0 lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_malloc_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"assert (t1 = t2).\ninv H; inv H0; auto.\nsubst t2.\nexists vres1; exists m1; auto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m0 lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_malloc_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : t1 = t2.","conclusion":"t1 = t2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m0 lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_malloc_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"inv H; inv H0; auto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m0 lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_malloc_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) (H1 : t1 = t2) : exists (vres2 : val) (m2 : mem), extcall_malloc_sem ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem), extcall_malloc_sem ge vargs m t2 vres2 m2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m0 lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_malloc_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) (H1 : t1 = t2)","proofString":"subst t2.\nexists vres1; exists m1; auto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m0 lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (H : extcall_malloc_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t1) : exists (vres2 : val) (m2 : mem), extcall_malloc_sem ge vargs m t1 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem), extcall_malloc_sem ge vargs m t1 vres2 m2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m0 lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (H : extcall_malloc_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t1)","proofString":"exists vres1; exists m1; auto."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m0 lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : extcall_malloc_sem ge vargs m t1 vres1 m1) (H0 : extcall_malloc_sem ge vargs m t2 vres2 m2) : match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2).","conclusion":"match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2)","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m' : Mem.mem') (b : block) (m'' : mem),\nMem.alloc m0 lo hi = (m', b) ->\nMem.store Mptr m' b lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : extcall_malloc_sem ge vargs m t1 vres1 m1) (H0 : extcall_malloc_sem ge vargs m t2 vres2 m2)","proofString":"inv H.\nsimple inversion H0.\nassert (EQ2: sz0 = sz).\nunfold Vptrofs in H4; destruct Archi.ptr64 eqn:SF.\nrewrite <- (Ptrofs.of_int64_to_int64 SF sz0), <- (Ptrofs.of_int64_to_int64 SF sz).\ncongruence.\nrewrite <- (Ptrofs.of_int_to_int SF sz0), <- (Ptrofs.of_int_to_int SF sz).\ncongruence.\nsubst.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m0 lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) : match_traces ge E0 t2 /\\ (E0 = t2 -> Vptr b Ptrofs.zero = vres2 /\\ m1 = m2).","conclusion":"match_traces ge E0 t2 /\\ (E0 = t2 -> Vptr b Ptrofs.zero = vres2 /\\ m1 = m2)","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m'0 : Mem.mem') (b0 : block) (m'' : mem),\nMem.alloc m0 lo hi = (m'0, b0) ->\nMem.store Mptr m'0 b0 lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1)","proofString":"simple inversion H0.\nassert (EQ2: sz0 = sz).\nunfold Vptrofs in H4; destruct Archi.ptr64 eqn:SF.\nrewrite <- (Ptrofs.of_int64_to_int64 SF sz0), <- (Ptrofs.of_int64_to_int64 SF sz).\ncongruence.\nrewrite <- (Ptrofs.of_int_to_int SF sz0), <- (Ptrofs.of_int_to_int SF sz).\ncongruence.\nsubst.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (H4 : Vptrofs sz0 :: nil = Vptrofs sz :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2) : Mem.alloc m0 (- size_chunk Mptr) (Ptrofs.unsigned sz0) = (m'0, b0) ->\nMem.store Mptr m'0 b0 (- size_chunk Mptr) (Vptrofs sz0) = Some m'' ->\nmatch_traces ge E0 t2 /\\ (E0 = t2 -> Vptr b Ptrofs.zero = vres2 /\\ m1 = m2).","conclusion":"Mem.alloc m0 (- size_chunk Mptr) (Ptrofs.unsigned sz0) = (m'0, b0) ->\nMem.store Mptr m'0 b0 (- size_chunk Mptr) (Vptrofs sz0) = Some m'' ->\nmatch_traces ge E0 t2 /\\ (E0 = t2 -> Vptr b Ptrofs.zero = vres2 /\\ m1 = m2)","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (H4 : Vptrofs sz0 :: nil = Vptrofs sz :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2)","proofString":"assert (EQ2: sz0 = sz).\nunfold Vptrofs in H4; destruct Archi.ptr64 eqn:SF.\nrewrite <- (Ptrofs.of_int64_to_int64 SF sz0), <- (Ptrofs.of_int64_to_int64 SF sz).\ncongruence.\nrewrite <- (Ptrofs.of_int_to_int SF sz0), <- (Ptrofs.of_int_to_int SF sz).\ncongruence.\nsubst.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (H4 : Vptrofs sz0 :: nil = Vptrofs sz :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2) : sz0 = sz.","conclusion":"sz0 = sz","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (H4 : Vptrofs sz0 :: nil = Vptrofs sz :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2)","proofString":"unfold Vptrofs in H4; destruct Archi.ptr64 eqn:SF.\nrewrite <- (Ptrofs.of_int64_to_int64 SF sz0), <- (Ptrofs.of_int64_to_int64 SF sz).\ncongruence.\nrewrite <- (Ptrofs.of_int_to_int SF sz0), <- (Ptrofs.of_int_to_int SF sz).\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (SF : Archi.ptr64 = true) (H4 : Vlong (Ptrofs.to_int64 sz0) :: nil = Vlong (Ptrofs.to_int64 sz) :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2) : sz0 = sz.","conclusion":"sz0 = sz","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (SF : Archi.ptr64 = true) (H4 : Vlong (Ptrofs.to_int64 sz0) :: nil = Vlong (Ptrofs.to_int64 sz) :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2)","proofString":"rewrite <- (Ptrofs.of_int64_to_int64 SF sz0), <- (Ptrofs.of_int64_to_int64 SF sz).\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (SF : Archi.ptr64 = true) (H4 : Vlong (Ptrofs.to_int64 sz0) :: nil = Vlong (Ptrofs.to_int64 sz) :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2) : Ptrofs.of_int64 (Ptrofs.to_int64 sz0) = Ptrofs.of_int64 (Ptrofs.to_int64 sz).","conclusion":"Ptrofs.of_int64 (Ptrofs.to_int64 sz0) = Ptrofs.of_int64 (Ptrofs.to_int64 sz)","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (SF : Archi.ptr64 = true) (H4 : Vlong (Ptrofs.to_int64 sz0) :: nil = Vlong (Ptrofs.to_int64 sz) :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2)","proofString":"congruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (SF : Archi.ptr64 = false) (H4 : Vint (Ptrofs.to_int sz0) :: nil = Vint (Ptrofs.to_int sz) :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2) : sz0 = sz.","conclusion":"sz0 = sz","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (SF : Archi.ptr64 = false) (H4 : Vint (Ptrofs.to_int sz0) :: nil = Vint (Ptrofs.to_int sz) :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2)","proofString":"rewrite <- (Ptrofs.of_int_to_int SF sz0), <- (Ptrofs.of_int_to_int SF sz).\ncongruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (SF : Archi.ptr64 = false) (H4 : Vint (Ptrofs.to_int sz0) :: nil = Vint (Ptrofs.to_int sz) :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2) : Ptrofs.of_int (Ptrofs.to_int sz0) = Ptrofs.of_int (Ptrofs.to_int sz).","conclusion":"Ptrofs.of_int (Ptrofs.to_int sz0) = Ptrofs.of_int (Ptrofs.to_int sz)","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (SF : Archi.ptr64 = false) (H4 : Vint (Ptrofs.to_int sz0) :: nil = Vint (Ptrofs.to_int sz) :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2)","proofString":"congruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (H4 : Vptrofs sz0 :: nil = Vptrofs sz :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2) (EQ2 : sz0 = sz) : Mem.alloc m0 (- size_chunk Mptr) (Ptrofs.unsigned sz0) = (m'0, b0) ->\nMem.store Mptr m'0 b0 (- size_chunk Mptr) (Vptrofs sz0) = Some m'' ->\nmatch_traces ge E0 t2 /\\ (E0 = t2 -> Vptr b Ptrofs.zero = vres2 /\\ m1 = m2).","conclusion":"Mem.alloc m0 (- size_chunk Mptr) (Ptrofs.unsigned sz0) = (m'0, b0) ->\nMem.store Mptr m'0 b0 (- size_chunk Mptr) (Vptrofs sz0) = Some m'' ->\nmatch_traces ge E0 t2 /\\ (E0 = t2 -> Vptr b Ptrofs.zero = vres2 /\\ m1 = m2)","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m3 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m''0 : mem),\nMem.alloc m3 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m''0 -> Mem.unchanged_on P m3 m''0) (ge : Senv.t) (m m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (sz : ptrofs) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m t2 vres2 m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (sz0 : ptrofs) (m0 : mem) (m'0 : Mem.mem') (b0 : block) (m'' : mem) (H4 : Vptrofs sz0 :: nil = Vptrofs sz :: nil) (H5 : m0 = m) (H6 : E0 = t2) (H7 : Vptr b0 Ptrofs.zero = vres2) (H8 : m'' = m2) (EQ2 : sz0 = sz)","proofString":"subst.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m0 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (m m1 m2 : mem) (sz : ptrofs) (b0 : block) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m E0 (Vptr b0 Ptrofs.zero) m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (m'0 : Mem.mem') (H4 : Vptrofs sz :: nil = Vptrofs sz :: nil) : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b0) ->\nMem.store Mptr m'0 b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2 ->\nmatch_traces ge E0 E0 /\\\n(E0 = E0 -> Vptr b Ptrofs.zero = Vptr b0 Ptrofs.zero /\\ m1 = m2).","conclusion":"Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b0) ->\nMem.store Mptr m'0 b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2 ->\nmatch_traces ge E0 E0 /\\\n(E0 = E0 -> Vptr b Ptrofs.zero = Vptr b0 Ptrofs.zero /\\ m1 = m2)","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m0 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (m m1 m2 : mem) (sz : ptrofs) (b0 : block) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m E0 (Vptr b0 Ptrofs.zero) m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (m'0 : Mem.mem') (H4 : Vptrofs sz :: nil = Vptrofs sz :: nil)","proofString":"split.\nconstructor.\nintuition congruence."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m0 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (m m1 m2 : mem) (sz : ptrofs) (b0 : block) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m E0 (Vptr b0 Ptrofs.zero) m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (m'0 : Mem.mem') (H4 : Vptrofs sz :: nil = Vptrofs sz :: nil) (H : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b0)) (H3 : Mem.store Mptr m'0 b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2) : match_traces ge E0 E0.","conclusion":"match_traces ge E0 E0","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m0 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (m m1 m2 : mem) (sz : ptrofs) (b0 : block) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m E0 (Vptr b0 Ptrofs.zero) m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (m'0 : Mem.mem') (H4 : Vptrofs sz :: nil = Vptrofs sz :: nil) (H : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b0)) (H3 : Mem.store Mptr m'0 b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2)","proofString":"constructor."},{"statement":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m0 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (m m1 m2 : mem) (sz : ptrofs) (b0 : block) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m E0 (Vptr b0 Ptrofs.zero) m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (m'0 : Mem.mem') (H4 : Vptrofs sz :: nil = Vptrofs sz :: nil) (H : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b0)) (H3 : Mem.store Mptr m'0 b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2) : E0 = E0 -> Vptr b Ptrofs.zero = Vptr b0 Ptrofs.zero /\\ m1 = m2.","conclusion":"E0 = E0 -> Vptr b Ptrofs.zero = Vptr b0 Ptrofs.zero /\\ m1 = m2","hypotheses":"(UNCHANGED : forall (P : block -> Z -> Prop) (m0 : mem) (lo hi : Z) \n  (v : val) (m'1 : Mem.mem') (b1 : block) (m'' : mem),\nMem.alloc m0 lo hi = (m'1, b1) ->\nMem.store Mptr m'1 b1 lo v = Some m'' -> Mem.unchanged_on P m0 m'') (ge : Senv.t) (m m1 m2 : mem) (sz : ptrofs) (b0 : block) (H0 : extcall_malloc_sem ge (Vptrofs sz :: nil) m E0 (Vptr b0 Ptrofs.zero) m2) (m' : Mem.mem') (b : block) (H1 : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m', b)) (H2 : Mem.store Mptr m' b (- size_chunk Mptr) (Vptrofs sz) = Some m1) (m'0 : Mem.mem') (H4 : Vptrofs sz :: nil = Vptrofs sz :: nil) (H : Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) = (m'0, b0)) (H3 : Mem.store Mptr m'0 b0 (- size_chunk Mptr) (Vptrofs sz) = Some m2)","proofString":"intuition congruence."},{"statement":"(ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : extcall_free_sem ge vargs m1 t vres m2) : Val.has_rettype vres (sig_res [Xptr ---> Xvoid]).","conclusion":"Val.has_rettype vres (sig_res [Xptr ---> Xvoid])","hypotheses":"(ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : extcall_free_sem ge vargs m1 t vres m2)","proofString":"inv H; simpl; auto."},{"statement":"(ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : extcall_free_sem ge1 vargs m1 t vres m2) : extcall_free_sem ge2 vargs m1 t vres m2.","conclusion":"extcall_free_sem ge2 vargs m1 t vres m2","hypotheses":"(ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : extcall_free_sem ge1 vargs m1 t vres m2)","proofString":"inv H0; econstructor; eauto."},{"statement":"(ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : extcall_free_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : extcall_free_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b)","proofString":"inv H; eauto with mem."},{"statement":"(ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : extcall_free_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) : Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p","hypotheses":"(ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : extcall_free_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p)","proofString":"inv H; eauto using Mem.perm_free_3."},{"statement":"(ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_free_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) : Mem.loadbytes m1 b ofs n = Some bytes.","conclusion":"Mem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_free_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable)","proofString":"eapply unchanged_on_readonly; eauto.\ninv H.\neapply Mem.free_unchanged_on; eauto.\nintros.\nred; intros.\nelim H5.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\napply Mem.unchanged_on_refl."},{"statement":"(ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_free_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) : Mem.unchanged_on (loc_not_writable m1) m1 m2.","conclusion":"Mem.unchanged_on (loc_not_writable m1) m1 m2","hypotheses":"(ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_free_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable)","proofString":"inv H.\neapply Mem.free_unchanged_on; eauto.\nintros.\nred; intros.\nelim H5.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto.\napply Mem.unchanged_on_refl."},{"statement":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) : Mem.unchanged_on (loc_not_writable m1) m1 m2.","conclusion":"Mem.unchanged_on (loc_not_writable m1) m1 m2","hypotheses":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2)","proofString":"eapply Mem.free_unchanged_on; eauto.\nintros.\nred; intros.\nelim H5.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto."},{"statement":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) : forall i : Z,\nPtrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz -> ~ loc_not_writable m1 b0 i.","conclusion":"forall i : Z,\nPtrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz -> ~ loc_not_writable m1 b0 i","hypotheses":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2)","proofString":"intros.\nred; intros.\nelim H5.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto."},{"statement":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) : ~ loc_not_writable m1 b0 i.","conclusion":"~ loc_not_writable m1 b0 i","hypotheses":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz)","proofString":"red; intros.\nelim H5.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto."},{"statement":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) (H5 : loc_not_writable m1 b0 i) : False.","conclusion":"False","hypotheses":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) (H5 : loc_not_writable m1 b0 i)","proofString":"elim H5.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto."},{"statement":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) (H5 : loc_not_writable m1 b0 i) : Mem.perm m1 b0 i Max Writable.","conclusion":"Mem.perm m1 b0 i Max Writable","hypotheses":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) (H5 : loc_not_writable m1 b0 i)","proofString":"apply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto."},{"statement":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) (H5 : loc_not_writable m1 b0 i) : Mem.perm m1 b0 i Cur Writable.","conclusion":"Mem.perm m1 b0 i Cur Writable","hypotheses":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) (H5 : loc_not_writable m1 b0 i)","proofString":"apply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm; eauto."},{"statement":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) (H5 : loc_not_writable m1 b0 i) : Mem.perm m1 b0 i Cur Freeable.","conclusion":"Mem.perm m1 b0 i Cur Freeable","hypotheses":"(ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (b0 : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (H4 : Mem.free m1 b0 (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) (H5 : loc_not_writable m1 b0 i)","proofString":"eapply Mem.free_range_perm; eauto."},{"statement":"(ge : Senv.t) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m2 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m2 b i Max Writable) : Mem.unchanged_on (loc_not_writable m2) m2 m2.","conclusion":"Mem.unchanged_on (loc_not_writable m2) m2 m2","hypotheses":"(ge : Senv.t) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m2 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m2 b i Max Writable)","proofString":"apply Mem.unchanged_on_refl."},{"statement":"(ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : extcall_free_sem ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs') : exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : extcall_free_sem ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs')","proofString":"inv H.\ninv H1.\ninv H7.\ninv H5.\nexploit Mem.load_extends; eauto.\nintros [v' [A B]].\nassert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nexploit Mem.free_parallel_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'; intuition auto.\neconstructor; eauto.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto.\ninv H1.\ninv H5.\nreplace v2 with Vnullptr.\nexists Vundef; exists m1'; intuition auto.\nconstructor.\napply Mem.unchanged_on_refl.\nunfold Vnullptr in *; destruct Archi.ptr64; inv H3; auto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m1 m1') (b : block) (lo : ptrofs) (H1 : Val.lessdef_list (Vptr b lo :: nil) vargs') (sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) : exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge vargs' m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge vargs' m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m1 m1') (b : block) (lo : ptrofs) (H1 : Val.lessdef_list (Vptr b lo :: nil) vargs') (sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2)","proofString":"inv H1.\ninv H7.\ninv H5.\nexploit Mem.load_extends; eauto.\nintros [v' [A B]].\nassert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nexploit Mem.free_parallel_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'; intuition auto.\neconstructor; eauto.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (v2 : val) (vl2 : list val) (H5 : Val.lessdef (Vptr b lo) v2) (H7 : Val.lessdef_list nil vl2) : exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (v2 :: vl2) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (v2 :: vl2) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (v2 : val) (vl2 : list val) (H5 : Val.lessdef (Vptr b lo) v2) (H7 : Val.lessdef_list nil vl2)","proofString":"inv H7.\ninv H5.\nexploit Mem.load_extends; eauto.\nintros [v' [A B]].\nassert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nexploit Mem.free_parallel_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'; intuition auto.\neconstructor; eauto.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (v2 : val) (H5 : Val.lessdef (Vptr b lo) v2) : exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (v2 :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (v2 :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (v2 : val) (H5 : Val.lessdef (Vptr b lo) v2)","proofString":"inv H5.\nexploit Mem.load_extends; eauto.\nintros [v' [A B]].\nassert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nexploit Mem.free_parallel_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'; intuition auto.\neconstructor; eauto.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) : exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2)","proofString":"exploit Mem.load_extends; eauto.\nintros [v' [A B]].\nassert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nexploit Mem.free_parallel_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'; intuition auto.\neconstructor; eauto.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) : (exists v2 : val,\n   Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) = Some v2 /\\\n   Val.lessdef (Vptrofs sz) v2) ->\nexists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"(exists v2 : val,\n   Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) = Some v2 /\\\n   Val.lessdef (Vptrofs sz) v2) ->\nexists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2)","proofString":"intros [v' [A B]].\nassert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nexploit Mem.free_parallel_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'; intuition auto.\neconstructor; eauto.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (v' : val) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) = Some v') (B : Val.lessdef (Vptrofs sz) v') : exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (v' : val) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) = Some v') (B : Val.lessdef (Vptrofs sz) v')","proofString":"assert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nexploit Mem.free_parallel_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'; intuition auto.\neconstructor; eauto.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (v' : val) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) = Some v') (B : Val.lessdef (Vptrofs sz) v') : v' = Vptrofs sz.","conclusion":"v' = Vptrofs sz","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (v' : val) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) = Some v') (B : Val.lessdef (Vptrofs sz) v')","proofString":"unfold Vptrofs in *; destruct Archi.ptr64; inv B; auto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (v' : val) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) = Some v') (B : Val.lessdef (Vptrofs sz) v') (H : v' = Vptrofs sz) : exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (v' : val) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) = Some v') (B : Val.lessdef (Vptrofs sz) v') (H : v' = Vptrofs sz)","proofString":"subst v'.\nexploit Mem.free_parallel_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'; intuition auto.\neconstructor; eauto.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) : exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz))","proofString":"exploit Mem.free_parallel_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'; intuition auto.\neconstructor; eauto.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) : (exists m2' : mem,\n   Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n     (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2' /\\\n   Mem.extends m2 m2') ->\nexists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"(exists m2' : mem,\n   Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n     (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2' /\\\n   Mem.extends m2 m2') ->\nexists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz))","proofString":"intros [m2' [C D]].\nexists Vundef; exists m2'; intuition auto.\neconstructor; eauto.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') : exists (vres' : val) (m2'0 : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2'0 /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2'0 /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'0.","conclusion":"exists (vres' : val) (m2'0 : mem),\n  extcall_free_sem ge (Vptr b lo :: nil) m1' E0 vres' m2'0 /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2'0 /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'0","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2')","proofString":"exists Vundef; exists m2'; intuition auto.\neconstructor; eauto.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') : extcall_free_sem ge (Vptr b lo :: nil) m1' E0 Vundef m2'.","conclusion":"extcall_free_sem ge (Vptr b lo :: nil) m1' E0 Vundef m2'","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2')","proofString":"econstructor; eauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') : Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2')","proofString":"eapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') : forall i : Z,\nPtrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz -> ~ loc_out_of_bounds m1 b i.","conclusion":"forall i : Z,\nPtrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz -> ~ loc_out_of_bounds m1 b i","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2')","proofString":"unfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) : ~ ~ Mem.perm m1 b i Max Nonempty.","conclusion":"~ ~ Mem.perm m1 b i Max Nonempty","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz)","proofString":"assert (Mem.perm m1 b i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto.\ntauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) : Mem.perm m1 b i Max Nonempty.","conclusion":"Mem.perm m1 b i Max Nonempty","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz)","proofString":"apply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) : Mem.perm m1 b i Cur Nonempty.","conclusion":"Mem.perm m1 b i Cur Nonempty","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz)","proofString":"apply Mem.perm_implies with Freeable; auto with mem.\neapply Mem.free_range_perm.\neexact H3.\neauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) : Mem.perm m1 b i Cur Freeable.","conclusion":"Mem.perm m1 b i Cur Freeable","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz)","proofString":"eapply Mem.free_range_perm.\neexact H3.\neauto."},{"statement":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) (H1 : Mem.perm m1 b i Max Nonempty) : ~ ~ Mem.perm m1 b i Max Nonempty.","conclusion":"~ ~ Mem.perm m1 b i Max Nonempty","hypotheses":"(ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (b : block) (lo sz : ptrofs) (H2 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H3 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (B : Val.lessdef (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b (Ptrofs.unsigned lo - size_chunk Mptr) =\nSome (Vptrofs sz)) (m2' : mem) (C : Mem.free m1' b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz) (H1 : Mem.perm m1 b i Max Nonempty)","proofString":"tauto."},{"statement":"(ge : Senv.t) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list (Vnullptr :: nil) vargs') : exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge vargs' m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge vargs' m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(ge : Senv.t) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list (Vnullptr :: nil) vargs')","proofString":"inv H1.\ninv H5.\nreplace v2 with Vnullptr.\nexists Vundef; exists m1'; intuition auto.\nconstructor.\napply Mem.unchanged_on_refl.\nunfold Vnullptr in *; destruct Archi.ptr64; inv H3; auto."},{"statement":"(ge : Senv.t) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (v2 : val) (vl2 : list val) (H3 : Val.lessdef Vnullptr v2) (H5 : Val.lessdef_list nil vl2) : exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (v2 :: vl2) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (v2 :: vl2) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(ge : Senv.t) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (v2 : val) (vl2 : list val) (H3 : Val.lessdef Vnullptr v2) (H5 : Val.lessdef_list nil vl2)","proofString":"inv H5.\nreplace v2 with Vnullptr.\nexists Vundef; exists m1'; intuition auto.\nconstructor.\napply Mem.unchanged_on_refl.\nunfold Vnullptr in *; destruct Archi.ptr64; inv H3; auto."},{"statement":"(ge : Senv.t) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (v2 : val) (H3 : Val.lessdef Vnullptr v2) : exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (v2 :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (v2 :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(ge : Senv.t) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (v2 : val) (H3 : Val.lessdef Vnullptr v2)","proofString":"replace v2 with Vnullptr.\nexists Vundef; exists m1'; intuition auto.\nconstructor.\napply Mem.unchanged_on_refl.\nunfold Vnullptr in *; destruct Archi.ptr64; inv H3; auto."},{"statement":"(ge : Senv.t) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (v2 : val) (H3 : Val.lessdef Vnullptr v2) : exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vnullptr :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_free_sem ge (Vnullptr :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(ge : Senv.t) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (v2 : val) (H3 : Val.lessdef Vnullptr v2)","proofString":"exists Vundef; exists m1'; intuition auto.\nconstructor.\napply Mem.unchanged_on_refl."},{"statement":"(ge : Senv.t) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (v2 : val) (H3 : Val.lessdef Vnullptr v2) : extcall_free_sem ge (Vnullptr :: nil) m1' E0 Vundef m1'.","conclusion":"extcall_free_sem ge (Vnullptr :: nil) m1' E0 Vundef m1'","hypotheses":"(ge : Senv.t) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (v2 : val) (H3 : Val.lessdef Vnullptr v2)","proofString":"constructor."},{"statement":"(ge : Senv.t) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (v2 : val) (H3 : Val.lessdef Vnullptr v2) : Mem.unchanged_on (loc_out_of_bounds m2) m1' m1'.","conclusion":"Mem.unchanged_on (loc_out_of_bounds m2) m1' m1'","hypotheses":"(ge : Senv.t) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (v2 : val) (H3 : Val.lessdef Vnullptr v2)","proofString":"apply Mem.unchanged_on_refl."},{"statement":"(ge : Senv.t) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (v2 : val) (H3 : Val.lessdef Vnullptr v2) : Vnullptr = v2.","conclusion":"Vnullptr = v2","hypotheses":"(ge : Senv.t) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (v2 : val) (H3 : Val.lessdef Vnullptr v2)","proofString":"unfold Vnullptr in *; destruct Archi.ptr64; inv H3; auto."},{"statement":"(ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : extcall_free_sem ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : extcall_free_sem ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"inv H0.\ninv H2.\ninv H6.\ninv H8.\nexploit Mem.load_inject; eauto.\nintros [v' [A B]].\nassert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nassert (P: Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr) (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable).\neapply Mem.free_range_perm; eauto.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) = Ptrofs.unsigned lo + delta).\neapply Mem.address_inject_gen with (p := Freeable); eauto.\nright.\napply P.\ngeneralize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia.\nexploit Mem.free_parallel_inject; eauto.\nintros (m2' & C & D).\nexists f, Vundef, m2'; split.\napply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence.\ninv H2.\ninv H6.\nreplace v' with Vnullptr.\nexists f, Vundef, m1'; intuition auto using Mem.unchanged_on_refl.\nconstructor.\nred; intros; congruence.\nunfold Vnullptr in *; destruct Archi.ptr64; inv H4; auto."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo : ptrofs) (H2 : Val.inject_list f (Vptr b lo :: nil) vargs') (sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 vargs' m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 vargs' m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo : ptrofs) (H2 : Val.inject_list f (Vptr b lo :: nil) vargs') (sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2)","proofString":"inv H2.\ninv H6.\ninv H8.\nexploit Mem.load_inject; eauto.\nintros [v' [A B]].\nassert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nassert (P: Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr) (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable).\neapply Mem.free_range_perm; eauto.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) = Ptrofs.unsigned lo + delta).\neapply Mem.address_inject_gen with (p := Freeable); eauto.\nright.\napply P.\ngeneralize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia.\nexploit Mem.free_parallel_inject; eauto.\nintros (m2' & C & D).\nexists f, Vundef, m2'; split.\napply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (v' : val) (vl' : list val) (H6 : Val.inject f (Vptr b lo) v') (H8 : Val.inject_list f nil vl') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (v' :: vl') m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (v' :: vl') m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (v' : val) (vl' : list val) (H6 : Val.inject f (Vptr b lo) v') (H8 : Val.inject_list f nil vl')","proofString":"inv H6.\ninv H8.\nexploit Mem.load_inject; eauto.\nintros [v' [A B]].\nassert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nassert (P: Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr) (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable).\neapply Mem.free_range_perm; eauto.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) = Ptrofs.unsigned lo + delta).\neapply Mem.address_inject_gen with (p := Freeable); eauto.\nright.\napply P.\ngeneralize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia.\nexploit Mem.free_parallel_inject; eauto.\nintros (m2' & C & D).\nexists f, Vundef, m2'; split.\napply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (vl' : list val) (H8 : Val.inject_list f nil vl') (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: vl')\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: vl')\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (vl' : list val) (H8 : Val.inject_list f nil vl') (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta))","proofString":"inv H8.\nexploit Mem.load_inject; eauto.\nintros [v' [A B]].\nassert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nassert (P: Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr) (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable).\neapply Mem.free_range_perm; eauto.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) = Ptrofs.unsigned lo + delta).\neapply Mem.address_inject_gen with (p := Freeable); eauto.\nright.\napply P.\ngeneralize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia.\nexploit Mem.free_parallel_inject; eauto.\nintros (m2' & C & D).\nexists f, Vundef, m2'; split.\napply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta))","proofString":"exploit Mem.load_inject; eauto.\nintros [v' [A B]].\nassert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nassert (P: Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr) (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable).\neapply Mem.free_range_perm; eauto.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) = Ptrofs.unsigned lo + delta).\neapply Mem.address_inject_gen with (p := Freeable); eauto.\nright.\napply P.\ngeneralize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia.\nexploit Mem.free_parallel_inject; eauto.\nintros (m2' & C & D).\nexists f, Vundef, m2'; split.\napply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) : (exists v2 : val,\n   Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\n   Some v2 /\\ Val.inject f (Vptrofs sz) v2) ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"(exists v2 : val,\n   Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\n   Some v2 /\\ Val.inject f (Vptrofs sz) v2) ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta))","proofString":"intros [v' [A B]].\nassert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nassert (P: Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr) (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable).\neapply Mem.free_range_perm; eauto.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) = Ptrofs.unsigned lo + delta).\neapply Mem.address_inject_gen with (p := Freeable); eauto.\nright.\napply P.\ngeneralize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia.\nexploit Mem.free_parallel_inject; eauto.\nintros (m2' & C & D).\nexists f, Vundef, m2'; split.\napply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (v' : val) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) = Some v') (B : Val.inject f (Vptrofs sz) v') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (v' : val) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) = Some v') (B : Val.inject f (Vptrofs sz) v')","proofString":"assert (v' = Vptrofs sz).\nunfold Vptrofs in *; destruct Archi.ptr64; inv B; auto.\nsubst v'.\nassert (P: Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr) (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable).\neapply Mem.free_range_perm; eauto.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) = Ptrofs.unsigned lo + delta).\neapply Mem.address_inject_gen with (p := Freeable); eauto.\nright.\napply P.\ngeneralize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia.\nexploit Mem.free_parallel_inject; eauto.\nintros (m2' & C & D).\nexists f, Vundef, m2'; split.\napply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (v' : val) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) = Some v') (B : Val.inject f (Vptrofs sz) v') : v' = Vptrofs sz.","conclusion":"v' = Vptrofs sz","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (v' : val) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) = Some v') (B : Val.inject f (Vptrofs sz) v')","proofString":"unfold Vptrofs in *; destruct Archi.ptr64; inv B; auto."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (v' : val) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) = Some v') (B : Val.inject f (Vptrofs sz) v') (H0 : v' = Vptrofs sz) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (v' : val) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) = Some v') (B : Val.inject f (Vptrofs sz) v') (H0 : v' = Vptrofs sz)","proofString":"subst v'.\nassert (P: Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr) (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable).\neapply Mem.free_range_perm; eauto.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) = Ptrofs.unsigned lo + delta).\neapply Mem.address_inject_gen with (p := Freeable); eauto.\nright.\napply P.\ngeneralize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia.\nexploit Mem.free_parallel_inject; eauto.\nintros (m2' & C & D).\nexists f, Vundef, m2'; split.\napply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz))","proofString":"assert (P: Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr) (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable).\neapply Mem.free_range_perm; eauto.\nassert (EQ: Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) = Ptrofs.unsigned lo + delta).\neapply Mem.address_inject_gen with (p := Freeable); eauto.\nright.\napply P.\ngeneralize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia.\nexploit Mem.free_parallel_inject; eauto.\nintros (m2' & C & D).\nexists f, Vundef, m2'; split.\napply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable.","conclusion":"Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz))","proofString":"eapply Mem.free_range_perm; eauto."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable)","proofString":"assert (EQ: Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) = Ptrofs.unsigned lo + delta).\neapply Mem.address_inject_gen with (p := Freeable); eauto.\nright.\napply P.\ngeneralize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia.\nexploit Mem.free_parallel_inject; eauto.\nintros (m2' & C & D).\nexists f, Vundef, m2'; split.\napply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta.","conclusion":"Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable)","proofString":"eapply Mem.address_inject_gen with (p := Freeable); eauto.\nright.\napply P.\ngeneralize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) : Mem.perm m1 b (Ptrofs.unsigned lo) Cur Freeable \\/\nMem.perm m1 b (Ptrofs.unsigned lo - 1) Cur Freeable.","conclusion":"Mem.perm m1 b (Ptrofs.unsigned lo) Cur Freeable \\/\nMem.perm m1 b (Ptrofs.unsigned lo - 1) Cur Freeable","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable)","proofString":"right.\napply P.\ngeneralize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) : Mem.perm m1 b (Ptrofs.unsigned lo - 1) Cur Freeable.","conclusion":"Mem.perm m1 b (Ptrofs.unsigned lo - 1) Cur Freeable","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable)","proofString":"apply P.\ngeneralize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) : Ptrofs.unsigned lo - size_chunk Mptr <= Ptrofs.unsigned lo - 1 <\nPtrofs.unsigned lo + Ptrofs.unsigned sz.","conclusion":"Ptrofs.unsigned lo - size_chunk Mptr <= Ptrofs.unsigned lo - 1 <\nPtrofs.unsigned lo + Ptrofs.unsigned sz","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable)","proofString":"generalize (size_chunk_pos Mptr), (Ptrofs.unsigned_range sz); lia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta)","proofString":"exploit Mem.free_parallel_inject; eauto.\nintros (m2' & C & D).\nexists f, Vundef, m2'; split.\napply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) : (exists m2' : mem,\n   Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n     (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \n   Some m2' /\\ Mem.inject f m2 m2') ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"(exists m2' : mem,\n   Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n     (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \n   Some m2' /\\ Mem.inject f m2 m2') ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta)","proofString":"intros (m2' & C & D).\nexists f, Vundef, m2'; split.\napply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : exists (f' : meminj) (vres' : val) (m2'0 : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2'0 /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2'0 /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'0 /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2'0 : mem),\n  extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil)\n    m1' E0 vres' m2'0 /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2'0 /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'0 /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"exists f, Vundef, m2'; split.\napply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia.\nsplit.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil) m1'\n  E0 Vundef m2'.","conclusion":"extcall_free_sem ge2 (Vptr b2 (Ptrofs.add lo (Ptrofs.repr delta)) :: nil) m1'\n  E0 Vundef m2'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"apply extcall_free_sem_ptr with (sz := sz) (m' := m2').\nrewrite EQ.\nrewrite <- A.\nf_equal.\nlia.\nauto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.load Mptr m1' b2\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) - size_chunk Mptr) =\nSome (Vptrofs sz).","conclusion":"Mem.load Mptr m1' b2\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) - size_chunk Mptr) =\nSome (Vptrofs sz)","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"rewrite EQ.\nrewrite <- A.\nf_equal.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo + delta - size_chunk Mptr) =\nSome (Vptrofs sz).","conclusion":"Mem.load Mptr m1' b2 (Ptrofs.unsigned lo + delta - size_chunk Mptr) =\nSome (Vptrofs sz)","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"rewrite <- A.\nf_equal.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo + delta - size_chunk Mptr) =\nMem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta).","conclusion":"Mem.load Mptr m1' b2 (Ptrofs.unsigned lo + delta - size_chunk Mptr) =\nMem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"f_equal.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Ptrofs.unsigned lo + delta - size_chunk Mptr =\nPtrofs.unsigned lo - size_chunk Mptr + delta.","conclusion":"Ptrofs.unsigned lo + delta - size_chunk Mptr =\nPtrofs.unsigned lo - size_chunk Mptr + delta","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"lia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.free m1' b2\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) - size_chunk Mptr)\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) + Ptrofs.unsigned sz) =\nSome m2'.","conclusion":"Mem.free m1' b2\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) - size_chunk Mptr)\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) + Ptrofs.unsigned sz) =\nSome m2'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"auto.\nauto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.free m1' b2\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) - size_chunk Mptr)\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) + Ptrofs.unsigned sz) =\nSome m2'.","conclusion":"Mem.free m1' b2\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) - size_chunk Mptr)\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) + Ptrofs.unsigned sz) =\nSome m2'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"auto.\nrewrite ! EQ.\nrewrite <- C.\nf_equal; lia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.free m1' b2\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) - size_chunk Mptr)\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) + Ptrofs.unsigned sz) =\nSome m2'.","conclusion":"Mem.free m1' b2\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) - size_chunk Mptr)\n  (Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) + Ptrofs.unsigned sz) =\nSome m2'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"rewrite ! EQ.\nrewrite <- C.\nf_equal; lia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.free m1' b2 (Ptrofs.unsigned lo + delta - size_chunk Mptr)\n  (Ptrofs.unsigned lo + delta + Ptrofs.unsigned sz) = \nSome m2'.","conclusion":"Mem.free m1' b2 (Ptrofs.unsigned lo + delta - size_chunk Mptr)\n  (Ptrofs.unsigned lo + delta + Ptrofs.unsigned sz) = \nSome m2'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"rewrite <- C.\nf_equal; lia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.free m1' b2 (Ptrofs.unsigned lo + delta - size_chunk Mptr)\n  (Ptrofs.unsigned lo + delta + Ptrofs.unsigned sz) =\nMem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta).","conclusion":"Mem.free m1' b2 (Ptrofs.unsigned lo + delta - size_chunk Mptr)\n  (Ptrofs.unsigned lo + delta + Ptrofs.unsigned sz) =\nMem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta)","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"f_equal; lia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Val.inject f Vundef Vundef /\\\nMem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"Val.inject f Vundef Vundef /\\\nMem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"split.\nauto.\nsplit.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Val.inject f Vundef Vundef.","conclusion":"Val.inject f Vundef Vundef","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"auto."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"Mem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"split.\nauto.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.inject f m2 m2'.","conclusion":"Mem.inject f m2 m2'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"auto."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"split.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence.\nsplit.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.unchanged_on (loc_unmapped f) m1 m2.","conclusion":"Mem.unchanged_on (loc_unmapped f) m1 m2","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"eapply Mem.free_unchanged_on; eauto.\nunfold loc_unmapped.\nintros; congruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : forall i : Z,\nPtrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz -> ~ loc_unmapped f b i.","conclusion":"forall i : Z,\nPtrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz -> ~ loc_unmapped f b i","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"unfold loc_unmapped.\nintros; congruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : forall i : Z,\nPtrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz -> f b <> None.","conclusion":"forall i : Z,\nPtrofs.unsigned lo - size_chunk Mptr <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz -> f b <> None","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"intros; congruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"split.\neapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia.\nsplit.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'.","conclusion":"Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"eapply Mem.free_unchanged_on; eauto.\nunfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : forall i : Z,\nPtrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta ->\n~ loc_out_of_reach f m1 b2 i.","conclusion":"forall i : Z,\nPtrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta ->\n~ loc_out_of_reach f m1 b2 i","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"unfold loc_out_of_reach.\nintros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : forall i : Z,\nPtrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta ->\n~\n(forall (b0 : block) (delta0 : Z),\n f b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty).","conclusion":"forall i : Z,\nPtrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta ->\n~\n(forall (b0 : block) (delta0 : Z),\n f b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty)","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta) : ~\n(forall (b0 : block) (delta0 : Z),\n f b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty).","conclusion":"~\n(forall (b0 : block) (delta0 : Z),\n f b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty)","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta)","proofString":"red; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta) (H2 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) : False.","conclusion":"False","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta) (H2 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty)","proofString":"eelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta) (H2 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) : Mem.perm m1 b (i - delta) Max Nonempty.","conclusion":"Mem.perm m1 b (i - delta) Max Nonempty","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta) (H2 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty)","proofString":"apply Mem.perm_cur_max.\napply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta) (H2 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) : Mem.perm m1 b (i - delta) Cur Nonempty.","conclusion":"Mem.perm m1 b (i - delta) Cur Nonempty","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta) (H2 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty)","proofString":"apply Mem.perm_implies with Freeable; auto with mem.\napply P.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta) (H2 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) : Mem.perm m1 b (i - delta) Cur Freeable.","conclusion":"Mem.perm m1 b (i - delta) Cur Freeable","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta) (H2 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty)","proofString":"apply P.\nlia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta) (H2 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty) : Ptrofs.unsigned lo - size_chunk Mptr <= i - delta <\nPtrofs.unsigned lo + Ptrofs.unsigned sz.","conclusion":"Ptrofs.unsigned lo - size_chunk Mptr <= i - delta <\nPtrofs.unsigned lo + Ptrofs.unsigned sz","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned lo - size_chunk Mptr + delta <= i <\nPtrofs.unsigned lo + Ptrofs.unsigned sz + delta) (H2 : forall (b0 : block) (delta0 : Z),\nf b0 = Some (b2, delta0) -> ~ Mem.perm m1 b0 (i - delta0) Max Nonempty)","proofString":"lia."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : inject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"inject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"split.\nauto.\nred; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : inject_incr f f.","conclusion":"inject_incr f f","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"auto."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') : inject_separated f f m1 m1'.","conclusion":"inject_separated f f m1 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2')","proofString":"red; intros.\ncongruence."},{"statement":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (b1 b0 : block) (delta0 : Z) (H0 : f b1 = None) (H2 : f b1 = Some (b0, delta0)) : ~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b0.","conclusion":"~ Mem.valid_block m1 b1 /\\ ~ Mem.valid_block m1' b0","hypotheses":"(ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (b : block) (lo sz : ptrofs) (H3 : Mem.load Mptr m1 b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H4 : Mem.free m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (b2 : block) (delta : Z) (H5 : f b = Some (b2, delta)) (B : Val.inject f (Vptrofs sz) (Vptrofs sz)) (A : Mem.load Mptr m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta) =\nSome (Vptrofs sz)) (P : Mem.range_perm m1 b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) Cur Freeable) (EQ : Ptrofs.unsigned (Ptrofs.add lo (Ptrofs.repr delta)) =\nPtrofs.unsigned lo + delta) (m2' : mem) (C : Mem.free m1' b2 (Ptrofs.unsigned lo - size_chunk Mptr + delta)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz + delta) = \nSome m2') (D : Mem.inject f m2 m2') (b1 b0 : block) (delta0 : Z) (H0 : f b1 = None) (H2 : f b1 = Some (b0, delta0))","proofString":"congruence."},{"statement":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f (Vnullptr :: nil) vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 vargs' m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 vargs' m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f (Vnullptr :: nil) vargs')","proofString":"inv H2.\ninv H6.\nreplace v' with Vnullptr.\nexists f, Vundef, m1'; intuition auto using Mem.unchanged_on_refl.\nconstructor.\nred; intros; congruence.\nunfold Vnullptr in *; destruct Archi.ptr64; inv H4; auto."},{"statement":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (v' : val) (vl' : list val) (H4 : Val.inject f Vnullptr v') (H6 : Val.inject_list f nil vl') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (v' :: vl') m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (v' :: vl') m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (v' : val) (vl' : list val) (H4 : Val.inject f Vnullptr v') (H6 : Val.inject_list f nil vl')","proofString":"inv H6.\nreplace v' with Vnullptr.\nexists f, Vundef, m1'; intuition auto using Mem.unchanged_on_refl.\nconstructor.\nred; intros; congruence.\nunfold Vnullptr in *; destruct Archi.ptr64; inv H4; auto."},{"statement":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (v' : val) (H4 : Val.inject f Vnullptr v') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (v' :: nil) m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (v' :: nil) m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (v' : val) (H4 : Val.inject f Vnullptr v')","proofString":"replace v' with Vnullptr.\nexists f, Vundef, m1'; intuition auto using Mem.unchanged_on_refl.\nconstructor.\nred; intros; congruence.\nunfold Vnullptr in *; destruct Archi.ptr64; inv H4; auto."},{"statement":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (v' : val) (H4 : Val.inject f Vnullptr v') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vnullptr :: nil) m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_free_sem ge2 (Vnullptr :: nil) m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (v' : val) (H4 : Val.inject f Vnullptr v')","proofString":"exists f, Vundef, m1'; intuition auto using Mem.unchanged_on_refl.\nconstructor.\nred; intros; congruence."},{"statement":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (v' : val) (H4 : Val.inject f Vnullptr v') : extcall_free_sem ge2 (Vnullptr :: nil) m1' E0 Vundef m1'.","conclusion":"extcall_free_sem ge2 (Vnullptr :: nil) m1' E0 Vundef m1'","hypotheses":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (v' : val) (H4 : Val.inject f Vnullptr v')","proofString":"constructor."},{"statement":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (v' : val) (H4 : Val.inject f Vnullptr v') : inject_separated f f m2 m1'.","conclusion":"inject_separated f f m2 m1'","hypotheses":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (v' : val) (H4 : Val.inject f Vnullptr v')","proofString":"red; intros; congruence."},{"statement":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (v' : val) (H4 : Val.inject f Vnullptr v') : Vnullptr = v'.","conclusion":"Vnullptr = v'","hypotheses":"(ge1 ge2 : Senv.t) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (v' : val) (H4 : Val.inject f Vnullptr v')","proofString":"unfold Vnullptr in *; destruct Archi.ptr64; inv H4; auto."},{"statement":"(ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : extcall_free_sem ge vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : extcall_free_sem ge vargs m t vres m')","proofString":"inv H; simpl; lia."},{"statement":"(ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_free_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : exists (vres2 : val) (m2 : mem), extcall_free_sem ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem), extcall_free_sem ge vargs m t2 vres2 m2","hypotheses":"(ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_free_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"assert (t1 = t2) by (inv H; inv H0; auto).\nsubst t2.\nexists vres1; exists m1; auto."},{"statement":"(ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_free_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) (H1 : t1 = t2) : exists (vres2 : val) (m2 : mem), extcall_free_sem ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem), extcall_free_sem ge vargs m t2 vres2 m2","hypotheses":"(ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_free_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) (H1 : t1 = t2)","proofString":"subst t2.\nexists vres1; exists m1; auto."},{"statement":"(ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (H : extcall_free_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t1) : exists (vres2 : val) (m2 : mem), extcall_free_sem ge vargs m t1 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem), extcall_free_sem ge vargs m t1 vres2 m2","hypotheses":"(ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (H : extcall_free_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t1)","proofString":"exists vres1; exists m1; auto."},{"statement":"(ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : extcall_free_sem ge vargs m t1 vres1 m1) (H0 : extcall_free_sem ge vargs m t2 vres2 m2) : match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2).","conclusion":"match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2)","hypotheses":"(ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : extcall_free_sem ge vargs m t1 vres1 m1) (H0 : extcall_free_sem ge vargs m t2 vres2 m2)","proofString":"inv H; inv H0; try (unfold Vnullptr in *; destruct Archi.ptr64; discriminate).\nassert (EQ1: Vptrofs sz0 = Vptrofs sz) by congruence.\nassert (EQ2: sz0 = sz).\nunfold Vptrofs in EQ1; destruct Archi.ptr64 eqn:SF.\nrewrite <- (Ptrofs.of_int64_to_int64 SF sz0), <- (Ptrofs.of_int64_to_int64 SF sz).\ncongruence.\nrewrite <- (Ptrofs.of_int_to_int SF sz0), <- (Ptrofs.of_int_to_int SF sz).\ncongruence.\nsubst sz0.\nsplit.\nconstructor.\nintuition congruence.\nsplit.\nconstructor.\nintuition auto."},{"statement":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) : match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m1 = m2).","conclusion":"match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m1 = m2)","hypotheses":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2)","proofString":"assert (EQ1: Vptrofs sz0 = Vptrofs sz) by congruence.\nassert (EQ2: sz0 = sz).\nunfold Vptrofs in EQ1; destruct Archi.ptr64 eqn:SF.\nrewrite <- (Ptrofs.of_int64_to_int64 SF sz0), <- (Ptrofs.of_int64_to_int64 SF sz).\ncongruence.\nrewrite <- (Ptrofs.of_int_to_int SF sz0), <- (Ptrofs.of_int_to_int SF sz).\ncongruence.\nsubst sz0.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (EQ1 : Vptrofs sz0 = Vptrofs sz) : match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m1 = m2).","conclusion":"match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m1 = m2)","hypotheses":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (EQ1 : Vptrofs sz0 = Vptrofs sz)","proofString":"assert (EQ2: sz0 = sz).\nunfold Vptrofs in EQ1; destruct Archi.ptr64 eqn:SF.\nrewrite <- (Ptrofs.of_int64_to_int64 SF sz0), <- (Ptrofs.of_int64_to_int64 SF sz).\ncongruence.\nrewrite <- (Ptrofs.of_int_to_int SF sz0), <- (Ptrofs.of_int_to_int SF sz).\ncongruence.\nsubst sz0.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (EQ1 : Vptrofs sz0 = Vptrofs sz) : sz0 = sz.","conclusion":"sz0 = sz","hypotheses":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (EQ1 : Vptrofs sz0 = Vptrofs sz)","proofString":"unfold Vptrofs in EQ1; destruct Archi.ptr64 eqn:SF.\nrewrite <- (Ptrofs.of_int64_to_int64 SF sz0), <- (Ptrofs.of_int64_to_int64 SF sz).\ncongruence.\nrewrite <- (Ptrofs.of_int_to_int SF sz0), <- (Ptrofs.of_int_to_int SF sz).\ncongruence."},{"statement":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (SF : Archi.ptr64 = true) (EQ1 : Vlong (Ptrofs.to_int64 sz0) = Vlong (Ptrofs.to_int64 sz)) : sz0 = sz.","conclusion":"sz0 = sz","hypotheses":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (SF : Archi.ptr64 = true) (EQ1 : Vlong (Ptrofs.to_int64 sz0) = Vlong (Ptrofs.to_int64 sz))","proofString":"rewrite <- (Ptrofs.of_int64_to_int64 SF sz0), <- (Ptrofs.of_int64_to_int64 SF sz).\ncongruence."},{"statement":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (SF : Archi.ptr64 = true) (EQ1 : Vlong (Ptrofs.to_int64 sz0) = Vlong (Ptrofs.to_int64 sz)) : Ptrofs.of_int64 (Ptrofs.to_int64 sz0) = Ptrofs.of_int64 (Ptrofs.to_int64 sz).","conclusion":"Ptrofs.of_int64 (Ptrofs.to_int64 sz0) = Ptrofs.of_int64 (Ptrofs.to_int64 sz)","hypotheses":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (SF : Archi.ptr64 = true) (EQ1 : Vlong (Ptrofs.to_int64 sz0) = Vlong (Ptrofs.to_int64 sz))","proofString":"congruence."},{"statement":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (SF : Archi.ptr64 = false) (EQ1 : Vint (Ptrofs.to_int sz0) = Vint (Ptrofs.to_int sz)) : sz0 = sz.","conclusion":"sz0 = sz","hypotheses":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (SF : Archi.ptr64 = false) (EQ1 : Vint (Ptrofs.to_int sz0) = Vint (Ptrofs.to_int sz))","proofString":"rewrite <- (Ptrofs.of_int_to_int SF sz0), <- (Ptrofs.of_int_to_int SF sz).\ncongruence."},{"statement":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (SF : Archi.ptr64 = false) (EQ1 : Vint (Ptrofs.to_int sz0) = Vint (Ptrofs.to_int sz)) : Ptrofs.of_int (Ptrofs.to_int sz0) = Ptrofs.of_int (Ptrofs.to_int sz).","conclusion":"Ptrofs.of_int (Ptrofs.to_int sz0) = Ptrofs.of_int (Ptrofs.to_int sz)","hypotheses":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (SF : Archi.ptr64 = false) (EQ1 : Vint (Ptrofs.to_int sz0) = Vint (Ptrofs.to_int sz))","proofString":"congruence."},{"statement":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (EQ1 : Vptrofs sz0 = Vptrofs sz) (EQ2 : sz0 = sz) : match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m1 = m2).","conclusion":"match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m1 = m2)","hypotheses":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (sz0 : ptrofs) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz0)) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz0) = Some m2) (EQ1 : Vptrofs sz0 = Vptrofs sz) (EQ2 : sz0 = sz)","proofString":"subst sz0.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (EQ1 : Vptrofs sz = Vptrofs sz) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) : match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m1 = m2).","conclusion":"match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m1 = m2)","hypotheses":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (EQ1 : Vptrofs sz = Vptrofs sz) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz))","proofString":"split.\nconstructor.\nintuition congruence."},{"statement":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (EQ1 : Vptrofs sz = Vptrofs sz) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) : match_traces ge E0 E0.","conclusion":"match_traces ge E0 E0","hypotheses":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (EQ1 : Vptrofs sz = Vptrofs sz) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz))","proofString":"constructor."},{"statement":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (EQ1 : Vptrofs sz = Vptrofs sz) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) : E0 = E0 -> Vundef = Vundef /\\ m1 = m2.","conclusion":"E0 = E0 -> Vundef = Vundef /\\ m1 = m2","hypotheses":"(ge : Senv.t) (m m1 m2 : mem) (b : block) (lo sz : ptrofs) (H1 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz)) (H2 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m1) (EQ1 : Vptrofs sz = Vptrofs sz) (H9 : Mem.free m b (Ptrofs.unsigned lo - size_chunk Mptr)\n  (Ptrofs.unsigned lo + Ptrofs.unsigned sz) = Some m2) (H4 : Mem.load Mptr m b (Ptrofs.unsigned lo - size_chunk Mptr) = Some (Vptrofs sz))","proofString":"intuition congruence."},{"statement":"(ge : Senv.t) (m2 : mem) : match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m2 = m2).","conclusion":"match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m2 = m2)","hypotheses":"(ge : Senv.t) (m2 : mem)","proofString":"split.\nconstructor.\nintuition auto."},{"statement":"(ge : Senv.t) (m2 : mem) : match_traces ge E0 E0.","conclusion":"match_traces ge E0 E0","hypotheses":"(ge : Senv.t) (m2 : mem)","proofString":"constructor."},{"statement":"(ge : Senv.t) (m2 : mem) : E0 = E0 -> Vundef = Vundef /\\ m2 = m2.","conclusion":"E0 = E0 -> Vundef = Vundef /\\ m2 = m2","hypotheses":"(ge : Senv.t) (m2 : mem)","proofString":"intuition auto."},{"statement":"(sz al : Z) : extcall_properties (extcall_memcpy_sem sz al) [Xptr; Xptr ---> Xvoid].","conclusion":"extcall_properties (extcall_memcpy_sem sz al) [Xptr; Xptr ---> Xvoid]","hypotheses":"(sz al : Z)","proofString":"constructor.\nintros.\ninv H.\nexact I.\nintros.\ninv H0.\neconstructor; eauto.\nintros.\ninv H.\neauto with mem.\nintros.\ninv H.\neapply Mem.perm_storebytes_2; eauto.\nintros.\ninv H.\neapply unchanged_on_readonly; eauto.\neapply Mem.storebytes_unchanged_on; eauto.\nintros; red; intros.\nelim H11.\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto.\nintros.\ninv H.\ninv H1.\ninv H13.\ninv H14.\ninv H10.\ninv H11.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nexploit Mem.loadbytes_extends; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_within_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto.\nintros.\ninv H0.\ninv H2.\ninv H14.\ninv H15.\ninv H11.\ninv H12.\ndestruct (zeq sz 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m1 bsrc (Ptrofs.unsigned osrc) sz).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes m1' b0 (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil)  as [m2' SB].\nsimpl.\nred; intros; extlia.\nexists f, Vundef, m2'.\nsplit.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).\nreplace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence.\nintros; inv H.\nsimpl; lia.\nintros.\nassert (t1 = t2).\ninv H; inv H0; auto.\nsubst t2.\nexists vres1; exists m1; auto.\nintros; inv H; inv H0.\nsplit.\nconstructor.\nintros; split; congruence."},{"statement":"(sz al : Z) : forall (ge : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 : mem),\nextcall_memcpy_sem sz al ge vargs m1 t vres m2 ->\nVal.has_rettype vres (sig_res [Xptr; Xptr ---> Xvoid]).","conclusion":"forall (ge : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 : mem),\nextcall_memcpy_sem sz al ge vargs m1 t vres m2 ->\nVal.has_rettype vres (sig_res [Xptr; Xptr ---> Xvoid])","hypotheses":"(sz al : Z)","proofString":"intros.\ninv H.\nexact I."},{"statement":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : extcall_memcpy_sem sz al ge vargs m1 t vres m2) : Val.has_rettype vres (sig_res [Xptr; Xptr ---> Xvoid]).","conclusion":"Val.has_rettype vres (sig_res [Xptr; Xptr ---> Xvoid])","hypotheses":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : extcall_memcpy_sem sz al ge vargs m1 t vres m2)","proofString":"inv H.\nexact I."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz >= 0) (H2 : (al | sz)) (H3 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H4 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H5 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H6 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H7 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) : Val.has_rettype Vundef (sig_res [Xptr; Xptr ---> Xvoid]).","conclusion":"Val.has_rettype Vundef (sig_res [Xptr; Xptr ---> Xvoid])","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz >= 0) (H2 : (al | sz)) (H3 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H4 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H5 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H6 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H7 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2)","proofString":"exact I."},{"statement":"(sz al : Z) : forall (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 : mem),\nSenv.equiv ge1 ge2 ->\nextcall_memcpy_sem sz al ge1 vargs m1 t vres m2 ->\nextcall_memcpy_sem sz al ge2 vargs m1 t vres m2.","conclusion":"forall (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 : mem),\nSenv.equiv ge1 ge2 ->\nextcall_memcpy_sem sz al ge1 vargs m1 t vres m2 ->\nextcall_memcpy_sem sz al ge2 vargs m1 t vres m2","hypotheses":"(sz al : Z)","proofString":"intros.\ninv H0.\neconstructor; eauto."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : extcall_memcpy_sem sz al ge1 vargs m1 t vres m2) : extcall_memcpy_sem sz al ge2 vargs m1 t vres m2.","conclusion":"extcall_memcpy_sem sz al ge2 vargs m1 t vres m2","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : extcall_memcpy_sem sz al ge1 vargs m1 t vres m2)","proofString":"inv H0.\neconstructor; eauto."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (H : Senv.equiv ge1 ge2) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) : extcall_memcpy_sem sz al ge2 (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1 E0\n  Vundef m2.","conclusion":"extcall_memcpy_sem sz al ge2 (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1 E0\n  Vundef m2","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (H : Senv.equiv ge1 ge2) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2)","proofString":"econstructor; eauto."},{"statement":"(sz al : Z) : forall (ge : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 : mem) (b : block),\nextcall_memcpy_sem sz al ge vargs m1 t vres m2 ->\nMem.valid_block m1 b -> Mem.valid_block m2 b.","conclusion":"forall (ge : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 : mem) (b : block),\nextcall_memcpy_sem sz al ge vargs m1 t vres m2 ->\nMem.valid_block m1 b -> Mem.valid_block m2 b","hypotheses":"(sz al : Z)","proofString":"intros.\ninv H.\neauto with mem."},{"statement":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : extcall_memcpy_sem sz al ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : extcall_memcpy_sem sz al ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b)","proofString":"inv H.\neauto with mem."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (H0 : Mem.valid_block m1 b) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (H0 : Mem.valid_block m1 b) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2)","proofString":"eauto with mem."},{"statement":"(sz al : Z) : forall (ge : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 : mem) (b : block) \n  (ofs : Z) (p : permission),\nextcall_memcpy_sem sz al ge vargs m1 t vres m2 ->\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p.","conclusion":"forall (ge : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 : mem) (b : block) \n  (ofs : Z) (p : permission),\nextcall_memcpy_sem sz al ge vargs m1 t vres m2 ->\nMem.valid_block m1 b -> Mem.perm m2 b ofs Max p -> Mem.perm m1 b ofs Max p","hypotheses":"(sz al : Z)","proofString":"intros.\ninv H.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : extcall_memcpy_sem sz al ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) : Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p","hypotheses":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : extcall_memcpy_sem sz al ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p)","proofString":"inv H.\neapply Mem.perm_storebytes_2; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) : Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs : Z) (p : permission) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2)","proofString":"eapply Mem.perm_storebytes_2; eauto."},{"statement":"(sz al : Z) : forall (ge : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 : mem) (b : block) \n  (ofs n : Z) (bytes : list memval),\nextcall_memcpy_sem sz al ge vargs m1 t vres m2 ->\nMem.valid_block m1 b ->\nMem.loadbytes m2 b ofs n = Some bytes ->\n(forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) ->\nMem.loadbytes m1 b ofs n = Some bytes.","conclusion":"forall (ge : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 : mem) (b : block) \n  (ofs n : Z) (bytes : list memval),\nextcall_memcpy_sem sz al ge vargs m1 t vres m2 ->\nMem.valid_block m1 b ->\nMem.loadbytes m2 b ofs n = Some bytes ->\n(forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) ->\nMem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(sz al : Z)","proofString":"intros.\ninv H.\neapply unchanged_on_readonly; eauto.\neapply Mem.storebytes_unchanged_on; eauto.\nintros; red; intros.\nelim H11.\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_memcpy_sem sz al ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) : Mem.loadbytes m1 b ofs n = Some bytes.","conclusion":"Mem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_memcpy_sem sz al ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable)","proofString":"inv H.\neapply unchanged_on_readonly; eauto.\neapply Mem.storebytes_unchanged_on; eauto.\nintros; red; intros.\nelim H11.\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes0 : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes0 = Some m2) : Mem.loadbytes m1 b ofs n = Some bytes.","conclusion":"Mem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes0 : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes0 = Some m2)","proofString":"eapply unchanged_on_readonly; eauto.\neapply Mem.storebytes_unchanged_on; eauto.\nintros; red; intros.\nelim H11.\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes0 : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes0 = Some m2) : Mem.unchanged_on (loc_not_writable m1) m1 m2.","conclusion":"Mem.unchanged_on (loc_not_writable m1) m1 m2","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes0 : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes0 = Some m2)","proofString":"eapply Mem.storebytes_unchanged_on; eauto.\nintros; red; intros.\nelim H11.\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes0 : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes0 = Some m2) : forall i : Z,\nPtrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes0) ->\n~ loc_not_writable m1 bdst i.","conclusion":"forall i : Z,\nPtrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes0) ->\n~ loc_not_writable m1 bdst i","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes0 : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes0 = Some m2)","proofString":"intros; red; intros.\nelim H11.\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes0 : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes0 = Some m2) (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes0)) (H11 : loc_not_writable m1 bdst i) : False.","conclusion":"False","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes0 : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes0 = Some m2) (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes0)) (H11 : loc_not_writable m1 bdst i)","proofString":"elim H11.\napply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes0 : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes0 = Some m2) (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes0)) (H11 : loc_not_writable m1 bdst i) : Mem.perm m1 bdst i Max Writable.","conclusion":"Mem.perm m1 bdst i Max Writable","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes0 : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes0 = Some m2) (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes0)) (H11 : loc_not_writable m1 bdst i)","proofString":"apply Mem.perm_cur_max.\neapply Mem.storebytes_range_perm; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes0 : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes0 = Some m2) (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes0)) (H11 : loc_not_writable m1 bdst i) : Mem.perm m1 bdst i Cur Writable.","conclusion":"Mem.perm m1 bdst i Cur Writable","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i0 : Z, ofs <= i0 < ofs + n -> ~ Mem.perm m1 b i0 Max Writable) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes0 : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes0 = Some m2) (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes0)) (H11 : loc_not_writable m1 bdst i)","proofString":"eapply Mem.storebytes_range_perm; eauto."},{"statement":"(sz al : Z) : forall (ge : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val),\nextcall_memcpy_sem sz al ge vargs m1 t vres m2 ->\nMem.extends m1 m1' ->\nVal.lessdef_list vargs vargs' ->\nexists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"forall (ge : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val),\nextcall_memcpy_sem sz al ge vargs m1 t vres m2 ->\nMem.extends m1 m1' ->\nVal.lessdef_list vargs vargs' ->\nexists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z)","proofString":"intros.\ninv H.\ninv H1.\ninv H13.\ninv H14.\ninv H10.\ninv H11.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nexploit Mem.loadbytes_extends; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_within_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : extcall_memcpy_sem sz al ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs') : exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : extcall_memcpy_sem sz al ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs')","proofString":"inv H.\ninv H1.\ninv H13.\ninv H14.\ninv H10.\ninv H11.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nexploit Mem.loadbytes_extends; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_within_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H1 : Val.lessdef_list (Vptr bdst odst :: Vptr bsrc osrc :: nil) vargs') (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) : exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge vargs' m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge vargs' m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H1 : Val.lessdef_list (Vptr bdst odst :: Vptr bsrc osrc :: nil) vargs') (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2)","proofString":"inv H1.\ninv H13.\ninv H14.\ninv H10.\ninv H11.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nexploit Mem.loadbytes_extends; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_within_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v2 : val) (vl2 : list val) (H11 : Val.lessdef (Vptr bdst odst) v2) (H13 : Val.lessdef_list (Vptr bsrc osrc :: nil) vl2) : exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (v2 :: vl2) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (v2 :: vl2) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v2 : val) (vl2 : list val) (H11 : Val.lessdef (Vptr bdst odst) v2) (H13 : Val.lessdef_list (Vptr bsrc osrc :: nil) vl2)","proofString":"inv H13.\ninv H14.\ninv H10.\ninv H11.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nexploit Mem.loadbytes_extends; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_within_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v2 : val) (H11 : Val.lessdef (Vptr bdst odst) v2) (v0 : val) (vl0 : list val) (H10 : Val.lessdef (Vptr bsrc osrc) v0) (H14 : Val.lessdef_list nil vl0) : exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (v2 :: v0 :: vl0) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (v2 :: v0 :: vl0) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v2 : val) (H11 : Val.lessdef (Vptr bdst odst) v2) (v0 : val) (vl0 : list val) (H10 : Val.lessdef (Vptr bsrc osrc) v0) (H14 : Val.lessdef_list nil vl0)","proofString":"inv H14.\ninv H10.\ninv H11.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nexploit Mem.loadbytes_extends; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_within_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v2 : val) (H11 : Val.lessdef (Vptr bdst odst) v2) (v0 : val) (H10 : Val.lessdef (Vptr bsrc osrc) v0) : exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (v2 :: v0 :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (v2 :: v0 :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v2 : val) (H11 : Val.lessdef (Vptr bdst odst) v2) (v0 : val) (H10 : Val.lessdef (Vptr bsrc osrc) v0)","proofString":"inv H10.\ninv H11.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nexploit Mem.loadbytes_extends; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_within_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v2 : val) (H11 : Val.lessdef (Vptr bdst odst) v2) : exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (v2 :: Vptr bsrc osrc :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (v2 :: Vptr bsrc osrc :: nil) m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v2 : val) (H11 : Val.lessdef (Vptr bdst odst) v2)","proofString":"inv H11.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nexploit Mem.loadbytes_extends; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_within_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) : exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2)","proofString":"exploit Mem.loadbytes_length; eauto.\nintros LEN.\nexploit Mem.loadbytes_extends; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_within_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) : Datatypes.length bytes = Z.to_nat sz ->\nexists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"Datatypes.length bytes = Z.to_nat sz ->\nexists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2)","proofString":"intros LEN.\nexploit Mem.loadbytes_extends; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_within_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) : exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz)","proofString":"exploit Mem.loadbytes_extends; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_within_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) : (exists bytes2 : list memval,\n   Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2 /\\\n   list_forall2 memval_lessdef bytes bytes2) ->\nexists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"(exists bytes2 : list memval,\n   Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2 /\\\n   list_forall2 memval_lessdef bytes bytes2) ->\nexists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz)","proofString":"intros [bytes2 [A B]].\nexploit Mem.storebytes_within_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) : exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2)","proofString":"exploit Mem.storebytes_within_extends; eauto.\nintros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) : (exists m2' : mem,\n   Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2' /\\\n   Mem.extends m2 m2') ->\nexists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"(exists m2' : mem,\n   Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2' /\\\n   Mem.extends m2 m2') ->\nexists (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2)","proofString":"intros [m2' [C D]].\nexists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') : exists (vres' : val) (m2'0 : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2'0 /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2'0 /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'0.","conclusion":"exists (vres' : val) (m2'0 : mem),\n  extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1'\n    E0 vres' m2'0 /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2'0 /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'0","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2')","proofString":"exists Vundef; exists m2'.\nsplit.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') : extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1' E0\n  Vundef m2' /\\\nVal.lessdef Vundef Vundef /\\\nMem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1' E0\n  Vundef m2' /\\\nVal.lessdef Vundef Vundef /\\\nMem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2')","proofString":"split.\neconstructor; eauto.\nsplit.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') : extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1' E0\n  Vundef m2'.","conclusion":"extcall_memcpy_sem sz al ge (Vptr bdst odst :: Vptr bsrc osrc :: nil) m1' E0\n  Vundef m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2')","proofString":"econstructor; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') : Val.lessdef Vundef Vundef /\\\nMem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"Val.lessdef Vundef Vundef /\\\nMem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2')","proofString":"split.\nconstructor.\nsplit.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') : Val.lessdef Vundef Vundef.","conclusion":"Val.lessdef Vundef Vundef","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2')","proofString":"constructor."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') : Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2')","proofString":"split.\nauto.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') : Mem.extends m2 m2'.","conclusion":"Mem.extends m2 m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2')","proofString":"auto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') : Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2')","proofString":"eapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') : forall i : Z,\nPtrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2) ->\n~ loc_out_of_bounds m1 bdst i.","conclusion":"forall i : Z,\nPtrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2) ->\n~ loc_out_of_bounds m1 bdst i","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2')","proofString":"unfold loc_out_of_bounds; intros.\nassert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2)) : ~ ~ Mem.perm m1 bdst i Max Nonempty.","conclusion":"~ ~ Mem.perm m1 bdst i Max Nonempty","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2))","proofString":"assert (Mem.perm m1 bdst i Max Nonempty).\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\ntauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2)) : Mem.perm m1 bdst i Max Nonempty.","conclusion":"Mem.perm m1 bdst i Max Nonempty","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2))","proofString":"apply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2)) : Mem.perm m1 bdst i Cur Nonempty.","conclusion":"Mem.perm m1 bdst i Cur Nonempty","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2))","proofString":"apply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2)) : Mem.perm m1 bdst i Cur Writable.","conclusion":"Mem.perm m1 bdst i Cur Writable","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2))","proofString":"eapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2)) : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes).","conclusion":"Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes)","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2))","proofString":"erewrite list_forall2_length; eauto."},{"statement":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2)) (H1 : Mem.perm m1 bdst i Max Nonempty) : ~ ~ Mem.perm m1 bdst i Max Nonempty.","conclusion":"~ ~ Mem.perm m1 bdst i Max Nonempty","hypotheses":"(sz al : Z) (ge : Senv.t) (m1 m2 m1' : mem) (H0 : Mem.extends m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H2 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H3 : sz >= 0) (H4 : (al | sz)) (H5 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H6 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H7 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H8 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H9 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (LEN : Datatypes.length bytes = Z.to_nat sz) (bytes2 : list memval) (A : Mem.loadbytes m1' bsrc (Ptrofs.unsigned osrc) sz = Some bytes2) (B : list_forall2 memval_lessdef bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' bdst (Ptrofs.unsigned odst) bytes2 = Some m2') (D : Mem.extends m2 m2') (i : Z) (H : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2)) (H1 : Mem.perm m1 bdst i Max Nonempty)","proofString":"tauto."},{"statement":"(sz al : Z) : forall (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z))\n  (m1' : mem) (vargs' : list val),\nsymbols_inject f ge1 ge2 ->\nextcall_memcpy_sem sz al ge1 vargs m1 t vres m2 ->\nMem.inject f m1 m1' ->\nVal.inject_list f vargs vargs' ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"forall (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) \n  (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z))\n  (m1' : mem) (vargs' : list val),\nsymbols_inject f ge1 ge2 ->\nextcall_memcpy_sem sz al ge1 vargs m1 t vres m2 ->\nMem.inject f m1 m1' ->\nVal.inject_list f vargs vargs' ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z)","proofString":"intros.\ninv H0.\ninv H2.\ninv H14.\ninv H15.\ninv H11.\ninv H12.\ndestruct (zeq sz 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m1 bsrc (Ptrofs.unsigned osrc) sz).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes m1' b0 (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil)  as [m2' SB].\nsimpl.\nred; intros; extlia.\nexists f, Vundef, m2'.\nsplit.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).\nreplace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : extcall_memcpy_sem sz al ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : extcall_memcpy_sem sz al ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"inv H0.\ninv H2.\ninv H14.\ninv H15.\ninv H11.\ninv H12.\ndestruct (zeq sz 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m1 bsrc (Ptrofs.unsigned osrc) sz).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes m1' b0 (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil)  as [m2' SB].\nsimpl.\nred; intros; extlia.\nexists f, Vundef, m2'.\nsplit.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).\nreplace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H2 : Val.inject_list f (Vptr bdst odst :: Vptr bsrc osrc :: nil) vargs') (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2 vargs' m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2 vargs' m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H2 : Val.inject_list f (Vptr bdst odst :: Vptr bsrc osrc :: nil) vargs') (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2)","proofString":"inv H2.\ninv H14.\ninv H15.\ninv H11.\ninv H12.\ndestruct (zeq sz 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m1 bsrc (Ptrofs.unsigned osrc) sz).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes m1' b0 (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil)  as [m2' SB].\nsimpl.\nred; intros; extlia.\nexists f, Vundef, m2'.\nsplit.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).\nreplace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v' : val) (vl' : list val) (H12 : Val.inject f (Vptr bdst odst) v') (H14 : Val.inject_list f (Vptr bsrc osrc :: nil) vl') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2 (v' :: vl') m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2 (v' :: vl') m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v' : val) (vl' : list val) (H12 : Val.inject f (Vptr bdst odst) v') (H14 : Val.inject_list f (Vptr bsrc osrc :: nil) vl')","proofString":"inv H14.\ninv H15.\ninv H11.\ninv H12.\ndestruct (zeq sz 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m1 bsrc (Ptrofs.unsigned osrc) sz).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes m1' b0 (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil)  as [m2' SB].\nsimpl.\nred; intros; extlia.\nexists f, Vundef, m2'.\nsplit.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).\nreplace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v' : val) (H12 : Val.inject f (Vptr bdst odst) v') (v'0 : val) (vl'0 : list val) (H11 : Val.inject f (Vptr bsrc osrc) v'0) (H15 : Val.inject_list f nil vl'0) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2 (v' :: v'0 :: vl'0) m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2 (v' :: v'0 :: vl'0) m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v' : val) (H12 : Val.inject f (Vptr bdst odst) v') (v'0 : val) (vl'0 : list val) (H11 : Val.inject f (Vptr bsrc osrc) v'0) (H15 : Val.inject_list f nil vl'0)","proofString":"inv H15.\ninv H11.\ninv H12.\ndestruct (zeq sz 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m1 bsrc (Ptrofs.unsigned osrc) sz).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes m1' b0 (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil)  as [m2' SB].\nsimpl.\nred; intros; extlia.\nexists f, Vundef, m2'.\nsplit.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).\nreplace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v' : val) (H12 : Val.inject f (Vptr bdst odst) v') (v'0 : val) (H11 : Val.inject f (Vptr bsrc osrc) v'0) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2 (v' :: v'0 :: nil) m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2 (v' :: v'0 :: nil) m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v' : val) (H12 : Val.inject f (Vptr bdst odst) v') (v'0 : val) (H11 : Val.inject f (Vptr bsrc osrc) v'0)","proofString":"inv H11.\ninv H12.\ndestruct (zeq sz 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m1 bsrc (Ptrofs.unsigned osrc) sz).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes m1' b0 (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil)  as [m2' SB].\nsimpl.\nred; intros; extlia.\nexists f, Vundef, m2'.\nsplit.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).\nreplace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v' : val) (H12 : Val.inject f (Vptr bdst odst) v') (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (v' :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (v' :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (v' : val) (H12 : Val.inject f (Vptr bdst odst) v') (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta))","proofString":"inv H12.\ndestruct (zeq sz 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m1 bsrc (Ptrofs.unsigned osrc) sz).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes m1' b0 (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil)  as [m2' SB].\nsimpl.\nred; intros; extlia.\nexists f, Vundef, m2'.\nsplit.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).\nreplace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0))","proofString":"destruct (zeq sz 0).\nassert (bytes = nil).\nexploit (Mem.loadbytes_empty m1 bsrc (Ptrofs.unsigned osrc) sz).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes m1' b0 (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil)  as [m2' SB].\nsimpl.\nred; intros; extlia.\nexists f, Vundef, m2'.\nsplit.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence.\nexploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).\nreplace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (e : sz = 0) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (e : sz = 0)","proofString":"assert (bytes = nil).\nexploit (Mem.loadbytes_empty m1 bsrc (Ptrofs.unsigned osrc) sz).\nlia.\ncongruence.\nsubst.\ndestruct (Mem.range_perm_storebytes m1' b0 (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil)  as [m2' SB].\nsimpl.\nred; intros; extlia.\nexists f, Vundef, m2'.\nsplit.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (e : sz = 0) : bytes = nil.","conclusion":"bytes = nil","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (e : sz = 0)","proofString":"exploit (Mem.loadbytes_empty m1 bsrc (Ptrofs.unsigned osrc) sz).\nlia.\ncongruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (e : sz = 0) : sz <= 0.","conclusion":"sz <= 0","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (e : sz = 0)","proofString":"lia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (e : sz = 0) : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some nil -> bytes = nil.","conclusion":"Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some nil -> bytes = nil","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (e : sz = 0)","proofString":"congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (e : sz = 0) (H0 : bytes = nil) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (e : sz = 0) (H0 : bytes = nil)","proofString":"subst.\ndestruct (Mem.range_perm_storebytes m1' b0 (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil)  as [m2' SB].\nsimpl.\nred; intros; extlia.\nexists f, Vundef, m2'.\nsplit.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem 0 al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem 0 al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0))","proofString":"destruct (Mem.range_perm_storebytes m1' b0 (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil)  as [m2' SB].\nsimpl.\nred; intros; extlia.\nexists f, Vundef, m2'.\nsplit.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) : Mem.range_perm m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)))\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) + 0) Cur Writable.","conclusion":"Mem.range_perm m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)))\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) + 0) Cur Writable","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0))","proofString":"red; intros; extlia."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : exists (f' : meminj) (vres' : val) (m2'0 : mem),\n  extcall_memcpy_sem 0 al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2'0 /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2'0 /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'0 /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2'0 : mem),\n  extcall_memcpy_sem 0 al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2'0 /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2'0 /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'0 /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"exists f, Vundef, m2'.\nsplit.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : extcall_memcpy_sem 0 al ge2\n  (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n   :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 Vundef m2' /\\\nVal.inject f Vundef Vundef /\\\nMem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"extcall_memcpy_sem 0 al ge2\n  (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n   :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 Vundef m2' /\\\nVal.inject f Vundef Vundef /\\\nMem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"split.\neconstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : extcall_memcpy_sem 0 al ge2\n  (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n   :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 Vundef m2'.","conclusion":"extcall_memcpy_sem 0 al ge2\n  (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n   :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 Vundef m2'","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"econstructor; eauto.\nintros; extlia.\nintros; extlia.\nright; lia.\napply Mem.loadbytes_empty.\nlia."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : 0 > 0 -> (al | Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta))).","conclusion":"0 > 0 -> (al | Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)))","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"intros; extlia."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : 0 > 0 -> (al | Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))).","conclusion":"0 > 0 -> (al | Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)))","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"intros; extlia."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : b2 <> b0 \\/\nPtrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) \\/\nPtrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) + 0 <=\nPtrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) \\/\nPtrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) + 0 <=\nPtrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)).","conclusion":"b2 <> b0 \\/\nPtrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) \\/\nPtrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) + 0 <=\nPtrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) \\/\nPtrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) + 0 <=\nPtrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta))","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"right; lia."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : Mem.loadbytes m1' b2 (Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)))\n  0 = Some nil.","conclusion":"Mem.loadbytes m1' b2 (Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)))\n  0 = Some nil","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"apply Mem.loadbytes_empty.\nlia."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : 0 <= 0.","conclusion":"0 <= 0","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"lia."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : Val.inject f Vundef Vundef /\\\nMem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"Val.inject f Vundef Vundef /\\\nMem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"split.\nauto.\nsplit.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : Val.inject f Vundef Vundef.","conclusion":"Val.inject f Vundef Vundef","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"auto."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : Mem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"Mem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"split.\neapply Mem.storebytes_empty_inject; eauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : Mem.inject f m2 m2'.","conclusion":"Mem.inject f m2 m2'","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"eapply Mem.storebytes_empty_inject; eauto."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"split.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : Mem.unchanged_on (loc_unmapped f) m1 m2.","conclusion":"Mem.unchanged_on (loc_unmapped f) m1 m2","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"eapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"split.\neapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'.","conclusion":"Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"eapply Mem.storebytes_unchanged_on; eauto.\nsimpl; intros; extlia."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : inject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"inject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"split.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : inject_incr f f.","conclusion":"inject_incr f f","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"apply inject_incr_refl."},{"statement":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2') : inject_separated f f m1 m1'.","conclusion":"inject_separated f f m1 m1'","hypotheses":"(al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) 0 = Some nil) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + 0 <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + 0 <= Ptrofs.unsigned osrc) (H7 : 0 > 0 -> (al | Ptrofs.unsigned odst)) (H6 : 0 > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : (al | 0)) (H4 : 0 >= 0) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) nil = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (m2' : mem) (SB : Mem.storebytes m1' b0\n  (Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0))) nil = \nSome m2')","proofString":"red; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0)","proofString":"exploit Mem.loadbytes_length; eauto.\nintros LEN.\nassert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).\nreplace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) : Datatypes.length bytes = Z.to_nat sz ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"Datatypes.length bytes = Z.to_nat sz ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0)","proofString":"intros LEN.\nassert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).\nreplace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz)","proofString":"assert (RPSRC: Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur Nonempty).\neapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem.\nassert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).\nreplace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty.","conclusion":"Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz)","proofString":"eapply Mem.range_perm_implies.\neapply Mem.loadbytes_range_perm; eauto.\nauto with mem."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty)","proofString":"assert (RPDST: Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur Nonempty).\nreplace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia.\nassert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty.","conclusion":"Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty)","proofString":"replace sz with (Z.of_nat (length bytes)).\neapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem.\nrewrite LEN.\napply Z2Nat.id.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) : Mem.range_perm m1 bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + Z.of_nat (Datatypes.length bytes)) Cur Nonempty.","conclusion":"Mem.range_perm m1 bdst (Ptrofs.unsigned odst)\n  (Ptrofs.unsigned odst + Z.of_nat (Datatypes.length bytes)) Cur Nonempty","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty)","proofString":"eapply Mem.range_perm_implies.\neapply Mem.storebytes_range_perm; eauto.\nauto with mem."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) : Z.of_nat (Datatypes.length bytes) = sz.","conclusion":"Z.of_nat (Datatypes.length bytes) = sz","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty)","proofString":"rewrite LEN.\napply Z2Nat.id.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) : Z.of_nat (Z.to_nat sz) = sz.","conclusion":"Z.of_nat (Z.to_nat sz) = sz","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty)","proofString":"apply Z2Nat.id.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) : 0 <= sz.","conclusion":"0 <= sz","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty)","proofString":"lia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty)","proofString":"assert (PSRC: Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty).\napply RPSRC.\nlia.\nassert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty.","conclusion":"Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty)","proofString":"apply RPSRC.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) : Ptrofs.unsigned osrc <= Ptrofs.unsigned osrc < Ptrofs.unsigned osrc + sz.","conclusion":"Ptrofs.unsigned osrc <= Ptrofs.unsigned osrc < Ptrofs.unsigned osrc + sz","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty)","proofString":"lia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty)","proofString":"assert (PDST: Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty).\napply RPDST.\nlia.\nexploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty.","conclusion":"Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty)","proofString":"apply RPDST.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) : Ptrofs.unsigned odst <= Ptrofs.unsigned odst < Ptrofs.unsigned odst + sz.","conclusion":"Ptrofs.unsigned odst <= Ptrofs.unsigned odst < Ptrofs.unsigned odst + sz","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty)","proofString":"lia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty)","proofString":"exploit Mem.address_inject.\neauto.\neexact PSRC.\neauto.\nintros EQ1.\nexploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta)","proofString":"exploit Mem.address_inject.\neauto.\neexact PDST.\neauto.\nintros EQ2.\nexploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0)","proofString":"exploit Mem.loadbytes_inject; eauto.\nintros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) : (exists bytes2 : list memval,\n   Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2 /\\\n   list_forall2 (memval_inject f) bytes bytes2) ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"(exists bytes2 : list memval,\n   Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2 /\\\n   list_forall2 (memval_inject f) bytes bytes2) ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0)","proofString":"intros [bytes2 [A B]].\nexploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2)","proofString":"exploit Mem.storebytes_mapped_inject; eauto.\nintros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) : (exists n2 : mem,\n   Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some n2 /\\\n   Mem.inject f m2 n2) ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"(exists n2 : mem,\n   Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some n2 /\\\n   Mem.inject f m2 n2) ->\nexists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2)","proofString":"intros [m2' [C D]].\nexists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : exists (f' : meminj) (vres' : val) (m2'0 : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2'0 /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2'0 /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'0 /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2'0 : mem),\n  extcall_memcpy_sem sz al ge2\n    (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n     :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 vres'\n    m2'0 /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2'0 /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'0 /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"exists f; exists Vundef; exists m2'.\nsplit.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : extcall_memcpy_sem sz al ge2\n  (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n   :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 Vundef m2' /\\\nVal.inject f Vundef Vundef /\\\nMem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"extcall_memcpy_sem sz al ge2\n  (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n   :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 Vundef m2' /\\\nVal.inject f Vundef Vundef /\\\nMem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"split.\neconstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia.\nsplit.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : extcall_memcpy_sem sz al ge2\n  (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n   :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 Vundef m2'.","conclusion":"extcall_memcpy_sem sz al ge2\n  (Vptr b0 (Ptrofs.add odst (Ptrofs.repr delta0))\n   :: Vptr b2 (Ptrofs.add osrc (Ptrofs.repr delta)) :: nil) m1' E0 Vundef m2'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"econstructor; try rewrite EQ1; try rewrite EQ2; eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\nintros; eapply Mem.aligned_area_inject with (m := m1); eauto.\neapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : sz > 0 -> (al | Ptrofs.unsigned osrc + delta).","conclusion":"sz > 0 -> (al | Ptrofs.unsigned osrc + delta)","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"intros; eapply Mem.aligned_area_inject with (m := m1); eauto."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : sz > 0 -> (al | Ptrofs.unsigned odst + delta0).","conclusion":"sz > 0 -> (al | Ptrofs.unsigned odst + delta0)","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"intros; eapply Mem.aligned_area_inject with (m := m1); eauto."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : b2 <> b0 \\/\nPtrofs.unsigned osrc + delta = Ptrofs.unsigned odst + delta0 \\/\nPtrofs.unsigned osrc + delta + sz <= Ptrofs.unsigned odst + delta0 \\/\nPtrofs.unsigned odst + delta0 + sz <= Ptrofs.unsigned osrc + delta.","conclusion":"b2 <> b0 \\/\nPtrofs.unsigned osrc + delta = Ptrofs.unsigned odst + delta0 \\/\nPtrofs.unsigned osrc + delta + sz <= Ptrofs.unsigned odst + delta0 \\/\nPtrofs.unsigned odst + delta0 + sz <= Ptrofs.unsigned osrc + delta","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"eapply Mem.disjoint_or_equal_inject with (m := m1); eauto.\napply Mem.range_perm_max with Cur; auto.\napply Mem.range_perm_max with Cur; auto.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Max\n  Nonempty.","conclusion":"Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Max\n  Nonempty","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"apply Mem.range_perm_max with Cur; auto."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Max\n  Nonempty.","conclusion":"Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Max\n  Nonempty","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"apply Mem.range_perm_max with Cur; auto."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : sz > 0.","conclusion":"sz > 0","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"lia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : Val.inject f Vundef Vundef /\\\nMem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"Val.inject f Vundef Vundef /\\\nMem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"split.\nconstructor.\nsplit.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : Val.inject f Vundef Vundef.","conclusion":"Val.inject f Vundef Vundef","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"constructor."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : Mem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"Mem.inject f m2 m2' /\\\nMem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"split.\nauto.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : Mem.inject f m2 m2'.","conclusion":"Mem.inject f m2 m2'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"auto."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\nMem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"split.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence.\nsplit.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : Mem.unchanged_on (loc_unmapped f) m1 m2.","conclusion":"Mem.unchanged_on (loc_unmapped f) m1 m2","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"eapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_unmapped; intros.\ncongruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : forall i : Z,\nPtrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes) ->\n~ loc_unmapped f bdst i.","conclusion":"forall i : Z,\nPtrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes) ->\n~ loc_unmapped f bdst i","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"unfold loc_unmapped; intros.\ncongruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes)) : f bdst <> None.","conclusion":"f bdst <> None","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst <= i <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes))","proofString":"congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\ninject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"split.\neapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia.\nsplit.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'.","conclusion":"Mem.unchanged_on (loc_out_of_reach f m1) m1' m2'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"eapply Mem.storebytes_unchanged_on; eauto.\nunfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : forall i : Z,\nPtrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2) ->\n~ loc_out_of_reach f m1 b0 i.","conclusion":"forall i : Z,\nPtrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2) ->\n~ loc_out_of_reach f m1 b0 i","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"unfold loc_out_of_reach; intros.\nred; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2)) : ~\n(forall (b1 : block) (delta1 : Z),\n f b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty).","conclusion":"~\n(forall (b1 : block) (delta1 : Z),\n f b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty)","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2))","proofString":"red; intros.\neelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2)) (H2 : forall (b1 : block) (delta1 : Z),\nf b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty) : False.","conclusion":"False","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2)) (H2 : forall (b1 : block) (delta1 : Z),\nf b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty)","proofString":"eelim H2; eauto.\napply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2)) (H2 : forall (b1 : block) (delta1 : Z),\nf b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty) : Mem.perm m1 bdst (i - delta0) Max Nonempty.","conclusion":"Mem.perm m1 bdst (i - delta0) Max Nonempty","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2)) (H2 : forall (b1 : block) (delta1 : Z),\nf b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty)","proofString":"apply Mem.perm_cur_max.\napply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2)) (H2 : forall (b1 : block) (delta1 : Z),\nf b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty) : Mem.perm m1 bdst (i - delta0) Cur Nonempty.","conclusion":"Mem.perm m1 bdst (i - delta0) Cur Nonempty","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2)) (H2 : forall (b1 : block) (delta1 : Z),\nf b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty)","proofString":"apply Mem.perm_implies with Writable; auto with mem.\neapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2)) (H2 : forall (b1 : block) (delta1 : Z),\nf b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty) : Mem.perm m1 bdst (i - delta0) Cur Writable.","conclusion":"Mem.perm m1 bdst (i - delta0) Cur Writable","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2)) (H2 : forall (b1 : block) (delta1 : Z),\nf b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty)","proofString":"eapply Mem.storebytes_range_perm; eauto.\nerewrite list_forall2_length; eauto.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2)) (H2 : forall (b1 : block) (delta1 : Z),\nf b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty) : Ptrofs.unsigned odst <= i - delta0 <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes).","conclusion":"Ptrofs.unsigned odst <= i - delta0 <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes)","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2)) (H2 : forall (b1 : block) (delta1 : Z),\nf b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty)","proofString":"erewrite list_forall2_length; eauto.\nlia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2)) (H2 : forall (b1 : block) (delta1 : Z),\nf b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty) : Ptrofs.unsigned odst <= i - delta0 <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2).","conclusion":"Ptrofs.unsigned odst <= i - delta0 <\nPtrofs.unsigned odst + Z.of_nat (Datatypes.length bytes2)","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') (i : Z) (H0 : Ptrofs.unsigned odst + delta0 <= i <\nPtrofs.unsigned odst + delta0 + Z.of_nat (Datatypes.length bytes2)) (H2 : forall (b1 : block) (delta1 : Z),\nf b1 = Some (b0, delta1) -> ~ Mem.perm m1 b1 (i - delta1) Max Nonempty)","proofString":"lia."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : inject_incr f f /\\ inject_separated f f m1 m1'.","conclusion":"inject_incr f f /\\ inject_separated f f m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"split.\napply inject_incr_refl.\nred; intros; congruence."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : inject_incr f f.","conclusion":"inject_incr f f","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"apply inject_incr_refl."},{"statement":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2') : inject_separated f f m1 m1'.","conclusion":"inject_separated f f m1 m1'","hypotheses":"(sz al : Z) (ge1 ge2 : Senv.t) (m1 m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m1 m1') (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H3 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H4 : sz >= 0) (H5 : (al | sz)) (H6 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H7 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H8 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H9 : Mem.loadbytes m1 bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H10 : Mem.storebytes m1 bdst (Ptrofs.unsigned odst) bytes = Some m2) (b2 : block) (delta : Z) (H13 : f bsrc = Some (b2, delta)) (b0 : block) (delta0 : Z) (H11 : f bdst = Some (b0, delta0)) (n : sz <> 0) (LEN : Datatypes.length bytes = Z.to_nat sz) (RPSRC : Mem.range_perm m1 bsrc (Ptrofs.unsigned osrc) (Ptrofs.unsigned osrc + sz) Cur\n  Nonempty) (RPDST : Mem.range_perm m1 bdst (Ptrofs.unsigned odst) (Ptrofs.unsigned odst + sz) Cur\n  Nonempty) (PSRC : Mem.perm m1 bsrc (Ptrofs.unsigned osrc) Cur Nonempty) (PDST : Mem.perm m1 bdst (Ptrofs.unsigned odst) Cur Nonempty) (EQ1 : Ptrofs.unsigned (Ptrofs.add osrc (Ptrofs.repr delta)) =\nPtrofs.unsigned osrc + delta) (EQ2 : Ptrofs.unsigned (Ptrofs.add odst (Ptrofs.repr delta0)) =\nPtrofs.unsigned odst + delta0) (bytes2 : list memval) (A : Mem.loadbytes m1' b2 (Ptrofs.unsigned osrc + delta) sz = Some bytes2) (B : list_forall2 (memval_inject f) bytes bytes2) (m2' : mem) (C : Mem.storebytes m1' b0 (Ptrofs.unsigned odst + delta0) bytes2 = Some m2') (D : Mem.inject f m2 m2')","proofString":"red; intros; congruence."},{"statement":"(sz al : Z) : forall (ge : Senv.t) (vargs : list val) (m : mem) \n  (t : trace) (vres : val) (m' : mem),\nextcall_memcpy_sem sz al ge vargs m t vres m' ->\n(Datatypes.length t <= 1)%nat.","conclusion":"forall (ge : Senv.t) (vargs : list val) (m : mem) \n  (t : trace) (vres : val) (m' : mem),\nextcall_memcpy_sem sz al ge vargs m t vres m' ->\n(Datatypes.length t <= 1)%nat","hypotheses":"(sz al : Z)","proofString":"intros; inv H.\nsimpl; lia."},{"statement":"(sz al : Z) (ge : Senv.t) (m m' : mem) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz >= 0) (H2 : (al | sz)) (H3 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H4 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H5 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H6 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H7 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m') : (Datatypes.length E0 <= 1)%nat.","conclusion":"(Datatypes.length E0 <= 1)%nat","hypotheses":"(sz al : Z) (ge : Senv.t) (m m' : mem) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H0 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H1 : sz >= 0) (H2 : (al | sz)) (H3 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H4 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H5 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H6 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H7 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m')","proofString":"simpl; lia."},{"statement":"(sz al : Z) : forall (ge : Senv.t) (vargs : list val) (m : mem) \n  (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace),\nextcall_memcpy_sem sz al ge vargs m t1 vres1 m1 ->\nmatch_traces ge t1 t2 ->\nexists (vres2 : val) (m2 : mem),\n  extcall_memcpy_sem sz al ge vargs m t2 vres2 m2.","conclusion":"forall (ge : Senv.t) (vargs : list val) (m : mem) \n  (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace),\nextcall_memcpy_sem sz al ge vargs m t1 vres1 m1 ->\nmatch_traces ge t1 t2 ->\nexists (vres2 : val) (m2 : mem),\n  extcall_memcpy_sem sz al ge vargs m t2 vres2 m2","hypotheses":"(sz al : Z)","proofString":"intros.\nassert (t1 = t2).\ninv H; inv H0; auto.\nsubst t2.\nexists vres1; exists m1; auto."},{"statement":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_memcpy_sem sz al ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : exists (vres2 : val) (m2 : mem),\n  extcall_memcpy_sem sz al ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  extcall_memcpy_sem sz al ge vargs m t2 vres2 m2","hypotheses":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_memcpy_sem sz al ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"assert (t1 = t2).\ninv H; inv H0; auto.\nsubst t2.\nexists vres1; exists m1; auto."},{"statement":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_memcpy_sem sz al ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : t1 = t2.","conclusion":"t1 = t2","hypotheses":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_memcpy_sem sz al ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"inv H; inv H0; auto."},{"statement":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_memcpy_sem sz al ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) (H1 : t1 = t2) : exists (vres2 : val) (m2 : mem),\n  extcall_memcpy_sem sz al ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  extcall_memcpy_sem sz al ge vargs m t2 vres2 m2","hypotheses":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_memcpy_sem sz al ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) (H1 : t1 = t2)","proofString":"subst t2.\nexists vres1; exists m1; auto."},{"statement":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (H : extcall_memcpy_sem sz al ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t1) : exists (vres2 : val) (m2 : mem),\n  extcall_memcpy_sem sz al ge vargs m t1 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  extcall_memcpy_sem sz al ge vargs m t1 vres2 m2","hypotheses":"(sz al : Z) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (H : extcall_memcpy_sem sz al ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t1)","proofString":"exists vres1; exists m1; auto."},{"statement":"(sz al : Z) : forall (ge : Senv.t) (vargs : list val) (m : mem) \n  (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) \n  (vres2 : val) (m2 : mem),\nextcall_memcpy_sem sz al ge vargs m t1 vres1 m1 ->\nextcall_memcpy_sem sz al ge vargs m t2 vres2 m2 ->\nmatch_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2).","conclusion":"forall (ge : Senv.t) (vargs : list val) (m : mem) \n  (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) \n  (vres2 : val) (m2 : mem),\nextcall_memcpy_sem sz al ge vargs m t1 vres1 m1 ->\nextcall_memcpy_sem sz al ge vargs m t2 vres2 m2 ->\nmatch_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2)","hypotheses":"(sz al : Z)","proofString":"intros; inv H; inv H0.\nsplit.\nconstructor.\nintros; split; congruence."},{"statement":"(sz al : Z) (ge : Senv.t) (m m1 m2 : mem) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m1) (bytes0 : list memval) (H12 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H13 : sz >= 0) (H14 : (al | sz)) (H15 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H16 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H21 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H22 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H23 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes0 = Some m2) : match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m1 = m2).","conclusion":"match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m1 = m2)","hypotheses":"(sz al : Z) (ge : Senv.t) (m m1 m2 : mem) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m1) (bytes0 : list memval) (H12 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H13 : sz >= 0) (H14 : (al | sz)) (H15 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H16 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H21 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H22 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H23 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes0 = Some m2)","proofString":"split.\nconstructor.\nintros; split; congruence."},{"statement":"(sz al : Z) (ge : Senv.t) (m m1 m2 : mem) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m1) (bytes0 : list memval) (H12 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H13 : sz >= 0) (H14 : (al | sz)) (H15 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H16 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H21 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H22 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H23 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes0 = Some m2) : match_traces ge E0 E0.","conclusion":"match_traces ge E0 E0","hypotheses":"(sz al : Z) (ge : Senv.t) (m m1 m2 : mem) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m1) (bytes0 : list memval) (H12 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H13 : sz >= 0) (H14 : (al | sz)) (H15 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H16 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H21 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H22 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H23 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes0 = Some m2)","proofString":"constructor."},{"statement":"(sz al : Z) (ge : Senv.t) (m m1 m2 : mem) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m1) (bytes0 : list memval) (H12 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H13 : sz >= 0) (H14 : (al | sz)) (H15 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H16 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H21 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H22 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H23 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes0 = Some m2) : E0 = E0 -> Vundef = Vundef /\\ m1 = m2.","conclusion":"E0 = E0 -> Vundef = Vundef /\\ m1 = m2","hypotheses":"(sz al : Z) (ge : Senv.t) (m m1 m2 : mem) (bdst : block) (odst : ptrofs) (bsrc : block) (osrc : ptrofs) (bytes : list memval) (H1 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H2 : sz >= 0) (H3 : (al | sz)) (H4 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H5 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H6 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H7 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes) (H8 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes = Some m1) (bytes0 : list memval) (H12 : al = 1 \\/ al = 2 \\/ al = 4 \\/ al = 8) (H13 : sz >= 0) (H14 : (al | sz)) (H15 : sz > 0 -> (al | Ptrofs.unsigned osrc)) (H16 : sz > 0 -> (al | Ptrofs.unsigned odst)) (H21 : bsrc <> bdst \\/\nPtrofs.unsigned osrc = Ptrofs.unsigned odst \\/\nPtrofs.unsigned osrc + sz <= Ptrofs.unsigned odst \\/\nPtrofs.unsigned odst + sz <= Ptrofs.unsigned osrc) (H22 : Mem.loadbytes m bsrc (Ptrofs.unsigned osrc) sz = Some bytes0) (H23 : Mem.storebytes m bdst (Ptrofs.unsigned odst) bytes0 = Some m2)","proofString":"intros; split; congruence."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : extcall_annot_sem text targs ge vargs m1 t vres m2) : Val.has_rettype vres\n  (sig_res\n     {|\n       sig_args := map inj_type targs; sig_res := Xvoid; sig_cc := cc_default\n     |}).","conclusion":"Val.has_rettype vres\n  (sig_res\n     {|\n       sig_args := map inj_type targs; sig_res := Xvoid; sig_cc := cc_default\n     |})","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : extcall_annot_sem text targs ge vargs m1 t vres m2)","proofString":"inv H.\nsimpl.\nauto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H0 : eventval_list_match ge args targs vargs) : Val.has_rettype Vundef\n  (sig_res\n     {|\n       sig_args := map inj_type targs; sig_res := Xvoid; sig_cc := cc_default\n     |}).","conclusion":"Val.has_rettype Vundef\n  (sig_res\n     {|\n       sig_args := map inj_type targs; sig_res := Xvoid; sig_cc := cc_default\n     |})","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H0 : eventval_list_match ge args targs vargs)","proofString":"simpl.\nauto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H0 : eventval_list_match ge args targs vargs) : True.","conclusion":"True","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H0 : eventval_list_match ge args targs vargs)","proofString":"auto."},{"statement":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : extcall_annot_sem text targs ge1 vargs m1 t vres m2) : extcall_annot_sem text targs ge2 vargs m1 t vres m2.","conclusion":"extcall_annot_sem text targs ge2 vargs m1 t vres m2","hypotheses":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : extcall_annot_sem text targs ge1 vargs m1 t vres m2)","proofString":"destruct H as (A & B & C).\ninv H0.\neconstructor; eauto.\neapply eventval_list_match_preserved; eauto."},{"statement":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b : block, Senv.block_is_volatile ge2 b = Senv.block_is_volatile ge1 b) (H0 : extcall_annot_sem text targs ge1 vargs m1 t vres m2) : extcall_annot_sem text targs ge2 vargs m1 t vres m2.","conclusion":"extcall_annot_sem text targs ge2 vargs m1 t vres m2","hypotheses":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b : block, Senv.block_is_volatile ge2 b = Senv.block_is_volatile ge1 b) (H0 : extcall_annot_sem text targs ge1 vargs m1 t vres m2)","proofString":"inv H0.\neconstructor; eauto.\neapply eventval_list_match_preserved; eauto."},{"statement":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b : block, Senv.block_is_volatile ge2 b = Senv.block_is_volatile ge1 b) (args : list eventval) (H : eventval_list_match ge1 args targs vargs) : extcall_annot_sem text targs ge2 vargs m2 (Event_annot text args :: E0)\n  Vundef m2.","conclusion":"extcall_annot_sem text targs ge2 vargs m2 (Event_annot text args :: E0)\n  Vundef m2","hypotheses":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b : block, Senv.block_is_volatile ge2 b = Senv.block_is_volatile ge1 b) (args : list eventval) (H : eventval_list_match ge1 args targs vargs)","proofString":"econstructor; eauto.\neapply eventval_list_match_preserved; eauto."},{"statement":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b : block, Senv.block_is_volatile ge2 b = Senv.block_is_volatile ge1 b) (args : list eventval) (H : eventval_list_match ge1 args targs vargs) : eventval_list_match ge2 args targs vargs.","conclusion":"eventval_list_match ge2 args targs vargs","hypotheses":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b : block, Senv.block_is_volatile ge2 b = Senv.block_is_volatile ge1 b) (args : list eventval) (H : eventval_list_match ge1 args targs vargs)","proofString":"eapply eventval_list_match_preserved; eauto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : extcall_annot_sem text targs ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : extcall_annot_sem text targs ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b)","proofString":"inv H; auto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : extcall_annot_sem text targs ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) : Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : extcall_annot_sem text targs ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p)","proofString":"inv H; auto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_annot_sem text targs ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) : Mem.loadbytes m1 b ofs n = Some bytes.","conclusion":"Mem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_annot_sem text targs ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable)","proofString":"inv H; auto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : extcall_annot_sem text targs ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs') : exists (vres' : val) (m2' : mem),\n  extcall_annot_sem text targs ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_annot_sem text targs ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : extcall_annot_sem text targs ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs')","proofString":"inv H.\nexists Vundef; exists m1'; intuition auto with mem.\neconstructor; eauto.\neapply eventval_list_match_lessdef; eauto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list vargs vargs') (args : list eventval) (H2 : eventval_list_match ge args targs vargs) : exists (vres' : val) (m2' : mem),\n  extcall_annot_sem text targs ge vargs' m1' (Event_annot text args :: E0)\n    vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_annot_sem text targs ge vargs' m1' (Event_annot text args :: E0)\n    vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list vargs vargs') (args : list eventval) (H2 : eventval_list_match ge args targs vargs)","proofString":"exists Vundef; exists m1'; intuition auto with mem.\neconstructor; eauto.\neapply eventval_list_match_lessdef; eauto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list vargs vargs') (args : list eventval) (H2 : eventval_list_match ge args targs vargs) : extcall_annot_sem text targs ge vargs' m1' (Event_annot text args :: E0)\n  Vundef m1'.","conclusion":"extcall_annot_sem text targs ge vargs' m1' (Event_annot text args :: E0)\n  Vundef m1'","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list vargs vargs') (args : list eventval) (H2 : eventval_list_match ge args targs vargs)","proofString":"econstructor; eauto.\neapply eventval_list_match_lessdef; eauto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list vargs vargs') (args : list eventval) (H2 : eventval_list_match ge args targs vargs) : eventval_list_match ge args targs vargs'.","conclusion":"eventval_list_match ge args targs vargs'","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list vargs vargs') (args : list eventval) (H2 : eventval_list_match ge args targs vargs)","proofString":"eapply eventval_list_match_lessdef; eauto."},{"statement":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : extcall_annot_sem text targs ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_annot_sem text targs ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_annot_sem text targs ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : extcall_annot_sem text targs ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"inv H0.\nexists f; exists Vundef; exists m1'; intuition auto with mem.\neconstructor; eauto.\neapply eventval_list_match_inject; eauto.\nred; intros; congruence."},{"statement":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs') (args : list eventval) (H3 : eventval_list_match ge1 args targs vargs) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_annot_sem text targs ge2 vargs' m1' (Event_annot text args :: E0)\n    vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_annot_sem text targs ge2 vargs' m1' (Event_annot text args :: E0)\n    vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs') (args : list eventval) (H3 : eventval_list_match ge1 args targs vargs)","proofString":"exists f; exists Vundef; exists m1'; intuition auto with mem.\neconstructor; eauto.\neapply eventval_list_match_inject; eauto.\nred; intros; congruence."},{"statement":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs') (args : list eventval) (H3 : eventval_list_match ge1 args targs vargs) : extcall_annot_sem text targs ge2 vargs' m1' (Event_annot text args :: E0)\n  Vundef m1'.","conclusion":"extcall_annot_sem text targs ge2 vargs' m1' (Event_annot text args :: E0)\n  Vundef m1'","hypotheses":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs') (args : list eventval) (H3 : eventval_list_match ge1 args targs vargs)","proofString":"econstructor; eauto.\neapply eventval_list_match_inject; eauto."},{"statement":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs') (args : list eventval) (H3 : eventval_list_match ge1 args targs vargs) : eventval_list_match ge2 args targs vargs'.","conclusion":"eventval_list_match ge2 args targs vargs'","hypotheses":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs') (args : list eventval) (H3 : eventval_list_match ge1 args targs vargs)","proofString":"eapply eventval_list_match_inject; eauto."},{"statement":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs') (args : list eventval) (H3 : eventval_list_match ge1 args targs vargs) : inject_separated f f m2 m1'.","conclusion":"inject_separated f f m2 m1'","hypotheses":"(text : string) (targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs') (args : list eventval) (H3 : eventval_list_match ge1 args targs vargs)","proofString":"red; intros; congruence."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : extcall_annot_sem text targs ge vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : extcall_annot_sem text targs ge vargs m t vres m')","proofString":"inv H; simpl; lia."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_annot_sem text targs ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : exists (vres2 : val) (m2 : mem),\n  extcall_annot_sem text targs ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  extcall_annot_sem text targs ge vargs m t2 vres2 m2","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_annot_sem text targs ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"assert (t1 = t2).\ninv H; inv H0; auto.\nexists vres1; exists m1; congruence."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_annot_sem text targs ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : t1 = t2.","conclusion":"t1 = t2","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_annot_sem text targs ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"inv H; inv H0; auto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_annot_sem text targs ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) (H1 : t1 = t2) : exists (vres2 : val) (m2 : mem),\n  extcall_annot_sem text targs ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  extcall_annot_sem text targs ge vargs m t2 vres2 m2","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_annot_sem text targs ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) (H1 : t1 = t2)","proofString":"exists vres1; exists m1; congruence."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : extcall_annot_sem text targs ge vargs m t1 vres1 m1) (H0 : extcall_annot_sem text targs ge vargs m t2 vres2 m2) : match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2).","conclusion":"match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2)","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : extcall_annot_sem text targs ge vargs m t1 vres1 m1) (H0 : extcall_annot_sem text targs ge vargs m t2 vres2 m2)","proofString":"inv H; inv H0.\nassert (args = args0).\neapply eventval_list_match_determ_2; eauto.\nsubst args0.\nsplit.\nconstructor.\nauto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H1 : eventval_list_match ge args targs vargs) (args0 : list eventval) (H : eventval_list_match ge args0 targs vargs) : match_traces ge (Event_annot text args :: E0) (Event_annot text args0 :: E0) /\\\n(Event_annot text args :: E0 = Event_annot text args0 :: E0 ->\n Vundef = Vundef /\\ m2 = m2).","conclusion":"match_traces ge (Event_annot text args :: E0) (Event_annot text args0 :: E0) /\\\n(Event_annot text args :: E0 = Event_annot text args0 :: E0 ->\n Vundef = Vundef /\\ m2 = m2)","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H1 : eventval_list_match ge args targs vargs) (args0 : list eventval) (H : eventval_list_match ge args0 targs vargs)","proofString":"assert (args = args0).\neapply eventval_list_match_determ_2; eauto.\nsubst args0.\nsplit.\nconstructor.\nauto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H1 : eventval_list_match ge args targs vargs) (args0 : list eventval) (H : eventval_list_match ge args0 targs vargs) : args = args0.","conclusion":"args = args0","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H1 : eventval_list_match ge args targs vargs) (args0 : list eventval) (H : eventval_list_match ge args0 targs vargs)","proofString":"eapply eventval_list_match_determ_2; eauto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H1 : eventval_list_match ge args targs vargs) (args0 : list eventval) (H : eventval_list_match ge args0 targs vargs) (H0 : args = args0) : match_traces ge (Event_annot text args :: E0) (Event_annot text args0 :: E0) /\\\n(Event_annot text args :: E0 = Event_annot text args0 :: E0 ->\n Vundef = Vundef /\\ m2 = m2).","conclusion":"match_traces ge (Event_annot text args :: E0) (Event_annot text args0 :: E0) /\\\n(Event_annot text args :: E0 = Event_annot text args0 :: E0 ->\n Vundef = Vundef /\\ m2 = m2)","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H1 : eventval_list_match ge args targs vargs) (args0 : list eventval) (H : eventval_list_match ge args0 targs vargs) (H0 : args = args0)","proofString":"subst args0.\nsplit.\nconstructor.\nauto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H1 H : eventval_list_match ge args targs vargs) : match_traces ge (Event_annot text args :: E0) (Event_annot text args :: E0) /\\\n(Event_annot text args :: E0 = Event_annot text args :: E0 ->\n Vundef = Vundef /\\ m2 = m2).","conclusion":"match_traces ge (Event_annot text args :: E0) (Event_annot text args :: E0) /\\\n(Event_annot text args :: E0 = Event_annot text args :: E0 ->\n Vundef = Vundef /\\ m2 = m2)","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H1 H : eventval_list_match ge args targs vargs)","proofString":"split.\nconstructor.\nauto."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H1 H : eventval_list_match ge args targs vargs) : match_traces ge (Event_annot text args :: E0) (Event_annot text args :: E0).","conclusion":"match_traces ge (Event_annot text args :: E0) (Event_annot text args :: E0)","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H1 H : eventval_list_match ge args targs vargs)","proofString":"constructor."},{"statement":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H1 H : eventval_list_match ge args targs vargs) : Event_annot text args :: E0 = Event_annot text args :: E0 ->\nVundef = Vundef /\\ m2 = m2.","conclusion":"Event_annot text args :: E0 = Event_annot text args :: E0 ->\nVundef = Vundef /\\ m2 = m2","hypotheses":"(text : string) (targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) (args : list eventval) (H1 H : eventval_list_match ge args targs vargs)","proofString":"auto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : extcall_annot_val_sem text targ ge vargs m1 t vres m2) : Val.has_rettype vres (sig_res [inj_type targ ---> inj_type targ]).","conclusion":"Val.has_rettype vres (sig_res [inj_type targ ---> inj_type targ])","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : extcall_annot_val_sem text targ ge vargs m1 t vres m2)","proofString":"inv H.\napply Val.has_inj_type.\neapply eventval_match_type; eauto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 : mem) (arg : eventval) (H0 : eventval_match ge arg targ vres) : Val.has_rettype vres (sig_res [inj_type targ ---> inj_type targ]).","conclusion":"Val.has_rettype vres (sig_res [inj_type targ ---> inj_type targ])","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 : mem) (arg : eventval) (H0 : eventval_match ge arg targ vres)","proofString":"apply Val.has_inj_type.\neapply eventval_match_type; eauto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 : mem) (arg : eventval) (H0 : eventval_match ge arg targ vres) : Val.has_type vres targ.","conclusion":"Val.has_type vres targ","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 : mem) (arg : eventval) (H0 : eventval_match ge arg targ vres)","proofString":"eapply eventval_match_type; eauto."},{"statement":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : extcall_annot_val_sem text targ ge1 vargs m1 t vres m2) : extcall_annot_val_sem text targ ge2 vargs m1 t vres m2.","conclusion":"extcall_annot_val_sem text targ ge2 vargs m1 t vres m2","hypotheses":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : extcall_annot_val_sem text targ ge1 vargs m1 t vres m2)","proofString":"destruct H as (A & B & C).\ninv H0.\neconstructor; eauto.\neapply eventval_match_preserved; eauto."},{"statement":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b : block, Senv.block_is_volatile ge2 b = Senv.block_is_volatile ge1 b) (H0 : extcall_annot_val_sem text targ ge1 vargs m1 t vres m2) : extcall_annot_val_sem text targ ge2 vargs m1 t vres m2.","conclusion":"extcall_annot_val_sem text targ ge2 vargs m1 t vres m2","hypotheses":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b : block, Senv.block_is_volatile ge2 b = Senv.block_is_volatile ge1 b) (H0 : extcall_annot_val_sem text targ ge1 vargs m1 t vres m2)","proofString":"inv H0.\neconstructor; eauto.\neapply eventval_match_preserved; eauto."},{"statement":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b : block, Senv.block_is_volatile ge2 b = Senv.block_is_volatile ge1 b) (arg : eventval) (H : eventval_match ge1 arg targ vres) : extcall_annot_val_sem text targ ge2 (vres :: nil) m2\n  (Event_annot text (arg :: nil) :: E0) vres m2.","conclusion":"extcall_annot_val_sem text targ ge2 (vres :: nil) m2\n  (Event_annot text (arg :: nil) :: E0) vres m2","hypotheses":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b : block, Senv.block_is_volatile ge2 b = Senv.block_is_volatile ge1 b) (arg : eventval) (H : eventval_match ge1 arg targ vres)","proofString":"econstructor; eauto.\neapply eventval_match_preserved; eauto."},{"statement":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b : block, Senv.block_is_volatile ge2 b = Senv.block_is_volatile ge1 b) (arg : eventval) (H : eventval_match ge1 arg targ vres) : eventval_match ge2 arg targ vres.","conclusion":"eventval_match ge2 arg targ vres","hypotheses":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (A : forall id : ident, Senv.find_symbol ge2 id = Senv.find_symbol ge1 id) (B : forall id : ident, Senv.public_symbol ge2 id = Senv.public_symbol ge1 id) (C : forall b : block, Senv.block_is_volatile ge2 b = Senv.block_is_volatile ge1 b) (arg : eventval) (H : eventval_match ge1 arg targ vres)","proofString":"eapply eventval_match_preserved; eauto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : extcall_annot_val_sem text targ ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : extcall_annot_val_sem text targ ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b)","proofString":"inv H; auto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : extcall_annot_val_sem text targ ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) : Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : extcall_annot_val_sem text targ ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p)","proofString":"inv H; auto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_annot_val_sem text targ ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) : Mem.loadbytes m1 b ofs n = Some bytes.","conclusion":"Mem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_annot_val_sem text targ ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable)","proofString":"inv H; auto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : extcall_annot_val_sem text targ ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs') : exists (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : extcall_annot_val_sem text targ ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs')","proofString":"inv H.\ninv H1.\ninv H6.\nexists v2; exists m1'; intuition auto with mem.\neconstructor; eauto.\neapply eventval_match_lessdef; eauto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list (vres :: nil) vargs') (arg : eventval) (H2 : eventval_match ge arg targ vres) : exists (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge vargs' m1'\n    (Event_annot text (arg :: nil) :: E0) vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge vargs' m1'\n    (Event_annot text (arg :: nil) :: E0) vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list (vres :: nil) vargs') (arg : eventval) (H2 : eventval_match ge arg targ vres)","proofString":"inv H1.\ninv H6.\nexists v2; exists m1'; intuition auto with mem.\neconstructor; eauto.\neapply eventval_match_lessdef; eauto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (arg : eventval) (H2 : eventval_match ge arg targ vres) (v2 : val) (vl2 : list val) (H4 : Val.lessdef vres v2) (H6 : Val.lessdef_list nil vl2) : exists (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge (v2 :: vl2) m1'\n    (Event_annot text (arg :: nil) :: E0) vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge (v2 :: vl2) m1'\n    (Event_annot text (arg :: nil) :: E0) vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (arg : eventval) (H2 : eventval_match ge arg targ vres) (v2 : val) (vl2 : list val) (H4 : Val.lessdef vres v2) (H6 : Val.lessdef_list nil vl2)","proofString":"inv H6.\nexists v2; exists m1'; intuition auto with mem.\neconstructor; eauto.\neapply eventval_match_lessdef; eauto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (arg : eventval) (H2 : eventval_match ge arg targ vres) (v2 : val) (H4 : Val.lessdef vres v2) : exists (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge (v2 :: nil) m1'\n    (Event_annot text (arg :: nil) :: E0) vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge (v2 :: nil) m1'\n    (Event_annot text (arg :: nil) :: E0) vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (arg : eventval) (H2 : eventval_match ge arg targ vres) (v2 : val) (H4 : Val.lessdef vres v2)","proofString":"exists v2; exists m1'; intuition auto with mem.\neconstructor; eauto.\neapply eventval_match_lessdef; eauto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (arg : eventval) (H2 : eventval_match ge arg targ vres) (v2 : val) (H4 : Val.lessdef vres v2) : extcall_annot_val_sem text targ ge (v2 :: nil) m1'\n  (Event_annot text (arg :: nil) :: E0) v2 m1'.","conclusion":"extcall_annot_val_sem text targ ge (v2 :: nil) m1'\n  (Event_annot text (arg :: nil) :: E0) v2 m1'","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (arg : eventval) (H2 : eventval_match ge arg targ vres) (v2 : val) (H4 : Val.lessdef vres v2)","proofString":"econstructor; eauto.\neapply eventval_match_lessdef; eauto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (arg : eventval) (H2 : eventval_match ge arg targ vres) (v2 : val) (H4 : Val.lessdef vres v2) : eventval_match ge arg targ v2.","conclusion":"eventval_match ge arg targ v2","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vres : val) (m2 m1' : mem) (H0 : Mem.extends m2 m1') (arg : eventval) (H2 : eventval_match ge arg targ vres) (v2 : val) (H4 : Val.lessdef vres v2)","proofString":"eapply eventval_match_lessdef; eauto."},{"statement":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : extcall_annot_val_sem text targ ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : extcall_annot_val_sem text targ ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"inv H0.\ninv H2.\ninv H7.\nexists f; exists v'; exists m1'; intuition auto with mem.\neconstructor; eauto.\neapply eventval_match_inject; eauto.\nred; intros; congruence."},{"statement":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f (vres :: nil) vargs') (arg : eventval) (H3 : eventval_match ge1 arg targ vres) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge2 vargs' m1'\n    (Event_annot text (arg :: nil) :: E0) vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge2 vargs' m1'\n    (Event_annot text (arg :: nil) :: E0) vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f (vres :: nil) vargs') (arg : eventval) (H3 : eventval_match ge1 arg targ vres)","proofString":"inv H2.\ninv H7.\nexists f; exists v'; exists m1'; intuition auto with mem.\neconstructor; eauto.\neapply eventval_match_inject; eauto.\nred; intros; congruence."},{"statement":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (arg : eventval) (H3 : eventval_match ge1 arg targ vres) (v' : val) (vl' : list val) (H5 : Val.inject f vres v') (H7 : Val.inject_list f nil vl') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge2 (v' :: vl') m1'\n    (Event_annot text (arg :: nil) :: E0) vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge2 (v' :: vl') m1'\n    (Event_annot text (arg :: nil) :: E0) vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (arg : eventval) (H3 : eventval_match ge1 arg targ vres) (v' : val) (vl' : list val) (H5 : Val.inject f vres v') (H7 : Val.inject_list f nil vl')","proofString":"inv H7.\nexists f; exists v'; exists m1'; intuition auto with mem.\neconstructor; eauto.\neapply eventval_match_inject; eauto.\nred; intros; congruence."},{"statement":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (arg : eventval) (H3 : eventval_match ge1 arg targ vres) (v' : val) (H5 : Val.inject f vres v') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge2 (v' :: nil) m1'\n    (Event_annot text (arg :: nil) :: E0) vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_annot_val_sem text targ ge2 (v' :: nil) m1'\n    (Event_annot text (arg :: nil) :: E0) vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (arg : eventval) (H3 : eventval_match ge1 arg targ vres) (v' : val) (H5 : Val.inject f vres v')","proofString":"exists f; exists v'; exists m1'; intuition auto with mem.\neconstructor; eauto.\neapply eventval_match_inject; eauto.\nred; intros; congruence."},{"statement":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (arg : eventval) (H3 : eventval_match ge1 arg targ vres) (v' : val) (H5 : Val.inject f vres v') : extcall_annot_val_sem text targ ge2 (v' :: nil) m1'\n  (Event_annot text (arg :: nil) :: E0) v' m1'.","conclusion":"extcall_annot_val_sem text targ ge2 (v' :: nil) m1'\n  (Event_annot text (arg :: nil) :: E0) v' m1'","hypotheses":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (arg : eventval) (H3 : eventval_match ge1 arg targ vres) (v' : val) (H5 : Val.inject f vres v')","proofString":"econstructor; eauto.\neapply eventval_match_inject; eauto."},{"statement":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (arg : eventval) (H3 : eventval_match ge1 arg targ vres) (v' : val) (H5 : Val.inject f vres v') : eventval_match ge2 arg targ v'.","conclusion":"eventval_match ge2 arg targ v'","hypotheses":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (arg : eventval) (H3 : eventval_match ge1 arg targ vres) (v' : val) (H5 : Val.inject f vres v')","proofString":"eapply eventval_match_inject; eauto."},{"statement":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (arg : eventval) (H3 : eventval_match ge1 arg targ vres) (v' : val) (H5 : Val.inject f vres v') : inject_separated f f m2 m1'.","conclusion":"inject_separated f f m2 m1'","hypotheses":"(text : string) (targ : typ) (ge1 ge2 : Senv.t) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (arg : eventval) (H3 : eventval_match ge1 arg targ vres) (v' : val) (H5 : Val.inject f vres v')","proofString":"red; intros; congruence."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : extcall_annot_val_sem text targ ge vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : extcall_annot_val_sem text targ ge vargs m t vres m')","proofString":"inv H; simpl; lia."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_annot_val_sem text targ ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : exists (vres2 : val) (m2 : mem),\n  extcall_annot_val_sem text targ ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  extcall_annot_val_sem text targ ge vargs m t2 vres2 m2","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_annot_val_sem text targ ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"assert (t1 = t2).\ninv H; inv H0; auto.\nsubst t2.\nexists vres1; exists m1; auto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_annot_val_sem text targ ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : t1 = t2.","conclusion":"t1 = t2","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_annot_val_sem text targ ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"inv H; inv H0; auto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_annot_val_sem text targ ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) (H1 : t1 = t2) : exists (vres2 : val) (m2 : mem),\n  extcall_annot_val_sem text targ ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  extcall_annot_val_sem text targ ge vargs m t2 vres2 m2","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_annot_val_sem text targ ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) (H1 : t1 = t2)","proofString":"subst t2.\nexists vres1; exists m1; auto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (H : extcall_annot_val_sem text targ ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t1) : exists (vres2 : val) (m2 : mem),\n  extcall_annot_val_sem text targ ge vargs m t1 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  extcall_annot_val_sem text targ ge vargs m t1 vres2 m2","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (H : extcall_annot_val_sem text targ ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t1)","proofString":"exists vres1; exists m1; auto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : extcall_annot_val_sem text targ ge vargs m t1 vres1 m1) (H0 : extcall_annot_val_sem text targ ge vargs m t2 vres2 m2) : match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2).","conclusion":"match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2)","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : extcall_annot_val_sem text targ ge vargs m t1 vres1 m1) (H0 : extcall_annot_val_sem text targ ge vargs m t2 vres2 m2)","proofString":"inv H; inv H0.\nassert (arg = arg0).\neapply eventval_match_determ_2; eauto.\nsubst arg0.\nsplit.\nconstructor.\nauto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vres2 : val) (m2 : mem) (arg : eventval) (H1 : eventval_match ge arg targ vres2) (arg0 : eventval) (H2 : eventval_match ge arg0 targ vres2) : match_traces ge (Event_annot text (arg :: nil) :: E0)\n  (Event_annot text (arg0 :: nil) :: E0) /\\\n(Event_annot text (arg :: nil) :: E0 = Event_annot text (arg0 :: nil) :: E0 ->\n vres2 = vres2 /\\ m2 = m2).","conclusion":"match_traces ge (Event_annot text (arg :: nil) :: E0)\n  (Event_annot text (arg0 :: nil) :: E0) /\\\n(Event_annot text (arg :: nil) :: E0 = Event_annot text (arg0 :: nil) :: E0 ->\n vres2 = vres2 /\\ m2 = m2)","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vres2 : val) (m2 : mem) (arg : eventval) (H1 : eventval_match ge arg targ vres2) (arg0 : eventval) (H2 : eventval_match ge arg0 targ vres2)","proofString":"assert (arg = arg0).\neapply eventval_match_determ_2; eauto.\nsubst arg0.\nsplit.\nconstructor.\nauto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vres2 : val) (m2 : mem) (arg : eventval) (H1 : eventval_match ge arg targ vres2) (arg0 : eventval) (H2 : eventval_match ge arg0 targ vres2) : arg = arg0.","conclusion":"arg = arg0","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vres2 : val) (m2 : mem) (arg : eventval) (H1 : eventval_match ge arg targ vres2) (arg0 : eventval) (H2 : eventval_match ge arg0 targ vres2)","proofString":"eapply eventval_match_determ_2; eauto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vres2 : val) (m2 : mem) (arg : eventval) (H1 : eventval_match ge arg targ vres2) (arg0 : eventval) (H2 : eventval_match ge arg0 targ vres2) (H : arg = arg0) : match_traces ge (Event_annot text (arg :: nil) :: E0)\n  (Event_annot text (arg0 :: nil) :: E0) /\\\n(Event_annot text (arg :: nil) :: E0 = Event_annot text (arg0 :: nil) :: E0 ->\n vres2 = vres2 /\\ m2 = m2).","conclusion":"match_traces ge (Event_annot text (arg :: nil) :: E0)\n  (Event_annot text (arg0 :: nil) :: E0) /\\\n(Event_annot text (arg :: nil) :: E0 = Event_annot text (arg0 :: nil) :: E0 ->\n vres2 = vres2 /\\ m2 = m2)","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vres2 : val) (m2 : mem) (arg : eventval) (H1 : eventval_match ge arg targ vres2) (arg0 : eventval) (H2 : eventval_match ge arg0 targ vres2) (H : arg = arg0)","proofString":"subst arg0.\nsplit.\nconstructor.\nauto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vres2 : val) (m2 : mem) (arg : eventval) (H1 H2 : eventval_match ge arg targ vres2) : match_traces ge (Event_annot text (arg :: nil) :: E0)\n  (Event_annot text (arg :: nil) :: E0) /\\\n(Event_annot text (arg :: nil) :: E0 = Event_annot text (arg :: nil) :: E0 ->\n vres2 = vres2 /\\ m2 = m2).","conclusion":"match_traces ge (Event_annot text (arg :: nil) :: E0)\n  (Event_annot text (arg :: nil) :: E0) /\\\n(Event_annot text (arg :: nil) :: E0 = Event_annot text (arg :: nil) :: E0 ->\n vres2 = vres2 /\\ m2 = m2)","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vres2 : val) (m2 : mem) (arg : eventval) (H1 H2 : eventval_match ge arg targ vres2)","proofString":"split.\nconstructor.\nauto."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vres2 : val) (m2 : mem) (arg : eventval) (H1 H2 : eventval_match ge arg targ vres2) : match_traces ge (Event_annot text (arg :: nil) :: E0)\n  (Event_annot text (arg :: nil) :: E0).","conclusion":"match_traces ge (Event_annot text (arg :: nil) :: E0)\n  (Event_annot text (arg :: nil) :: E0)","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vres2 : val) (m2 : mem) (arg : eventval) (H1 H2 : eventval_match ge arg targ vres2)","proofString":"constructor."},{"statement":"(text : string) (targ : typ) (ge : Senv.t) (vres2 : val) (m2 : mem) (arg : eventval) (H1 H2 : eventval_match ge arg targ vres2) : Event_annot text (arg :: nil) :: E0 = Event_annot text (arg :: nil) :: E0 ->\nvres2 = vres2 /\\ m2 = m2.","conclusion":"Event_annot text (arg :: nil) :: E0 = Event_annot text (arg :: nil) :: E0 ->\nvres2 = vres2 /\\ m2 = m2","hypotheses":"(text : string) (targ : typ) (ge : Senv.t) (vres2 : val) (m2 : mem) (arg : eventval) (H1 H2 : eventval_match ge arg targ vres2)","proofString":"auto."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : extcall_debug_sem ge vargs m1 t vres m2) : Val.has_rettype vres\n  (sig_res\n     {|\n       sig_args := map inj_type targs; sig_res := Xvoid; sig_cc := cc_default\n     |}).","conclusion":"Val.has_rettype vres\n  (sig_res\n     {|\n       sig_args := map inj_type targs; sig_res := Xvoid; sig_cc := cc_default\n     |})","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : extcall_debug_sem ge vargs m1 t vres m2)","proofString":"inv H.\nsimpl.\nauto."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) : Val.has_rettype Vundef\n  (sig_res\n     {|\n       sig_args := map inj_type targs; sig_res := Xvoid; sig_cc := cc_default\n     |}).","conclusion":"Val.has_rettype Vundef\n  (sig_res\n     {|\n       sig_args := map inj_type targs; sig_res := Xvoid; sig_cc := cc_default\n     |})","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem)","proofString":"simpl.\nauto."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) : True.","conclusion":"True","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem)","proofString":"auto."},{"statement":"(targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : extcall_debug_sem ge1 vargs m1 t vres m2) : extcall_debug_sem ge2 vargs m1 t vres m2.","conclusion":"extcall_debug_sem ge2 vargs m1 t vres m2","hypotheses":"(targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : extcall_debug_sem ge1 vargs m1 t vres m2)","proofString":"inv H0.\neconstructor; eauto."},{"statement":"(targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (H : Senv.equiv ge1 ge2) : extcall_debug_sem ge2 vargs m2 E0 Vundef m2.","conclusion":"extcall_debug_sem ge2 vargs m2 E0 Vundef m2","hypotheses":"(targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (H : Senv.equiv ge1 ge2)","proofString":"econstructor; eauto."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : extcall_debug_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : extcall_debug_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b)","proofString":"inv H; auto."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : extcall_debug_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) : Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : extcall_debug_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p)","proofString":"inv H; auto."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_debug_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) : Mem.loadbytes m1 b ofs n = Some bytes.","conclusion":"Mem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : extcall_debug_sem ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable)","proofString":"inv H; auto."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : extcall_debug_sem ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs') : exists (vres' : val) (m2' : mem),\n  extcall_debug_sem ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_debug_sem ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : extcall_debug_sem ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs')","proofString":"inv H.\nexists Vundef; exists m1'; intuition auto with mem.\neconstructor; eauto."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list vargs vargs') : exists (vres' : val) (m2' : mem),\n  extcall_debug_sem ge vargs' m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  extcall_debug_sem ge vargs' m1' E0 vres' m2' /\\\n  Val.lessdef Vundef vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m2) m1' m2'","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list vargs vargs')","proofString":"exists Vundef; exists m1'; intuition auto with mem.\neconstructor; eauto."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list vargs vargs') : extcall_debug_sem ge vargs' m1' E0 Vundef m1'.","conclusion":"extcall_debug_sem ge vargs' m1' E0 Vundef m1'","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 m1' : mem) (vargs' : list val) (H0 : Mem.extends m2 m1') (H1 : Val.lessdef_list vargs vargs')","proofString":"econstructor; eauto."},{"statement":"(targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : extcall_debug_sem ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_debug_sem ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_debug_sem ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : extcall_debug_sem ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"inv H0.\nexists f; exists Vundef; exists m1'; intuition auto with mem.\neconstructor; eauto.\nred; intros; congruence."},{"statement":"(targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_debug_sem ge2 vargs' m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  extcall_debug_sem ge2 vargs' m1' E0 vres' m2' /\\\n  Val.inject f' Vundef vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m2 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m2) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m2 m1'","hypotheses":"(targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"exists f; exists Vundef; exists m1'; intuition auto with mem.\neconstructor; eauto.\nred; intros; congruence."},{"statement":"(targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs') : extcall_debug_sem ge2 vargs' m1' E0 Vundef m1'.","conclusion":"extcall_debug_sem ge2 vargs' m1' E0 Vundef m1'","hypotheses":"(targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"econstructor; eauto."},{"statement":"(targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs') : inject_separated f f m2 m1'.","conclusion":"inject_separated f f m2 m1'","hypotheses":"(targs : list typ) (ge1 ge2 : Senv.t) (vargs : list val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H1 : Mem.inject f m2 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"red; intros; congruence."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : extcall_debug_sem ge vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : extcall_debug_sem ge vargs m t vres m')","proofString":"inv H; simpl; lia."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_debug_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : exists (vres2 : val) (m2 : mem), extcall_debug_sem ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem), extcall_debug_sem ge vargs m t2 vres2 m2","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : extcall_debug_sem ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"inv H; inv H0.\nexists Vundef, m1; constructor."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem) : exists (vres2 : val) (m2 : mem), extcall_debug_sem ge vargs m1 nil vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem), extcall_debug_sem ge vargs m1 nil vres2 m2","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m1 : mem)","proofString":"exists Vundef, m1; constructor."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : extcall_debug_sem ge vargs m t1 vres1 m1) (H0 : extcall_debug_sem ge vargs m t2 vres2 m2) : match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2).","conclusion":"match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2)","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : extcall_debug_sem ge vargs m t1 vres1 m1) (H0 : extcall_debug_sem ge vargs m t2 vres2 m2)","proofString":"inv H; inv H0.\nsplit.\nconstructor.\nauto."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) : match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m2 = m2).","conclusion":"match_traces ge E0 E0 /\\ (E0 = E0 -> Vundef = Vundef /\\ m2 = m2)","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem)","proofString":"split.\nconstructor.\nauto."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) : match_traces ge E0 E0.","conclusion":"match_traces ge E0 E0","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem)","proofString":"constructor."},{"statement":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem) : E0 = E0 -> Vundef = Vundef /\\ m2 = m2.","conclusion":"E0 = E0 -> Vundef = Vundef /\\ m2 = m2","hypotheses":"(targs : list typ) (ge : Senv.t) (vargs : list val) (m2 : mem)","proofString":"auto."},{"statement":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : meminj) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Val.inject_list f vargs vargs') : exists vres' : val,\n  known_builtin_sem bf ge' vargs' m' t vres' m' /\\ Val.inject f vres vres'.","conclusion":"exists vres' : val,\n  known_builtin_sem bf ge' vargs' m' t vres' m' /\\ Val.inject f vres vres'","hypotheses":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : meminj) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Val.inject_list f vargs vargs')","proofString":"inv H.\nexploit builtin_function_sem_inject; eauto.\nintros (vres' & A & B).\nexists vres'; auto using known_builtin_sem."},{"statement":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (f : meminj) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H0 : Val.inject_list f vargs vargs') (H1 : builtin_function_sem bf vargs = Some vres) : exists vres' : val,\n  known_builtin_sem bf ge' vargs' m' E0 vres' m' /\\ Val.inject f vres vres'.","conclusion":"exists vres' : val,\n  known_builtin_sem bf ge' vargs' m' E0 vres' m' /\\ Val.inject f vres vres'","hypotheses":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (f : meminj) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H0 : Val.inject_list f vargs vargs') (H1 : builtin_function_sem bf vargs = Some vres)","proofString":"exploit builtin_function_sem_inject; eauto.\nintros (vres' & A & B).\nexists vres'; auto using known_builtin_sem."},{"statement":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (f : meminj) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H0 : Val.inject_list f vargs vargs') (H1 : builtin_function_sem bf vargs = Some vres) : (exists vres' : val,\n   builtin_function_sem bf vargs' = Some vres' /\\ Val.inject f vres vres') ->\nexists vres' : val,\n  known_builtin_sem bf ge' vargs' m' E0 vres' m' /\\ Val.inject f vres vres'.","conclusion":"(exists vres' : val,\n   builtin_function_sem bf vargs' = Some vres' /\\ Val.inject f vres vres') ->\nexists vres' : val,\n  known_builtin_sem bf ge' vargs' m' E0 vres' m' /\\ Val.inject f vres vres'","hypotheses":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (f : meminj) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H0 : Val.inject_list f vargs vargs') (H1 : builtin_function_sem bf vargs = Some vres)","proofString":"intros (vres' & A & B).\nexists vres'; auto using known_builtin_sem."},{"statement":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (f : meminj) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H0 : Val.inject_list f vargs vargs') (H1 : builtin_function_sem bf vargs = Some vres) (vres' : val) (A : builtin_function_sem bf vargs' = Some vres') (B : Val.inject f vres vres') : exists vres'0 : val,\n  known_builtin_sem bf ge' vargs' m' E0 vres'0 m' /\\ Val.inject f vres vres'0.","conclusion":"exists vres'0 : val,\n  known_builtin_sem bf ge' vargs' m' E0 vres'0 m' /\\ Val.inject f vres vres'0","hypotheses":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (f : meminj) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H0 : Val.inject_list f vargs vargs') (H1 : builtin_function_sem bf vargs = Some vres) (vres' : val) (A : builtin_function_sem bf vargs' = Some vres') (B : Val.inject f vres vres')","proofString":"exists vres'; auto using known_builtin_sem."},{"statement":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Val.lessdef_list vargs vargs') : exists vres' : val,\n  known_builtin_sem bf ge' vargs' m' t vres' m' /\\ Val.lessdef vres vres'.","conclusion":"exists vres' : val,\n  known_builtin_sem bf ge' vargs' m' t vres' m' /\\ Val.lessdef vres vres'","hypotheses":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Val.lessdef_list vargs vargs')","proofString":"inv H.\nexploit builtin_function_sem_lessdef; eauto.\nintros (vres' & A & B).\nexists vres'; auto using known_builtin_sem."},{"statement":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H0 : Val.lessdef_list vargs vargs') (H1 : builtin_function_sem bf vargs = Some vres) : exists vres' : val,\n  known_builtin_sem bf ge' vargs' m' E0 vres' m' /\\ Val.lessdef vres vres'.","conclusion":"exists vres' : val,\n  known_builtin_sem bf ge' vargs' m' E0 vres' m' /\\ Val.lessdef vres vres'","hypotheses":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H0 : Val.lessdef_list vargs vargs') (H1 : builtin_function_sem bf vargs = Some vres)","proofString":"exploit builtin_function_sem_lessdef; eauto.\nintros (vres' & A & B).\nexists vres'; auto using known_builtin_sem."},{"statement":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H0 : Val.lessdef_list vargs vargs') (H1 : builtin_function_sem bf vargs = Some vres) : (exists vres' : val,\n   builtin_function_sem bf vargs' = Some vres' /\\ Val.lessdef vres vres') ->\nexists vres' : val,\n  known_builtin_sem bf ge' vargs' m' E0 vres' m' /\\ Val.lessdef vres vres'.","conclusion":"(exists vres' : val,\n   builtin_function_sem bf vargs' = Some vres' /\\ Val.lessdef vres vres') ->\nexists vres' : val,\n  known_builtin_sem bf ge' vargs' m' E0 vres' m' /\\ Val.lessdef vres vres'","hypotheses":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H0 : Val.lessdef_list vargs vargs') (H1 : builtin_function_sem bf vargs = Some vres)","proofString":"intros (vres' & A & B).\nexists vres'; auto using known_builtin_sem."},{"statement":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H0 : Val.lessdef_list vargs vargs') (H1 : builtin_function_sem bf vargs = Some vres) (vres' : val) (A : builtin_function_sem bf vargs' = Some vres') (B : Val.lessdef vres vres') : exists vres'0 : val,\n  known_builtin_sem bf ge' vargs' m' E0 vres'0 m' /\\ Val.lessdef vres vres'0.","conclusion":"exists vres'0 : val,\n  known_builtin_sem bf ge' vargs' m' E0 vres'0 m' /\\ Val.lessdef vres vres'0","hypotheses":"(bf : builtin_function) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (ge' : Senv.t) (vargs' : list val) (m' : mem) (H0 : Val.lessdef_list vargs vargs') (H1 : builtin_function_sem bf vargs = Some vres) (vres' : val) (A : builtin_function_sem bf vargs' = Some vres') (B : Val.lessdef vres vres')","proofString":"exists vres'; auto using known_builtin_sem."},{"statement":"(bf : builtin_function) : extcall_properties (known_builtin_sem bf) (builtin_function_sig bf).","conclusion":"extcall_properties (known_builtin_sem bf) (builtin_function_sig bf)","hypotheses":"(bf : builtin_function)","proofString":"set (bsem := builtin_function_sem bf).\nconstructor; intros.\ninv H.\nspecialize (bs_well_typed  _ bsem vargs).\nunfold val_opt_has_rettype, bsem; rewrite H0.\nauto.\ninv H0.\neconstructor; eauto.\ninv H; auto.\ninv H; auto.\ninv H; auto.\nassert (m2 = m1) by (inv H; auto).\nsubst m2.\nexploit known_builtin_sem_lessdef; eauto.\nintros (vres' & A & B).\nexists vres', m1'; intuition eauto using Mem.unchanged_on_refl.\nassert (m2 = m1) by (inv H0; auto).\nsubst m2.\nexploit known_builtin_sem_inject; eauto.\nintros (vres' & A & B).\nexists f, vres', m1'; intuition eauto using Mem.unchanged_on_refl.\nred; intros; congruence.\ninv H; simpl; lia.\ninv H; inv H0.\nexists vres1, m1; constructor; auto.\ninv H; inv H0.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (H0 : builtin_function_sem bf vargs = Some vres) : Val.has_rettype vres (sig_res (builtin_function_sig bf)) ->\nVal.has_rettype vres (sig_res (builtin_function_sig bf)).","conclusion":"Val.has_rettype vres (sig_res (builtin_function_sig bf)) ->\nVal.has_rettype vres (sig_res (builtin_function_sig bf))","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (H0 : builtin_function_sem bf vargs = Some vres)","proofString":"auto."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : known_builtin_sem bf ge1 vargs m1 t vres m2) : known_builtin_sem bf ge2 vargs m1 t vres m2.","conclusion":"known_builtin_sem bf ge2 vargs m1 t vres m2","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H0 : known_builtin_sem bf ge1 vargs m1 t vres m2)","proofString":"inv H0.\neconstructor; eauto."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge1 ge2 : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H1 : builtin_function_sem bf vargs = Some vres) : known_builtin_sem bf ge2 vargs m2 E0 vres m2.","conclusion":"known_builtin_sem bf ge2 vargs m2 E0 vres m2","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge1 ge2 : Senv.t) (vargs : list val) (vres : val) (m2 : mem) (H : Senv.equiv ge1 ge2) (H1 : builtin_function_sem bf vargs = Some vres)","proofString":"econstructor; eauto."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) : Mem.valid_block m2 b.","conclusion":"Mem.valid_block m2 b","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b)","proofString":"inv H; auto."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p) : Mem.perm m1 b ofs Max p.","conclusion":"Mem.perm m1 b ofs Max p","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs : Z) (p : permission) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.perm m2 b ofs Max p)","proofString":"inv H; auto."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable) : Mem.loadbytes m1 b ofs n = Some bytes.","conclusion":"Mem.loadbytes m1 b ofs n = Some bytes","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (b : block) (ofs n : Z) (bytes : list memval) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Mem.valid_block m1 b) (H1 : Mem.loadbytes m2 b ofs n = Some bytes) (H2 : forall i : Z, ofs <= i < ofs + n -> ~ Mem.perm m1 b i Max Writable)","proofString":"inv H; auto."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs') : exists (vres' : val) (m2' : mem),\n  known_builtin_sem bf ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  known_builtin_sem bf ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs')","proofString":"assert (m2 = m1) by (inv H; auto).\nsubst m2.\nexploit known_builtin_sem_lessdef; eauto.\nintros (vres' & A & B).\nexists vres', m1'; intuition eauto using Mem.unchanged_on_refl."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs') (H2 : m2 = m1) : exists (vres' : val) (m2' : mem),\n  known_builtin_sem bf ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  known_builtin_sem bf ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m2 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 m1' : mem) (vargs' : list val) (H : known_builtin_sem bf ge vargs m1 t vres m2) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs') (H2 : m2 = m1)","proofString":"subst m2.\nexploit known_builtin_sem_lessdef; eauto.\nintros (vres' & A & B).\nexists vres', m1'; intuition eauto using Mem.unchanged_on_refl."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m1' : mem) (vargs' : list val) (H : known_builtin_sem bf ge vargs m1 t vres m1) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs') : exists (vres' : val) (m2' : mem),\n  known_builtin_sem bf ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m1 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'.","conclusion":"exists (vres' : val) (m2' : mem),\n  known_builtin_sem bf ge vargs' m1' t vres' m2' /\\\n  Val.lessdef vres vres' /\\\n  Mem.extends m1 m2' /\\ Mem.unchanged_on (loc_out_of_bounds m1) m1' m2'","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m1' : mem) (vargs' : list val) (H : known_builtin_sem bf ge vargs m1 t vres m1) (H0 : Mem.extends m1 m1') (H1 : Val.lessdef_list vargs vargs')","proofString":"exploit known_builtin_sem_lessdef; eauto.\nintros (vres' & A & B).\nexists vres', m1'; intuition eauto using Mem.unchanged_on_refl."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : known_builtin_sem bf ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  known_builtin_sem bf ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  known_builtin_sem bf ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : known_builtin_sem bf ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"assert (m2 = m1) by (inv H0; auto).\nsubst m2.\nexploit known_builtin_sem_inject; eauto.\nintros (vres' & A & B).\nexists f, vres', m1'; intuition eauto using Mem.unchanged_on_refl.\nred; intros; congruence."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : known_builtin_sem bf ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (H3 : m2 = m1) : exists (f' : meminj) (vres' : val) (m2' : mem),\n  known_builtin_sem bf ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  known_builtin_sem bf ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : known_builtin_sem bf ge1 vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (H3 : m2 = m1)","proofString":"subst m2.\nexploit known_builtin_sem_inject; eauto.\nintros (vres' & A & B).\nexists f, vres', m1'; intuition eauto using Mem.unchanged_on_refl.\nred; intros; congruence."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : known_builtin_sem bf ge1 vargs m1 t vres m1) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  known_builtin_sem bf ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m1 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m1 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  known_builtin_sem bf ge2 vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m1 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m1 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : known_builtin_sem bf ge1 vargs m1 t vres m1) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"exploit known_builtin_sem_inject; eauto.\nintros (vres' & A & B).\nexists f, vres', m1'; intuition eauto using Mem.unchanged_on_refl.\nred; intros; congruence."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : known_builtin_sem bf ge1 vargs m1 t vres m1) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (vres' : val) (A : known_builtin_sem bf ge2 vargs' m1' t vres' m1') (B : Val.inject f vres vres') : inject_separated f f m1 m1'.","conclusion":"inject_separated f f m1 m1'","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge1 ge2 : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : symbols_inject f ge1 ge2) (H0 : known_builtin_sem bf ge1 vargs m1 t vres m1) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (vres' : val) (A : known_builtin_sem bf ge2 vargs' m1' t vres' m1') (B : Val.inject f vres vres')","proofString":"red; intros; congruence."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : known_builtin_sem bf ge vargs m t vres m') : (Datatypes.length t <= 1)%nat.","conclusion":"(Datatypes.length t <= 1)%nat","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres : val) (m' : mem) (H : known_builtin_sem bf ge vargs m t vres m')","proofString":"inv H; simpl; lia."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : known_builtin_sem bf ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2) : exists (vres2 : val) (m2 : mem), known_builtin_sem bf ge vargs m t2 vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem), known_builtin_sem bf ge vargs m t2 vres2 m2","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (H : known_builtin_sem bf ge vargs m t1 vres1 m1) (H0 : match_traces ge t1 t2)","proofString":"inv H; inv H0.\nexists vres1, m1; constructor; auto."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (vres1 : val) (m1 : mem) (H1 : builtin_function_sem bf vargs = Some vres1) : exists (vres2 : val) (m2 : mem),\n  known_builtin_sem bf ge vargs m1 nil vres2 m2.","conclusion":"exists (vres2 : val) (m2 : mem),\n  known_builtin_sem bf ge vargs m1 nil vres2 m2","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (vres1 : val) (m1 : mem) (H1 : builtin_function_sem bf vargs = Some vres1)","proofString":"exists vres1, m1; constructor; auto."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : known_builtin_sem bf ge vargs m t1 vres1 m1) (H0 : known_builtin_sem bf ge vargs m t2 vres2 m2) : match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2).","conclusion":"match_traces ge t1 t2 /\\ (t1 = t2 -> vres1 = vres2 /\\ m1 = m2)","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : known_builtin_sem bf ge vargs m t1 vres1 m1) (H0 : known_builtin_sem bf ge vargs m t2 vres2 m2)","proofString":"inv H; inv H0.\nsplit.\nconstructor.\nintuition congruence."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (vres1 vres2 : val) (m2 : mem) (H1 : builtin_function_sem bf vargs = Some vres1) (H : builtin_function_sem bf vargs = Some vres2) : match_traces ge E0 E0 /\\ (E0 = E0 -> vres1 = vres2 /\\ m2 = m2).","conclusion":"match_traces ge E0 E0 /\\ (E0 = E0 -> vres1 = vres2 /\\ m2 = m2)","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (vres1 vres2 : val) (m2 : mem) (H1 : builtin_function_sem bf vargs = Some vres1) (H : builtin_function_sem bf vargs = Some vres2)","proofString":"split.\nconstructor.\nintuition congruence."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (vres1 vres2 : val) (m2 : mem) (H1 : builtin_function_sem bf vargs = Some vres1) (H : builtin_function_sem bf vargs = Some vres2) : match_traces ge E0 E0.","conclusion":"match_traces ge E0 E0","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (vres1 vres2 : val) (m2 : mem) (H1 : builtin_function_sem bf vargs = Some vres1) (H : builtin_function_sem bf vargs = Some vres2)","proofString":"constructor."},{"statement":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (vres1 vres2 : val) (m2 : mem) (H1 : builtin_function_sem bf vargs = Some vres1) (H : builtin_function_sem bf vargs = Some vres2) : E0 = E0 -> vres1 = vres2 /\\ m2 = m2.","conclusion":"E0 = E0 -> vres1 = vres2 /\\ m2 = m2","hypotheses":"(bf : builtin_function) (bsem : builtin_sem (sig_res (builtin_function_sig bf))) (ge : Senv.t) (vargs : list val) (vres1 vres2 : val) (m2 : mem) (H1 : builtin_function_sem bf vargs = Some vres1) (H : builtin_function_sem bf vargs = Some vres2)","proofString":"intuition congruence."},{"statement":"(name : string) (sg : signature) : extcall_properties\n  match lookup_builtin_function name sg with\n  | Some bf => known_builtin_sem bf\n  | None => external_functions_sem name sg\n  end sg.","conclusion":"extcall_properties\n  match lookup_builtin_function name sg with\n  | Some bf => known_builtin_sem bf\n  | None => external_functions_sem name sg\n  end sg","hypotheses":"(name : string) (sg : signature)","proofString":"destruct (lookup_builtin_function name sg) as [bf|] eqn:L.\nexploit lookup_builtin_function_sig; eauto.\nintros EQ; subst sg.\napply known_builtin_ok.\napply external_functions_properties."},{"statement":"(name : string) (sg : signature) (bf : builtin_function) (L : lookup_builtin_function name sg = Some bf) : extcall_properties (known_builtin_sem bf) sg.","conclusion":"extcall_properties (known_builtin_sem bf) sg","hypotheses":"(name : string) (sg : signature) (bf : builtin_function) (L : lookup_builtin_function name sg = Some bf)","proofString":"exploit lookup_builtin_function_sig; eauto.\nintros EQ; subst sg.\napply known_builtin_ok."},{"statement":"(name : string) (sg : signature) (bf : builtin_function) (L : lookup_builtin_function name sg = Some bf) : builtin_function_sig bf = sg -> extcall_properties (known_builtin_sem bf) sg.","conclusion":"builtin_function_sig bf = sg -> extcall_properties (known_builtin_sem bf) sg","hypotheses":"(name : string) (sg : signature) (bf : builtin_function) (L : lookup_builtin_function name sg = Some bf)","proofString":"intros EQ; subst sg.\napply known_builtin_ok."},{"statement":"(name : string) (bf : builtin_function) (L : lookup_builtin_function name (builtin_function_sig bf) = Some bf) : extcall_properties (known_builtin_sem bf) (builtin_function_sig bf).","conclusion":"extcall_properties (known_builtin_sem bf) (builtin_function_sig bf)","hypotheses":"(name : string) (bf : builtin_function) (L : lookup_builtin_function name (builtin_function_sig bf) = Some bf)","proofString":"apply known_builtin_ok."},{"statement":"(name : string) (sg : signature) (L : lookup_builtin_function name sg = None) : extcall_properties (external_functions_sem name sg) sg.","conclusion":"extcall_properties (external_functions_sem name sg) sg","hypotheses":"(name : string) (sg : signature) (L : lookup_builtin_function name sg = None)","proofString":"apply external_functions_properties."},{"statement":"(ef : external_function) : extcall_properties (external_call ef) (ef_sig ef).","conclusion":"extcall_properties (external_call ef) (ef_sig ef)","hypotheses":"(ef : external_function)","proofString":"unfold external_call, ef_sig; destruct ef.\napply external_functions_properties.\napply builtin_or_external_sem_ok.\napply builtin_or_external_sem_ok.\napply volatile_load_ok.\napply volatile_store_ok.\napply extcall_malloc_ok.\napply extcall_free_ok.\napply extcall_memcpy_ok.\napply extcall_annot_ok.\napply extcall_annot_val_ok.\napply inline_assembly_properties.\napply extcall_debug_ok."},{"statement":"(name : string) (sg : signature) : extcall_properties (external_functions_sem name sg) sg.","conclusion":"extcall_properties (external_functions_sem name sg) sg","hypotheses":"(name : string) (sg : signature)","proofString":"apply external_functions_properties."},{"statement":"(name : string) (sg : signature) : extcall_properties (builtin_or_external_sem name sg) sg.","conclusion":"extcall_properties (builtin_or_external_sem name sg) sg","hypotheses":"(name : string) (sg : signature)","proofString":"apply builtin_or_external_sem_ok."},{"statement":"(name : string) (sg : signature) : extcall_properties (builtin_or_external_sem name sg) sg.","conclusion":"extcall_properties (builtin_or_external_sem name sg) sg","hypotheses":"(name : string) (sg : signature)","proofString":"apply builtin_or_external_sem_ok."},{"statement":"(chunk : memory_chunk) : extcall_properties (volatile_load_sem chunk) [Xptr ---> xtype_of_chunk chunk].","conclusion":"extcall_properties (volatile_load_sem chunk) [Xptr ---> xtype_of_chunk chunk]","hypotheses":"(chunk : memory_chunk)","proofString":"apply volatile_load_ok."},{"statement":"(chunk : memory_chunk) : extcall_properties (volatile_store_sem chunk)\n  [Xptr; xtype_of_chunk chunk ---> Xvoid].","conclusion":"extcall_properties (volatile_store_sem chunk)\n  [Xptr; xtype_of_chunk chunk ---> Xvoid]","hypotheses":"(chunk : memory_chunk)","proofString":"apply volatile_store_ok."},{"statement":"extcall_properties extcall_malloc_sem [Xsize_t ---> Xptr].","conclusion":"extcall_properties extcall_malloc_sem [Xsize_t ---> Xptr]","hypotheses":"","proofString":"apply extcall_malloc_ok."},{"statement":"extcall_properties extcall_free_sem [Xptr ---> Xvoid].","conclusion":"extcall_properties extcall_free_sem [Xptr ---> Xvoid]","hypotheses":"","proofString":"apply extcall_free_ok."},{"statement":"(sz al : Z) : extcall_properties (extcall_memcpy_sem sz al) [Xptr; Xptr ---> Xvoid].","conclusion":"extcall_properties (extcall_memcpy_sem sz al) [Xptr; Xptr ---> Xvoid]","hypotheses":"(sz al : Z)","proofString":"apply extcall_memcpy_ok."},{"statement":"(kind : positive) (text : string) (targs : list typ) : extcall_properties (extcall_annot_sem text targs)\n  {|\n    sig_args := map inj_type targs; sig_res := Xvoid; sig_cc := cc_default\n  |}.","conclusion":"extcall_properties (extcall_annot_sem text targs)\n  {|\n    sig_args := map inj_type targs; sig_res := Xvoid; sig_cc := cc_default\n  |}","hypotheses":"(kind : positive) (text : string) (targs : list typ)","proofString":"apply extcall_annot_ok."},{"statement":"(kind : positive) (text : string) (targ : typ) : extcall_properties (extcall_annot_val_sem text targ)\n  [inj_type targ ---> inj_type targ].","conclusion":"extcall_properties (extcall_annot_val_sem text targ)\n  [inj_type targ ---> inj_type targ]","hypotheses":"(kind : positive) (text : string) (targ : typ)","proofString":"apply extcall_annot_val_ok."},{"statement":"(text : string) (sg : signature) (clobbers : list string) : extcall_properties (inline_assembly_sem text sg) sg.","conclusion":"extcall_properties (inline_assembly_sem text sg) sg","hypotheses":"(text : string) (sg : signature) (clobbers : list string)","proofString":"apply inline_assembly_properties."},{"statement":"(kind : positive) (text : ident) (targs : list typ) : extcall_properties extcall_debug_sem\n  {|\n    sig_args := map inj_type targs; sig_res := Xvoid; sig_cc := cc_default\n  |}.","conclusion":"extcall_properties extcall_debug_sem\n  {|\n    sig_args := map inj_type targs; sig_res := Xvoid; sig_cc := cc_default\n  |}","hypotheses":"(kind : positive) (text : ident) (targs : list typ)","proofString":"apply extcall_debug_ok."},{"statement":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2) : Val.has_type vres (proj_sig_res (ef_sig ef)).","conclusion":"Val.has_type vres (proj_sig_res (ef_sig ef))","hypotheses":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2)","proofString":"apply Val.has_proj_xtype.\neapply external_call_well_typed_gen; eauto."},{"statement":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2) : Val.has_rettype vres (sig_res (ef_sig ef)).","conclusion":"Val.has_rettype vres (sig_res (ef_sig ef))","hypotheses":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2)","proofString":"eapply external_call_well_typed_gen; eauto."},{"statement":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2) : Ple (Mem.nextblock m1) (Mem.nextblock m2).","conclusion":"Ple (Mem.nextblock m1) (Mem.nextblock m2)","hypotheses":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2)","proofString":"destruct (plt (Mem.nextblock m2) (Mem.nextblock m1)).\nexploit external_call_valid_block; eauto.\nintros.\neelim Plt_strict; eauto.\nunfold Plt, Ple in *; zify; lia."},{"statement":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2) (p : Plt (Mem.nextblock m2) (Mem.nextblock m1)) : Ple (Mem.nextblock m1) (Mem.nextblock m2).","conclusion":"Ple (Mem.nextblock m1) (Mem.nextblock m2)","hypotheses":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2) (p : Plt (Mem.nextblock m2) (Mem.nextblock m1))","proofString":"exploit external_call_valid_block; eauto.\nintros.\neelim Plt_strict; eauto."},{"statement":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2) (p : Plt (Mem.nextblock m2) (Mem.nextblock m1)) : Mem.valid_block m2 (Mem.nextblock m2) ->\nPle (Mem.nextblock m1) (Mem.nextblock m2).","conclusion":"Mem.valid_block m2 (Mem.nextblock m2) ->\nPle (Mem.nextblock m1) (Mem.nextblock m2)","hypotheses":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2) (p : Plt (Mem.nextblock m2) (Mem.nextblock m1))","proofString":"intros.\neelim Plt_strict; eauto."},{"statement":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2) (p : Plt (Mem.nextblock m2) (Mem.nextblock m1)) (H0 : Mem.valid_block m2 (Mem.nextblock m2)) : Ple (Mem.nextblock m1) (Mem.nextblock m2).","conclusion":"Ple (Mem.nextblock m1) (Mem.nextblock m2)","hypotheses":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2) (p : Plt (Mem.nextblock m2) (Mem.nextblock m1)) (H0 : Mem.valid_block m2 (Mem.nextblock m2))","proofString":"eelim Plt_strict; eauto."},{"statement":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2) (n : ~ Plt (Mem.nextblock m2) (Mem.nextblock m1)) : Ple (Mem.nextblock m1) (Mem.nextblock m2).","conclusion":"Ple (Mem.nextblock m1) (Mem.nextblock m2)","hypotheses":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (H : external_call ef ge vargs m1 t vres m2) (n : ~ Plt (Mem.nextblock m2) (Mem.nextblock m1))","proofString":"unfold Plt, Ple in *; zify; lia."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : meminj_preserves_globals ge f) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  external_call ef ge vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  external_call ef ge vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (H : meminj_preserves_globals ge f) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"destruct H as (A & B & C).\neapply external_call_mem_inject_gen with (ge1 := ge); eauto.\nrepeat split; intros.\nsimpl in H3.\nexploit A; eauto.\nintros EQ; rewrite EQ in H; inv H.\nauto.\nsimpl in H3.\nexploit A; eauto.\nintros EQ; rewrite EQ in H; inv H.\nauto.\nsimpl in H3.\nexists b1; split; eauto.\nsimpl; unfold Genv.block_is_volatile.\ndestruct (Genv.find_var_info ge b1) as [gv1|] eqn:V1.\nexploit B; eauto.\nintros EQ; rewrite EQ in H; inv H.\nrewrite V1; auto.\ndestruct (Genv.find_var_info ge b2) as [gv2|] eqn:V2; auto.\nexploit C; eauto.\nintros EQ; subst b2.\ncongruence."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b1 b2 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b2 = Some gv -> f b1 = Some (b2, delta) -> b2 = b1) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : exists (f' : meminj) (vres' : val) (m2' : mem),\n  external_call ef ge vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'.","conclusion":"exists (f' : meminj) (vres' : val) (m2' : mem),\n  external_call ef ge vargs' m1' t vres' m2' /\\\n  Val.inject f' vres vres' /\\\n  Mem.inject f' m2 m2' /\\\n  Mem.unchanged_on (loc_unmapped f) m1 m2 /\\\n  Mem.unchanged_on (loc_out_of_reach f m1) m1' m2' /\\\n  inject_incr f f' /\\ inject_separated f f' m1 m1'","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b1 b2 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b2 = Some gv -> f b1 = Some (b2, delta) -> b2 = b1) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"eapply external_call_mem_inject_gen with (ge1 := ge); eauto.\nrepeat split; intros.\nsimpl in H3.\nexploit A; eauto.\nintros EQ; rewrite EQ in H; inv H.\nauto.\nsimpl in H3.\nexploit A; eauto.\nintros EQ; rewrite EQ in H; inv H.\nauto.\nsimpl in H3.\nexists b1; split; eauto.\nsimpl; unfold Genv.block_is_volatile.\ndestruct (Genv.find_var_info ge b1) as [gv1|] eqn:V1.\nexploit B; eauto.\nintros EQ; rewrite EQ in H; inv H.\nrewrite V1; auto.\ndestruct (Genv.find_var_info ge b2) as [gv2|] eqn:V2; auto.\nexploit C; eauto.\nintros EQ; subst b2.\ncongruence."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b1 b2 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b2 = Some gv -> f b1 = Some (b2, delta) -> b2 = b1) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') : symbols_inject f ge ge.","conclusion":"symbols_inject f ge ge","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b1 b2 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b2 = Some gv -> f b1 = Some (b2, delta) -> b2 = b1) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs')","proofString":"repeat split; intros.\nsimpl in H3.\nexploit A; eauto.\nintros EQ; rewrite EQ in H; inv H.\nauto.\nsimpl in H3.\nexploit A; eauto.\nintros EQ; rewrite EQ in H; inv H.\nauto.\nsimpl in H3.\nexists b1; split; eauto.\nsimpl; unfold Genv.block_is_volatile.\ndestruct (Genv.find_var_info ge b1) as [gv1|] eqn:V1.\nexploit B; eauto.\nintros EQ; rewrite EQ in H; inv H.\nrewrite V1; auto.\ndestruct (Genv.find_var_info ge b2) as [gv2|] eqn:V2; auto.\nexploit C; eauto.\nintros EQ; subst b2.\ncongruence."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H3 : Senv.find_symbol ge id = Some b1) : delta = 0.","conclusion":"delta = 0","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H3 : Senv.find_symbol ge id = Some b1)","proofString":"simpl in H3.\nexploit A; eauto.\nintros EQ; rewrite EQ in H; inv H.\nauto."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H3 : Genv.find_symbol ge id = Some b1) : delta = 0.","conclusion":"delta = 0","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H3 : Genv.find_symbol ge id = Some b1)","proofString":"exploit A; eauto.\nintros EQ; rewrite EQ in H; inv H.\nauto."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H3 : Genv.find_symbol ge id = Some b1) : f b1 = Some (b1, 0) -> delta = 0.","conclusion":"f b1 = Some (b1, 0) -> delta = 0","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H3 : Genv.find_symbol ge id = Some b1)","proofString":"intros EQ; rewrite EQ in H; inv H.\nauto."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b1 b0 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b0 = Some gv -> f b1 = Some (b0, delta) -> b0 = b1) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b2 : block) (EQ : f b2 = Some (b2, 0)) (H3 : Genv.find_symbol ge id = Some b2) : 0 = 0.","conclusion":"0 = 0","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b1 b0 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b0 = Some gv -> f b1 = Some (b0, delta) -> b0 = b1) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b2 : block) (EQ : f b2 = Some (b2, 0)) (H3 : Genv.find_symbol ge id = Some b2)","proofString":"auto."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H3 : Senv.find_symbol ge id = Some b1) : Senv.find_symbol ge id = Some b2.","conclusion":"Senv.find_symbol ge id = Some b2","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H3 : Senv.find_symbol ge id = Some b1)","proofString":"simpl in H3.\nexploit A; eauto.\nintros EQ; rewrite EQ in H; inv H.\nauto."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H3 : Genv.find_symbol ge id = Some b1) : Senv.find_symbol ge id = Some b2.","conclusion":"Senv.find_symbol ge id = Some b2","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H3 : Genv.find_symbol ge id = Some b1)","proofString":"exploit A; eauto.\nintros EQ; rewrite EQ in H; inv H.\nauto."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H3 : Genv.find_symbol ge id = Some b1) : f b1 = Some (b1, 0) -> Senv.find_symbol ge id = Some b2.","conclusion":"f b1 = Some (b1, 0) -> Senv.find_symbol ge id = Some b2","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (H3 : Genv.find_symbol ge id = Some b1)","proofString":"intros EQ; rewrite EQ in H; inv H.\nauto."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b1 b0 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b0 = Some gv -> f b1 = Some (b0, delta) -> b0 = b1) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b2 : block) (EQ : f b2 = Some (b2, 0)) (H3 : Genv.find_symbol ge id = Some b2) : Senv.find_symbol ge id = Some b2.","conclusion":"Senv.find_symbol ge id = Some b2","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b1 b0 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b0 = Some gv -> f b1 = Some (b0, delta) -> b0 = b1) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b2 : block) (EQ : f b2 = Some (b2, 0)) (H3 : Genv.find_symbol ge id = Some b2)","proofString":"auto."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b2 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b2 = Some gv -> f b0 = Some (b2, delta) -> b2 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 : block) (H : Senv.public_symbol ge id = true) (H3 : Senv.find_symbol ge id = Some b1) : exists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge id = Some b2.","conclusion":"exists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge id = Some b2","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b2 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b2 = Some gv -> f b0 = Some (b2, delta) -> b2 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 : block) (H : Senv.public_symbol ge id = true) (H3 : Senv.find_symbol ge id = Some b1)","proofString":"simpl in H3.\nexists b1; split; eauto."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b2 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b2 = Some gv -> f b0 = Some (b2, delta) -> b2 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 : block) (H : Senv.public_symbol ge id = true) (H3 : Genv.find_symbol ge id = Some b1) : exists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge id = Some b2.","conclusion":"exists b2 : block, f b1 = Some (b2, 0) /\\ Senv.find_symbol ge id = Some b2","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id0 : ident) (b : block),\nGenv.find_symbol ge id0 = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b2 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b2 = Some gv -> f b0 = Some (b2, delta) -> b2 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (id : ident) (b1 : block) (H : Senv.public_symbol ge id = true) (H3 : Genv.find_symbol ge id = Some b1)","proofString":"exists b1; split; eauto."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) : Senv.block_is_volatile ge b2 = Senv.block_is_volatile ge b1.","conclusion":"Senv.block_is_volatile ge b2 = Senv.block_is_volatile ge b1","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta))","proofString":"simpl; unfold Genv.block_is_volatile.\ndestruct (Genv.find_var_info ge b1) as [gv1|] eqn:V1.\nexploit B; eauto.\nintros EQ; rewrite EQ in H; inv H.\nrewrite V1; auto.\ndestruct (Genv.find_var_info ge b2) as [gv2|] eqn:V2; auto.\nexploit C; eauto.\nintros EQ; subst b2.\ncongruence."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) : match Genv.find_var_info ge b2 with\n| Some gv => gvar_volatile gv\n| None => false\nend =\nmatch Genv.find_var_info ge b1 with\n| Some gv => gvar_volatile gv\n| None => false\nend.","conclusion":"match Genv.find_var_info ge b2 with\n| Some gv => gvar_volatile gv\n| None => false\nend =\nmatch Genv.find_var_info ge b1 with\n| Some gv => gvar_volatile gv\n| None => false\nend","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta))","proofString":"destruct (Genv.find_var_info ge b1) as [gv1|] eqn:V1.\nexploit B; eauto.\nintros EQ; rewrite EQ in H; inv H.\nrewrite V1; auto.\ndestruct (Genv.find_var_info ge b2) as [gv2|] eqn:V2; auto.\nexploit C; eauto.\nintros EQ; subst b2.\ncongruence."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (gv1 : globvar V) (V1 : Genv.find_var_info ge b1 = Some gv1) : match Genv.find_var_info ge b2 with\n| Some gv => gvar_volatile gv\n| None => false\nend = gvar_volatile gv1.","conclusion":"match Genv.find_var_info ge b2 with\n| Some gv => gvar_volatile gv\n| None => false\nend = gvar_volatile gv1","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (gv1 : globvar V) (V1 : Genv.find_var_info ge b1 = Some gv1)","proofString":"exploit B; eauto.\nintros EQ; rewrite EQ in H; inv H.\nrewrite V1; auto."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (gv1 : globvar V) (V1 : Genv.find_var_info ge b1 = Some gv1) : f b1 = Some (b1, 0) ->\nmatch Genv.find_var_info ge b2 with\n| Some gv => gvar_volatile gv\n| None => false\nend = gvar_volatile gv1.","conclusion":"f b1 = Some (b1, 0) ->\nmatch Genv.find_var_info ge b2 with\n| Some gv => gvar_volatile gv\n| None => false\nend = gvar_volatile gv1","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (gv1 : globvar V) (V1 : Genv.find_var_info ge b1 = Some gv1)","proofString":"intros EQ; rewrite EQ in H; inv H.\nrewrite V1; auto."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b1 b0 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b0 = Some gv -> f b1 = Some (b0, delta) -> b0 = b1) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b2 : block) (gv1 : globvar V) (EQ : f b2 = Some (b2, 0)) (V1 : Genv.find_var_info ge b2 = Some gv1) : match Genv.find_var_info ge b2 with\n| Some gv => gvar_volatile gv\n| None => false\nend = gvar_volatile gv1.","conclusion":"match Genv.find_var_info ge b2 with\n| Some gv => gvar_volatile gv\n| None => false\nend = gvar_volatile gv1","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b1 b0 : block) (delta : Z) (gv : globvar V),\nGenv.find_var_info ge b0 = Some gv -> f b1 = Some (b0, delta) -> b0 = b1) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b2 : block) (gv1 : globvar V) (EQ : f b2 = Some (b2, 0)) (V1 : Genv.find_var_info ge b2 = Some gv1)","proofString":"rewrite V1; auto."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (V1 : Genv.find_var_info ge b1 = None) : match Genv.find_var_info ge b2 with\n| Some gv => gvar_volatile gv\n| None => false\nend = false.","conclusion":"match Genv.find_var_info ge b2 with\n| Some gv => gvar_volatile gv\n| None => false\nend = false","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (V1 : Genv.find_var_info ge b1 = None)","proofString":"destruct (Genv.find_var_info ge b2) as [gv2|] eqn:V2; auto.\nexploit C; eauto.\nintros EQ; subst b2.\ncongruence."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (V1 : Genv.find_var_info ge b1 = None) (gv2 : globvar V) (V2 : Genv.find_var_info ge b2 = Some gv2) : gvar_volatile gv2 = false.","conclusion":"gvar_volatile gv2 = false","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (V1 : Genv.find_var_info ge b1 = None) (gv2 : globvar V) (V2 : Genv.find_var_info ge b2 = Some gv2)","proofString":"exploit C; eauto.\nintros EQ; subst b2.\ncongruence."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (V1 : Genv.find_var_info ge b1 = None) (gv2 : globvar V) (V2 : Genv.find_var_info ge b2 = Some gv2) : b2 = b1 -> gvar_volatile gv2 = false.","conclusion":"b2 = b1 -> gvar_volatile gv2 = false","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b3 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b3 = Some gv -> f b0 = Some (b3, delta0) -> b3 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 b2 : block) (delta : Z) (H : f b1 = Some (b2, delta)) (V1 : Genv.find_var_info ge b1 = None) (gv2 : globvar V) (V2 : Genv.find_var_info ge b2 = Some gv2)","proofString":"intros EQ; subst b2.\ncongruence."},{"statement":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b2 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b2 = Some gv -> f b0 = Some (b2, delta0) -> b2 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 : block) (delta : Z) (H : f b1 = Some (b1, delta)) (V1 : Genv.find_var_info ge b1 = None) (gv2 : globvar V) (V2 : Genv.find_var_info ge b1 = Some gv2) : gvar_volatile gv2 = false.","conclusion":"gvar_volatile gv2 = false","hypotheses":"(ef : external_function) (F : Type) (V : Type) (ge : Genv.t F V) (vargs : list val) (m1 : mem) (t : trace) (vres : val) (m2 : mem) (f : block -> option (block * Z)) (m1' : mem) (vargs' : list val) (A : forall (id : ident) (b : block),\nGenv.find_symbol ge id = Some b -> f b = Some (b, 0)) (B : forall (b : block) (gv : globvar V),\nGenv.find_var_info ge b = Some gv -> f b = Some (b, 0)) (C : forall (b0 b2 : block) (delta0 : Z) (gv : globvar V),\nGenv.find_var_info ge b2 = Some gv -> f b0 = Some (b2, delta0) -> b2 = b0) (H0 : external_call ef ge vargs m1 t vres m2) (H1 : Mem.inject f m1 m1') (H2 : Val.inject_list f vargs vargs') (b1 : block) (delta : Z) (H : f b1 = Some (b1, delta)) (V1 : Genv.find_var_info ge b1 = None) (gv2 : globvar V) (V2 : Genv.find_var_info ge b1 = Some gv2)","proofString":"congruence."},{"statement":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : external_call ef ge vargs m t1 vres1 m1) (H0 : external_call ef ge vargs m t2 vres2 m2) : match_traces ge t1 t2.","conclusion":"match_traces ge t1 t2","hypotheses":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m : mem) (t1 : trace) (vres1 : val) (m1 : mem) (t2 : trace) (vres2 : val) (m2 : mem) (H : external_call ef ge vargs m t1 vres1 m1) (H0 : external_call ef ge vargs m t2 vres2 m2)","proofString":"exploit external_call_determ.\neexact H.\neexact H0.\ntauto."},{"statement":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres1 : val) (m1 : mem) (vres2 : val) (m2 : mem) (H : external_call ef ge vargs m t vres1 m1) (H0 : external_call ef ge vargs m t vres2 m2) : vres1 = vres2 /\\ m1 = m2.","conclusion":"vres1 = vres2 /\\ m1 = m2","hypotheses":"(ef : external_function) (ge : Senv.t) (vargs : list val) (m : mem) (t : trace) (vres1 : val) (m1 : mem) (vres2 : val) (m2 : mem) (H : external_call ef ge vargs m t vres1 m1) (H0 : external_call ef ge vargs m t vres2 m2)","proofString":"exploit external_call_determ.\neexact H.\neexact H0.\nintuition."},{"statement":"(hi lo : builtin_arg A) (vhi vlo : val) (H : eval_builtin_arg hi vhi) (H0 : eval_builtin_arg lo vlo) (IHeval_builtin_arg1 : forall v' : val, eval_builtin_arg hi v' -> v' = vhi) (IHeval_builtin_arg2 : forall v' : val, eval_builtin_arg lo v' -> v' = vlo) (vhi0 vlo0 : val) (H3 : eval_builtin_arg hi vhi0) (H5 : eval_builtin_arg lo vlo0) : Val.longofwords vhi0 vlo0 = Val.longofwords vhi vlo.","conclusion":"Val.longofwords vhi0 vlo0 = Val.longofwords vhi vlo","hypotheses":"(hi lo : builtin_arg A) (vhi vlo : val) (H : eval_builtin_arg hi vhi) (H0 : eval_builtin_arg lo vlo) (IHeval_builtin_arg1 : forall v' : val, eval_builtin_arg hi v' -> v' = vhi) (IHeval_builtin_arg2 : forall v' : val, eval_builtin_arg lo v' -> v' = vlo) (vhi0 vlo0 : val) (H3 : eval_builtin_arg hi vhi0) (H5 : eval_builtin_arg lo vlo0)","proofString":"f_equal; eauto."},{"statement":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg a1 v1) (H0 : eval_builtin_arg a2 v2) (IHeval_builtin_arg1 : forall v' : val, eval_builtin_arg a1 v' -> v' = v1) (IHeval_builtin_arg2 : forall v' : val, eval_builtin_arg a2 v' -> v' = v2) (v0 v3 : val) (H3 : eval_builtin_arg a1 v0) (H5 : eval_builtin_arg a2 v3) : (if Archi.ptr64 then Val.addl v0 v3 else Val.add v0 v3) =\n(if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2).","conclusion":"(if Archi.ptr64 then Val.addl v0 v3 else Val.add v0 v3) =\n(if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2)","hypotheses":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg a1 v1) (H0 : eval_builtin_arg a2 v2) (IHeval_builtin_arg1 : forall v' : val, eval_builtin_arg a1 v' -> v' = v1) (IHeval_builtin_arg2 : forall v' : val, eval_builtin_arg a2 v' -> v' = v2) (v0 v3 : val) (H3 : eval_builtin_arg a1 v0) (H5 : eval_builtin_arg a2 v3)","proofString":"apply IHeval_builtin_arg1 in H3.\napply IHeval_builtin_arg2 in H5.\nsubst; auto."},{"statement":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg a1 v1) (H0 : eval_builtin_arg a2 v2) (IHeval_builtin_arg1 : forall v' : val, eval_builtin_arg a1 v' -> v' = v1) (IHeval_builtin_arg2 : forall v' : val, eval_builtin_arg a2 v' -> v' = v2) (v0 v3 : val) (H3 : v0 = v1) (H5 : eval_builtin_arg a2 v3) : (if Archi.ptr64 then Val.addl v0 v3 else Val.add v0 v3) =\n(if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2).","conclusion":"(if Archi.ptr64 then Val.addl v0 v3 else Val.add v0 v3) =\n(if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2)","hypotheses":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg a1 v1) (H0 : eval_builtin_arg a2 v2) (IHeval_builtin_arg1 : forall v' : val, eval_builtin_arg a1 v' -> v' = v1) (IHeval_builtin_arg2 : forall v' : val, eval_builtin_arg a2 v' -> v' = v2) (v0 v3 : val) (H3 : v0 = v1) (H5 : eval_builtin_arg a2 v3)","proofString":"apply IHeval_builtin_arg2 in H5.\nsubst; auto."},{"statement":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg a1 v1) (H0 : eval_builtin_arg a2 v2) (IHeval_builtin_arg1 : forall v' : val, eval_builtin_arg a1 v' -> v' = v1) (IHeval_builtin_arg2 : forall v' : val, eval_builtin_arg a2 v' -> v' = v2) (v0 v3 : val) (H3 : v0 = v1) (H5 : v3 = v2) : (if Archi.ptr64 then Val.addl v0 v3 else Val.add v0 v3) =\n(if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2).","conclusion":"(if Archi.ptr64 then Val.addl v0 v3 else Val.add v0 v3) =\n(if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2)","hypotheses":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg a1 v1) (H0 : eval_builtin_arg a2 v2) (IHeval_builtin_arg1 : forall v' : val, eval_builtin_arg a1 v' -> v' = v1) (IHeval_builtin_arg2 : forall v' : val, eval_builtin_arg a2 v' -> v' = v2) (v0 v3 : val) (H3 : v0 = v1) (H5 : v3 = v2)","proofString":"subst; auto."},{"statement":"forall (id : ident) (ofs : ptrofs),\nSenv.symbol_address ge2 id ofs = Senv.symbol_address ge1 id ofs.","conclusion":"forall (id : ident) (ofs : ptrofs),\nSenv.symbol_address ge2 id ofs = Senv.symbol_address ge1 id ofs","hypotheses":"","proofString":"unfold Senv.symbol_address; simpl; intros.\nrewrite symbols_preserved; auto."},{"statement":"(id : ident) (ofs : ptrofs) : match Genv.find_symbol ge2 id with\n| Some b => Vptr b ofs\n| None => Vundef\nend =\nmatch Genv.find_symbol ge1 id with\n| Some b => Vptr b ofs\n| None => Vundef\nend.","conclusion":"match Genv.find_symbol ge2 id with\n| Some b => Vptr b ofs\n| None => Vundef\nend =\nmatch Genv.find_symbol ge1 id with\n| Some b => Vptr b ofs\n| None => Vundef\nend","hypotheses":"(id : ident) (ofs : ptrofs)","proofString":"rewrite symbols_preserved; auto."},{"statement":"(EQ : forall (id : ident) (ofs : ptrofs),\nSenv.symbol_address ge2 id ofs = Senv.symbol_address ge1 id ofs) : forall (a : builtin_arg A) (v : val),\neval_builtin_arg ge1 e sp m a v -> eval_builtin_arg ge2 e sp m a v.","conclusion":"forall (a : builtin_arg A) (v : val),\neval_builtin_arg ge1 e sp m a v -> eval_builtin_arg ge2 e sp m a v","hypotheses":"(EQ : forall (id : ident) (ofs : ptrofs),\nSenv.symbol_address ge2 id ofs = Senv.symbol_address ge1 id ofs)","proofString":"induction 1; eauto with barg.\nrewrite <- EQ in H; eauto with barg.\nrewrite <- EQ; eauto with barg."},{"statement":"(EQ : forall (id0 : ident) (ofs0 : ptrofs),\nSenv.symbol_address ge2 id0 ofs0 = Senv.symbol_address ge1 id0 ofs0) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge1 id ofs) = Some v) : eval_builtin_arg ge2 e sp m (BA_loadglobal chunk id ofs) v.","conclusion":"eval_builtin_arg ge2 e sp m (BA_loadglobal chunk id ofs) v","hypotheses":"(EQ : forall (id0 : ident) (ofs0 : ptrofs),\nSenv.symbol_address ge2 id0 ofs0 = Senv.symbol_address ge1 id0 ofs0) (chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m (Senv.symbol_address ge1 id ofs) = Some v)","proofString":"rewrite <- EQ in H; eauto with barg."},{"statement":"(EQ : forall (id0 : ident) (ofs0 : ptrofs),\nSenv.symbol_address ge2 id0 ofs0 = Senv.symbol_address ge1 id0 ofs0) (id : ident) (ofs : ptrofs) : eval_builtin_arg ge2 e sp m (BA_addrglobal id ofs)\n  (Senv.symbol_address ge1 id ofs).","conclusion":"eval_builtin_arg ge2 e sp m (BA_addrglobal id ofs)\n  (Senv.symbol_address ge1 id ofs)","hypotheses":"(EQ : forall (id0 : ident) (ofs0 : ptrofs),\nSenv.symbol_address ge2 id0 ofs0 = Senv.symbol_address ge1 id0 ofs0) (id : ident) (ofs : ptrofs)","proofString":"rewrite <- EQ; eauto with barg."},{"statement":"(x : A) : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA x) v2 /\\ Val.lessdef (e1 x) v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA x) v2 /\\ Val.lessdef (e1 x) v2","hypotheses":"(x : A)","proofString":"exists (e2 x); auto with barg."},{"statement":"(n : int) : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_int n) v2 /\\ Val.lessdef (Vint n) v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_int n) v2 /\\ Val.lessdef (Vint n) v2","hypotheses":"(n : int)","proofString":"econstructor; eauto with barg."},{"statement":"(n : int64) : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_long n) v2 /\\ Val.lessdef (Vlong n) v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_long n) v2 /\\ Val.lessdef (Vlong n) v2","hypotheses":"(n : int64)","proofString":"econstructor; eauto with barg."},{"statement":"(n : float) : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_float n) v2 /\\ Val.lessdef (Vfloat n) v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_float n) v2 /\\ Val.lessdef (Vfloat n) v2","hypotheses":"(n : float)","proofString":"econstructor; eauto with barg."},{"statement":"(n : float32) : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_single n) v2 /\\ Val.lessdef (Vsingle n) v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_single n) v2 /\\ Val.lessdef (Vsingle n) v2","hypotheses":"(n : float32)","proofString":"econstructor; eauto with barg."},{"statement":"(chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m1 (Val.offset_ptr sp ofs) = Some v) : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_loadstack chunk ofs) v2 /\\\n  Val.lessdef v v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_loadstack chunk ofs) v2 /\\\n  Val.lessdef v v2","hypotheses":"(chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m1 (Val.offset_ptr sp ofs) = Some v)","proofString":"exploit Mem.loadv_extends; eauto.\nintros (v' & P & Q).\nexists v'; eauto with barg."},{"statement":"(chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m1 (Val.offset_ptr sp ofs) = Some v) : (exists v2 : val,\n   Mem.loadv chunk m2 (Val.offset_ptr sp ofs) = Some v2 /\\ Val.lessdef v v2) ->\nexists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_loadstack chunk ofs) v2 /\\\n  Val.lessdef v v2.","conclusion":"(exists v2 : val,\n   Mem.loadv chunk m2 (Val.offset_ptr sp ofs) = Some v2 /\\ Val.lessdef v v2) ->\nexists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_loadstack chunk ofs) v2 /\\\n  Val.lessdef v v2","hypotheses":"(chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m1 (Val.offset_ptr sp ofs) = Some v)","proofString":"intros (v' & P & Q).\nexists v'; eauto with barg."},{"statement":"(chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m1 (Val.offset_ptr sp ofs) = Some v) (v' : val) (P : Mem.loadv chunk m2 (Val.offset_ptr sp ofs) = Some v') (Q : Val.lessdef v v') : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_loadstack chunk ofs) v2 /\\\n  Val.lessdef v v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_loadstack chunk ofs) v2 /\\\n  Val.lessdef v v2","hypotheses":"(chunk : memory_chunk) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m1 (Val.offset_ptr sp ofs) = Some v) (v' : val) (P : Mem.loadv chunk m2 (Val.offset_ptr sp ofs) = Some v') (Q : Val.lessdef v v')","proofString":"exists v'; eauto with barg."},{"statement":"(ofs : ptrofs) : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_addrstack ofs) v2 /\\\n  Val.lessdef (Val.offset_ptr sp ofs) v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_addrstack ofs) v2 /\\\n  Val.lessdef (Val.offset_ptr sp ofs) v2","hypotheses":"(ofs : ptrofs)","proofString":"econstructor; eauto with barg."},{"statement":"(chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m1 (Senv.symbol_address ge id ofs) = Some v) : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_loadglobal chunk id ofs) v2 /\\\n  Val.lessdef v v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_loadglobal chunk id ofs) v2 /\\\n  Val.lessdef v v2","hypotheses":"(chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m1 (Senv.symbol_address ge id ofs) = Some v)","proofString":"exploit Mem.loadv_extends; eauto.\nintros (v' & P & Q).\nexists v'; eauto with barg."},{"statement":"(chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m1 (Senv.symbol_address ge id ofs) = Some v) : (exists v2 : val,\n   Mem.loadv chunk m2 (Senv.symbol_address ge id ofs) = Some v2 /\\\n   Val.lessdef v v2) ->\nexists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_loadglobal chunk id ofs) v2 /\\\n  Val.lessdef v v2.","conclusion":"(exists v2 : val,\n   Mem.loadv chunk m2 (Senv.symbol_address ge id ofs) = Some v2 /\\\n   Val.lessdef v v2) ->\nexists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_loadglobal chunk id ofs) v2 /\\\n  Val.lessdef v v2","hypotheses":"(chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m1 (Senv.symbol_address ge id ofs) = Some v)","proofString":"intros (v' & P & Q).\nexists v'; eauto with barg."},{"statement":"(chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m1 (Senv.symbol_address ge id ofs) = Some v) (v' : val) (P : Mem.loadv chunk m2 (Senv.symbol_address ge id ofs) = Some v') (Q : Val.lessdef v v') : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_loadglobal chunk id ofs) v2 /\\\n  Val.lessdef v v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_loadglobal chunk id ofs) v2 /\\\n  Val.lessdef v v2","hypotheses":"(chunk : memory_chunk) (id : ident) (ofs : ptrofs) (v : val) (H : Mem.loadv chunk m1 (Senv.symbol_address ge id ofs) = Some v) (v' : val) (P : Mem.loadv chunk m2 (Senv.symbol_address ge id ofs) = Some v') (Q : Val.lessdef v v')","proofString":"exists v'; eauto with barg."},{"statement":"(id : ident) (ofs : ptrofs) : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_addrglobal id ofs) v2 /\\\n  Val.lessdef (Senv.symbol_address ge id ofs) v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_addrglobal id ofs) v2 /\\\n  Val.lessdef (Senv.symbol_address ge id ofs) v2","hypotheses":"(id : ident) (ofs : ptrofs)","proofString":"econstructor; eauto with barg."},{"statement":"(hi lo : builtin_arg A) (vhi vlo : val) (H : eval_builtin_arg ge e1 sp m1 hi vhi) (H0 : eval_builtin_arg ge e1 sp m1 lo vlo) (IHeval_builtin_arg1 : exists v2 : val, eval_builtin_arg ge e2 sp m2 hi v2 /\\ Val.lessdef vhi v2) (IHeval_builtin_arg2 : exists v2 : val, eval_builtin_arg ge e2 sp m2 lo v2 /\\ Val.lessdef vlo v2) : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_splitlong hi lo) v2 /\\\n  Val.lessdef (Val.longofwords vhi vlo) v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_splitlong hi lo) v2 /\\\n  Val.lessdef (Val.longofwords vhi vlo) v2","hypotheses":"(hi lo : builtin_arg A) (vhi vlo : val) (H : eval_builtin_arg ge e1 sp m1 hi vhi) (H0 : eval_builtin_arg ge e1 sp m1 lo vlo) (IHeval_builtin_arg1 : exists v2 : val, eval_builtin_arg ge e2 sp m2 hi v2 /\\ Val.lessdef vhi v2) (IHeval_builtin_arg2 : exists v2 : val, eval_builtin_arg ge e2 sp m2 lo v2 /\\ Val.lessdef vlo v2)","proofString":"destruct IHeval_builtin_arg1 as (vhi' & P & Q).\ndestruct IHeval_builtin_arg2 as (vlo' & R & S).\neconstructor; split; eauto with barg.\napply Val.longofwords_lessdef; auto."},{"statement":"(hi lo : builtin_arg A) (vhi vlo : val) (H : eval_builtin_arg ge e1 sp m1 hi vhi) (H0 : eval_builtin_arg ge e1 sp m1 lo vlo) (vhi' : val) (P : eval_builtin_arg ge e2 sp m2 hi vhi') (Q : Val.lessdef vhi vhi') (IHeval_builtin_arg2 : exists v2 : val, eval_builtin_arg ge e2 sp m2 lo v2 /\\ Val.lessdef vlo v2) : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_splitlong hi lo) v2 /\\\n  Val.lessdef (Val.longofwords vhi vlo) v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_splitlong hi lo) v2 /\\\n  Val.lessdef (Val.longofwords vhi vlo) v2","hypotheses":"(hi lo : builtin_arg A) (vhi vlo : val) (H : eval_builtin_arg ge e1 sp m1 hi vhi) (H0 : eval_builtin_arg ge e1 sp m1 lo vlo) (vhi' : val) (P : eval_builtin_arg ge e2 sp m2 hi vhi') (Q : Val.lessdef vhi vhi') (IHeval_builtin_arg2 : exists v2 : val, eval_builtin_arg ge e2 sp m2 lo v2 /\\ Val.lessdef vlo v2)","proofString":"destruct IHeval_builtin_arg2 as (vlo' & R & S).\neconstructor; split; eauto with barg.\napply Val.longofwords_lessdef; auto."},{"statement":"(hi lo : builtin_arg A) (vhi vlo : val) (H : eval_builtin_arg ge e1 sp m1 hi vhi) (H0 : eval_builtin_arg ge e1 sp m1 lo vlo) (vhi' : val) (P : eval_builtin_arg ge e2 sp m2 hi vhi') (Q : Val.lessdef vhi vhi') (vlo' : val) (R : eval_builtin_arg ge e2 sp m2 lo vlo') (S : Val.lessdef vlo vlo') : exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_splitlong hi lo) v2 /\\\n  Val.lessdef (Val.longofwords vhi vlo) v2.","conclusion":"exists v2 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_splitlong hi lo) v2 /\\\n  Val.lessdef (Val.longofwords vhi vlo) v2","hypotheses":"(hi lo : builtin_arg A) (vhi vlo : val) (H : eval_builtin_arg ge e1 sp m1 hi vhi) (H0 : eval_builtin_arg ge e1 sp m1 lo vlo) (vhi' : val) (P : eval_builtin_arg ge e2 sp m2 hi vhi') (Q : Val.lessdef vhi vhi') (vlo' : val) (R : eval_builtin_arg ge e2 sp m2 lo vlo') (S : Val.lessdef vlo vlo')","proofString":"econstructor; split; eauto with barg.\napply Val.longofwords_lessdef; auto."},{"statement":"(hi lo : builtin_arg A) (vhi vlo : val) (H : eval_builtin_arg ge e1 sp m1 hi vhi) (H0 : eval_builtin_arg ge e1 sp m1 lo vlo) (vhi' : val) (P : eval_builtin_arg ge e2 sp m2 hi vhi') (Q : Val.lessdef vhi vhi') (vlo' : val) (R : eval_builtin_arg ge e2 sp m2 lo vlo') (S : Val.lessdef vlo vlo') : Val.lessdef (Val.longofwords vhi vlo) (Val.longofwords vhi' vlo').","conclusion":"Val.lessdef (Val.longofwords vhi vlo) (Val.longofwords vhi' vlo')","hypotheses":"(hi lo : builtin_arg A) (vhi vlo : val) (H : eval_builtin_arg ge e1 sp m1 hi vhi) (H0 : eval_builtin_arg ge e1 sp m1 lo vlo) (vhi' : val) (P : eval_builtin_arg ge e2 sp m2 hi vhi') (Q : Val.lessdef vhi vhi') (vlo' : val) (R : eval_builtin_arg ge e2 sp m2 lo vlo') (S : Val.lessdef vlo vlo')","proofString":"apply Val.longofwords_lessdef; auto."},{"statement":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg ge e1 sp m1 a1 v1) (H0 : eval_builtin_arg ge e1 sp m1 a2 v2) (IHeval_builtin_arg1 : exists v0 : val, eval_builtin_arg ge e2 sp m2 a1 v0 /\\ Val.lessdef v1 v0) (IHeval_builtin_arg2 : exists v0 : val, eval_builtin_arg ge e2 sp m2 a2 v0 /\\ Val.lessdef v2 v0) : exists v0 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_addptr a1 a2) v0 /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v0.","conclusion":"exists v0 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_addptr a1 a2) v0 /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v0","hypotheses":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg ge e1 sp m1 a1 v1) (H0 : eval_builtin_arg ge e1 sp m1 a2 v2) (IHeval_builtin_arg1 : exists v0 : val, eval_builtin_arg ge e2 sp m2 a1 v0 /\\ Val.lessdef v1 v0) (IHeval_builtin_arg2 : exists v0 : val, eval_builtin_arg ge e2 sp m2 a2 v0 /\\ Val.lessdef v2 v0)","proofString":"destruct IHeval_builtin_arg1 as (vhi' & P & Q).\ndestruct IHeval_builtin_arg2 as (vlo' & R & S).\neconstructor; split; eauto with barg.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg ge e1 sp m1 a1 v1) (H0 : eval_builtin_arg ge e1 sp m1 a2 v2) (vhi' : val) (P : eval_builtin_arg ge e2 sp m2 a1 vhi') (Q : Val.lessdef v1 vhi') (IHeval_builtin_arg2 : exists v0 : val, eval_builtin_arg ge e2 sp m2 a2 v0 /\\ Val.lessdef v2 v0) : exists v0 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_addptr a1 a2) v0 /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v0.","conclusion":"exists v0 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_addptr a1 a2) v0 /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v0","hypotheses":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg ge e1 sp m1 a1 v1) (H0 : eval_builtin_arg ge e1 sp m1 a2 v2) (vhi' : val) (P : eval_builtin_arg ge e2 sp m2 a1 vhi') (Q : Val.lessdef v1 vhi') (IHeval_builtin_arg2 : exists v0 : val, eval_builtin_arg ge e2 sp m2 a2 v0 /\\ Val.lessdef v2 v0)","proofString":"destruct IHeval_builtin_arg2 as (vlo' & R & S).\neconstructor; split; eauto with barg.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg ge e1 sp m1 a1 v1) (H0 : eval_builtin_arg ge e1 sp m1 a2 v2) (vhi' : val) (P : eval_builtin_arg ge e2 sp m2 a1 vhi') (Q : Val.lessdef v1 vhi') (vlo' : val) (R : eval_builtin_arg ge e2 sp m2 a2 vlo') (S : Val.lessdef v2 vlo') : exists v0 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_addptr a1 a2) v0 /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v0.","conclusion":"exists v0 : val,\n  eval_builtin_arg ge e2 sp m2 (BA_addptr a1 a2) v0 /\\\n  Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2) v0","hypotheses":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg ge e1 sp m1 a1 v1) (H0 : eval_builtin_arg ge e1 sp m1 a2 v2) (vhi' : val) (P : eval_builtin_arg ge e2 sp m2 a1 vhi') (Q : Val.lessdef v1 vhi') (vlo' : val) (R : eval_builtin_arg ge e2 sp m2 a2 vlo') (S : Val.lessdef v2 vlo')","proofString":"econstructor; split; eauto with barg.\ndestruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg ge e1 sp m1 a1 v1) (H0 : eval_builtin_arg ge e1 sp m1 a2 v2) (vhi' : val) (P : eval_builtin_arg ge e2 sp m2 a1 vhi') (Q : Val.lessdef v1 vhi') (vlo' : val) (R : eval_builtin_arg ge e2 sp m2 a2 vlo') (S : Val.lessdef v2 vlo') : Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2)\n  (if Archi.ptr64 then Val.addl vhi' vlo' else Val.add vhi' vlo').","conclusion":"Val.lessdef (if Archi.ptr64 then Val.addl v1 v2 else Val.add v1 v2)\n  (if Archi.ptr64 then Val.addl vhi' vlo' else Val.add vhi' vlo')","hypotheses":"(a1 a2 : builtin_arg A) (v1 v2 : val) (H : eval_builtin_arg ge e1 sp m1 a1 v1) (H0 : eval_builtin_arg ge e1 sp m1 a2 v2) (vhi' : val) (P : eval_builtin_arg ge e2 sp m2 a1 vhi') (Q : Val.lessdef v1 vhi') (vlo' : val) (R : eval_builtin_arg ge e2 sp m2 a2 vlo') (S : Val.lessdef v2 vlo')","proofString":"destruct Archi.ptr64; auto using Val.add_lessdef, Val.addl_lessdef."},{"statement":"exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 nil vl2 /\\ Val.lessdef_list nil vl2.","conclusion":"exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 nil vl2 /\\ Val.lessdef_list nil vl2","hypotheses":"","proofString":"econstructor; split.\nconstructor.\nauto."},{"statement":"(a1 : builtin_arg A) (al : list (builtin_arg A)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge e1 sp m1 a1 b1) (H0 : list_forall2 (eval_builtin_arg ge e1 sp m1) al bl) (IHlist_forall2 : exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 al vl2 /\\ Val.lessdef_list bl vl2) : exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 (a1 :: al) vl2 /\\\n  Val.lessdef_list (b1 :: bl) vl2.","conclusion":"exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 (a1 :: al) vl2 /\\\n  Val.lessdef_list (b1 :: bl) vl2","hypotheses":"(a1 : builtin_arg A) (al : list (builtin_arg A)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge e1 sp m1 a1 b1) (H0 : list_forall2 (eval_builtin_arg ge e1 sp m1) al bl) (IHlist_forall2 : exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 al vl2 /\\ Val.lessdef_list bl vl2)","proofString":"exploit eval_builtin_arg_lessdef; eauto.\nintros (v1' & P & Q).\ndestruct IHlist_forall2 as (vl' & U & V).\nexists (v1'::vl'); split; constructor; auto."},{"statement":"(a1 : builtin_arg A) (al : list (builtin_arg A)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge e1 sp m1 a1 b1) (H0 : list_forall2 (eval_builtin_arg ge e1 sp m1) al bl) (IHlist_forall2 : exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 al vl2 /\\ Val.lessdef_list bl vl2) : (exists v2 : val, eval_builtin_arg ge e2 sp m2 a1 v2 /\\ Val.lessdef b1 v2) ->\nexists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 (a1 :: al) vl2 /\\\n  Val.lessdef_list (b1 :: bl) vl2.","conclusion":"(exists v2 : val, eval_builtin_arg ge e2 sp m2 a1 v2 /\\ Val.lessdef b1 v2) ->\nexists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 (a1 :: al) vl2 /\\\n  Val.lessdef_list (b1 :: bl) vl2","hypotheses":"(a1 : builtin_arg A) (al : list (builtin_arg A)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge e1 sp m1 a1 b1) (H0 : list_forall2 (eval_builtin_arg ge e1 sp m1) al bl) (IHlist_forall2 : exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 al vl2 /\\ Val.lessdef_list bl vl2)","proofString":"intros (v1' & P & Q).\ndestruct IHlist_forall2 as (vl' & U & V).\nexists (v1'::vl'); split; constructor; auto."},{"statement":"(a1 : builtin_arg A) (al : list (builtin_arg A)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge e1 sp m1 a1 b1) (H0 : list_forall2 (eval_builtin_arg ge e1 sp m1) al bl) (IHlist_forall2 : exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 al vl2 /\\ Val.lessdef_list bl vl2) (v1' : val) (P : eval_builtin_arg ge e2 sp m2 a1 v1') (Q : Val.lessdef b1 v1') : exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 (a1 :: al) vl2 /\\\n  Val.lessdef_list (b1 :: bl) vl2.","conclusion":"exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 (a1 :: al) vl2 /\\\n  Val.lessdef_list (b1 :: bl) vl2","hypotheses":"(a1 : builtin_arg A) (al : list (builtin_arg A)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge e1 sp m1 a1 b1) (H0 : list_forall2 (eval_builtin_arg ge e1 sp m1) al bl) (IHlist_forall2 : exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 al vl2 /\\ Val.lessdef_list bl vl2) (v1' : val) (P : eval_builtin_arg ge e2 sp m2 a1 v1') (Q : Val.lessdef b1 v1')","proofString":"destruct IHlist_forall2 as (vl' & U & V).\nexists (v1'::vl'); split; constructor; auto."},{"statement":"(a1 : builtin_arg A) (al : list (builtin_arg A)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge e1 sp m1 a1 b1) (H0 : list_forall2 (eval_builtin_arg ge e1 sp m1) al bl) (vl' : list val) (U : eval_builtin_args ge e2 sp m2 al vl') (V : Val.lessdef_list bl vl') (v1' : val) (P : eval_builtin_arg ge e2 sp m2 a1 v1') (Q : Val.lessdef b1 v1') : exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 (a1 :: al) vl2 /\\\n  Val.lessdef_list (b1 :: bl) vl2.","conclusion":"exists vl2 : list val,\n  eval_builtin_args ge e2 sp m2 (a1 :: al) vl2 /\\\n  Val.lessdef_list (b1 :: bl) vl2","hypotheses":"(a1 : builtin_arg A) (al : list (builtin_arg A)) (b1 : val) (bl : list val) (H : eval_builtin_arg ge e1 sp m1 a1 b1) (H0 : list_forall2 (eval_builtin_arg ge e1 sp m1) al bl) (vl' : list val) (U : eval_builtin_args ge e2 sp m2 al vl') (V : Val.lessdef_list bl vl') (v1' : val) (P : eval_builtin_arg ge e2 sp m2 a1 v1') (Q : Val.lessdef b1 v1')","proofString":"exists (v1'::vl'); split; constructor; auto."}]}