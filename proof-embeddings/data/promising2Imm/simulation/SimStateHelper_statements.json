{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/promising2ToImm/src/simulation/SimStateHelper.v","fileSamples":[{"statement":"(e : actid) (state : ProgToExecution.state) (state' : Language.state (thread_lts (tid e))) (T : trav_label -> Prop) (smode : sim_mode) (GPC : wf_thread_state (tid e) state) (NEXT : next G (covered T) e) (TCOH : tls_coherent G T) (PCOV : forall index : nat,\ncovered T (ThreadEvent (tid e) index) <-> index < eindex state) (SSH : sim_state_helper G smode state state') : e = ThreadEvent (tid e) (eindex state).","proofString":"cdes SSH.\neapply next_event_representation; eauto.\nred.\nsplits; eauto."},{"statement":"(e : actid) (state : ProgToExecution.state) (state' : Language.state (thread_lts (tid e))) (T : trav_label -> Prop) (smode : sim_mode) (GPC : wf_thread_state (tid e) state) (NEXT : next G (covered T) e) (TCOH : tls_coherent G T) (PCOV : forall index : nat,\ncovered T (ThreadEvent (tid e) index) <-> index < eindex state) (SSH : sim_state_helper G smode state state') (STEPS : (step (tid e))＊ state state') (TERMINAL : smode = sim_normal -> is_terminal state') (TEH : thread_restricted_execution G (tid e) (ProgToExecution.G state')) : e = ThreadEvent (tid e) (eindex state).","proofString":"eapply next_event_representation; eauto.\nred.\nsplits; eauto."},{"statement":"(e : actid) (state : ProgToExecution.state) (state' : Language.state (thread_lts (tid e))) (T : trav_label -> Prop) (smode : sim_mode) (GPC : wf_thread_state (tid (ThreadEvent (tid e) (eindex state))) state) (NEXT : next G (covered T) (ThreadEvent (tid e) (eindex state))) (TCOH : tls_coherent G T) (PCOV : forall index : nat,\ncovered T (ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) index) <->\nindex < eindex state) (SSH : sim_state_helper G smode state state') (HH : e = ThreadEvent (tid e) (eindex state)) : E (ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (eindex state)).","proofString":"apply NEXT."},{"statement":"(e : actid) (state : ProgToExecution.state) (state' : Language.state (thread_lts (tid e))) (T : trav_label -> Prop) (smode : sim_mode) (GPC : wf_thread_state (tid (ThreadEvent (tid e) (eindex state))) state) (NEXT : next G (covered T) (ThreadEvent (tid e) (eindex state))) (TCOH : tls_coherent G T) (PCOV : forall index : nat,\ncovered T (ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) index) <->\nindex < eindex state) (SSH : sim_state_helper G smode state state') (HH : e = ThreadEvent (tid e) (eindex state)) (ev : ProgramEvent.t) (state'' state''' : ProgToExecution.state) (ESTEPS : (lts_step (tid (ThreadEvent (tid e) (eindex state))) ProgramEvent.silent)＊\n  state state'') (STEP : lts_step (tid (ThreadEvent (tid e) (eindex state))) ev state'' state''') (SAME_NRMW : ~\ndom_rel rmw\n  (ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (eindex state)) ->\nsame_g_events lab\n  [ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (eindex state)] ev) (SAME_RMW : dom_rel rmw\n  (ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (eindex state)) ->\nsame_g_events lab\n  [ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (1 + eindex state);\n   ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (eindex state)] ev) (INDEX_NRMW : ~\ndom_rel rmw\n  (ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (eindex state)) ->\neindex state''' = 1 + eindex state) (INDEX_RMW : dom_rel rmw\n  (ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (eindex state)) ->\neindex state''' = 2 + eindex state) (SSH0 : sim_state_helper G smode state''' state') (YY : forall w : actid, rmw e w -> w = ThreadEvent (tid e) (S (eindex state))) : (step (tid (ThreadEvent (tid e) (eindex state))))＊ state state''.","proofString":"simpls.\nassert (lts_step (tid e) ProgramEvent.silent ⊆ step (tid e)) as XX.\nunfold lts_step, step.\nbasic_solver.\nclear -XX ESTEPS.\neapply clos_refl_trans_mori in XX.\nby apply XX."},{"statement":"(e : actid) (state state'' : ProgToExecution.state) (ESTEPS : (lts_step (tid e) ProgramEvent.silent)＊ state state'') (XX : lts_step (tid e) ProgramEvent.silent ⊆ step (tid e)) : (step (tid e))＊ state state''.","proofString":"eapply clos_refl_trans_mori in XX.\nby apply XX."},{"statement":"(e : actid) (state state'' : ProgToExecution.state) (ESTEPS : (lts_step (tid e) ProgramEvent.silent)＊ state state'') (XX : (lts_step (tid e) ProgramEvent.silent)＊ ⊆ (step (tid e))＊) : (step (tid e))＊ state state''.","proofString":"by apply XX."},{"statement":"(e : actid) (state : ProgToExecution.state) (state' : Language.state (thread_lts (tid e))) (T : trav_label -> Prop) (smode : sim_mode) (GPC : wf_thread_state (tid (ThreadEvent (tid e) (eindex state))) state) (NEXT : next G (covered T) (ThreadEvent (tid e) (eindex state))) (TCOH : tls_coherent G T) (PCOV : forall index : nat,\ncovered T (ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) index) <->\nindex < eindex state) (SSH : sim_state_helper G smode state state') (HH : e = ThreadEvent (tid e) (eindex state)) (ev : ProgramEvent.t) (state'' state''' : ProgToExecution.state) (ESTEPS : (lts_step (tid (ThreadEvent (tid e) (eindex state))) ProgramEvent.silent)＊\n  state state'') (STEP : lts_step (tid (ThreadEvent (tid e) (eindex state))) ev state'' state''') (SAME_NRMW : ~\ndom_rel rmw\n  (ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (eindex state)) ->\nsame_g_events lab\n  [ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (eindex state)] ev) (SAME_RMW : dom_rel rmw\n  (ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (eindex state)) ->\nsame_g_events lab\n  [ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (1 + eindex state);\n   ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (eindex state)] ev) (INDEX_NRMW : ~\ndom_rel rmw\n  (ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (eindex state)) ->\neindex state''' = 1 + eindex state) (INDEX_RMW : dom_rel rmw\n  (ThreadEvent (tid (ThreadEvent (tid e) (eindex state))) (eindex state)) ->\neindex state''' = 2 + eindex state) (SSH0 : sim_state_helper G smode state''' state') (YY : forall w : actid, rmw e w -> w = ThreadEvent (tid e) (S (eindex state))) : forall w : actid,\nrmw (ThreadEvent (tid e) (eindex state)) w ->\neindex state''' = 2 + eindex state.","proofString":"ins.\nrewrite HH in YY.\napply INDEX_RMW.\neexists.\neauto."}]}