[{"statement":"Lemma mode_split (S: actid -> Prop) (HASLOC: forall x, S x -> exists l, loc x = Some l):\n  S ≡₁ (S ∩₁ NA) ∪₁ (S ∩₁ AT).","proof":"red.\nsplit; [| basic_solver].\nrewrite <- set_inter_union_r.\napply set_subset_inter_r.\nsplit; [basic_solver| ].\nred.\nintros x Sx.\nred.\nspecialize (HASLOC x).\napply HASLOC in Sx.\ndestruct Sx as [l Lx].\nspecialize (LOCMODE l).\ndestruct LOCMODE; specialize (H x); auto.\n"},{"statement":"Lemma sb_f_helper T M (TF: T ⊆₁ codom_rel (⦗F ∩₁ M⦘ ⨾ immediate sb)):\n  ⦗RW⦘ ⨾ sb ⨾ ⦗T⦘ ⊆ ⦗RW⦘ ⨾ sb ⨾ ⦗F ∩₁ M⦘ ⨾ sb ⨾ ⦗T⦘.","proof":"unfolder.\nintros e a H.\ndestruct H as [RWe [SBew Ta]].\nsplit; auto.\nred in TF.\nspecialize (@TF a).\npose proof (TF Ta) as [f HH].\napply seq_eqv_l in HH.\ndestruct HH as [[Ff Mf] [SBfw IMMfw]].\nexists f.\nassert (NIf: NInit f).\n{\nspecialize (read_or_fence_is_not_init WF).\nintros RFNI.\nspecialize (RFNI f).\nbasic_solver 10.\n}\nassert (NEQef: e <> f).\n{\ndestruct RWe; red; intros; type_solver.\n}\nassert (SBef: sb e f).\n{\npose (sb_semi_total_r WF NIf NEQef SBew SBfw) as SB2.\ndestruct SB2; auto.\nexfalso.\nspecialize (IMMfw e).\nauto.\n}\nbasic_solver.\n"},{"statement":"Lemma sb_f_w:\n  ⦗RW⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ ⦗RW⦘ ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sb ⨾ ⦗W ∩₁ AT⦘ ∪ ⦗RW⦘ ⨾ sb ⨾ ⦗F ∩₁ Acqrel⦘ ⨾ sb ⨾ ⦗W ∩₁ NA⦘.","proof":"assert (FENCE: forall MW MF (COMP: W ∩₁ MW          ⊆₁ codom_rel (⦗F ∩₁ MF⦘ ⨾ immediate sb) ∪₁ Init),             ⦗RW⦘ ⨾ sb ⨾ ⦗W ∩₁ MW⦘ ⊆ ⦗RW⦘ ⨾ sb ⨾ ⦗F ∩₁ MF⦘ ⨾ sb ⨾ ⦗W ∩₁ MW⦘).\n{\nins.\nrewrite (no_sb_to_init G) at 3.\nrewrite seqA, <- id_inter.\nassert (TMP: NInit ∩₁ (W ∩₁ MW) ⊆₁ codom_rel (⦗F ∩₁ MF⦘ ⨾ immediate sb)).\n{\nrewrite COMP.\nrewrite set_inter_union_r.\napply set_subset_union_l.\nsplit; [basic_solver 10 | basic_solver].\n}\nrewrite (no_sb_to_init G) at 1.\nrewrite seqA, <- id_inter.\napply (sb_f_helper TMP).\n}\nrewrite (mode_split W) at 2; [| apply is_w_loc].\nrewrite (id_union (W ∩₁ NA) _).\ndo 2 rewrite seq_union_r.\nunionL; [unionR right;apply (FENCE NA Acqrel WNAF)          | unionR left; apply (FENCE AT Sc WATF1)].\n"},{"statement":"Lemma sb_rf_acyclic: acyclic (sb ⨾ rfe).","proof":"rewrite ((wf_rfeD WF)).\narewrite (R ⊆₁ RW).\nrewrite <- !seqA, acyclic_rotl, !seqA.\nsin_rewrite sb_f_w.\ncdes IC.\ncdes Cext.\narewrite (F ∩₁ Sc ⊆₁ F ∩₁ Acq/Rel) by mode_solver.\narewrite (F ∩₁ Acqrel ⊆₁ F ∩₁ Acq/Rel) by mode_solver.\nassert (FBOB: sb ⨾ ⦗F ∩₁ Acq/Rel⦘ ⨾ sb ⊆ bob ⨾ bob).\n{\nseq_rewrite <- seq_eqvK.\nrewrite seqA.\nsin_rewrite sb_to_f_in_bob.\nsin_rewrite sb_from_f_in_bob.\nbasic_solver.\n}\ndo 2 sin_rewrite FBOB.\nrewrite !inclusion_seq_eqv_r, !inclusion_seq_eqv_l.\narewrite (rfe ⊆ ar).\narewrite (bob ⊆ ar).\n{\nunfold ar, ar_int.\neauto with hahn.\n}\nrewrite unionK, seqA.\nred.\nred in Cext0.\narewrite (ar ⨾ ar ⨾ ar ⊆ ar^+).\n{\ndo 2 rewrite <- ct_unit.\nrewrite seqA.\nnow rewrite <- ct_step.\n}\nrewrite ct_of_ct.\nauto.\n"},{"statement":"Lemma sb_rfe_crt_hb: (⦗RW⦘ ⨾ sb ⨾ rfe)^* ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⊆ hb.","proof":"rewrite (dom_l (wf_rfeD WF)).\nsin_rewrite sb_f_w.\narewrite (F ∩₁ Sc ⊆₁ F ∩₁ Acqrel) by mode_solver.\ndo 2 rewrite inclusion_seq_eqv_r.\nrewrite unionK.\nrewrite inclusion_seq_eqv_l.\nrewrite !seqA.\nrewrite rtE, seq_union_l.\nunionL.\n{\nrewrite sb_in_hb.\nbasic_solver.\n}\narewrite ((sb ⨾ ⦗F ∩₁ Acqrel⦘ ⨾ sb ⨾ rfe)⁺ ⊆ sb ⨾ ⦗F ∩₁ Acqrel⦘ ⨾ (⦗F ∩₁ Acqrel⦘ ⨾ sb ⨾ rfe ⨾ sb ⨾ ⦗F ∩₁ Acqrel⦘)^* ⨾ ⦗F ∩₁ Acqrel⦘ ⨾ sb ⨾ rfe).\n{\nrewrite <- seq_eqvK at 1.\nrewrite seqA.\nrewrite <- seqA with (r2:=⦗F ∩₁ Acqrel⦘).\nrewrite ct_rotl.\nbasic_solver.\n}\narewrite ((⦗F ∩₁ Acqrel⦘ ⨾ sb ⨾ rfe ⨾ sb ⨾ ⦗F ∩₁ Acqrel⦘) ⊆ hb).\n{\nseq_rewrite (dom_l (wf_rfeD WF)).\nrewrite seqA.\narewrite (⦗F ∩₁ Acqrel⦘ ⨾ sb ⨾ ⦗W⦘ ⊆ imm_hb.release G).\n{\nunfold imm_hb.release.\narewrite (⦗W⦘ ⊆ imm_hb.rs G).\n{\nunfold imm_hb.rs.\nrewrite seq_union_r.\nunionR right.\nbasic_solver.\n}\nhahn_frame_r.\nmode_solver 10.\n}\nrewrite <- sw_in_hb.\nunfold imm_hb.sw.\nrewrite id_inter.\narewrite (Acqrel ⊆₁ Acq) by mode_solver.\narewrite ((sb ⨾ ⦗F⦘) ⊆ (sb ⨾ ⦗F⦘)^?).\nhahn_frame.\nunionR right.\nbasic_solver.\n}\nrewrite sb_in_hb.\nrewrite inclusion_seq_eqv_l.\nseq_rewrite <- ct_begin.\nsin_rewrite ct_unit.\nrewrite (ct_of_trans (@hb_trans G)).\nbasic_solver.\n"},{"statement":"Lemma sl_mode r (SL: r ⊆ same_loc):\n  ⦗RW⦘ ⨾ r ⨾ ⦗RW⦘ ⊆ restr_rel NA r ∪ restr_rel AT r.","proof":"unfolder.\nins.\ndestruct H as [RWx [RELxy RWy]].\nassert (exists l, Loc_ l x) as [l Lx].\n{\nunfold Events.loc.\nunfold is_f in *.\ndestruct (lab x) eqn:AA; simpls.\nall: eauto.\ntype_solver.\n}\nspecialize (LOCMODE l).\nred in SL.\npose proof (SL x y RELxy) as SLxy.\nred in SLxy.\nrewrite Lx in SLxy.\ndestruct LOCMODE; splits; auto.\n"},{"statement":"Lemma sb_f_at: RW ∩₁ AT ∩₁ NInit ⊆₁ codom_rel (⦗F ∩₁ Sc⦘ ⨾ immediate sb).","proof":"do 2 rewrite set_inter_union_l.\napply set_subset_union_l.\nsplit.\n{\narewrite (R ∩₁ AT ∩₁ NInit ⊆₁ R ∩₁ AT) by basic_solver.\n}\nrewrite WATF1.\nrewrite set_inter_union_l.\napply set_subset_union_l.\nsplit; [basic_solver 10 | basic_solver].\n"},{"statement":"Lemma f_sb_at: RW ∩₁ AT ∩₁ NInit  ⊆₁ dom_rel (immediate sb ⨾ ⦗F ∩₁ Sc⦘).","proof":"do 2 rewrite set_inter_union_l.\napply set_subset_union_l.\nsplit.\n{\narewrite (R ∩₁ AT ∩₁ NInit ⊆₁ R ∩₁ AT) by basic_solver.\n}\nrewrite WATF2.\nrewrite set_inter_union_l.\napply set_subset_union_l.\nsplit; [basic_solver 10 | basic_solver].\n"},{"statement":"Lemma ct_dom_start: forall (A: Type) (r: relation A) (dom: A -> Prop), \n    ⦗dom⦘ ⨾ (r ⨾ ⦗dom⦘)^+ ≡ (⦗dom⦘ ⨾ r ⨾ ⦗dom⦘)^+.","proof":"intros A r dom.\nrewrite ct_rotl.\nrewrite <- (seqA ⦗dom⦘ r ⦗dom⦘).\nrewrite ct_rotl.\nrewrite !seqA.\nseq_rewrite seq_eqvK.\nbasic_solver.\n"},{"statement":"Lemma acyclic_empty: forall (A: Type), @acyclic A ∅₂.","proof":"intros A.\nred.\nrewrite ct_of_trans; [| basic_solver].\nbasic_solver.\n"},{"statement":"Lemma sb_eco_sb_psc: ⦗F ∩₁ Sc⦘ ⨾ sb ⨾ eco ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⊆ psc G.","proof":"unfold psc.\nrewrite sb_in_hb.\nbasic_solver 10.\n"},{"statement":"Lemma RFE1: rfe^+ ≡ rfe.","proof":"apply ct_no_step.\nrewrite (wf_rfeD WF).\ntype_solver.\n"},{"statement":"Lemma no_eco_to_init: eco ≡ eco ⨾ ⦗NInit⦘.","proof":"split; [| basic_solver].\narewrite (eco ≡ eco ⨾ ⦗codom_rel eco⦘) at 1 by basic_solver.\napply seq_mori; [basic_solver|].\nrewrite (eco_alt3 WF).\ncdes IC.\nrewrite (no_rf_to_init WF), (no_co_to_init WF (coherence_sc_per_loc Cint)).\nrewrite (no_fr_to_init WF (coherence_sc_per_loc Cint)).\ndo 2 rewrite <- seq_union_l.\nrewrite inclusion_ct_seq_eqv_r.\nrewrite codom_seq.\nbasic_solver.\n"},{"statement":"Lemma acyclic_sb_rf_eco: acyclic (sb ∪ restr_rel NA rf ∪ restr_rel AT eco).","proof":"rewrite rfi_union_rfe, restr_union, <- unionA.\narewrite (restr_rel NA rfi ⊆ sb).\nrewrite unionK.\nassert (na_at_rels_empty: restr_rel NA rfe ⨾ restr_rel AT eco ≡ ∅₂).\n{\ngeneralize DIFMODE.\nbasic_solver.\n}\nrewrite unionA.\napply acyclic_union1; [apply Execution.sb_acyclic | |].\n{\ncdes IC.\ncdes Cint.\napply acyclic_union1.\n{\nrewrite inclusion_restr.\nrewrite (wf_rfeD WF).\napply acyclic_disj.\ntype_solver.\n}\n{\nrewrite inclusion_restr.\nred.\nrewrite (ct_of_trans (eco_trans WF)).\napply (eco_irr WF).\n}\nrewrite ct_end, ct_begin, seqA.\nseq_rewrite na_at_rels_empty.\nrewrite seq_false_l, seq_false_r.\napply acyclic_empty.\n}\nrewrite (ct_of_trans (@sb_trans G)).\narewrite ((restr_rel NA rfe ∪ restr_rel AT eco)⁺ ⊆ (restr_rel NA rfe)⁺ ∪ (restr_rel AT eco)⁺).\n{\nrewrite path_union.\napply union_mori; [basic_solver| ].\nrewrite rtE.\nrewrite seq_union_l.\nrewrite (ct_end (restr_rel NA rfe)) at 1.\nrewrite seqA.\nrewrite na_at_rels_empty.\nrewrite !seq_false_r, union_false_r.\nrewrite seq_id_l at 1.\nrewrite seq_union_r.\nunionL; [basic_solver| ].\nrewrite ct_end, ct_begin, seqA at 1.\nassert (restr_rel AT eco ⨾ restr_rel NA rfe ≡ ∅₂).\n{\ndo 2 rewrite restr_relE, seqA.\nseq_rewrite <- id_inter.\nrewrite DIFMODE.\nbasic_solver.\n}\nseq_rewrite H.\nbasic_solver.\n}\nrewrite seq_union_r.\napply acyclic_union1.\n{\nrewrite inclusion_restr.\nrewrite RFE1.\napply sb_rf_acyclic.\n}\n{\nrewrite restr_relE.\nrewrite inclusion_ct_seq_eqv_l, inclusion_seq_eqv_r.\nrewrite (ct_of_trans (eco_trans WF)).\nrewrite (wf_ecoD WF).\nseq_rewrite <- id_inter.\nrewrite <- seqA with (r3:=⦗RW⦘), <- seqA.\nrewrite acyclic_rotl.\nrewrite set_interC.\nrewrite no_sb_to_init, seqA.\nseq_rewrite <- id_inter.\nrewrite set_interC.\nsin_rewrite (sb_f_helper sb_f_at).\nrewrite inclusion_seq_eqv_r,  inclusion_seq_eqv_l.\nrewrite !seqA.\nrewrite <- (seq_eqvK (F ∩₁ Sc)), seqA.\nrewrite <- seqA with (r2:=⦗F ∩₁ Sc⦘).\napply acyclic_rotl.\nrewrite !seqA.\nrewrite sb_eco_sb_psc.\narewrite (psc G ⊆ ar).\ncdes IC.\ncdes Cext.\nauto.\n}\nrewrite inclusion_restr, RFE1.\nrewrite restr_relE, inclusion_seq_eqv_r.\nrewrite acyclic_rotl.\nrewrite inclusion_ct_seq_eqv_l.\nrewrite (ct_of_trans (eco_trans WF)).\nrewrite (dom_r (wf_rfeD WF)) at 1.\narewrite (R ⊆₁ RW) at 1.\nrewrite <- seqA with (r3:=⦗RW⦘).\nrewrite (@inclusion_ct_seq_eqv_r _ RW _).\nrewrite <- seqA, acyclic_rotl.\narewrite (⦗RW⦘ ⨾ (sb ⨾ ⦗AT⦘ ⨾ eco)⁺ ⊆ (⦗RW⦘ ⨾ sb ⨾ ⦗RW ∩₁ AT⦘ ⨾ eco)⁺).\n{\nrewrite (wf_ecoD WF) at 1.\nrewrite <- !seqA.\nrewrite ct_dom_start, !seqA.\napply clos_trans_mori.\nhahn_frame.\nbasic_solver.\n}\nrewrite no_sb_to_init, seqA.\nseq_rewrite <- id_inter.\nrewrite set_interC.\nsin_rewrite (sb_f_helper sb_f_at).\ndo 2 rewrite inclusion_seq_eqv_r.\nrewrite <- (seq_eqvK (F ∩₁ Sc)), !seqA.\nrewrite <- seqA with (r2:=⦗F ∩₁ Sc⦘).\nrewrite <- seqA with (r1:=⦗RW⦘).\nrewrite inclusion_seq_eqv_l.\nrewrite ct_rotl, !seqA.\nrewrite sb_eco_sb_psc.\nrewrite <- seqA.\nrewrite acyclic_rotl.\nrewrite !seqA.\narewrite (eco ⨾ (sb ⨾ rfe)⁺ ⊆ eco ⨾ (⦗RW⦘ ⨾ sb ⨾ rfe)⁺).\n{\nrewrite (dom_r (wf_ecoD WF)) at 1.\nrewrite !seqA.\nhahn_frame_l.\nrewrite (dom_r (wf_rfeD WF)) at 1.\narewrite (R ⊆₁ RW) at 2.\nrewrite <- seqA.\nrewrite ct_dom_start.\nrewrite inclusion_seq_eqv_r.\nbasic_solver.\n}\nrewrite <- (seq_eqvK (F ∩₁ Sc)) at 2.\nrewrite inclusion_t_rt.\nsin_rewrite sb_rfe_crt_hb.\narewrite ((⦗F ∩₁ Sc⦘ ⨾ sb ⨾ eco ⨾ hb ⨾ ⦗F ∩₁ Sc⦘) ⊆ psc G).\nrewrite <- ct_end.\narewrite (psc G ⊆ ar).\nred.\nrewrite ct_of_ct.\ncdes IC.\ncdes Cext.\nauto.\n"},{"statement":"Lemma imm_to_ocaml_causal:\n  acyclic (sb ∪ rfe ∪ restr_rel AT (coe ∪ fre G)).","proof":"arewrite (rfe ⊆ rf).\narewrite (rf ⊆ restr_rel NA rf ∪ restr_rel AT rf).\n{\nrewrite (wf_rfD WF) at 1.\narewrite (R ⊆₁ RW).\narewrite (W ⊆₁ RW) at 1.\nrewrite sl_mode; [basic_solver | apply (wf_rfl WF)].\n}\ndo 2 rewrite unionA.\nrewrite <- restr_union.\narewrite ((rf ∪ (coe ∪ fre G)) ⊆ eco).\n{\nunfold Execution_eco.eco, Execution.rf, Execution.coe, Execution.fre.\nbasic_solver 10.\n}\nrewrite <- unionA.\napply acyclic_sb_rf_eco.\n"},{"statement":"Lemma f_sb_helper T M (TF: T ⊆₁ dom_rel (immediate sb ⨾ ⦗F ∩₁ M⦘))\n  (NIT: T ∩₁ is_init ≡₁ ∅):\n  ⦗T⦘ ⨾ sb ⨾ ⦗RW⦘ ⊆ ⦗T⦘ ⨾ sb ⨾ ⦗F ∩₁ M⦘ ⨾ sb ⨾ ⦗RW⦘.","proof":"unfolder.\nintros a e [Ta [SBae RWe]].\nsplit; auto.\nred in TF.\nspecialize (@TF a).\npose proof (TF Ta) as [f HH].\napply seq_eqv_r in HH.\ndestruct HH as [[SBaf IMMfw] [Ff Mf]].\nexists f.\nassert (NIa: ~is_init a).\n{\nred in NIT.\ndestruct NIT as [NIT _].\nred in NIT.\nspecialize (NIT a).\nred.\nintros contra.\ndestruct NIT.\nred.\nsplit; auto.\n}\nassert (NEQef: e <> f).\n{\ndestruct RWe; red; intros; type_solver.\n}\nassert (SBfe: sb f e).\n{\npose (sb_semi_total_l WF NIa NEQef SBae SBaf) as SB2.\ndestruct SB2; auto.\nexfalso.\nspecialize (IMMfw e).\nauto.\n}\nbasic_solver.\n"},{"statement":"Lemma ac_irr: forall A (r: relation A), acyclic r <-> irreflexive r^+.","proof":"intros A r.\nbasic_solver.\n"},{"statement":"Lemma imm_to_ocaml_coherent: irreflexive ((sb ∪ ae)^+ ⨾ (co ∪ fr)).","proof":"arewrite (co ∪ fr ⊆ eco) by unfold Execution_eco.eco; basic_solver 10.\nrewrite ct_unionE.\nassert (ae_in_eco: ae ⊆ eco).\n{\nunfold Execution_eco.eco, ae.\nrewrite inclusion_seq_eqv_l, inclusion_seq_eqv_r.\nunfold Execution.rfe.\nbasic_solver 10.\n}\nrewrite seq_union_l.\napply irreflexive_union.\nsplit.\n{\nrewrite ae_in_eco.\nrewrite ct_unit.\nrewrite (ct_of_trans (eco_trans WF)).\napply (eco_irr WF).\n}\nrewrite seqA.\nrewrite irreflexive_seqC, seqA.\narewrite (eco ⨾ ae＊ ⊆ eco).\n{\nrewrite ae_in_eco.\nrewrite <- ct_begin.\napply (ct_of_trans (eco_trans WF)).\n}\nrewrite rtE, seq_union_r, seq_id_r.\nrewrite unionC, path_absorb2.\n2: {\nsin_rewrite (rewrite_trans (@sb_trans G)).\nbasic_solver.\n}\ndo 2 rewrite seq_union_l.\nrewrite unionA.\napply irreflexive_union.\nsplit.\n{\narewrite (ae ⊆ ⦗AT⦘ ⨾ eco ⨾ ⦗AT⦘).\n{\nunfold ae, Execution_eco.eco, Execution.rfe.\nbasic_solver 10.\n}\nrewrite <- restr_relE.\nrewrite (ct_of_trans (transitive_restr (eco_trans WF))).\nassert (eco_sl: eco ⊆ same_loc).\n{\nrewrite (eco_alt3 WF).\nrewrite (wf_rfl WF), (wf_col WF), (wf_frl WF).\ndo 2 rewrite unionK.\napply (ct_of_trans (@same_loc_trans _ lab)).\n}\nrewrite (wf_ecoD WF) at 2.\nrewrite (sl_mode eco_sl).\nrewrite seq_union_r.\napply irreflexive_union.\nsplit.\n{\nrewrite ct_end, seqA, seqA.\narewrite (restr_rel AT eco ⨾ restr_rel NA eco ⊆ ∅₂).\n{\ndo 2 rewrite restr_relE.\ngeneralize DIFMODE.\nbasic_solver.\n}\nrewrite !seq_false_r.\nbasic_solver.\n}\nrewrite ct_rotl, !seqA.\nrewrite (rewrite_trans (transitive_restr (eco_trans WF))).\nrewrite <- ct_rotl.\nrewrite <- ac_irr.\napply acyclic_seq_from_union.\narewrite (sb ∪ restr_rel AT eco ⊆ sb ∪ restr_rel NA rf ∪ restr_rel AT eco) by basic_solver 10.\napply acyclic_sb_rf_eco.\n}\nrewrite (ct_of_trans (@sb_trans G)).\napply irreflexive_union.\nsplit.\n{\nrewrite sb_in_hb.\ncdes IC.\ncdes Cint.\nauto.\n}\nrewrite (dom_r (wf_ecoD WF)), <- seqA.\nrewrite irreflexive_seqC, seqA.\narewrite (⦗RW⦘ ⨾ (sb ⨾ ae⁺)⁺ ⊆  sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ (psc G)^* ⨾ ⦗F ∩₁ Sc⦘ ⨾ sb ⨾ ae⁺).\n{\narewrite (ae⁺ ⊆ ⦗RW ∩₁ AT⦘ ⨾ ae⁺ ⨾ ⦗RW⦘) at 1.\n{\nrewrite <- inclusion_ct_seq_eqv_r, <- inclusion_ct_seq_eqv_l.\napply clos_trans_mori.\nunfold ae.\nrewrite !seqA.\nrewrite id_inter, seqA.\nseq_rewrite seq_eqvK.\nseq_rewrite (seq_eqvC (RW) (AT)).\nrewrite seqA.\nrewrite (seq_eqvC (AT) (RW)).\nhahn_frame.\nrewrite ((wf_rfeD WF)), ((wf_coD WF)) at 1.\nbasic_solver.\n}\ndo 2 rewrite <- seqA.\nrewrite ct_dom_start, seqA, seqA.\nrewrite no_sb_to_init at 1.\nrewrite seqA.\nseq_rewrite <- id_inter.\nrewrite set_interC.\nsin_rewrite (sb_f_helper sb_f_at).\ndo 2 rewrite inclusion_seq_eqv_r.\nrewrite !seqA.\nrewrite inclusion_seq_eqv_l.\nrewrite <- seq_eqvK at 1.\nrewrite seqA.\nrewrite <- seqA with (r2:=⦗F ∩₁ Sc⦘).\nrewrite ct_rotl, seqA.\nhahn_frame.\nrepeat hahn_frame_r.\napply clos_refl_trans_mori.\nrewrite ae_in_eco.\nrewrite (ct_of_trans (eco_trans WF)).\nrewrite sb_in_hb.\nunfold psc.\nbasic_solver 10.\n}\narewrite (ae⁺ ⊆ eco ⨾ ⦗RW ∩₁ AT⦘).\n{\nunfold ae.\nrewrite <- seqA, inclusion_ct_seq_eqv_r.\nrewrite id_inter.\nhahn_frame.\nrewrite inclusion_seq_eqv_l.\narewrite (rfe ∪ co ⊆ eco) by unfold Execution_eco.eco, Execution.rfe; basic_solver 10.\nrewrite (ct_of_trans (eco_trans WF)).\napply (dom_r (wf_ecoD WF)).\n}\nrewrite (dom_l (wf_ecoD WF)) at 2.\nrewrite no_eco_to_init.\nrewrite seqA.\nseq_rewrite <- id_inter.\nrewrite (set_interC _ (RW ∩₁ AT)).\nassert (NINIT: RW ∩₁ AT ∩₁ NInit ∩₁ Init ≡₁ ∅) by basic_solver.\nsin_rewrite (f_sb_helper f_sb_at NINIT).\nrewrite !seqA.\nsin_rewrite (@inclusion_seq_eqv_r _ eco _).\nrewrite <- seq_eqvK at 3.\nrewrite seqA.\narewrite (⦗RW ∩₁ AT ∩₁ NInit⦘ ⨾ sb ⊆ sb).\nsin_rewrite sb_eco_sb_psc.\nrewrite <- seqA with (r2:=psc G).\nrewrite <- seqA with (r1:=sb).\nrewrite irreflexive_seqC, !seqA.\nsin_rewrite (@inclusion_seq_eqv_l _ eco _).\nsin_rewrite sb_eco_sb_psc.\nseq_rewrite <- ct_end.\nrewrite ct_unit.\narewrite (psc G ⊆ ar).\ncdes IC.\ncdes Cext.\nauto.\n"},{"statement":"Theorem ldrf_condition_ext:\n  acyclic(sb ∪ rf ∪ ⦗F ∩₁ Sc⦘ ⨾ sb ⨾ eco ⨾ sb ⨾ ⦗F ∩₁ Sc⦘).","proof":"apply acyclic_union1.\n{\nrewrite (wf_rfD WF).\narewrite (W ⊆₁ RW).\narewrite (R ⊆₁ RW) at 2 .\nrewrite (sl_mode); [| apply (wf_rfl WF)].\nrewrite rf_in_eco at 2.\nrewrite <- unionA.\napply acyclic_sb_rf_eco.\n}\n{\nsin_rewrite sb_eco_sb_psc.\narewrite (psc G ⊆ ar).\ncdes IC.\ncdes Cext.\nauto.\n}\nrewrite rfi_union_rfe, (rfi_in_sbloc' WF), inclusion_inter_l1.\nrewrite <- unionA, unionK.\nrewrite <- seq_eqvK.\nrewrite !seqA.\nsin_rewrite sb_eco_sb_psc.\nrewrite unionC.\nrewrite path_ut2; [| apply (@sb_trans G)].\nrewrite RFE1.\narewrite (rfe^* ≡ rfe^?).\n{\nrewrite rtE, RFE1.\nbasic_solver.\n}\nrewrite <- seqA with (r3:=⦗F ∩₁ Sc⦘).\nrewrite inclusion_ct_seq_eqv_r.\nrewrite <- seqA.\nrewrite acyclic_rotl.\nseq_rewrite seq_union_r.\narewrite (⦗F ∩₁ Sc⦘ ⨾ rfe ≡ ∅₂) by rewrite (wf_rfeD WF); type_solver.\nrewrite union_false_l.\narewrite (⦗F ∩₁ Sc⦘ ⨾ rfe^? ≡ ⦗F ∩₁ Sc⦘) by rewrite (wf_rfeD WF); type_solver.\nrewrite inclusion_ct_seq_eqv_l.\narewrite (rfe^? ⨾ ⦗F ∩₁ Sc⦘ ≡ ⦗F ∩₁ Sc⦘) by rewrite (wf_rfeD WF); type_solver.\nrewrite rtE.\nrepeat case_union _ _.\narewrite (⦗F ∩₁ Sc⦘ ⨾ ⦗fun _ : actid => True⦘ ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⊆ ar).\n{\narewrite (sb ⨾ ⦗F ∩₁ Sc⦘ ⊆ bob).\n{\nunfold imm_bob.bob, imm_bob.fwbob.\narewrite (Sc ⊆₁ Acq/Rel) by mode_solver.\nbasic_solver 10.\n}\nunfold imm.ar, imm_ppo.ar_int.\nbasic_solver 10.\n}\nrewrite ct_begin with (r:=(sb ⨾ rfe)).\nrewrite !seqA.\nrewrite (dom_r (wf_rfeD WF)), seqA.\narewrite (⦗R⦘ ⨾ (sb ⨾ rfe ⨾ ⦗R⦘)＊ ⊆ (⦗RW⦘ ⨾ sb ⨾ rfe)＊).\n{\nrewrite rtE, seq_union_r.\nunionL; [basic_solver| ].\narewrite (⦗R⦘ ⊆ ⦗RW⦘).\nrewrite <- seqA, ct_dom_start.\nrewrite inclusion_seq_eqv_r.\nbasic_solver.\n}\nsin_rewrite sb_rfe_crt_hb.\narewrite (rfe ⊆ eco) by unfold Execution_eco.eco, Execution.rfe; basic_solver.\narewrite ((psc G)⁺ ⊆ ⦗F ∩₁ Sc⦘ ⨾ (psc G)⁺).\n{\nunfold psc.\nrewrite <- seq_eqvK at 1.\nrewrite seqA.\nrewrite inclusion_ct_seq_eqv_l at 1.\nbasic_solver.\n}\narewrite (⦗F ∩₁ Sc⦘ ⨾ sb ⨾ eco ⨾ hb ⨾ ⦗F ∩₁ Sc⦘ ⊆ psc G).\narewrite (psc G ⊆ ar).\nrewrite inclusion_seq_eqv_l, unionK.\nrewrite acyclic_rotl, ct_unit.\nred.\nrewrite ct_of_ct.\ncdes IC.\ncdes Cext.\nauto.\n"},{"statement":"Theorem ldrf_condition: acyclic(sb ∪ rf ∪ ⦗AT⦘ ⨾ sb ⨾ eco ⨾ sb ⨾ ⦗AT⦘).","proof":"arewrite (sb ∪ rf ∪ ⦗AT⦘ ⨾ sb ⨾ eco ⨾ sb ⨾ ⦗AT⦘ ⊆ (sb ∪ rf ∪ ⦗AT⦘ ⨾ sb ⨾ eco ⨾ sb ⨾ ⦗AT⦘) ⨾ ⦗NInit⦘).\n{\nrewrite (no_sb_to_init G) at 1.\nrewrite (no_sb_to_init G) at 3.\nrewrite (no_rf_to_init WF) at 1.\nrewrite seqA.\nrewrite seq_eqvC.\nrewrite <- !seqA.\ndo 2 rewrite <- seq_union_l.\nhahn_frame.\nbasic_solver.\n}\nrewrite acyclic_rotl, seq_union_r.\narewrite (AT ⊆₁ RW ∩₁ AT).\n{\napply set_subset_inter_r.\nsplit; auto.\ngeneralize RWMODE.\nbasic_solver.\n}\narewrite (⦗NInit⦘ ⨾ ⦗RW ∩₁ AT⦘ ⨾ sb ⨾ eco ⨾ sb ⨾ ⦗RW ∩₁ AT⦘ ⊆ ⦗RW ∩₁ AT⦘ ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sb ⨾ eco ⨾ sb ⨾ ⦗F ∩₁ Sc⦘ ⨾ sb).\n{\nseq_rewrite <- id_inter.\nrewrite set_interC.\nrewrite (wf_ecoD WF), !seqA.\nrewrite no_sb_to_init at 2.\nrewrite seqA, <- id_inter.\nrewrite (set_interC NInit _).\nrewrite (sb_f_helper sb_f_at).\nrewrite inclusion_seq_eqv_r.\ndo 5 hahn_frame_r.\nassert (ninit': (RW ∩₁ AT ∩₁ NInit) ∩₁ is_init ≡₁ ∅) by basic_solver.\nsin_rewrite (f_sb_helper f_sb_at ninit').\nhahn_frame.\nbasic_solver.\n}\ndo 2 rewrite inclusion_seq_eqv_l.\nred.\nassert (ct_spec: forall (x y z: relation actid), (x ∪ y ∪ x ⨾ z ⨾ x)⁺ ⊆ (x ∪ y ∪ z)⁺).\n{\nintros x y z.\nassert (inclusion_ext: x ∪ y ∪ x ⨾ z ⨾ x ⊆ (x ∪ y ∪ z)⁺).\n{\napply inclusion_union_l.\n{\nrewrite <- ct_step.\nbasic_solver.\n}\ndo 2 rewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| basic_solver].\napply seq_mori; [| basic_solver].\nrewrite <- ct_step.\nbasic_solver.\n}\napply inclusion_t_ind_right; [apply inclusion_ext| ].\nrewrite <- ct_ct with (r:=(x ∪ y ∪ z)) at 2.\napply seq_mori; [basic_solver | apply inclusion_ext].\n}\ndo 4 rewrite <- seqA with (r3:=sb).\nrewrite ct_spec.\napply -> ac_irr.\napply ldrf_condition_ext.\n"}]