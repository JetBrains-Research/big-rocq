{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Cminor.v","fileSamples":[{"statement":"(p : program) : receptive (semantics p).","conclusion":"receptive (semantics p)","hypotheses":"(p : program)","proofString":"constructor; simpl; intros.\nassert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).\nintros.\nsubst.\ninv H0.\nexists s1; auto.\ninversion H; subst; auto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (State f Sskip k sp (set_optvar optid vres2 e) m2).\neconstructor; eauto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (Returnstate vres2 k m2).\neconstructor; eauto.\nred; intros; inv H; simpl; try lia; eapply external_call_trace_length; eauto."},{"statement":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) : exists s2 : state, step (Genv.globalenv p) s t2 s2.","conclusion":"exists s2 : state, step (Genv.globalenv p) s t2 s2","hypotheses":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2)","proofString":"assert (t1 = E0 -> exists s2, step (Genv.globalenv p) s t2 s2).\nintros.\nsubst.\ninv H0.\nexists s1; auto.\ninversion H; subst; auto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (State f Sskip k sp (set_optvar optid vres2 e) m2).\neconstructor; eauto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (Returnstate vres2 k m2).\neconstructor; eauto."},{"statement":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) : t1 = E0 -> exists s2 : state, step (Genv.globalenv p) s t2 s2.","conclusion":"t1 = E0 -> exists s2 : state, step (Genv.globalenv p) s t2 s2","hypotheses":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2)","proofString":"intros.\nsubst.\ninv H0.\nexists s1; auto."},{"statement":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0) : exists s2 : state, step (Genv.globalenv p) s t2 s2.","conclusion":"exists s2 : state, step (Genv.globalenv p) s t2 s2","hypotheses":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0)","proofString":"subst.\ninv H0.\nexists s1; auto."},{"statement":"(p : program) (s s1 : state) (t2 : trace) (H0 : match_traces (Genv.globalenv p) E0 t2) (H : step (Genv.globalenv p) s E0 s1) : exists s2 : state, step (Genv.globalenv p) s t2 s2.","conclusion":"exists s2 : state, step (Genv.globalenv p) s t2 s2","hypotheses":"(p : program) (s s1 : state) (t2 : trace) (H0 : match_traces (Genv.globalenv p) E0 t2) (H : step (Genv.globalenv p) s E0 s1)","proofString":"inv H0.\nexists s1; auto."},{"statement":"(p : program) (s s1 : state) (H : step (Genv.globalenv p) s E0 s1) : exists s2 : state, step (Genv.globalenv p) s nil s2.","conclusion":"exists s2 : state, step (Genv.globalenv p) s nil s2","hypotheses":"(p : program) (s s1 : state) (H : step (Genv.globalenv p) s E0 s1)","proofString":"exists s1; auto."},{"statement":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 -> exists s2 : state, step (Genv.globalenv p) s t2 s2) : exists s2 : state, step (Genv.globalenv p) s t2 s2.","conclusion":"exists s2 : state, step (Genv.globalenv p) s t2 s2","hypotheses":"(p : program) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (H : step (Genv.globalenv p) s t1 s1) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 -> exists s2 : state, step (Genv.globalenv p) s t2 s2)","proofString":"inversion H; subst; auto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (State f Sskip k sp (set_optvar optid vres2 e) m2).\neconstructor; eauto.\nexploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (Returnstate vres2 k m2).\neconstructor; eauto."},{"statement":"(p : program) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t1\n  (State f Sskip k sp (set_optvar optid vres e) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2) (vargs : list val) (H2 : eval_exprlist (Genv.globalenv p) sp e m bl vargs) (H3 : external_call ef (Genv.globalenv p) vargs m t1 vres m') : exists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2.","conclusion":"exists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2","hypotheses":"(p : program) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t1\n  (State f Sskip k sp (set_optvar optid vres e) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2) (vargs : list val) (H2 : eval_exprlist (Genv.globalenv p) sp e m bl vargs) (H3 : external_call ef (Genv.globalenv p) vargs m t1 vres m')","proofString":"exploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (State f Sskip k sp (set_optvar optid vres2 e) m2).\neconstructor; eauto."},{"statement":"(p : program) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t1\n  (State f Sskip k sp (set_optvar optid vres e) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2) (vargs : list val) (H2 : eval_exprlist (Genv.globalenv p) sp e m bl vargs) (H3 : external_call ef (Genv.globalenv p) vargs m t1 vres m') : (exists (vres2 : val) (m2 : mem),\n   external_call ef (Genv.globalenv p) vargs m t2 vres2 m2) ->\nexists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2.","conclusion":"(exists (vres2 : val) (m2 : mem),\n   external_call ef (Genv.globalenv p) vargs m t2 vres2 m2) ->\nexists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2","hypotheses":"(p : program) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t1\n  (State f Sskip k sp (set_optvar optid vres e) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2) (vargs : list val) (H2 : eval_exprlist (Genv.globalenv p) sp e m bl vargs) (H3 : external_call ef (Genv.globalenv p) vargs m t1 vres m')","proofString":"intros [vres2 [m2 EC2]].\nexists (State f Sskip k sp (set_optvar optid vres2 e) m2).\neconstructor; eauto."},{"statement":"(p : program) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t1\n  (State f Sskip k sp (set_optvar optid vres e) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2) (vargs : list val) (H2 : eval_exprlist (Genv.globalenv p) sp e m bl vargs) (H3 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) vargs m t2 vres2 m2) : exists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2.","conclusion":"exists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2","hypotheses":"(p : program) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t1\n  (State f Sskip k sp (set_optvar optid vres e) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2) (vargs : list val) (H2 : eval_exprlist (Genv.globalenv p) sp e m bl vargs) (H3 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) vargs m t2 vres2 m2)","proofString":"exists (State f Sskip k sp (set_optvar optid vres2 e) m2).\neconstructor; eauto."},{"statement":"(p : program) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t1\n  (State f Sskip k sp (set_optvar optid vres e) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2) (vargs : list val) (H2 : eval_exprlist (Genv.globalenv p) sp e m bl vargs) (H3 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) vargs m t2 vres2 m2) : step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2\n  (State f Sskip k sp (set_optvar optid vres2 e) m2).","conclusion":"step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2\n  (State f Sskip k sp (set_optvar optid vres2 e) m2)","hypotheses":"(p : program) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t1\n  (State f Sskip k sp (set_optvar optid vres e) m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (State f (Sbuiltin optid ef bl) k sp e m) t2 s2) (vargs : list val) (H2 : eval_exprlist (Genv.globalenv p) sp e m bl vargs) (H3 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) vargs m t2 vres2 m2)","proofString":"econstructor; eauto."},{"statement":"(p : program) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate (External ef) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') : exists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2.","conclusion":"exists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2","hypotheses":"(p : program) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate (External ef) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m')","proofString":"exploit external_call_receptive; eauto.\nintros [vres2 [m2 EC2]].\nexists (Returnstate vres2 k m2).\neconstructor; eauto."},{"statement":"(p : program) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate (External ef) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') : (exists (vres2 : val) (m2 : mem),\n   external_call ef (Genv.globalenv p) vargs m t2 vres2 m2) ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2.","conclusion":"(exists (vres2 : val) (m2 : mem),\n   external_call ef (Genv.globalenv p) vargs m t2 vres2 m2) ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2","hypotheses":"(p : program) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate (External ef) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m')","proofString":"intros [vres2 [m2 EC2]].\nexists (Returnstate vres2 k m2).\neconstructor; eauto."},{"statement":"(p : program) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate (External ef) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) vargs m t2 vres2 m2) : exists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2.","conclusion":"exists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2","hypotheses":"(p : program) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate (External ef) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) vargs m t2 vres2 m2)","proofString":"exists (Returnstate vres2 k m2).\neconstructor; eauto."},{"statement":"(p : program) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate (External ef) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) vargs m t2 vres2 m2) : step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2\n  (Returnstate vres2 k m2).","conclusion":"step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2\n  (Returnstate vres2 k m2)","hypotheses":"(p : program) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H : step (Genv.globalenv p) (Callstate (External ef) vargs k m) t1\n  (Returnstate vres k m')) (H0 : match_traces (Genv.globalenv p) t1 t2) (H1 : t1 = E0 ->\nexists s2 : state,\n  step (Genv.globalenv p) (Callstate (External ef) vargs k m) t2 s2) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres2 : val) (m2 : mem) (EC2 : external_call ef (Genv.globalenv p) vargs m t2 vres2 m2)","proofString":"econstructor; eauto."},{"statement":"(p : program) : single_events (semantics p).","conclusion":"single_events (semantics p)","hypotheses":"(p : program)","proofString":"red; intros; inv H; simpl; try lia; eapply external_call_trace_length; eauto."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (v' : val) (H1 : e ! id = Some v') : v' = v.","conclusion":"v' = v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (id : positive) (v : val) (H : e ! id = Some v) (v' : val) (H1 : e ! id = Some v')","proofString":"congruence."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (cst : constant) (v : val) (H : eval_constant ge sp cst = Some v) (v' : val) (H1 : eval_constant ge sp cst = Some v') : v' = v.","conclusion":"v' = v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (cst : constant) (v : val) (H : eval_constant ge sp cst = Some v) (v' : val) (H1 : eval_constant ge sp cst = Some v')","proofString":"congruence."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (op : unary_operation) (a1 : expr) (v1 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall v'0 : val, eval_expr ge sp e m a1 v'0 -> v'0 = v1) (v' v0 : val) (H3 : eval_expr ge sp e m a1 v0) (H5 : eval_unop op v0 = Some v') : v' = v.","conclusion":"v' = v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (op : unary_operation) (a1 : expr) (v1 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall v'0 : val, eval_expr ge sp e m a1 v'0 -> v'0 = v1) (v' v0 : val) (H3 : eval_expr ge sp e m a1 v0) (H5 : eval_unop op v0 = Some v')","proofString":"assert (v0 = v1) by eauto.\ncongruence."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (op : unary_operation) (a1 : expr) (v1 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall v'0 : val, eval_expr ge sp e m a1 v'0 -> v'0 = v1) (v' v0 : val) (H3 : eval_expr ge sp e m a1 v0) (H5 : eval_unop op v0 = Some v') (H1 : v0 = v1) : v' = v.","conclusion":"v' = v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (op : unary_operation) (a1 : expr) (v1 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_unop op v1 = Some v) (IHeval_expr : forall v'0 : val, eval_expr ge sp e m a1 v'0 -> v'0 = v1) (v' v0 : val) (H3 : eval_expr ge sp e m a1 v0) (H5 : eval_unop op v0 = Some v') (H1 : v0 = v1)","proofString":"congruence."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall v'0 : val, eval_expr ge sp e m a1 v'0 -> v'0 = v1) (IHeval_expr2 : forall v'0 : val, eval_expr ge sp e m a2 v'0 -> v'0 = v2) (v' v0 v3 : val) (H5 : eval_expr ge sp e m a1 v0) (H7 : eval_expr ge sp e m a2 v3) (H8 : eval_binop op v0 v3 m = Some v') : v' = v.","conclusion":"v' = v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall v'0 : val, eval_expr ge sp e m a1 v'0 -> v'0 = v1) (IHeval_expr2 : forall v'0 : val, eval_expr ge sp e m a2 v'0 -> v'0 = v2) (v' v0 v3 : val) (H5 : eval_expr ge sp e m a1 v0) (H7 : eval_expr ge sp e m a2 v3) (H8 : eval_binop op v0 v3 m = Some v')","proofString":"assert (v0 = v1) by eauto.\nassert (v3 = v2) by eauto.\ncongruence."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall v'0 : val, eval_expr ge sp e m a1 v'0 -> v'0 = v1) (IHeval_expr2 : forall v'0 : val, eval_expr ge sp e m a2 v'0 -> v'0 = v2) (v' v0 v3 : val) (H5 : eval_expr ge sp e m a1 v0) (H7 : eval_expr ge sp e m a2 v3) (H8 : eval_binop op v0 v3 m = Some v') (H2 : v0 = v1) : v' = v.","conclusion":"v' = v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall v'0 : val, eval_expr ge sp e m a1 v'0 -> v'0 = v1) (IHeval_expr2 : forall v'0 : val, eval_expr ge sp e m a2 v'0 -> v'0 = v2) (v' v0 v3 : val) (H5 : eval_expr ge sp e m a1 v0) (H7 : eval_expr ge sp e m a2 v3) (H8 : eval_binop op v0 v3 m = Some v') (H2 : v0 = v1)","proofString":"assert (v3 = v2) by eauto.\ncongruence."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall v'0 : val, eval_expr ge sp e m a1 v'0 -> v'0 = v1) (IHeval_expr2 : forall v'0 : val, eval_expr ge sp e m a2 v'0 -> v'0 = v2) (v' v0 v3 : val) (H5 : eval_expr ge sp e m a1 v0) (H7 : eval_expr ge sp e m a2 v3) (H8 : eval_binop op v0 v3 m = Some v') (H2 : v0 = v1) (H3 : v3 = v2) : v' = v.","conclusion":"v' = v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (op : binary_operation) (a1 a2 : expr) (v1 v2 v : val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_expr ge sp e m a2 v2) (H1 : eval_binop op v1 v2 m = Some v) (IHeval_expr1 : forall v'0 : val, eval_expr ge sp e m a1 v'0 -> v'0 = v1) (IHeval_expr2 : forall v'0 : val, eval_expr ge sp e m a2 v'0 -> v'0 = v2) (v' v0 v3 : val) (H5 : eval_expr ge sp e m a1 v0) (H7 : eval_expr ge sp e m a2 v3) (H8 : eval_binop op v0 v3 m = Some v') (H2 : v0 = v1) (H3 : v3 = v2)","proofString":"congruence."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (chunk : memory_chunk) (addr : expr) (vaddr v : val) (H : eval_expr ge sp e m addr vaddr) (H0 : Mem.loadv chunk m vaddr = Some v) (IHeval_expr : forall v'0 : val, eval_expr ge sp e m addr v'0 -> v'0 = vaddr) (v' vaddr0 : val) (H3 : eval_expr ge sp e m addr vaddr0) (H5 : Mem.loadv chunk m vaddr0 = Some v') : v' = v.","conclusion":"v' = v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (chunk : memory_chunk) (addr : expr) (vaddr v : val) (H : eval_expr ge sp e m addr vaddr) (H0 : Mem.loadv chunk m vaddr = Some v) (IHeval_expr : forall v'0 : val, eval_expr ge sp e m addr v'0 -> v'0 = vaddr) (v' vaddr0 : val) (H3 : eval_expr ge sp e m addr vaddr0) (H5 : Mem.loadv chunk m vaddr0 = Some v')","proofString":"assert (vaddr0 = vaddr) by eauto.\ncongruence."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (chunk : memory_chunk) (addr : expr) (vaddr v : val) (H : eval_expr ge sp e m addr vaddr) (H0 : Mem.loadv chunk m vaddr = Some v) (IHeval_expr : forall v'0 : val, eval_expr ge sp e m addr v'0 -> v'0 = vaddr) (v' vaddr0 : val) (H3 : eval_expr ge sp e m addr vaddr0) (H5 : Mem.loadv chunk m vaddr0 = Some v') (H1 : vaddr0 = vaddr) : v' = v.","conclusion":"v' = v","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (chunk : memory_chunk) (addr : expr) (vaddr v : val) (H : eval_expr ge sp e m addr vaddr) (H0 : Mem.loadv chunk m vaddr = Some v) (IHeval_expr : forall v'0 : val, eval_expr ge sp e m addr v'0 -> v'0 = vaddr) (v' vaddr0 : val) (H3 : eval_expr ge sp e m addr vaddr0) (H5 : Mem.loadv chunk m vaddr0 = Some v') (H1 : vaddr0 = vaddr)","proofString":"congruence."},{"statement":"(ge : genv) (sp : val) (e : env) (m : mem) (a1 : expr) (al : list expr) (v1 : val) (vl : list val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_exprlist ge sp e m al vl) (IHeval_exprlist : forall vl' : list val, eval_exprlist ge sp e m al vl' -> vl' = vl) (v0 : val) (vl0 : list val) (H3 : eval_expr ge sp e m a1 v0) (H5 : eval_exprlist ge sp e m al vl0) : v0 :: vl0 = v1 :: vl.","conclusion":"v0 :: vl0 = v1 :: vl","hypotheses":"(ge : genv) (sp : val) (e : env) (m : mem) (a1 : expr) (al : list expr) (v1 : val) (vl : list val) (H : eval_expr ge sp e m a1 v1) (H0 : eval_exprlist ge sp e m al vl) (IHeval_exprlist : forall vl' : list val, eval_exprlist ge sp e m al vl' -> vl' = vl) (v0 : val) (vl0 : list val) (H3 : eval_expr ge sp e m a1 v0) (H5 : eval_exprlist ge sp e m al vl0)","proofString":"f_equal; eauto using eval_expr_determ."},{"statement":"(p : program) : determinate (semantics p).","conclusion":"determinate (semantics p)","hypotheses":"(p : program)","proofString":"constructor; set (ge := Genv.globalenv p); simpl; intros.\ninv H; inv H0; Determ.\nsubst vargs0.\nexploit external_call_determ.\neexact H2.\neexact H13.\nintros (A & B).\nsplit; intros; auto.\napply B in H; destruct H; congruence.\nsubst v0.\nassert (b0 = b) by (inv H2; inv H13; auto).\nsubst b0; auto.\nassert (n0 = n) by (inv H2; inv H14; auto).\nsubst n0; auto.\nexploit external_call_determ.\neexact H1.\neexact H7.\nintros (A & B).\nsplit; intros; auto.\napply B in H; destruct H; congruence.\nred; simpl.\ndestruct 1; simpl; try lia;  eapply external_call_trace_length; eauto.\ninv H; inv H0.\nunfold ge0, ge1 in *.\ncongruence.\nred; intros; red; intros.\ninv H; inv H0.\ninv H; inv H0; auto."},{"statement":"(p : program) (ge : Genv.t fundef unit) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (s2 : state) (H : step (Genv.globalenv p) s t1 s1) (H0 : step (Genv.globalenv p) s t2 s2) : match_traces (Genv.globalenv p) t1 t2 /\\ (t1 = t2 -> s1 = s2).","conclusion":"match_traces (Genv.globalenv p) t1 t2 /\\ (t1 = t2 -> s1 = s2)","hypotheses":"(p : program) (ge : Genv.t fundef unit) (s : state) (t1 : trace) (s1 : state) (t2 : trace) (s2 : state) (H : step (Genv.globalenv p) s t1 s1) (H0 : step (Genv.globalenv p) s t2 s2)","proofString":"inv H; inv H0; Determ.\nsubst vargs0.\nexploit external_call_determ.\neexact H2.\neexact H13.\nintros (A & B).\nsplit; intros; auto.\napply B in H; destruct H; congruence.\nsubst v0.\nassert (b0 = b) by (inv H2; inv H13; auto).\nsubst b0; auto.\nassert (n0 = n) by (inv H2; inv H14; auto).\nsubst n0; auto.\nexploit external_call_determ.\neexact H1.\neexact H7.\nintros (A & B).\nsplit; intros; auto.\napply B in H; destruct H; congruence."},{"statement":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vargs0 : list val) (vres0 : val) (m'0 : mem) (H13 : external_call ef (Genv.globalenv p) vargs0 m t2 vres0 m'0) (H : vargs = vargs0) : match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State f Sskip k sp (set_optvar optid vres e) m' =\n State f Sskip k sp (set_optvar optid vres0 e) m'0).","conclusion":"match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State f Sskip k sp (set_optvar optid vres e) m' =\n State f Sskip k sp (set_optvar optid vres0 e) m'0)","hypotheses":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vargs0 : list val) (vres0 : val) (m'0 : mem) (H13 : external_call ef (Genv.globalenv p) vargs0 m t2 vres0 m'0) (H : vargs = vargs0)","proofString":"subst vargs0.\nexploit external_call_determ.\neexact H2.\neexact H13.\nintros (A & B).\nsplit; intros; auto.\napply B in H; destruct H; congruence."},{"statement":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H13 : external_call ef (Genv.globalenv p) vargs m t2 vres0 m'0) : match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State f Sskip k sp (set_optvar optid vres e) m' =\n State f Sskip k sp (set_optvar optid vres0 e) m'0).","conclusion":"match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State f Sskip k sp (set_optvar optid vres e) m' =\n State f Sskip k sp (set_optvar optid vres0 e) m'0)","hypotheses":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H13 : external_call ef (Genv.globalenv p) vargs m t2 vres0 m'0)","proofString":"exploit external_call_determ.\neexact H2.\neexact H13.\nintros (A & B).\nsplit; intros; auto.\napply B in H; destruct H; congruence."},{"statement":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H13 : external_call ef (Genv.globalenv p) vargs m t2 vres0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> vres = vres0 /\\ m' = m'0) : match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State f Sskip k sp (set_optvar optid vres e) m' =\n State f Sskip k sp (set_optvar optid vres0 e) m'0).","conclusion":"match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 ->\n State f Sskip k sp (set_optvar optid vres e) m' =\n State f Sskip k sp (set_optvar optid vres0 e) m'0)","hypotheses":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H13 : external_call ef (Genv.globalenv p) vargs m t2 vres0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> vres = vres0 /\\ m' = m'0)","proofString":"split; intros; auto.\napply B in H; destruct H; congruence."},{"statement":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H13 : external_call ef (Genv.globalenv p) vargs m t2 vres0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> vres = vres0 /\\ m' = m'0) (H : t1 = t2) : State f Sskip k sp (set_optvar optid vres e) m' =\nState f Sskip k sp (set_optvar optid vres0 e) m'0.","conclusion":"State f Sskip k sp (set_optvar optid vres e) m' =\nState f Sskip k sp (set_optvar optid vres0 e) m'0","hypotheses":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (f : function) (optid : option ident) (ef : external_function) (bl : list expr) (k : cont) (sp : val) (e : env) (m : mem) (vargs : list val) (vres : val) (m' : mem) (H2 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H13 : external_call ef (Genv.globalenv p) vargs m t2 vres0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> vres = vres0 /\\ m' = m'0) (H : t1 = t2)","proofString":"apply B in H; destruct H; congruence."},{"statement":"(p : program) (ge : Genv.t fundef unit) (f : function) (a : expr) (s0 s3 : stmt) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (b : bool) (H2 : Val.bool_of_val v b) (v0 : val) (b0 : bool) (H13 : Val.bool_of_val v0 b0) (H : v = v0) : State f (if b then s0 else s3) k sp e m =\nState f (if b0 then s0 else s3) k sp e m.","conclusion":"State f (if b then s0 else s3) k sp e m =\nState f (if b0 then s0 else s3) k sp e m","hypotheses":"(p : program) (ge : Genv.t fundef unit) (f : function) (a : expr) (s0 s3 : stmt) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (b : bool) (H2 : Val.bool_of_val v b) (v0 : val) (b0 : bool) (H13 : Val.bool_of_val v0 b0) (H : v = v0)","proofString":"subst v0.\nassert (b0 = b) by (inv H2; inv H13; auto).\nsubst b0; auto."},{"statement":"(p : program) (ge : Genv.t fundef unit) (f : function) (a : expr) (s0 s3 : stmt) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (b : bool) (H2 : Val.bool_of_val v b) (b0 : bool) (H13 : Val.bool_of_val v b0) : State f (if b then s0 else s3) k sp e m =\nState f (if b0 then s0 else s3) k sp e m.","conclusion":"State f (if b then s0 else s3) k sp e m =\nState f (if b0 then s0 else s3) k sp e m","hypotheses":"(p : program) (ge : Genv.t fundef unit) (f : function) (a : expr) (s0 s3 : stmt) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (b : bool) (H2 : Val.bool_of_val v b) (b0 : bool) (H13 : Val.bool_of_val v b0)","proofString":"assert (b0 = b) by (inv H2; inv H13; auto).\nsubst b0; auto."},{"statement":"(p : program) (ge : Genv.t fundef unit) (f : function) (a : expr) (s0 s3 : stmt) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (b : bool) (H2 : Val.bool_of_val v b) (b0 : bool) (H13 : Val.bool_of_val v b0) (H : b0 = b) : State f (if b then s0 else s3) k sp e m =\nState f (if b0 then s0 else s3) k sp e m.","conclusion":"State f (if b then s0 else s3) k sp e m =\nState f (if b0 then s0 else s3) k sp e m","hypotheses":"(p : program) (ge : Genv.t fundef unit) (f : function) (a : expr) (s0 s3 : stmt) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (b : bool) (H2 : Val.bool_of_val v b) (b0 : bool) (H13 : Val.bool_of_val v b0) (H : b0 = b)","proofString":"subst b0; auto."},{"statement":"(p : program) (ge : Genv.t fundef unit) (f : function) (islong : bool) (a : expr) (cases : list (Z * nat)) (default : nat) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (n : Z) (H2 : switch_argument islong v n) (v0 : val) (n0 : Z) (H14 : switch_argument islong v0 n0) (H : v = v0) : State f (Sexit (switch_target n default cases)) k sp e m =\nState f (Sexit (switch_target n0 default cases)) k sp e m.","conclusion":"State f (Sexit (switch_target n default cases)) k sp e m =\nState f (Sexit (switch_target n0 default cases)) k sp e m","hypotheses":"(p : program) (ge : Genv.t fundef unit) (f : function) (islong : bool) (a : expr) (cases : list (Z * nat)) (default : nat) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (n : Z) (H2 : switch_argument islong v n) (v0 : val) (n0 : Z) (H14 : switch_argument islong v0 n0) (H : v = v0)","proofString":"assert (n0 = n) by (inv H2; inv H14; auto).\nsubst n0; auto."},{"statement":"(p : program) (ge : Genv.t fundef unit) (f : function) (islong : bool) (a : expr) (cases : list (Z * nat)) (default : nat) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (n : Z) (H2 : switch_argument islong v n) (v0 : val) (n0 : Z) (H14 : switch_argument islong v0 n0) (H : v = v0) (H0 : n0 = n) : State f (Sexit (switch_target n default cases)) k sp e m =\nState f (Sexit (switch_target n0 default cases)) k sp e m.","conclusion":"State f (Sexit (switch_target n default cases)) k sp e m =\nState f (Sexit (switch_target n0 default cases)) k sp e m","hypotheses":"(p : program) (ge : Genv.t fundef unit) (f : function) (islong : bool) (a : expr) (cases : list (Z * nat)) (default : nat) (k : cont) (sp : val) (e : env) (m : mem) (v : val) (n : Z) (H2 : switch_argument islong v n) (v0 : val) (n0 : Z) (H14 : switch_argument islong v0 n0) (H : v = v0) (H0 : n0 = n)","proofString":"subst n0; auto."},{"statement":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H1 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H7 : external_call ef (Genv.globalenv p) vargs m t2 vres0 m'0) : match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 -> Returnstate vres k m' = Returnstate vres0 k m'0).","conclusion":"match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 -> Returnstate vres k m' = Returnstate vres0 k m'0)","hypotheses":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H1 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H7 : external_call ef (Genv.globalenv p) vargs m t2 vres0 m'0)","proofString":"exploit external_call_determ.\neexact H1.\neexact H7.\nintros (A & B).\nsplit; intros; auto.\napply B in H; destruct H; congruence."},{"statement":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H1 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H7 : external_call ef (Genv.globalenv p) vargs m t2 vres0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> vres = vres0 /\\ m' = m'0) : match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 -> Returnstate vres k m' = Returnstate vres0 k m'0).","conclusion":"match_traces (Genv.globalenv p) t1 t2 /\\\n(t1 = t2 -> Returnstate vres k m' = Returnstate vres0 k m'0)","hypotheses":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H1 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H7 : external_call ef (Genv.globalenv p) vargs m t2 vres0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> vres = vres0 /\\ m' = m'0)","proofString":"split; intros; auto.\napply B in H; destruct H; congruence."},{"statement":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H1 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H7 : external_call ef (Genv.globalenv p) vargs m t2 vres0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> vres = vres0 /\\ m' = m'0) (H : t1 = t2) : Returnstate vres k m' = Returnstate vres0 k m'0.","conclusion":"Returnstate vres k m' = Returnstate vres0 k m'0","hypotheses":"(p : program) (ge : Genv.t fundef unit) (t1 t2 : trace) (ef : external_function) (vargs : list val) (k : cont) (m : mem) (vres : val) (m' : mem) (H1 : external_call ef (Genv.globalenv p) vargs m t1 vres m') (vres0 : val) (m'0 : mem) (H7 : external_call ef (Genv.globalenv p) vargs m t2 vres0 m'0) (A : match_traces (Genv.globalenv p) t1 t2) (B : t1 = t2 -> vres = vres0 /\\ m' = m'0) (H : t1 = t2)","proofString":"apply B in H; destruct H; congruence."},{"statement":"(p : program) (ge : Genv.t fundef unit) : single_events (semantics p).","conclusion":"single_events (semantics p)","hypotheses":"(p : program) (ge : Genv.t fundef unit)","proofString":"red; simpl.\ndestruct 1; simpl; try lia;  eapply external_call_trace_length; eauto."},{"statement":"(p : program) (ge : Genv.t fundef unit) : forall (s : state) (t : trace) (s' : state),\nstep (Genv.globalenv p) s t s' -> (Datatypes.length t <= 1)%nat.","conclusion":"forall (s : state) (t : trace) (s' : state),\nstep (Genv.globalenv p) s t s' -> (Datatypes.length t <= 1)%nat","hypotheses":"(p : program) (ge : Genv.t fundef unit)","proofString":"destruct 1; simpl; try lia;  eapply external_call_trace_length; eauto."},{"statement":"(p : program) (ge : Genv.t fundef unit) (s1 s2 : state) (H : initial_state p s1) (H0 : initial_state p s2) : s1 = s2.","conclusion":"s1 = s2","hypotheses":"(p : program) (ge : Genv.t fundef unit) (s1 s2 : state) (H : initial_state p s1) (H0 : initial_state p s2)","proofString":"inv H; inv H0.\nunfold ge0, ge1 in *.\ncongruence."},{"statement":"(p : program) (ge : Genv.t fundef unit) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H1 : Genv.init_mem p = Some m0) (H2 : Genv.find_symbol (Genv.globalenv p) (prog_main p) = Some b) (H3 : Genv.find_funct_ptr (Genv.globalenv p) b = Some f) (H4 : funsig f = signature_main) (b0 : block) (f0 : fundef) (m1 : mem) (ge1 : Genv.t fundef unit) (H : Genv.init_mem p = Some m1) (H5 : Genv.find_symbol (Genv.globalenv p) (prog_main p) = Some b0) (H6 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some f0) (H7 : funsig f0 = signature_main) : Callstate f nil Kstop m0 = Callstate f0 nil Kstop m1.","conclusion":"Callstate f nil Kstop m0 = Callstate f0 nil Kstop m1","hypotheses":"(p : program) (ge : Genv.t fundef unit) (b : block) (f : fundef) (m0 : mem) (ge0 : Genv.t fundef unit) (H1 : Genv.init_mem p = Some m0) (H2 : Genv.find_symbol (Genv.globalenv p) (prog_main p) = Some b) (H3 : Genv.find_funct_ptr (Genv.globalenv p) b = Some f) (H4 : funsig f = signature_main) (b0 : block) (f0 : fundef) (m1 : mem) (ge1 : Genv.t fundef unit) (H : Genv.init_mem p = Some m1) (H5 : Genv.find_symbol (Genv.globalenv p) (prog_main p) = Some b0) (H6 : Genv.find_funct_ptr (Genv.globalenv p) b0 = Some f0) (H7 : funsig f0 = signature_main)","proofString":"congruence."},{"statement":"(p : program) (ge : Genv.t fundef unit) (s : state) (r : int) (H : final_state s r) : nostep step (Genv.globalenv p) s.","conclusion":"nostep step (Genv.globalenv p) s","hypotheses":"(p : program) (ge : Genv.t fundef unit) (s : state) (r : int) (H : final_state s r)","proofString":"red; intros; red; intros.\ninv H; inv H0."},{"statement":"(p : program) (ge : Genv.t fundef unit) (s : state) (r : int) (H : final_state s r) (t : trace) (s' : state) (H0 : step (Genv.globalenv p) s t s') : False.","conclusion":"False","hypotheses":"(p : program) (ge : Genv.t fundef unit) (s : state) (r : int) (H : final_state s r) (t : trace) (s' : state) (H0 : step (Genv.globalenv p) s t s')","proofString":"inv H; inv H0."},{"statement":"(p : program) (ge : Genv.t fundef unit) (s : state) (r1 r2 : int) (H : final_state s r1) (H0 : final_state s r2) : r1 = r2.","conclusion":"r1 = r2","hypotheses":"(p : program) (ge : Genv.t fundef unit) (s : state) (r1 r2 : int) (H : final_state s r1) (H0 : final_state s r2)","proofString":"inv H; inv H0; auto."},{"statement":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 : mem) (out : outcome) (vres : val) (m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2 out) (H3 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 out S) (H4 : outcome_result_value out vres) (H5 : outcome_free_mem out m2 sp (fn_stackspace f) m3) (k : cont) (H6 : is_call_cont k) : star step ge (Callstate (Internal f) vargs k m) t (Returnstate vres k m3).","conclusion":"star step ge (Callstate (Internal f) vargs k m) t (Returnstate vres k m3)","hypotheses":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 : mem) (out : outcome) (vres : val) (m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2 out) (H3 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 out S) (H4 : outcome_result_value out vres) (H5 : outcome_free_mem out m2 sp (fn_stackspace f) m3) (k : cont) (H6 : is_call_cont k)","proofString":"destruct (H3 k) as [S [A B]].\nassert (call_cont k = k) by (apply call_cont_is_call_cont; auto).\neapply star_left.\neconstructor; eauto.\neapply star_trans.\neexact A.\ninversion B; clear B; subst out; simpl in H4; simpl; try contradiction.\nsubst vres.\napply star_one.\napply step_skip_call; auto.\nsubst vres.\nreplace k with (call_cont k') by congruence.\napply star_one.\napply step_return_0; auto.\nsubst vres.\nreplace k with (call_cont k') by congruence.\napply star_one.\neapply step_return_1; eauto.\nsubst vres.\nred in H5.\nsubst m3.\nrewrite H7.\napply star_refl.\nreflexivity.\ntraceEq."},{"statement":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 : mem) (out : outcome) (vres : val) (m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2 out) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 out S0) (H4 : outcome_result_value out vres) (H5 : outcome_free_mem out m2 sp (fn_stackspace f) m3) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (B : outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k out S) : star step ge (Callstate (Internal f) vargs k m) t (Returnstate vres k m3).","conclusion":"star step ge (Callstate (Internal f) vargs k m) t (Returnstate vres k m3)","hypotheses":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 : mem) (out : outcome) (vres : val) (m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2 out) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 out S0) (H4 : outcome_result_value out vres) (H5 : outcome_free_mem out m2 sp (fn_stackspace f) m3) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (B : outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k out S)","proofString":"assert (call_cont k = k) by (apply call_cont_is_call_cont; auto).\neapply star_left.\neconstructor; eauto.\neapply star_trans.\neexact A.\ninversion B; clear B; subst out; simpl in H4; simpl; try contradiction.\nsubst vres.\napply star_one.\napply step_skip_call; auto.\nsubst vres.\nreplace k with (call_cont k') by congruence.\napply star_one.\napply step_return_0; auto.\nsubst vres.\nreplace k with (call_cont k') by congruence.\napply star_one.\neapply step_return_1; eauto.\nsubst vres.\nred in H5.\nsubst m3.\nrewrite H7.\napply star_refl.\nreflexivity.\ntraceEq."},{"statement":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 : mem) (out : outcome) (vres : val) (m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2 out) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 out S0) (H4 : outcome_result_value out vres) (H5 : outcome_free_mem out m2 sp (fn_stackspace f) m3) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (B : outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k out S) (H7 : call_cont k = k) : star step ge (Callstate (Internal f) vargs k m) t (Returnstate vres k m3).","conclusion":"star step ge (Callstate (Internal f) vargs k m) t (Returnstate vres k m3)","hypotheses":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 : mem) (out : outcome) (vres : val) (m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2 out) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 out S0) (H4 : outcome_result_value out vres) (H5 : outcome_free_mem out m2 sp (fn_stackspace f) m3) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (B : outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k out S) (H7 : call_cont k = k)","proofString":"eapply star_left.\neconstructor; eauto.\neapply star_trans.\neexact A.\ninversion B; clear B; subst out; simpl in H4; simpl; try contradiction.\nsubst vres.\napply star_one.\napply step_skip_call; auto.\nsubst vres.\nreplace k with (call_cont k') by congruence.\napply star_one.\napply step_return_0; auto.\nsubst vres.\nreplace k with (call_cont k') by congruence.\napply star_one.\neapply step_return_1; eauto.\nsubst vres.\nred in H5.\nsubst m3.\nrewrite H7.\napply star_refl.\nreflexivity.\ntraceEq."},{"statement":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (H5 : outcome_free_mem (Out_return None) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 (Out_return None) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_return None)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (k' : cont) (H8 : call_cont k' = call_cont k) (H10 : State f (Sreturn None) k' (Vptr sp Ptrofs.zero) e2 m2 = S) : star step ge (State f (Sreturn None) k' (Vptr sp Ptrofs.zero) e2 m2) E0\n  (Returnstate Vundef k m3).","conclusion":"star step ge (State f (Sreturn None) k' (Vptr sp Ptrofs.zero) e2 m2) E0\n  (Returnstate Vundef k m3)","hypotheses":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (H5 : outcome_free_mem (Out_return None) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 (Out_return None) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_return None)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (k' : cont) (H8 : call_cont k' = call_cont k) (H10 : State f (Sreturn None) k' (Vptr sp Ptrofs.zero) e2 m2 = S)","proofString":"replace k with (call_cont k') by congruence.\napply star_one.\napply step_return_0; auto."},{"statement":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (H5 : outcome_free_mem (Out_return None) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 (Out_return None) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_return None)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (k' : cont) (H8 : call_cont k' = call_cont k) (H10 : State f (Sreturn None) k' (Vptr sp Ptrofs.zero) e2 m2 = S) : star step ge (State f (Sreturn None) k' (Vptr sp Ptrofs.zero) e2 m2) E0\n  (Returnstate Vundef (call_cont k') m3).","conclusion":"star step ge (State f (Sreturn None) k' (Vptr sp Ptrofs.zero) e2 m2) E0\n  (Returnstate Vundef (call_cont k') m3)","hypotheses":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (H5 : outcome_free_mem (Out_return None) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 (Out_return None) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_return None)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (k' : cont) (H8 : call_cont k' = call_cont k) (H10 : State f (Sreturn None) k' (Vptr sp Ptrofs.zero) e2 m2 = S)","proofString":"apply star_one.\napply step_return_0; auto."},{"statement":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (H5 : outcome_free_mem (Out_return None) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 (Out_return None) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_return None)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (k' : cont) (H8 : call_cont k' = call_cont k) (H10 : State f (Sreturn None) k' (Vptr sp Ptrofs.zero) e2 m2 = S) : step ge (State f (Sreturn None) k' (Vptr sp Ptrofs.zero) e2 m2) E0\n  (Returnstate Vundef (call_cont k') m3).","conclusion":"step ge (State f (Sreturn None) k' (Vptr sp Ptrofs.zero) e2 m2) E0\n  (Returnstate Vundef (call_cont k') m3)","hypotheses":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (H5 : outcome_free_mem (Out_return None) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 (Out_return None) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_return None)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (k' : cont) (H8 : call_cont k' = call_cont k) (H10 : State f (Sreturn None) k' (Vptr sp Ptrofs.zero) e2 m2 = S)","proofString":"apply step_return_0; auto."},{"statement":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H5 : outcome_free_mem (Out_return (Some v)) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 \n    (Out_return (Some v)) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_return (Some v))) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (k' : cont) (a : expr) (H8 : call_cont k' = call_cont k) (H9 : eval_expr ge (Vptr sp Ptrofs.zero) e2 m2 a v) (H11 : State f (Sreturn (Some a)) k' (Vptr sp Ptrofs.zero) e2 m2 = S) : star step ge (State f (Sreturn (Some a)) k' (Vptr sp Ptrofs.zero) e2 m2) E0\n  (Returnstate v k m3).","conclusion":"star step ge (State f (Sreturn (Some a)) k' (Vptr sp Ptrofs.zero) e2 m2) E0\n  (Returnstate v k m3)","hypotheses":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H5 : outcome_free_mem (Out_return (Some v)) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 \n    (Out_return (Some v)) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_return (Some v))) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (k' : cont) (a : expr) (H8 : call_cont k' = call_cont k) (H9 : eval_expr ge (Vptr sp Ptrofs.zero) e2 m2 a v) (H11 : State f (Sreturn (Some a)) k' (Vptr sp Ptrofs.zero) e2 m2 = S)","proofString":"replace k with (call_cont k') by congruence.\napply star_one.\neapply step_return_1; eauto."},{"statement":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H5 : outcome_free_mem (Out_return (Some v)) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 \n    (Out_return (Some v)) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_return (Some v))) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (k' : cont) (a : expr) (H8 : call_cont k' = call_cont k) (H9 : eval_expr ge (Vptr sp Ptrofs.zero) e2 m2 a v) (H11 : State f (Sreturn (Some a)) k' (Vptr sp Ptrofs.zero) e2 m2 = S) : star step ge (State f (Sreturn (Some a)) k' (Vptr sp Ptrofs.zero) e2 m2) E0\n  (Returnstate v (call_cont k') m3).","conclusion":"star step ge (State f (Sreturn (Some a)) k' (Vptr sp Ptrofs.zero) e2 m2) E0\n  (Returnstate v (call_cont k') m3)","hypotheses":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H5 : outcome_free_mem (Out_return (Some v)) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 \n    (Out_return (Some v)) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_return (Some v))) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (k' : cont) (a : expr) (H8 : call_cont k' = call_cont k) (H9 : eval_expr ge (Vptr sp Ptrofs.zero) e2 m2 a v) (H11 : State f (Sreturn (Some a)) k' (Vptr sp Ptrofs.zero) e2 m2 = S)","proofString":"apply star_one.\neapply step_return_1; eauto."},{"statement":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H5 : outcome_free_mem (Out_return (Some v)) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 \n    (Out_return (Some v)) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_return (Some v))) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (k' : cont) (a : expr) (H8 : call_cont k' = call_cont k) (H9 : eval_expr ge (Vptr sp Ptrofs.zero) e2 m2 a v) (H11 : State f (Sreturn (Some a)) k' (Vptr sp Ptrofs.zero) e2 m2 = S) : step ge (State f (Sreturn (Some a)) k' (Vptr sp Ptrofs.zero) e2 m2) E0\n  (Returnstate v (call_cont k') m3).","conclusion":"step ge (State f (Sreturn (Some a)) k' (Vptr sp Ptrofs.zero) e2 m2) E0\n  (Returnstate v (call_cont k') m3)","hypotheses":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H5 : outcome_free_mem (Out_return (Some v)) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0 \n    (Out_return (Some v)) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_return (Some v))) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (k' : cont) (a : expr) (H8 : call_cont k' = call_cont k) (H9 : eval_expr ge (Vptr sp Ptrofs.zero) e2 m2 a v) (H11 : State f (Sreturn (Some a)) k' (Vptr sp Ptrofs.zero) e2 m2 = S)","proofString":"eapply step_return_1; eauto."},{"statement":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H5 : outcome_free_mem (Out_tailcall_return v) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0\n    (Out_tailcall_return v) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_tailcall_return v)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (H9 : Returnstate v (call_cont k) m2 = S) : star step ge (Returnstate v (call_cont k) m2) E0 (Returnstate v k m3).","conclusion":"star step ge (Returnstate v (call_cont k) m2) E0 (Returnstate v k m3)","hypotheses":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H5 : outcome_free_mem (Out_tailcall_return v) m2 sp (fn_stackspace f) m3) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0\n    (Out_tailcall_return v) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_tailcall_return v)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (H9 : Returnstate v (call_cont k) m2 = S)","proofString":"red in H5.\nsubst m3.\nrewrite H7.\napply star_refl."},{"statement":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H5 : m3 = m2) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0\n    (Out_tailcall_return v) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_tailcall_return v)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (H9 : Returnstate v (call_cont k) m2 = S) : star step ge (Returnstate v (call_cont k) m2) E0 (Returnstate v k m3).","conclusion":"star step ge (Returnstate v (call_cont k) m2) E0 (Returnstate v k m3)","hypotheses":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 m3 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H5 : m3 = m2) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0\n    (Out_tailcall_return v) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_tailcall_return v)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (H9 : Returnstate v (call_cont k) m2 = S)","proofString":"subst m3.\nrewrite H7.\napply star_refl."},{"statement":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0\n    (Out_tailcall_return v) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_tailcall_return v)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (H9 : Returnstate v (call_cont k) m2 = S) : star step ge (Returnstate v (call_cont k) m2) E0 (Returnstate v k m2).","conclusion":"star step ge (Returnstate v (call_cont k) m2) E0 (Returnstate v k m2)","hypotheses":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0\n    (Out_tailcall_return v) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_tailcall_return v)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (H9 : Returnstate v (call_cont k) m2 = S)","proofString":"rewrite H7.\napply star_refl."},{"statement":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0\n    (Out_tailcall_return v) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_tailcall_return v)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (H9 : Returnstate v (call_cont k) m2 = S) : star step ge (Returnstate v k m2) E0 (Returnstate v k m2).","conclusion":"star step ge (Returnstate v k m2) E0 (Returnstate v k m2)","hypotheses":"(m : mem) (f : function) (vargs : list val) (m1 : Mem.mem') (sp : block) (e : env) (t : trace) (e2 : env) (m2 : mem) (H : list_forall2 Val.has_argtype vargs (sig_args (fn_sig f))) (H0 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H1 : set_locals (fn_vars f) (set_params vargs (fn_params f)) = e) (v : val) (H3 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (fn_body f) k0 (Vptr sp Ptrofs.zero) e m1) t S0 /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e2 m2 f k0\n    (Out_tailcall_return v) S0) (H2 : exec_stmt ge f (Vptr sp Ptrofs.zero) e m1 (fn_body f) t e2 m2\n  (Out_tailcall_return v)) (k : cont) (H6 : is_call_cont k) (S : state) (A : star step ge (State f (fn_body f) k (Vptr sp Ptrofs.zero) e m1) t S) (H7 : call_cont k = k) (H9 : Returnstate v (call_cont k) m2 = S)","proofString":"apply star_refl."},{"statement":"(ef : external_function) (m : mem) (args : list val) (t : trace) (res : val) (m' : mem) (H : external_call ef ge args m t res m') (k : cont) (H0 : is_call_cont k) : star step ge (Callstate (External ef) args k m) t (Returnstate res k m').","conclusion":"star step ge (Callstate (External ef) args k m) t (Returnstate res k m')","hypotheses":"(ef : external_function) (m : mem) (args : list val) (t : trace) (res : val) (m' : mem) (H : external_call ef ge args m t res m') (k : cont) (H0 : is_call_cont k)","proofString":"apply star_one.\nconstructor; auto."},{"statement":"(ef : external_function) (m : mem) (args : list val) (t : trace) (res : val) (m' : mem) (H : external_call ef ge args m t res m') (k : cont) (H0 : is_call_cont k) : step ge (Callstate (External ef) args k m) t (Returnstate res k m').","conclusion":"step ge (Callstate (External ef) args k m) t (Returnstate res k m')","hypotheses":"(ef : external_function) (m : mem) (args : list val) (t : trace) (res : val) (m' : mem) (H : external_call ef ge args m t res m') (k : cont) (H0 : is_call_cont k)","proofString":"constructor; auto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (k : cont) : exists S : state,\n  star step ge (State f Sskip k sp e m) E0 S /\\\n  outcome_state_match sp e m f k Out_normal S.","conclusion":"exists S : state,\n  star step ge (State f Sskip k sp e m) E0 S /\\\n  outcome_state_match sp e m f k Out_normal S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (k : cont)","proofString":"econstructor; split.\napply star_refl.\nconstructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (id : ident) (a : expr) (v : val) (H : eval_expr ge sp e m a v) (k : cont) : exists S : state,\n  star step ge (State f (Sassign id a) k sp e m) E0 S /\\\n  outcome_state_match sp (PTree.set id v e) m f k Out_normal S.","conclusion":"exists S : state,\n  star step ge (State f (Sassign id a) k sp e m) E0 S /\\\n  outcome_state_match sp (PTree.set id v e) m f k Out_normal S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (id : ident) (a : expr) (v : val) (H : eval_expr ge sp e m a v) (k : cont)","proofString":"exists (State f Sskip k sp (PTree.set id v e) m); split.\napply star_one.\nconstructor.\nauto.\nconstructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (id : ident) (a : expr) (v : val) (H : eval_expr ge sp e m a v) (k : cont) : star step ge (State f (Sassign id a) k sp e m) E0\n  (State f Sskip k sp (PTree.set id v e) m).","conclusion":"star step ge (State f (Sassign id a) k sp e m) E0\n  (State f Sskip k sp (PTree.set id v e) m)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (id : ident) (a : expr) (v : val) (H : eval_expr ge sp e m a v) (k : cont)","proofString":"apply star_one.\nconstructor.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (id : ident) (a : expr) (v : val) (H : eval_expr ge sp e m a v) (k : cont) : step ge (State f (Sassign id a) k sp e m) E0\n  (State f Sskip k sp (PTree.set id v e) m).","conclusion":"step ge (State f (Sassign id a) k sp e m) E0\n  (State f Sskip k sp (PTree.set id v e) m)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (id : ident) (a : expr) (v : val) (H : eval_expr ge sp e m a v) (k : cont)","proofString":"constructor.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (id : ident) (a : expr) (v : val) (H : eval_expr ge sp e m a v) (k : cont) : eval_expr ge sp e m a v.","conclusion":"eval_expr ge sp e m a v","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (id : ident) (a : expr) (v : val) (H : eval_expr ge sp e m a v) (k : cont)","proofString":"auto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (id : ident) (a : expr) (v : val) (H : eval_expr ge sp e m a v) (k : cont) : outcome_state_match sp (PTree.set id v e) m f k Out_normal\n  (State f Sskip k sp (PTree.set id v e) m).","conclusion":"outcome_state_match sp (PTree.set id v e) m f k Out_normal\n  (State f Sskip k sp (PTree.set id v e) m)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (id : ident) (a : expr) (v : val) (H : eval_expr ge sp e m a v) (k : cont)","proofString":"constructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (chunk : memory_chunk) (addr a : expr) (vaddr v : val) (m' : mem) (H : eval_expr ge sp e m addr vaddr) (H0 : eval_expr ge sp e m a v) (H1 : Mem.storev chunk m vaddr v = Some m') (k : cont) : exists S : state,\n  star step ge (State f (Sstore chunk addr a) k sp e m) E0 S /\\\n  outcome_state_match sp e m' f k Out_normal S.","conclusion":"exists S : state,\n  star step ge (State f (Sstore chunk addr a) k sp e m) E0 S /\\\n  outcome_state_match sp e m' f k Out_normal S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (chunk : memory_chunk) (addr a : expr) (vaddr v : val) (m' : mem) (H : eval_expr ge sp e m addr vaddr) (H0 : eval_expr ge sp e m a v) (H1 : Mem.storev chunk m vaddr v = Some m') (k : cont)","proofString":"econstructor; split.\napply star_one.\neconstructor; eauto.\nconstructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (optid : option ident) (sig : signature) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (t : trace) (m' : mem) (vres : val) (e' : env) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H2 : funsig fd = sig) (H3 : eval_funcall ge m fd vargs t m' vres) (H4 : forall k0 : cont,\nis_call_cont k0 ->\nstar step ge (Callstate fd vargs k0 m) t (Returnstate vres k0 m')) (H5 : e' = set_optvar optid vres e) (k : cont) : exists S : state,\n  star step ge (State f (Scall optid sig a bl) k sp e m) t S /\\\n  outcome_state_match sp e' m' f k Out_normal S.","conclusion":"exists S : state,\n  star step ge (State f (Scall optid sig a bl) k sp e m) t S /\\\n  outcome_state_match sp e' m' f k Out_normal S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (optid : option ident) (sig : signature) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (t : trace) (m' : mem) (vres : val) (e' : env) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H2 : funsig fd = sig) (H3 : eval_funcall ge m fd vargs t m' vres) (H4 : forall k0 : cont,\nis_call_cont k0 ->\nstar step ge (Callstate fd vargs k0 m) t (Returnstate vres k0 m')) (H5 : e' = set_optvar optid vres e) (k : cont)","proofString":"econstructor; split.\neapply star_left.\neconstructor; eauto.\neapply star_right.\napply H4.\nred; auto.\nconstructor.\nreflexivity.\ntraceEq.\nsubst e'.\nconstructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (optid : option ident) (sig : signature) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (t : trace) (m' : mem) (vres : val) (e' : env) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H2 : funsig fd = sig) (H3 : eval_funcall ge m fd vargs t m' vres) (H4 : forall k0 : cont,\nis_call_cont k0 ->\nstar step ge (Callstate fd vargs k0 m) t (Returnstate vres k0 m')) (H5 : e' = set_optvar optid vres e) (k : cont) : is_call_cont (Kcall optid f sp e k).","conclusion":"is_call_cont (Kcall optid f sp e k)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (optid : option ident) (sig : signature) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (t : trace) (m' : mem) (vres : val) (e' : env) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H2 : funsig fd = sig) (H3 : eval_funcall ge m fd vargs t m' vres) (H4 : forall k0 : cont,\nis_call_cont k0 ->\nstar step ge (Callstate fd vargs k0 m) t (Returnstate vres k0 m')) (H5 : e' = set_optvar optid vres e) (k : cont)","proofString":"red; auto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (optid : option ident) (sig : signature) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (t : trace) (m' : mem) (vres : val) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H2 : funsig fd = sig) (H3 : eval_funcall ge m fd vargs t m' vres) (H4 : forall k0 : cont,\nis_call_cont k0 ->\nstar step ge (Callstate fd vargs k0 m) t (Returnstate vres k0 m')) (k : cont) : outcome_state_match sp (set_optvar optid vres e) m' f k Out_normal\n  (State f Sskip k sp (set_optvar optid vres e) m').","conclusion":"outcome_state_match sp (set_optvar optid vres e) m' f k Out_normal\n  (State f Sskip k sp (set_optvar optid vres e) m')","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (optid : option ident) (sig : signature) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (t : trace) (m' : mem) (vres : val) (H : eval_expr ge sp e m a vf) (H0 : eval_exprlist ge sp e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H2 : funsig fd = sig) (H3 : eval_funcall ge m fd vargs t m' vres) (H4 : forall k0 : cont,\nis_call_cont k0 ->\nstar step ge (Callstate fd vargs k0 m) t (Returnstate vres k0 m')) (k : cont)","proofString":"constructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (optid : option ident) (ef : external_function) (bl : list expr) (t : trace) (m' : mem) (vargs : list val) (vres : val) (e' : env) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : e' = set_optvar optid vres e) (k : cont) : exists S : state,\n  star step ge (State f (Sbuiltin optid ef bl) k sp e m) t S /\\\n  outcome_state_match sp e' m' f k Out_normal S.","conclusion":"exists S : state,\n  star step ge (State f (Sbuiltin optid ef bl) k sp e m) t S /\\\n  outcome_state_match sp e' m' f k Out_normal S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (optid : option ident) (ef : external_function) (bl : list expr) (t : trace) (m' : mem) (vargs : list val) (vres : val) (e' : env) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (H1 : e' = set_optvar optid vres e) (k : cont)","proofString":"econstructor; split.\napply star_one.\neconstructor; eauto.\nsubst e'.\nconstructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (optid : option ident) (ef : external_function) (bl : list expr) (t : trace) (m' : mem) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (k : cont) : outcome_state_match sp (set_optvar optid vres e) m' f k Out_normal\n  (State f Sskip k sp (set_optvar optid vres e) m').","conclusion":"outcome_state_match sp (set_optvar optid vres e) m' f k Out_normal\n  (State f Sskip k sp (set_optvar optid vres e) m')","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (optid : option ident) (ef : external_function) (bl : list expr) (t : trace) (m' : mem) (vargs : list val) (vres : val) (H : eval_exprlist ge sp e m bl vargs) (H0 : external_call ef ge vargs m t vres m') (k : cont)","proofString":"constructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S /\\\n  outcome_state_match sp e' m' f k0 out S) (k : cont) : exists S : state,\n  star step ge (State f (Sifthenelse a s1 s2) k sp e m) t S /\\\n  outcome_state_match sp e' m' f k out S.","conclusion":"exists S : state,\n  star step ge (State f (Sifthenelse a s1 s2) k sp e m) t S /\\\n  outcome_state_match sp e' m' f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S /\\\n  outcome_state_match sp e' m' f k0 out S) (k : cont)","proofString":"destruct (H2 k) as [S [A B]].\nexists S; split.\napply star_left with E0 (State f (if b then s1 else s2) k sp e m) t.\neconstructor; eauto.\nexact A.\ntraceEq.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k0 out S0) (k : cont) (S : state) (A : star step ge (State f (if b then s1 else s2) k sp e m) t S) (B : outcome_state_match sp e' m' f k out S) : exists S0 : state,\n  star step ge (State f (Sifthenelse a s1 s2) k sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k out S0.","conclusion":"exists S0 : state,\n  star step ge (State f (Sifthenelse a s1 s2) k sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k out S0","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k0 out S0) (k : cont) (S : state) (A : star step ge (State f (if b then s1 else s2) k sp e m) t S) (B : outcome_state_match sp e' m' f k out S)","proofString":"exists S; split.\napply star_left with E0 (State f (if b then s1 else s2) k sp e m) t.\neconstructor; eauto.\nexact A.\ntraceEq.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k0 out S0) (k : cont) (S : state) (A : star step ge (State f (if b then s1 else s2) k sp e m) t S) (B : outcome_state_match sp e' m' f k out S) : star step ge (State f (Sifthenelse a s1 s2) k sp e m) t S.","conclusion":"star step ge (State f (Sifthenelse a s1 s2) k sp e m) t S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k0 out S0) (k : cont) (S : state) (A : star step ge (State f (if b then s1 else s2) k sp e m) t S) (B : outcome_state_match sp e' m' f k out S)","proofString":"apply star_left with E0 (State f (if b then s1 else s2) k sp e m) t.\neconstructor; eauto.\nexact A.\ntraceEq."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k0 out S0) (k : cont) (S : state) (A : star step ge (State f (if b then s1 else s2) k sp e m) t S) (B : outcome_state_match sp e' m' f k out S) : step ge (State f (Sifthenelse a s1 s2) k sp e m) E0\n  (State f (if b then s1 else s2) k sp e m).","conclusion":"step ge (State f (Sifthenelse a s1 s2) k sp e m) E0\n  (State f (if b then s1 else s2) k sp e m)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k0 out S0) (k : cont) (S : state) (A : star step ge (State f (if b then s1 else s2) k sp e m) t S) (B : outcome_state_match sp e' m' f k out S)","proofString":"econstructor; eauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k0 out S0) (k : cont) (S : state) (A : star step ge (State f (if b then s1 else s2) k sp e m) t S) (B : outcome_state_match sp e' m' f k out S) : star step ge (State f (if b then s1 else s2) k sp e m) t S.","conclusion":"star step ge (State f (if b then s1 else s2) k sp e m) t S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k0 out S0) (k : cont) (S : state) (A : star step ge (State f (if b then s1 else s2) k sp e m) t S) (B : outcome_state_match sp e' m' f k out S)","proofString":"exact A."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k0 out S0) (k : cont) (S : state) (A : star step ge (State f (if b then s1 else s2) k sp e m) t S) (B : outcome_state_match sp e' m' f k out S) : t = E0 ** t.","conclusion":"t = E0 ** t","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k0 out S0) (k : cont) (S : state) (A : star step ge (State f (if b then s1 else s2) k sp e m) t S) (B : outcome_state_match sp e' m' f k out S)","proofString":"traceEq."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k0 out S0) (k : cont) (S : state) (A : star step ge (State f (if b then s1 else s2) k sp e m) t S) (B : outcome_state_match sp e' m' f k out S) : outcome_state_match sp e' m' f k out S.","conclusion":"outcome_state_match sp e' m' f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (t : trace) (e' : env) (m' : mem) (out : outcome) (H : eval_expr ge sp e m a v) (H0 : Val.bool_of_val v b) (H1 : exec_stmt ge f sp e m (if b then s1 else s2) t e' m' out) (H2 : forall k0 : cont,\nexists S0 : state,\n  star step ge (State f (if b then s1 else s2) k0 sp e m) t S0 /\\\n  outcome_state_match sp e' m' f k0 out S0) (k : cont) (S : state) (A : star step ge (State f (if b then s1 else s2) k sp e m) t S) (B : outcome_state_match sp e' m' f k out S)","proofString":"auto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 s2 t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s2 k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (H3 : t = t1 ** t2) (k : cont) : exists S : state,\n  star step ge (State f (Sseq s1 s2) k sp e m) t S /\\\n  outcome_state_match sp e2 m2 f k out S.","conclusion":"exists S : state,\n  star step ge (State f (Sseq s1 s2) k sp e m) t S /\\\n  outcome_state_match sp e2 m2 f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 s2 t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s2 k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (H3 : t = t1 ** t2) (k : cont)","proofString":"destruct (H0 (Kseq s2 k)) as [S1 [A1 B1]].\ndestruct (H2 k) as [S2 [A2 B2]].\ninv B1.\nexists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\nconstructor.\neexact A2.\nreflexivity.\nreflexivity.\ntraceEq.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 s2 t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s2 k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (H3 : t = t1 ** t2) (k : cont) (S1 : state) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t1 S1) (B1 : outcome_state_match sp e1 m1 f (Kseq s2 k) Out_normal S1) : exists S : state,\n  star step ge (State f (Sseq s1 s2) k sp e m) t S /\\\n  outcome_state_match sp e2 m2 f k out S.","conclusion":"exists S : state,\n  star step ge (State f (Sseq s1 s2) k sp e m) t S /\\\n  outcome_state_match sp e2 m2 f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 s2 t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s2 k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (H3 : t = t1 ** t2) (k : cont) (S1 : state) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t1 S1) (B1 : outcome_state_match sp e1 m1 f (Kseq s2 k) Out_normal S1)","proofString":"destruct (H2 k) as [S2 [A2 B2]].\ninv B1.\nexists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\nconstructor.\neexact A2.\nreflexivity.\nreflexivity.\ntraceEq.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 s2 t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s2 k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (H3 : t = t1 ** t2) (k : cont) (S1 : state) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t1 S1) (B1 : outcome_state_match sp e1 m1 f (Kseq s2 k) Out_normal S1) (S2 : state) (A2 : star step ge (State f s2 k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2) : exists S : state,\n  star step ge (State f (Sseq s1 s2) k sp e m) t S /\\\n  outcome_state_match sp e2 m2 f k out S.","conclusion":"exists S : state,\n  star step ge (State f (Sseq s1 s2) k sp e m) t S /\\\n  outcome_state_match sp e2 m2 f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 s2 t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s2 k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (H3 : t = t1 ** t2) (k : cont) (S1 : state) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t1 S1) (B1 : outcome_state_match sp e1 m1 f (Kseq s2 k) Out_normal S1) (S2 : state) (A2 : star step ge (State f s2 k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2)","proofString":"inv B1.\nexists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\nconstructor.\neexact A2.\nreflexivity.\nreflexivity.\ntraceEq.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 s2 t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s2 k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (k : cont) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t1\n  (State f Sskip (Kseq s2 k) sp e1 m1)) (S2 : state) (A2 : star step ge (State f s2 k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2) : exists S : state,\n  star step ge (State f (Sseq s1 s2) k sp e m) (t1 ** t2) S /\\\n  outcome_state_match sp e2 m2 f k out S.","conclusion":"exists S : state,\n  star step ge (State f (Sseq s1 s2) k sp e m) (t1 ** t2) S /\\\n  outcome_state_match sp e2 m2 f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 s2 t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s2 k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (k : cont) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t1\n  (State f Sskip (Kseq s2 k) sp e1 m1)) (S2 : state) (A2 : star step ge (State f s2 k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2)","proofString":"exists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\nconstructor.\neexact A2.\nreflexivity.\nreflexivity.\ntraceEq.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 s2 t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s2 k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (k : cont) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t1\n  (State f Sskip (Kseq s2 k) sp e1 m1)) (S2 : state) (A2 : star step ge (State f s2 k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2) : star step ge (State f (Sseq s1 s2) k sp e m) (t1 ** t2) S2.","conclusion":"star step ge (State f (Sseq s1 s2) k sp e m) (t1 ** t2) S2","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 s2 t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s2 k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (k : cont) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t1\n  (State f Sskip (Kseq s2 k) sp e1 m1)) (S2 : state) (A2 : star step ge (State f s2 k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2)","proofString":"eapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\nconstructor.\neexact A2.\nreflexivity.\nreflexivity.\ntraceEq."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 s2 t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s2 k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (k : cont) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t1\n  (State f Sskip (Kseq s2 k) sp e1 m1)) (S2 : state) (A2 : star step ge (State f s2 k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2) : outcome_state_match sp e2 m2 f k out S2.","conclusion":"outcome_state_match sp e2 m2 f k out S2","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 s2 t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s2 k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (k : cont) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t1\n  (State f Sskip (Kseq s2 k) sp e1 m1)) (S2 : state) (A2 : star step ge (State f s2 k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2)","proofString":"auto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 s2 : stmt) (e1 : env) (m1 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t e1 m1 out) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 out S) (H1 : out <> Out_normal) (k : cont) : exists S : state,\n  star step ge (State f (Sseq s1 s2) k sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k out S.","conclusion":"exists S : state,\n  star step ge (State f (Sseq s1 s2) k sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 s2 : stmt) (e1 : env) (m1 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t e1 m1 out) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 out S) (H1 : out <> Out_normal) (k : cont)","proofString":"destruct (H0 (Kseq s2 k)) as [S1 [A1 B1]].\nset (S2 :=    match out with    | Out_exit n => State f (Sexit n) k sp e1 m1    | _ => S1    end).\nexists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\nunfold S2; destruct out; try (apply star_refl).\ninv B1.\napply star_one.\nconstructor.\nreflexivity.\ntraceEq.\nunfold S2; inv B1; congruence || simpl; constructor; auto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 s2 : stmt) (e1 : env) (m1 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t e1 m1 out) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 out S) (H1 : out <> Out_normal) (k : cont) (S1 : state) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kseq s2 k) out S1) : exists S : state,\n  star step ge (State f (Sseq s1 s2) k sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k out S.","conclusion":"exists S : state,\n  star step ge (State f (Sseq s1 s2) k sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 s2 : stmt) (e1 : env) (m1 : mem) (out : outcome) (H : exec_stmt ge f sp e m s1 t e1 m1 out) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 out S) (H1 : out <> Out_normal) (k : cont) (S1 : state) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kseq s2 k) out S1)","proofString":"set (S2 :=    match out with    | Out_exit n => State f (Sexit n) k sp e1 m1    | _ => S1    end).\nexists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\nunfold S2; destruct out; try (apply star_refl).\ninv B1.\napply star_one.\nconstructor.\nreflexivity.\ntraceEq.\nunfold S2; inv B1; congruence || simpl; constructor; auto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 s2 : stmt) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s1 t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H1 : Out_exit n <> Out_normal) (k : cont) (S1 : state) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kseq s2 k) (Out_exit n) S1) (S2 : state) : star step ge S1 E0 (State f (Sexit n) k sp e1 m1).","conclusion":"star step ge S1 E0 (State f (Sexit n) k sp e1 m1)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 s2 : stmt) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s1 t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H1 : Out_exit n <> Out_normal) (k : cont) (S1 : state) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kseq s2 k) (Out_exit n) S1) (S2 : state)","proofString":"inv B1.\napply star_one.\nconstructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 s2 : stmt) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s1 t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H1 : Out_exit n <> Out_normal) (k : cont) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t\n  (State f (Sexit n) (Kseq s2 k) sp e1 m1)) (S2 : state) : star step ge (State f (Sexit n) (Kseq s2 k) sp e1 m1) E0\n  (State f (Sexit n) k sp e1 m1).","conclusion":"star step ge (State f (Sexit n) (Kseq s2 k) sp e1 m1) E0\n  (State f (Sexit n) k sp e1 m1)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 s2 : stmt) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s1 t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H1 : Out_exit n <> Out_normal) (k : cont) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t\n  (State f (Sexit n) (Kseq s2 k) sp e1 m1)) (S2 : state)","proofString":"apply star_one.\nconstructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 s2 : stmt) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s1 t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H1 : Out_exit n <> Out_normal) (k : cont) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t\n  (State f (Sexit n) (Kseq s2 k) sp e1 m1)) (S2 : state) : step ge (State f (Sexit n) (Kseq s2 k) sp e1 m1) E0\n  (State f (Sexit n) k sp e1 m1).","conclusion":"step ge (State f (Sexit n) (Kseq s2 k) sp e1 m1) E0\n  (State f (Sexit n) k sp e1 m1)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s1 s2 : stmt) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s1 t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s1 k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H1 : Out_exit n <> Out_normal) (k : cont) (A1 : star step ge (State f s1 (Kseq s2 k) sp e m) t\n  (State f (Sexit n) (Kseq s2 k) sp e1 m1)) (S2 : state)","proofString":"constructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t t1 : trace) (e1 : env) (m1 : mem) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 (Sloop s) t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (Sloop s) k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (H3 : t = t1 ** t2) (k : cont) : exists S : state,\n  star step ge (State f (Sloop s) k sp e m) t S /\\\n  outcome_state_match sp e2 m2 f k out S.","conclusion":"exists S : state,\n  star step ge (State f (Sloop s) k sp e m) t S /\\\n  outcome_state_match sp e2 m2 f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t t1 : trace) (e1 : env) (m1 : mem) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 (Sloop s) t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (Sloop s) k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (H3 : t = t1 ** t2) (k : cont)","proofString":"destruct (H0 (Kseq (Sloop s) k)) as [S1 [A1 B1]].\ndestruct (H2 k) as [S2 [A2 B2]].\ninv B1.\nexists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\nconstructor.\neexact A2.\nreflexivity.\nreflexivity.\ntraceEq.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t t1 : trace) (e1 : env) (m1 : mem) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 (Sloop s) t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (Sloop s) k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (H3 : t = t1 ** t2) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t1 S1) (B1 : outcome_state_match sp e1 m1 f (Kseq (Sloop s) k) Out_normal S1) : exists S : state,\n  star step ge (State f (Sloop s) k sp e m) t S /\\\n  outcome_state_match sp e2 m2 f k out S.","conclusion":"exists S : state,\n  star step ge (State f (Sloop s) k sp e m) t S /\\\n  outcome_state_match sp e2 m2 f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t t1 : trace) (e1 : env) (m1 : mem) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 (Sloop s) t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (Sloop s) k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (H3 : t = t1 ** t2) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t1 S1) (B1 : outcome_state_match sp e1 m1 f (Kseq (Sloop s) k) Out_normal S1)","proofString":"destruct (H2 k) as [S2 [A2 B2]].\ninv B1.\nexists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\nconstructor.\neexact A2.\nreflexivity.\nreflexivity.\ntraceEq.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t t1 : trace) (e1 : env) (m1 : mem) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 (Sloop s) t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (Sloop s) k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (H3 : t = t1 ** t2) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t1 S1) (B1 : outcome_state_match sp e1 m1 f (Kseq (Sloop s) k) Out_normal S1) (S2 : state) (A2 : star step ge (State f (Sloop s) k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2) : exists S : state,\n  star step ge (State f (Sloop s) k sp e m) t S /\\\n  outcome_state_match sp e2 m2 f k out S.","conclusion":"exists S : state,\n  star step ge (State f (Sloop s) k sp e m) t S /\\\n  outcome_state_match sp e2 m2 f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t t1 : trace) (e1 : env) (m1 : mem) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 (Sloop s) t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (Sloop s) k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (H3 : t = t1 ** t2) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t1 S1) (B1 : outcome_state_match sp e1 m1 f (Kseq (Sloop s) k) Out_normal S1) (S2 : state) (A2 : star step ge (State f (Sloop s) k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2)","proofString":"inv B1.\nexists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\nconstructor.\neexact A2.\nreflexivity.\nreflexivity.\ntraceEq.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t1 : trace) (e1 : env) (m1 : mem) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 (Sloop s) t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (Sloop s) k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (k : cont) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t1\n  (State f Sskip (Kseq (Sloop s) k) sp e1 m1)) (S2 : state) (A2 : star step ge (State f (Sloop s) k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2) : exists S : state,\n  star step ge (State f (Sloop s) k sp e m) (t1 ** t2) S /\\\n  outcome_state_match sp e2 m2 f k out S.","conclusion":"exists S : state,\n  star step ge (State f (Sloop s) k sp e m) (t1 ** t2) S /\\\n  outcome_state_match sp e2 m2 f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t1 : trace) (e1 : env) (m1 : mem) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 (Sloop s) t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (Sloop s) k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (k : cont) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t1\n  (State f Sskip (Kseq (Sloop s) k) sp e1 m1)) (S2 : state) (A2 : star step ge (State f (Sloop s) k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2)","proofString":"exists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\nconstructor.\neexact A2.\nreflexivity.\nreflexivity.\ntraceEq.\nauto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t1 : trace) (e1 : env) (m1 : mem) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 (Sloop s) t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (Sloop s) k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (k : cont) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t1\n  (State f Sskip (Kseq (Sloop s) k) sp e1 m1)) (S2 : state) (A2 : star step ge (State f (Sloop s) k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2) : star step ge (State f (Sloop s) k sp e m) (t1 ** t2) S2.","conclusion":"star step ge (State f (Sloop s) k sp e m) (t1 ** t2) S2","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t1 : trace) (e1 : env) (m1 : mem) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 (Sloop s) t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (Sloop s) k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (k : cont) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t1\n  (State f Sskip (Kseq (Sloop s) k) sp e1 m1)) (S2 : state) (A2 : star step ge (State f (Sloop s) k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2)","proofString":"eapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\neapply star_left.\nconstructor.\neexact A2.\nreflexivity.\nreflexivity.\ntraceEq."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t1 : trace) (e1 : env) (m1 : mem) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 (Sloop s) t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (Sloop s) k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (k : cont) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t1\n  (State f Sskip (Kseq (Sloop s) k) sp e1 m1)) (S2 : state) (A2 : star step ge (State f (Sloop s) k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2) : outcome_state_match sp e2 m2 f k out S2.","conclusion":"outcome_state_match sp e2 m2 f k out S2","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t1 : trace) (e1 : env) (m1 : mem) (t2 : trace) (e2 : env) (m2 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t1 e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t1 S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (H1 : exec_stmt ge f sp e1 m1 (Sloop s) t2 e2 m2 out) (H2 : forall k0 : cont,\nexists S : state,\n  star step ge (State f (Sloop s) k0 sp e1 m1) t2 S /\\\n  outcome_state_match sp e2 m2 f k0 out S) (k : cont) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t1\n  (State f Sskip (Kseq (Sloop s) k) sp e1 m1)) (S2 : state) (A2 : star step ge (State f (Sloop s) k sp e1 m1) t2 S2) (B2 : outcome_state_match sp e2 m2 f k out S2)","proofString":"auto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s : stmt) (e1 : env) (m1 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t e1 m1 out) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 out S) (H1 : out <> Out_normal) (k : cont) : exists S : state,\n  star step ge (State f (Sloop s) k sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k out S.","conclusion":"exists S : state,\n  star step ge (State f (Sloop s) k sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s : stmt) (e1 : env) (m1 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t e1 m1 out) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 out S) (H1 : out <> Out_normal) (k : cont)","proofString":"destruct (H0 (Kseq (Sloop s) k)) as [S1 [A1 B1]].\nset (S2 :=    match out with    | Out_exit n => State f (Sexit n) k sp e1 m1    | _ => S1    end).\nexists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\nunfold S2; destruct out; try (apply star_refl).\ninv B1.\napply star_one.\nconstructor.\nreflexivity.\ntraceEq.\nunfold S2; inv B1; congruence || simpl; constructor; auto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s : stmt) (e1 : env) (m1 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t e1 m1 out) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 out S) (H1 : out <> Out_normal) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kseq (Sloop s) k) out S1) : exists S : state,\n  star step ge (State f (Sloop s) k sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k out S.","conclusion":"exists S : state,\n  star step ge (State f (Sloop s) k sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k out S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s : stmt) (e1 : env) (m1 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t e1 m1 out) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 out S) (H1 : out <> Out_normal) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kseq (Sloop s) k) out S1)","proofString":"set (S2 :=    match out with    | Out_exit n => State f (Sexit n) k sp e1 m1    | _ => S1    end).\nexists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\nunfold S2; destruct out; try (apply star_refl).\ninv B1.\napply star_one.\nconstructor.\nreflexivity.\ntraceEq.\nunfold S2; inv B1; congruence || simpl; constructor; auto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s : stmt) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H1 : Out_exit n <> Out_normal) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kseq (Sloop s) k) (Out_exit n) S1) (S2 : state) : star step ge S1 E0 (State f (Sexit n) k sp e1 m1).","conclusion":"star step ge S1 E0 (State f (Sexit n) k sp e1 m1)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s : stmt) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H1 : Out_exit n <> Out_normal) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kseq (Sloop s) k) (Out_exit n) S1) (S2 : state)","proofString":"inv B1.\napply star_one.\nconstructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s : stmt) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H1 : Out_exit n <> Out_normal) (k : cont) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t\n  (State f (Sexit n) (Kseq (Sloop s) k) sp e1 m1)) (S2 : state) : star step ge (State f (Sexit n) (Kseq (Sloop s) k) sp e1 m1) E0\n  (State f (Sexit n) k sp e1 m1).","conclusion":"star step ge (State f (Sexit n) (Kseq (Sloop s) k) sp e1 m1) E0\n  (State f (Sexit n) k sp e1 m1)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s : stmt) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H1 : Out_exit n <> Out_normal) (k : cont) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t\n  (State f (Sexit n) (Kseq (Sloop s) k) sp e1 m1)) (S2 : state)","proofString":"apply star_one.\nconstructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s : stmt) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H1 : Out_exit n <> Out_normal) (k : cont) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t\n  (State f (Sexit n) (Kseq (Sloop s) k) sp e1 m1)) (S2 : state) : step ge (State f (Sexit n) (Kseq (Sloop s) k) sp e1 m1) E0\n  (State f (Sexit n) k sp e1 m1).","conclusion":"step ge (State f (Sexit n) (Kseq (Sloop s) k) sp e1 m1) E0\n  (State f (Sexit n) k sp e1 m1)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (t : trace) (s : stmt) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H1 : Out_exit n <> Out_normal) (k : cont) (A1 : star step ge (State f s (Kseq (Sloop s) k) sp e m) t\n  (State f (Sexit n) (Kseq (Sloop s) k) sp e1 m1)) (S2 : state)","proofString":"constructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t e1 m1 out) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 out S) (k : cont) : exists S : state,\n  star step ge (State f (Sblock s) k sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k (outcome_block out) S.","conclusion":"exists S : state,\n  star step ge (State f (Sblock s) k sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k (outcome_block out) S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t e1 m1 out) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 out S) (k : cont)","proofString":"destruct (H0 (Kblock k)) as [S1 [A1 B1]].\nset (S2 :=    match out with    | Out_normal => State f Sskip k sp e1 m1    | Out_exit O => State f Sskip k sp e1 m1    | Out_exit (S m) => State f (Sexit m) k sp e1 m1    | _ => S1    end).\nexists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\nunfold S2; destruct out; try (apply star_refl).\ninv B1.\napply star_one.\nconstructor.\ninv B1.\napply star_one.\ndestruct n; constructor.\nreflexivity.\ntraceEq.\nunfold S2; inv B1; simpl; try constructor; auto.\ndestruct n; constructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t e1 m1 out) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 out S) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kblock k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kblock k) out S1) : exists S : state,\n  star step ge (State f (Sblock s) k sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k (outcome_block out) S.","conclusion":"exists S : state,\n  star step ge (State f (Sblock s) k sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k (outcome_block out) S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (out : outcome) (H : exec_stmt ge f sp e m s t e1 m1 out) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 out S) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kblock k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kblock k) out S1)","proofString":"set (S2 :=    match out with    | Out_normal => State f Sskip k sp e1 m1    | Out_exit O => State f Sskip k sp e1 m1    | Out_exit (S m) => State f (Sexit m) k sp e1 m1    | _ => S1    end).\nexists S2; split.\neapply star_left.\nconstructor.\neapply star_trans.\neexact A1.\nunfold S2; destruct out; try (apply star_refl).\ninv B1.\napply star_one.\nconstructor.\ninv B1.\napply star_one.\ndestruct n; constructor.\nreflexivity.\ntraceEq.\nunfold S2; inv B1; simpl; try constructor; auto.\ndestruct n; constructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (H : exec_stmt ge f sp e m s t e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kblock k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kblock k) Out_normal S1) (S2 : state) : star step ge S1 E0 (State f Sskip k sp e1 m1).","conclusion":"star step ge S1 E0 (State f Sskip k sp e1 m1)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (H : exec_stmt ge f sp e m s t e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kblock k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kblock k) Out_normal S1) (S2 : state)","proofString":"inv B1.\napply star_one.\nconstructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (H : exec_stmt ge f sp e m s t e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (k : cont) (A1 : star step ge (State f s (Kblock k) sp e m) t\n  (State f Sskip (Kblock k) sp e1 m1)) (S2 : state) : star step ge (State f Sskip (Kblock k) sp e1 m1) E0\n  (State f Sskip k sp e1 m1).","conclusion":"star step ge (State f Sskip (Kblock k) sp e1 m1) E0\n  (State f Sskip k sp e1 m1)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (H : exec_stmt ge f sp e m s t e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (k : cont) (A1 : star step ge (State f s (Kblock k) sp e m) t\n  (State f Sskip (Kblock k) sp e1 m1)) (S2 : state)","proofString":"apply star_one.\nconstructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (H : exec_stmt ge f sp e m s t e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (k : cont) (A1 : star step ge (State f s (Kblock k) sp e m) t\n  (State f Sskip (Kblock k) sp e1 m1)) (S2 : state) : step ge (State f Sskip (Kblock k) sp e1 m1) E0 (State f Sskip k sp e1 m1).","conclusion":"step ge (State f Sskip (Kblock k) sp e1 m1) E0 (State f Sskip k sp e1 m1)","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (H : exec_stmt ge f sp e m s t e1 m1 Out_normal) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 Out_normal S) (k : cont) (A1 : star step ge (State f s (Kblock k) sp e m) t\n  (State f Sskip (Kblock k) sp e1 m1)) (S2 : state)","proofString":"constructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kblock k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kblock k) (Out_exit n) S1) (S2 : state) : star step ge S1 E0\n  match n with\n  | 0%nat => State f Sskip k sp e1 m1\n  | S m0 => State f (Sexit m0) k sp e1 m1\n  end.","conclusion":"star step ge S1 E0\n  match n with\n  | 0%nat => State f Sskip k sp e1 m1\n  | S m0 => State f (Sexit m0) k sp e1 m1\n  end","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (k : cont) (S1 : state) (A1 : star step ge (State f s (Kblock k) sp e m) t S1) (B1 : outcome_state_match sp e1 m1 f (Kblock k) (Out_exit n) S1) (S2 : state)","proofString":"inv B1.\napply star_one.\ndestruct n; constructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (k : cont) (A1 : star step ge (State f s (Kblock k) sp e m) t\n  (State f (Sexit n) (Kblock k) sp e1 m1)) (S2 : state) : star step ge (State f (Sexit n) (Kblock k) sp e1 m1) E0\n  match n with\n  | 0%nat => State f Sskip k sp e1 m1\n  | S m0 => State f (Sexit m0) k sp e1 m1\n  end.","conclusion":"star step ge (State f (Sexit n) (Kblock k) sp e1 m1) E0\n  match n with\n  | 0%nat => State f Sskip k sp e1 m1\n  | S m0 => State f (Sexit m0) k sp e1 m1\n  end","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (k : cont) (A1 : star step ge (State f s (Kblock k) sp e m) t\n  (State f (Sexit n) (Kblock k) sp e1 m1)) (S2 : state)","proofString":"apply star_one.\ndestruct n; constructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (k : cont) (A1 : star step ge (State f s (Kblock k) sp e m) t\n  (State f (Sexit n) (Kblock k) sp e1 m1)) (S2 : state) : step ge (State f (Sexit n) (Kblock k) sp e1 m1) E0\n  match n with\n  | 0%nat => State f Sskip k sp e1 m1\n  | S m0 => State f (Sexit m0) k sp e1 m1\n  end.","conclusion":"step ge (State f (Sexit n) (Kblock k) sp e1 m1) E0\n  match n with\n  | 0%nat => State f Sskip k sp e1 m1\n  | S m0 => State f (Sexit m0) k sp e1 m1\n  end","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (n : nat) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (k : cont) (A1 : star step ge (State f s (Kblock k) sp e m) t\n  (State f (Sexit n) (Kblock k) sp e1 m1)) (S2 : state)","proofString":"destruct n; constructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (n : nat) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (k : cont) (A1 : star step ge (State f s (Kblock k) sp e m) t\n  (State f (Sexit n) (Kblock k) sp e1 m1)) (S2 : state) : outcome_state_match sp e1 m1 f k\n  match n with\n  | 0%nat => Out_normal\n  | S n0 => Out_exit n0\n  end\n  match n with\n  | 0%nat => State f Sskip k sp e1 m1\n  | S m0 => State f (Sexit m0) k sp e1 m1\n  end.","conclusion":"outcome_state_match sp e1 m1 f k\n  match n with\n  | 0%nat => Out_normal\n  | S n0 => Out_exit n0\n  end\n  match n with\n  | 0%nat => State f Sskip k sp e1 m1\n  | S m0 => State f (Sexit m0) k sp e1 m1\n  end","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (s : stmt) (t : trace) (e1 : env) (m1 : mem) (n : nat) (H0 : forall k0 : cont,\nexists S : state,\n  star step ge (State f s k0 sp e m) t S /\\\n  outcome_state_match sp e1 m1 f k0 (Out_exit n) S) (H : exec_stmt ge f sp e m s t e1 m1 (Out_exit n)) (k : cont) (A1 : star step ge (State f s (Kblock k) sp e m) t\n  (State f (Sexit n) (Kblock k) sp e1 m1)) (S2 : state)","proofString":"destruct n; constructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (n : nat) (k : cont) : exists S : state,\n  star step ge (State f (Sexit n) k sp e m) E0 S /\\\n  outcome_state_match sp e m f k (Out_exit n) S.","conclusion":"exists S : state,\n  star step ge (State f (Sexit n) k sp e m) E0 S /\\\n  outcome_state_match sp e m f k (Out_exit n) S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (n : nat) (k : cont)","proofString":"econstructor; split.\napply star_refl.\nconstructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (islong : bool) (a : expr) (cases : list (Z * nat)) (default : nat) (v : val) (n : Z) (H : eval_expr ge sp e m a v) (H0 : switch_argument islong v n) (k : cont) : exists S : state,\n  star step ge (State f (Sswitch islong a cases default) k sp e m) E0 S /\\\n  outcome_state_match sp e m f k (Out_exit (switch_target n default cases)) S.","conclusion":"exists S : state,\n  star step ge (State f (Sswitch islong a cases default) k sp e m) E0 S /\\\n  outcome_state_match sp e m f k (Out_exit (switch_target n default cases)) S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (islong : bool) (a : expr) (cases : list (Z * nat)) (default : nat) (v : val) (n : Z) (H : eval_expr ge sp e m a v) (H0 : switch_argument islong v n) (k : cont)","proofString":"econstructor; split.\napply star_one.\neconstructor; eauto.\nconstructor."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (k : cont) : exists S : state,\n  star step ge (State f (Sreturn None) k sp e m) E0 S /\\\n  outcome_state_match sp e m f k (Out_return None) S.","conclusion":"exists S : state,\n  star step ge (State f (Sreturn None) k sp e m) E0 S /\\\n  outcome_state_match sp e m f k (Out_return None) S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (k : cont)","proofString":"econstructor; split.\napply star_refl.\nconstructor; auto."},{"statement":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (v : val) (H : eval_expr ge sp e m a v) (k : cont) : exists S : state,\n  star step ge (State f (Sreturn (Some a)) k sp e m) E0 S /\\\n  outcome_state_match sp e m f k (Out_return (Some v)) S.","conclusion":"exists S : state,\n  star step ge (State f (Sreturn (Some a)) k sp e m) E0 S /\\\n  outcome_state_match sp e m f k (Out_return (Some v)) S","hypotheses":"(f : function) (sp : val) (e : env) (m : mem) (a : expr) (v : val) (H : eval_expr ge sp e m a v) (k : cont)","proofString":"econstructor; split.\napply star_refl.\nconstructor; auto."},{"statement":"(f : function) (sp : block) (e : env) (m : mem) (sig : signature) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (t : trace) (m' m'' : mem) (vres : val) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H2 : funsig fd = sig) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (H4 : eval_funcall ge m' fd vargs t m'' vres) (H5 : forall k0 : cont,\nis_call_cont k0 ->\nstar step ge (Callstate fd vargs k0 m') t (Returnstate vres k0 m'')) (k : cont) : exists S : state,\n  star step ge (State f (Stailcall sig a bl) k (Vptr sp Ptrofs.zero) e m) t S /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e m'' f k\n    (Out_tailcall_return vres) S.","conclusion":"exists S : state,\n  star step ge (State f (Stailcall sig a bl) k (Vptr sp Ptrofs.zero) e m) t S /\\\n  outcome_state_match (Vptr sp Ptrofs.zero) e m'' f k\n    (Out_tailcall_return vres) S","hypotheses":"(f : function) (sp : block) (e : env) (m : mem) (sig : signature) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (t : trace) (m' m'' : mem) (vres : val) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H2 : funsig fd = sig) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (H4 : eval_funcall ge m' fd vargs t m'' vres) (H5 : forall k0 : cont,\nis_call_cont k0 ->\nstar step ge (Callstate fd vargs k0 m') t (Returnstate vres k0 m'')) (k : cont)","proofString":"econstructor; split.\neapply star_left.\neconstructor; eauto.\napply H5.\napply is_call_cont_call_cont.\ntraceEq.\neconstructor."},{"statement":"(f : function) (sp : block) (e : env) (m : mem) (sig : signature) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (t : trace) (m' m'' : mem) (vres : val) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H2 : funsig fd = sig) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (H4 : eval_funcall ge m' fd vargs t m'' vres) (H5 : forall k0 : cont,\nis_call_cont k0 ->\nstar step ge (Callstate fd vargs k0 m') t (Returnstate vres k0 m'')) (k : cont) : is_call_cont (call_cont k).","conclusion":"is_call_cont (call_cont k)","hypotheses":"(f : function) (sp : block) (e : env) (m : mem) (sig : signature) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (t : trace) (m' m'' : mem) (vres : val) (H : eval_expr ge (Vptr sp Ptrofs.zero) e m a vf) (H0 : eval_exprlist ge (Vptr sp Ptrofs.zero) e m bl vargs) (H1 : Genv.find_funct ge vf = Some fd) (H2 : funsig fd = sig) (H3 : Mem.free m sp 0 (fn_stackspace f) = Some m') (H4 : eval_funcall ge m' fd vargs t m'' vres) (H5 : forall k0 : cont,\nis_call_cont k0 ->\nstar step ge (Callstate fd vargs k0 m') t (Returnstate vres k0 m'')) (k : cont)","proofString":"apply is_call_cont_call_cont."},{"statement":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_plus step ge (Callstate fd args k m) T) : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_plus step ge (Callstate fd args k m) T.","conclusion":"forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_plus step ge (Callstate fd args k m) T","hypotheses":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_plus step ge (Callstate fd args k m) T)","proofString":"assert (forall sp e m s T f k,          execinf_stmt ge f sp e m s T ->          forever_plus step ge (State f s k sp e m) T).\ncofix CIH_STMT.\nintros.\ninv H.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_FUN.\neauto.\ntraceEq.\neapply forever_plus_intro with (s2 := State f (if b then s1 else s2) k sp e m).\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\nconstructor.\napply CIH_STMT.\neauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq s2 k))  as [S [A B]].\ninv B.\neapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq (Sloop s0) k))  as [S [A B]].\ninv B.\neapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_FUN.\neauto.\ntraceEq.\nintros.\ninv H0.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply H.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_plus step ge (Callstate fd args k m) T) : forall (sp : val) (e : env) (m : mem) (s : stmt) (T : traceinf)\n  (f : function) (k : cont),\nexecinf_stmt ge f sp e m s T -> forever_plus step ge (State f s k sp e m) T.","conclusion":"forall (sp : val) (e : env) (m : mem) (s : stmt) (T : traceinf)\n  (f : function) (k : cont),\nexecinf_stmt ge f sp e m s T -> forever_plus step ge (State f s k sp e m) T","hypotheses":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_plus step ge (Callstate fd args k m) T)","proofString":"cofix CIH_STMT.\nintros.\ninv H.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_FUN.\neauto.\ntraceEq.\neapply forever_plus_intro with (s2 := State f (if b then s1 else s2) k sp e m).\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\nconstructor.\napply CIH_STMT.\neauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq s2 k))  as [S [A B]].\ninv B.\neapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq (Sloop s0) k))  as [S [A B]].\ninv B.\neapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_FUN.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_plus step ge (Callstate fd args k m) T) (CIH_STMT : forall (sp : val) (e : env) (m : mem) (s : stmt) (T : traceinf)\n  (f : function) (k : cont),\nexecinf_stmt ge f sp e m s T -> forever_plus step ge (State f s k sp e m) T) : forall (sp : val) (e : env) (m : mem) (s : stmt) (T : traceinf)\n  (f : function) (k : cont),\nexecinf_stmt ge f sp e m s T -> forever_plus step ge (State f s k sp e m) T.","conclusion":"forall (sp : val) (e : env) (m : mem) (s : stmt) (T : traceinf)\n  (f : function) (k : cont),\nexecinf_stmt ge f sp e m s T -> forever_plus step ge (State f s k sp e m) T","hypotheses":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_plus step ge (Callstate fd args k m) T) (CIH_STMT : forall (sp : val) (e : env) (m : mem) (s : stmt) (T : traceinf)\n  (f : function) (k : cont),\nexecinf_stmt ge f sp e m s T -> forever_plus step ge (State f s k sp e m) T)","proofString":"intros.\ninv H.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_FUN.\neauto.\ntraceEq.\neapply forever_plus_intro with (s2 := State f (if b then s1 else s2) k sp e m).\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\nconstructor.\napply CIH_STMT.\neauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq s2 k))  as [S [A B]].\ninv B.\neapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq (Sloop s0) k))  as [S [A B]].\ninv B.\neapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_FUN.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_plus step ge (Callstate fd args k0 m0) T0) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s0 : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s0 T0 ->\nforever_plus step ge (State f0 s0 k0 sp0 e0 m0) T0) (sp : val) (e : env) (m : mem) (s : stmt) (T : traceinf) (f : function) (k : cont) (H : execinf_stmt ge f sp e m s T) : forever_plus step ge (State f s k sp e m) T.","conclusion":"forever_plus step ge (State f s k sp e m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_plus step ge (Callstate fd args k0 m0) T0) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s0 : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s0 T0 ->\nforever_plus step ge (State f0 s0 k0 sp0 e0 m0) T0) (sp : val) (e : env) (m : mem) (s : stmt) (T : traceinf) (f : function) (k : cont) (H : execinf_stmt ge f sp e m s T)","proofString":"inv H.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_FUN.\neauto.\ntraceEq.\neapply forever_plus_intro with (s2 := State f (if b then s1 else s2) k sp e m).\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\nconstructor.\napply CIH_STMT.\neauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq s2 k))  as [S [A B]].\ninv B.\neapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq.\ndestruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq (Sloop s0) k))  as [S [A B]].\ninv B.\neapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_FUN.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd0 : fundef) (args : list val) \n  (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd0 args T0 ->\nforever_plus step ge (Callstate fd0 args k0 m0) T0) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T0) (sp : val) (e : env) (m : mem) (T : traceinf) (f : function) (k : cont) (optid : option ident) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (H0 : eval_expr ge sp e m a vf) (H1 : eval_exprlist ge sp e m bl vargs) (H2 : Genv.find_funct ge vf = Some fd) (H4 : evalinf_funcall ge m fd vargs T) : forever_plus step ge (State f (Scall optid (funsig fd) a bl) k sp e m) T.","conclusion":"forever_plus step ge (State f (Scall optid (funsig fd) a bl) k sp e m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd0 : fundef) (args : list val) \n  (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd0 args T0 ->\nforever_plus step ge (Callstate fd0 args k0 m0) T0) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T0) (sp : val) (e : env) (m : mem) (T : traceinf) (f : function) (k : cont) (optid : option ident) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (H0 : eval_expr ge sp e m a vf) (H1 : eval_exprlist ge sp e m bl vargs) (H2 : Genv.find_funct ge vf = Some fd) (H4 : evalinf_funcall ge m fd vargs T)","proofString":"eapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_FUN.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_plus step ge (Callstate fd args k0 m0) T0) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T0) (sp : val) (e : env) (m : mem) (T : traceinf) (f : function) (k : cont) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (H0 : eval_expr ge sp e m a v) (H1 : Val.bool_of_val v b) (H2 : execinf_stmt ge f sp e m (if b then s1 else s2) T) : forever_plus step ge (State f (Sifthenelse a s1 s2) k sp e m) T.","conclusion":"forever_plus step ge (State f (Sifthenelse a s1 s2) k sp e m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_plus step ge (Callstate fd args k0 m0) T0) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T0) (sp : val) (e : env) (m : mem) (T : traceinf) (f : function) (k : cont) (a : expr) (s1 s2 : stmt) (v : val) (b : bool) (H0 : eval_expr ge sp e m a v) (H1 : Val.bool_of_val v b) (H2 : execinf_stmt ge f sp e m (if b then s1 else s2) T)","proofString":"eapply forever_plus_intro with (s2 := State f (if b then s1 else s2) k sp e m).\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_plus step ge (Callstate fd args k0 m0) T0) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T0) (sp : val) (e : env) (m : mem) (T : traceinf) (f : function) (k : cont) (s1 s2 : stmt) (H0 : execinf_stmt ge f sp e m s1 T) : forever_plus step ge (State f (Sseq s1 s2) k sp e m) T.","conclusion":"forever_plus step ge (State f (Sseq s1 s2) k sp e m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_plus step ge (Callstate fd args k0 m0) T0) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T0) (sp : val) (e : env) (m : mem) (T : traceinf) (f : function) (k : cont) (s1 s2 : stmt) (H0 : execinf_stmt ge f sp e m s1 T)","proofString":"eapply forever_plus_intro.\napply plus_one.\nconstructor.\napply CIH_STMT.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_plus step ge (Callstate fd args k0 m0) T) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T) (sp : val) (e : env) (m : mem) (f : function) (k : cont) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : traceinf) (H0 : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H1 : execinf_stmt ge f sp e1 m1 s2 t2) : forever_plus step ge (State f (Sseq s1 s2) k sp e m) (t1 *** t2).","conclusion":"forever_plus step ge (State f (Sseq s1 s2) k sp e m) (t1 *** t2)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_plus step ge (Callstate fd args k0 m0) T) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T) (sp : val) (e : env) (m : mem) (f : function) (k : cont) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : traceinf) (H0 : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H1 : execinf_stmt ge f sp e1 m1 s2 t2)","proofString":"destruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq s2 k))  as [S [A B]].\ninv B.\neapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_plus step ge (Callstate fd args k0 m0) T) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T) (sp : val) (e : env) (m : mem) (f : function) (k : cont) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : traceinf) (H0 : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H1 : execinf_stmt ge f sp e1 m1 s2 t2) (S : state) (A : star step ge (State f s1 (Kseq s2 k) sp e m) t1 S) (B : outcome_state_match sp e1 m1 f (Kseq s2 k) Out_normal S) : forever_plus step ge (State f (Sseq s1 s2) k sp e m) (t1 *** t2).","conclusion":"forever_plus step ge (State f (Sseq s1 s2) k sp e m) (t1 *** t2)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_plus step ge (Callstate fd args k0 m0) T) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T) (sp : val) (e : env) (m : mem) (f : function) (k : cont) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : traceinf) (H0 : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H1 : execinf_stmt ge f sp e1 m1 s2 t2) (S : state) (A : star step ge (State f s1 (Kseq s2 k) sp e m) t1 S) (B : outcome_state_match sp e1 m1 f (Kseq s2 k) Out_normal S)","proofString":"inv B.\neapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_plus step ge (Callstate fd args k0 m0) T) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T) (sp : val) (e : env) (m : mem) (f : function) (k : cont) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : traceinf) (H0 : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H1 : execinf_stmt ge f sp e1 m1 s2 t2) (A : star step ge (State f s1 (Kseq s2 k) sp e m) t1\n  (State f Sskip (Kseq s2 k) sp e1 m1)) : forever_plus step ge (State f (Sseq s1 s2) k sp e m) (t1 *** t2).","conclusion":"forever_plus step ge (State f (Sseq s1 s2) k sp e m) (t1 *** t2)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_plus step ge (Callstate fd args k0 m0) T) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T) (sp : val) (e : env) (m : mem) (f : function) (k : cont) (s1 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (s2 : stmt) (t2 : traceinf) (H0 : exec_stmt ge f sp e m s1 t1 e1 m1 Out_normal) (H1 : execinf_stmt ge f sp e1 m1 s2 t2) (A : star step ge (State f s1 (Kseq s2 k) sp e m) t1\n  (State f Sskip (Kseq s2 k) sp e1 m1))","proofString":"eapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_plus step ge (Callstate fd args k0 m0) T0) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T0) (sp : val) (e : env) (m : mem) (T : traceinf) (f : function) (k : cont) (s0 : stmt) (H0 : execinf_stmt ge f sp e m s0 T) : forever_plus step ge (State f (Sloop s0) k sp e m) T.","conclusion":"forever_plus step ge (State f (Sloop s0) k sp e m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_plus step ge (Callstate fd args k0 m0) T0) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T0) (sp : val) (e : env) (m : mem) (T : traceinf) (f : function) (k : cont) (s0 : stmt) (H0 : execinf_stmt ge f sp e m s0 T)","proofString":"eapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_plus step ge (Callstate fd args k0 m0) T) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T) (sp : val) (e : env) (m : mem) (f : function) (k : cont) (s0 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt ge f sp e m s0 t1 e1 m1 Out_normal) (H1 : execinf_stmt ge f sp e1 m1 (Sloop s0) t2) : forever_plus step ge (State f (Sloop s0) k sp e m) (t1 *** t2).","conclusion":"forever_plus step ge (State f (Sloop s0) k sp e m) (t1 *** t2)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_plus step ge (Callstate fd args k0 m0) T) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T) (sp : val) (e : env) (m : mem) (f : function) (k : cont) (s0 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt ge f sp e m s0 t1 e1 m1 Out_normal) (H1 : execinf_stmt ge f sp e1 m1 (Sloop s0) t2)","proofString":"destruct (exec_stmt_steps _ _ _ _ _ _ _ _ _ H0 (Kseq (Sloop s0) k))  as [S [A B]].\ninv B.\neapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_plus step ge (Callstate fd args k0 m0) T) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T) (sp : val) (e : env) (m : mem) (f : function) (k : cont) (s0 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt ge f sp e m s0 t1 e1 m1 Out_normal) (H1 : execinf_stmt ge f sp e1 m1 (Sloop s0) t2) (S : state) (A : star step ge (State f s0 (Kseq (Sloop s0) k) sp e m) t1 S) (B : outcome_state_match sp e1 m1 f (Kseq (Sloop s0) k) Out_normal S) : forever_plus step ge (State f (Sloop s0) k sp e m) (t1 *** t2).","conclusion":"forever_plus step ge (State f (Sloop s0) k sp e m) (t1 *** t2)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_plus step ge (Callstate fd args k0 m0) T) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T) (sp : val) (e : env) (m : mem) (f : function) (k : cont) (s0 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt ge f sp e m s0 t1 e1 m1 Out_normal) (H1 : execinf_stmt ge f sp e1 m1 (Sloop s0) t2) (S : state) (A : star step ge (State f s0 (Kseq (Sloop s0) k) sp e m) t1 S) (B : outcome_state_match sp e1 m1 f (Kseq (Sloop s0) k) Out_normal S)","proofString":"inv B.\neapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_plus step ge (Callstate fd args k0 m0) T) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T) (sp : val) (e : env) (m : mem) (f : function) (k : cont) (s0 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt ge f sp e m s0 t1 e1 m1 Out_normal) (H1 : execinf_stmt ge f sp e1 m1 (Sloop s0) t2) (A : star step ge (State f s0 (Kseq (Sloop s0) k) sp e m) t1\n  (State f Sskip (Kseq (Sloop s0) k) sp e1 m1)) : forever_plus step ge (State f (Sloop s0) k sp e m) (t1 *** t2).","conclusion":"forever_plus step ge (State f (Sloop s0) k sp e m) (t1 *** t2)","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T ->\nforever_plus step ge (Callstate fd args k0 m0) T) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T) (sp : val) (e : env) (m : mem) (f : function) (k : cont) (s0 : stmt) (t1 : trace) (e1 : env) (m1 : mem) (t2 : traceinf) (H0 : exec_stmt ge f sp e m s0 t1 e1 m1 Out_normal) (H1 : execinf_stmt ge f sp e1 m1 (Sloop s0) t2) (A : star step ge (State f s0 (Kseq (Sloop s0) k) sp e m) t1\n  (State f Sskip (Kseq (Sloop s0) k) sp e1 m1))","proofString":"eapply forever_plus_intro.\neapply plus_left.\nconstructor.\neapply star_right.\neexact A.\nconstructor.\nreflexivity.\nreflexivity.\napply CIH_STMT.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_plus step ge (Callstate fd args k0 m0) T0) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T0) (sp : val) (e : env) (m : mem) (T : traceinf) (f : function) (k : cont) (s0 : stmt) (H0 : execinf_stmt ge f sp e m s0 T) : forever_plus step ge (State f (Sblock s0) k sp e m) T.","conclusion":"forever_plus step ge (State f (Sblock s0) k sp e m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args : list val) (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args T0 ->\nforever_plus step ge (Callstate fd args k0 m0) T0) (CIH_STMT : forall (sp0 : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e0 m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp0 e0 m0) T0) (sp : val) (e : env) (m : mem) (T : traceinf) (f : function) (k : cont) (s0 : stmt) (H0 : execinf_stmt ge f sp e m s0 T)","proofString":"eapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_STMT.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd0 : fundef) (args : list val) \n  (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd0 args T0 ->\nforever_plus step ge (Callstate fd0 args k0 m0) T0) (CIH_STMT : forall (sp : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp e0 m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp e0 m0) T0) (e : env) (m : mem) (T : traceinf) (f : function) (k : cont) (sp0 : block) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (m' : mem) (H0 : eval_expr ge (Vptr sp0 Ptrofs.zero) e m a vf) (H1 : eval_exprlist ge (Vptr sp0 Ptrofs.zero) e m bl vargs) (H2 : Genv.find_funct ge vf = Some fd) (H4 : Mem.free m sp0 0 (fn_stackspace f) = Some m') (H5 : evalinf_funcall ge m' fd vargs T) : forever_plus step ge\n  (State f (Stailcall (funsig fd) a bl) k (Vptr sp0 Ptrofs.zero) e m) T.","conclusion":"forever_plus step ge\n  (State f (Stailcall (funsig fd) a bl) k (Vptr sp0 Ptrofs.zero) e m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd0 : fundef) (args : list val) \n  (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd0 args T0 ->\nforever_plus step ge (Callstate fd0 args k0 m0) T0) (CIH_STMT : forall (sp : val) (e0 : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp e0 m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp e0 m0) T0) (e : env) (m : mem) (T : traceinf) (f : function) (k : cont) (sp0 : block) (a : expr) (bl : list expr) (vf : val) (vargs : list val) (fd : fundef) (m' : mem) (H0 : eval_expr ge (Vptr sp0 Ptrofs.zero) e m a vf) (H1 : eval_exprlist ge (Vptr sp0 Ptrofs.zero) e m bl vargs) (H2 : Genv.find_funct ge vf = Some fd) (H4 : Mem.free m sp0 0 (fn_stackspace f) = Some m') (H5 : evalinf_funcall ge m' fd vargs T)","proofString":"eapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply CIH_FUN.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_plus step ge (Callstate fd args k m) T) (H : forall (sp : val) (e : env) (m : mem) (s : stmt) (T : traceinf)\n  (f : function) (k : cont),\nexecinf_stmt ge f sp e m s T -> forever_plus step ge (State f s k sp e m) T) : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_plus step ge (Callstate fd args k m) T.","conclusion":"forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_plus step ge (Callstate fd args k m) T","hypotheses":"(CIH_FUN : forall (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont),\nevalinf_funcall ge m fd args T ->\nforever_plus step ge (Callstate fd args k m) T) (H : forall (sp : val) (e : env) (m : mem) (s : stmt) (T : traceinf)\n  (f : function) (k : cont),\nexecinf_stmt ge f sp e m s T -> forever_plus step ge (State f s k sp e m) T)","proofString":"intros.\ninv H0.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply H.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd0 : fundef) (args0 : list val) \n  (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd0 args0 T0 ->\nforever_plus step ge (Callstate fd0 args0 k0 m0) T0) (H : forall (sp : val) (e : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f : function) (k0 : cont),\nexecinf_stmt ge f sp e m0 s T0 ->\nforever_plus step ge (State f s k0 sp e m0) T0) (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont) (H0 : evalinf_funcall ge m fd args T) : forever_plus step ge (Callstate fd args k m) T.","conclusion":"forever_plus step ge (Callstate fd args k m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd0 : fundef) (args0 : list val) \n  (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd0 args0 T0 ->\nforever_plus step ge (Callstate fd0 args0 k0 m0) T0) (H : forall (sp : val) (e : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f : function) (k0 : cont),\nexecinf_stmt ge f sp e m0 s T0 ->\nforever_plus step ge (State f s k0 sp e m0) T0) (m : mem) (fd : fundef) (args : list val) (T : traceinf) (k : cont) (H0 : evalinf_funcall ge m fd args T)","proofString":"inv H0.\neapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply H.\neauto.\ntraceEq."},{"statement":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args0 : list val) \n  (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args0 T0 ->\nforever_plus step ge (Callstate fd args0 k0 m0) T0) (H : forall (sp0 : val) (e : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp0 e m0) T0) (m : mem) (args : list val) (T : traceinf) (k : cont) (f : function) (m1 : Mem.mem') (sp : block) (H1 : list_forall2 Val.has_argtype args (sig_args (fn_sig f))) (H2 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H4 : execinf_stmt ge f (Vptr sp Ptrofs.zero)\n  (set_locals (fn_vars f) (set_params args (fn_params f))) m1 \n  (fn_body f) T) : forever_plus step ge (Callstate (Internal f) args k m) T.","conclusion":"forever_plus step ge (Callstate (Internal f) args k m) T","hypotheses":"(CIH_FUN : forall (m0 : mem) (fd : fundef) (args0 : list val) \n  (T0 : traceinf) (k0 : cont),\nevalinf_funcall ge m0 fd args0 T0 ->\nforever_plus step ge (Callstate fd args0 k0 m0) T0) (H : forall (sp0 : val) (e : env) (m0 : mem) (s : stmt) \n  (T0 : traceinf) (f0 : function) (k0 : cont),\nexecinf_stmt ge f0 sp0 e m0 s T0 ->\nforever_plus step ge (State f0 s k0 sp0 e m0) T0) (m : mem) (args : list val) (T : traceinf) (k : cont) (f : function) (m1 : Mem.mem') (sp : block) (H1 : list_forall2 Val.has_argtype args (sig_args (fn_sig f))) (H2 : Mem.alloc m 0 (fn_stackspace f) = (m1, sp)) (H4 : execinf_stmt ge f (Vptr sp Ptrofs.zero)\n  (set_locals (fn_vars f) (set_params args (fn_params f))) m1 \n  (fn_body f) T)","proofString":"eapply forever_plus_intro.\napply plus_one.\neconstructor; eauto.\napply H.\neauto.\ntraceEq."},{"statement":"(t : trace) (r : int) (H : bigstep_terminates (bigstep_semantics prog) t r) : exists s1 s2 : Smallstep.state (semantics prog),\n  Smallstep.initial_state (semantics prog) s1 /\\\n  Star (semantics prog) s1 t s2 /\\\n  Smallstep.final_state (semantics prog) s2 r.","conclusion":"exists s1 s2 : Smallstep.state (semantics prog),\n  Smallstep.initial_state (semantics prog) s1 /\\\n  Star (semantics prog) s1 t s2 /\\\n  Smallstep.final_state (semantics prog) s2 r","hypotheses":"(t : trace) (r : int) (H : bigstep_terminates (bigstep_semantics prog) t r)","proofString":"inv H.\neconstructor; econstructor.\nsplit.\neconstructor; eauto.\nsplit.\napply eval_funcall_steps.\neauto.\nred; auto.\neconstructor."},{"statement":"(t : trace) (r : int) (b : block) (f : fundef) (m0 m : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : eval_funcall ge0 m0 f nil t m (Vint r)) : is_call_cont Kstop.","conclusion":"is_call_cont Kstop","hypotheses":"(t : trace) (r : int) (b : block) (f : fundef) (m0 m : mem) (ge0 : Genv.t fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol ge0 (prog_main prog) = Some b) (H2 : Genv.find_funct_ptr ge0 b = Some f) (H3 : funsig f = signature_main) (H4 : eval_funcall ge0 m0 f nil t m (Vint r))","proofString":"red; auto."},{"statement":"(T : traceinf) (H : bigstep_diverges (bigstep_semantics prog) T) : exists s1 : Smallstep.state (semantics prog),\n  Smallstep.initial_state (semantics prog) s1 /\\\n  forever (Smallstep.step (semantics prog)) (globalenv (semantics prog)) s1 T.","conclusion":"exists s1 : Smallstep.state (semantics prog),\n  Smallstep.initial_state (semantics prog) s1 /\\\n  forever (Smallstep.step (semantics prog)) (globalenv (semantics prog)) s1 T","hypotheses":"(T : traceinf) (H : bigstep_diverges (bigstep_semantics prog) T)","proofString":"inv H.\neconstructor.\nsplit.\neconstructor; eauto.\neapply forever_plus_forever.\neapply evalinf_funcall_forever; eauto."}]}