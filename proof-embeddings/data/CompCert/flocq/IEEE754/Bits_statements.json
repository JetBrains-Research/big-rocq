{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/IEEE754/Bits.v","fileSamples":[{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) : (0 <= join_bits s m e < 2 ^ (mw + ew + 1))%Z.","proofString":"assert (0 <= mw)%Z as Hmw.\ndestruct mw as [|mw'|mw'] ; try easy.\nclear -Hm ; simpl in Hm ; lia.\nassert (0 <= ew)%Z as Hew.\ndestruct ew as [|ew'|ew'] ; try easy.\nclear -He ; simpl in He ; lia.\nunfold join_bits.\nrewrite Z.shiftl_mul_pow2 by easy.\nsplit.\napply (Zplus_le_compat 0 _ 0) with (2 := proj1 Hm).\nrewrite <- (Zmult_0_l (2^mw)).\napply Zmult_le_compat_r.\ncase s.\nclear -He ; lia.\nnow rewrite Zmult_0_l.\nclear -Hm ; lia.\napply Z.lt_le_trans with (((if s then 2 ^ ew else 0) + e + 1) * 2 ^ mw)%Z.\nrewrite (Zmult_plus_distr_l _ 1).\napply Zplus_lt_compat_l.\nnow rewrite Zmult_1_l.\nrewrite <- (Zplus_assoc mw), (Zplus_comm mw), Zpower_plus.\napply Zmult_le_compat_r.\nrewrite Zpower_plus by easy.\nchange (2^1)%Z with 2%Z.\ncase s ; clear -He ; lia.\nclear -Hm ; lia.\nclear -Hew ; lia.\neasy."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) : (0 <= mw)%Z.","proofString":"destruct mw as [|mw'|mw'] ; try easy.\nclear -Hm ; simpl in Hm ; lia."},{"statement":"(s : bool) (m e : Z) (mw' : positive) (Hm : (0 <= m < 2 ^ Z.neg mw')%Z) (He : (0 <= e < 2 ^ ew)%Z) : (0 <= Z.neg mw')%Z.","proofString":"clear -Hm ; simpl in Hm ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) : (0 <= join_bits s m e < 2 ^ (mw + ew + 1))%Z.","proofString":"assert (0 <= ew)%Z as Hew.\ndestruct ew as [|ew'|ew'] ; try easy.\nclear -He ; simpl in He ; lia.\nunfold join_bits.\nrewrite Z.shiftl_mul_pow2 by easy.\nsplit.\napply (Zplus_le_compat 0 _ 0) with (2 := proj1 Hm).\nrewrite <- (Zmult_0_l (2^mw)).\napply Zmult_le_compat_r.\ncase s.\nclear -He ; lia.\nnow rewrite Zmult_0_l.\nclear -Hm ; lia.\napply Z.lt_le_trans with (((if s then 2 ^ ew else 0) + e + 1) * 2 ^ mw)%Z.\nrewrite (Zmult_plus_distr_l _ 1).\napply Zplus_lt_compat_l.\nnow rewrite Zmult_1_l.\nrewrite <- (Zplus_assoc mw), (Zplus_comm mw), Zpower_plus.\napply Zmult_le_compat_r.\nrewrite Zpower_plus by easy.\nchange (2^1)%Z with 2%Z.\ncase s ; clear -He ; lia.\nclear -Hm ; lia.\nclear -Hew ; lia.\neasy."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) : (0 <= ew)%Z.","proofString":"destruct ew as [|ew'|ew'] ; try easy.\nclear -He ; simpl in He ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (ew' : positive) (He : (0 <= e < 2 ^ Z.neg ew')%Z) (Hmw : (0 <= mw)%Z) : (0 <= Z.neg ew')%Z.","proofString":"clear -He ; simpl in He ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (0 <= join_bits s m e < 2 ^ (mw + ew + 1))%Z.","proofString":"unfold join_bits.\nrewrite Z.shiftl_mul_pow2 by easy.\nsplit.\napply (Zplus_le_compat 0 _ 0) with (2 := proj1 Hm).\nrewrite <- (Zmult_0_l (2^mw)).\napply Zmult_le_compat_r.\ncase s.\nclear -He ; lia.\nnow rewrite Zmult_0_l.\nclear -Hm ; lia.\napply Z.lt_le_trans with (((if s then 2 ^ ew else 0) + e + 1) * 2 ^ mw)%Z.\nrewrite (Zmult_plus_distr_l _ 1).\napply Zplus_lt_compat_l.\nnow rewrite Zmult_1_l.\nrewrite <- (Zplus_assoc mw), (Zplus_comm mw), Zpower_plus.\napply Zmult_le_compat_r.\nrewrite Zpower_plus by easy.\nchange (2^1)%Z with 2%Z.\ncase s ; clear -He ; lia.\nclear -Hm ; lia.\nclear -Hew ; lia.\neasy."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (0 <= Z.shiftl ((if s then 2 ^ ew else 0) + e) mw + m < 2 ^ (mw + ew + 1))%Z.","proofString":"rewrite Z.shiftl_mul_pow2 by easy.\nsplit.\napply (Zplus_le_compat 0 _ 0) with (2 := proj1 Hm).\nrewrite <- (Zmult_0_l (2^mw)).\napply Zmult_le_compat_r.\ncase s.\nclear -He ; lia.\nnow rewrite Zmult_0_l.\nclear -Hm ; lia.\napply Z.lt_le_trans with (((if s then 2 ^ ew else 0) + e + 1) * 2 ^ mw)%Z.\nrewrite (Zmult_plus_distr_l _ 1).\napply Zplus_lt_compat_l.\nnow rewrite Zmult_1_l.\nrewrite <- (Zplus_assoc mw), (Zplus_comm mw), Zpower_plus.\napply Zmult_le_compat_r.\nrewrite Zpower_plus by easy.\nchange (2^1)%Z with 2%Z.\ncase s ; clear -He ; lia.\nclear -Hm ; lia.\nclear -Hew ; lia.\neasy."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (0 <= ((if s then 2 ^ ew else 0) + e) * 2 ^ mw + m < 2 ^ (mw + ew + 1))%Z.","proofString":"split.\napply (Zplus_le_compat 0 _ 0) with (2 := proj1 Hm).\nrewrite <- (Zmult_0_l (2^mw)).\napply Zmult_le_compat_r.\ncase s.\nclear -He ; lia.\nnow rewrite Zmult_0_l.\nclear -Hm ; lia.\napply Z.lt_le_trans with (((if s then 2 ^ ew else 0) + e + 1) * 2 ^ mw)%Z.\nrewrite (Zmult_plus_distr_l _ 1).\napply Zplus_lt_compat_l.\nnow rewrite Zmult_1_l.\nrewrite <- (Zplus_assoc mw), (Zplus_comm mw), Zpower_plus.\napply Zmult_le_compat_r.\nrewrite Zpower_plus by easy.\nchange (2^1)%Z with 2%Z.\ncase s ; clear -He ; lia.\nclear -Hm ; lia.\nclear -Hew ; lia.\neasy."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) : split_bits (join_bits s m e) = (s, m, e).","proofString":"assert (0 <= mw)%Z as Hmw.\ndestruct mw as [|mw'|mw'] ; try easy.\nclear -Hm ; simpl in Hm ; lia.\nassert (0 <= ew)%Z as Hew.\ndestruct ew as [|ew'|ew'] ; try easy.\nclear -He ; simpl in He ; lia.\nunfold split_bits, join_bits.\nrewrite Z.shiftl_mul_pow2 by easy.\napply f_equal2 ; [apply f_equal2|].\ncase s.\napply Zle_bool_true.\napply Zle_0_minus_le.\nring_simplify.\napply Zplus_le_0_compat.\napply Zmult_le_0_compat.\napply He.\nclear -Hm ; lia.\napply Hm.\napply Zle_bool_false.\napply Zplus_lt_reg_l with (2^mw * (-e))%Z.\nreplace (2 ^ mw * - e + ((0 + e) * 2 ^ mw + m))%Z with (m * 1)%Z by ring.\nrewrite <- Zmult_plus_distr_r.\napply Z.lt_le_trans with (2^mw * 1)%Z.\nnow apply Zmult_lt_compat_r.\napply Zmult_le_compat_l.\nclear -He ; lia.\nclear -Hm ; lia.\nrewrite Zplus_comm.\nrewrite Z_mod_plus_full.\nnow apply Zmod_small.\nrewrite Z_div_plus_full_l by (clear -Hm ; lia).\nrewrite Zdiv_small with (1 := Hm).\nrewrite Zplus_0_r.\ncase s.\nreplace (2^ew + e)%Z with (e + 1 * 2^ew)%Z by ring.\nrewrite Z_mod_plus_full.\nnow apply Zmod_small.\nnow apply Zmod_small."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) : (0 <= mw)%Z.","proofString":"destruct mw as [|mw'|mw'] ; try easy.\nclear -Hm ; simpl in Hm ; lia."},{"statement":"(s : bool) (m e : Z) (mw' : positive) (Hm : (0 <= m < 2 ^ Z.neg mw')%Z) (He : (0 <= e < 2 ^ ew)%Z) : (0 <= Z.neg mw')%Z.","proofString":"clear -Hm ; simpl in Hm ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) : split_bits (join_bits s m e) = (s, m, e).","proofString":"assert (0 <= ew)%Z as Hew.\ndestruct ew as [|ew'|ew'] ; try easy.\nclear -He ; simpl in He ; lia.\nunfold split_bits, join_bits.\nrewrite Z.shiftl_mul_pow2 by easy.\napply f_equal2 ; [apply f_equal2|].\ncase s.\napply Zle_bool_true.\napply Zle_0_minus_le.\nring_simplify.\napply Zplus_le_0_compat.\napply Zmult_le_0_compat.\napply He.\nclear -Hm ; lia.\napply Hm.\napply Zle_bool_false.\napply Zplus_lt_reg_l with (2^mw * (-e))%Z.\nreplace (2 ^ mw * - e + ((0 + e) * 2 ^ mw + m))%Z with (m * 1)%Z by ring.\nrewrite <- Zmult_plus_distr_r.\napply Z.lt_le_trans with (2^mw * 1)%Z.\nnow apply Zmult_lt_compat_r.\napply Zmult_le_compat_l.\nclear -He ; lia.\nclear -Hm ; lia.\nrewrite Zplus_comm.\nrewrite Z_mod_plus_full.\nnow apply Zmod_small.\nrewrite Z_div_plus_full_l by (clear -Hm ; lia).\nrewrite Zdiv_small with (1 := Hm).\nrewrite Zplus_0_r.\ncase s.\nreplace (2^ew + e)%Z with (e + 1 * 2^ew)%Z by ring.\nrewrite Z_mod_plus_full.\nnow apply Zmod_small.\nnow apply Zmod_small."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) : (0 <= ew)%Z.","proofString":"destruct ew as [|ew'|ew'] ; try easy.\nclear -He ; simpl in He ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (ew' : positive) (He : (0 <= e < 2 ^ Z.neg ew')%Z) (Hmw : (0 <= mw)%Z) : (0 <= Z.neg ew')%Z.","proofString":"clear -He ; simpl in He ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : split_bits (join_bits s m e) = (s, m, e).","proofString":"unfold split_bits, join_bits.\nrewrite Z.shiftl_mul_pow2 by easy.\napply f_equal2 ; [apply f_equal2|].\ncase s.\napply Zle_bool_true.\napply Zle_0_minus_le.\nring_simplify.\napply Zplus_le_0_compat.\napply Zmult_le_0_compat.\napply He.\nclear -Hm ; lia.\napply Hm.\napply Zle_bool_false.\napply Zplus_lt_reg_l with (2^mw * (-e))%Z.\nreplace (2 ^ mw * - e + ((0 + e) * 2 ^ mw + m))%Z with (m * 1)%Z by ring.\nrewrite <- Zmult_plus_distr_r.\napply Z.lt_le_trans with (2^mw * 1)%Z.\nnow apply Zmult_lt_compat_r.\napply Zmult_le_compat_l.\nclear -He ; lia.\nclear -Hm ; lia.\nrewrite Zplus_comm.\nrewrite Z_mod_plus_full.\nnow apply Zmod_small.\nrewrite Z_div_plus_full_l by (clear -Hm ; lia).\nrewrite Zdiv_small with (1 := Hm).\nrewrite Zplus_0_r.\ncase s.\nreplace (2^ew + e)%Z with (e + 1 * 2^ew)%Z by ring.\nrewrite Z_mod_plus_full.\nnow apply Zmod_small.\nnow apply Zmod_small."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : ((2 ^ mw * 2 ^ ew <=? Z.shiftl ((if s then 2 ^ ew else 0) + e) mw + m)%Z,\n ((Z.shiftl ((if s then 2 ^ ew else 0) + e) mw + m) mod 2 ^ mw)%Z,\n (((Z.shiftl ((if s then 2 ^ ew else 0) + e) mw + m) / 2 ^ mw) mod 2 ^ ew)%Z) =\n(s, m, e).","proofString":"rewrite Z.shiftl_mul_pow2 by easy.\napply f_equal2 ; [apply f_equal2|].\ncase s.\napply Zle_bool_true.\napply Zle_0_minus_le.\nring_simplify.\napply Zplus_le_0_compat.\napply Zmult_le_0_compat.\napply He.\nclear -Hm ; lia.\napply Hm.\napply Zle_bool_false.\napply Zplus_lt_reg_l with (2^mw * (-e))%Z.\nreplace (2 ^ mw * - e + ((0 + e) * 2 ^ mw + m))%Z with (m * 1)%Z by ring.\nrewrite <- Zmult_plus_distr_r.\napply Z.lt_le_trans with (2^mw * 1)%Z.\nnow apply Zmult_lt_compat_r.\napply Zmult_le_compat_l.\nclear -He ; lia.\nclear -Hm ; lia.\nrewrite Zplus_comm.\nrewrite Z_mod_plus_full.\nnow apply Zmod_small.\nrewrite Z_div_plus_full_l by (clear -Hm ; lia).\nrewrite Zdiv_small with (1 := Hm).\nrewrite Zplus_0_r.\ncase s.\nreplace (2^ew + e)%Z with (e + 1 * 2^ew)%Z by ring.\nrewrite Z_mod_plus_full.\nnow apply Zmod_small.\nnow apply Zmod_small."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : ((2 ^ mw * 2 ^ ew <=? ((if s then 2 ^ ew else 0) + e) * 2 ^ mw + m)%Z,\n ((((if s then 2 ^ ew else 0) + e) * 2 ^ mw + m) mod 2 ^ mw)%Z,\n (((((if s then 2 ^ ew else 0) + e) * 2 ^ mw + m) / 2 ^ mw) mod 2 ^ ew)%Z) =\n(s, m, e).","proofString":"apply f_equal2 ; [apply f_equal2|].\ncase s.\napply Zle_bool_true.\napply Zle_0_minus_le.\nring_simplify.\napply Zplus_le_0_compat.\napply Zmult_le_0_compat.\napply He.\nclear -Hm ; lia.\napply Hm.\napply Zle_bool_false.\napply Zplus_lt_reg_l with (2^mw * (-e))%Z.\nreplace (2 ^ mw * - e + ((0 + e) * 2 ^ mw + m))%Z with (m * 1)%Z by ring.\nrewrite <- Zmult_plus_distr_r.\napply Z.lt_le_trans with (2^mw * 1)%Z.\nnow apply Zmult_lt_compat_r.\napply Zmult_le_compat_l.\nclear -He ; lia.\nclear -Hm ; lia.\nrewrite Zplus_comm.\nrewrite Z_mod_plus_full.\nnow apply Zmod_small.\nrewrite Z_div_plus_full_l by (clear -Hm ; lia).\nrewrite Zdiv_small with (1 := Hm).\nrewrite Zplus_0_r.\ncase s.\nreplace (2^ew + e)%Z with (e + 1 * 2^ew)%Z by ring.\nrewrite Z_mod_plus_full.\nnow apply Zmod_small.\nnow apply Zmod_small."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (2 ^ mw * 2 ^ ew <=? ((if s then 2 ^ ew else 0) + e) * 2 ^ mw + m)%Z = s.","proofString":"case s.\napply Zle_bool_true.\napply Zle_0_minus_le.\nring_simplify.\napply Zplus_le_0_compat.\napply Zmult_le_0_compat.\napply He.\nclear -Hm ; lia.\napply Hm.\napply Zle_bool_false.\napply Zplus_lt_reg_l with (2^mw * (-e))%Z.\nreplace (2 ^ mw * - e + ((0 + e) * 2 ^ mw + m))%Z with (m * 1)%Z by ring.\nrewrite <- Zmult_plus_distr_r.\napply Z.lt_le_trans with (2^mw * 1)%Z.\nnow apply Zmult_lt_compat_r.\napply Zmult_le_compat_l.\nclear -He ; lia.\nclear -Hm ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (2 ^ mw * 2 ^ ew <=? (2 ^ ew + e) * 2 ^ mw + m)%Z = true.","proofString":"apply Zle_bool_true.\napply Zle_0_minus_le.\nring_simplify.\napply Zplus_le_0_compat.\napply Zmult_le_0_compat.\napply He.\nclear -Hm ; lia.\napply Hm."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (2 ^ mw * 2 ^ ew <= (2 ^ ew + e) * 2 ^ mw + m)%Z.","proofString":"apply Zle_0_minus_le.\nring_simplify.\napply Zplus_le_0_compat.\napply Zmult_le_0_compat.\napply He.\nclear -Hm ; lia.\napply Hm."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (0 <= (2 ^ ew + e) * 2 ^ mw + m - 2 ^ mw * 2 ^ ew)%Z.","proofString":"ring_simplify.\napply Zplus_le_0_compat.\napply Zmult_le_0_compat.\napply He.\nclear -Hm ; lia.\napply Hm."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (0 <= e * 2 ^ mw + m)%Z.","proofString":"apply Zplus_le_0_compat.\napply Zmult_le_0_compat.\napply He.\nclear -Hm ; lia.\napply Hm."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (0 <= e * 2 ^ mw)%Z.","proofString":"apply Zmult_le_0_compat.\napply He.\nclear -Hm ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (0 <= e)%Z.","proofString":"apply He."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (0 <= 2 ^ mw)%Z.","proofString":"clear -Hm ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (0 <= m)%Z.","proofString":"apply Hm."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (2 ^ mw * 2 ^ ew <=? (0 + e) * 2 ^ mw + m)%Z = false.","proofString":"apply Zle_bool_false.\napply Zplus_lt_reg_l with (2^mw * (-e))%Z.\nreplace (2 ^ mw * - e + ((0 + e) * 2 ^ mw + m))%Z with (m * 1)%Z by ring.\nrewrite <- Zmult_plus_distr_r.\napply Z.lt_le_trans with (2^mw * 1)%Z.\nnow apply Zmult_lt_compat_r.\napply Zmult_le_compat_l.\nclear -He ; lia.\nclear -Hm ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : ((0 + e) * 2 ^ mw + m < 2 ^ mw * 2 ^ ew)%Z.","proofString":"apply Zplus_lt_reg_l with (2^mw * (-e))%Z.\nreplace (2 ^ mw * - e + ((0 + e) * 2 ^ mw + m))%Z with (m * 1)%Z by ring.\nrewrite <- Zmult_plus_distr_r.\napply Z.lt_le_trans with (2^mw * 1)%Z.\nnow apply Zmult_lt_compat_r.\napply Zmult_le_compat_l.\nclear -He ; lia.\nclear -Hm ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (2 ^ mw * - e + ((0 + e) * 2 ^ mw + m) < 2 ^ mw * - e + 2 ^ mw * 2 ^ ew)%Z.","proofString":"replace (2 ^ mw * - e + ((0 + e) * 2 ^ mw + m))%Z with (m * 1)%Z by ring.\nrewrite <- Zmult_plus_distr_r.\napply Z.lt_le_trans with (2^mw * 1)%Z.\nnow apply Zmult_lt_compat_r.\napply Zmult_le_compat_l.\nclear -He ; lia.\nclear -Hm ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (m * 1 < 2 ^ mw * - e + 2 ^ mw * 2 ^ ew)%Z.","proofString":"rewrite <- Zmult_plus_distr_r.\napply Z.lt_le_trans with (2^mw * 1)%Z.\nnow apply Zmult_lt_compat_r.\napply Zmult_le_compat_l.\nclear -He ; lia.\nclear -Hm ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (m * 1 < 2 ^ mw * (- e + 2 ^ ew))%Z.","proofString":"apply Z.lt_le_trans with (2^mw * 1)%Z.\nnow apply Zmult_lt_compat_r.\napply Zmult_le_compat_l.\nclear -He ; lia.\nclear -Hm ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (m * 1 < 2 ^ mw * 1)%Z.","proofString":"now apply Zmult_lt_compat_r."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (2 ^ mw * 1 <= 2 ^ mw * (- e + 2 ^ ew))%Z.","proofString":"apply Zmult_le_compat_l.\nclear -He ; lia.\nclear -Hm ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (1 <= - e + 2 ^ ew)%Z.","proofString":"clear -He ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (0 <= 2 ^ mw)%Z.","proofString":"clear -Hm ; lia."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : ((((if s then 2 ^ ew else 0) + e) * 2 ^ mw + m) mod 2 ^ mw)%Z = m.","proofString":"rewrite Zplus_comm.\nrewrite Z_mod_plus_full.\nnow apply Zmod_small."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : ((m + ((if s then 2 ^ ew else 0) + e) * 2 ^ mw) mod 2 ^ mw)%Z = m.","proofString":"rewrite Z_mod_plus_full.\nnow apply Zmod_small."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (m mod 2 ^ mw)%Z = m.","proofString":"now apply Zmod_small."},{"statement":"(s : bool) (m e : Z) (Hm : (0 <= m < 2 ^ mw)%Z) (He : (0 <= e < 2 ^ ew)%Z) (Hmw : (0 <= mw)%Z) (Hew : (0 <= ew)%Z) : (((((if s then 2 ^ ew else 0) + e) * 2 ^ mw + m) / 2 ^ mw) mod 2 ^ ew)%Z = e.","proofString":"rewrite Z_div_plus_full_l by (clear -Hm ; lia).\nrewrite Zdiv_small with (1 := Hm).\nrewrite Zplus_0_r.\ncase s.\nreplace (2^ew + e)%Z with (e + 1 * 2^ew)%Z by ring.\nrewrite Z_mod_plus_full.\nnow apply Zmod_small.\nnow apply Zmod_small."},{"statement":"(0 < mw + 1)%Z.","proofString":"apply Zle_lt_succ.\nnow apply Zlt_le_weak."},{"statement":"(0 <= mw)%Z.","proofString":"now apply Zlt_le_weak."},{"statement":"(0 <= mw)%Z.","proofString":"now apply Zlt_le_weak."},{"statement":"(0 <= ew)%Z.","proofString":"now apply Zlt_le_weak."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : let '(s, m, e) := split_bits x in join_bits s m e = x.","proofString":"unfold split_bits, join_bits.\nrewrite Z.shiftl_mul_pow2 by now apply Zlt_le_weak.\npattern x at 4 ; rewrite Z.div_mod with x (2^mw)%Z.\napply (f_equal (fun v => (v + _)%Z)).\nrewrite Zmult_comm.\napply f_equal.\npattern (x / (2^mw))%Z at 2 ; rewrite Z.div_mod with (x / (2^mw))%Z (2^ew)%Z.\napply (f_equal (fun v => (v + _)%Z)).\nreplace (x / 2 ^ mw / 2 ^ ew)%Z with (if Zle_bool (2 ^ mw * 2 ^ ew) x then 1 else 0)%Z.\ncase Zle_bool.\nnow rewrite Zmult_1_r.\nnow rewrite Zmult_0_r.\nrewrite Zdiv_Zdiv.\napply sym_eq.\ncase Zle_bool_spec ; intros Hs.\napply Zle_antisym.\ncut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak.\napply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l.\napply Zdiv_small.\nnow split.\nnow apply Zlt_le_weak.\nnow apply Zlt_le_weak.\nnow apply Zgt_not_eq.\nnow apply Zgt_not_eq."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (Z.shiftl\n   ((if 2 ^ mw * 2 ^ ew <=? x then 2 ^ ew else 0) + (x / 2 ^ mw) mod 2 ^ ew)\n   mw + x mod 2 ^ mw)%Z = x.","proofString":"rewrite Z.shiftl_mul_pow2 by now apply Zlt_le_weak.\npattern x at 4 ; rewrite Z.div_mod with x (2^mw)%Z.\napply (f_equal (fun v => (v + _)%Z)).\nrewrite Zmult_comm.\napply f_equal.\npattern (x / (2^mw))%Z at 2 ; rewrite Z.div_mod with (x / (2^mw))%Z (2^ew)%Z.\napply (f_equal (fun v => (v + _)%Z)).\nreplace (x / 2 ^ mw / 2 ^ ew)%Z with (if Zle_bool (2 ^ mw * 2 ^ ew) x then 1 else 0)%Z.\ncase Zle_bool.\nnow rewrite Zmult_1_r.\nnow rewrite Zmult_0_r.\nrewrite Zdiv_Zdiv.\napply sym_eq.\ncase Zle_bool_spec ; intros Hs.\napply Zle_antisym.\ncut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak.\napply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l.\napply Zdiv_small.\nnow split.\nnow apply Zlt_le_weak.\nnow apply Zlt_le_weak.\nnow apply Zgt_not_eq.\nnow apply Zgt_not_eq."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (((if 2 ^ mw * 2 ^ ew <=? x then 2 ^ ew else 0) + (x / 2 ^ mw) mod 2 ^ ew) *\n 2 ^ mw + x mod 2 ^ mw)%Z = x.","proofString":"pattern x at 4 ; rewrite Z.div_mod with x (2^mw)%Z.\napply (f_equal (fun v => (v + _)%Z)).\nrewrite Zmult_comm.\napply f_equal.\npattern (x / (2^mw))%Z at 2 ; rewrite Z.div_mod with (x / (2^mw))%Z (2^ew)%Z.\napply (f_equal (fun v => (v + _)%Z)).\nreplace (x / 2 ^ mw / 2 ^ ew)%Z with (if Zle_bool (2 ^ mw * 2 ^ ew) x then 1 else 0)%Z.\ncase Zle_bool.\nnow rewrite Zmult_1_r.\nnow rewrite Zmult_0_r.\nrewrite Zdiv_Zdiv.\napply sym_eq.\ncase Zle_bool_spec ; intros Hs.\napply Zle_antisym.\ncut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak.\napply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l.\napply Zdiv_small.\nnow split.\nnow apply Zlt_le_weak.\nnow apply Zlt_le_weak.\nnow apply Zgt_not_eq.\nnow apply Zgt_not_eq."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (((if 2 ^ mw * 2 ^ ew <=? x then 2 ^ ew else 0) + (x / 2 ^ mw) mod 2 ^ ew) *\n 2 ^ mw + x mod 2 ^ mw)%Z = (2 ^ mw * (x / 2 ^ mw) + x mod 2 ^ mw)%Z.","proofString":"apply (f_equal (fun v => (v + _)%Z)).\nrewrite Zmult_comm.\napply f_equal.\npattern (x / (2^mw))%Z at 2 ; rewrite Z.div_mod with (x / (2^mw))%Z (2^ew)%Z.\napply (f_equal (fun v => (v + _)%Z)).\nreplace (x / 2 ^ mw / 2 ^ ew)%Z with (if Zle_bool (2 ^ mw * 2 ^ ew) x then 1 else 0)%Z.\ncase Zle_bool.\nnow rewrite Zmult_1_r.\nnow rewrite Zmult_0_r.\nrewrite Zdiv_Zdiv.\napply sym_eq.\ncase Zle_bool_spec ; intros Hs.\napply Zle_antisym.\ncut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak.\napply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l.\napply Zdiv_small.\nnow split.\nnow apply Zlt_le_weak.\nnow apply Zlt_le_weak.\nnow apply Zgt_not_eq."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (((if 2 ^ mw * 2 ^ ew <=? x then 2 ^ ew else 0) + (x / 2 ^ mw) mod 2 ^ ew) *\n 2 ^ mw)%Z = (2 ^ mw * (x / 2 ^ mw))%Z.","proofString":"rewrite Zmult_comm.\napply f_equal.\npattern (x / (2^mw))%Z at 2 ; rewrite Z.div_mod with (x / (2^mw))%Z (2^ew)%Z.\napply (f_equal (fun v => (v + _)%Z)).\nreplace (x / 2 ^ mw / 2 ^ ew)%Z with (if Zle_bool (2 ^ mw * 2 ^ ew) x then 1 else 0)%Z.\ncase Zle_bool.\nnow rewrite Zmult_1_r.\nnow rewrite Zmult_0_r.\nrewrite Zdiv_Zdiv.\napply sym_eq.\ncase Zle_bool_spec ; intros Hs.\napply Zle_antisym.\ncut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak.\napply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l.\napply Zdiv_small.\nnow split.\nnow apply Zlt_le_weak.\nnow apply Zlt_le_weak.\nnow apply Zgt_not_eq."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (2 ^ mw *\n ((if 2 ^ mw * 2 ^ ew <=? x then 2 ^ ew else 0) + (x / 2 ^ mw) mod 2 ^ ew))%Z =\n(2 ^ mw * (x / 2 ^ mw))%Z.","proofString":"apply f_equal.\npattern (x / (2^mw))%Z at 2 ; rewrite Z.div_mod with (x / (2^mw))%Z (2^ew)%Z.\napply (f_equal (fun v => (v + _)%Z)).\nreplace (x / 2 ^ mw / 2 ^ ew)%Z with (if Zle_bool (2 ^ mw * 2 ^ ew) x then 1 else 0)%Z.\ncase Zle_bool.\nnow rewrite Zmult_1_r.\nnow rewrite Zmult_0_r.\nrewrite Zdiv_Zdiv.\napply sym_eq.\ncase Zle_bool_spec ; intros Hs.\napply Zle_antisym.\ncut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak.\napply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l.\napply Zdiv_small.\nnow split.\nnow apply Zlt_le_weak.\nnow apply Zlt_le_weak.\nnow apply Zgt_not_eq."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : ((if 2 ^ mw * 2 ^ ew <=? x then 2 ^ ew else 0) + (x / 2 ^ mw) mod 2 ^ ew)%Z =\n(x / 2 ^ mw)%Z.","proofString":"pattern (x / (2^mw))%Z at 2 ; rewrite Z.div_mod with (x / (2^mw))%Z (2^ew)%Z.\napply (f_equal (fun v => (v + _)%Z)).\nreplace (x / 2 ^ mw / 2 ^ ew)%Z with (if Zle_bool (2 ^ mw * 2 ^ ew) x then 1 else 0)%Z.\ncase Zle_bool.\nnow rewrite Zmult_1_r.\nnow rewrite Zmult_0_r.\nrewrite Zdiv_Zdiv.\napply sym_eq.\ncase Zle_bool_spec ; intros Hs.\napply Zle_antisym.\ncut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak.\napply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l.\napply Zdiv_small.\nnow split.\nnow apply Zlt_le_weak.\nnow apply Zlt_le_weak.\nnow apply Zgt_not_eq."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : ((if 2 ^ mw * 2 ^ ew <=? x then 2 ^ ew else 0) + (x / 2 ^ mw) mod 2 ^ ew)%Z =\n(2 ^ ew * (x / 2 ^ mw / 2 ^ ew) + (x / 2 ^ mw) mod 2 ^ ew)%Z.","proofString":"apply (f_equal (fun v => (v + _)%Z)).\nreplace (x / 2 ^ mw / 2 ^ ew)%Z with (if Zle_bool (2 ^ mw * 2 ^ ew) x then 1 else 0)%Z.\ncase Zle_bool.\nnow rewrite Zmult_1_r.\nnow rewrite Zmult_0_r.\nrewrite Zdiv_Zdiv.\napply sym_eq.\ncase Zle_bool_spec ; intros Hs.\napply Zle_antisym.\ncut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak.\napply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l.\napply Zdiv_small.\nnow split.\nnow apply Zlt_le_weak.\nnow apply Zlt_le_weak."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (if (2 ^ mw * 2 ^ ew <=? x)%Z then (2 ^ ew)%Z else 0%Z) =\n(2 ^ ew * (x / 2 ^ mw / 2 ^ ew))%Z.","proofString":"replace (x / 2 ^ mw / 2 ^ ew)%Z with (if Zle_bool (2 ^ mw * 2 ^ ew) x then 1 else 0)%Z.\ncase Zle_bool.\nnow rewrite Zmult_1_r.\nnow rewrite Zmult_0_r.\nrewrite Zdiv_Zdiv.\napply sym_eq.\ncase Zle_bool_spec ; intros Hs.\napply Zle_antisym.\ncut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak.\napply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l.\napply Zdiv_small.\nnow split.\nnow apply Zlt_le_weak.\nnow apply Zlt_le_weak."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (if (2 ^ mw * 2 ^ ew <=? x)%Z then (2 ^ ew)%Z else 0%Z) =\n(2 ^ ew * (if 2 ^ mw * 2 ^ ew <=? x then 1 else 0))%Z.","proofString":"case Zle_bool.\nnow rewrite Zmult_1_r.\nnow rewrite Zmult_0_r."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (2 ^ ew)%Z = (2 ^ ew * 1)%Z.","proofString":"now rewrite Zmult_1_r."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : 0%Z = (2 ^ ew * 0)%Z.","proofString":"now rewrite Zmult_0_r."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (if (2 ^ mw * 2 ^ ew <=? x)%Z then 1%Z else 0%Z) = (x / 2 ^ mw / 2 ^ ew)%Z.","proofString":"rewrite Zdiv_Zdiv.\napply sym_eq.\ncase Zle_bool_spec ; intros Hs.\napply Zle_antisym.\ncut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak.\napply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l.\napply Zdiv_small.\nnow split.\nnow apply Zlt_le_weak.\nnow apply Zlt_le_weak."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (if (2 ^ mw * 2 ^ ew <=? x)%Z then 1%Z else 0%Z) = (x / (2 ^ mw * 2 ^ ew))%Z.","proofString":"apply sym_eq.\ncase Zle_bool_spec ; intros Hs.\napply Zle_antisym.\ncut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak.\napply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l.\napply Zdiv_small.\nnow split."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (x / (2 ^ mw * 2 ^ ew))%Z = (if (2 ^ mw * 2 ^ ew <=? x)%Z then 1%Z else 0%Z).","proofString":"case Zle_bool_spec ; intros Hs.\napply Zle_antisym.\ncut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak.\napply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l.\napply Zdiv_small.\nnow split."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (x / (2 ^ mw * 2 ^ ew))%Z = 1%Z.","proofString":"apply Zle_antisym.\ncut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak.\napply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (x / (2 ^ mw * 2 ^ ew) <= 1)%Z.","proofString":"cut (x / (2^mw * 2^ew) < 2)%Z.\nclear ; lia.\napply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (x / (2 ^ mw * 2 ^ ew) < 2)%Z -> (x / (2 ^ mw * 2 ^ ew) <= 1)%Z.","proofString":"clear ; lia."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (x / (2 ^ mw * 2 ^ ew) < 2)%Z.","proofString":"apply Zdiv_lt_upper_bound.\nnow apply Zmult_lt_0_compat.\nrewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (0 < 2 ^ mw * 2 ^ ew)%Z.","proofString":"now apply Zmult_lt_0_compat."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (x < 2 * (2 ^ mw * 2 ^ ew))%Z.","proofString":"rewrite <- Zpower_exp ; try ( apply Z.le_ge ; apply Zlt_le_weak ; assumption ).\nchange 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (x < 2 * 2 ^ (mw + ew))%Z.","proofString":"change 2%Z with (Zpower 2 1) at 1.\nrewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (x < 2 ^ 1 * 2 ^ (mw + ew))%Z.","proofString":"rewrite <- Zpower_exp.\nnow rewrite Zplus_comm.\ndiscriminate.\napply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (x < 2 ^ (1 + (mw + ew)))%Z.","proofString":"now rewrite Zplus_comm."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (1 >= 0)%Z.","proofString":"discriminate."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (mw + ew >= 0)%Z.","proofString":"apply Z.le_ge.\nnow apply Zplus_le_0_compat ; apply Zlt_le_weak."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (0 <= mw + ew)%Z.","proofString":"now apply Zplus_le_0_compat ; apply Zlt_le_weak."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (1 <= x / (2 ^ mw * 2 ^ ew))%Z.","proofString":"apply Zdiv_le_lower_bound.\nnow apply Zmult_lt_0_compat.\nnow rewrite Zmult_1_l."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (0 < 2 ^ mw * 2 ^ ew)%Z.","proofString":"now apply Zmult_lt_0_compat."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (2 ^ mw * 2 ^ ew <= x)%Z) : (1 * (2 ^ mw * 2 ^ ew) <= x)%Z.","proofString":"now rewrite Zmult_1_l."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (x < 2 ^ mw * 2 ^ ew)%Z) : (x / (2 ^ mw * 2 ^ ew))%Z = 0%Z.","proofString":"apply Zdiv_small.\nnow split."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hs : (x < 2 ^ mw * 2 ^ ew)%Z) : (0 <= x < 2 ^ mw * 2 ^ ew)%Z.","proofString":"now split."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (0 <= 2 ^ mw)%Z.","proofString":"now apply Zlt_le_weak."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (0 <= 2 ^ ew)%Z.","proofString":"now apply Zlt_le_weak."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (2 ^ ew)%Z <> 0%Z.","proofString":"now apply Zgt_not_eq."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (2 ^ mw)%Z <> 0%Z.","proofString":"now apply Zgt_not_eq."},{"statement":"(x y : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hy : (0 <= y < 2 ^ (mw + ew + 1))%Z) : split_bits x = split_bits y -> x = y.","proofString":"generalize (join_split_bits x Hx) (join_split_bits y Hy).\ndestruct (split_bits x) as ((sx, mx), ex).\ndestruct (split_bits y) as ((sy, my), ey).\nintros Jx Jy H.\nrevert Jx Jy.\ninversion_clear H.\nintros Jx Jy.\nnow rewrite <- Jx."},{"statement":"(x y : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hy : (0 <= y < 2 ^ (mw + ew + 1))%Z) : (let '(s, m, e) := split_bits x in join_bits s m e = x) ->\n(let '(s, m, e) := split_bits y in join_bits s m e = y) ->\nsplit_bits x = split_bits y -> x = y.","proofString":"destruct (split_bits x) as ((sx, mx), ex).\ndestruct (split_bits y) as ((sy, my), ey).\nintros Jx Jy H.\nrevert Jx Jy.\ninversion_clear H.\nintros Jx Jy.\nnow rewrite <- Jx."},{"statement":"(x y : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hy : (0 <= y < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) : join_bits sx mx ex = x ->\n(let '(s, m, e) := split_bits y in join_bits s m e = y) ->\n(sx, mx, ex) = split_bits y -> x = y.","proofString":"destruct (split_bits y) as ((sy, my), ey).\nintros Jx Jy H.\nrevert Jx Jy.\ninversion_clear H.\nintros Jx Jy.\nnow rewrite <- Jx."},{"statement":"(x y : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hy : (0 <= y < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (sy : bool) (my ey : Z) : join_bits sx mx ex = x ->\njoin_bits sy my ey = y -> (sx, mx, ex) = (sy, my, ey) -> x = y.","proofString":"intros Jx Jy H.\nrevert Jx Jy.\ninversion_clear H.\nintros Jx Jy.\nnow rewrite <- Jx."},{"statement":"(x y : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hy : (0 <= y < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (sy : bool) (my ey : Z) (Jx : join_bits sx mx ex = x) (Jy : join_bits sy my ey = y) (H : (sx, mx, ex) = (sy, my, ey)) : x = y.","proofString":"revert Jx Jy.\ninversion_clear H.\nintros Jx Jy.\nnow rewrite <- Jx."},{"statement":"(x y : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hy : (0 <= y < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (sy : bool) (my ey : Z) (H : (sx, mx, ex) = (sy, my, ey)) : join_bits sx mx ex = x -> join_bits sy my ey = y -> x = y.","proofString":"inversion_clear H.\nintros Jx Jy.\nnow rewrite <- Jx."},{"statement":"(x y : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hy : (0 <= y < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (sy : bool) (my ey : Z) : join_bits sy my ey = x -> join_bits sy my ey = y -> x = y.","proofString":"intros Jx Jy.\nnow rewrite <- Jx."},{"statement":"(x y : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Hy : (0 <= y < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (sy : bool) (my ey : Z) (Jx : join_bits sy my ey = x) (Jy : join_bits sy my ey = y) : x = y.","proofString":"now rewrite <- Jx."},{"statement":"(sx : bool) (plx : positive) (Hplx : nan_pl prec plx = true) : split_bits (bits_of_binary_float (B754_nan sx plx Hplx)) =\nsplit_bits_of_binary_float (B754_nan sx plx Hplx).","proofString":"simpl.\napply split_join_bits; split; try lia.\ndestruct (digits2_Pnat_correct plx).\nunfold nan_pl in Hplx.\nrewrite Zpos_digits2_pos, <- Z_of_nat_S_digits2_Pnat in Hplx.\nrewrite Zpower_nat_Z in H0.\neapply Z.lt_le_trans.\napply H0.\nchange 2%Z with (radix_val radix2).\napply Zpower_le.\nrewrite Z.ltb_lt in Hplx.\nunfold prec in *.\nlia."},{"statement":"(sx : bool) (plx : positive) (Hplx : nan_pl prec plx = true) : split_bits (join_bits sx (Z.pos plx) (2 ^ ew - 1)) =\n(sx, Z.pos plx, (2 ^ ew - 1)%Z).","proofString":"apply split_join_bits; split; try lia.\ndestruct (digits2_Pnat_correct plx).\nunfold nan_pl in Hplx.\nrewrite Zpos_digits2_pos, <- Z_of_nat_S_digits2_Pnat in Hplx.\nrewrite Zpower_nat_Z in H0.\neapply Z.lt_le_trans.\napply H0.\nchange 2%Z with (radix_val radix2).\napply Zpower_le.\nrewrite Z.ltb_lt in Hplx.\nunfold prec in *.\nlia."},{"statement":"(sx : bool) (plx : positive) (Hplx : nan_pl prec plx = true) : (Z.pos plx < 2 ^ mw)%Z.","proofString":"destruct (digits2_Pnat_correct plx).\nunfold nan_pl in Hplx.\nrewrite Zpos_digits2_pos, <- Z_of_nat_S_digits2_Pnat in Hplx.\nrewrite Zpower_nat_Z in H0.\neapply Z.lt_le_trans.\napply H0.\nchange 2%Z with (radix_val radix2).\napply Zpower_le.\nrewrite Z.ltb_lt in Hplx.\nunfold prec in *.\nlia."},{"statement":"(sx : bool) (plx : positive) (Hplx : nan_pl prec plx = true) (H : (Zpower_nat 2 (digits2_Pnat plx) <= Z.pos plx)%Z) (H0 : (Z.pos plx < Zpower_nat 2 (S (digits2_Pnat plx)))%Z) : (Z.pos plx < 2 ^ mw)%Z.","proofString":"unfold nan_pl in Hplx.\nrewrite Zpos_digits2_pos, <- Z_of_nat_S_digits2_Pnat in Hplx.\nrewrite Zpower_nat_Z in H0.\neapply Z.lt_le_trans.\napply H0.\nchange 2%Z with (radix_val radix2).\napply Zpower_le.\nrewrite Z.ltb_lt in Hplx.\nunfold prec in *.\nlia."},{"statement":"(sx : bool) (plx : positive) (Hplx : (Z.pos (digits2_pos plx) <? prec)%Z = true) (H : (Zpower_nat 2 (digits2_Pnat plx) <= Z.pos plx)%Z) (H0 : (Z.pos plx < Zpower_nat 2 (S (digits2_Pnat plx)))%Z) : (Z.pos plx < 2 ^ mw)%Z.","proofString":"rewrite Zpos_digits2_pos, <- Z_of_nat_S_digits2_Pnat in Hplx.\nrewrite Zpower_nat_Z in H0.\neapply Z.lt_le_trans.\napply H0.\nchange 2%Z with (radix_val radix2).\napply Zpower_le.\nrewrite Z.ltb_lt in Hplx.\nunfold prec in *.\nlia."},{"statement":"(sx : bool) (plx : positive) (Hplx : (Z.of_nat (S (digits2_Pnat plx)) <? prec)%Z = true) (H : (Zpower_nat 2 (digits2_Pnat plx) <= Z.pos plx)%Z) (H0 : (Z.pos plx < Zpower_nat 2 (S (digits2_Pnat plx)))%Z) : (Z.pos plx < 2 ^ mw)%Z.","proofString":"rewrite Zpower_nat_Z in H0.\neapply Z.lt_le_trans.\napply H0.\nchange 2%Z with (radix_val radix2).\napply Zpower_le.\nrewrite Z.ltb_lt in Hplx.\nunfold prec in *.\nlia."},{"statement":"(sx : bool) (plx : positive) (Hplx : (Z.of_nat (S (digits2_Pnat plx)) <? prec)%Z = true) (H : (Zpower_nat 2 (digits2_Pnat plx) <= Z.pos plx)%Z) (H0 : (Z.pos plx < 2 ^ Z.of_nat (S (digits2_Pnat plx)))%Z) : (Z.pos plx < 2 ^ mw)%Z.","proofString":"eapply Z.lt_le_trans.\napply H0.\nchange 2%Z with (radix_val radix2).\napply Zpower_le.\nrewrite Z.ltb_lt in Hplx.\nunfold prec in *.\nlia."},{"statement":"(sx : bool) (plx : positive) (Hplx : (Z.of_nat (S (digits2_Pnat plx)) <? prec)%Z = true) (H : (Zpower_nat 2 (digits2_Pnat plx) <= Z.pos plx)%Z) (H0 : (Z.pos plx < 2 ^ Z.of_nat (S (digits2_Pnat plx)))%Z) : (radix2 ^ Z.of_nat (S (digits2_Pnat plx)) <= radix2 ^ mw)%Z.","proofString":"apply Zpower_le.\nrewrite Z.ltb_lt in Hplx.\nunfold prec in *.\nlia."},{"statement":"(sx : bool) (plx : positive) (Hplx : (Z.of_nat (S (digits2_Pnat plx)) <? prec)%Z = true) (H : (Zpower_nat 2 (digits2_Pnat plx) <= Z.pos plx)%Z) (H0 : (Z.pos plx < 2 ^ Z.of_nat (S (digits2_Pnat plx)))%Z) : (Z.of_nat (S (digits2_Pnat plx)) <= mw)%Z.","proofString":"rewrite Z.ltb_lt in Hplx.\nunfold prec in *.\nlia."},{"statement":"(sx : bool) (plx : positive) (Hplx : (Z.of_nat (S (digits2_Pnat plx)) < prec)%Z) (H : (Zpower_nat 2 (digits2_Pnat plx) <= Z.pos plx)%Z) (H0 : (Z.pos plx < 2 ^ Z.of_nat (S (digits2_Pnat plx)))%Z) : (Z.of_nat (S (digits2_Pnat plx)) <= mw)%Z.","proofString":"unfold prec in *.\nlia."},{"statement":"(sx : bool) (plx : positive) (Hplx : (Z.of_nat (S (digits2_Pnat plx)) < mw + 1)%Z) (H : (Zpower_nat 2 (digits2_Pnat plx) <= Z.pos plx)%Z) (H0 : (Z.pos plx < 2 ^ Z.of_nat (S (digits2_Pnat plx)))%Z) : (Z.of_nat (S (digits2_Pnat plx)) <= mw)%Z.","proofString":"lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded prec emax mx ex = true) : split_bits (bits_of_binary_float (B754_finite sx mx ex Hx)) =\nsplit_bits_of_binary_float (B754_finite sx mx ex Hx).","proofString":"unfold bits_of_binary_float, split_bits_of_binary_float.\nassert (Hf: (emin <= ex /\\ Zdigits radix2 (Zpos mx) <= prec)%Z).\ndestruct (andb_prop _ _ Hx) as (Hx', _).\nunfold canonical_mantissa in Hx'.\nrewrite Zpos_digits2_pos in Hx'.\ngeneralize (Zeq_bool_eq _ _ Hx').\nunfold fexp, FLT_exp, emin.\nclear ; lia.\ncase Zle_bool_spec ; intros H ;  [ apply -> Z.le_0_sub in H | apply -> Z.lt_sub_0 in H ] ;  apply split_join_bits ; try now split.\nsplit.\nclear -He_gt_0 H ; lia.\ncut (Zpos mx < 2 * 2^mw)%Z.\nclear ; lia.\nreplace (2 * 2^mw)%Z with (2^prec)%Z.\napply (Zpower_gt_Zdigits radix2 _ (Zpos mx)).\napply Hf.\nunfold prec.\nrewrite Zplus_comm.\napply Zpower_exp ; apply Z.le_ge.\ndiscriminate.\nnow apply Zlt_le_weak.\nsplit.\ngeneralize (proj1 Hf).\nclear ; lia.\ndestruct (andb_prop _ _ Hx) as (_, Hx').\nunfold emin.\nreplace (2^ew)%Z with (2 * emax)%Z.\ngeneralize (Zle_bool_imp_le _ _ Hx').\nclear ; lia.\napply sym_eq.\nrewrite (Zsucc_pred ew).\nunfold Z.succ.\nrewrite Zplus_comm.\napply Zpower_exp ; apply Z.le_ge.\ndiscriminate.\nnow apply Zlt_0_le_0_pred."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (Hx : bounded prec emax mx ex = true) : split_bits\n  (if (0 <=? Z.pos mx - 2 ^ mw)%Z\n   then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n   else join_bits sx (Z.pos mx) 0) =\n(if (0 <=? Z.pos mx - 2 ^ mw)%Z\n then (sx, (Z.pos mx - 2 ^ mw)%Z, (ex - SpecFloat.emin prec emax + 1)%Z)\n else (sx, Z.pos mx, 0%Z)).","proofString":"assert (Hf: (emin <= ex /\\ Zdigits radix2 (Zpos mx) <= prec)%Z).\ndestruct (andb_prop _ _ Hx) as (Hx', _).\nunfold canonical_mantissa in Hx'.\nrewrite Zpos_digits2_pos in Hx'.\ngeneralize (Zeq_bool_eq _ _ Hx').\nunfold fexp, FLT_exp, emin.\nclear ; lia.\ncase Zle_bool_spec ; intros H ;  [ apply -> Z.le_0_sub in H | apply -> Z.lt_sub_0 in H ] ;  apply split_join_bits ; try now split.\nsplit.\nclear -He_gt_0 H ; lia.\ncut (Zpos mx < 2 * 2^mw)%Z.\nclear ; lia.\nreplace (2 * 2^mw)%Z with (2^prec)%Z.\napply (Zpower_gt_Zdigits radix2 _ (Zpos mx)).\napply Hf.\nunfold prec.\nrewrite Zplus_comm.\napply Zpower_exp ; apply Z.le_ge.\ndiscriminate.\nnow apply Zlt_le_weak.\nsplit.\ngeneralize (proj1 Hf).\nclear ; lia.\ndestruct (andb_prop _ _ Hx) as (_, Hx').\nunfold emin.\nreplace (2^ew)%Z with (2 * emax)%Z.\ngeneralize (Zle_bool_imp_le _ _ Hx').\nclear ; lia.\napply sym_eq.\nrewrite (Zsucc_pred ew).\nunfold Z.succ.\nrewrite Zplus_comm.\napply Zpower_exp ; apply Z.le_ge.\ndiscriminate.\nnow apply Zlt_0_le_0_pred."},{"statement":"forall x : Binary.binary_float prec emax,\n(0 <=\n match x with\n | B754_zero sx => join_bits sx 0 0\n | B754_infinity sx => join_bits sx 0 (2 ^ ew - 1)\n | B754_nan sx plx _ => join_bits sx (Z.pos plx) (2 ^ ew - 1)\n | B754_finite sx mx ex _ =>\n     if 0 <=? Z.pos mx - 2 ^ mw\n     then\n      join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n     else join_bits sx (Z.pos mx) 0\n end < 2 ^ (mw + ew + 1))%Z.","proofString":"intros [sx|sx|sx pl pl_range|sx mx ex H].\napply join_bits_range ; now split.\napply join_bits_range.\nnow split.\nclear -He_gt_0 ; lia.\napply Z.ltb_lt in pl_range.\napply join_bits_range.\nsplit.\neasy.\napply (Zpower_gt_Zdigits radix2 _ (Zpos pl)).\napply Z.lt_succ_r.\nnow rewrite <- Zdigits2_Zdigits.\nclear -He_gt_0 ; lia.\nunfold bounded in H.\napply Bool.andb_true_iff in H ; destruct H as [A B].\napply Z.leb_le in B.\nunfold canonical_mantissa, fexp, FLT_exp in A.\napply Zeq_bool_eq in A.\ncase Zle_bool_spec ; intros H.\napply join_bits_range.\nsplit.\nclear -H ; lia.\nrewrite Zpos_digits2_pos in A.\ncut (Zpos mx < 2 ^ prec)%Z.\nunfold prec.\nrewrite Zpower_plus by (clear -Hmw ; lia).\nchange (2^1)%Z with 2%Z.\nclear ; lia.\napply (Zpower_gt_Zdigits radix2 _ (Zpos mx)).\nunfold emin in A.\nclear -A ; lia.\nsplit.\nunfold emin in A |- * ; clear -A ; lia.\nreplace ew with ((ew - 1) + 1)%Z by ring.\nrewrite Zpower_plus by (clear - Hew ; lia).\nunfold emin, emax in *.\nchange (2^1)%Z with 2%Z.\nclear -B ; lia.\napply -> Z.lt_sub_0 in H.\napply join_bits_range ; now split."},{"statement":"(sx : bool) : (0 <= join_bits sx 0 0 < 2 ^ (mw + ew + 1))%Z.","proofString":"apply join_bits_range ; now split."},{"statement":"(sx : bool) : (0 <= join_bits sx 0 (2 ^ ew - 1) < 2 ^ (mw + ew + 1))%Z.","proofString":"apply join_bits_range.\nnow split.\nclear -He_gt_0 ; lia."},{"statement":"(sx : bool) : (0 <= 0 < 2 ^ mw)%Z.","proofString":"now split."},{"statement":"(sx : bool) : (0 <= 2 ^ ew - 1 < 2 ^ ew)%Z.","proofString":"clear -He_gt_0 ; lia."},{"statement":"(sx : bool) (pl : positive) (pl_range : nan_pl prec pl = true) : (0 <= join_bits sx (Z.pos pl) (2 ^ ew - 1) < 2 ^ (mw + ew + 1))%Z.","proofString":"apply Z.ltb_lt in pl_range.\napply join_bits_range.\nsplit.\neasy.\napply (Zpower_gt_Zdigits radix2 _ (Zpos pl)).\napply Z.lt_succ_r.\nnow rewrite <- Zdigits2_Zdigits.\nclear -He_gt_0 ; lia."},{"statement":"(sx : bool) (pl : positive) (pl_range : (Z.pos (digits2_pos pl) < prec)%Z) : (0 <= join_bits sx (Z.pos pl) (2 ^ ew - 1) < 2 ^ (mw + ew + 1))%Z.","proofString":"apply join_bits_range.\nsplit.\neasy.\napply (Zpower_gt_Zdigits radix2 _ (Zpos pl)).\napply Z.lt_succ_r.\nnow rewrite <- Zdigits2_Zdigits.\nclear -He_gt_0 ; lia."},{"statement":"(sx : bool) (pl : positive) (pl_range : (Z.pos (digits2_pos pl) < prec)%Z) : (0 <= Z.pos pl < 2 ^ mw)%Z.","proofString":"split.\neasy.\napply (Zpower_gt_Zdigits radix2 _ (Zpos pl)).\napply Z.lt_succ_r.\nnow rewrite <- Zdigits2_Zdigits."},{"statement":"(sx : bool) (pl : positive) (pl_range : (Z.pos (digits2_pos pl) < prec)%Z) : (0 <= Z.pos pl)%Z.","proofString":"easy."},{"statement":"(sx : bool) (pl : positive) (pl_range : (Z.pos (digits2_pos pl) < prec)%Z) : (Z.pos pl < 2 ^ mw)%Z.","proofString":"apply (Zpower_gt_Zdigits radix2 _ (Zpos pl)).\napply Z.lt_succ_r.\nnow rewrite <- Zdigits2_Zdigits."},{"statement":"(sx : bool) (pl : positive) (pl_range : (Z.pos (digits2_pos pl) < prec)%Z) : (Zdigits radix2 (Z.pos pl) <= mw)%Z.","proofString":"apply Z.lt_succ_r.\nnow rewrite <- Zdigits2_Zdigits."},{"statement":"(sx : bool) (pl : positive) (pl_range : (Z.pos (digits2_pos pl) < prec)%Z) : (Zdigits radix2 (Z.pos pl) < Z.succ mw)%Z.","proofString":"now rewrite <- Zdigits2_Zdigits."},{"statement":"(sx : bool) (pl : positive) (pl_range : (Z.pos (digits2_pos pl) < prec)%Z) : (0 <= 2 ^ ew - 1 < 2 ^ ew)%Z.","proofString":"clear -He_gt_0 ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (H : bounded prec emax mx ex = true) : (0 <=\n (if 0 <=? Z.pos mx - 2 ^ mw\n  then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n  else join_bits sx (Z.pos mx) 0) < 2 ^ (mw + ew + 1))%Z.","proofString":"unfold bounded in H.\napply Bool.andb_true_iff in H ; destruct H as [A B].\napply Z.leb_le in B.\nunfold canonical_mantissa, fexp, FLT_exp in A.\napply Zeq_bool_eq in A.\ncase Zle_bool_spec ; intros H.\napply join_bits_range.\nsplit.\nclear -H ; lia.\nrewrite Zpos_digits2_pos in A.\ncut (Zpos mx < 2 ^ prec)%Z.\nunfold prec.\nrewrite Zpower_plus by (clear -Hmw ; lia).\nchange (2^1)%Z with 2%Z.\nclear ; lia.\napply (Zpower_gt_Zdigits radix2 _ (Zpos mx)).\nunfold emin in A.\nclear -A ; lia.\nsplit.\nunfold emin in A |- * ; clear -A ; lia.\nreplace ew with ((ew - 1) + 1)%Z by ring.\nrewrite Zpower_plus by (clear - Hew ; lia).\nunfold emin, emax in *.\nchange (2^1)%Z with 2%Z.\nclear -B ; lia.\napply -> Z.lt_sub_0 in H.\napply join_bits_range ; now split."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (H : (canonical_mantissa prec emax mx ex && (ex <=? emax - prec)%Z)%bool = true) : (0 <=\n (if 0 <=? Z.pos mx - 2 ^ mw\n  then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n  else join_bits sx (Z.pos mx) 0) < 2 ^ (mw + ew + 1))%Z.","proofString":"apply Bool.andb_true_iff in H ; destruct H as [A B].\napply Z.leb_le in B.\nunfold canonical_mantissa, fexp, FLT_exp in A.\napply Zeq_bool_eq in A.\ncase Zle_bool_spec ; intros H.\napply join_bits_range.\nsplit.\nclear -H ; lia.\nrewrite Zpos_digits2_pos in A.\ncut (Zpos mx < 2 ^ prec)%Z.\nunfold prec.\nrewrite Zpower_plus by (clear -Hmw ; lia).\nchange (2^1)%Z with 2%Z.\nclear ; lia.\napply (Zpower_gt_Zdigits radix2 _ (Zpos mx)).\nunfold emin in A.\nclear -A ; lia.\nsplit.\nunfold emin in A |- * ; clear -A ; lia.\nreplace ew with ((ew - 1) + 1)%Z by ring.\nrewrite Zpower_plus by (clear - Hew ; lia).\nunfold emin, emax in *.\nchange (2^1)%Z with 2%Z.\nclear -B ; lia.\napply -> Z.lt_sub_0 in H.\napply join_bits_range ; now split."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (A : canonical_mantissa prec emax mx ex = true) (B : (ex <=? emax - prec)%Z = true) : (0 <=\n (if 0 <=? Z.pos mx - 2 ^ mw\n  then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n  else join_bits sx (Z.pos mx) 0) < 2 ^ (mw + ew + 1))%Z.","proofString":"apply Z.leb_le in B.\nunfold canonical_mantissa, fexp, FLT_exp in A.\napply Zeq_bool_eq in A.\ncase Zle_bool_spec ; intros H.\napply join_bits_range.\nsplit.\nclear -H ; lia.\nrewrite Zpos_digits2_pos in A.\ncut (Zpos mx < 2 ^ prec)%Z.\nunfold prec.\nrewrite Zpower_plus by (clear -Hmw ; lia).\nchange (2^1)%Z with 2%Z.\nclear ; lia.\napply (Zpower_gt_Zdigits radix2 _ (Zpos mx)).\nunfold emin in A.\nclear -A ; lia.\nsplit.\nunfold emin in A |- * ; clear -A ; lia.\nreplace ew with ((ew - 1) + 1)%Z by ring.\nrewrite Zpower_plus by (clear - Hew ; lia).\nunfold emin, emax in *.\nchange (2^1)%Z with 2%Z.\nclear -B ; lia.\napply -> Z.lt_sub_0 in H.\napply join_bits_range ; now split."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (A : canonical_mantissa prec emax mx ex = true) (B : (ex <= emax - prec)%Z) : (0 <=\n (if 0 <=? Z.pos mx - 2 ^ mw\n  then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n  else join_bits sx (Z.pos mx) 0) < 2 ^ (mw + ew + 1))%Z.","proofString":"unfold canonical_mantissa, fexp, FLT_exp in A.\napply Zeq_bool_eq in A.\ncase Zle_bool_spec ; intros H.\napply join_bits_range.\nsplit.\nclear -H ; lia.\nrewrite Zpos_digits2_pos in A.\ncut (Zpos mx < 2 ^ prec)%Z.\nunfold prec.\nrewrite Zpower_plus by (clear -Hmw ; lia).\nchange (2^1)%Z with 2%Z.\nclear ; lia.\napply (Zpower_gt_Zdigits radix2 _ (Zpos mx)).\nunfold emin in A.\nclear -A ; lia.\nsplit.\nunfold emin in A |- * ; clear -A ; lia.\nreplace ew with ((ew - 1) + 1)%Z by ring.\nrewrite Zpower_plus by (clear - Hew ; lia).\nunfold emin, emax in *.\nchange (2^1)%Z with 2%Z.\nclear -B ; lia.\napply -> Z.lt_sub_0 in H.\napply join_bits_range ; now split."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (A : Zeq_bool\n  (Z.max (Z.pos (digits2_pos mx) + ex - prec) (SpecFloat.emin prec emax)) ex =\ntrue) (B : (ex <= emax - prec)%Z) : (0 <=\n (if 0 <=? Z.pos mx - 2 ^ mw\n  then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n  else join_bits sx (Z.pos mx) 0) < 2 ^ (mw + ew + 1))%Z.","proofString":"apply Zeq_bool_eq in A.\ncase Zle_bool_spec ; intros H.\napply join_bits_range.\nsplit.\nclear -H ; lia.\nrewrite Zpos_digits2_pos in A.\ncut (Zpos mx < 2 ^ prec)%Z.\nunfold prec.\nrewrite Zpower_plus by (clear -Hmw ; lia).\nchange (2^1)%Z with 2%Z.\nclear ; lia.\napply (Zpower_gt_Zdigits radix2 _ (Zpos mx)).\nunfold emin in A.\nclear -A ; lia.\nsplit.\nunfold emin in A |- * ; clear -A ; lia.\nreplace ew with ((ew - 1) + 1)%Z by ring.\nrewrite Zpower_plus by (clear - Hew ; lia).\nunfold emin, emax in *.\nchange (2^1)%Z with 2%Z.\nclear -B ; lia.\napply -> Z.lt_sub_0 in H.\napply join_bits_range ; now split."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (A : Z.max (Z.pos (digits2_pos mx) + ex - prec) (SpecFloat.emin prec emax) = ex) (B : (ex <= emax - prec)%Z) : (0 <=\n (if 0 <=? Z.pos mx - 2 ^ mw\n  then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n  else join_bits sx (Z.pos mx) 0) < 2 ^ (mw + ew + 1))%Z.","proofString":"case Zle_bool_spec ; intros H.\napply join_bits_range.\nsplit.\nclear -H ; lia.\nrewrite Zpos_digits2_pos in A.\ncut (Zpos mx < 2 ^ prec)%Z.\nunfold prec.\nrewrite Zpower_plus by (clear -Hmw ; lia).\nchange (2^1)%Z with 2%Z.\nclear ; lia.\napply (Zpower_gt_Zdigits radix2 _ (Zpos mx)).\nunfold emin in A.\nclear -A ; lia.\nsplit.\nunfold emin in A |- * ; clear -A ; lia.\nreplace ew with ((ew - 1) + 1)%Z by ring.\nrewrite Zpower_plus by (clear - Hew ; lia).\nunfold emin, emax in *.\nchange (2^1)%Z with 2%Z.\nclear -B ; lia.\napply -> Z.lt_sub_0 in H.\napply join_bits_range ; now split."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (A : Z.max (Z.pos (digits2_pos mx) + ex - prec) (SpecFloat.emin prec emax) = ex) (B : (ex <= emax - prec)%Z) (H : (0 <= Z.pos mx - 2 ^ mw)%Z) : (0 <= Z.pos mx - 2 ^ mw)%Z.","proofString":"clear -H ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (A : Z.max (Zdigits radix2 (Z.pos mx) + ex - prec) (SpecFloat.emin prec emax) = ex) (B : (ex <= emax - prec)%Z) (H : (0 <= Z.pos mx - 2 ^ mw)%Z) : (Z.pos mx < 2 ^ prec)%Z -> (Z.pos mx - 2 ^ mw < 2 ^ mw)%Z.","proofString":"unfold prec.\nrewrite Zpower_plus by (clear -Hmw ; lia).\nchange (2^1)%Z with 2%Z.\nclear ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (A : Z.max (Zdigits radix2 (Z.pos mx) + ex - prec) (SpecFloat.emin prec emax) = ex) (B : (ex <= emax - prec)%Z) (H : (0 <= Z.pos mx - 2 ^ mw)%Z) : (Z.pos mx < 2 ^ (mw + 1))%Z -> (Z.pos mx - 2 ^ mw < 2 ^ mw)%Z.","proofString":"rewrite Zpower_plus by (clear -Hmw ; lia).\nchange (2^1)%Z with 2%Z.\nclear ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (A : Z.max (Zdigits radix2 (Z.pos mx) + ex - prec) (SpecFloat.emin prec emax) = ex) (B : (ex <= emax - prec)%Z) (H : (0 <= Z.pos mx - 2 ^ mw)%Z) : (Z.pos mx < 2 ^ mw * 2 ^ 1)%Z -> (Z.pos mx - 2 ^ mw < 2 ^ mw)%Z.","proofString":"change (2^1)%Z with 2%Z.\nclear ; lia."},{"statement":"(sx : bool) (mx : positive) (ex : Z) (A : Z.max (Zdigits radix2 (Z.pos mx) + ex - prec) (SpecFloat.emin prec emax) = ex) (B : (ex <= emax - prec)%Z) (H : (0 <= Z.pos mx - 2 ^ mw)%Z) : (Z.pos mx < 2 ^ mw * 2)%Z -> (Z.pos mx - 2 ^ mw < 2 ^ mw)%Z.","proofString":"clear ; lia."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : bits_of_binary_float (binary_float_of_bits x) = x.","proofString":"unfold binary_float_of_bits, bits_of_binary_float.\nset (Cx := binary_float_of_bits_aux_correct x).\nclearbody Cx.\nrewrite match_FF2B.\nrevert Cx.\ngeneralize (join_split_bits x Hx).\nunfold binary_float_of_bits_aux.\ncase_eq (split_bits x).\nintros (sx, mx) ex Sx.\nassert (Bm: (0 <= mx < 2^mw)%Z).\ninversion_clear Sx.\napply Z_mod_lt.\nnow apply Z.lt_gt.\ncase Zeq_bool_spec ; intros He1.\ncase_eq mx.\nintros Hm Jx _.\nnow rewrite He1 in Jx.\nintros px Hm Jx _.\nrewrite Zle_bool_false.\nnow rewrite <- He1.\napply <- Z.lt_sub_0.\nnow rewrite <- Hm.\nintros px Hm _ _.\napply False_ind.\napply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm.\ncase Zeq_bool_spec ; intros He2.\ncase_eq mx; intros Hm.\nnow rewrite He2.\nnow rewrite He2.\nintros ; lia.\ncase_eq (mx + 2 ^ mw)%Z.\nintros Hm.\napply False_ind.\nclear -Bm Hm ; lia.\nintros p Hm Jx Cx.\nrewrite <- Hm.\nrewrite Zle_bool_true.\nnow ring_simplify (mx + 2^mw - 2^mw)%Z (ex + emin - 1 - emin + 1)%Z.\nnow ring_simplify.\nintros p Hm.\napply False_ind.\nclear -Bm Hm ; lia."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : match\n  FF2B prec emax (binary_float_of_bits_aux x)\n    (binary_float_of_bits_aux_correct x)\nwith\n| B754_zero sx => join_bits sx 0 0\n| B754_infinity sx => join_bits sx 0 (2 ^ ew - 1)\n| B754_nan sx plx _ => join_bits sx (Z.pos plx) (2 ^ ew - 1)\n| B754_finite sx mx ex _ =>\n    if (0 <=? Z.pos mx - 2 ^ mw)%Z\n    then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n    else join_bits sx (Z.pos mx) 0\nend = x.","proofString":"set (Cx := binary_float_of_bits_aux_correct x).\nclearbody Cx.\nrewrite match_FF2B.\nrevert Cx.\ngeneralize (join_split_bits x Hx).\nunfold binary_float_of_bits_aux.\ncase_eq (split_bits x).\nintros (sx, mx) ex Sx.\nassert (Bm: (0 <= mx < 2^mw)%Z).\ninversion_clear Sx.\napply Z_mod_lt.\nnow apply Z.lt_gt.\ncase Zeq_bool_spec ; intros He1.\ncase_eq mx.\nintros Hm Jx _.\nnow rewrite He1 in Jx.\nintros px Hm Jx _.\nrewrite Zle_bool_false.\nnow rewrite <- He1.\napply <- Z.lt_sub_0.\nnow rewrite <- Hm.\nintros px Hm _ _.\napply False_ind.\napply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm.\ncase Zeq_bool_spec ; intros He2.\ncase_eq mx; intros Hm.\nnow rewrite He2.\nnow rewrite He2.\nintros ; lia.\ncase_eq (mx + 2 ^ mw)%Z.\nintros Hm.\napply False_ind.\nclear -Bm Hm ; lia.\nintros p Hm Jx Cx.\nrewrite <- Hm.\nrewrite Zle_bool_true.\nnow ring_simplify (mx + 2^mw - 2^mw)%Z (ex + emin - 1 - emin + 1)%Z.\nnow ring_simplify.\nintros p Hm.\napply False_ind.\nclear -Bm Hm ; lia."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Cx : valid_binary prec emax (binary_float_of_bits_aux x) = true) : match FF2B prec emax (binary_float_of_bits_aux x) Cx with\n| B754_zero sx => join_bits sx 0 0\n| B754_infinity sx => join_bits sx 0 (2 ^ ew - 1)\n| B754_nan sx plx _ => join_bits sx (Z.pos plx) (2 ^ ew - 1)\n| B754_finite sx mx ex _ =>\n    if (0 <=? Z.pos mx - 2 ^ mw)%Z\n    then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n    else join_bits sx (Z.pos mx) 0\nend = x.","proofString":"rewrite match_FF2B.\nrevert Cx.\ngeneralize (join_split_bits x Hx).\nunfold binary_float_of_bits_aux.\ncase_eq (split_bits x).\nintros (sx, mx) ex Sx.\nassert (Bm: (0 <= mx < 2^mw)%Z).\ninversion_clear Sx.\napply Z_mod_lt.\nnow apply Z.lt_gt.\ncase Zeq_bool_spec ; intros He1.\ncase_eq mx.\nintros Hm Jx _.\nnow rewrite He1 in Jx.\nintros px Hm Jx _.\nrewrite Zle_bool_false.\nnow rewrite <- He1.\napply <- Z.lt_sub_0.\nnow rewrite <- Hm.\nintros px Hm _ _.\napply False_ind.\napply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm.\ncase Zeq_bool_spec ; intros He2.\ncase_eq mx; intros Hm.\nnow rewrite He2.\nnow rewrite He2.\nintros ; lia.\ncase_eq (mx + 2 ^ mw)%Z.\nintros Hm.\napply False_ind.\nclear -Bm Hm ; lia.\nintros p Hm Jx Cx.\nrewrite <- Hm.\nrewrite Zle_bool_true.\nnow ring_simplify (mx + 2^mw - 2^mw)%Z (ex + emin - 1 - emin + 1)%Z.\nnow ring_simplify.\nintros p Hm.\napply False_ind.\nclear -Bm Hm ; lia."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (Cx : valid_binary prec emax (binary_float_of_bits_aux x) = true) : match binary_float_of_bits_aux x with\n| F754_zero sx => join_bits sx 0 0\n| F754_infinity sx => join_bits sx 0 (2 ^ ew - 1)\n| F754_nan b p => join_bits b (Z.pos p) (2 ^ ew - 1)\n| F754_finite sx mx ex =>\n    if (0 <=? Z.pos mx - 2 ^ mw)%Z\n    then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n    else join_bits sx (Z.pos mx) 0\nend = x.","proofString":"revert Cx.\ngeneralize (join_split_bits x Hx).\nunfold binary_float_of_bits_aux.\ncase_eq (split_bits x).\nintros (sx, mx) ex Sx.\nassert (Bm: (0 <= mx < 2^mw)%Z).\ninversion_clear Sx.\napply Z_mod_lt.\nnow apply Z.lt_gt.\ncase Zeq_bool_spec ; intros He1.\ncase_eq mx.\nintros Hm Jx _.\nnow rewrite He1 in Jx.\nintros px Hm Jx _.\nrewrite Zle_bool_false.\nnow rewrite <- He1.\napply <- Z.lt_sub_0.\nnow rewrite <- Hm.\nintros px Hm _ _.\napply False_ind.\napply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm.\ncase Zeq_bool_spec ; intros He2.\ncase_eq mx; intros Hm.\nnow rewrite He2.\nnow rewrite He2.\nintros ; lia.\ncase_eq (mx + 2 ^ mw)%Z.\nintros Hm.\napply False_ind.\nclear -Bm Hm ; lia.\nintros p Hm Jx Cx.\nrewrite <- Hm.\nrewrite Zle_bool_true.\nnow ring_simplify (mx + 2^mw - 2^mw)%Z (ex + emin - 1 - emin + 1)%Z.\nnow ring_simplify.\nintros p Hm.\napply False_ind.\nclear -Bm Hm ; lia."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : valid_binary prec emax (binary_float_of_bits_aux x) = true ->\nmatch binary_float_of_bits_aux x with\n| F754_zero sx => join_bits sx 0 0\n| F754_infinity sx => join_bits sx 0 (2 ^ ew - 1)\n| F754_nan b p => join_bits b (Z.pos p) (2 ^ ew - 1)\n| F754_finite sx mx ex =>\n    if (0 <=? Z.pos mx - 2 ^ mw)%Z\n    then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n    else join_bits sx (Z.pos mx) 0\nend = x.","proofString":"generalize (join_split_bits x Hx).\nunfold binary_float_of_bits_aux.\ncase_eq (split_bits x).\nintros (sx, mx) ex Sx.\nassert (Bm: (0 <= mx < 2^mw)%Z).\ninversion_clear Sx.\napply Z_mod_lt.\nnow apply Z.lt_gt.\ncase Zeq_bool_spec ; intros He1.\ncase_eq mx.\nintros Hm Jx _.\nnow rewrite He1 in Jx.\nintros px Hm Jx _.\nrewrite Zle_bool_false.\nnow rewrite <- He1.\napply <- Z.lt_sub_0.\nnow rewrite <- Hm.\nintros px Hm _ _.\napply False_ind.\napply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm.\ncase Zeq_bool_spec ; intros He2.\ncase_eq mx; intros Hm.\nnow rewrite He2.\nnow rewrite He2.\nintros ; lia.\ncase_eq (mx + 2 ^ mw)%Z.\nintros Hm.\napply False_ind.\nclear -Bm Hm ; lia.\nintros p Hm Jx Cx.\nrewrite <- Hm.\nrewrite Zle_bool_true.\nnow ring_simplify (mx + 2^mw - 2^mw)%Z (ex + emin - 1 - emin + 1)%Z.\nnow ring_simplify.\nintros p Hm.\napply False_ind.\nclear -Bm Hm ; lia."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (let '(s, m, e) := split_bits x in join_bits s m e = x) ->\nvalid_binary prec emax (binary_float_of_bits_aux x) = true ->\nmatch binary_float_of_bits_aux x with\n| F754_zero sx => join_bits sx 0 0\n| F754_infinity sx => join_bits sx 0 (2 ^ ew - 1)\n| F754_nan b p => join_bits b (Z.pos p) (2 ^ ew - 1)\n| F754_finite sx mx ex =>\n    if (0 <=? Z.pos mx - 2 ^ mw)%Z\n    then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n    else join_bits sx (Z.pos mx) 0\nend = x.","proofString":"unfold binary_float_of_bits_aux.\ncase_eq (split_bits x).\nintros (sx, mx) ex Sx.\nassert (Bm: (0 <= mx < 2^mw)%Z).\ninversion_clear Sx.\napply Z_mod_lt.\nnow apply Z.lt_gt.\ncase Zeq_bool_spec ; intros He1.\ncase_eq mx.\nintros Hm Jx _.\nnow rewrite He1 in Jx.\nintros px Hm Jx _.\nrewrite Zle_bool_false.\nnow rewrite <- He1.\napply <- Z.lt_sub_0.\nnow rewrite <- Hm.\nintros px Hm _ _.\napply False_ind.\napply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm.\ncase Zeq_bool_spec ; intros He2.\ncase_eq mx; intros Hm.\nnow rewrite He2.\nnow rewrite He2.\nintros ; lia.\ncase_eq (mx + 2 ^ mw)%Z.\nintros Hm.\napply False_ind.\nclear -Bm Hm ; lia.\nintros p Hm Jx Cx.\nrewrite <- Hm.\nrewrite Zle_bool_true.\nnow ring_simplify (mx + 2^mw - 2^mw)%Z (ex + emin - 1 - emin + 1)%Z.\nnow ring_simplify.\nintros p Hm.\napply False_ind.\nclear -Bm Hm ; lia."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : (let '(s, m, e) := split_bits x in join_bits s m e = x) ->\nvalid_binary prec emax\n  (let\n   '(sx, mx, ex) := split_bits x in\n    if Zeq_bool ex 0\n    then\n     match mx with\n     | 0%Z => F754_zero sx\n     | Z.pos px => F754_finite sx px (SpecFloat.emin prec emax)\n     | Z.neg _ => F754_nan false 1\n     end\n    else\n     if Zeq_bool ex (2 ^ ew - 1)\n     then\n      match mx with\n      | 0%Z => F754_infinity sx\n      | Z.pos plx => F754_nan sx plx\n      | Z.neg _ => F754_nan false 1\n      end\n     else\n      match (mx + 2 ^ mw)%Z with\n      | Z.pos px => F754_finite sx px (ex + SpecFloat.emin prec emax - 1)\n      | _ => F754_nan false 1\n      end) = true ->\nmatch\n  (let\n   '(sx, mx, ex) := split_bits x in\n    if Zeq_bool ex 0\n    then\n     match mx with\n     | 0%Z => F754_zero sx\n     | Z.pos px => F754_finite sx px (SpecFloat.emin prec emax)\n     | Z.neg _ => F754_nan false 1\n     end\n    else\n     if Zeq_bool ex (2 ^ ew - 1)\n     then\n      match mx with\n      | 0%Z => F754_infinity sx\n      | Z.pos plx => F754_nan sx plx\n      | Z.neg _ => F754_nan false 1\n      end\n     else\n      match (mx + 2 ^ mw)%Z with\n      | Z.pos px => F754_finite sx px (ex + SpecFloat.emin prec emax - 1)\n      | _ => F754_nan false 1\n      end)\nwith\n| F754_zero sx => join_bits sx 0 0\n| F754_infinity sx => join_bits sx 0 (2 ^ ew - 1)\n| F754_nan b p => join_bits b (Z.pos p) (2 ^ ew - 1)\n| F754_finite sx mx ex =>\n    if (0 <=? Z.pos mx - 2 ^ mw)%Z\n    then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n    else join_bits sx (Z.pos mx) 0\nend = x.","proofString":"case_eq (split_bits x).\nintros (sx, mx) ex Sx.\nassert (Bm: (0 <= mx < 2^mw)%Z).\ninversion_clear Sx.\napply Z_mod_lt.\nnow apply Z.lt_gt.\ncase Zeq_bool_spec ; intros He1.\ncase_eq mx.\nintros Hm Jx _.\nnow rewrite He1 in Jx.\nintros px Hm Jx _.\nrewrite Zle_bool_false.\nnow rewrite <- He1.\napply <- Z.lt_sub_0.\nnow rewrite <- Hm.\nintros px Hm _ _.\napply False_ind.\napply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm.\ncase Zeq_bool_spec ; intros He2.\ncase_eq mx; intros Hm.\nnow rewrite He2.\nnow rewrite He2.\nintros ; lia.\ncase_eq (mx + 2 ^ mw)%Z.\nintros Hm.\napply False_ind.\nclear -Bm Hm ; lia.\nintros p Hm Jx Cx.\nrewrite <- Hm.\nrewrite Zle_bool_true.\nnow ring_simplify (mx + 2^mw - 2^mw)%Z (ex + emin - 1 - emin + 1)%Z.\nnow ring_simplify.\nintros p Hm.\napply False_ind.\nclear -Bm Hm ; lia."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) : forall (p : bool * Z) (z : Z),\nsplit_bits x = (p, z) ->\n(let '(s, m) := p in join_bits s m z = x) ->\nvalid_binary prec emax\n  (let\n   '(sx, mx) := p in\n    if Zeq_bool z 0\n    then\n     match mx with\n     | 0%Z => F754_zero sx\n     | Z.pos px => F754_finite sx px (SpecFloat.emin prec emax)\n     | Z.neg _ => F754_nan false 1\n     end\n    else\n     if Zeq_bool z (2 ^ ew - 1)\n     then\n      match mx with\n      | 0%Z => F754_infinity sx\n      | Z.pos plx => F754_nan sx plx\n      | Z.neg _ => F754_nan false 1\n      end\n     else\n      match (mx + 2 ^ mw)%Z with\n      | Z.pos px => F754_finite sx px (z + SpecFloat.emin prec emax - 1)\n      | _ => F754_nan false 1\n      end) = true ->\nmatch\n  (let\n   '(sx, mx) := p in\n    if Zeq_bool z 0\n    then\n     match mx with\n     | 0%Z => F754_zero sx\n     | Z.pos px => F754_finite sx px (SpecFloat.emin prec emax)\n     | Z.neg _ => F754_nan false 1\n     end\n    else\n     if Zeq_bool z (2 ^ ew - 1)\n     then\n      match mx with\n      | 0%Z => F754_infinity sx\n      | Z.pos plx => F754_nan sx plx\n      | Z.neg _ => F754_nan false 1\n      end\n     else\n      match (mx + 2 ^ mw)%Z with\n      | Z.pos px => F754_finite sx px (z + SpecFloat.emin prec emax - 1)\n      | _ => F754_nan false 1\n      end)\nwith\n| F754_zero sx => join_bits sx 0 0\n| F754_infinity sx => join_bits sx 0 (2 ^ ew - 1)\n| F754_nan b p0 => join_bits b (Z.pos p0) (2 ^ ew - 1)\n| F754_finite sx mx ex =>\n    if (0 <=? Z.pos mx - 2 ^ mw)%Z\n    then join_bits sx (Z.pos mx - 2 ^ mw) (ex - SpecFloat.emin prec emax + 1)\n    else join_bits sx (Z.pos mx) 0\nend = x.","proofString":"intros (sx, mx) ex Sx.\nassert (Bm: (0 <= mx < 2^mw)%Z).\ninversion_clear Sx.\napply Z_mod_lt.\nnow apply Z.lt_gt.\ncase Zeq_bool_spec ; intros He1.\ncase_eq mx.\nintros Hm Jx _.\nnow rewrite He1 in Jx.\nintros px Hm Jx _.\nrewrite Zle_bool_false.\nnow rewrite <- He1.\napply <- Z.lt_sub_0.\nnow rewrite <- Hm.\nintros px Hm _ _.\napply False_ind.\napply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm.\ncase Zeq_bool_spec ; intros He2.\ncase_eq mx; intros Hm.\nnow rewrite He2.\nnow rewrite He2.\nintros ; lia.\ncase_eq (mx + 2 ^ mw)%Z.\nintros Hm.\napply False_ind.\nclear -Bm Hm ; lia.\nintros p Hm Jx Cx.\nrewrite <- Hm.\nrewrite Zle_bool_true.\nnow ring_simplify (mx + 2^mw - 2^mw)%Z (ex + emin - 1 - emin + 1)%Z.\nnow ring_simplify.\nintros p Hm.\napply False_ind.\nclear -Bm Hm ; lia."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) : join_bits sx mx ex = x ->\nvalid_binary prec emax\n  (if Zeq_bool ex 0\n   then\n    match mx with\n    | 0%Z => F754_zero sx\n    | Z.pos px => F754_finite sx px (SpecFloat.emin prec emax)\n    | Z.neg _ => F754_nan false 1\n    end\n   else\n    if Zeq_bool ex (2 ^ ew - 1)\n    then\n     match mx with\n     | 0%Z => F754_infinity sx\n     | Z.pos plx => F754_nan sx plx\n     | Z.neg _ => F754_nan false 1\n     end\n    else\n     match (mx + 2 ^ mw)%Z with\n     | Z.pos px => F754_finite sx px (ex + SpecFloat.emin prec emax - 1)\n     | _ => F754_nan false 1\n     end) = true ->\nmatch\n  (if Zeq_bool ex 0\n   then\n    match mx with\n    | 0%Z => F754_zero sx\n    | Z.pos px => F754_finite sx px (SpecFloat.emin prec emax)\n    | Z.neg _ => F754_nan false 1\n    end\n   else\n    if Zeq_bool ex (2 ^ ew - 1)\n    then\n     match mx with\n     | 0%Z => F754_infinity sx\n     | Z.pos plx => F754_nan sx plx\n     | Z.neg _ => F754_nan false 1\n     end\n    else\n     match (mx + 2 ^ mw)%Z with\n     | Z.pos px => F754_finite sx px (ex + SpecFloat.emin prec emax - 1)\n     | _ => F754_nan false 1\n     end)\nwith\n| F754_zero sx0 => join_bits sx0 0 0\n| F754_infinity sx0 => join_bits sx0 0 (2 ^ ew - 1)\n| F754_nan b p => join_bits b (Z.pos p) (2 ^ ew - 1)\n| F754_finite sx0 mx0 ex0 =>\n    if (0 <=? Z.pos mx0 - 2 ^ mw)%Z\n    then\n     join_bits sx0 (Z.pos mx0 - 2 ^ mw) (ex0 - SpecFloat.emin prec emax + 1)\n    else join_bits sx0 (Z.pos mx0) 0\nend = x.","proofString":"assert (Bm: (0 <= mx < 2^mw)%Z).\ninversion_clear Sx.\napply Z_mod_lt.\nnow apply Z.lt_gt.\ncase Zeq_bool_spec ; intros He1.\ncase_eq mx.\nintros Hm Jx _.\nnow rewrite He1 in Jx.\nintros px Hm Jx _.\nrewrite Zle_bool_false.\nnow rewrite <- He1.\napply <- Z.lt_sub_0.\nnow rewrite <- Hm.\nintros px Hm _ _.\napply False_ind.\napply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm.\ncase Zeq_bool_spec ; intros He2.\ncase_eq mx; intros Hm.\nnow rewrite He2.\nnow rewrite He2.\nintros ; lia.\ncase_eq (mx + 2 ^ mw)%Z.\nintros Hm.\napply False_ind.\nclear -Bm Hm ; lia.\nintros p Hm Jx Cx.\nrewrite <- Hm.\nrewrite Zle_bool_true.\nnow ring_simplify (mx + 2^mw - 2^mw)%Z (ex + emin - 1 - emin + 1)%Z.\nnow ring_simplify.\nintros p Hm.\napply False_ind.\nclear -Bm Hm ; lia."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) : (0 <= mx < 2 ^ mw)%Z.","proofString":"inversion_clear Sx.\napply Z_mod_lt.\nnow apply Z.lt_gt."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) : (0 <= x mod 2 ^ mw < 2 ^ mw)%Z.","proofString":"apply Z_mod_lt.\nnow apply Z.lt_gt."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) : (2 ^ mw > 0)%Z.","proofString":"now apply Z.lt_gt."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) : join_bits sx mx ex = x ->\nvalid_binary prec emax\n  (if Zeq_bool ex 0\n   then\n    match mx with\n    | 0%Z => F754_zero sx\n    | Z.pos px => F754_finite sx px (SpecFloat.emin prec emax)\n    | Z.neg _ => F754_nan false 1\n    end\n   else\n    if Zeq_bool ex (2 ^ ew - 1)\n    then\n     match mx with\n     | 0%Z => F754_infinity sx\n     | Z.pos plx => F754_nan sx plx\n     | Z.neg _ => F754_nan false 1\n     end\n    else\n     match (mx + 2 ^ mw)%Z with\n     | Z.pos px => F754_finite sx px (ex + SpecFloat.emin prec emax - 1)\n     | _ => F754_nan false 1\n     end) = true ->\nmatch\n  (if Zeq_bool ex 0\n   then\n    match mx with\n    | 0%Z => F754_zero sx\n    | Z.pos px => F754_finite sx px (SpecFloat.emin prec emax)\n    | Z.neg _ => F754_nan false 1\n    end\n   else\n    if Zeq_bool ex (2 ^ ew - 1)\n    then\n     match mx with\n     | 0%Z => F754_infinity sx\n     | Z.pos plx => F754_nan sx plx\n     | Z.neg _ => F754_nan false 1\n     end\n    else\n     match (mx + 2 ^ mw)%Z with\n     | Z.pos px => F754_finite sx px (ex + SpecFloat.emin prec emax - 1)\n     | _ => F754_nan false 1\n     end)\nwith\n| F754_zero sx0 => join_bits sx0 0 0\n| F754_infinity sx0 => join_bits sx0 0 (2 ^ ew - 1)\n| F754_nan b p => join_bits b (Z.pos p) (2 ^ ew - 1)\n| F754_finite sx0 mx0 ex0 =>\n    if (0 <=? Z.pos mx0 - 2 ^ mw)%Z\n    then\n     join_bits sx0 (Z.pos mx0 - 2 ^ mw) (ex0 - SpecFloat.emin prec emax + 1)\n    else join_bits sx0 (Z.pos mx0) 0\nend = x.","proofString":"case Zeq_bool_spec ; intros He1.\ncase_eq mx.\nintros Hm Jx _.\nnow rewrite He1 in Jx.\nintros px Hm Jx _.\nrewrite Zle_bool_false.\nnow rewrite <- He1.\napply <- Z.lt_sub_0.\nnow rewrite <- Hm.\nintros px Hm _ _.\napply False_ind.\napply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm.\ncase Zeq_bool_spec ; intros He2.\ncase_eq mx; intros Hm.\nnow rewrite He2.\nnow rewrite He2.\nintros ; lia.\ncase_eq (mx + 2 ^ mw)%Z.\nintros Hm.\napply False_ind.\nclear -Bm Hm ; lia.\nintros p Hm Jx Cx.\nrewrite <- Hm.\nrewrite Zle_bool_true.\nnow ring_simplify (mx + 2^mw - 2^mw)%Z (ex + emin - 1 - emin + 1)%Z.\nnow ring_simplify.\nintros p Hm.\napply False_ind.\nclear -Bm Hm ; lia."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex = 0%Z) : join_bits sx mx ex = x ->\nvalid_binary prec emax\n  match mx with\n  | 0%Z => F754_zero sx\n  | Z.pos px => F754_finite sx px (SpecFloat.emin prec emax)\n  | Z.neg _ => F754_nan false 1\n  end = true ->\nmatch\n  match mx with\n  | 0%Z => F754_zero sx\n  | Z.pos px => F754_finite sx px (SpecFloat.emin prec emax)\n  | Z.neg _ => F754_nan false 1\n  end\nwith\n| F754_zero sx0 => join_bits sx0 0 0\n| F754_infinity sx0 => join_bits sx0 0 (2 ^ ew - 1)\n| F754_nan b p => join_bits b (Z.pos p) (2 ^ ew - 1)\n| F754_finite sx0 mx0 ex0 =>\n    if (0 <=? Z.pos mx0 - 2 ^ mw)%Z\n    then\n     join_bits sx0 (Z.pos mx0 - 2 ^ mw) (ex0 - SpecFloat.emin prec emax + 1)\n    else join_bits sx0 (Z.pos mx0) 0\nend = x.","proofString":"case_eq mx.\nintros Hm Jx _.\nnow rewrite He1 in Jx.\nintros px Hm Jx _.\nrewrite Zle_bool_false.\nnow rewrite <- He1.\napply <- Z.lt_sub_0.\nnow rewrite <- Hm.\nintros px Hm _ _.\napply False_ind.\napply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex = 0%Z) : mx = 0%Z ->\njoin_bits sx 0 ex = x ->\nvalid_binary prec emax (F754_zero sx) = true -> join_bits sx 0 0 = x.","proofString":"intros Hm Jx _.\nnow rewrite He1 in Jx."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex = 0%Z) (Hm : mx = 0%Z) (Jx : join_bits sx 0 ex = x) : join_bits sx 0 0 = x.","proofString":"now rewrite He1 in Jx."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex = 0%Z) : forall p : positive,\nmx = Z.pos p ->\njoin_bits sx (Z.pos p) ex = x ->\nvalid_binary prec emax (F754_finite sx p (SpecFloat.emin prec emax)) = true ->\n(if (0 <=? Z.pos p - 2 ^ mw)%Z\n then\n  join_bits sx (Z.pos p - 2 ^ mw)\n    (SpecFloat.emin prec emax - SpecFloat.emin prec emax + 1)\n else join_bits sx (Z.pos p) 0) = x.","proofString":"intros px Hm Jx _.\nrewrite Zle_bool_false.\nnow rewrite <- He1.\napply <- Z.lt_sub_0.\nnow rewrite <- Hm."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex = 0%Z) (px : positive) (Hm : mx = Z.pos px) (Jx : join_bits sx (Z.pos px) ex = x) : (if (0 <=? Z.pos px - 2 ^ mw)%Z\n then\n  join_bits sx (Z.pos px - 2 ^ mw)\n    (SpecFloat.emin prec emax - SpecFloat.emin prec emax + 1)\n else join_bits sx (Z.pos px) 0) = x.","proofString":"rewrite Zle_bool_false.\nnow rewrite <- He1.\napply <- Z.lt_sub_0.\nnow rewrite <- Hm."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex = 0%Z) (px : positive) (Hm : mx = Z.pos px) (Jx : join_bits sx (Z.pos px) ex = x) : join_bits sx (Z.pos px) 0 = x.","proofString":"now rewrite <- He1."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex = 0%Z) (px : positive) (Hm : mx = Z.pos px) (Jx : join_bits sx (Z.pos px) ex = x) : (Z.pos px - 2 ^ mw < 0)%Z.","proofString":"apply <- Z.lt_sub_0.\nnow rewrite <- Hm."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex = 0%Z) (px : positive) (Hm : mx = Z.pos px) (Jx : join_bits sx (Z.pos px) ex = x) : (Z.pos px < 2 ^ mw)%Z.","proofString":"now rewrite <- Hm."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex = 0%Z) : forall p : positive,\nmx = Z.neg p ->\njoin_bits sx (Z.neg p) ex = x ->\nvalid_binary prec emax (F754_nan false 1) = true ->\njoin_bits false 1 (2 ^ ew - 1) = x.","proofString":"intros px Hm _ _.\napply False_ind.\napply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex = 0%Z) (px : positive) (Hm : mx = Z.neg px) : join_bits false 1 (2 ^ ew - 1) = x.","proofString":"apply False_ind.\napply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex = 0%Z) (px : positive) (Hm : mx = Z.neg px) : False.","proofString":"apply Zle_not_lt with (1 := proj1 Bm).\nnow rewrite Hm."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex = 0%Z) (px : positive) (Hm : mx = Z.neg px) : (mx < 0)%Z.","proofString":"now rewrite Hm."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex <> 0%Z) : join_bits sx mx ex = x ->\nvalid_binary prec emax\n  (if Zeq_bool ex (2 ^ ew - 1)\n   then\n    match mx with\n    | 0%Z => F754_infinity sx\n    | Z.pos plx => F754_nan sx plx\n    | Z.neg _ => F754_nan false 1\n    end\n   else\n    match (mx + 2 ^ mw)%Z with\n    | Z.pos px => F754_finite sx px (ex + SpecFloat.emin prec emax - 1)\n    | _ => F754_nan false 1\n    end) = true ->\nmatch\n  (if Zeq_bool ex (2 ^ ew - 1)\n   then\n    match mx with\n    | 0%Z => F754_infinity sx\n    | Z.pos plx => F754_nan sx plx\n    | Z.neg _ => F754_nan false 1\n    end\n   else\n    match (mx + 2 ^ mw)%Z with\n    | Z.pos px => F754_finite sx px (ex + SpecFloat.emin prec emax - 1)\n    | _ => F754_nan false 1\n    end)\nwith\n| F754_zero sx0 => join_bits sx0 0 0\n| F754_infinity sx0 => join_bits sx0 0 (2 ^ ew - 1)\n| F754_nan b p => join_bits b (Z.pos p) (2 ^ ew - 1)\n| F754_finite sx0 mx0 ex0 =>\n    if (0 <=? Z.pos mx0 - 2 ^ mw)%Z\n    then\n     join_bits sx0 (Z.pos mx0 - 2 ^ mw) (ex0 - SpecFloat.emin prec emax + 1)\n    else join_bits sx0 (Z.pos mx0) 0\nend = x.","proofString":"case Zeq_bool_spec ; intros He2.\ncase_eq mx; intros Hm.\nnow rewrite He2.\nnow rewrite He2.\nintros ; lia.\ncase_eq (mx + 2 ^ mw)%Z.\nintros Hm.\napply False_ind.\nclear -Bm Hm ; lia.\nintros p Hm Jx Cx.\nrewrite <- Hm.\nrewrite Zle_bool_true.\nnow ring_simplify (mx + 2^mw - 2^mw)%Z (ex + emin - 1 - emin + 1)%Z.\nnow ring_simplify.\nintros p Hm.\napply False_ind.\nclear -Bm Hm ; lia."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex <> 0%Z) (He2 : ex = (2 ^ ew - 1)%Z) (Hm : mx = 0%Z) : join_bits sx 0 ex = x ->\nvalid_binary prec emax (F754_infinity sx) = true ->\njoin_bits sx 0 (2 ^ ew - 1) = x.","proofString":"now rewrite He2."},{"statement":"(x : Z) (Hx : (0 <= x < 2 ^ (mw + ew + 1))%Z) (sx : bool) (mx ex : Z) (Sx : split_bits x = (sx, mx, ex)) (Bm : (0 <= mx < 2 ^ mw)%Z) (He1 : ex <> 0%Z) (He2 : ex = (2 ^ ew - 1)%Z) (Hm : positive) : mx = Z.pos Hm ->\njoin_bits sx (Z.pos Hm) ex = x ->\nvalid_binary prec emax (F754_nan sx Hm) = true ->\njoin_bits sx (Z.pos Hm) (2 ^ ew - 1) = x.","proofString":"now rewrite He2."},{"statement":"(H : (3 ?= 128)%Z = Gt) : False.","proofString":"discriminate H."},{"statement":"(H : (3 ?= 1024)%Z = Gt) : False.","proofString":"discriminate H."}]}