{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/imm/src/travorder/TlsEventSets.v","fileSamples":[{"statement":"(T : trav_label -> Prop) (a : trav_action) (e : actid) : (exists y : trav_label, (T y /\\ a = action y) /\\ event y = e) <->\nT (mkTL a e).","conclusion":"(exists y : trav_label, (T y /\\ a = action y) /\\ event y = e) <->\nT (mkTL a e)","hypotheses":"(T : trav_label -> Prop) (a : trav_action) (e : actid)","proofString":"split; ins; desc; eauto.\ndestruct y; ins; by subst."},{"statement":"(T : trav_label -> Prop) (a : trav_action) (e : actid) (y : trav_label) (H : T y) (H1 : a = action y) (H0 : event y = e) : T (mkTL a e).","conclusion":"T (mkTL a e)","hypotheses":"(T : trav_label -> Prop) (a : trav_action) (e : actid) (y : trav_label) (H : T y) (H1 : a = action y) (H0 : event y = e)","proofString":"destruct y; ins; by subst."},{"statement":"(G : execution) (T : trav_label -> Prop) : event\n↑₁ (T ∩₁ action ↓₁ (⋃₁t ∈ threads_set G \\₁ eq tid_init, eq (ta_propagate t)))\n≡₁ (⋃₁t ∈ threads_set G \\₁ eq tid_init,\n     event ↑₁ (T ∩₁ action ↓₁ eq (ta_propagate t))).","conclusion":"event\n↑₁ (T ∩₁ action ↓₁ (⋃₁t ∈ threads_set G \\₁ eq tid_init, eq (ta_propagate t)))\n≡₁ (⋃₁t ∈ threads_set G \\₁ eq tid_init,\n     event ↑₁ (T ∩₁ action ↓₁ eq (ta_propagate t)))","hypotheses":"(G : execution) (T : trav_label -> Prop)","proofString":"basic_solver 10."},{"statement":"(e : actid) : event ↑₁ (eq (mkTL ta_cover e) ∩₁ action ↓₁ eq ta_cover) ≡₁ eq e.","conclusion":"event ↑₁ (eq (mkTL ta_cover e) ∩₁ action ↓₁ eq ta_cover) ≡₁ eq e","hypotheses":"(e : actid)","proofString":"rewrite set_inter_absorb_r; basic_solver."},{"statement":"(s : actid -> Prop) : event ↑₁ (eq ta_reserve <*> s ∩₁ action ↓₁ eq ta_reserve) ≡₁ s.","conclusion":"event ↑₁ (eq ta_reserve <*> s ∩₁ action ↓₁ eq ta_reserve) ≡₁ s","hypotheses":"(s : actid -> Prop)","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf.\neexists (_, _).\nsplits; ins; eauto."},{"statement":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_reserve <*> s) y) (H1 : ta_reserve = action y) : s (event y).","conclusion":"s (event y)","hypotheses":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_reserve <*> s) y) (H1 : ta_reserve = action y)","proofString":"destruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_reserve = t /\\ s a) (H1 : ta_reserve = t) : s a.","conclusion":"s a","hypotheses":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_reserve = t /\\ s a) (H1 : ta_reserve = t)","proofString":"desf."},{"statement":"(s : actid -> Prop) (x : actid) (H : s x) : exists y : trav_label,\n  ((eq ta_reserve <*> s) y /\\ ta_reserve = action y) /\\ event y = x.","conclusion":"exists y : trav_label,\n  ((eq ta_reserve <*> s) y /\\ ta_reserve = action y) /\\ event y = x","hypotheses":"(s : actid -> Prop) (x : actid) (H : s x)","proofString":"eexists (_, _).\nsplits; ins; eauto."},{"statement":"(e : actid) : event ↑₁ (eq (mkTL ta_reserve e) ∩₁ action ↓₁ eq ta_reserve) ≡₁ eq e.","conclusion":"event ↑₁ (eq (mkTL ta_reserve e) ∩₁ action ↓₁ eq ta_reserve) ≡₁ eq e","hypotheses":"(e : actid)","proofString":"unfolder; split; ins; desf.\neexists (_, _).\nsplits; ins; eauto."},{"statement":"(x : actid) : exists y : trav_label,\n  (mkTL ta_reserve x = y /\\ ta_reserve = action y) /\\ event y = x.","conclusion":"exists y : trav_label,\n  (mkTL ta_reserve x = y /\\ ta_reserve = action y) /\\ event y = x","hypotheses":"(x : actid)","proofString":"eexists (_, _).\nsplits; ins; eauto."},{"statement":"(tid : thread_id) (e : actid) : event ↑₁ (eq (mkTL (ta_propagate tid) e) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","conclusion":"event ↑₁ (eq (mkTL (ta_propagate tid) e) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅","hypotheses":"(tid : thread_id) (e : actid)","proofString":"unfolder; split; ins; desf."},{"statement":"(tid : thread_id) (s : actid -> Prop) : event ↑₁ (eq (ta_propagate tid) <*> s ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","conclusion":"event ↑₁ (eq (ta_propagate tid) <*> s ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅","hypotheses":"(tid : thread_id) (s : actid -> Prop)","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf."},{"statement":"(tid : thread_id) (s : actid -> Prop) (y : trav_label) (H : (eq (ta_propagate tid) <*> s) y) (H1 : ta_reserve = action y) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s : actid -> Prop) (y : trav_label) (H : (eq (ta_propagate tid) <*> s) y) (H1 : ta_reserve = action y)","proofString":"destruct y; ins.\ndesf."},{"statement":"(tid : thread_id) (s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_propagate tid = t /\\ s a) (H1 : ta_reserve = t) : False.","conclusion":"False","hypotheses":"(tid : thread_id) (s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_propagate tid = t /\\ s a) (H1 : ta_reserve = t)","proofString":"desf."},{"statement":"(s : actid -> Prop) : event ↑₁ (eq ta_reserve <*> s ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","conclusion":"event ↑₁ (eq ta_reserve <*> s ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅","hypotheses":"(s : actid -> Prop)","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_reserve <*> s) y) (H1 : ta_issue = action y) : False.","conclusion":"False","hypotheses":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_reserve <*> s) y) (H1 : ta_issue = action y)","proofString":"destruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_reserve = t /\\ s a) (H1 : ta_issue = t) : False.","conclusion":"False","hypotheses":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_reserve = t /\\ s a) (H1 : ta_issue = t)","proofString":"desf."},{"statement":"(s : actid -> Prop) : event ↑₁ (eq ta_issue <*> s ∩₁ action ↓₁ eq ta_issue) ≡₁ s.","conclusion":"event ↑₁ (eq ta_issue <*> s ∩₁ action ↓₁ eq ta_issue) ≡₁ s","hypotheses":"(s : actid -> Prop)","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf.\neexists (_, _).\nsplits; ins; eauto."},{"statement":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_issue <*> s) y) (H1 : ta_issue = action y) : s (event y).","conclusion":"s (event y)","hypotheses":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_issue <*> s) y) (H1 : ta_issue = action y)","proofString":"destruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_issue = t /\\ s a) (H1 : ta_issue = t) : s a.","conclusion":"s a","hypotheses":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_issue = t /\\ s a) (H1 : ta_issue = t)","proofString":"desf."},{"statement":"(s : actid -> Prop) (x : actid) (H : s x) : exists y : trav_label,\n  ((eq ta_issue <*> s) y /\\ ta_issue = action y) /\\ event y = x.","conclusion":"exists y : trav_label,\n  ((eq ta_issue <*> s) y /\\ ta_issue = action y) /\\ event y = x","hypotheses":"(s : actid -> Prop) (x : actid) (H : s x)","proofString":"eexists (_, _).\nsplits; ins; eauto."},{"statement":"(s : actid -> Prop) : event ↑₁ (eq ta_cover <*> s ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","conclusion":"event ↑₁ (eq ta_cover <*> s ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅","hypotheses":"(s : actid -> Prop)","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_cover <*> s) y) (H1 : ta_issue = action y) : False.","conclusion":"False","hypotheses":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_cover <*> s) y) (H1 : ta_issue = action y)","proofString":"destruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_cover = t /\\ s a) (H1 : ta_issue = t) : False.","conclusion":"False","hypotheses":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_cover = t /\\ s a) (H1 : ta_issue = t)","proofString":"desf."},{"statement":"(G : execution) (s : actid -> Prop) : event\n↑₁ ((⋃₁t ∈ threads_set G \\₁ eq tid_init, eq (ta_propagate t)) <*> s\n    ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","conclusion":"event\n↑₁ ((⋃₁t ∈ threads_set G \\₁ eq tid_init, eq (ta_propagate t)) <*> s\n    ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅","hypotheses":"(G : execution) (s : actid -> Prop)","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf."},{"statement":"(G : execution) (s : actid -> Prop) (y : trav_label) (H : ((fun x : trav_action =>\n  exists y0 : thread_id,\n    (threads_set G y0 /\\ tid_init <> y0) /\\ ta_propagate y0 = x) <*> s) y) (H1 : ta_issue = action y) : False.","conclusion":"False","hypotheses":"(G : execution) (s : actid -> Prop) (y : trav_label) (H : ((fun x : trav_action =>\n  exists y0 : thread_id,\n    (threads_set G y0 /\\ tid_init <> y0) /\\ ta_propagate y0 = x) <*> s) y) (H1 : ta_issue = action y)","proofString":"destruct y; ins.\ndesf."},{"statement":"(G : execution) (s : actid -> Prop) (t : trav_action) (a : actid) (H : (exists y : thread_id,\n   (threads_set G y /\\ tid_init <> y) /\\ ta_propagate y = t) /\\ \ns a) (H1 : ta_issue = t) : False.","conclusion":"False","hypotheses":"(G : execution) (s : actid -> Prop) (t : trav_action) (a : actid) (H : (exists y : thread_id,\n   (threads_set G y /\\ tid_init <> y) /\\ ta_propagate y = t) /\\ \ns a) (H1 : ta_issue = t)","proofString":"desf."},{"statement":"(s : actid -> Prop) : event ↑₁ (eq ta_reserve <*> s ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","conclusion":"event ↑₁ (eq ta_reserve <*> s ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅","hypotheses":"(s : actid -> Prop)","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_reserve <*> s) y) (H1 : ta_cover = action y) : False.","conclusion":"False","hypotheses":"(s : actid -> Prop) (y : trav_label) (H : (eq ta_reserve <*> s) y) (H1 : ta_cover = action y)","proofString":"destruct y; ins.\ndesf."},{"statement":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_reserve = t /\\ s a) (H1 : ta_cover = t) : False.","conclusion":"False","hypotheses":"(s : actid -> Prop) (t : trav_action) (a : actid) (H : ta_reserve = t /\\ s a) (H1 : ta_cover = t)","proofString":"desf."},{"statement":"event ↑₁ (action ↓₁ eq ta_reserve ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","conclusion":"event ↑₁ (action ↓₁ eq ta_reserve ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅","hypotheses":"","proofString":"unfolder; split; ins; desf.\ndestruct y; ins.\ndesf."},{"statement":"(y : trav_label) (H : ta_reserve = action y) (H1 : ta_cover = action y) : False.","conclusion":"False","hypotheses":"(y : trav_label) (H : ta_reserve = action y) (H1 : ta_cover = action y)","proofString":"destruct y; ins.\ndesf."},{"statement":"(t : trav_action) (a : actid) (H : ta_reserve = t) (H1 : ta_cover = t) : False.","conclusion":"False","hypotheses":"(t : trav_action) (a : actid) (H : ta_reserve = t) (H1 : ta_cover = t)","proofString":"desf."},{"statement":"(w : actid) : event ↑₁ (eq (ta_cover, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","conclusion":"event ↑₁ (eq (ta_cover, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅","hypotheses":"(w : actid)","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_cover, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","conclusion":"event ↑₁ (eq (ta_cover, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅","hypotheses":"(w : actid)","proofString":"basic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ eq w.","conclusion":"event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ eq w","hypotheses":"(w : actid)","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ eq w.","conclusion":"event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ eq w","hypotheses":"(w : actid)","proofString":"basic_solver 10."},{"statement":"(tid : thread_id) (e : actid) : event ↑₁ (eq (mkTL (ta_propagate tid) e) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","conclusion":"event ↑₁ (eq (mkTL (ta_propagate tid) e) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅","hypotheses":"(tid : thread_id) (e : actid)","proofString":"unfolder; split; ins; desf."},{"statement":"(tid : thread_id) (e : actid) : event ↑₁ (eq (mkTL (ta_propagate tid) e) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","conclusion":"event ↑₁ (eq (mkTL (ta_propagate tid) e) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅","hypotheses":"(tid : thread_id) (e : actid)","proofString":"unfolder; split; ins; desf."},{"statement":"(w : actid) : event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","conclusion":"event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅","hypotheses":"(w : actid)","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","conclusion":"event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅","hypotheses":"(w : actid)","proofString":"basic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_reserve, w) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","conclusion":"event ↑₁ (eq (ta_reserve, w) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅","hypotheses":"(w : actid)","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_reserve, w) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","conclusion":"event ↑₁ (eq (ta_reserve, w) ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅","hypotheses":"(w : actid)","proofString":"basic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_reserve, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","conclusion":"event ↑₁ (eq (ta_reserve, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅","hypotheses":"(w : actid)","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_reserve, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","conclusion":"event ↑₁ (eq (ta_reserve, w) ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅","hypotheses":"(w : actid)","proofString":"basic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","conclusion":"event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅","hypotheses":"(w : actid)","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","conclusion":"event ↑₁ (eq (ta_issue, w) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅","hypotheses":"(w : actid)","proofString":"basic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_cover, w) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","conclusion":"event ↑₁ (eq (ta_cover, w) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅","hypotheses":"(w : actid)","proofString":"clear.\nbasic_solver 10."},{"statement":"(w : actid) : event ↑₁ (eq (ta_cover, w) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","conclusion":"event ↑₁ (eq (ta_cover, w) ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅","hypotheses":"(w : actid)","proofString":"basic_solver 10."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) : event ↑₁ (T1 ∩₁ action ↓₁ eq a) ∩₁ event ↑₁ (T2 ∩₁ action ↓₁ eq a)\n⊆₁ event ↑₁ (T1 ∩₁ T2 ∩₁ action ↓₁ eq a).","conclusion":"event ↑₁ (T1 ∩₁ action ↓₁ eq a) ∩₁ event ↑₁ (T2 ∩₁ action ↓₁ eq a)\n⊆₁ event ↑₁ (T1 ∩₁ T2 ∩₁ action ↓₁ eq a)","hypotheses":"(T1 T2 : trav_label -> Prop) (a : trav_action)","proofString":"unfolder.\nins.\ndesc.\ndestruct y, y0; ins; subst.\neauto."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) : forall x : actid,\n(exists y : trav_label, (T1 y /\\ a = action y) /\\ event y = x) /\\\n(exists y : trav_label, (T2 y /\\ a = action y) /\\ event y = x) ->\nexists y : trav_label, ((T1 y /\\ T2 y) /\\ a = action y) /\\ event y = x.","conclusion":"forall x : actid,\n(exists y : trav_label, (T1 y /\\ a = action y) /\\ event y = x) /\\\n(exists y : trav_label, (T2 y /\\ a = action y) /\\ event y = x) ->\nexists y : trav_label, ((T1 y /\\ T2 y) /\\ a = action y) /\\ event y = x","hypotheses":"(T1 T2 : trav_label -> Prop) (a : trav_action)","proofString":"ins.\ndesc.\ndestruct y, y0; ins; subst.\neauto."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) (x : actid) (H : (exists y : trav_label, (T1 y /\\ a = action y) /\\ event y = x) /\\\n(exists y : trav_label, (T2 y /\\ a = action y) /\\ event y = x)) : exists y : trav_label, ((T1 y /\\ T2 y) /\\ a = action y) /\\ event y = x.","conclusion":"exists y : trav_label, ((T1 y /\\ T2 y) /\\ a = action y) /\\ event y = x","hypotheses":"(T1 T2 : trav_label -> Prop) (a : trav_action) (x : actid) (H : (exists y : trav_label, (T1 y /\\ a = action y) /\\ event y = x) /\\\n(exists y : trav_label, (T2 y /\\ a = action y) /\\ event y = x))","proofString":"desc.\ndestruct y, y0; ins; subst.\neauto."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) (x : actid) (y0 : trav_label) (H : T1 y0) (H4 : a = action y0) (H3 : event y0 = x) (y : trav_label) (H0 : T2 y) (H2 : a = action y) (H1 : event y = x) : exists y1 : trav_label, ((T1 y1 /\\ T2 y1) /\\ a = action y1) /\\ event y1 = x.","conclusion":"exists y1 : trav_label, ((T1 y1 /\\ T2 y1) /\\ a = action y1) /\\ event y1 = x","hypotheses":"(T1 T2 : trav_label -> Prop) (a : trav_action) (x : actid) (y0 : trav_label) (H : T1 y0) (H4 : a = action y0) (H3 : event y0 = x) (y : trav_label) (H0 : T2 y) (H2 : a = action y) (H1 : event y = x)","proofString":"destruct y, y0; ins; subst.\neauto."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H : T1 (t, x)) (H0 : T2 (t, x)) : exists y : trav_label, ((T1 y /\\ T2 y) /\\ t = action y) /\\ event y = x.","conclusion":"exists y : trav_label, ((T1 y /\\ T2 y) /\\ t = action y) /\\ event y = x","hypotheses":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H : T1 (t, x)) (H0 : T2 (t, x))","proofString":"eauto."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) : event ↑₁ ((T1 \\₁ T2) ∩₁ action ↓₁ eq a)\n⊆₁ event ↑₁ (T1 ∩₁ action ↓₁ eq a) \\₁ event ↑₁ (T2 ∩₁ action ↓₁ eq a).","conclusion":"event ↑₁ ((T1 \\₁ T2) ∩₁ action ↓₁ eq a)\n⊆₁ event ↑₁ (T1 ∩₁ action ↓₁ eq a) \\₁ event ↑₁ (T2 ∩₁ action ↓₁ eq a)","hypotheses":"(T1 T2 : trav_label -> Prop) (a : trav_action)","proofString":"unfolder.\nins.\ndesc.\ndestruct y; ins; subst.\nsplits; try by eauto.\nintro.\ndesc.\nins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) : forall x : actid,\n(exists y : trav_label, ((T1 y /\\ ~ T2 y) /\\ a = action y) /\\ event y = x) ->\n(exists y : trav_label, (T1 y /\\ a = action y) /\\ event y = x) /\\\n~ (exists y : trav_label, (T2 y /\\ a = action y) /\\ event y = x).","conclusion":"forall x : actid,\n(exists y : trav_label, ((T1 y /\\ ~ T2 y) /\\ a = action y) /\\ event y = x) ->\n(exists y : trav_label, (T1 y /\\ a = action y) /\\ event y = x) /\\\n~ (exists y : trav_label, (T2 y /\\ a = action y) /\\ event y = x)","hypotheses":"(T1 T2 : trav_label -> Prop) (a : trav_action)","proofString":"ins.\ndesc.\ndestruct y; ins; subst.\nsplits; try by eauto.\nintro.\ndesc.\nins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (a : trav_action) (x : actid) (H : exists y : trav_label, ((T1 y /\\ ~ T2 y) /\\ a = action y) /\\ event y = x) : (exists y : trav_label, (T1 y /\\ a = action y) /\\ event y = x) /\\\n~ (exists y : trav_label, (T2 y /\\ a = action y) /\\ event y = x).","conclusion":"(exists y : trav_label, (T1 y /\\ a = action y) /\\ event y = x) /\\\n~ (exists y : trav_label, (T2 y /\\ a = action y) /\\ event y = x)","hypotheses":"(T1 T2 : trav_label -> Prop) (a : trav_action) (x : actid) (H : exists y : trav_label, ((T1 y /\\ ~ T2 y) /\\ a = action y) /\\ event y = x)","proofString":"desc.\ndestruct y; ins; subst.\nsplits; try by eauto.\nintro.\ndesc.\nins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) : (exists y : trav_label, (T1 y /\\ t = action y) /\\ event y = x) /\\\n~ (exists y : trav_label, (T2 y /\\ t = action y) /\\ event y = x).","conclusion":"(exists y : trav_label, (T1 y /\\ t = action y) /\\ event y = x) /\\\n~ (exists y : trav_label, (T2 y /\\ t = action y) /\\ event y = x)","hypotheses":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x))","proofString":"splits; try by eauto.\nintro.\ndesc.\nins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) : ~ (exists y : trav_label, (T2 y /\\ t = action y) /\\ event y = x).","conclusion":"~ (exists y : trav_label, (T2 y /\\ t = action y) /\\ event y = x)","hypotheses":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x))","proofString":"intro.\ndesc.\nins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) (H0 : exists y : trav_label, (T2 y /\\ t = action y) /\\ event y = x) : False.","conclusion":"False","hypotheses":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) (H0 : exists y : trav_label, (T2 y /\\ t = action y) /\\ event y = x)","proofString":"desc.\nins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) (y : trav_label) (H0 : T2 y) (H3 : t = action y) (H1 : event y = x) : False.","conclusion":"False","hypotheses":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) (y : trav_label) (H0 : T2 y) (H3 : t = action y) (H1 : event y = x)","proofString":"ins.\ndesc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) (y : trav_label) (H0 : T2 y) (H3 : t = action y) (H1 : event y = x) : False.","conclusion":"False","hypotheses":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) (y : trav_label) (H0 : T2 y) (H3 : t = action y) (H1 : event y = x)","proofString":"desc.\ndestruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) (y : trav_label) (H0 : T2 y) (H3 : t = action y) (H1 : event y = x) : False.","conclusion":"False","hypotheses":"(T1 T2 : trav_label -> Prop) (x : actid) (t : trav_action) (H2 : ~ T2 (t, x)) (H : T1 (t, x)) (y : trav_label) (H0 : T2 y) (H3 : t = action y) (H1 : event y = x)","proofString":"destruct y; ins; subst.\ndone."},{"statement":"(T1 T2 : trav_label -> Prop) (x : actid) (t0 : trav_action) (H : T1 (t0, x)) (H2 : ~ T2 (t0, x)) (H0 : T2 (t0, x)) : False.","conclusion":"False","hypotheses":"(T1 T2 : trav_label -> Prop) (x : actid) (t0 : trav_action) (H : T1 (t0, x)) (H2 : ~ T2 (t0, x)) (H0 : T2 (t0, x))","proofString":"done."},{"statement":"(A : actid -> Prop) : event ↑₁ (event ↓₁ A ∩₁ action ↓₁ eq ta_cover) ⊆₁ A.","conclusion":"event ↑₁ (event ↓₁ A ∩₁ action ↓₁ eq ta_cover) ⊆₁ A","hypotheses":"(A : actid -> Prop)","proofString":"basic_solver."},{"statement":"(A : actid -> Prop) : event ↑₁ (event ↓₁ A ∩₁ action ↓₁ eq ta_issue) ⊆₁ A.","conclusion":"event ↑₁ (event ↓₁ A ∩₁ action ↓₁ eq ta_issue) ⊆₁ A","hypotheses":"(A : actid -> Prop)","proofString":"basic_solver."},{"statement":"(A : actid -> Prop) : event ↑₁ (event ↓₁ A ∩₁ action ↓₁ eq ta_reserve) ⊆₁ A.","conclusion":"event ↑₁ (event ↓₁ A ∩₁ action ↓₁ eq ta_reserve) ⊆₁ A","hypotheses":"(A : actid -> Prop)","proofString":"basic_solver."},{"statement":"(G : execution) (A : actid -> Prop) : event ↑₁ (event ↓₁ A ∩₁ action ↓₁ is_ta_propagate_to_G G) ⊆₁ A.","conclusion":"event ↑₁ (event ↓₁ A ∩₁ action ↓₁ is_ta_propagate_to_G G) ⊆₁ A","hypotheses":"(G : execution) (A : actid -> Prop)","proofString":"basic_solver."},{"statement":"(T1 T2 : trav_label -> Prop) : event ↑₁ ((T1 ∪₁ T2) ∩₁ action ↓₁ eq ta_cover)\n≡₁ event ↑₁ (T1 ∩₁ action ↓₁ eq ta_cover)\n   ∪₁ event ↑₁ (T2 ∩₁ action ↓₁ eq ta_cover).","conclusion":"event ↑₁ ((T1 ∪₁ T2) ∩₁ action ↓₁ eq ta_cover)\n≡₁ event ↑₁ (T1 ∩₁ action ↓₁ eq ta_cover)\n   ∪₁ event ↑₁ (T2 ∩₁ action ↓₁ eq ta_cover)","hypotheses":"(T1 T2 : trav_label -> Prop)","proofString":"basic_solver 10."},{"statement":"(T1 T2 : trav_label -> Prop) : event ↑₁ ((T1 ∪₁ T2) ∩₁ action ↓₁ eq ta_issue)\n≡₁ event ↑₁ (T1 ∩₁ action ↓₁ eq ta_issue)\n   ∪₁ event ↑₁ (T2 ∩₁ action ↓₁ eq ta_issue).","conclusion":"event ↑₁ ((T1 ∪₁ T2) ∩₁ action ↓₁ eq ta_issue)\n≡₁ event ↑₁ (T1 ∩₁ action ↓₁ eq ta_issue)\n   ∪₁ event ↑₁ (T2 ∩₁ action ↓₁ eq ta_issue)","hypotheses":"(T1 T2 : trav_label -> Prop)","proofString":"basic_solver 10."},{"statement":"(T1 T2 : trav_label -> Prop) : event ↑₁ ((T1 ∪₁ T2) ∩₁ action ↓₁ eq ta_reserve)\n≡₁ event ↑₁ (T1 ∩₁ action ↓₁ eq ta_reserve)\n   ∪₁ event ↑₁ (T2 ∩₁ action ↓₁ eq ta_reserve).","conclusion":"event ↑₁ ((T1 ∪₁ T2) ∩₁ action ↓₁ eq ta_reserve)\n≡₁ event ↑₁ (T1 ∩₁ action ↓₁ eq ta_reserve)\n   ∪₁ event ↑₁ (T2 ∩₁ action ↓₁ eq ta_reserve)","hypotheses":"(T1 T2 : trav_label -> Prop)","proofString":"basic_solver 10."},{"statement":"(G : execution) (T1 T2 : trav_label -> Prop) : event ↑₁ ((T1 ∪₁ T2) ∩₁ action ↓₁ is_ta_propagate_to_G G)\n≡₁ event ↑₁ (T1 ∩₁ action ↓₁ is_ta_propagate_to_G G)\n   ∪₁ event ↑₁ (T2 ∩₁ action ↓₁ is_ta_propagate_to_G G).","conclusion":"event ↑₁ ((T1 ∪₁ T2) ∩₁ action ↓₁ is_ta_propagate_to_G G)\n≡₁ event ↑₁ (T1 ∩₁ action ↓₁ is_ta_propagate_to_G G)\n   ∪₁ event ↑₁ (T2 ∩₁ action ↓₁ is_ta_propagate_to_G G)","hypotheses":"(G : execution) (T1 T2 : trav_label -> Prop)","proofString":"basic_solver 10."},{"statement":"(e : actid) : event ↑₁ (eq (mkTL ta_cover e) ∩₁ action ↓₁ eq ta_cover) ≡₁ eq e.","conclusion":"event ↑₁ (eq (mkTL ta_cover e) ∩₁ action ↓₁ eq ta_cover) ≡₁ eq e","hypotheses":"(e : actid)","proofString":"split; basic_solver."},{"statement":"(e : actid) : event ↑₁ (eq (mkTL ta_issue e) ∩₁ action ↓₁ eq ta_issue) ≡₁ eq e.","conclusion":"event ↑₁ (eq (mkTL ta_issue e) ∩₁ action ↓₁ eq ta_issue) ≡₁ eq e","hypotheses":"(e : actid)","proofString":"split; basic_solver."},{"statement":"(e : actid) : event ↑₁ (eq (mkTL ta_reserve e) ∩₁ action ↓₁ eq ta_reserve) ≡₁ eq e.","conclusion":"event ↑₁ (eq (mkTL ta_reserve e) ∩₁ action ↓₁ eq ta_reserve) ≡₁ eq e","hypotheses":"(e : actid)","proofString":"split; basic_solver."},{"statement":"(S : trav_label -> Prop) (NONCOVER : set_disjoint S (action ↓₁ eq ta_cover)) : event ↑₁ (S ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅.","conclusion":"event ↑₁ (S ∩₁ action ↓₁ eq ta_cover) ≡₁ ∅","hypotheses":"(S : trav_label -> Prop) (NONCOVER : set_disjoint S (action ↓₁ eq ta_cover))","proofString":"split; basic_solver."},{"statement":"(S : trav_label -> Prop) (NONISSUE : set_disjoint S (action ↓₁ eq ta_issue)) : event ↑₁ (S ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅.","conclusion":"event ↑₁ (S ∩₁ action ↓₁ eq ta_issue) ≡₁ ∅","hypotheses":"(S : trav_label -> Prop) (NONISSUE : set_disjoint S (action ↓₁ eq ta_issue))","proofString":"split; basic_solver."},{"statement":"(S : trav_label -> Prop) (NONISSUE : set_disjoint S (action ↓₁ eq ta_reserve)) : event ↑₁ (S ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅.","conclusion":"event ↑₁ (S ∩₁ action ↓₁ eq ta_reserve) ≡₁ ∅","hypotheses":"(S : trav_label -> Prop) (NONISSUE : set_disjoint S (action ↓₁ eq ta_reserve))","proofString":"split; basic_solver."},{"statement":"(G : execution) (S : trav_label -> Prop) (NONPROP : set_disjoint S (action ↓₁ is_ta_propagate_to_G G)) : event ↑₁ (S ∩₁ action ↓₁ is_ta_propagate_to_G G) ≡₁ ∅.","conclusion":"event ↑₁ (S ∩₁ action ↓₁ is_ta_propagate_to_G G) ≡₁ ∅","hypotheses":"(G : execution) (S : trav_label -> Prop) (NONPROP : set_disjoint S (action ↓₁ is_ta_propagate_to_G G))","proofString":"split; basic_solver."},{"statement":"(M : trav_label -> Prop) (COV : M ⊆₁ action ↓₁ eq ta_cover) : event ↑₁ (M ∩₁ action ↓₁ eq ta_cover) ≡₁ event ↑₁ M.","conclusion":"event ↑₁ (M ∩₁ action ↓₁ eq ta_cover) ≡₁ event ↑₁ M","hypotheses":"(M : trav_label -> Prop) (COV : M ⊆₁ action ↓₁ eq ta_cover)","proofString":"split; [basic_solver| ].\napply set_collect_mori; auto.\ngeneralize COV.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (COV : M ⊆₁ action ↓₁ eq ta_cover) : event ↑₁ M ⊆₁ event ↑₁ (M ∩₁ action ↓₁ eq ta_cover).","conclusion":"event ↑₁ M ⊆₁ event ↑₁ (M ∩₁ action ↓₁ eq ta_cover)","hypotheses":"(M : trav_label -> Prop) (COV : M ⊆₁ action ↓₁ eq ta_cover)","proofString":"apply set_collect_mori; auto.\ngeneralize COV.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (COV : M ⊆₁ action ↓₁ eq ta_cover) : M ⊆₁ M ∩₁ action ↓₁ eq ta_cover.","conclusion":"M ⊆₁ M ∩₁ action ↓₁ eq ta_cover","hypotheses":"(M : trav_label -> Prop) (COV : M ⊆₁ action ↓₁ eq ta_cover)","proofString":"generalize COV.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (COV : M ⊆₁ action ↓₁ eq ta_cover) : M ⊆₁ action ↓₁ eq ta_cover -> M ⊆₁ M ∩₁ action ↓₁ eq ta_cover.","conclusion":"M ⊆₁ action ↓₁ eq ta_cover -> M ⊆₁ M ∩₁ action ↓₁ eq ta_cover","hypotheses":"(M : trav_label -> Prop) (COV : M ⊆₁ action ↓₁ eq ta_cover)","proofString":"basic_solver."},{"statement":"(M : trav_label -> Prop) (ISS : M ⊆₁ action ↓₁ eq ta_issue) : event ↑₁ (M ∩₁ action ↓₁ eq ta_issue) ≡₁ event ↑₁ M.","conclusion":"event ↑₁ (M ∩₁ action ↓₁ eq ta_issue) ≡₁ event ↑₁ M","hypotheses":"(M : trav_label -> Prop) (ISS : M ⊆₁ action ↓₁ eq ta_issue)","proofString":"split; [basic_solver| ].\napply set_collect_mori; auto.\ngeneralize ISS.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (ISS : M ⊆₁ action ↓₁ eq ta_issue) : event ↑₁ M ⊆₁ event ↑₁ (M ∩₁ action ↓₁ eq ta_issue).","conclusion":"event ↑₁ M ⊆₁ event ↑₁ (M ∩₁ action ↓₁ eq ta_issue)","hypotheses":"(M : trav_label -> Prop) (ISS : M ⊆₁ action ↓₁ eq ta_issue)","proofString":"apply set_collect_mori; auto.\ngeneralize ISS.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (ISS : M ⊆₁ action ↓₁ eq ta_issue) : M ⊆₁ M ∩₁ action ↓₁ eq ta_issue.","conclusion":"M ⊆₁ M ∩₁ action ↓₁ eq ta_issue","hypotheses":"(M : trav_label -> Prop) (ISS : M ⊆₁ action ↓₁ eq ta_issue)","proofString":"generalize ISS.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (ISS : M ⊆₁ action ↓₁ eq ta_issue) : M ⊆₁ action ↓₁ eq ta_issue -> M ⊆₁ M ∩₁ action ↓₁ eq ta_issue.","conclusion":"M ⊆₁ action ↓₁ eq ta_issue -> M ⊆₁ M ∩₁ action ↓₁ eq ta_issue","hypotheses":"(M : trav_label -> Prop) (ISS : M ⊆₁ action ↓₁ eq ta_issue)","proofString":"basic_solver."},{"statement":"(M : trav_label -> Prop) (RES : M ⊆₁ action ↓₁ eq ta_reserve) : event ↑₁ (M ∩₁ action ↓₁ eq ta_reserve) ≡₁ event ↑₁ M.","conclusion":"event ↑₁ (M ∩₁ action ↓₁ eq ta_reserve) ≡₁ event ↑₁ M","hypotheses":"(M : trav_label -> Prop) (RES : M ⊆₁ action ↓₁ eq ta_reserve)","proofString":"split; [basic_solver| ].\napply set_collect_mori; auto.\ngeneralize RES.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (RES : M ⊆₁ action ↓₁ eq ta_reserve) : event ↑₁ M ⊆₁ event ↑₁ (M ∩₁ action ↓₁ eq ta_reserve).","conclusion":"event ↑₁ M ⊆₁ event ↑₁ (M ∩₁ action ↓₁ eq ta_reserve)","hypotheses":"(M : trav_label -> Prop) (RES : M ⊆₁ action ↓₁ eq ta_reserve)","proofString":"apply set_collect_mori; auto.\ngeneralize RES.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (RES : M ⊆₁ action ↓₁ eq ta_reserve) : M ⊆₁ M ∩₁ action ↓₁ eq ta_reserve.","conclusion":"M ⊆₁ M ∩₁ action ↓₁ eq ta_reserve","hypotheses":"(M : trav_label -> Prop) (RES : M ⊆₁ action ↓₁ eq ta_reserve)","proofString":"generalize RES.\nbasic_solver."},{"statement":"(M : trav_label -> Prop) (RES : M ⊆₁ action ↓₁ eq ta_reserve) : M ⊆₁ action ↓₁ eq ta_reserve -> M ⊆₁ M ∩₁ action ↓₁ eq ta_reserve.","conclusion":"M ⊆₁ action ↓₁ eq ta_reserve -> M ⊆₁ M ∩₁ action ↓₁ eq ta_reserve","hypotheses":"(M : trav_label -> Prop) (RES : M ⊆₁ action ↓₁ eq ta_reserve)","proofString":"basic_solver."},{"statement":"(G : execution) (M : trav_label -> Prop) (PROP : M ⊆₁ action ↓₁ is_ta_propagate_to_G G) : event ↑₁ (M ∩₁ action ↓₁ is_ta_propagate_to_G G) ≡₁ event ↑₁ M.","conclusion":"event ↑₁ (M ∩₁ action ↓₁ is_ta_propagate_to_G G) ≡₁ event ↑₁ M","hypotheses":"(G : execution) (M : trav_label -> Prop) (PROP : M ⊆₁ action ↓₁ is_ta_propagate_to_G G)","proofString":"split; [basic_solver| ].\napply set_collect_mori; auto.\ngeneralize PROP.\nbasic_solver."},{"statement":"(G : execution) (M : trav_label -> Prop) (PROP : M ⊆₁ action ↓₁ is_ta_propagate_to_G G) : event ↑₁ M ⊆₁ event ↑₁ (M ∩₁ action ↓₁ is_ta_propagate_to_G G).","conclusion":"event ↑₁ M ⊆₁ event ↑₁ (M ∩₁ action ↓₁ is_ta_propagate_to_G G)","hypotheses":"(G : execution) (M : trav_label -> Prop) (PROP : M ⊆₁ action ↓₁ is_ta_propagate_to_G G)","proofString":"apply set_collect_mori; auto.\ngeneralize PROP.\nbasic_solver."},{"statement":"(G : execution) (M : trav_label -> Prop) (PROP : M ⊆₁ action ↓₁ is_ta_propagate_to_G G) : M ⊆₁ M ∩₁ action ↓₁ is_ta_propagate_to_G G.","conclusion":"M ⊆₁ M ∩₁ action ↓₁ is_ta_propagate_to_G G","hypotheses":"(G : execution) (M : trav_label -> Prop) (PROP : M ⊆₁ action ↓₁ is_ta_propagate_to_G G)","proofString":"generalize PROP.\nbasic_solver."},{"statement":"(G : execution) (M : trav_label -> Prop) (PROP : M ⊆₁ action ↓₁ is_ta_propagate_to_G G) : M ⊆₁ action ↓₁ is_ta_propagate_to_G G ->\nM ⊆₁ M ∩₁ action ↓₁ is_ta_propagate_to_G G.","conclusion":"M ⊆₁ action ↓₁ is_ta_propagate_to_G G ->\nM ⊆₁ M ∩₁ action ↓₁ is_ta_propagate_to_G G","hypotheses":"(G : execution) (M : trav_label -> Prop) (PROP : M ⊆₁ action ↓₁ is_ta_propagate_to_G G)","proofString":"basic_solver."},{"statement":"(T : trav_label -> Prop) (e : actid) : reserved T ∪₁ eq e ≡₁ reserved T ∪₁ eq e.","conclusion":"reserved T ∪₁ eq e ≡₁ reserved T ∪₁ eq e","hypotheses":"(T : trav_label -> Prop) (e : actid)","proofString":"basic_solver."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ W.","conclusion":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ W","hypotheses":"","proofString":"rewrite tlsc_I_in_W; eauto.\nbasic_solver."},{"statement":"event ↑₁ (event ↓₁ W) ⊆₁ W.","conclusion":"event ↑₁ (event ↓₁ W) ⊆₁ W","hypotheses":"","proofString":"basic_solver."},{"statement":"E ∩₁ W ⊆₁ E.","conclusion":"E ∩₁ W ⊆₁ E","hypotheses":"","proofString":"basic_solver 1."},{"statement":"E ∩₁ W ⊆₁ W.","conclusion":"E ∩₁ W ⊆₁ W","hypotheses":"","proofString":"basic_solver 1."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E.","conclusion":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E","hypotheses":"","proofString":"rewrite (tlsc_E WF TLSCOH).\nbasic_solver."},{"statement":"event ↑₁ (event ↓₁ E ∩₁ action ↓₁ eq ta_issue) ⊆₁ E.","conclusion":"event ↑₁ (event ↓₁ E ∩₁ action ↓₁ eq ta_issue) ⊆₁ E","hypotheses":"","proofString":"basic_solver."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_cover) ⊆₁ E.","conclusion":"event ↑₁ (T ∩₁ action ↓₁ eq ta_cover) ⊆₁ E","hypotheses":"","proofString":"rewrite (tlsc_E WF TLSCOH).\nbasic_solver."},{"statement":"event ↑₁ (event ↓₁ E ∩₁ action ↓₁ eq ta_cover) ⊆₁ E.","conclusion":"event ↑₁ (event ↓₁ E ∩₁ action ↓₁ eq ta_cover) ⊆₁ E","hypotheses":"","proofString":"basic_solver."},{"statement":"W ∩₁ event ↑₁ (T ∩₁ action ↓₁ eq ta_cover) ⊆₁ issued T.","conclusion":"W ∩₁ event ↑₁ (T ∩₁ action ↓₁ eq ta_cover) ⊆₁ issued T","hypotheses":"","proofString":"unfolder.\nins.\ndesc.\nforward eapply tlsc_w_covered_issued with (x := mkTL ta_cover x); eauto.\ndestruct y; ins; vauto."},{"statement":"forall x : actid,\nis_w (lab G) x /\\\n(exists y : trav_label, (T y /\\ ta_cover = action y) /\\ event y = x) ->\nissued T x.","conclusion":"forall x : actid,\nis_w (lab G) x /\\\n(exists y : trav_label, (T y /\\ ta_cover = action y) /\\ event y = x) ->\nissued T x","hypotheses":"","proofString":"ins.\ndesc.\nforward eapply tlsc_w_covered_issued with (x := mkTL ta_cover x); eauto.\ndestruct y; ins; vauto."},{"statement":"(x : actid) (H : is_w (lab G) x /\\\n(exists y : trav_label, (T y /\\ ta_cover = action y) /\\ event y = x)) : issued T x.","conclusion":"issued T x","hypotheses":"(x : actid) (H : is_w (lab G) x /\\\n(exists y : trav_label, (T y /\\ ta_cover = action y) /\\ event y = x))","proofString":"desc.\nforward eapply tlsc_w_covered_issued with (x := mkTL ta_cover x); eauto.\ndestruct y; ins; vauto."},{"statement":"(x : actid) (H : is_w (lab G) x) (y : trav_label) (H0 : T y) (H2 : ta_cover = action y) (H1 : event y = x) : issued T x.","conclusion":"issued T x","hypotheses":"(x : actid) (H : is_w (lab G) x) (y : trav_label) (H0 : T y) (H2 : ta_cover = action y) (H1 : event y = x)","proofString":"forward eapply tlsc_w_covered_issued with (x := mkTL ta_cover x); eauto.\ndestruct y; ins; vauto."},{"statement":"(x : actid) (H : is_w (lab G) x) (y : trav_label) (H0 : T y) (H2 : ta_cover = action y) (H1 : event y = x) : (T ∩₁ action ↓₁ eq ta_cover ∩₁ event ↓₁ W) (mkTL ta_cover x).","conclusion":"(T ∩₁ action ↓₁ eq ta_cover ∩₁ event ↓₁ W) (mkTL ta_cover x)","hypotheses":"(x : actid) (H : is_w (lab G) x) (y : trav_label) (H0 : T y) (H2 : ta_cover = action y) (H1 : event y = x)","proofString":"destruct y; ins; vauto."},{"statement":"IPROP G ⊆ SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc.","conclusion":"IPROP G ⊆ SB G sc ∪ RF G ∪ FWBOB G ∪ AR G sc ∪ IPROP G ∪ PROP G sc","hypotheses":"","proofString":"eauto with hahn."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : issued T x.","conclusion":"issued T x","hypotheses":"(x : actid) (H : is_init x) (H0 : E x)","proofString":"red.\nexists (mkTL ta_issue x).\nrepeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : (event ↑₁ (T ∩₁ action ↓₁ eq ta_issue)) x.","conclusion":"(event ↑₁ (T ∩₁ action ↓₁ eq ta_issue)) x","hypotheses":"(x : actid) (H : is_init x) (H0 : E x)","proofString":"exists (mkTL ta_issue x).\nrepeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : (T ∩₁ action ↓₁ eq ta_issue) (mkTL ta_issue x) /\\ event (mkTL ta_issue x) = x.","conclusion":"(T ∩₁ action ↓₁ eq ta_issue) (mkTL ta_issue x) /\\ event (mkTL ta_issue x) = x","hypotheses":"(x : actid) (H : is_init x) (H0 : E x)","proofString":"repeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : T (mkTL ta_issue x).","conclusion":"T (mkTL ta_issue x)","hypotheses":"(x : actid) (H : is_init x) (H0 : E x)","proofString":"destruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : T (mkTL ta_issue x).","conclusion":"T (mkTL ta_issue x)","hypotheses":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G)","proofString":"apply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : init_tls G (mkTL ta_issue x).","conclusion":"init_tls G (mkTL ta_issue x)","hypotheses":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G)","proofString":"red.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : ((eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n (E ∩₁ (fun a : actid => is_init a))) (mkTL ta_issue x).","conclusion":"((eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n (E ∩₁ (fun a : actid => is_init a))) (mkTL ta_issue x)","hypotheses":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G)","proofString":"split; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : covered T x.","conclusion":"covered T x","hypotheses":"(x : actid) (H : is_init x) (H0 : E x)","proofString":"red.\nexists (mkTL ta_cover x).\nrepeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : (event ↑₁ (T ∩₁ action ↓₁ eq ta_cover)) x.","conclusion":"(event ↑₁ (T ∩₁ action ↓₁ eq ta_cover)) x","hypotheses":"(x : actid) (H : is_init x) (H0 : E x)","proofString":"exists (mkTL ta_cover x).\nrepeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : (T ∩₁ action ↓₁ eq ta_cover) (mkTL ta_cover x) /\\ event (mkTL ta_cover x) = x.","conclusion":"(T ∩₁ action ↓₁ eq ta_cover) (mkTL ta_cover x) /\\ event (mkTL ta_cover x) = x","hypotheses":"(x : actid) (H : is_init x) (H0 : E x)","proofString":"repeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) : T (mkTL ta_cover x).","conclusion":"T (mkTL ta_cover x)","hypotheses":"(x : actid) (H : is_init x) (H0 : E x)","proofString":"destruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : T (mkTL ta_cover x).","conclusion":"T (mkTL ta_cover x)","hypotheses":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G)","proofString":"apply tls_coh_init.\nred.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : init_tls G (mkTL ta_cover x).","conclusion":"init_tls G (mkTL ta_cover x)","hypotheses":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G)","proofString":"red.\nsplit; basic_solver."},{"statement":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : ((eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n (E ∩₁ (fun a : actid => is_init a))) (mkTL ta_cover x).","conclusion":"((eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n (E ∩₁ (fun a : actid => is_init a))) (mkTL ta_cover x)","hypotheses":"(x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G)","proofString":"split; basic_solver."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) : exists y : trav_label, (T y /\\ ta_propagate t = action y) /\\ event y = x.","conclusion":"exists y : trav_label, (T y /\\ ta_propagate t = action y) /\\ event y = x","hypotheses":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x)","proofString":"exists (mkTL (ta_propagate t) x).\nrepeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; try basic_solver.\nright.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) : (T (mkTL (ta_propagate t) x) /\\\n ta_propagate t = action (mkTL (ta_propagate t) x)) /\\\nevent (mkTL (ta_propagate t) x) = x.","conclusion":"(T (mkTL (ta_propagate t) x) /\\\n ta_propagate t = action (mkTL (ta_propagate t) x)) /\\\nevent (mkTL (ta_propagate t) x) = x","hypotheses":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x)","proofString":"repeat split; auto.\ndestruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; try basic_solver.\nright.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) : T (mkTL (ta_propagate t) x).","conclusion":"T (mkTL (ta_propagate t) x)","hypotheses":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x)","proofString":"destruct TLSCOH.\napply tls_coh_init.\nred.\nsplit; try basic_solver.\nright.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : T (mkTL (ta_propagate t) x).","conclusion":"T (mkTL (ta_propagate t) x)","hypotheses":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G)","proofString":"apply tls_coh_init.\nred.\nsplit; try basic_solver.\nright.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : init_tls G (mkTL (ta_propagate t) x).","conclusion":"init_tls G (mkTL (ta_propagate t) x)","hypotheses":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G)","proofString":"red.\nsplit; try basic_solver.\nright.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : ((eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n (E ∩₁ (fun a : actid => is_init a))) (mkTL (ta_propagate t) x).","conclusion":"((eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G) <*>\n (E ∩₁ (fun a : actid => is_init a))) (mkTL (ta_propagate t) x)","hypotheses":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G)","proofString":"split; try basic_solver.\nright.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : (eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n  (ta_propagate t).","conclusion":"(eq ta_cover ∪₁ eq ta_issue ∪₁ eq ta_reserve ∪₁ is_ta_propagate_to_G G)\n  (ta_propagate t)","hypotheses":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G)","proofString":"right.\nred.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : is_ta_propagate_to_G G (ta_propagate t).","conclusion":"is_ta_propagate_to_G G (ta_propagate t)","hypotheses":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G)","proofString":"red.\nexists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : (⋃₁t0 ∈ threads_set G \\₁ eq tid_init, eq (ta_propagate t0)) (ta_propagate t).","conclusion":"(⋃₁t0 ∈ threads_set G \\₁ eq tid_init, eq (ta_propagate t0)) (ta_propagate t)","hypotheses":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G)","proofString":"exists t.\nsplit; auto."},{"statement":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G) : (threads_set G \\₁ eq tid_init) t /\\ ta_propagate t = ta_propagate t.","conclusion":"(threads_set G \\₁ eq tid_init) t /\\ ta_propagate t = ta_propagate t","hypotheses":"(t : thread_id) (Gt : (threads_set G \\₁ eq tid_init) t) (x : actid) (H : is_init x) (H0 : E x) (tls_coh_init : init_tls G ⊆₁ T) (tls_coh_exec : T ⊆₁ init_tls G ∪₁ exec_tls G)","proofString":"split; auto."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_cover)\n⊆₁ E ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover).","conclusion":"event ↑₁ (T ∩₁ action ↓₁ eq ta_cover)\n⊆₁ E ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover)","hypotheses":"","proofString":"apply set_subset_inter_r.\nsplit; [apply coveredE|].\napply set_collect_mori; [done| ].\napply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_cover) ⊆₁ E /\\\nevent ↑₁ (T ∩₁ action ↓₁ eq ta_cover)\n⊆₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover).","conclusion":"event ↑₁ (T ∩₁ action ↓₁ eq ta_cover) ⊆₁ E /\\\nevent ↑₁ (T ∩₁ action ↓₁ eq ta_cover)\n⊆₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover)","hypotheses":"","proofString":"split; [apply coveredE|].\napply set_collect_mori; [done| ].\napply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_cover)\n⊆₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover).","conclusion":"event ↑₁ (T ∩₁ action ↓₁ eq ta_cover)\n⊆₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover)","hypotheses":"","proofString":"apply set_collect_mori; [done| ].\napply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"T ∩₁ action ↓₁ eq ta_cover ⊆₁ dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover.","conclusion":"T ∩₁ action ↓₁ eq ta_cover ⊆₁ dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover","hypotheses":"","proofString":"apply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"T ⊆₁ dom_cond (iord G sc) T.","conclusion":"T ⊆₁ dom_cond (iord G sc) T","hypotheses":"","proofString":"by apply dom_rel_to_cond."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue)\n⊆₁ E ∩₁ W ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue).","conclusion":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue)\n⊆₁ E ∩₁ W ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue)","hypotheses":"","proofString":"repeat (apply set_subset_inter_r; split); auto using issuedE, issuedW.\napply set_collect_mori; [done| ].\napply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue)\n⊆₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue).","conclusion":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue)\n⊆₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue)","hypotheses":"","proofString":"apply set_collect_mori; [done| ].\napply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"T ∩₁ action ↓₁ eq ta_issue ⊆₁ dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue.","conclusion":"T ∩₁ action ↓₁ eq ta_issue ⊆₁ dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue","hypotheses":"","proofString":"apply set_subset_inter; [| done].\nby apply dom_rel_to_cond."},{"statement":"T ⊆₁ dom_cond (iord G sc) T.","conclusion":"T ⊆₁ dom_cond (iord G sc) T","hypotheses":"","proofString":"by apply dom_rel_to_cond."},{"statement":"E ∩₁ W ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E.","conclusion":"E ∩₁ W ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E","hypotheses":"","proofString":"basic_solver."},{"statement":"E ∩₁ W ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue) ⊆₁ W.","conclusion":"E ∩₁ W ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue) ⊆₁ W","hypotheses":"","proofString":"basic_solver."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E ∩₁ W.","conclusion":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E ∩₁ W","hypotheses":"","proofString":"apply set_subset_inter_r.\nsplit.\napply issuedE; auto.\napply issuedW; auto."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E /\\\nevent ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ W.","conclusion":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E /\\\nevent ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ W","hypotheses":"","proofString":"split.\napply issuedE; auto.\napply issuedW; auto."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E.","conclusion":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ E","hypotheses":"","proofString":"apply issuedE; auto."},{"statement":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ W.","conclusion":"event ↑₁ (T ∩₁ action ↓₁ eq ta_issue) ⊆₁ W","hypotheses":"","proofString":"apply issuedW; auto."},{"statement":"(G : execution) (sc : relation actid) (T : trav_label -> Prop) (e : actid) (COV : (acts_set G ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover)) e) : dom_cond (iord G sc) T (mkTL ta_cover e).","conclusion":"dom_cond (iord G sc) T (mkTL ta_cover e)","hypotheses":"(G : execution) (sc : relation actid) (T : trav_label -> Prop) (e : actid) (COV : (acts_set G ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_cover)) e)","proofString":"apply proj2 in COV as [[a e_] [[AA [=]] [=]]].\nby subst."},{"statement":"(G : execution) (sc : relation actid) (T : trav_label -> Prop) (e : actid) (a : trav_action) (e_ : actid) (AA : dom_cond (iord G sc) T (a, e_)) (H0 : ta_cover = a) (H2 : e_ = e) : dom_cond (iord G sc) T (mkTL ta_cover e).","conclusion":"dom_cond (iord G sc) T (mkTL ta_cover e)","hypotheses":"(G : execution) (sc : relation actid) (T : trav_label -> Prop) (e : actid) (a : trav_action) (e_ : actid) (AA : dom_cond (iord G sc) T (a, e_)) (H0 : ta_cover = a) (H2 : e_ = e)","proofString":"by subst."},{"statement":"(G : execution) (sc : relation actid) (T : trav_label -> Prop) (e : actid) (ISS : (acts_set G ∩₁ (fun a : actid => is_w (lab G) a)\n ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue)) e) : dom_cond (iord G sc) T (mkTL ta_issue e).","conclusion":"dom_cond (iord G sc) T (mkTL ta_issue e)","hypotheses":"(G : execution) (sc : relation actid) (T : trav_label -> Prop) (e : actid) (ISS : (acts_set G ∩₁ (fun a : actid => is_w (lab G) a)\n ∩₁ event ↑₁ (dom_cond (iord G sc) T ∩₁ action ↓₁ eq ta_issue)) e)","proofString":"apply proj2 in ISS as [[a e_] [[AA [=]] [=]]].\nby subst."},{"statement":"(G : execution) (sc : relation actid) (T : trav_label -> Prop) (e : actid) (a : trav_action) (e_ : actid) (AA : dom_cond (iord G sc) T (a, e_)) (H0 : ta_issue = a) (H2 : e_ = e) : dom_cond (iord G sc) T (mkTL ta_issue e).","conclusion":"dom_cond (iord G sc) T (mkTL ta_issue e)","hypotheses":"(G : execution) (sc : relation actid) (T : trav_label -> Prop) (e : actid) (a : trav_action) (e_ : actid) (AA : dom_cond (iord G sc) T (a, e_)) (H0 : ta_issue = a) (H2 : e_ = e)","proofString":"by subst."}]}