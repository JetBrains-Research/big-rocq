{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/flocq/Core/Ulp.v","fileSamples":[{"statement":"(x y : Z) : (x <= y)%Z \\/ ~ (x <= y)%Z.","proofString":"destruct (Z_le_dec x y).\nnow left.\nnow right."},{"statement":"(x y : Z) (l : (x <= y)%Z) : (x <= y)%Z \\/ ~ (x <= y)%Z.","proofString":"now left."},{"statement":"(x y : Z) (n : ~ (x <= y)%Z) : (x <= y)%Z \\/ ~ (x <= y)%Z.","proofString":"now right."},{"statement":"(n : Z) (Hn : (n <= fexp n)%Z) : negligible_exp_prop\n  (Some (proj1_sig (exist (fun n0 : Z => (n0 <= fexp n0)%Z) n Hn))).","proofString":"now apply negligible_Some."},{"statement":"(Hn : forall n : Z, ~ (n <= fexp n)%Z) : negligible_exp_prop None.","proofString":"apply negligible_None.\nintros n; specialize (Hn n); lia."},{"statement":"(Hn : forall n : Z, ~ (n <= fexp n)%Z) : forall n : Z, (fexp n < n)%Z.","proofString":"intros n; specialize (Hn n); lia."},{"statement":"(n : Z) (Hn : (n <= fexp n)%Z) : Some (proj1_sig (exist (fun n0 : Z => (n0 <= fexp n0)%Z) n Hn)) = None /\\\n(forall n0 : Z, (fexp n0 < n0)%Z) \\/\n(exists n0 : Z,\n   Some (proj1_sig (exist (fun n1 : Z => (n1 <= fexp n1)%Z) n Hn)) = Some n0 /\\\n   (n0 <= fexp n0)%Z).","proofString":"right; simpl; exists n; now split."},{"statement":"(Hn : forall n : Z, ~ (n <= fexp n)%Z) : forall n : Z, (fexp n < n)%Z.","proofString":"intros n; specialize (Hn n); lia."},{"statement":"(n m : Z) (Hn : (n <= fexp n)%Z) (Hm : (m <= fexp m)%Z) : fexp n = fexp m.","proofString":"case (Zle_or_lt n m); intros H.\napply valid_exp; lia.\napply sym_eq, valid_exp; lia."},{"statement":"(x : R) (Hx : x <> 0%R) : ulp x = bpow (cexp beta fexp x).","proofString":"unfold ulp; case (Req_bool_spec x); trivial.\nintros H; now contradict H."},{"statement":"(x : R) (Hx : x <> 0%R) : x = 0%R ->\nmatch negligible_exp with\n| Some n => bpow (fexp n)\n| None => 0%R\nend = bpow (cexp beta fexp x).","proofString":"intros H; now contradict H."},{"statement":"(x : R) : ulp (- x) = ulp x.","proofString":"unfold ulp.\ncase Req_bool_spec; intros H1.\nrewrite Req_bool_true; trivial.\nrewrite <- (Ropp_involutive x), H1; ring.\nrewrite Req_bool_false.\nnow rewrite cexp_opp.\nintros H2; apply H1; rewrite H2; ring."},{"statement":"(x : R) : (if Req_bool (- x) 0\n then match negligible_exp with\n      | Some n => bpow (fexp n)\n      | None => 0%R\n      end\n else bpow (cexp beta fexp (- x))) =\n(if Req_bool x 0\n then match negligible_exp with\n      | Some n => bpow (fexp n)\n      | None => 0%R\n      end\n else bpow (cexp beta fexp x)).","proofString":"case Req_bool_spec; intros H1.\nrewrite Req_bool_true; trivial.\nrewrite <- (Ropp_involutive x), H1; ring.\nrewrite Req_bool_false.\nnow rewrite cexp_opp.\nintros H2; apply H1; rewrite H2; ring."},{"statement":"(x : R) (H1 : (- x)%R = 0%R) : match negligible_exp with\n| Some n => bpow (fexp n)\n| None => 0%R\nend =\n(if Req_bool x 0\n then match negligible_exp with\n      | Some n => bpow (fexp n)\n      | None => 0%R\n      end\n else bpow (cexp beta fexp x)).","proofString":"rewrite Req_bool_true; trivial.\nrewrite <- (Ropp_involutive x), H1; ring."},{"statement":"(x : R) (H1 : (- x)%R = 0%R) : x = 0%R.","proofString":"rewrite <- (Ropp_involutive x), H1; ring."},{"statement":"(x : R) (H1 : (- x)%R <> 0%R) : bpow (cexp beta fexp (- x)) =\n(if Req_bool x 0\n then match negligible_exp with\n      | Some n => bpow (fexp n)\n      | None => 0%R\n      end\n else bpow (cexp beta fexp x)).","proofString":"rewrite Req_bool_false.\nnow rewrite cexp_opp.\nintros H2; apply H1; rewrite H2; ring."},{"statement":"(x : R) (H1 : (- x)%R <> 0%R) : bpow (cexp beta fexp (- x)) = bpow (cexp beta fexp x).","proofString":"now rewrite cexp_opp."},{"statement":"(x : R) (H1 : (- x)%R <> 0%R) : x <> 0%R.","proofString":"intros H2; apply H1; rewrite H2; ring."},{"statement":"(x : R) : ulp (Rabs x) = ulp x.","proofString":"unfold ulp; case (Req_bool_spec x 0); intros H1.\nrewrite Req_bool_true; trivial.\nnow rewrite H1, Rabs_R0.\nrewrite Req_bool_false.\nnow rewrite cexp_abs.\nnow apply Rabs_no_R0."},{"statement":"(x : R) (H1 : x = 0%R) : (if Req_bool (Rabs x) 0\n then match negligible_exp with\n      | Some n => bpow (fexp n)\n      | None => 0%R\n      end\n else bpow (cexp beta fexp (Rabs x))) =\nmatch negligible_exp with\n| Some n => bpow (fexp n)\n| None => 0%R\nend.","proofString":"rewrite Req_bool_true; trivial.\nnow rewrite H1, Rabs_R0."},{"statement":"(x : R) (H1 : x = 0%R) : Rabs x = 0%R.","proofString":"now rewrite H1, Rabs_R0."},{"statement":"(x : R) (H1 : x <> 0%R) : (if Req_bool (Rabs x) 0\n then match negligible_exp with\n      | Some n => bpow (fexp n)\n      | None => 0%R\n      end\n else bpow (cexp beta fexp (Rabs x))) = bpow (cexp beta fexp x).","proofString":"rewrite Req_bool_false.\nnow rewrite cexp_abs.\nnow apply Rabs_no_R0."},{"statement":"(x : R) (H1 : x <> 0%R) : bpow (cexp beta fexp (Rabs x)) = bpow (cexp beta fexp x).","proofString":"now rewrite cexp_abs."},{"statement":"(x : R) (H1 : x <> 0%R) : Rabs x <> 0%R.","proofString":"now apply Rabs_no_R0."},{"statement":"(x : R) (H : x = 0%R) : (0 <= match negligible_exp with\n      | Some n => bpow (fexp n)\n      | None => 0\n      end)%R.","proofString":"case negligible_exp; intros.\napply bpow_ge_0.\napply Rle_refl."},{"statement":"(x : R) (H : x = 0%R) (z : Z) : (0 <= bpow (fexp z))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (H : x = 0%R) : (0 <= 0)%R.","proofString":"apply Rle_refl."},{"statement":"(x : R) (H : x <> 0%R) : (0 <= bpow (cexp beta fexp x))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (Zx : x <> 0%R) (Fx : F x) : (ulp x <= Rabs x)%R.","proofString":"rewrite <- ulp_abs.\napply ulp_le_id.\nnow apply Rabs_pos_lt.\nnow apply generic_format_abs."},{"statement":"(x : R) (Zx : x <> 0%R) (Fx : F x) : (ulp (Rabs x) <= Rabs x)%R.","proofString":"apply ulp_le_id.\nnow apply Rabs_pos_lt.\nnow apply generic_format_abs."},{"statement":"(x : R) (Zx : x <> 0%R) (Fx : F x) : (0 < Rabs x)%R.","proofString":"now apply Rabs_pos_lt."},{"statement":"(x : R) (Zx : x <> 0%R) (Fx : F x) : F (Rabs x).","proofString":"now apply generic_format_abs."},{"statement":"(x : R) (Fx : ~ F x) : round beta fexp Zceil x = (round beta fexp Zfloor x + ulp x)%R.","proofString":"rewrite ulp_neq_0.\nunfold round.\nsimpl.\nunfold F2R.\nsimpl.\nrewrite Zceil_floor_neq.\nrewrite plus_IZR.\nsimpl.\nring.\nintros H.\napply Fx.\nunfold generic_format, F2R.\nsimpl.\nrewrite <- H.\nrewrite Ztrunc_IZR.\nrewrite H.\nnow rewrite scaled_mantissa_mult_bpow.\nintros V; apply Fx.\nrewrite V.\napply generic_format_0."},{"statement":"(x : R) (Fx : ~ F x) : round beta fexp Zceil x =\n(round beta fexp Zfloor x + bpow (cexp beta fexp x))%R.","proofString":"unfold round.\nsimpl.\nunfold F2R.\nsimpl.\nrewrite Zceil_floor_neq.\nrewrite plus_IZR.\nsimpl.\nring.\nintros H.\napply Fx.\nunfold generic_format, F2R.\nsimpl.\nrewrite <- H.\nrewrite Ztrunc_IZR.\nrewrite H.\nnow rewrite scaled_mantissa_mult_bpow."},{"statement":"(x : R) (Fx : ~ F x) : (IZR (Zceil (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x))%R =\n(IZR (Zfloor (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x) +\n bpow (cexp beta fexp x))%R.","proofString":"rewrite Zceil_floor_neq.\nrewrite plus_IZR.\nsimpl.\nring.\nintros H.\napply Fx.\nunfold generic_format, F2R.\nsimpl.\nrewrite <- H.\nrewrite Ztrunc_IZR.\nrewrite H.\nnow rewrite scaled_mantissa_mult_bpow."},{"statement":"(x : R) (Fx : ~ F x) : (IZR (Zfloor (scaled_mantissa beta fexp x) + 1) * bpow (cexp beta fexp x))%R =\n(IZR (Zfloor (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x) +\n bpow (cexp beta fexp x))%R.","proofString":"rewrite plus_IZR.\nsimpl.\nring."},{"statement":"(x : R) (Fx : ~ F x) : ((IZR (Zfloor (scaled_mantissa beta fexp x)) + 1) * bpow (cexp beta fexp x))%R =\n(IZR (Zfloor (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x) +\n bpow (cexp beta fexp x))%R.","proofString":"simpl.\nring."},{"statement":"(x : R) (Fx : ~ F x) : ((IZR (Zfloor (scaled_mantissa beta fexp x)) + 1) * bpow (cexp beta fexp x))%R =\n(IZR (Zfloor (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x) +\n bpow (cexp beta fexp x))%R.","proofString":"ring."},{"statement":"(x : R) (Fx : ~ F x) : IZR (Zfloor (scaled_mantissa beta fexp x)) <> scaled_mantissa beta fexp x.","proofString":"intros H.\napply Fx.\nunfold generic_format, F2R.\nsimpl.\nrewrite <- H.\nrewrite Ztrunc_IZR.\nrewrite H.\nnow rewrite scaled_mantissa_mult_bpow."},{"statement":"(x : R) (Fx : ~ F x) (H : IZR (Zfloor (scaled_mantissa beta fexp x)) = scaled_mantissa beta fexp x) : False.","proofString":"apply Fx.\nunfold generic_format, F2R.\nsimpl.\nrewrite <- H.\nrewrite Ztrunc_IZR.\nrewrite H.\nnow rewrite scaled_mantissa_mult_bpow."},{"statement":"(x : R) (Fx : ~ F x) (H : IZR (Zfloor (scaled_mantissa beta fexp x)) = scaled_mantissa beta fexp x) : F x.","proofString":"unfold generic_format, F2R.\nsimpl.\nrewrite <- H.\nrewrite Ztrunc_IZR.\nrewrite H.\nnow rewrite scaled_mantissa_mult_bpow."},{"statement":"(x : R) (Fx : ~ F x) (H : IZR (Zfloor (scaled_mantissa beta fexp x)) = scaled_mantissa beta fexp x) : x = (IZR (Ztrunc (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x))%R.","proofString":"rewrite <- H.\nrewrite Ztrunc_IZR.\nrewrite H.\nnow rewrite scaled_mantissa_mult_bpow."},{"statement":"(x : R) (Fx : ~ F x) (H : IZR (Zfloor (scaled_mantissa beta fexp x)) = scaled_mantissa beta fexp x) : x =\n(IZR (Ztrunc (IZR (Zfloor (scaled_mantissa beta fexp x)))) *\n bpow (cexp beta fexp x))%R.","proofString":"rewrite Ztrunc_IZR.\nrewrite H.\nnow rewrite scaled_mantissa_mult_bpow."},{"statement":"(x : R) (Fx : ~ F x) (H : IZR (Zfloor (scaled_mantissa beta fexp x)) = scaled_mantissa beta fexp x) : x = (IZR (Zfloor (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x))%R.","proofString":"rewrite H.\nnow rewrite scaled_mantissa_mult_bpow."},{"statement":"(x : R) (Fx : ~ F x) (H : IZR (Zfloor (scaled_mantissa beta fexp x)) = scaled_mantissa beta fexp x) : x = (scaled_mantissa beta fexp x * bpow (cexp beta fexp x))%R.","proofString":"now rewrite scaled_mantissa_mult_bpow."},{"statement":"(x : R) (Fx : ~ F x) : x <> 0%R.","proofString":"intros V; apply Fx.\nrewrite V.\napply generic_format_0."},{"statement":"(x : R) (Fx : ~ F x) (V : x = 0%R) : F x.","proofString":"rewrite V.\napply generic_format_0."},{"statement":"(x : R) (Fx : ~ F x) (V : x = 0%R) : F 0.","proofString":"apply generic_format_0."},{"statement":"(e : Z) : ulp (bpow e) = bpow (fexp (e + 1)).","proofString":"rewrite ulp_neq_0.\napply f_equal.\napply cexp_fexp.\nrewrite Rabs_pos_eq.\nsplit.\nring_simplify (e + 1 - 1)%Z.\napply Rle_refl.\napply bpow_lt.\napply Zlt_succ.\napply bpow_ge_0.\napply Rgt_not_eq, Rlt_gt, bpow_gt_0."},{"statement":"(e : Z) : bpow (cexp beta fexp (bpow e)) = bpow (fexp (e + 1)).","proofString":"apply f_equal.\napply cexp_fexp.\nrewrite Rabs_pos_eq.\nsplit.\nring_simplify (e + 1 - 1)%Z.\napply Rle_refl.\napply bpow_lt.\napply Zlt_succ.\napply bpow_ge_0."},{"statement":"(e : Z) : cexp beta fexp (bpow e) = fexp (e + 1).","proofString":"apply cexp_fexp.\nrewrite Rabs_pos_eq.\nsplit.\nring_simplify (e + 1 - 1)%Z.\napply Rle_refl.\napply bpow_lt.\napply Zlt_succ.\napply bpow_ge_0."},{"statement":"(e : Z) : (bpow (e + 1 - 1) <= Rabs (bpow e) < bpow (e + 1))%R.","proofString":"rewrite Rabs_pos_eq.\nsplit.\nring_simplify (e + 1 - 1)%Z.\napply Rle_refl.\napply bpow_lt.\napply Zlt_succ.\napply bpow_ge_0."},{"statement":"(e : Z) : (bpow (e + 1 - 1) <= bpow e < bpow (e + 1))%R.","proofString":"split.\nring_simplify (e + 1 - 1)%Z.\napply Rle_refl.\napply bpow_lt.\napply Zlt_succ."},{"statement":"(e : Z) : (bpow (e + 1 - 1) <= bpow e)%R.","proofString":"ring_simplify (e + 1 - 1)%Z.\napply Rle_refl."},{"statement":"(e : Z) : (bpow e <= bpow e)%R.","proofString":"apply Rle_refl."},{"statement":"(e : Z) : (bpow e < bpow (e + 1))%R.","proofString":"apply bpow_lt.\napply Zlt_succ."},{"statement":"(e : Z) : (e < e + 1)%Z.","proofString":"apply Zlt_succ."},{"statement":"(e : Z) : (0 <= bpow e)%R.","proofString":"apply bpow_ge_0."},{"statement":"(e : Z) : bpow e <> 0%R.","proofString":"apply Rgt_not_eq, Rlt_gt, bpow_gt_0."},{"statement":"F\n  (if Req_bool 0 0\n   then match negligible_exp with\n        | Some n => bpow (fexp n)\n        | None => 0%R\n        end\n   else bpow (cexp beta fexp 0)).","proofString":"rewrite Req_bool_true; trivial.\ncase negligible_exp_spec.\nintros _; apply generic_format_0.\nintros n H1.\napply generic_format_bpow.\nnow apply valid_exp."},{"statement":"F match negligible_exp with\n  | Some n => bpow (fexp n)\n  | None => 0\n  end.","proofString":"case negligible_exp_spec.\nintros _; apply generic_format_0.\nintros n H1.\napply generic_format_bpow.\nnow apply valid_exp."},{"statement":"(forall n : Z, (fexp n < n)%Z) -> F 0.","proofString":"intros _; apply generic_format_0."},{"statement":"forall n : Z, (n <= fexp n)%Z -> F (bpow (fexp n)).","proofString":"intros n H1.\napply generic_format_bpow.\nnow apply valid_exp."},{"statement":"(n : Z) (H1 : (n <= fexp n)%Z) : F (bpow (fexp n)).","proofString":"apply generic_format_bpow.\nnow apply valid_exp."},{"statement":"(n : Z) (H1 : (n <= fexp n)%Z) : (fexp (fexp n + 1) <= fexp n)%Z.","proofString":"now apply valid_exp."},{"statement":"(e : Z) : ((if Req_bool 0 0\n  then match negligible_exp with\n       | Some n => bpow (fexp n)\n       | None => 0\n       end\n  else bpow (cexp beta fexp 0)) <= bpow e)%R -> F (bpow e).","proofString":"rewrite Req_bool_true; trivial.\ncase negligible_exp_spec.\nintros H1 _.\napply generic_format_bpow.\nspecialize (H1 (e+1)%Z); lia.\nintros n H1 H2.\napply generic_format_bpow.\ncase (Zle_or_lt (e+1) (fexp (e+1))); intros H4.\nabsurd (e+1 <= e)%Z.\nlia.\napply Z.le_trans with (1:=H4).\nreplace (fexp (e+1)) with (fexp n).\nnow apply le_bpow with beta.\nnow apply fexp_negligible_exp_eq.\nlia."},{"statement":"(e : Z) : (match negligible_exp with\n | Some n => bpow (fexp n)\n | None => 0\n end <= bpow e)%R -> F (bpow e).","proofString":"case negligible_exp_spec.\nintros H1 _.\napply generic_format_bpow.\nspecialize (H1 (e+1)%Z); lia.\nintros n H1 H2.\napply generic_format_bpow.\ncase (Zle_or_lt (e+1) (fexp (e+1))); intros H4.\nabsurd (e+1 <= e)%Z.\nlia.\napply Z.le_trans with (1:=H4).\nreplace (fexp (e+1)) with (fexp n).\nnow apply le_bpow with beta.\nnow apply fexp_negligible_exp_eq.\nlia."},{"statement":"(e : Z) : (forall n : Z, (fexp n < n)%Z) -> (0 <= bpow e)%R -> F (bpow e).","proofString":"intros H1 _.\napply generic_format_bpow.\nspecialize (H1 (e+1)%Z); lia."},{"statement":"(e : Z) (H1 : forall n : Z, (fexp n < n)%Z) : F (bpow e).","proofString":"apply generic_format_bpow.\nspecialize (H1 (e+1)%Z); lia."},{"statement":"(e : Z) (H1 : forall n : Z, (fexp n < n)%Z) : (fexp (e + 1) <= e)%Z.","proofString":"specialize (H1 (e+1)%Z); lia."},{"statement":"(e : Z) : forall n : Z, (n <= fexp n)%Z -> (bpow (fexp n) <= bpow e)%R -> F (bpow e).","proofString":"intros n H1 H2.\napply generic_format_bpow.\ncase (Zle_or_lt (e+1) (fexp (e+1))); intros H4.\nabsurd (e+1 <= e)%Z.\nlia.\napply Z.le_trans with (1:=H4).\nreplace (fexp (e+1)) with (fexp n).\nnow apply le_bpow with beta.\nnow apply fexp_negligible_exp_eq.\nlia."},{"statement":"(e n : Z) (H1 : (n <= fexp n)%Z) (H2 : (bpow (fexp n) <= bpow e)%R) : F (bpow e).","proofString":"apply generic_format_bpow.\ncase (Zle_or_lt (e+1) (fexp (e+1))); intros H4.\nabsurd (e+1 <= e)%Z.\nlia.\napply Z.le_trans with (1:=H4).\nreplace (fexp (e+1)) with (fexp n).\nnow apply le_bpow with beta.\nnow apply fexp_negligible_exp_eq.\nlia."},{"statement":"(e n : Z) (H1 : (n <= fexp n)%Z) (H2 : (bpow (fexp n) <= bpow e)%R) : (fexp (e + 1) <= e)%Z.","proofString":"case (Zle_or_lt (e+1) (fexp (e+1))); intros H4.\nabsurd (e+1 <= e)%Z.\nlia.\napply Z.le_trans with (1:=H4).\nreplace (fexp (e+1)) with (fexp n).\nnow apply le_bpow with beta.\nnow apply fexp_negligible_exp_eq.\nlia."},{"statement":"(e n : Z) (H1 : (n <= fexp n)%Z) (H2 : (bpow (fexp n) <= bpow e)%R) (H4 : (e + 1 <= fexp (e + 1))%Z) : (fexp (e + 1) <= e)%Z.","proofString":"absurd (e+1 <= e)%Z.\nlia.\napply Z.le_trans with (1:=H4).\nreplace (fexp (e+1)) with (fexp n).\nnow apply le_bpow with beta.\nnow apply fexp_negligible_exp_eq."},{"statement":"(e n : Z) (H1 : (n <= fexp n)%Z) (H2 : (bpow (fexp n) <= bpow e)%R) (H4 : (e + 1 <= fexp (e + 1))%Z) : ~ (e + 1 <= e)%Z.","proofString":"lia."},{"statement":"(e n : Z) (H1 : (n <= fexp n)%Z) (H2 : (bpow (fexp n) <= bpow e)%R) (H4 : (e + 1 <= fexp (e + 1))%Z) : (e + 1 <= e)%Z.","proofString":"apply Z.le_trans with (1:=H4).\nreplace (fexp (e+1)) with (fexp n).\nnow apply le_bpow with beta.\nnow apply fexp_negligible_exp_eq."},{"statement":"(e n : Z) (H1 : (n <= fexp n)%Z) (H2 : (bpow (fexp n) <= bpow e)%R) (H4 : (e + 1 <= fexp (e + 1))%Z) : (fexp (e + 1) <= e)%Z.","proofString":"replace (fexp (e+1)) with (fexp n).\nnow apply le_bpow with beta.\nnow apply fexp_negligible_exp_eq."},{"statement":"(e n : Z) (H1 : (n <= fexp n)%Z) (H2 : (bpow (fexp n) <= bpow e)%R) (H4 : (e + 1 <= fexp (e + 1))%Z) : (fexp n <= e)%Z.","proofString":"now apply le_bpow with beta."},{"statement":"(e n : Z) (H1 : (n <= fexp n)%Z) (H2 : (bpow (fexp n) <= bpow e)%R) (H4 : (e + 1 <= fexp (e + 1))%Z) : fexp n = fexp (e + 1).","proofString":"now apply fexp_negligible_exp_eq."},{"statement":"(e n : Z) (H1 : (n <= fexp n)%Z) (H2 : (bpow (fexp n) <= bpow e)%R) (H4 : (fexp (e + 1) < e + 1)%Z) : (fexp (e + 1) <= e)%Z.","proofString":"lia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) : F (ulp x).","proofString":"case (Req_dec x 0); intros Hx.\nrewrite Hx; apply generic_format_ulp_0.\nrewrite (ulp_neq_0 _ Hx).\napply generic_format_bpow.\napply H."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x = 0%R) : F (ulp x).","proofString":"rewrite Hx; apply generic_format_ulp_0."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) : F (ulp x).","proofString":"rewrite (ulp_neq_0 _ Hx).\napply generic_format_bpow.\napply H."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) : F (bpow (cexp beta fexp x)).","proofString":"apply generic_format_bpow.\napply H."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) : (fexp (cexp beta fexp x + 1) <= cexp beta fexp x)%Z.","proofString":"apply H."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) : (ulp 0 <= ulp x)%R.","proofString":"case (Req_dec x 0); intros Hx.\nrewrite Hx; now right.\nunfold ulp at 1.\nrewrite Req_bool_true; trivial.\ncase negligible_exp_spec'.\nintros (H1,H2); rewrite H1; apply ulp_ge_0.\nintros (n,(H1,H2)); rewrite H1.\nrewrite ulp_neq_0; trivial.\napply bpow_le; unfold cexp.\ngeneralize (mag beta x); intros l.\ncase (Zle_or_lt l (fexp l)); intros Hl.\nrewrite (fexp_negligible_exp_eq n l); trivial; apply Z.le_refl.\ncase (Zle_or_lt (fexp n) (fexp l)); trivial; intros K.\nabsurd (fexp n <= fexp l)%Z.\nlia.\napply Z.le_trans with (2:= H _).\napply Zeq_le, sym_eq, valid_exp; trivial.\nlia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x = 0%R) : (ulp 0 <= ulp x)%R.","proofString":"rewrite Hx; now right."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) : (ulp 0 <= ulp x)%R.","proofString":"unfold ulp at 1.\nrewrite Req_bool_true; trivial.\ncase negligible_exp_spec'.\nintros (H1,H2); rewrite H1; apply ulp_ge_0.\nintros (n,(H1,H2)); rewrite H1.\nrewrite ulp_neq_0; trivial.\napply bpow_le; unfold cexp.\ngeneralize (mag beta x); intros l.\ncase (Zle_or_lt l (fexp l)); intros Hl.\nrewrite (fexp_negligible_exp_eq n l); trivial; apply Z.le_refl.\ncase (Zle_or_lt (fexp n) (fexp l)); trivial; intros K.\nabsurd (fexp n <= fexp l)%Z.\nlia.\napply Z.le_trans with (2:= H _).\napply Zeq_le, sym_eq, valid_exp; trivial.\nlia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) : ((if Req_bool 0 0\n  then match negligible_exp with\n       | Some n => bpow (fexp n)\n       | None => 0\n       end\n  else bpow (cexp beta fexp 0)) <= ulp x)%R.","proofString":"rewrite Req_bool_true; trivial.\ncase negligible_exp_spec'.\nintros (H1,H2); rewrite H1; apply ulp_ge_0.\nintros (n,(H1,H2)); rewrite H1.\nrewrite ulp_neq_0; trivial.\napply bpow_le; unfold cexp.\ngeneralize (mag beta x); intros l.\ncase (Zle_or_lt l (fexp l)); intros Hl.\nrewrite (fexp_negligible_exp_eq n l); trivial; apply Z.le_refl.\ncase (Zle_or_lt (fexp n) (fexp l)); trivial; intros K.\nabsurd (fexp n <= fexp l)%Z.\nlia.\napply Z.le_trans with (2:= H _).\napply Zeq_le, sym_eq, valid_exp; trivial.\nlia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) : (match negligible_exp with\n | Some n => bpow (fexp n)\n | None => 0\n end <= ulp x)%R.","proofString":"case negligible_exp_spec'.\nintros (H1,H2); rewrite H1; apply ulp_ge_0.\nintros (n,(H1,H2)); rewrite H1.\nrewrite ulp_neq_0; trivial.\napply bpow_le; unfold cexp.\ngeneralize (mag beta x); intros l.\ncase (Zle_or_lt l (fexp l)); intros Hl.\nrewrite (fexp_negligible_exp_eq n l); trivial; apply Z.le_refl.\ncase (Zle_or_lt (fexp n) (fexp l)); trivial; intros K.\nabsurd (fexp n <= fexp l)%Z.\nlia.\napply Z.le_trans with (2:= H _).\napply Zeq_le, sym_eq, valid_exp; trivial.\nlia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) : negligible_exp = None /\\ (forall n : Z, (fexp n < n)%Z) ->\n(match negligible_exp with\n | Some n => bpow (fexp n)\n | None => 0\n end <= ulp x)%R.","proofString":"intros (H1,H2); rewrite H1; apply ulp_ge_0."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) : (exists n : Z, negligible_exp = Some n /\\ (n <= fexp n)%Z) ->\n(match negligible_exp with\n | Some n => bpow (fexp n)\n | None => 0\n end <= ulp x)%R.","proofString":"intros (n,(H1,H2)); rewrite H1.\nrewrite ulp_neq_0; trivial.\napply bpow_le; unfold cexp.\ngeneralize (mag beta x); intros l.\ncase (Zle_or_lt l (fexp l)); intros Hl.\nrewrite (fexp_negligible_exp_eq n l); trivial; apply Z.le_refl.\ncase (Zle_or_lt (fexp n) (fexp l)); trivial; intros K.\nabsurd (fexp n <= fexp l)%Z.\nlia.\napply Z.le_trans with (2:= H _).\napply Zeq_le, sym_eq, valid_exp; trivial.\nlia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) (n : Z) (H1 : negligible_exp = Some n) (H2 : (n <= fexp n)%Z) : (bpow (fexp n) <= ulp x)%R.","proofString":"rewrite ulp_neq_0; trivial.\napply bpow_le; unfold cexp.\ngeneralize (mag beta x); intros l.\ncase (Zle_or_lt l (fexp l)); intros Hl.\nrewrite (fexp_negligible_exp_eq n l); trivial; apply Z.le_refl.\ncase (Zle_or_lt (fexp n) (fexp l)); trivial; intros K.\nabsurd (fexp n <= fexp l)%Z.\nlia.\napply Z.le_trans with (2:= H _).\napply Zeq_le, sym_eq, valid_exp; trivial.\nlia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) (n : Z) (H1 : negligible_exp = Some n) (H2 : (n <= fexp n)%Z) : (bpow (fexp n) <= bpow (cexp beta fexp x))%R.","proofString":"apply bpow_le; unfold cexp.\ngeneralize (mag beta x); intros l.\ncase (Zle_or_lt l (fexp l)); intros Hl.\nrewrite (fexp_negligible_exp_eq n l); trivial; apply Z.le_refl.\ncase (Zle_or_lt (fexp n) (fexp l)); trivial; intros K.\nabsurd (fexp n <= fexp l)%Z.\nlia.\napply Z.le_trans with (2:= H _).\napply Zeq_le, sym_eq, valid_exp; trivial.\nlia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) (n : Z) (H1 : negligible_exp = Some n) (H2 : (n <= fexp n)%Z) : (fexp n <= fexp (mag beta x))%Z.","proofString":"generalize (mag beta x); intros l.\ncase (Zle_or_lt l (fexp l)); intros Hl.\nrewrite (fexp_negligible_exp_eq n l); trivial; apply Z.le_refl.\ncase (Zle_or_lt (fexp n) (fexp l)); trivial; intros K.\nabsurd (fexp n <= fexp l)%Z.\nlia.\napply Z.le_trans with (2:= H _).\napply Zeq_le, sym_eq, valid_exp; trivial.\nlia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) (n : Z) (H1 : negligible_exp = Some n) (H2 : (n <= fexp n)%Z) (l : mag_prop beta x) : (fexp n <= fexp l)%Z.","proofString":"case (Zle_or_lt l (fexp l)); intros Hl.\nrewrite (fexp_negligible_exp_eq n l); trivial; apply Z.le_refl.\ncase (Zle_or_lt (fexp n) (fexp l)); trivial; intros K.\nabsurd (fexp n <= fexp l)%Z.\nlia.\napply Z.le_trans with (2:= H _).\napply Zeq_le, sym_eq, valid_exp; trivial.\nlia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) (n : Z) (H1 : negligible_exp = Some n) (H2 : (n <= fexp n)%Z) (l : mag_prop beta x) (Hl : (l <= fexp l)%Z) : (fexp n <= fexp l)%Z.","proofString":"rewrite (fexp_negligible_exp_eq n l); trivial; apply Z.le_refl."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) (n : Z) (H1 : negligible_exp = Some n) (H2 : (n <= fexp n)%Z) (l : mag_prop beta x) (Hl : (fexp l < l)%Z) : (fexp n <= fexp l)%Z.","proofString":"case (Zle_or_lt (fexp n) (fexp l)); trivial; intros K.\nabsurd (fexp n <= fexp l)%Z.\nlia.\napply Z.le_trans with (2:= H _).\napply Zeq_le, sym_eq, valid_exp; trivial.\nlia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) (n : Z) (H1 : negligible_exp = Some n) (H2 : (n <= fexp n)%Z) (l : mag_prop beta x) (Hl : (fexp l < l)%Z) (K : (fexp l < fexp n)%Z) : (fexp n <= fexp l)%Z.","proofString":"absurd (fexp n <= fexp l)%Z.\nlia.\napply Z.le_trans with (2:= H _).\napply Zeq_le, sym_eq, valid_exp; trivial.\nlia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) (n : Z) (H1 : negligible_exp = Some n) (H2 : (n <= fexp n)%Z) (l : mag_prop beta x) (Hl : (fexp l < l)%Z) (K : (fexp l < fexp n)%Z) : ~ (fexp n <= fexp l)%Z.","proofString":"lia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) (n : Z) (H1 : negligible_exp = Some n) (H2 : (n <= fexp n)%Z) (l : mag_prop beta x) (Hl : (fexp l < l)%Z) (K : (fexp l < fexp n)%Z) : (fexp n <= fexp l)%Z.","proofString":"apply Z.le_trans with (2:= H _).\napply Zeq_le, sym_eq, valid_exp; trivial.\nlia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) (n : Z) (H1 : negligible_exp = Some n) (H2 : (n <= fexp n)%Z) (l : mag_prop beta x) (Hl : (fexp l < l)%Z) (K : (fexp l < fexp n)%Z) : (fexp n <= fexp (fexp l + 1))%Z.","proofString":"apply Zeq_le, sym_eq, valid_exp; trivial.\nlia."},{"statement":"(H : forall e : Z, (fexp (fexp e + 1) <= fexp e)%Z) (x : R) (Hx : x <> 0%R) (n : Z) (H1 : negligible_exp = Some n) (H2 : (n <= fexp n)%Z) (l : mag_prop beta x) (Hl : (fexp l < l)%Z) (K : (fexp l < fexp n)%Z) : (fexp l + 1 <= fexp n)%Z.","proofString":"lia."},{"statement":"(H : forall x : R, (ulp 0 <= ulp x)%R) (e : Z) : (fexp (fexp e + 1) <= fexp e)%Z.","proofString":"apply generic_format_bpow_inv' with beta.\napply generic_format_bpow_ge_ulp_0.\nreplace e with ((e-1)+1)%Z by ring.\nrewrite <- ulp_bpow.\napply H."},{"statement":"(H : forall x : R, (ulp 0 <= ulp x)%R) (e : Z) : F (bpow (fexp e)).","proofString":"apply generic_format_bpow_ge_ulp_0.\nreplace e with ((e-1)+1)%Z by ring.\nrewrite <- ulp_bpow.\napply H."},{"statement":"(H : forall x : R, (ulp 0 <= ulp x)%R) (e : Z) : (ulp 0 <= bpow (fexp e))%R.","proofString":"replace e with ((e-1)+1)%Z by ring.\nrewrite <- ulp_bpow.\napply H."},{"statement":"(H : forall x : R, (ulp 0 <= ulp x)%R) (e : Z) : (ulp 0 <= bpow (fexp (e - 1 + 1)))%R.","proofString":"rewrite <- ulp_bpow.\napply H."},{"statement":"(H : forall x : R, (ulp 0 <= ulp x)%R) (e : Z) : (ulp 0 <= ulp (bpow (e - 1)))%R.","proofString":"apply H."},{"statement":"(Hm : Monotone_exp fexp) (x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R) : (ulp x <= ulp y)%R.","proofString":"rewrite ulp_neq_0.\nrewrite ulp_neq_0.\napply bpow_le.\napply Hm.\nnow apply mag_le.\napply Rgt_not_eq, Rlt_gt.\nnow apply Rlt_le_trans with (1:=Hx).\nnow apply Rgt_not_eq."},{"statement":"(Hm : Monotone_exp fexp) (x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R) : (bpow (cexp beta fexp x) <= ulp y)%R.","proofString":"rewrite ulp_neq_0.\napply bpow_le.\napply Hm.\nnow apply mag_le.\napply Rgt_not_eq, Rlt_gt.\nnow apply Rlt_le_trans with (1:=Hx)."},{"statement":"(Hm : Monotone_exp fexp) (x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R) : (bpow (cexp beta fexp x) <= bpow (cexp beta fexp y))%R.","proofString":"apply bpow_le.\napply Hm.\nnow apply mag_le."},{"statement":"(Hm : Monotone_exp fexp) (x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R) : (cexp beta fexp x <= cexp beta fexp y)%Z.","proofString":"apply Hm.\nnow apply mag_le."},{"statement":"(Hm : Monotone_exp fexp) (x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R) : (mag beta x <= mag beta y)%Z.","proofString":"now apply mag_le."},{"statement":"(Hm : Monotone_exp fexp) (x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R) : y <> 0%R.","proofString":"apply Rgt_not_eq, Rlt_gt.\nnow apply Rlt_le_trans with (1:=Hx)."},{"statement":"(Hm : Monotone_exp fexp) (x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R) : (0 < y)%R.","proofString":"now apply Rlt_le_trans with (1:=Hx)."},{"statement":"(Hm : Monotone_exp fexp) (x y : R) (Hx : (0 < x)%R) (Hxy : (x <= y)%R) : x <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(Hm : Monotone_exp fexp) (x y : R) (Hxy : (Rabs x <= Rabs y)%R) : (ulp x <= ulp y)%R.","proofString":"rewrite <- ulp_abs.\nrewrite <- (ulp_abs y).\napply ulp_le_pos; trivial.\napply Rabs_pos."},{"statement":"(Hm : Monotone_exp fexp) (x y : R) (Hxy : (Rabs x <= Rabs y)%R) : (ulp (Rabs x) <= ulp y)%R.","proofString":"rewrite <- (ulp_abs y).\napply ulp_le_pos; trivial.\napply Rabs_pos."},{"statement":"(Hm : Monotone_exp fexp) (x y : R) (Hxy : (Rabs x <= Rabs y)%R) : (ulp (Rabs x) <= ulp (Rabs y))%R.","proofString":"apply ulp_le_pos; trivial.\napply Rabs_pos."},{"statement":"(Hm : Monotone_exp fexp) (x y : R) (Hxy : (Rabs x <= Rabs y)%R) : (0 <= Rabs x)%R.","proofString":"apply Rabs_pos."},{"statement":"(x : R) (Hx : (0 <= x)%R) : (if Rle_bool 0 x then (x + ulp x)%R else (- pred_pos (- x))%R) =\n(x + ulp x)%R.","proofString":"now rewrite Rle_bool_true."},{"statement":"(x : R) : succ (- x) = (- pred x)%R.","proofString":"now apply sym_eq, Ropp_involutive."},{"statement":"(x : R) : pred (- x) = (- succ x)%R.","proofString":"unfold pred.\nnow rewrite Ropp_involutive."},{"statement":"(x : R) : (- succ (- - x))%R = (- succ x)%R.","proofString":"now rewrite Ropp_involutive."},{"statement":"(e : Z) : pred (bpow e) = (bpow e - bpow (fexp e))%R.","proofString":"rewrite pred_eq_pos by apply bpow_ge_0.\nunfold pred_pos.\nrewrite mag_bpow.\nreplace (e + 1 - 1)%Z with e by ring.\nnow rewrite Req_bool_true."},{"statement":"(e : Z) : pred_pos (bpow e) = (bpow e - bpow (fexp e))%R.","proofString":"unfold pred_pos.\nrewrite mag_bpow.\nreplace (e + 1 - 1)%Z with e by ring.\nnow rewrite Req_bool_true."},{"statement":"(e : Z) : (if Req_bool (bpow e) (bpow (mag beta (bpow e) - 1))\n then (bpow e - bpow (fexp (mag beta (bpow e) - 1)))%R\n else (bpow e - ulp (bpow e))%R) = (bpow e - bpow (fexp e))%R.","proofString":"rewrite mag_bpow.\nreplace (e + 1 - 1)%Z with e by ring.\nnow rewrite Req_bool_true."},{"statement":"(e : Z) : (if Req_bool (bpow e) (bpow (e + 1 - 1))\n then (bpow e - bpow (fexp (e + 1 - 1)))%R\n else (bpow e - ulp (bpow e))%R) = (bpow e - bpow (fexp e))%R.","proofString":"replace (e + 1 - 1)%Z with e by ring.\nnow rewrite Req_bool_true."},{"statement":"(e : Z) : (if Req_bool (bpow e) (bpow e)\n then (bpow e - bpow (fexp e))%R\n else (bpow e - ulp (bpow e))%R) = (bpow e - bpow (fexp e))%R.","proofString":"now rewrite Req_bool_true."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) : (bpow e <= x - ulp x)%R.","proofString":"assert (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z.\nassert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=Hx).\napply bpow_ge_0.\nlia.\ncase (Zle_lt_or_eq _ _ H); intros Hm.\npattern x at 1 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R.\nsimpl.\npattern (bpow (cexp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.\nrewrite <- Rmult_minus_distr_r.\nrewrite <- minus_IZR.\napply bpow_le_F2R_m1.\neasy.\nnow rewrite <- Fx.\napply Rgt_not_eq, Rlt_gt.\napply Rlt_trans with (2:=Hx), bpow_gt_0.\ncontradict Hx'.\npattern x at 1; rewrite Fx.\nrewrite  <- Hm.\nrewrite ulp_neq_0.\nunfold F2R; simpl.\nnow rewrite Rmult_1_l.\napply Rgt_not_eq, Rlt_gt.\napply Rlt_trans with (2:=Hx), bpow_gt_0."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z.","proofString":"assert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=Hx).\napply bpow_ge_0.\nlia."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) : (0 < Ztrunc (scaled_mantissa beta fexp x))%Z.","proofString":"apply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=Hx).\napply bpow_ge_0."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) : (0 < x)%R.","proofString":"apply Rle_lt_trans with (2:=Hx).\napply bpow_ge_0."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) : (0 <= bpow e)%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) (H : (0 < Ztrunc (scaled_mantissa beta fexp x))%Z) : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z.","proofString":"lia."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) : (bpow e <= x - ulp x)%R.","proofString":"case (Zle_lt_or_eq _ _ H); intros Hm.\npattern x at 1 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R.\nsimpl.\npattern (bpow (cexp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.\nrewrite <- Rmult_minus_distr_r.\nrewrite <- minus_IZR.\napply bpow_le_F2R_m1.\neasy.\nnow rewrite <- Fx.\napply Rgt_not_eq, Rlt_gt.\napply Rlt_trans with (2:=Hx), bpow_gt_0.\ncontradict Hx'.\npattern x at 1; rewrite Fx.\nrewrite  <- Hm.\nrewrite ulp_neq_0.\nunfold F2R; simpl.\nnow rewrite Rmult_1_l.\napply Rgt_not_eq, Rlt_gt.\napply Rlt_trans with (2:=Hx), bpow_gt_0."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) (Hm : (1 < Ztrunc (scaled_mantissa beta fexp x))%Z) : (bpow e <= x - ulp x)%R.","proofString":"pattern x at 1 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R.\nsimpl.\npattern (bpow (cexp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.\nrewrite <- Rmult_minus_distr_r.\nrewrite <- minus_IZR.\napply bpow_le_F2R_m1.\neasy.\nnow rewrite <- Fx.\napply Rgt_not_eq, Rlt_gt.\napply Rlt_trans with (2:=Hx), bpow_gt_0."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) (Hm : (1 < Ztrunc (scaled_mantissa beta fexp x))%Z) : (bpow e <=\n IZR (Ztrunc (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x) -\n bpow (cexp beta fexp x))%R.","proofString":"pattern (bpow (cexp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.\nrewrite <- Rmult_minus_distr_r.\nrewrite <- minus_IZR.\napply bpow_le_F2R_m1.\neasy.\nnow rewrite <- Fx."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) (Hm : (1 < Ztrunc (scaled_mantissa beta fexp x))%Z) : (bpow e <=\n IZR (Ztrunc (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x) -\n 1 * bpow (cexp beta fexp x))%R.","proofString":"rewrite <- Rmult_minus_distr_r.\nrewrite <- minus_IZR.\napply bpow_le_F2R_m1.\neasy.\nnow rewrite <- Fx."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) (Hm : (1 < Ztrunc (scaled_mantissa beta fexp x))%Z) : (bpow e <=\n (IZR (Ztrunc (scaled_mantissa beta fexp x)) - 1) * bpow (cexp beta fexp x))%R.","proofString":"rewrite <- minus_IZR.\napply bpow_le_F2R_m1.\neasy.\nnow rewrite <- Fx."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) (Hm : (1 < Ztrunc (scaled_mantissa beta fexp x))%Z) : (bpow e <=\n IZR (Ztrunc (scaled_mantissa beta fexp x) - 1) * bpow (cexp beta fexp x))%R.","proofString":"apply bpow_le_F2R_m1.\neasy.\nnow rewrite <- Fx."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) (Hm : (1 < Ztrunc (scaled_mantissa beta fexp x))%Z) : (1 < Ztrunc (scaled_mantissa beta fexp x))%Z.","proofString":"easy."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) (Hm : (1 < Ztrunc (scaled_mantissa beta fexp x))%Z) : x <> 0%R.","proofString":"apply Rgt_not_eq, Rlt_gt.\napply Rlt_trans with (2:=Hx), bpow_gt_0."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) (Hm : (1 < Ztrunc (scaled_mantissa beta fexp x))%Z) : (0 < x)%R.","proofString":"apply Rlt_trans with (2:=Hx), bpow_gt_0."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx' : x <> ulp x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) (Hm : 1%Z = Ztrunc (scaled_mantissa beta fexp x)) : (bpow e <= x - ulp x)%R.","proofString":"contradict Hx'.\npattern x at 1; rewrite Fx.\nrewrite  <- Hm.\nrewrite ulp_neq_0.\nunfold F2R; simpl.\nnow rewrite Rmult_1_l.\napply Rgt_not_eq, Rlt_gt.\napply Rlt_trans with (2:=Hx), bpow_gt_0."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) (Hm : 1%Z = Ztrunc (scaled_mantissa beta fexp x)) : x = ulp x.","proofString":"pattern x at 1; rewrite Fx.\nrewrite  <- Hm.\nrewrite ulp_neq_0.\nunfold F2R; simpl.\nnow rewrite Rmult_1_l.\napply Rgt_not_eq, Rlt_gt.\napply Rlt_trans with (2:=Hx), bpow_gt_0."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) (Hm : 1%Z = Ztrunc (scaled_mantissa beta fexp x)) : (1 * bpow (cexp beta fexp x))%R = bpow (cexp beta fexp x).","proofString":"now rewrite Rmult_1_l."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) (Hm : 1%Z = Ztrunc (scaled_mantissa beta fexp x)) : x <> 0%R.","proofString":"apply Rgt_not_eq, Rlt_gt.\napply Rlt_trans with (2:=Hx), bpow_gt_0."},{"statement":"(x : R) (e : Z) (Fx : F x) (Hx : (bpow e < x)%R) (H : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z) (Hm : 1%Z = Ztrunc (scaled_mantissa beta fexp x)) : (0 < x)%R.","proofString":"apply Rlt_trans with (2:=Hx), bpow_gt_0."},{"statement":"(x : R) (e : Z) (Zx : (0 < x)%R) (Fx : F x) (Hx : (x < bpow e)%R) : (x + ulp x <= bpow e)%R.","proofString":"pattern x at 1 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R.\nsimpl.\npattern (bpow (cexp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.\nrewrite <- Rmult_plus_distr_r.\nrewrite <- plus_IZR.\napply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (e : Z) (Zx : (0 < x)%R) (Fx : F x) (Hx : (x < bpow e)%R) : (IZR (Ztrunc (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x) +\n bpow (cexp beta fexp x) <= bpow e)%R.","proofString":"pattern (bpow (cexp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.\nrewrite <- Rmult_plus_distr_r.\nrewrite <- plus_IZR.\napply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx."},{"statement":"(x : R) (e : Z) (Zx : (0 < x)%R) (Fx : F x) (Hx : (x < bpow e)%R) : (IZR (Ztrunc (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x) +\n 1 * bpow (cexp beta fexp x) <= bpow e)%R.","proofString":"rewrite <- Rmult_plus_distr_r.\nrewrite <- plus_IZR.\napply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx."},{"statement":"(x : R) (e : Z) (Zx : (0 < x)%R) (Fx : F x) (Hx : (x < bpow e)%R) : ((IZR (Ztrunc (scaled_mantissa beta fexp x)) + 1) * bpow (cexp beta fexp x) <=\n bpow e)%R.","proofString":"rewrite <- plus_IZR.\napply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx."},{"statement":"(x : R) (e : Z) (Zx : (0 < x)%R) (Fx : F x) (Hx : (x < bpow e)%R) : (IZR (Ztrunc (scaled_mantissa beta fexp x) + 1) * bpow (cexp beta fexp x) <=\n bpow e)%R.","proofString":"apply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx."},{"statement":"(x : R) (e : Z) (Zx : (0 < x)%R) (Fx : F x) (Hx : (x < bpow e)%R) : (0 < Ztrunc (scaled_mantissa beta fexp x))%Z.","proofString":"apply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx."},{"statement":"(x : R) (e : Z) (Zx : (0 < x)%R) (Fx : F x) (Hx : (x < bpow e)%R) : x <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (Hx : x <> bpow (mag beta x - 1)) : F (x - ulp x).","proofString":"destruct (mag beta x) as (ex, Ex).\nsimpl in Hx.\nspecialize (Ex (Rgt_not_eq _ _ Zx)).\nassert (Ex' : (bpow (ex - 1) < x < bpow ex)%R).\nrewrite Rabs_pos_eq in Ex.\ndestruct Ex as (H,H'); destruct H; split; trivial.\ncontradict Hx; easy.\nnow apply Rlt_le.\nunfold generic_format, scaled_mantissa, cexp.\nrewrite mag_unique with beta (x - ulp x)%R ex.\npattern x at 1 3 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\nunfold F2R.\nsimpl.\nrewrite Rmult_minus_distr_r.\nrewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- minus_IZR.\nrewrite Ztrunc_IZR.\nrewrite minus_IZR.\nrewrite Rmult_minus_distr_r.\nnow rewrite Rmult_1_l.\nnow apply Rgt_not_eq.\nrewrite Rabs_pos_eq.\nsplit.\napply id_m_ulp_ge_bpow; trivial.\nrewrite ulp_neq_0.\nintro H.\nassert (ex-1 < cexp beta fexp x  < ex)%Z.\nsplit ; apply (lt_bpow beta) ; rewrite <- H ; easy.\nclear -H0.\nlia.\nnow apply Rgt_not_eq.\napply Ex'.\napply Rle_lt_trans with (2 := proj2 Ex').\npattern x at 3 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\nrewrite <-Ropp_0.\napply Ropp_le_contravar.\napply ulp_ge_0.\napply Rle_0_minus.\npattern x at 2; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R; simpl.\npattern (bpow (cexp beta fexp x)) at 1; rewrite <- Rmult_1_l.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply IZR_le.\nassert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0.\nlia.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (Build_mag_prop beta x ex Ex - 1)) : F (x - ulp x).","proofString":"simpl in Hx.\nspecialize (Ex (Rgt_not_eq _ _ Zx)).\nassert (Ex' : (bpow (ex - 1) < x < bpow ex)%R).\nrewrite Rabs_pos_eq in Ex.\ndestruct Ex as (H,H'); destruct H; split; trivial.\ncontradict Hx; easy.\nnow apply Rlt_le.\nunfold generic_format, scaled_mantissa, cexp.\nrewrite mag_unique with beta (x - ulp x)%R ex.\npattern x at 1 3 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\nunfold F2R.\nsimpl.\nrewrite Rmult_minus_distr_r.\nrewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- minus_IZR.\nrewrite Ztrunc_IZR.\nrewrite minus_IZR.\nrewrite Rmult_minus_distr_r.\nnow rewrite Rmult_1_l.\nnow apply Rgt_not_eq.\nrewrite Rabs_pos_eq.\nsplit.\napply id_m_ulp_ge_bpow; trivial.\nrewrite ulp_neq_0.\nintro H.\nassert (ex-1 < cexp beta fexp x  < ex)%Z.\nsplit ; apply (lt_bpow beta) ; rewrite <- H ; easy.\nclear -H0.\nlia.\nnow apply Rgt_not_eq.\napply Ex'.\napply Rle_lt_trans with (2 := proj2 Ex').\npattern x at 3 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\nrewrite <-Ropp_0.\napply Ropp_le_contravar.\napply ulp_ge_0.\napply Rle_0_minus.\npattern x at 2; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R; simpl.\npattern (bpow (cexp beta fexp x)) at 1; rewrite <- Rmult_1_l.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply IZR_le.\nassert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0.\nlia.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) : F (x - ulp x).","proofString":"specialize (Ex (Rgt_not_eq _ _ Zx)).\nassert (Ex' : (bpow (ex - 1) < x < bpow ex)%R).\nrewrite Rabs_pos_eq in Ex.\ndestruct Ex as (H,H'); destruct H; split; trivial.\ncontradict Hx; easy.\nnow apply Rlt_le.\nunfold generic_format, scaled_mantissa, cexp.\nrewrite mag_unique with beta (x - ulp x)%R ex.\npattern x at 1 3 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\nunfold F2R.\nsimpl.\nrewrite Rmult_minus_distr_r.\nrewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- minus_IZR.\nrewrite Ztrunc_IZR.\nrewrite minus_IZR.\nrewrite Rmult_minus_distr_r.\nnow rewrite Rmult_1_l.\nnow apply Rgt_not_eq.\nrewrite Rabs_pos_eq.\nsplit.\napply id_m_ulp_ge_bpow; trivial.\nrewrite ulp_neq_0.\nintro H.\nassert (ex-1 < cexp beta fexp x  < ex)%Z.\nsplit ; apply (lt_bpow beta) ; rewrite <- H ; easy.\nclear -H0.\nlia.\nnow apply Rgt_not_eq.\napply Ex'.\napply Rle_lt_trans with (2 := proj2 Ex').\npattern x at 3 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\nrewrite <-Ropp_0.\napply Ropp_le_contravar.\napply ulp_ge_0.\napply Rle_0_minus.\npattern x at 2; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R; simpl.\npattern (bpow (cexp beta fexp x)) at 1; rewrite <- Rmult_1_l.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply IZR_le.\nassert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0.\nlia.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) : F (x - ulp x).","proofString":"assert (Ex' : (bpow (ex - 1) < x < bpow ex)%R).\nrewrite Rabs_pos_eq in Ex.\ndestruct Ex as (H,H'); destruct H; split; trivial.\ncontradict Hx; easy.\nnow apply Rlt_le.\nunfold generic_format, scaled_mantissa, cexp.\nrewrite mag_unique with beta (x - ulp x)%R ex.\npattern x at 1 3 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\nunfold F2R.\nsimpl.\nrewrite Rmult_minus_distr_r.\nrewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- minus_IZR.\nrewrite Ztrunc_IZR.\nrewrite minus_IZR.\nrewrite Rmult_minus_distr_r.\nnow rewrite Rmult_1_l.\nnow apply Rgt_not_eq.\nrewrite Rabs_pos_eq.\nsplit.\napply id_m_ulp_ge_bpow; trivial.\nrewrite ulp_neq_0.\nintro H.\nassert (ex-1 < cexp beta fexp x  < ex)%Z.\nsplit ; apply (lt_bpow beta) ; rewrite <- H ; easy.\nclear -H0.\nlia.\nnow apply Rgt_not_eq.\napply Ex'.\napply Rle_lt_trans with (2 := proj2 Ex').\npattern x at 3 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\nrewrite <-Ropp_0.\napply Ropp_le_contravar.\napply ulp_ge_0.\napply Rle_0_minus.\npattern x at 2; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R; simpl.\npattern (bpow (cexp beta fexp x)) at 1; rewrite <- Rmult_1_l.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply IZR_le.\nassert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0.\nlia.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) : (bpow (ex - 1) < x < bpow ex)%R.","proofString":"rewrite Rabs_pos_eq in Ex.\ndestruct Ex as (H,H'); destruct H; split; trivial.\ncontradict Hx; easy.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) : (bpow (ex - 1) < x < bpow ex)%R.","proofString":"destruct Ex as (H,H'); destruct H; split; trivial.\ncontradict Hx; easy."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (H : bpow (ex - 1) = x) (H' : (x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) : (bpow (ex - 1) < x)%R.","proofString":"contradict Hx; easy."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) : (0 <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : F (x - ulp x).","proofString":"unfold generic_format, scaled_mantissa, cexp.\nrewrite mag_unique with beta (x - ulp x)%R ex.\npattern x at 1 3 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\nunfold F2R.\nsimpl.\nrewrite Rmult_minus_distr_r.\nrewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- minus_IZR.\nrewrite Ztrunc_IZR.\nrewrite minus_IZR.\nrewrite Rmult_minus_distr_r.\nnow rewrite Rmult_1_l.\nnow apply Rgt_not_eq.\nrewrite Rabs_pos_eq.\nsplit.\napply id_m_ulp_ge_bpow; trivial.\nrewrite ulp_neq_0.\nintro H.\nassert (ex-1 < cexp beta fexp x  < ex)%Z.\nsplit ; apply (lt_bpow beta) ; rewrite <- H ; easy.\nclear -H0.\nlia.\nnow apply Rgt_not_eq.\napply Ex'.\napply Rle_lt_trans with (2 := proj2 Ex').\npattern x at 3 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\nrewrite <-Ropp_0.\napply Ropp_le_contravar.\napply ulp_ge_0.\napply Rle_0_minus.\npattern x at 2; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R; simpl.\npattern (bpow (cexp beta fexp x)) at 1; rewrite <- Rmult_1_l.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply IZR_le.\nassert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0.\nlia.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) - bpow (fexp ex))%R =\n(IZR\n   (Ztrunc\n      ((IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) - bpow (fexp ex)) *\n       bpow (- fexp ex))) * bpow (fexp ex))%R.","proofString":"rewrite Rmult_minus_distr_r.\nrewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- minus_IZR.\nrewrite Ztrunc_IZR.\nrewrite minus_IZR.\nrewrite Rmult_minus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) - bpow (fexp ex))%R =\n(IZR\n   (Ztrunc\n      (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) *\n       bpow (- fexp ex) - bpow (fexp ex) * bpow (- fexp ex))) *\n bpow (fexp ex))%R.","proofString":"rewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- minus_IZR.\nrewrite Ztrunc_IZR.\nrewrite minus_IZR.\nrewrite Rmult_minus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) - bpow (fexp ex))%R =\n(IZR\n   (Ztrunc\n      (IZR (Ztrunc (x * bpow (- fexp ex))) *\n       (bpow (fexp ex) * bpow (- fexp ex)) -\n       bpow (fexp ex) * bpow (- fexp ex))) * bpow (fexp ex))%R.","proofString":"rewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- minus_IZR.\nrewrite Ztrunc_IZR.\nrewrite minus_IZR.\nrewrite Rmult_minus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) - bpow (fexp ex))%R =\n(IZR (Ztrunc (IZR (Ztrunc (x * bpow (- fexp ex))) - bpow 0)) * bpow (fexp ex))%R.","proofString":"change (bpow 0) with 1%R.\nrewrite <- minus_IZR.\nrewrite Ztrunc_IZR.\nrewrite minus_IZR.\nrewrite Rmult_minus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) - bpow (fexp ex))%R =\n(IZR (Ztrunc (IZR (Ztrunc (x * bpow (- fexp ex))) - 1)) * bpow (fexp ex))%R.","proofString":"rewrite <- minus_IZR.\nrewrite Ztrunc_IZR.\nrewrite minus_IZR.\nrewrite Rmult_minus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) - bpow (fexp ex))%R =\n(IZR (Ztrunc (IZR (Ztrunc (x * bpow (- fexp ex)) - 1))) * bpow (fexp ex))%R.","proofString":"rewrite Ztrunc_IZR.\nrewrite minus_IZR.\nrewrite Rmult_minus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) - bpow (fexp ex))%R =\n(IZR (Ztrunc (x * bpow (- fexp ex)) - 1) * bpow (fexp ex))%R.","proofString":"rewrite minus_IZR.\nrewrite Rmult_minus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) - bpow (fexp ex))%R =\n((IZR (Ztrunc (x * bpow (- fexp ex))) - 1) * bpow (fexp ex))%R.","proofString":"rewrite Rmult_minus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) - bpow (fexp ex))%R =\n(IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) - 1 * bpow (fexp ex))%R.","proofString":"now rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : x <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (bpow (ex - 1) <= Rabs (x - ulp x) < bpow ex)%R.","proofString":"rewrite Rabs_pos_eq.\nsplit.\napply id_m_ulp_ge_bpow; trivial.\nrewrite ulp_neq_0.\nintro H.\nassert (ex-1 < cexp beta fexp x  < ex)%Z.\nsplit ; apply (lt_bpow beta) ; rewrite <- H ; easy.\nclear -H0.\nlia.\nnow apply Rgt_not_eq.\napply Ex'.\napply Rle_lt_trans with (2 := proj2 Ex').\npattern x at 3 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\nrewrite <-Ropp_0.\napply Ropp_le_contravar.\napply ulp_ge_0.\napply Rle_0_minus.\npattern x at 2; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R; simpl.\npattern (bpow (cexp beta fexp x)) at 1; rewrite <- Rmult_1_l.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply IZR_le.\nassert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0.\nlia.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (bpow (ex - 1) <= x - ulp x < bpow ex)%R.","proofString":"split.\napply id_m_ulp_ge_bpow; trivial.\nrewrite ulp_neq_0.\nintro H.\nassert (ex-1 < cexp beta fexp x  < ex)%Z.\nsplit ; apply (lt_bpow beta) ; rewrite <- H ; easy.\nclear -H0.\nlia.\nnow apply Rgt_not_eq.\napply Ex'.\napply Rle_lt_trans with (2 := proj2 Ex').\npattern x at 3 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\nrewrite <-Ropp_0.\napply Ropp_le_contravar.\napply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (bpow (ex - 1) <= x - ulp x)%R.","proofString":"apply id_m_ulp_ge_bpow; trivial.\nrewrite ulp_neq_0.\nintro H.\nassert (ex-1 < cexp beta fexp x  < ex)%Z.\nsplit ; apply (lt_bpow beta) ; rewrite <- H ; easy.\nclear -H0.\nlia.\nnow apply Rgt_not_eq.\napply Ex'."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : x <> ulp x.","proofString":"rewrite ulp_neq_0.\nintro H.\nassert (ex-1 < cexp beta fexp x  < ex)%Z.\nsplit ; apply (lt_bpow beta) ; rewrite <- H ; easy.\nclear -H0.\nlia.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : x <> bpow (cexp beta fexp x).","proofString":"intro H.\nassert (ex-1 < cexp beta fexp x  < ex)%Z.\nsplit ; apply (lt_bpow beta) ; rewrite <- H ; easy.\nclear -H0.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) (H : x = bpow (cexp beta fexp x)) : False.","proofString":"assert (ex-1 < cexp beta fexp x  < ex)%Z.\nsplit ; apply (lt_bpow beta) ; rewrite <- H ; easy.\nclear -H0.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) (H : x = bpow (cexp beta fexp x)) : (ex - 1 < cexp beta fexp x < ex)%Z.","proofString":"split ; apply (lt_bpow beta) ; rewrite <- H ; easy."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) (H : x = bpow (cexp beta fexp x)) (H0 : (ex - 1 < cexp beta fexp x < ex)%Z) : False.","proofString":"clear -H0.\nlia."},{"statement":"(x : R) (ex : Z) (H0 : (ex - 1 < cexp beta fexp x < ex)%Z) : False.","proofString":"lia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : x <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (bpow (ex - 1) < x)%R.","proofString":"apply Ex'."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (x - ulp x < bpow ex)%R.","proofString":"apply Rle_lt_trans with (2 := proj2 Ex').\npattern x at 3 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\nrewrite <-Ropp_0.\napply Ropp_le_contravar.\napply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (x - ulp x <= x)%R.","proofString":"pattern x at 3 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\nrewrite <-Ropp_0.\napply Ropp_le_contravar.\napply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (x - ulp x <= x + 0)%R.","proofString":"apply Rplus_le_compat_l.\nrewrite <-Ropp_0.\napply Ropp_le_contravar.\napply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (- ulp x <= 0)%R.","proofString":"rewrite <-Ropp_0.\napply Ropp_le_contravar.\napply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (- ulp x <= - 0)%R.","proofString":"apply Ropp_le_contravar.\napply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (0 <= ulp x)%R.","proofString":"apply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (0 <= x - ulp x)%R.","proofString":"apply Rle_0_minus.\npattern x at 2; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R; simpl.\npattern (bpow (cexp beta fexp x)) at 1; rewrite <- Rmult_1_l.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply IZR_le.\nassert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0.\nlia.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (ulp x <= x)%R.","proofString":"pattern x at 2; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R; simpl.\npattern (bpow (cexp beta fexp x)) at 1; rewrite <- Rmult_1_l.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply IZR_le.\nassert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0.\nlia.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (bpow (cexp beta fexp x) <=\n IZR (Ztrunc (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x))%R.","proofString":"pattern (bpow (cexp beta fexp x)) at 1; rewrite <- Rmult_1_l.\napply Rmult_le_compat_r.\napply bpow_ge_0.\napply IZR_le.\nassert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (1 * bpow (cexp beta fexp x) <=\n IZR (Ztrunc (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x))%R.","proofString":"apply Rmult_le_compat_r.\napply bpow_ge_0.\napply IZR_le.\nassert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (0 <= bpow (cexp beta fexp x))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (1 <= IZR (Ztrunc (scaled_mantissa beta fexp x)))%R.","proofString":"apply IZR_le.\nassert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z.","proofString":"assert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.\napply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (0 < Ztrunc (scaled_mantissa beta fexp x))%Z.","proofString":"apply gt_0_F2R with beta (cexp beta fexp x).\nrewrite <- Fx.\napply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (0 < x)%R.","proofString":"apply Rle_lt_trans with (2:=proj1 Ex').\napply bpow_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : (0 <= bpow (ex - 1))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) (H : (0 < Ztrunc (scaled_mantissa beta fexp x))%Z) : (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z.","proofString":"lia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Hx : x <> bpow (ex - 1)) (Ex' : (bpow (ex - 1) < x < bpow ex)%R) : x <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hx : x = bpow (e - 1)) : F (x - bpow (fexp (e - 1))).","proofString":"pose (f:=(x - bpow (fexp (e - 1)))%R).\nfold f.\nassert (He:(fexp (e-1) <= e-1)%Z).\napply generic_format_bpow_inv with beta; trivial.\nrewrite <- Hx; assumption.\ncase (Zle_lt_or_eq _ _ He); clear He; intros He.\nassert (f = F2R (Float beta (Zpower beta (e-1-(fexp (e-1))) -1) (fexp (e-1))))%R.\nunfold f; rewrite Hx.\nunfold F2R; simpl.\nrewrite minus_IZR, IZR_Zpower.\nrewrite Rmult_minus_distr_r, Rmult_1_l.\nrewrite <- bpow_plus.\nnow replace (e - 1 - fexp (e - 1) + fexp (e - 1))%Z with (e-1)%Z by ring.\nlia.\nrewrite H.\napply generic_format_F2R.\nintros _.\napply Zeq_le.\napply cexp_fexp.\nrewrite <- H.\nunfold f; rewrite Hx.\nrewrite Rabs_right.\nsplit.\napply Rplus_le_reg_l with (bpow (fexp (e-1))).\nring_simplify.\napply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.\napply Rplus_le_compat ; apply bpow_le ; lia.\napply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right.\nrewrite <- Rplus_0_r.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0.\napply Rle_ge; apply Rle_0_minus.\napply bpow_le.\nlia.\nreplace f with 0%R.\napply generic_format_0.\nunfold f.\nrewrite Hx, He.\nring."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hx : x = bpow (e - 1)) (f : R) : (fexp (e - 1) <= e - 1)%Z.","proofString":"apply generic_format_bpow_inv with beta; trivial.\nrewrite <- Hx; assumption."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hx : x = bpow (e - 1)) (f : R) : F (bpow (e - 1)).","proofString":"rewrite <- Hx; assumption."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hx : x = bpow (e - 1)) (f : R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (e - 1) - bpow (fexp (e - 1)))%R =\n(IZR (beta ^ (e - 1 - fexp (e - 1)) - 1) * bpow (fexp (e - 1)))%R.","proofString":"rewrite minus_IZR, IZR_Zpower.\nrewrite Rmult_minus_distr_r, Rmult_1_l.\nrewrite <- bpow_plus.\nnow replace (e - 1 - fexp (e - 1) + fexp (e - 1))%Z with (e-1)%Z by ring.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hx : x = bpow (e - 1)) (f : R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (e - 1) - bpow (fexp (e - 1)))%R =\n((bpow (e - 1 - fexp (e - 1)) - 1) * bpow (fexp (e - 1)))%R.","proofString":"rewrite Rmult_minus_distr_r, Rmult_1_l.\nrewrite <- bpow_plus.\nnow replace (e - 1 - fexp (e - 1) + fexp (e - 1))%Z with (e-1)%Z by ring."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hx : x = bpow (e - 1)) (f : R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (e - 1) - bpow (fexp (e - 1)))%R =\n(bpow (e - 1 - fexp (e - 1)) * bpow (fexp (e - 1)) - bpow (fexp (e - 1)))%R.","proofString":"rewrite <- bpow_plus.\nnow replace (e - 1 - fexp (e - 1) + fexp (e - 1))%Z with (e-1)%Z by ring."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hx : x = bpow (e - 1)) (f : R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (e - 1) - bpow (fexp (e - 1)))%R =\n(bpow (e - 1 - fexp (e - 1) + fexp (e - 1)) - bpow (fexp (e - 1)))%R.","proofString":"now replace (e - 1 - fexp (e - 1) + fexp (e - 1))%Z with (e-1)%Z by ring."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hx : x = bpow (e - 1)) (f : R) (He : (fexp (e - 1) < e - 1)%Z) : (0 <= e - 1 - fexp (e - 1))%Z.","proofString":"lia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hx : x = bpow (e - 1)) (f : R) (He : fexp (e - 1) = (e - 1)%Z) : F 0.","proofString":"apply generic_format_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hx : x = bpow (e - 1)) (f : R) (He : fexp (e - 1) = (e - 1)%Z) : 0%R = (x - bpow (fexp (e - 1)))%R.","proofString":"rewrite Hx, He.\nring."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hx : x = bpow (e - 1)) (f : R) (He : fexp (e - 1) = (e - 1)%Z) : 0%R = (bpow (e - 1) - bpow (e - 1))%R.","proofString":"ring."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) : F (x + ulp x).","proofString":"destruct (mag beta x) as (ex, Ex).\nspecialize (Ex (Rgt_not_eq _ _ Zx)).\nassert (Ex' := Ex).\nrewrite Rabs_pos_eq in Ex'.\ndestruct (id_p_ulp_le_bpow x ex) ; try easy.\nunfold generic_format, scaled_mantissa, cexp.\nrewrite mag_unique with beta (x + ulp x)%R ex.\npattern x at 1 3 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\nunfold F2R.\nsimpl.\nrewrite Rmult_plus_distr_r.\nrewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- plus_IZR.\nrewrite Ztrunc_IZR.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l.\nnow apply Rgt_not_eq.\nrewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Ex').\npattern x at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply ulp_ge_0.\nexact H.\napply Rplus_le_le_0_compat.\nnow apply Rlt_le.\napply ulp_ge_0.\nrewrite H.\napply generic_format_bpow.\napply valid_exp.\ndestruct (Zle_or_lt ex (fexp ex)) ; trivial.\nelim Rlt_not_le with (1 := Zx).\nrewrite Fx.\nreplace (Ztrunc (scaled_mantissa beta fexp x)) with Z0.\nrewrite F2R_0.\napply Rle_refl.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\ndestruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : F (x + ulp x).","proofString":"specialize (Ex (Rgt_not_eq _ _ Zx)).\nassert (Ex' := Ex).\nrewrite Rabs_pos_eq in Ex'.\ndestruct (id_p_ulp_le_bpow x ex) ; try easy.\nunfold generic_format, scaled_mantissa, cexp.\nrewrite mag_unique with beta (x + ulp x)%R ex.\npattern x at 1 3 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\nunfold F2R.\nsimpl.\nrewrite Rmult_plus_distr_r.\nrewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- plus_IZR.\nrewrite Ztrunc_IZR.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l.\nnow apply Rgt_not_eq.\nrewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Ex').\npattern x at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply ulp_ge_0.\nexact H.\napply Rplus_le_le_0_compat.\nnow apply Rlt_le.\napply ulp_ge_0.\nrewrite H.\napply generic_format_bpow.\napply valid_exp.\ndestruct (Zle_or_lt ex (fexp ex)) ; trivial.\nelim Rlt_not_le with (1 := Zx).\nrewrite Fx.\nreplace (Ztrunc (scaled_mantissa beta fexp x)) with Z0.\nrewrite F2R_0.\napply Rle_refl.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\ndestruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : F (x + ulp x).","proofString":"assert (Ex' := Ex).\nrewrite Rabs_pos_eq in Ex'.\ndestruct (id_p_ulp_le_bpow x ex) ; try easy.\nunfold generic_format, scaled_mantissa, cexp.\nrewrite mag_unique with beta (x + ulp x)%R ex.\npattern x at 1 3 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\nunfold F2R.\nsimpl.\nrewrite Rmult_plus_distr_r.\nrewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- plus_IZR.\nrewrite Ztrunc_IZR.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l.\nnow apply Rgt_not_eq.\nrewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Ex').\npattern x at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply ulp_ge_0.\nexact H.\napply Rplus_le_le_0_compat.\nnow apply Rlt_le.\napply ulp_ge_0.\nrewrite H.\napply generic_format_bpow.\napply valid_exp.\ndestruct (Zle_or_lt ex (fexp ex)) ; trivial.\nelim Rlt_not_le with (1 := Zx).\nrewrite Fx.\nreplace (Ztrunc (scaled_mantissa beta fexp x)) with Z0.\nrewrite F2R_0.\napply Rle_refl.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\ndestruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex Ex' : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : F (x + ulp x).","proofString":"rewrite Rabs_pos_eq in Ex'.\ndestruct (id_p_ulp_le_bpow x ex) ; try easy.\nunfold generic_format, scaled_mantissa, cexp.\nrewrite mag_unique with beta (x + ulp x)%R ex.\npattern x at 1 3 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\nunfold F2R.\nsimpl.\nrewrite Rmult_plus_distr_r.\nrewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- plus_IZR.\nrewrite Ztrunc_IZR.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l.\nnow apply Rgt_not_eq.\nrewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Ex').\npattern x at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply ulp_ge_0.\nexact H.\napply Rplus_le_le_0_compat.\nnow apply Rlt_le.\napply ulp_ge_0.\nrewrite H.\napply generic_format_bpow.\napply valid_exp.\ndestruct (Zle_or_lt ex (fexp ex)) ; trivial.\nelim Rlt_not_le with (1 := Zx).\nrewrite Fx.\nreplace (Ztrunc (scaled_mantissa beta fexp x)) with Z0.\nrewrite F2R_0.\napply Rle_refl.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\ndestruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) : F (x + ulp x).","proofString":"destruct (id_p_ulp_le_bpow x ex) ; try easy.\nunfold generic_format, scaled_mantissa, cexp.\nrewrite mag_unique with beta (x + ulp x)%R ex.\npattern x at 1 3 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\nunfold F2R.\nsimpl.\nrewrite Rmult_plus_distr_r.\nrewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- plus_IZR.\nrewrite Ztrunc_IZR.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l.\nnow apply Rgt_not_eq.\nrewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Ex').\npattern x at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply ulp_ge_0.\nexact H.\napply Rplus_le_le_0_compat.\nnow apply Rlt_le.\napply ulp_ge_0.\nrewrite H.\napply generic_format_bpow.\napply valid_exp.\ndestruct (Zle_or_lt ex (fexp ex)) ; trivial.\nelim Rlt_not_le with (1 := Zx).\nrewrite Fx.\nreplace (Ztrunc (scaled_mantissa beta fexp x)) with Z0.\nrewrite F2R_0.\napply Rle_refl.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\ndestruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : F (x + ulp x).","proofString":"unfold generic_format, scaled_mantissa, cexp.\nrewrite mag_unique with beta (x + ulp x)%R ex.\npattern x at 1 3 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\nunfold F2R.\nsimpl.\nrewrite Rmult_plus_distr_r.\nrewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- plus_IZR.\nrewrite Ztrunc_IZR.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l.\nnow apply Rgt_not_eq.\nrewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Ex').\npattern x at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply ulp_ge_0.\nexact H.\napply Rplus_le_le_0_compat.\nnow apply Rlt_le.\napply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) + bpow (fexp ex))%R =\n(IZR\n   (Ztrunc\n      ((IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) + bpow (fexp ex)) *\n       bpow (- fexp ex))) * bpow (fexp ex))%R.","proofString":"rewrite Rmult_plus_distr_r.\nrewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- plus_IZR.\nrewrite Ztrunc_IZR.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) + bpow (fexp ex))%R =\n(IZR\n   (Ztrunc\n      (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) *\n       bpow (- fexp ex) + bpow (fexp ex) * bpow (- fexp ex))) *\n bpow (fexp ex))%R.","proofString":"rewrite Rmult_assoc.\nrewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- plus_IZR.\nrewrite Ztrunc_IZR.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) + bpow (fexp ex))%R =\n(IZR\n   (Ztrunc\n      (IZR (Ztrunc (x * bpow (- fexp ex))) *\n       (bpow (fexp ex) * bpow (- fexp ex)) +\n       bpow (fexp ex) * bpow (- fexp ex))) * bpow (fexp ex))%R.","proofString":"rewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.\nchange (bpow 0) with 1%R.\nrewrite <- plus_IZR.\nrewrite Ztrunc_IZR.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) + bpow (fexp ex))%R =\n(IZR (Ztrunc (IZR (Ztrunc (x * bpow (- fexp ex))) + bpow 0)) * bpow (fexp ex))%R.","proofString":"change (bpow 0) with 1%R.\nrewrite <- plus_IZR.\nrewrite Ztrunc_IZR.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) + bpow (fexp ex))%R =\n(IZR (Ztrunc (IZR (Ztrunc (x * bpow (- fexp ex))) + 1)) * bpow (fexp ex))%R.","proofString":"rewrite <- plus_IZR.\nrewrite Ztrunc_IZR.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) + bpow (fexp ex))%R =\n(IZR (Ztrunc (IZR (Ztrunc (x * bpow (- fexp ex)) + 1))) * bpow (fexp ex))%R.","proofString":"rewrite Ztrunc_IZR.\nrewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) + bpow (fexp ex))%R =\n(IZR (Ztrunc (x * bpow (- fexp ex)) + 1) * bpow (fexp ex))%R.","proofString":"rewrite plus_IZR.\nrewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) + bpow (fexp ex))%R =\n((IZR (Ztrunc (x * bpow (- fexp ex))) + 1) * bpow (fexp ex))%R.","proofString":"rewrite Rmult_plus_distr_r.\nnow rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) + bpow (fexp ex))%R =\n(IZR (Ztrunc (x * bpow (- fexp ex))) * bpow (fexp ex) + 1 * bpow (fexp ex))%R.","proofString":"now rewrite Rmult_1_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : x <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (bpow (ex - 1) <= Rabs (x + ulp x) < bpow ex)%R.","proofString":"rewrite Rabs_pos_eq.\nsplit.\napply Rle_trans with (1 := proj1 Ex').\npattern x at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply ulp_ge_0.\nexact H.\napply Rplus_le_le_0_compat.\nnow apply Rlt_le.\napply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (bpow (ex - 1) <= x + ulp x < bpow ex)%R.","proofString":"split.\napply Rle_trans with (1 := proj1 Ex').\npattern x at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply ulp_ge_0.\nexact H."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (bpow (ex - 1) <= x + ulp x)%R.","proofString":"apply Rle_trans with (1 := proj1 Ex').\npattern x at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (x <= x + ulp x)%R.","proofString":"pattern x at 1 ; rewrite <- Rplus_0_r.\napply Rplus_le_compat_l.\napply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (x + 0 <= x + ulp x)%R.","proofString":"apply Rplus_le_compat_l.\napply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (0 <= ulp x)%R.","proofString":"apply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (x + ulp x < bpow ex)%R.","proofString":"exact H."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (0 <= x + ulp x)%R.","proofString":"apply Rplus_le_le_0_compat.\nnow apply Rlt_le.\napply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (0 <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x < bpow ex)%R) : (0 <= ulp x)%R.","proofString":"apply ulp_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) : F (x + ulp x).","proofString":"rewrite H.\napply generic_format_bpow.\napply valid_exp.\ndestruct (Zle_or_lt ex (fexp ex)) ; trivial.\nelim Rlt_not_le with (1 := Zx).\nrewrite Fx.\nreplace (Ztrunc (scaled_mantissa beta fexp x)) with Z0.\nrewrite F2R_0.\napply Rle_refl.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\ndestruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) : F (bpow ex).","proofString":"apply generic_format_bpow.\napply valid_exp.\ndestruct (Zle_or_lt ex (fexp ex)) ; trivial.\nelim Rlt_not_le with (1 := Zx).\nrewrite Fx.\nreplace (Ztrunc (scaled_mantissa beta fexp x)) with Z0.\nrewrite F2R_0.\napply Rle_refl.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\ndestruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) : (fexp (ex + 1) <= ex)%Z.","proofString":"apply valid_exp.\ndestruct (Zle_or_lt ex (fexp ex)) ; trivial.\nelim Rlt_not_le with (1 := Zx).\nrewrite Fx.\nreplace (Ztrunc (scaled_mantissa beta fexp x)) with Z0.\nrewrite F2R_0.\napply Rle_refl.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\ndestruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) : (fexp ex < ex)%Z.","proofString":"destruct (Zle_or_lt ex (fexp ex)) ; trivial.\nelim Rlt_not_le with (1 := Zx).\nrewrite Fx.\nreplace (Ztrunc (scaled_mantissa beta fexp x)) with Z0.\nrewrite F2R_0.\napply Rle_refl.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\ndestruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) (H0 : (ex <= fexp ex)%Z) : (fexp ex < ex)%Z.","proofString":"elim Rlt_not_le with (1 := Zx).\nrewrite Fx.\nreplace (Ztrunc (scaled_mantissa beta fexp x)) with Z0.\nrewrite F2R_0.\napply Rle_refl.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\ndestruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) (H0 : (ex <= fexp ex)%Z) : (x <= 0)%R.","proofString":"rewrite Fx.\nreplace (Ztrunc (scaled_mantissa beta fexp x)) with Z0.\nrewrite F2R_0.\napply Rle_refl.\nunfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\ndestruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) (H0 : (ex <= fexp ex)%Z) : (0 <= 0)%R.","proofString":"apply Rle_refl."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) (H0 : (ex <= fexp ex)%Z) : 0%Z = Ztrunc (scaled_mantissa beta fexp x).","proofString":"unfold scaled_mantissa.\nrewrite cexp_fexp with (1 := Ex).\ndestruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) (H0 : (ex <= fexp ex)%Z) : 0%Z = Ztrunc (x * bpow (- cexp beta fexp x)).","proofString":"rewrite cexp_fexp with (1 := Ex).\ndestruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) (H0 : (ex <= fexp ex)%Z) : 0%Z = Ztrunc (x * bpow (- fexp ex)).","proofString":"destruct (mantissa_small_pos beta fexp x ex) ; trivial.\nrewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) (H0 : (ex <= fexp ex)%Z) (H1 : (0 < x * bpow (- fexp ex))%R) (H2 : (x * bpow (- fexp ex) < 1)%R) : 0%Z = Ztrunc (x * bpow (- fexp ex)).","proofString":"rewrite Ztrunc_floor.\napply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) (H0 : (ex <= fexp ex)%Z) (H1 : (0 < x * bpow (- fexp ex))%R) (H2 : (x * bpow (- fexp ex) < 1)%R) : 0%Z = Zfloor (x * bpow (- fexp ex)).","proofString":"apply sym_eq.\napply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) (H0 : (ex <= fexp ex)%Z) (H1 : (0 < x * bpow (- fexp ex))%R) (H2 : (x * bpow (- fexp ex) < 1)%R) : Zfloor (x * bpow (- fexp ex)) = 0%Z.","proofString":"apply Zfloor_imp.\nsplit.\nnow apply Rlt_le.\nexact H2."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) (H0 : (ex <= fexp ex)%Z) (H1 : (0 < x * bpow (- fexp ex))%R) (H2 : (x * bpow (- fexp ex) < 1)%R) : (0 <= x * bpow (- fexp ex) < IZR (0 + 1))%R.","proofString":"split.\nnow apply Rlt_le.\nexact H2."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) (H0 : (ex <= fexp ex)%Z) (H1 : (0 < x * bpow (- fexp ex))%R) (H2 : (x * bpow (- fexp ex) < 1)%R) : (0 <= x * bpow (- fexp ex))%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) (H0 : (ex <= fexp ex)%Z) (H1 : (0 < x * bpow (- fexp ex))%R) (H2 : (x * bpow (- fexp ex) < 1)%R) : (x * bpow (- fexp ex) < IZR (0 + 1))%R.","proofString":"exact H2."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (Ex' : (bpow (ex - 1) <= x < bpow ex)%R) (H : (x + ulp x)%R = bpow ex) (H0 : (ex <= fexp ex)%Z) (H1 : (0 < x * bpow (- fexp ex))%R) (H2 : (x * bpow (- fexp ex) < 1)%R) : (0 <= x * bpow (- fexp ex))%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex Ex' : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Fx : F x) (Zx : (0 < x)%R) : F (pred_pos x).","proofString":"unfold pred_pos; case Req_bool_spec; intros H.\nnow apply generic_format_pred_aux2.\nnow apply generic_format_pred_aux1."},{"statement":"(x : R) (Fx : F x) (Zx : (0 < x)%R) (H : x = bpow (mag beta x - 1)) : F (x - bpow (fexp (mag beta x - 1))).","proofString":"now apply generic_format_pred_aux2."},{"statement":"(x : R) (Fx : F x) (Zx : (0 < x)%R) (H : x <> bpow (mag beta x - 1)) : F (x - ulp x).","proofString":"now apply generic_format_pred_aux1."},{"statement":"(x : R) (Fx : F x) : F (succ x).","proofString":"unfold succ; case Rle_bool_spec; intros Zx.\ndestruct Zx as [Zx|Zx].\nnow apply generic_format_succ_aux1.\nrewrite <- Zx, Rplus_0_l.\napply generic_format_ulp_0.\napply generic_format_opp.\napply generic_format_pred_pos.\nnow apply generic_format_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) (Zx : (0 <= x)%R) : F (x + ulp x).","proofString":"destruct Zx as [Zx|Zx].\nnow apply generic_format_succ_aux1.\nrewrite <- Zx, Rplus_0_l.\napply generic_format_ulp_0."},{"statement":"(x : R) (Fx : F x) (Zx : (0 < x)%R) : F (x + ulp x).","proofString":"now apply generic_format_succ_aux1."},{"statement":"(x : R) (Fx : F x) (Zx : 0%R = x) : F (x + ulp x).","proofString":"rewrite <- Zx, Rplus_0_l.\napply generic_format_ulp_0."},{"statement":"(x : R) (Fx : F x) (Zx : 0%R = x) : F (ulp 0).","proofString":"apply generic_format_ulp_0."},{"statement":"(x : R) (Fx : F x) (Zx : (x < 0)%R) : F (- pred_pos (- x)).","proofString":"apply generic_format_opp.\napply generic_format_pred_pos.\nnow apply generic_format_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) (Zx : (x < 0)%R) : F (pred_pos (- x)).","proofString":"apply generic_format_pred_pos.\nnow apply generic_format_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) (Zx : (x < 0)%R) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (Zx : (x < 0)%R) : (0 < - x)%R.","proofString":"now apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) : F (pred x).","proofString":"unfold pred.\napply generic_format_opp.\napply generic_format_succ.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) : F (- succ (- x)).","proofString":"apply generic_format_opp.\napply generic_format_succ.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) : F (succ (- x)).","proofString":"apply generic_format_succ.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x : R) (Zx : x <> 0%R) : (pred_pos x < x)%R.","proofString":"unfold pred_pos.\ncase Req_bool_spec; intros H.\nrewrite <- Rplus_0_r.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0.\nrewrite <- Rplus_0_r.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\nrewrite ulp_neq_0; trivial.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) : ((if Req_bool x (bpow (mag beta x - 1))\n  then x - bpow (fexp (mag beta x - 1))\n  else x - ulp x) < x)%R.","proofString":"case Req_bool_spec; intros H.\nrewrite <- Rplus_0_r.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0.\nrewrite <- Rplus_0_r.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\nrewrite ulp_neq_0; trivial.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (H : x = bpow (mag beta x - 1)) : (x - bpow (fexp (mag beta x - 1)) < x)%R.","proofString":"rewrite <- Rplus_0_r.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (H : x = bpow (mag beta x - 1)) : (x - bpow (fexp (mag beta x - 1)) < x + 0)%R.","proofString":"apply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (H : x = bpow (mag beta x - 1)) : (- bpow (fexp (mag beta x - 1)) < 0)%R.","proofString":"rewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (H : x = bpow (mag beta x - 1)) : (- bpow (fexp (mag beta x - 1)) < - 0)%R.","proofString":"apply Ropp_lt_contravar.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (H : x = bpow (mag beta x - 1)) : (0 < bpow (fexp (mag beta x - 1)))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (H : x <> bpow (mag beta x - 1)) : (x - ulp x < x)%R.","proofString":"rewrite <- Rplus_0_r.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\nrewrite ulp_neq_0; trivial.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (H : x <> bpow (mag beta x - 1)) : (x - ulp x < x + 0)%R.","proofString":"apply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\nrewrite ulp_neq_0; trivial.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (H : x <> bpow (mag beta x - 1)) : (- ulp x < 0)%R.","proofString":"rewrite <- Ropp_0.\napply Ropp_lt_contravar.\nrewrite ulp_neq_0; trivial.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (H : x <> bpow (mag beta x - 1)) : (- ulp x < - 0)%R.","proofString":"apply Ropp_lt_contravar.\nrewrite ulp_neq_0; trivial.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (H : x <> bpow (mag beta x - 1)) : (0 < ulp x)%R.","proofString":"rewrite ulp_neq_0; trivial.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (H : x <> bpow (mag beta x - 1)) : (0 < bpow (cexp beta fexp x))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) : (x < (if Rle_bool 0 x then x + ulp x else - pred_pos (- x)))%R.","proofString":"case Rle_bool_spec; intros Hx.\npattern x at 1; rewrite <- (Rplus_0_r x).\napply Rplus_lt_compat_l.\nrewrite ulp_neq_0; trivial.\napply bpow_gt_0.\npattern x at 1; rewrite <- (Ropp_involutive x).\napply Ropp_lt_contravar.\napply pred_pos_lt_id.\nauto with real."},{"statement":"(x : R) (Zx : x <> 0%R) (Hx : (0 <= x)%R) : (x < x + ulp x)%R.","proofString":"pattern x at 1; rewrite <- (Rplus_0_r x).\napply Rplus_lt_compat_l.\nrewrite ulp_neq_0; trivial.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (Hx : (0 <= x)%R) : (x + 0 < x + ulp x)%R.","proofString":"apply Rplus_lt_compat_l.\nrewrite ulp_neq_0; trivial.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (Hx : (0 <= x)%R) : (0 < ulp x)%R.","proofString":"rewrite ulp_neq_0; trivial.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (Hx : (0 <= x)%R) : (0 < bpow (cexp beta fexp x))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Zx : x <> 0%R) (Hx : (x < 0)%R) : (x < - pred_pos (- x))%R.","proofString":"pattern x at 1; rewrite <- (Ropp_involutive x).\napply Ropp_lt_contravar.\napply pred_pos_lt_id.\nauto with real."},{"statement":"(x : R) (Zx : x <> 0%R) (Hx : (x < 0)%R) : (- - x < - pred_pos (- x))%R.","proofString":"apply Ropp_lt_contravar.\napply pred_pos_lt_id.\nauto with real."},{"statement":"(x : R) (Zx : x <> 0%R) (Hx : (x < 0)%R) : (pred_pos (- x) < - x)%R.","proofString":"apply pred_pos_lt_id.\nauto with real."},{"statement":"(x : R) (Zx : x <> 0%R) (Hx : (x < 0)%R) : (- x)%R <> 0%R.","proofString":"auto with real."},{"statement":"(x : R) (Zx : x <> 0%R) : (- succ (- x) < x)%R.","proofString":"pattern x at 2; rewrite <- (Ropp_involutive x).\napply Ropp_lt_contravar.\napply succ_gt_id.\nauto with real."},{"statement":"(x : R) (Zx : x <> 0%R) : (- succ (- x) < - - x)%R.","proofString":"apply Ropp_lt_contravar.\napply succ_gt_id.\nauto with real."},{"statement":"(x : R) (Zx : x <> 0%R) : (- x < succ (- x))%R.","proofString":"apply succ_gt_id.\nauto with real."},{"statement":"(x : R) (Zx : x <> 0%R) : (- x)%R <> 0%R.","proofString":"auto with real."},{"statement":"(x : R) : x = 0%R -> (x <= succ x)%R.","proofString":"intros V; rewrite V.\nunfold succ; rewrite Rle_bool_true;[idtac|now right].\nrewrite Rplus_0_l; apply ulp_ge_0."},{"statement":"(x : R) (V : x = 0%R) : (0 <= succ 0)%R.","proofString":"unfold succ; rewrite Rle_bool_true;[idtac|now right].\nrewrite Rplus_0_l; apply ulp_ge_0."},{"statement":"(x : R) (V : x = 0%R) : (0 <= 0 + ulp 0)%R.","proofString":"rewrite Rplus_0_l; apply ulp_ge_0."},{"statement":"(x : R) : x <> 0%R -> (x <= succ x)%R.","proofString":"intros; left; now apply succ_gt_id."},{"statement":"(x : R) : (- succ (- x) <= x)%R.","proofString":"pattern x at 2; rewrite <- (Ropp_involutive x).\napply Ropp_le_contravar.\napply succ_ge_id."},{"statement":"(x : R) : (- succ (- x) <= - - x)%R.","proofString":"apply Ropp_le_contravar.\napply succ_ge_id."},{"statement":"(x : R) : (- x <= succ (- x))%R.","proofString":"apply succ_ge_id."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) : (0 <= pred_pos x)%R.","proofString":"unfold pred_pos.\ncase Req_bool_spec; intros H.\napply Rle_0_minus.\nrewrite H.\napply bpow_le.\ndestruct (mag beta x) as (ex,Ex) ; simpl.\nrewrite mag_bpow.\nring_simplify (ex - 1 + 1 - 1)%Z.\napply generic_format_bpow_inv with beta; trivial.\nsimpl in H.\nrewrite <- H; assumption.\napply Rle_0_minus.\nnow apply ulp_le_id."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) : (0 <=\n (if Req_bool x (bpow (mag beta x - 1))\n  then x - bpow (fexp (mag beta x - 1))\n  else x - ulp x))%R.","proofString":"case Req_bool_spec; intros H.\napply Rle_0_minus.\nrewrite H.\napply bpow_le.\ndestruct (mag beta x) as (ex,Ex) ; simpl.\nrewrite mag_bpow.\nring_simplify (ex - 1 + 1 - 1)%Z.\napply generic_format_bpow_inv with beta; trivial.\nsimpl in H.\nrewrite <- H; assumption.\napply Rle_0_minus.\nnow apply ulp_le_id."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (H : x = bpow (mag beta x - 1)) : (0 <= x - bpow (fexp (mag beta x - 1)))%R.","proofString":"apply Rle_0_minus.\nrewrite H.\napply bpow_le.\ndestruct (mag beta x) as (ex,Ex) ; simpl.\nrewrite mag_bpow.\nring_simplify (ex - 1 + 1 - 1)%Z.\napply generic_format_bpow_inv with beta; trivial.\nsimpl in H.\nrewrite <- H; assumption."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (H : x = bpow (mag beta x - 1)) : (bpow (fexp (mag beta x - 1)) <= x)%R.","proofString":"rewrite H.\napply bpow_le.\ndestruct (mag beta x) as (ex,Ex) ; simpl.\nrewrite mag_bpow.\nring_simplify (ex - 1 + 1 - 1)%Z.\napply generic_format_bpow_inv with beta; trivial.\nsimpl in H.\nrewrite <- H; assumption."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (H : x = bpow (mag beta x - 1)) : (bpow (fexp (mag beta (bpow (mag beta x - 1)) - 1)) <= bpow (mag beta x - 1))%R.","proofString":"apply bpow_le.\ndestruct (mag beta x) as (ex,Ex) ; simpl.\nrewrite mag_bpow.\nring_simplify (ex - 1 + 1 - 1)%Z.\napply generic_format_bpow_inv with beta; trivial.\nsimpl in H.\nrewrite <- H; assumption."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (H : x = bpow (mag beta x - 1)) : (fexp (mag beta (bpow (mag beta x - 1)) - 1) <= mag beta x - 1)%Z.","proofString":"destruct (mag beta x) as (ex,Ex) ; simpl.\nrewrite mag_bpow.\nring_simplify (ex - 1 + 1 - 1)%Z.\napply generic_format_bpow_inv with beta; trivial.\nsimpl in H.\nrewrite <- H; assumption."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : x = bpow (Build_mag_prop beta x ex Ex - 1)) : (fexp (mag beta (bpow (ex - 1)) - 1) <= ex - 1)%Z.","proofString":"rewrite mag_bpow.\nring_simplify (ex - 1 + 1 - 1)%Z.\napply generic_format_bpow_inv with beta; trivial.\nsimpl in H.\nrewrite <- H; assumption."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : x = bpow (Build_mag_prop beta x ex Ex - 1)) : (fexp (ex - 1 + 1 - 1) <= ex - 1)%Z.","proofString":"ring_simplify (ex - 1 + 1 - 1)%Z.\napply generic_format_bpow_inv with beta; trivial.\nsimpl in H.\nrewrite <- H; assumption."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : x = bpow (Build_mag_prop beta x ex Ex - 1)) : (fexp (ex - 1) <= ex - 1)%Z.","proofString":"apply generic_format_bpow_inv with beta; trivial.\nsimpl in H.\nrewrite <- H; assumption."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : x = bpow (Build_mag_prop beta x ex Ex - 1)) : F (bpow (ex - 1)).","proofString":"simpl in H.\nrewrite <- H; assumption."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (ex : Z) (Ex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H : x = bpow (ex - 1)) : F (bpow (ex - 1)).","proofString":"rewrite <- H; assumption."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (H : x <> bpow (mag beta x - 1)) : (0 <= x - ulp x)%R.","proofString":"apply Rle_0_minus.\nnow apply ulp_le_id."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (H : x <> bpow (mag beta x - 1)) : (ulp x <= x)%R.","proofString":"now apply ulp_le_id."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) : (0 <= pred x)%R.","proofString":"rewrite pred_eq_pos.\nnow apply pred_pos_ge_0.\nnow left."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) : (0 <= pred_pos x)%R.","proofString":"now apply pred_pos_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) : (0 <= x)%R.","proofString":"now left."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) : (x - bpow (fexp (e - 1)) + ulp (x - bpow (fexp (e - 1))))%R = x.","proofString":"replace (ulp (x - bpow (fexp (e - 1)))) with (bpow (fexp (e - 1))).\nring.\nassert (He:(fexp (e-1) <= e-1)%Z).\napply generic_format_bpow_inv with beta; trivial.\nrewrite <- Hxe; assumption.\ncase (Zle_lt_or_eq _ _ He); clear He; intros He.\nrewrite ulp_neq_0; trivial.\napply f_equal.\nunfold cexp ; apply f_equal.\napply sym_eq.\napply mag_unique.\nrewrite Rabs_right.\nsplit.\napply Rplus_le_reg_l with (bpow (fexp (e-1))).\nring_simplify.\napply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.\napply Rplus_le_compat; apply bpow_le; lia.\napply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right.\nrewrite <- Rplus_0_r, Hxe.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0.\napply Rle_ge; apply Rle_0_minus.\nrewrite Hxe.\napply bpow_le.\nlia.\ncontradict Zp.\nrewrite Hxe, He; ring."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) : (x - bpow (fexp (e - 1)) + bpow (fexp (e - 1)))%R = x.","proofString":"ring."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) : bpow (fexp (e - 1)) = ulp (x - bpow (fexp (e - 1))).","proofString":"assert (He:(fexp (e-1) <= e-1)%Z).\napply generic_format_bpow_inv with beta; trivial.\nrewrite <- Hxe; assumption.\ncase (Zle_lt_or_eq _ _ He); clear He; intros He.\nrewrite ulp_neq_0; trivial.\napply f_equal.\nunfold cexp ; apply f_equal.\napply sym_eq.\napply mag_unique.\nrewrite Rabs_right.\nsplit.\napply Rplus_le_reg_l with (bpow (fexp (e-1))).\nring_simplify.\napply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.\napply Rplus_le_compat; apply bpow_le; lia.\napply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right.\nrewrite <- Rplus_0_r, Hxe.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0.\napply Rle_ge; apply Rle_0_minus.\nrewrite Hxe.\napply bpow_le.\nlia.\ncontradict Zp.\nrewrite Hxe, He; ring."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) : (fexp (e - 1) <= e - 1)%Z.","proofString":"apply generic_format_bpow_inv with beta; trivial.\nrewrite <- Hxe; assumption."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) : F (bpow (e - 1)).","proofString":"rewrite <- Hxe; assumption."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) <= e - 1)%Z) : bpow (fexp (e - 1)) = ulp (x - bpow (fexp (e - 1))).","proofString":"case (Zle_lt_or_eq _ _ He); clear He; intros He.\nrewrite ulp_neq_0; trivial.\napply f_equal.\nunfold cexp ; apply f_equal.\napply sym_eq.\napply mag_unique.\nrewrite Rabs_right.\nsplit.\napply Rplus_le_reg_l with (bpow (fexp (e-1))).\nring_simplify.\napply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.\napply Rplus_le_compat; apply bpow_le; lia.\napply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right.\nrewrite <- Rplus_0_r, Hxe.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0.\napply Rle_ge; apply Rle_0_minus.\nrewrite Hxe.\napply bpow_le.\nlia.\ncontradict Zp.\nrewrite Hxe, He; ring."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : bpow (fexp (e - 1)) = ulp (x - bpow (fexp (e - 1))).","proofString":"rewrite ulp_neq_0; trivial.\napply f_equal.\nunfold cexp ; apply f_equal.\napply sym_eq.\napply mag_unique.\nrewrite Rabs_right.\nsplit.\napply Rplus_le_reg_l with (bpow (fexp (e-1))).\nring_simplify.\napply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.\napply Rplus_le_compat; apply bpow_le; lia.\napply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right.\nrewrite <- Rplus_0_r, Hxe.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0.\napply Rle_ge; apply Rle_0_minus.\nrewrite Hxe.\napply bpow_le.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : bpow (fexp (e - 1)) = bpow (cexp beta fexp (x - bpow (fexp (e - 1)))).","proofString":"apply f_equal.\nunfold cexp ; apply f_equal.\napply sym_eq.\napply mag_unique.\nrewrite Rabs_right.\nsplit.\napply Rplus_le_reg_l with (bpow (fexp (e-1))).\nring_simplify.\napply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.\napply Rplus_le_compat; apply bpow_le; lia.\napply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right.\nrewrite <- Rplus_0_r, Hxe.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0.\napply Rle_ge; apply Rle_0_minus.\nrewrite Hxe.\napply bpow_le.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : fexp (e - 1) = cexp beta fexp (x - bpow (fexp (e - 1))).","proofString":"unfold cexp ; apply f_equal.\napply sym_eq.\napply mag_unique.\nrewrite Rabs_right.\nsplit.\napply Rplus_le_reg_l with (bpow (fexp (e-1))).\nring_simplify.\napply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.\napply Rplus_le_compat; apply bpow_le; lia.\napply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right.\nrewrite <- Rplus_0_r, Hxe.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0.\napply Rle_ge; apply Rle_0_minus.\nrewrite Hxe.\napply bpow_le.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (e - 1)%Z = mag beta (x - bpow (fexp (e - 1))).","proofString":"apply sym_eq.\napply mag_unique.\nrewrite Rabs_right.\nsplit.\napply Rplus_le_reg_l with (bpow (fexp (e-1))).\nring_simplify.\napply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.\napply Rplus_le_compat; apply bpow_le; lia.\napply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right.\nrewrite <- Rplus_0_r, Hxe.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0.\napply Rle_ge; apply Rle_0_minus.\nrewrite Hxe.\napply bpow_le.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (e - 1 - 1) <= Rabs (x - bpow (fexp (e - 1))) < bpow (e - 1))%R.","proofString":"rewrite Rabs_right.\nsplit.\napply Rplus_le_reg_l with (bpow (fexp (e-1))).\nring_simplify.\napply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.\napply Rplus_le_compat; apply bpow_le; lia.\napply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right.\nrewrite <- Rplus_0_r, Hxe.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0.\napply Rle_ge; apply Rle_0_minus.\nrewrite Hxe.\napply bpow_le.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (e - 1 - 1) <= x - bpow (fexp (e - 1)) < bpow (e - 1))%R.","proofString":"split.\napply Rplus_le_reg_l with (bpow (fexp (e-1))).\nring_simplify.\napply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.\napply Rplus_le_compat; apply bpow_le; lia.\napply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right.\nrewrite <- Rplus_0_r, Hxe.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (e - 1 - 1) <= x - bpow (fexp (e - 1)))%R.","proofString":"apply Rplus_le_reg_l with (bpow (fexp (e-1))).\nring_simplify.\napply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.\napply Rplus_le_compat; apply bpow_le; lia.\napply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (fexp (e - 1)) + bpow (e - 1 - 1) <=\n bpow (fexp (e - 1)) + (x - bpow (fexp (e - 1))))%R.","proofString":"ring_simplify.\napply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.\napply Rplus_le_compat; apply bpow_le; lia.\napply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (fexp (e - 1)) + bpow (e - 1 - 1) <= x)%R.","proofString":"apply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.\napply Rplus_le_compat; apply bpow_le; lia.\napply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (fexp (e - 1)) + bpow (e - 1 - 1) <= bpow (e - 2) + bpow (e - 2))%R.","proofString":"apply Rplus_le_compat; apply bpow_le; lia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (e - 2) + bpow (e - 2) <= x)%R.","proofString":"apply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].\napply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (2 * bpow (e - 2) <= x)%R.","proofString":"apply Rle_trans with (bpow 1*bpow (e - 2))%R.\napply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r.\nrewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (2 * bpow (e - 2) <= bpow 1 * bpow (e - 2))%R.","proofString":"apply Rmult_le_compat_r.\napply bpow_ge_0.\nreplace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (0 <= bpow (e - 2))%R.","proofString":"apply bpow_ge_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (2 <= bpow 1)%R.","proofString":"replace (bpow 1) with (IZR beta).\napply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta.\nsimpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (2 <= IZR beta)%R.","proofString":"apply IZR_le.\napply <- Zle_is_le_bool.\nnow destruct beta."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (2 <= beta)%Z.","proofString":"apply <- Zle_is_le_bool.\nnow destruct beta."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (2 <=? beta)%Z = true.","proofString":"now destruct beta."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : IZR beta = bpow 1.","proofString":"simpl.\nunfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : IZR beta = IZR (Z.pow_pos beta 1).","proofString":"unfold Zpower_pos; simpl.\nnow rewrite Zmult_1_r."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : IZR beta = IZR (beta * 1).","proofString":"now rewrite Zmult_1_r."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow 1 * bpow (e - 2) <= x)%R.","proofString":"rewrite <- bpow_plus.\nreplace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (1 + (e - 2)) <= x)%R.","proofString":"replace (1+(e-2))%Z with (e-1)%Z by ring.\nnow right."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (e - 1) <= x)%R.","proofString":"now right."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (x - bpow (fexp (e - 1)) < bpow (e - 1))%R.","proofString":"rewrite <- Rplus_0_r, Hxe.\napply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (e - 1) - bpow (fexp (e - 1)) < bpow (e - 1) + 0)%R.","proofString":"apply Rplus_lt_compat_l.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (- bpow (fexp (e - 1)) < 0)%R.","proofString":"rewrite <- Ropp_0.\napply Ropp_lt_contravar.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (- bpow (fexp (e - 1)) < - 0)%R.","proofString":"apply Ropp_lt_contravar.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (0 < bpow (fexp (e - 1)))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (x - bpow (fexp (e - 1)) >= 0)%R.","proofString":"apply Rle_ge; apply Rle_0_minus.\nrewrite Hxe.\napply bpow_le.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (fexp (e - 1)) <= x)%R.","proofString":"rewrite Hxe.\napply bpow_le.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (bpow (fexp (e - 1)) <= bpow (e - 1))%R.","proofString":"apply bpow_le.\nlia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : (fexp (e - 1) < e - 1)%Z) : (fexp (e - 1) <= e - 1)%Z.","proofString":"lia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (Zp : (x - bpow (fexp (e - 1)))%R <> 0%R) (He : fexp (e - 1) = (e - 1)%Z) : bpow (fexp (e - 1)) = ulp (x - bpow (fexp (e - 1))).","proofString":"contradict Zp.\nrewrite Hxe, He; ring."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (e : Z) (Hxe : x = bpow (e - 1)) (He : fexp (e - 1) = (e - 1)%Z) : (x - bpow (fexp (e - 1)))%R = 0%R.","proofString":"rewrite Hxe, He; ring."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) (e : Z) (H1 : x = bpow (e - 1)) (H2 : (x - bpow (fexp (e - 1)))%R = 0%R) : ulp 0 = x.","proofString":"assert (H3:(x = bpow (fexp (e - 1)))).\nnow apply Rminus_diag_uniq.\nassert (H4: (fexp (e-1) = e-1)%Z).\napply bpow_inj with beta.\nnow rewrite <- H1.\nunfold ulp; rewrite Req_bool_true; trivial.\ncase negligible_exp_spec.\nintros K.\nspecialize (K (e-1)%Z).\ncontradict K; lia.\nintros n Hn.\nrewrite H3; apply f_equal.\ncase (Zle_or_lt n (e-1)); intros H6.\napply valid_exp; lia.\napply sym_eq, valid_exp; lia."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) (e : Z) (H1 : x = bpow (e - 1)) (H2 : (x - bpow (fexp (e - 1)))%R = 0%R) : x = bpow (fexp (e - 1)).","proofString":"now apply Rminus_diag_uniq."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) (e : Z) (H1 : x = bpow (e - 1)) (H2 : (x - bpow (fexp (e - 1)))%R = 0%R) (H3 : x = bpow (fexp (e - 1))) : ulp 0 = x.","proofString":"assert (H4: (fexp (e-1) = e-1)%Z).\napply bpow_inj with beta.\nnow rewrite <- H1.\nunfold ulp; rewrite Req_bool_true; trivial.\ncase negligible_exp_spec.\nintros K.\nspecialize (K (e-1)%Z).\ncontradict K; lia.\nintros n Hn.\nrewrite H3; apply f_equal.\ncase (Zle_or_lt n (e-1)); intros H6.\napply valid_exp; lia.\napply sym_eq, valid_exp; lia."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) (e : Z) (H1 : x = bpow (e - 1)) (H2 : (x - bpow (fexp (e - 1)))%R = 0%R) (H3 : x = bpow (fexp (e - 1))) : fexp (e - 1) = (e - 1)%Z.","proofString":"apply bpow_inj with beta.\nnow rewrite <- H1."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) (e : Z) (H1 : x = bpow (e - 1)) (H2 : (x - bpow (fexp (e - 1)))%R = 0%R) (H3 : x = bpow (fexp (e - 1))) : bpow (fexp (e - 1)) = bpow (e - 1).","proofString":"now rewrite <- H1."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) (e : Z) (H1 : x = bpow (e - 1)) (H2 : (x - bpow (fexp (e - 1)))%R = 0%R) (H3 : x = bpow (fexp (e - 1))) (H4 : fexp (e - 1) = (e - 1)%Z) : ulp 0 = x.","proofString":"unfold ulp; rewrite Req_bool_true; trivial.\ncase negligible_exp_spec.\nintros K.\nspecialize (K (e-1)%Z).\ncontradict K; lia.\nintros n Hn.\nrewrite H3; apply f_equal.\ncase (Zle_or_lt n (e-1)); intros H6.\napply valid_exp; lia.\napply sym_eq, valid_exp; lia."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) (e : Z) (H1 : x = bpow (e - 1)) (H2 : (x - bpow (fexp (e - 1)))%R = 0%R) (H3 : x = bpow (fexp (e - 1))) (H4 : fexp (e - 1) = (e - 1)%Z) : match negligible_exp with\n| Some n => bpow (fexp n)\n| None => 0%R\nend = x.","proofString":"case negligible_exp_spec.\nintros K.\nspecialize (K (e-1)%Z).\ncontradict K; lia.\nintros n Hn.\nrewrite H3; apply f_equal.\ncase (Zle_or_lt n (e-1)); intros H6.\napply valid_exp; lia.\napply sym_eq, valid_exp; lia."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) : (pred_pos x + ulp (pred_pos x))%R = x.","proofString":"unfold pred_pos.\ncase Req_bool_spec; intros H.\ncase (Req_EM_T (x - bpow (fexp (mag_val beta x (mag beta x) -1))) 0); intros H1.\nrewrite H1, Rplus_0_l.\nnow apply pred_pos_plus_ulp_aux3.\nnow apply pred_pos_plus_ulp_aux2.\nnow apply pred_pos_plus_ulp_aux1."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) : ((if Req_bool x (bpow (mag beta x - 1))\n  then x - bpow (fexp (mag beta x - 1))\n  else x - ulp x) +\n ulp\n   (if Req_bool x (bpow (mag beta x - 1))\n    then x - bpow (fexp (mag beta x - 1))\n    else x - ulp x))%R = x.","proofString":"case Req_bool_spec; intros H.\ncase (Req_EM_T (x - bpow (fexp (mag_val beta x (mag beta x) -1))) 0); intros H1.\nrewrite H1, Rplus_0_l.\nnow apply pred_pos_plus_ulp_aux3.\nnow apply pred_pos_plus_ulp_aux2.\nnow apply pred_pos_plus_ulp_aux1."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (H : x = bpow (mag beta x - 1)) : (x - bpow (fexp (mag beta x - 1)) + ulp (x - bpow (fexp (mag beta x - 1))))%R =\nx.","proofString":"case (Req_EM_T (x - bpow (fexp (mag_val beta x (mag beta x) -1))) 0); intros H1.\nrewrite H1, Rplus_0_l.\nnow apply pred_pos_plus_ulp_aux3.\nnow apply pred_pos_plus_ulp_aux2."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (H : x = bpow (mag beta x - 1)) (H1 : (x - bpow (fexp (mag beta x - 1)))%R = 0%R) : (x - bpow (fexp (mag beta x - 1)) + ulp (x - bpow (fexp (mag beta x - 1))))%R =\nx.","proofString":"rewrite H1, Rplus_0_l.\nnow apply pred_pos_plus_ulp_aux3."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (H : x = bpow (mag beta x - 1)) (H1 : (x - bpow (fexp (mag beta x - 1)))%R = 0%R) : ulp 0 = x.","proofString":"now apply pred_pos_plus_ulp_aux3."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (H : x = bpow (mag beta x - 1)) (H1 : (x - bpow (fexp (mag beta x - 1)))%R <> 0%R) : (x - bpow (fexp (mag beta x - 1)) + ulp (x - bpow (fexp (mag beta x - 1))))%R =\nx.","proofString":"now apply pred_pos_plus_ulp_aux2."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (H : x <> bpow (mag beta x - 1)) : (x - ulp x + ulp (x - ulp x))%R = x.","proofString":"now apply pred_pos_plus_ulp_aux1."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) : (pred x + ulp (pred x))%R = x.","proofString":"rewrite pred_eq_pos.\nnow apply pred_pos_plus_ulp.\nnow apply Rlt_le."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) : (pred_pos x + ulp (pred_pos x))%R = x.","proofString":"now apply pred_pos_plus_ulp."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) : (0 <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1) <= Rabs (x + eps) < bpow ex)%R.","proofString":"rewrite Rabs_pos_eq.\nrewrite Rabs_pos_eq in He.\nsplit.\napply Rle_trans with (1 := proj1 He).\npattern x at 1 ; rewrite <- Rplus_0_r.\nnow apply Rplus_le_compat_l.\napply Rlt_le_trans with (x + ulp x)%R.\nnow apply Rplus_lt_compat_l.\npattern x at 1 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R.\nsimpl.\npattern (bpow (cexp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.\nrewrite <- Rmult_plus_distr_r.\nrewrite <- plus_IZR.\napply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx.\nnow apply Rgt_not_eq.\nnow apply Rlt_le.\napply Rplus_le_le_0_compat.\nnow apply Rlt_le.\napply Heps."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1) <= x + eps < bpow ex)%R.","proofString":"rewrite Rabs_pos_eq in He.\nsplit.\napply Rle_trans with (1 := proj1 He).\npattern x at 1 ; rewrite <- Rplus_0_r.\nnow apply Rplus_le_compat_l.\napply Rlt_le_trans with (x + ulp x)%R.\nnow apply Rplus_lt_compat_l.\npattern x at 1 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R.\nsimpl.\npattern (bpow (cexp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.\nrewrite <- Rmult_plus_distr_r.\nrewrite <- plus_IZR.\napply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx.\nnow apply Rgt_not_eq.\nnow apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= x < bpow ex)%R) : (bpow (ex - 1) <= x + eps < bpow ex)%R.","proofString":"split.\napply Rle_trans with (1 := proj1 He).\npattern x at 1 ; rewrite <- Rplus_0_r.\nnow apply Rplus_le_compat_l.\napply Rlt_le_trans with (x + ulp x)%R.\nnow apply Rplus_lt_compat_l.\npattern x at 1 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R.\nsimpl.\npattern (bpow (cexp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.\nrewrite <- Rmult_plus_distr_r.\nrewrite <- plus_IZR.\napply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= x < bpow ex)%R) : (bpow (ex - 1) <= x + eps)%R.","proofString":"apply Rle_trans with (1 := proj1 He).\npattern x at 1 ; rewrite <- Rplus_0_r.\nnow apply Rplus_le_compat_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= x < bpow ex)%R) : (x <= x + eps)%R.","proofString":"pattern x at 1 ; rewrite <- Rplus_0_r.\nnow apply Rplus_le_compat_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= x < bpow ex)%R) : (x + 0 <= x + eps)%R.","proofString":"now apply Rplus_le_compat_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= x < bpow ex)%R) : (x + eps < bpow ex)%R.","proofString":"apply Rlt_le_trans with (x + ulp x)%R.\nnow apply Rplus_lt_compat_l.\npattern x at 1 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R.\nsimpl.\npattern (bpow (cexp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.\nrewrite <- Rmult_plus_distr_r.\nrewrite <- plus_IZR.\napply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= x < bpow ex)%R) : (x + eps < x + ulp x)%R.","proofString":"now apply Rplus_lt_compat_l."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= x < bpow ex)%R) : (x + ulp x <= bpow ex)%R.","proofString":"pattern x at 1 ; rewrite Fx.\nrewrite ulp_neq_0.\nunfold F2R.\nsimpl.\npattern (bpow (cexp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.\nrewrite <- Rmult_plus_distr_r.\nrewrite <- plus_IZR.\napply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= x < bpow ex)%R) : (IZR (Ztrunc (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x) +\n bpow (cexp beta fexp x) <= bpow ex)%R.","proofString":"pattern (bpow (cexp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.\nrewrite <- Rmult_plus_distr_r.\nrewrite <- plus_IZR.\napply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= x < bpow ex)%R) : (IZR (Ztrunc (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x) +\n 1 * bpow (cexp beta fexp x) <= bpow ex)%R.","proofString":"rewrite <- Rmult_plus_distr_r.\nrewrite <- plus_IZR.\napply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= x < bpow ex)%R) : ((IZR (Ztrunc (scaled_mantissa beta fexp x)) + 1) * bpow (cexp beta fexp x) <=\n bpow ex)%R.","proofString":"rewrite <- plus_IZR.\napply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= x < bpow ex)%R) : (IZR (Ztrunc (scaled_mantissa beta fexp x) + 1) * bpow (cexp beta fexp x) <=\n bpow ex)%R.","proofString":"apply F2R_p1_le_bpow.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\nnow rewrite <- Fx."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= x < bpow ex)%R) : (0 < Ztrunc (scaled_mantissa beta fexp x))%Z.","proofString":"apply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= x < bpow ex)%R) : x <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 <= x + eps)%R.","proofString":"apply Rplus_le_le_0_compat.\nnow apply Rlt_le.\napply Heps."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Zx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (ex : Z) (He : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 <= eps)%R.","proofString":"apply Heps."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : (0 < x)%R) (Heps1 : (0 < eps)%R) (Heps2 : (eps < ulp x)%R) : (0 <= eps < ulp x)%R.","proofString":"split.\nnow apply Rlt_le.\nexact Heps2."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : (0 < x)%R) (Heps1 : (0 < eps)%R) (Heps2 : (eps < ulp x)%R) : (0 <= eps)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : (0 < x)%R) (Heps1 : (0 < eps)%R) (Heps2 : (eps < ulp x)%R) : (eps < ulp x)%R.","proofString":"exact Heps2."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : (0 < x)%R) (Heps1 : (0 < eps)%R) (Heps2 : (eps < ulp x)%R) (Heps : (0 <= eps < ulp x)%R) (Hd : round beta fexp Zfloor (x + eps) = x) : (round beta fexp Zfloor (x + eps) + ulp (x + eps))%R = (x + ulp x)%R.","proofString":"rewrite Hd.\nrewrite 2!ulp_neq_0.\nunfold cexp.\nnow rewrite mag_plus_eps.\nnow apply Rgt_not_eq.\nnow apply Rgt_not_eq, Rplus_lt_0_compat."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : (0 < x)%R) (Heps1 : (0 < eps)%R) (Heps2 : (eps < ulp x)%R) (Heps : (0 <= eps < ulp x)%R) (Hd : round beta fexp Zfloor (x + eps) = x) : (x + ulp (x + eps))%R = (x + ulp x)%R.","proofString":"rewrite 2!ulp_neq_0.\nunfold cexp.\nnow rewrite mag_plus_eps.\nnow apply Rgt_not_eq.\nnow apply Rgt_not_eq, Rplus_lt_0_compat."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : (0 < x)%R) (Heps1 : (0 < eps)%R) (Heps2 : (eps < ulp x)%R) (Heps : (0 <= eps < ulp x)%R) (Hd : round beta fexp Zfloor (x + eps) = x) : (x + bpow (cexp beta fexp (x + eps)))%R = (x + bpow (cexp beta fexp x))%R.","proofString":"unfold cexp.\nnow rewrite mag_plus_eps."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : (0 < x)%R) (Heps1 : (0 < eps)%R) (Heps2 : (eps < ulp x)%R) (Heps : (0 <= eps < ulp x)%R) (Hd : round beta fexp Zfloor (x + eps) = x) : (x + bpow (fexp (mag beta (x + eps))))%R = (x + bpow (fexp (mag beta x)))%R.","proofString":"now rewrite mag_plus_eps."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : (0 < x)%R) (Heps1 : (0 < eps)%R) (Heps2 : (eps < ulp x)%R) (Heps : (0 <= eps < ulp x)%R) (Hd : round beta fexp Zfloor (x + eps) = x) : x <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : (0 < x)%R) (Heps1 : (0 < eps)%R) (Heps2 : (eps < ulp x)%R) (Heps : (0 <= eps < ulp x)%R) (Hd : round beta fexp Zfloor (x + eps) = x) : (x + eps)%R <> 0%R.","proofString":"now apply Rgt_not_eq, Rplus_lt_0_compat."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : (0 < x)%R) (Heps1 : (0 < eps)%R) (Heps2 : (eps < ulp x)%R) (Heps : (0 <= eps < ulp x)%R) (Hd : (x + eps)%R = x) (Fs : F (x + eps)) : False.","proofString":"apply Rgt_not_eq with (2 := Hd).\npattern x at 2 ; rewrite <- Rplus_0_r.\nnow apply Rplus_lt_compat_l."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : (0 < x)%R) (Heps1 : (0 < eps)%R) (Heps2 : (eps < ulp x)%R) (Heps : (0 <= eps < ulp x)%R) (Hd : (x + eps)%R = x) (Fs : F (x + eps)) : (x + eps > x)%R.","proofString":"pattern x at 2 ; rewrite <- Rplus_0_r.\nnow apply Rplus_lt_compat_l."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : (0 < x)%R) (Heps1 : (0 < eps)%R) (Heps2 : (eps < ulp x)%R) (Heps : (0 <= eps < ulp x)%R) (Hd : (x + eps)%R = x) (Fs : F (x + eps)) : (x + eps > x + 0)%R.","proofString":"now apply Rplus_lt_compat_l."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : (0 < x)%R) (Heps1 : (0 < eps)%R) (Heps2 : eps = ulp x) : F (x + ulp x).","proofString":"now apply generic_format_succ_aux1."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) : (eps < ulp 0)%R -> round beta fexp Zceil eps = ulp 0.","proofString":"unfold round, scaled_mantissa, cexp.\nunfold ulp.\nrewrite Req_bool_true; trivial.\ncase negligible_exp_spec.\nlra.\nintros n Hn H.\nassert (fexp (mag beta eps) = fexp n).\napply valid_exp; try assumption.\ncut (mag beta eps-1 < fexp n)%Z.\nlia.\napply lt_bpow with beta.\napply Rle_lt_trans with (2:=H).\ndestruct (mag beta eps) as (e,He).\nsimpl; rewrite Rabs_pos_eq in He.\nnow apply He, Rgt_not_eq.\nnow left.\nreplace (Zceil (eps * bpow (- fexp (mag beta eps)))) with 1%Z.\nunfold F2R; simpl; rewrite H0; ring.\napply sym_eq, Zceil_imp.\nsplit.\nsimpl; apply Rmult_lt_0_compat.\napply Heps.\napply bpow_gt_0.\napply Rmult_le_reg_r with (bpow (fexp n)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus.\nrewrite H0; ring_simplify (-fexp n + fexp n)%Z.\nsimpl; rewrite Rmult_1_l, Rmult_1_r.\nnow left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) : fexp (mag beta eps) = fexp n.","proofString":"apply valid_exp; try assumption.\ncut (mag beta eps-1 < fexp n)%Z.\nlia.\napply lt_bpow with beta.\napply Rle_lt_trans with (2:=H).\ndestruct (mag beta eps) as (e,He).\nsimpl; rewrite Rabs_pos_eq in He.\nnow apply He, Rgt_not_eq.\nnow left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) : (mag beta eps <= fexp n)%Z.","proofString":"cut (mag beta eps-1 < fexp n)%Z.\nlia.\napply lt_bpow with beta.\napply Rle_lt_trans with (2:=H).\ndestruct (mag beta eps) as (e,He).\nsimpl; rewrite Rabs_pos_eq in He.\nnow apply He, Rgt_not_eq.\nnow left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) : (mag beta eps - 1 < fexp n)%Z -> (mag beta eps <= fexp n)%Z.","proofString":"lia."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) : (mag beta eps - 1 < fexp n)%Z.","proofString":"apply lt_bpow with beta.\napply Rle_lt_trans with (2:=H).\ndestruct (mag beta eps) as (e,He).\nsimpl; rewrite Rabs_pos_eq in He.\nnow apply He, Rgt_not_eq.\nnow left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) : (bpow (mag beta eps - 1) < bpow (fexp n))%R.","proofString":"apply Rle_lt_trans with (2:=H).\ndestruct (mag beta eps) as (e,He).\nsimpl; rewrite Rabs_pos_eq in He.\nnow apply He, Rgt_not_eq.\nnow left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) : (bpow (mag beta eps - 1) <= eps)%R.","proofString":"destruct (mag beta eps) as (e,He).\nsimpl; rewrite Rabs_pos_eq in He.\nnow apply He, Rgt_not_eq.\nnow left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (e : Z) (He : eps <> 0%R -> (bpow (e - 1) <= Rabs eps < bpow e)%R) : (bpow (Build_mag_prop beta eps e He - 1) <= eps)%R.","proofString":"simpl; rewrite Rabs_pos_eq in He.\nnow apply He, Rgt_not_eq.\nnow left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (e : Z) (He : eps <> 0%R -> (bpow (e - 1) <= eps < bpow e)%R) : (bpow (e - 1) <= eps)%R.","proofString":"now apply He, Rgt_not_eq."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (e : Z) (He : eps <> 0%R -> (bpow (e - 1) <= Rabs eps < bpow e)%R) : (0 <= eps)%R.","proofString":"now left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (H0 : fexp (mag beta eps) = fexp n) : 1%Z = Zceil (eps * bpow (- fexp (mag beta eps))).","proofString":"apply sym_eq, Zceil_imp.\nsplit.\nsimpl; apply Rmult_lt_0_compat.\napply Heps.\napply bpow_gt_0.\napply Rmult_le_reg_r with (bpow (fexp n)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus.\nrewrite H0; ring_simplify (-fexp n + fexp n)%Z.\nsimpl; rewrite Rmult_1_l, Rmult_1_r.\nnow left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (H0 : fexp (mag beta eps) = fexp n) : (IZR (1 - 1) < eps * bpow (- fexp (mag beta eps)) <= 1)%R.","proofString":"split.\nsimpl; apply Rmult_lt_0_compat.\napply Heps.\napply bpow_gt_0.\napply Rmult_le_reg_r with (bpow (fexp n)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus.\nrewrite H0; ring_simplify (-fexp n + fexp n)%Z.\nsimpl; rewrite Rmult_1_l, Rmult_1_r.\nnow left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (H0 : fexp (mag beta eps) = fexp n) : (IZR (1 - 1) < eps * bpow (- fexp (mag beta eps)))%R.","proofString":"simpl; apply Rmult_lt_0_compat.\napply Heps.\napply bpow_gt_0."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (H0 : fexp (mag beta eps) = fexp n) : (0 < eps)%R.","proofString":"apply Heps."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (H0 : fexp (mag beta eps) = fexp n) : (0 < bpow (- fexp (mag beta eps)))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (H0 : fexp (mag beta eps) = fexp n) : (eps * bpow (- fexp (mag beta eps)) <= 1)%R.","proofString":"apply Rmult_le_reg_r with (bpow (fexp n)).\napply bpow_gt_0.\nrewrite Rmult_assoc, <- bpow_plus.\nrewrite H0; ring_simplify (-fexp n + fexp n)%Z.\nsimpl; rewrite Rmult_1_l, Rmult_1_r.\nnow left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (H0 : fexp (mag beta eps) = fexp n) : (0 < bpow (fexp n))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (H0 : fexp (mag beta eps) = fexp n) : (eps * bpow (- fexp (mag beta eps)) * bpow (fexp n) <= 1 * bpow (fexp n))%R.","proofString":"rewrite Rmult_assoc, <- bpow_plus.\nrewrite H0; ring_simplify (-fexp n + fexp n)%Z.\nsimpl; rewrite Rmult_1_l, Rmult_1_r.\nnow left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (H0 : fexp (mag beta eps) = fexp n) : (eps * bpow (- fexp (mag beta eps) + fexp n) <= 1 * bpow (fexp n))%R.","proofString":"rewrite H0; ring_simplify (-fexp n + fexp n)%Z.\nsimpl; rewrite Rmult_1_l, Rmult_1_r.\nnow left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (H0 : fexp (mag beta eps) = fexp n) : (eps * bpow 0 <= 1 * bpow (fexp n))%R.","proofString":"simpl; rewrite Rmult_1_l, Rmult_1_r.\nnow left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (n : Z) (Hn : (n <= fexp n)%Z) (H : (eps < bpow (fexp n))%R) (H0 : fexp (mag beta eps) = fexp n) : (eps <= bpow (fexp n))%R.","proofString":"now left."},{"statement":"(x : R) (Zx : (0 <= x)%R) (Fx : F x) (eps : R) (Zx1 : 0%R = x) (Heps : (0 < eps <= ulp 0)%R) (P : eps = ulp 0) : F (ulp 0).","proofString":"apply generic_format_ulp_0."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred x))%R) : round beta fexp Zceil (pred x + eps) = x.","proofString":"rewrite round_UP_plus_eps_pos; trivial.\nrewrite pred_eq_pos.\napply pred_pos_plus_ulp; trivial.\nnow left.\nnow apply pred_ge_0.\napply generic_format_pred; trivial."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred x))%R) : (pred x + ulp (pred x))%R = x.","proofString":"rewrite pred_eq_pos.\napply pred_pos_plus_ulp; trivial.\nnow left."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred x))%R) : (pred_pos x + ulp (pred_pos x))%R = x.","proofString":"apply pred_pos_plus_ulp; trivial."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred x))%R) : (0 <= x)%R.","proofString":"now left."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred x))%R) : (0 <= pred x)%R.","proofString":"now apply pred_ge_0."},{"statement":"(x : R) (Hx : (0 < x)%R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred x))%R) : F (pred x).","proofString":"apply generic_format_pred; trivial."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < (if Rle_bool 0 x then ulp x else ulp (pred (- x))))%R) : round beta fexp Zfloor (x + eps) = x.","proofString":"case (Rle_or_lt 0 x); intros Zx.\napply round_DN_plus_eps_pos; try assumption.\nsplit; try apply Heps.\nrewrite Rle_bool_true in Heps; trivial.\nnow apply Heps.\nrewrite Rle_bool_false in Heps; trivial.\nrewrite <- (Ropp_involutive (x+eps)).\npattern x at 2; rewrite <- (Ropp_involutive x).\nrewrite round_DN_opp.\napply f_equal.\nreplace (-(x+eps))%R with (pred (-x) + (ulp (pred (-x)) - eps))%R.\nrewrite round_UP_pred_plus_eps_pos; try reflexivity.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nsplit.\napply Rplus_lt_reg_l with eps; ring_simplify.\napply Heps.\napply Rplus_le_reg_l with (eps-ulp (pred (- x)))%R; ring_simplify.\napply Heps.\nunfold pred.\nrewrite Ropp_involutive.\nunfold succ; rewrite Rle_bool_false; try assumption.\nrewrite Ropp_involutive; unfold Rminus.\nrewrite <- Rplus_assoc, pred_pos_plus_ulp.\nring.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < (if Rle_bool 0 x then ulp x else ulp (pred (- x))))%R) (Zx : (0 <= x)%R) : round beta fexp Zfloor (x + eps) = x.","proofString":"apply round_DN_plus_eps_pos; try assumption.\nsplit; try apply Heps.\nrewrite Rle_bool_true in Heps; trivial.\nnow apply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < (if Rle_bool 0 x then ulp x else ulp (pred (- x))))%R) (Zx : (0 <= x)%R) : (0 <= eps < ulp x)%R.","proofString":"split; try apply Heps.\nrewrite Rle_bool_true in Heps; trivial.\nnow apply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < (if Rle_bool 0 x then ulp x else ulp (pred (- x))))%R) (Zx : (0 <= x)%R) : (eps < ulp x)%R.","proofString":"rewrite Rle_bool_true in Heps; trivial.\nnow apply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp x)%R) (Zx : (0 <= x)%R) : (eps < ulp x)%R.","proofString":"now apply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < (if Rle_bool 0 x then ulp x else ulp (pred (- x))))%R) (Zx : (x < 0)%R) : round beta fexp Zfloor (x + eps) = x.","proofString":"rewrite Rle_bool_false in Heps; trivial.\nrewrite <- (Ropp_involutive (x+eps)).\npattern x at 2; rewrite <- (Ropp_involutive x).\nrewrite round_DN_opp.\napply f_equal.\nreplace (-(x+eps))%R with (pred (-x) + (ulp (pred (-x)) - eps))%R.\nrewrite round_UP_pred_plus_eps_pos; try reflexivity.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nsplit.\napply Rplus_lt_reg_l with eps; ring_simplify.\napply Heps.\napply Rplus_le_reg_l with (eps-ulp (pred (- x)))%R; ring_simplify.\napply Heps.\nunfold pred.\nrewrite Ropp_involutive.\nunfold succ; rewrite Rle_bool_false; try assumption.\nrewrite Ropp_involutive; unfold Rminus.\nrewrite <- Rplus_assoc, pred_pos_plus_ulp.\nring.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : round beta fexp Zfloor (x + eps) = x.","proofString":"rewrite <- (Ropp_involutive (x+eps)).\npattern x at 2; rewrite <- (Ropp_involutive x).\nrewrite round_DN_opp.\napply f_equal.\nreplace (-(x+eps))%R with (pred (-x) + (ulp (pred (-x)) - eps))%R.\nrewrite round_UP_pred_plus_eps_pos; try reflexivity.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nsplit.\napply Rplus_lt_reg_l with eps; ring_simplify.\napply Heps.\napply Rplus_le_reg_l with (eps-ulp (pred (- x)))%R; ring_simplify.\napply Heps.\nunfold pred.\nrewrite Ropp_involutive.\nunfold succ; rewrite Rle_bool_false; try assumption.\nrewrite Ropp_involutive; unfold Rminus.\nrewrite <- Rplus_assoc, pred_pos_plus_ulp.\nring.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : round beta fexp Zfloor (- - (x + eps)) = x.","proofString":"pattern x at 2; rewrite <- (Ropp_involutive x).\nrewrite round_DN_opp.\napply f_equal.\nreplace (-(x+eps))%R with (pred (-x) + (ulp (pred (-x)) - eps))%R.\nrewrite round_UP_pred_plus_eps_pos; try reflexivity.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nsplit.\napply Rplus_lt_reg_l with eps; ring_simplify.\napply Heps.\napply Rplus_le_reg_l with (eps-ulp (pred (- x)))%R; ring_simplify.\napply Heps.\nunfold pred.\nrewrite Ropp_involutive.\nunfold succ; rewrite Rle_bool_false; try assumption.\nrewrite Ropp_involutive; unfold Rminus.\nrewrite <- Rplus_assoc, pred_pos_plus_ulp.\nring.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : round beta fexp Zfloor (- - (x + eps)) = (- - x)%R.","proofString":"rewrite round_DN_opp.\napply f_equal.\nreplace (-(x+eps))%R with (pred (-x) + (ulp (pred (-x)) - eps))%R.\nrewrite round_UP_pred_plus_eps_pos; try reflexivity.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nsplit.\napply Rplus_lt_reg_l with eps; ring_simplify.\napply Heps.\napply Rplus_le_reg_l with (eps-ulp (pred (- x)))%R; ring_simplify.\napply Heps.\nunfold pred.\nrewrite Ropp_involutive.\nunfold succ; rewrite Rle_bool_false; try assumption.\nrewrite Ropp_involutive; unfold Rminus.\nrewrite <- Rplus_assoc, pred_pos_plus_ulp.\nring.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (- round beta fexp Zceil (- (x + eps)))%R = (- - x)%R.","proofString":"apply f_equal.\nreplace (-(x+eps))%R with (pred (-x) + (ulp (pred (-x)) - eps))%R.\nrewrite round_UP_pred_plus_eps_pos; try reflexivity.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nsplit.\napply Rplus_lt_reg_l with eps; ring_simplify.\napply Heps.\napply Rplus_le_reg_l with (eps-ulp (pred (- x)))%R; ring_simplify.\napply Heps.\nunfold pred.\nrewrite Ropp_involutive.\nunfold succ; rewrite Rle_bool_false; try assumption.\nrewrite Ropp_involutive; unfold Rminus.\nrewrite <- Rplus_assoc, pred_pos_plus_ulp.\nring.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : round beta fexp Zceil (- (x + eps)) = (- x)%R.","proofString":"replace (-(x+eps))%R with (pred (-x) + (ulp (pred (-x)) - eps))%R.\nrewrite round_UP_pred_plus_eps_pos; try reflexivity.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nsplit.\napply Rplus_lt_reg_l with eps; ring_simplify.\napply Heps.\napply Rplus_le_reg_l with (eps-ulp (pred (- x)))%R; ring_simplify.\napply Heps.\nunfold pred.\nrewrite Ropp_involutive.\nunfold succ; rewrite Rle_bool_false; try assumption.\nrewrite Ropp_involutive; unfold Rminus.\nrewrite <- Rplus_assoc, pred_pos_plus_ulp.\nring.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : round beta fexp Zceil (pred (- x) + (ulp (pred (- x)) - eps)) = (- x)%R.","proofString":"rewrite round_UP_pred_plus_eps_pos; try reflexivity.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nsplit.\napply Rplus_lt_reg_l with eps; ring_simplify.\napply Heps.\napply Rplus_le_reg_l with (eps-ulp (pred (- x)))%R; ring_simplify.\napply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (0 < - x)%R.","proofString":"now apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (0 < ulp (pred (- x)) - eps <= ulp (pred (- x)))%R.","proofString":"split.\napply Rplus_lt_reg_l with eps; ring_simplify.\napply Heps.\napply Rplus_le_reg_l with (eps-ulp (pred (- x)))%R; ring_simplify.\napply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (0 < ulp (pred (- x)) - eps)%R.","proofString":"apply Rplus_lt_reg_l with eps; ring_simplify.\napply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (eps < ulp (pred (- x)))%R.","proofString":"apply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (ulp (pred (- x)) - eps <= ulp (pred (- x)))%R.","proofString":"apply Rplus_le_reg_l with (eps-ulp (pred (- x)))%R; ring_simplify.\napply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (0 <= eps)%R.","proofString":"apply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (pred (- x) + (ulp (pred (- x)) - eps))%R = (- (x + eps))%R.","proofString":"unfold pred.\nrewrite Ropp_involutive.\nunfold succ; rewrite Rle_bool_false; try assumption.\nrewrite Ropp_involutive; unfold Rminus.\nrewrite <- Rplus_assoc, pred_pos_plus_ulp.\nring.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (- succ (- - x) + (ulp (- succ (- - x)) - eps))%R = (- (x + eps))%R.","proofString":"rewrite Ropp_involutive.\nunfold succ; rewrite Rle_bool_false; try assumption.\nrewrite Ropp_involutive; unfold Rminus.\nrewrite <- Rplus_assoc, pred_pos_plus_ulp.\nring.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (- succ x + (ulp (- succ x) - eps))%R = (- (x + eps))%R.","proofString":"unfold succ; rewrite Rle_bool_false; try assumption.\nrewrite Ropp_involutive; unfold Rminus.\nrewrite <- Rplus_assoc, pred_pos_plus_ulp.\nring.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (- - pred_pos (- x) + (ulp (- - pred_pos (- x)) - eps))%R = (- (x + eps))%R.","proofString":"rewrite Ropp_involutive; unfold Rminus.\nrewrite <- Rplus_assoc, pred_pos_plus_ulp.\nring.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (pred_pos (- x) + (ulp (pred_pos (- x)) + - eps))%R = (- (x + eps))%R.","proofString":"rewrite <- Rplus_assoc, pred_pos_plus_ulp.\nring.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (- x + - eps)%R = (- (x + eps))%R.","proofString":"ring."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (0 < - x)%R.","proofString":"now apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 <= eps < ulp (pred (- x)))%R) (Zx : (x < 0)%R) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool 0 x then ulp x else ulp (pred (- x))))%R) : round beta fexp Zceil (x + eps) = succ x.","proofString":"case (Rle_or_lt 0 x); intros Zx.\nrewrite succ_eq_pos; try assumption.\nrewrite Rle_bool_true in Heps; trivial.\napply round_UP_plus_eps_pos; assumption.\nrewrite Rle_bool_false in Heps; trivial.\nrewrite <- (Ropp_involutive (x+eps)).\nrewrite <- (Ropp_involutive (succ x)).\nrewrite round_UP_opp.\napply f_equal.\nreplace (-(x+eps))%R with (-succ x + (-eps + ulp (pred (-x))))%R.\napply round_DN_plus_eps_pos.\nrewrite <- pred_opp.\napply pred_ge_0.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nnow apply generic_format_opp, generic_format_succ.\nsplit.\napply Rplus_le_reg_l with eps; ring_simplify.\napply Heps.\nunfold pred; rewrite Ropp_involutive.\napply Rplus_lt_reg_l with (eps-ulp (- succ x))%R; ring_simplify.\napply Heps.\nunfold succ; rewrite Rle_bool_false; try assumption.\napply trans_eq with (-x +-eps)%R;[idtac|ring].\npattern (-x)%R at 3; rewrite <- (pred_pos_plus_ulp (-x)).\nrewrite pred_eq_pos.\nring.\nleft; now apply Ropp_0_gt_lt_contravar.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool 0 x then ulp x else ulp (pred (- x))))%R) (Zx : (0 <= x)%R) : round beta fexp Zceil (x + eps) = succ x.","proofString":"rewrite succ_eq_pos; try assumption.\nrewrite Rle_bool_true in Heps; trivial.\napply round_UP_plus_eps_pos; assumption."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool 0 x then ulp x else ulp (pred (- x))))%R) (Zx : (0 <= x)%R) : round beta fexp Zceil (x + eps) = (x + ulp x)%R.","proofString":"rewrite Rle_bool_true in Heps; trivial.\napply round_UP_plus_eps_pos; assumption."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp x)%R) (Zx : (0 <= x)%R) : round beta fexp Zceil (x + eps) = (x + ulp x)%R.","proofString":"apply round_UP_plus_eps_pos; assumption."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool 0 x then ulp x else ulp (pred (- x))))%R) (Zx : (x < 0)%R) : round beta fexp Zceil (x + eps) = succ x.","proofString":"rewrite Rle_bool_false in Heps; trivial.\nrewrite <- (Ropp_involutive (x+eps)).\nrewrite <- (Ropp_involutive (succ x)).\nrewrite round_UP_opp.\napply f_equal.\nreplace (-(x+eps))%R with (-succ x + (-eps + ulp (pred (-x))))%R.\napply round_DN_plus_eps_pos.\nrewrite <- pred_opp.\napply pred_ge_0.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nnow apply generic_format_opp, generic_format_succ.\nsplit.\napply Rplus_le_reg_l with eps; ring_simplify.\napply Heps.\nunfold pred; rewrite Ropp_involutive.\napply Rplus_lt_reg_l with (eps-ulp (- succ x))%R; ring_simplify.\napply Heps.\nunfold succ; rewrite Rle_bool_false; try assumption.\napply trans_eq with (-x +-eps)%R;[idtac|ring].\npattern (-x)%R at 3; rewrite <- (pred_pos_plus_ulp (-x)).\nrewrite pred_eq_pos.\nring.\nleft; now apply Ropp_0_gt_lt_contravar.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : round beta fexp Zceil (x + eps) = succ x.","proofString":"rewrite <- (Ropp_involutive (x+eps)).\nrewrite <- (Ropp_involutive (succ x)).\nrewrite round_UP_opp.\napply f_equal.\nreplace (-(x+eps))%R with (-succ x + (-eps + ulp (pred (-x))))%R.\napply round_DN_plus_eps_pos.\nrewrite <- pred_opp.\napply pred_ge_0.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nnow apply generic_format_opp, generic_format_succ.\nsplit.\napply Rplus_le_reg_l with eps; ring_simplify.\napply Heps.\nunfold pred; rewrite Ropp_involutive.\napply Rplus_lt_reg_l with (eps-ulp (- succ x))%R; ring_simplify.\napply Heps.\nunfold succ; rewrite Rle_bool_false; try assumption.\napply trans_eq with (-x +-eps)%R;[idtac|ring].\npattern (-x)%R at 3; rewrite <- (pred_pos_plus_ulp (-x)).\nrewrite pred_eq_pos.\nring.\nleft; now apply Ropp_0_gt_lt_contravar.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : round beta fexp Zceil (- - (x + eps)) = succ x.","proofString":"rewrite <- (Ropp_involutive (succ x)).\nrewrite round_UP_opp.\napply f_equal.\nreplace (-(x+eps))%R with (-succ x + (-eps + ulp (pred (-x))))%R.\napply round_DN_plus_eps_pos.\nrewrite <- pred_opp.\napply pred_ge_0.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nnow apply generic_format_opp, generic_format_succ.\nsplit.\napply Rplus_le_reg_l with eps; ring_simplify.\napply Heps.\nunfold pred; rewrite Ropp_involutive.\napply Rplus_lt_reg_l with (eps-ulp (- succ x))%R; ring_simplify.\napply Heps.\nunfold succ; rewrite Rle_bool_false; try assumption.\napply trans_eq with (-x +-eps)%R;[idtac|ring].\npattern (-x)%R at 3; rewrite <- (pred_pos_plus_ulp (-x)).\nrewrite pred_eq_pos.\nring.\nleft; now apply Ropp_0_gt_lt_contravar.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : round beta fexp Zceil (- - (x + eps)) = (- - succ x)%R.","proofString":"rewrite round_UP_opp.\napply f_equal.\nreplace (-(x+eps))%R with (-succ x + (-eps + ulp (pred (-x))))%R.\napply round_DN_plus_eps_pos.\nrewrite <- pred_opp.\napply pred_ge_0.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nnow apply generic_format_opp, generic_format_succ.\nsplit.\napply Rplus_le_reg_l with eps; ring_simplify.\napply Heps.\nunfold pred; rewrite Ropp_involutive.\napply Rplus_lt_reg_l with (eps-ulp (- succ x))%R; ring_simplify.\napply Heps.\nunfold succ; rewrite Rle_bool_false; try assumption.\napply trans_eq with (-x +-eps)%R;[idtac|ring].\npattern (-x)%R at 3; rewrite <- (pred_pos_plus_ulp (-x)).\nrewrite pred_eq_pos.\nring.\nleft; now apply Ropp_0_gt_lt_contravar.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (- round beta fexp Zfloor (- (x + eps)))%R = (- - succ x)%R.","proofString":"apply f_equal.\nreplace (-(x+eps))%R with (-succ x + (-eps + ulp (pred (-x))))%R.\napply round_DN_plus_eps_pos.\nrewrite <- pred_opp.\napply pred_ge_0.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nnow apply generic_format_opp, generic_format_succ.\nsplit.\napply Rplus_le_reg_l with eps; ring_simplify.\napply Heps.\nunfold pred; rewrite Ropp_involutive.\napply Rplus_lt_reg_l with (eps-ulp (- succ x))%R; ring_simplify.\napply Heps.\nunfold succ; rewrite Rle_bool_false; try assumption.\napply trans_eq with (-x +-eps)%R;[idtac|ring].\npattern (-x)%R at 3; rewrite <- (pred_pos_plus_ulp (-x)).\nrewrite pred_eq_pos.\nring.\nleft; now apply Ropp_0_gt_lt_contravar.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : round beta fexp Zfloor (- (x + eps)) = (- succ x)%R.","proofString":"replace (-(x+eps))%R with (-succ x + (-eps + ulp (pred (-x))))%R.\napply round_DN_plus_eps_pos.\nrewrite <- pred_opp.\napply pred_ge_0.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nnow apply generic_format_opp, generic_format_succ.\nsplit.\napply Rplus_le_reg_l with eps; ring_simplify.\napply Heps.\nunfold pred; rewrite Ropp_involutive.\napply Rplus_lt_reg_l with (eps-ulp (- succ x))%R; ring_simplify.\napply Heps.\nunfold succ; rewrite Rle_bool_false; try assumption.\napply trans_eq with (-x +-eps)%R;[idtac|ring].\npattern (-x)%R at 3; rewrite <- (pred_pos_plus_ulp (-x)).\nrewrite pred_eq_pos.\nring.\nleft; now apply Ropp_0_gt_lt_contravar.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : round beta fexp Zfloor (- succ x + (- eps + ulp (pred (- x)))) = (- succ x)%R.","proofString":"apply round_DN_plus_eps_pos.\nrewrite <- pred_opp.\napply pred_ge_0.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp.\nnow apply generic_format_opp, generic_format_succ.\nsplit.\napply Rplus_le_reg_l with eps; ring_simplify.\napply Heps.\nunfold pred; rewrite Ropp_involutive.\napply Rplus_lt_reg_l with (eps-ulp (- succ x))%R; ring_simplify.\napply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (0 <= - succ x)%R.","proofString":"rewrite <- pred_opp.\napply pred_ge_0.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (0 <= pred (- x))%R.","proofString":"apply pred_ge_0.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (0 < - x)%R.","proofString":"now apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : F (- succ x).","proofString":"now apply generic_format_opp, generic_format_succ."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (0 <= - eps + ulp (pred (- x)) < ulp (- succ x))%R.","proofString":"split.\napply Rplus_le_reg_l with eps; ring_simplify.\napply Heps.\nunfold pred; rewrite Ropp_involutive.\napply Rplus_lt_reg_l with (eps-ulp (- succ x))%R; ring_simplify.\napply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (0 <= - eps + ulp (pred (- x)))%R.","proofString":"apply Rplus_le_reg_l with eps; ring_simplify.\napply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (eps <= ulp (pred (- x)))%R.","proofString":"apply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (- eps + ulp (pred (- x)) < ulp (- succ x))%R.","proofString":"unfold pred; rewrite Ropp_involutive.\napply Rplus_lt_reg_l with (eps-ulp (- succ x))%R; ring_simplify.\napply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (- eps + ulp (- succ x) < ulp (- succ x))%R.","proofString":"apply Rplus_lt_reg_l with (eps-ulp (- succ x))%R; ring_simplify.\napply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (0 < eps)%R.","proofString":"apply Heps."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (- succ x + (- eps + ulp (pred (- x))))%R = (- (x + eps))%R.","proofString":"unfold succ; rewrite Rle_bool_false; try assumption.\napply trans_eq with (-x +-eps)%R;[idtac|ring].\npattern (-x)%R at 3; rewrite <- (pred_pos_plus_ulp (-x)).\nrewrite pred_eq_pos.\nring.\nleft; now apply Ropp_0_gt_lt_contravar.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (- - pred_pos (- x) + (- eps + ulp (pred (- x))))%R = (- (x + eps))%R.","proofString":"apply trans_eq with (-x +-eps)%R;[idtac|ring].\npattern (-x)%R at 3; rewrite <- (pred_pos_plus_ulp (-x)).\nrewrite pred_eq_pos.\nring.\nleft; now apply Ropp_0_gt_lt_contravar.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (- - pred_pos (- x) + (- eps + ulp (pred (- x))))%R = (- x + - eps)%R.","proofString":"pattern (-x)%R at 3; rewrite <- (pred_pos_plus_ulp (-x)).\nrewrite pred_eq_pos.\nring.\nleft; now apply Ropp_0_gt_lt_contravar.\nnow apply Ropp_0_gt_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (- - pred_pos (- x) + (- eps + ulp (pred (- x))))%R =\n(pred_pos (- x) + ulp (pred_pos (- x)) + - eps)%R.","proofString":"rewrite pred_eq_pos.\nring.\nleft; now apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (- - pred_pos (- x) + (- eps + ulp (pred_pos (- x))))%R =\n(pred_pos (- x) + ulp (pred_pos (- x)) + - eps)%R.","proofString":"ring."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (0 <= - x)%R.","proofString":"left; now apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : (0 < - x)%R.","proofString":"now apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= ulp (pred (- x)))%R) (Zx : (x < 0)%R) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) : (0 < y)%R.","proofString":"apply Rle_lt_trans with (1:=proj1 H).\napply H."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) : (x < y)%R.","proofString":"apply H."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) : (0 < pred y)%R.","proofString":"assert (Zp:(0 <= pred y)%R).\napply pred_ge_0 ; trivial.\ndestruct Zp; trivial.\ngeneralize H0.\nrewrite pred_eq_pos;[idtac|now left].\nunfold pred_pos.\ndestruct (mag beta y) as (ey,Hey); simpl.\ncase Req_bool_spec; intros Hy2.\nintros Hy3.\nassert (ey-1 = fexp (ey -1))%Z.\napply bpow_inj with beta.\nrewrite <- Hy2, <- Rplus_0_l, Hy3.\nring.\nassert (Zx: (x <> 0)%R).\nnow apply Rgt_not_eq.\ndestruct (mag beta x) as (ex,Hex).\nspecialize (Hex Zx).\nassert (ex <= ey)%Z.\napply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq.\ncase (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge.\nintros Hy3.\nassert (y = bpow (fexp ey))%R.\napply Rminus_diag_uniq.\nrewrite Hy3.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq.\ncontradict Hy2.\nrewrite H1.\napply f_equal.\napply Zplus_reg_l with 1%Z.\nring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) : (0 <= pred y)%R.","proofString":"apply pred_ge_0 ; trivial."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (Zp : (0 <= pred y)%R) : (0 < pred y)%R.","proofString":"destruct Zp; trivial.\ngeneralize H0.\nrewrite pred_eq_pos;[idtac|now left].\nunfold pred_pos.\ndestruct (mag beta y) as (ey,Hey); simpl.\ncase Req_bool_spec; intros Hy2.\nintros Hy3.\nassert (ey-1 = fexp (ey -1))%Z.\napply bpow_inj with beta.\nrewrite <- Hy2, <- Rplus_0_l, Hy3.\nring.\nassert (Zx: (x <> 0)%R).\nnow apply Rgt_not_eq.\ndestruct (mag beta x) as (ex,Hex).\nspecialize (Hex Zx).\nassert (ex <= ey)%Z.\napply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq.\ncase (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge.\nintros Hy3.\nassert (y = bpow (fexp ey))%R.\napply Rminus_diag_uniq.\nrewrite Hy3.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq.\ncontradict Hy2.\nrewrite H1.\napply f_equal.\napply Zplus_reg_l with 1%Z.\nring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) : (0 < pred y)%R.","proofString":"generalize H0.\nrewrite pred_eq_pos;[idtac|now left].\nunfold pred_pos.\ndestruct (mag beta y) as (ey,Hey); simpl.\ncase Req_bool_spec; intros Hy2.\nintros Hy3.\nassert (ey-1 = fexp (ey -1))%Z.\napply bpow_inj with beta.\nrewrite <- Hy2, <- Rplus_0_l, Hy3.\nring.\nassert (Zx: (x <> 0)%R).\nnow apply Rgt_not_eq.\ndestruct (mag beta x) as (ex,Hex).\nspecialize (Hex Zx).\nassert (ex <= ey)%Z.\napply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq.\ncase (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge.\nintros Hy3.\nassert (y = bpow (fexp ey))%R.\napply Rminus_diag_uniq.\nrewrite Hy3.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq.\ncontradict Hy2.\nrewrite H1.\napply f_equal.\napply Zplus_reg_l with 1%Z.\nring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) : 0%R = pred y -> (0 < pred y)%R.","proofString":"rewrite pred_eq_pos;[idtac|now left].\nunfold pred_pos.\ndestruct (mag beta y) as (ey,Hey); simpl.\ncase Req_bool_spec; intros Hy2.\nintros Hy3.\nassert (ey-1 = fexp (ey -1))%Z.\napply bpow_inj with beta.\nrewrite <- Hy2, <- Rplus_0_l, Hy3.\nring.\nassert (Zx: (x <> 0)%R).\nnow apply Rgt_not_eq.\ndestruct (mag beta x) as (ex,Hex).\nspecialize (Hex Zx).\nassert (ex <= ey)%Z.\napply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq.\ncase (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge.\nintros Hy3.\nassert (y = bpow (fexp ey))%R.\napply Rminus_diag_uniq.\nrewrite Hy3.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq.\ncontradict Hy2.\nrewrite H1.\napply f_equal.\napply Zplus_reg_l with 1%Z.\nring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) : 0%R = pred_pos y -> (0 < pred_pos y)%R.","proofString":"unfold pred_pos.\ndestruct (mag beta y) as (ey,Hey); simpl.\ncase Req_bool_spec; intros Hy2.\nintros Hy3.\nassert (ey-1 = fexp (ey -1))%Z.\napply bpow_inj with beta.\nrewrite <- Hy2, <- Rplus_0_l, Hy3.\nring.\nassert (Zx: (x <> 0)%R).\nnow apply Rgt_not_eq.\ndestruct (mag beta x) as (ex,Hex).\nspecialize (Hex Zx).\nassert (ex <= ey)%Z.\napply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq.\ncase (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge.\nintros Hy3.\nassert (y = bpow (fexp ey))%R.\napply Rminus_diag_uniq.\nrewrite Hy3.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq.\ncontradict Hy2.\nrewrite H1.\napply f_equal.\napply Zplus_reg_l with 1%Z.\nring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) : 0%R =\n(if Req_bool y (bpow (mag beta y - 1))\n then (y - bpow (fexp (mag beta y - 1)))%R\n else (y - ulp y)%R) ->\n(0 <\n (if Req_bool y (bpow (mag beta y - 1))\n  then y - bpow (fexp (mag beta y - 1))\n  else y - ulp y))%R.","proofString":"destruct (mag beta y) as (ey,Hey); simpl.\ncase Req_bool_spec; intros Hy2.\nintros Hy3.\nassert (ey-1 = fexp (ey -1))%Z.\napply bpow_inj with beta.\nrewrite <- Hy2, <- Rplus_0_l, Hy3.\nring.\nassert (Zx: (x <> 0)%R).\nnow apply Rgt_not_eq.\ndestruct (mag beta x) as (ex,Hex).\nspecialize (Hex Zx).\nassert (ex <= ey)%Z.\napply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq.\ncase (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge.\nintros Hy3.\nassert (y = bpow (fexp ey))%R.\napply Rminus_diag_uniq.\nrewrite Hy3.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq.\ncontradict Hy2.\nrewrite H1.\napply f_equal.\napply Zplus_reg_l with 1%Z.\nring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) : 0%R =\n(if Req_bool y (bpow (ey - 1))\n then (y - bpow (fexp (ey - 1)))%R\n else (y - ulp y)%R) ->\n(0 <\n (if Req_bool y (bpow (ey - 1)) then y - bpow (fexp (ey - 1)) else y - ulp y))%R.","proofString":"case Req_bool_spec; intros Hy2.\nintros Hy3.\nassert (ey-1 = fexp (ey -1))%Z.\napply bpow_inj with beta.\nrewrite <- Hy2, <- Rplus_0_l, Hy3.\nring.\nassert (Zx: (x <> 0)%R).\nnow apply Rgt_not_eq.\ndestruct (mag beta x) as (ex,Hex).\nspecialize (Hex Zx).\nassert (ex <= ey)%Z.\napply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq.\ncase (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge.\nintros Hy3.\nassert (y = bpow (fexp ey))%R.\napply Rminus_diag_uniq.\nrewrite Hy3.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq.\ncontradict Hy2.\nrewrite H1.\napply f_equal.\napply Zplus_reg_l with 1%Z.\nring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) : 0%R = (y - bpow (fexp (ey - 1)))%R -> (0 < y - bpow (fexp (ey - 1)))%R.","proofString":"intros Hy3.\nassert (ey-1 = fexp (ey -1))%Z.\napply bpow_inj with beta.\nrewrite <- Hy2, <- Rplus_0_l, Hy3.\nring.\nassert (Zx: (x <> 0)%R).\nnow apply Rgt_not_eq.\ndestruct (mag beta x) as (ex,Hex).\nspecialize (Hex Zx).\nassert (ex <= ey)%Z.\napply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq.\ncase (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) : (0 < y - bpow (fexp (ey - 1)))%R.","proofString":"assert (ey-1 = fexp (ey -1))%Z.\napply bpow_inj with beta.\nrewrite <- Hy2, <- Rplus_0_l, Hy3.\nring.\nassert (Zx: (x <> 0)%R).\nnow apply Rgt_not_eq.\ndestruct (mag beta x) as (ex,Hex).\nspecialize (Hex Zx).\nassert (ex <= ey)%Z.\napply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq.\ncase (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) : (ey - 1)%Z = fexp (ey - 1).","proofString":"apply bpow_inj with beta.\nrewrite <- Hy2, <- Rplus_0_l, Hy3.\nring."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) : bpow (ey - 1) = bpow (fexp (ey - 1)).","proofString":"rewrite <- Hy2, <- Rplus_0_l, Hy3.\nring."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) : y = (y - bpow (fexp (ey - 1)) + bpow (fexp (ey - 1)))%R.","proofString":"ring."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) : (0 < y - bpow (fexp (ey - 1)))%R.","proofString":"assert (Zx: (x <> 0)%R).\nnow apply Rgt_not_eq.\ndestruct (mag beta x) as (ex,Hex).\nspecialize (Hex Zx).\nassert (ex <= ey)%Z.\napply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq.\ncase (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) : x <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) : (0 < y - bpow (fexp (ey - 1)))%R.","proofString":"destruct (mag beta x) as (ex,Hex).\nspecialize (Hex Zx).\nassert (ex <= ey)%Z.\napply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq.\ncase (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : x <> 0%R -> (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 < y - bpow (fexp (ey - 1)))%R.","proofString":"specialize (Hex Zx).\nassert (ex <= ey)%Z.\napply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq.\ncase (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (0 < y - bpow (fexp (ey - 1)))%R.","proofString":"assert (ex <= ey)%Z.\napply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq.\ncase (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (ex <= ey)%Z.","proofString":"apply bpow_lt_bpow with beta.\napply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (bpow (ex - 1) < bpow ey)%R.","proofString":"apply Rle_lt_trans with (1:=proj1 Hex).\napply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (Rabs x < bpow ey)%R.","proofString":"apply Rlt_trans with (Rabs y).\nrewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (Rabs x < Rabs y)%R.","proofString":"rewrite 2!Rabs_right.\napply H.\nnow apply Rgt_ge.\nnow apply Rgt_ge."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (x < y)%R.","proofString":"apply H."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (y >= 0)%R.","proofString":"now apply Rgt_ge."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (x >= 0)%R.","proofString":"now apply Rgt_ge."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : (Rabs y < bpow ey)%R.","proofString":"apply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) : y <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) : (0 < y - bpow (fexp (ey - 1)))%R.","proofString":"case (Zle_lt_or_eq _ _ H2); intros Hexy.\nassert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex.\nabsurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) : (0 < y - bpow (fexp (ey - 1)))%R.","proofString":"assert (fexp ex = fexp (ey-1))%Z.\napply valid_exp.\nlia.\nrewrite <- H1.\nlia.\nabsurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) : fexp ex = fexp (ey - 1).","proofString":"apply valid_exp.\nlia.\nrewrite <- H1.\nlia."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) : (ey - 1 <= fexp (ey - 1))%Z.","proofString":"lia."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) : (ex <= fexp (ey - 1))%Z.","proofString":"rewrite <- H1.\nlia."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) : (ex <= ey - 1)%Z.","proofString":"lia."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : (0 < y - bpow (fexp (ey - 1)))%R.","proofString":"absurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.\nlia.\nsplit.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : ~ (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.","proofString":"lia."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.","proofString":"split.\napply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx.\napply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : (0 < Ztrunc (scaled_mantissa beta fexp x))%Z.","proofString":"apply gt_0_F2R with beta (cexp beta fexp x).\nnow rewrite <- Fx."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : (Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.","proofString":"apply lt_IZR.\napply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : (IZR (Ztrunc (scaled_mantissa beta fexp x)) < 1)%R.","proofString":"apply Rmult_lt_reg_r with (bpow (cexp beta fexp x)).\napply bpow_gt_0.\nreplace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : (0 < bpow (cexp beta fexp x))%R.","proofString":"apply bpow_gt_0."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : (IZR (Ztrunc (scaled_mantissa beta fexp x)) * bpow (cexp beta fexp x) <\n 1 * bpow (cexp beta fexp x))%R.","proofString":"replace (IZR (Ztrunc (scaled_mantissa beta fexp x)) *  bpow (cexp beta fexp x))%R with x.\nrewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : (x < 1 * bpow (cexp beta fexp x))%R.","proofString":"rewrite Rmult_1_l.\nunfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : (x < bpow (cexp beta fexp x))%R.","proofString":"unfold cexp.\nrewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : (x < bpow (fexp (mag beta x)))%R.","proofString":"rewrite mag_unique with beta x ex.\nrewrite H3,<-H1, <- Hy2.\napply H.\nexact Hex."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : (x < bpow (fexp ex))%R.","proofString":"rewrite H3,<-H1, <- Hy2.\napply H."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : (x < y)%R.","proofString":"apply H."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : (ex < ey)%Z) (H3 : fexp ex = fexp (ey - 1)) : (bpow (ex - 1) <= Rabs x < bpow ex)%R.","proofString":"exact Hex."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : ex = ey) : (0 < y - bpow (fexp (ey - 1)))%R.","proofString":"absurd (y <= x)%R.\nnow apply Rlt_not_le.\nrewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : ex = ey) : ~ (y <= x)%R.","proofString":"now apply Rlt_not_le."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : ex = ey) : (y <= x)%R.","proofString":"rewrite Rabs_right in Hex.\napply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl.\nnow apply Rgt_ge."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : ex = ey) : (y <= x)%R.","proofString":"apply Rle_trans with (2:=proj1 Hex).\nrewrite Hexy, Hy2.\nnow apply Rle_refl."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : ex = ey) : (y <= bpow (ex - 1))%R.","proofString":"rewrite Hexy, Hy2.\nnow apply Rle_refl."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : ex = ey) : (bpow (ey - 1) <= bpow (ey - 1))%R.","proofString":"now apply Rle_refl."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y = bpow (ey - 1)) (Hy3 : 0%R = (y - bpow (fexp (ey - 1)))%R) (H1 : (ey - 1)%Z = fexp (ey - 1)) (Zx : x <> 0%R) (ex : Z) (Hex : (bpow (ex - 1) <= Rabs x < bpow ex)%R) (H2 : (ex <= ey)%Z) (Hexy : ex = ey) : (x >= 0)%R.","proofString":"now apply Rgt_ge."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y <> bpow (ey - 1)) : 0%R = (y - ulp y)%R -> (0 < y - ulp y)%R.","proofString":"intros Hy3.\nassert (y = bpow (fexp ey))%R.\napply Rminus_diag_uniq.\nrewrite Hy3.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq.\ncontradict Hy2.\nrewrite H1.\napply f_equal.\napply Zplus_reg_l with 1%Z.\nring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y <> bpow (ey - 1)) (Hy3 : 0%R = (y - ulp y)%R) : (0 < y - ulp y)%R.","proofString":"assert (y = bpow (fexp ey))%R.\napply Rminus_diag_uniq.\nrewrite Hy3.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq.\ncontradict Hy2.\nrewrite H1.\napply f_equal.\napply Zplus_reg_l with 1%Z.\nring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y <> bpow (ey - 1)) (Hy3 : 0%R = (y - ulp y)%R) : y = bpow (fexp ey).","proofString":"apply Rminus_diag_uniq.\nrewrite Hy3.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y <> bpow (ey - 1)) (Hy3 : 0%R = (y - ulp y)%R) : (y - bpow (fexp ey))%R = 0%R.","proofString":"rewrite Hy3.\nrewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y <> bpow (ey - 1)) (Hy3 : 0%R = (y - ulp y)%R) : (y - bpow (fexp ey))%R = (y - ulp y)%R.","proofString":"rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].\nunfold cexp.\nrewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y <> bpow (ey - 1)) (Hy3 : 0%R = (y - ulp y)%R) : (y - bpow (fexp ey))%R = (y - bpow (cexp beta fexp y))%R.","proofString":"unfold cexp.\nrewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y <> bpow (ey - 1)) (Hy3 : 0%R = (y - ulp y)%R) : (y - bpow (fexp ey))%R = (y - bpow (fexp (mag beta y)))%R.","proofString":"rewrite (mag_unique beta y ey); trivial.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y <> bpow (ey - 1)) (Hy3 : 0%R = (y - ulp y)%R) : (bpow (ey - 1) <= Rabs y < bpow ey)%R.","proofString":"apply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y <> bpow (ey - 1)) (Hy3 : 0%R = (y - ulp y)%R) : y <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy2 : y <> bpow (ey - 1)) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : (0 < y - ulp y)%R.","proofString":"contradict Hy2.\nrewrite H1.\napply f_equal.\napply Zplus_reg_l with 1%Z.\nring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : y = bpow (ey - 1).","proofString":"rewrite H1.\napply f_equal.\napply Zplus_reg_l with 1%Z.\nring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : bpow (fexp ey) = bpow (ey - 1).","proofString":"apply f_equal.\napply Zplus_reg_l with 1%Z.\nring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : fexp ey = (ey - 1)%Z.","proofString":"apply Zplus_reg_l with 1%Z.\nring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : (1 + fexp ey)%Z = (1 + (ey - 1))%Z.","proofString":"ring_simplify.\napply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : (fexp ey + 1)%Z = ey.","proofString":"apply trans_eq with (mag beta y).\napply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0.\napply mag_unique.\napply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : (fexp ey + 1)%Z = mag beta y.","proofString":"apply sym_eq; apply mag_unique.\nrewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : (bpow (fexp ey + 1 - 1) <= Rabs y < bpow (fexp ey + 1))%R.","proofString":"rewrite H1, Rabs_right.\nsplit.\napply bpow_le.\nlia.\napply bpow_lt.\nlia.\napply Rle_ge; apply bpow_ge_0."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : (bpow (fexp ey + 1 - 1) <= bpow (fexp ey) < bpow (fexp ey + 1))%R.","proofString":"split.\napply bpow_le.\nlia.\napply bpow_lt.\nlia."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : (bpow (fexp ey + 1 - 1) <= bpow (fexp ey))%R.","proofString":"apply bpow_le.\nlia."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : (fexp ey + 1 - 1 <= fexp ey)%Z.","proofString":"lia."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : (bpow (fexp ey) < bpow (fexp ey + 1))%R.","proofString":"apply bpow_lt.\nlia."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : (fexp ey < fexp ey + 1)%Z.","proofString":"lia."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : (bpow (fexp ey) >= 0)%R.","proofString":"apply Rle_ge; apply bpow_ge_0."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : (bpow (ey - 1) <= Rabs y < bpow ey)%R.","proofString":"apply Hey.\nnow apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (H0 : 0%R = pred y) (ey : Z) (Hey : y <> 0%R -> (bpow (ey - 1) <= Rabs y < bpow ey)%R) (Hy3 : 0%R = (y - ulp y)%R) (H1 : y = bpow (fexp ey)) : y <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (Zp : (0 < pred y)%R) (H1 : (ulp (pred_pos y) <= y - x)%R) : (x <= pred_pos y)%R.","proofString":"apply Rplus_le_reg_r with (-x + ulp (pred_pos y))%R.\nring_simplify (x+(-x+ulp (pred_pos y)))%R.\napply Rle_trans with (1:=H1).\nrewrite <- (pred_pos_plus_ulp y) at 1; trivial.\napply Req_le; ring."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (Zp : (0 < pred y)%R) (H1 : (ulp (pred_pos y) <= y - x)%R) : (x + (- x + ulp (pred_pos y)) <= pred_pos y + (- x + ulp (pred_pos y)))%R.","proofString":"ring_simplify (x+(-x+ulp (pred_pos y)))%R.\napply Rle_trans with (1:=H1).\nrewrite <- (pred_pos_plus_ulp y) at 1; trivial.\napply Req_le; ring."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (Zp : (0 < pred y)%R) (H1 : (ulp (pred_pos y) <= y - x)%R) : (ulp (pred_pos y) <= pred_pos y + (- x + ulp (pred_pos y)))%R.","proofString":"apply Rle_trans with (1:=H1).\nrewrite <- (pred_pos_plus_ulp y) at 1; trivial.\napply Req_le; ring."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (Zp : (0 < pred y)%R) (H1 : (ulp (pred_pos y) <= y - x)%R) : (y - x <= pred_pos y + (- x + ulp (pred_pos y)))%R.","proofString":"rewrite <- (pred_pos_plus_ulp y) at 1; trivial.\napply Req_le; ring."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (Zp : (0 < pred y)%R) (H1 : (ulp (pred_pos y) <= y - x)%R) : (pred_pos y + ulp (pred_pos y) - x <= pred_pos y + (- x + ulp (pred_pos y)))%R.","proofString":"apply Req_le; ring."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (Zp : (0 < pred y)%R) (H1 : (y - x < ulp (pred_pos y))%R) : (0 < y - x <= ulp (pred y))%R.","proofString":"split; trivial.\nnow apply Rlt_Rminus.\nrewrite pred_eq_pos;[idtac|now left].\nnow apply Rlt_le."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (Zp : (0 < pred y)%R) (H1 : (y - x < ulp (pred_pos y))%R) : (0 < y - x)%R.","proofString":"now apply Rlt_Rminus."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (Zp : (0 < pred y)%R) (H1 : (y - x < ulp (pred_pos y))%R) : (y - x <= ulp (pred y))%R.","proofString":"rewrite pred_eq_pos;[idtac|now left].\nnow apply Rlt_le."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : (0 < x)%R) (Zy : (0 < y)%R) (Zp : (0 < pred y)%R) (H1 : (y - x < ulp (pred_pos y))%R) : (y - x <= ulp (pred_pos y))%R.","proofString":"now apply Rlt_le."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : 0%R = x) : (x <= pred_pos y)%R.","proofString":"rewrite <- V; apply pred_pos_ge_0; trivial.\napply Rle_lt_trans with (1:=proj1 H); apply H."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (0 <= x < y)%R) (V : 0%R = x) : (0 < y)%R.","proofString":"apply Rle_lt_trans with (1:=proj1 H); apply H."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) : (succ x <= y)%R.","proofString":"destruct (Rle_or_lt 0 x) as [Hx|Hx].\nnow apply succ_le_lt_aux.\nunfold succ; rewrite Rle_bool_false; try assumption.\ncase (Rle_or_lt y 0); intros Hy.\nrewrite <- (Ropp_involutive y).\napply Ropp_le_contravar.\napply le_pred_pos_lt.\nnow apply generic_format_opp.\nnow apply generic_format_opp.\nsplit.\nrewrite <- Ropp_0; now apply Ropp_le_contravar.\nnow apply Ropp_lt_contravar.\napply Rle_trans with (-0)%R.\napply Ropp_le_contravar.\napply pred_pos_ge_0.\nrewrite <- Ropp_0; now apply Ropp_lt_contravar.\nnow apply generic_format_opp.\nrewrite Ropp_0; now left."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (0 <= x)%R) : (succ x <= y)%R.","proofString":"now apply succ_le_lt_aux."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) : (succ x <= y)%R.","proofString":"unfold succ; rewrite Rle_bool_false; try assumption.\ncase (Rle_or_lt y 0); intros Hy.\nrewrite <- (Ropp_involutive y).\napply Ropp_le_contravar.\napply le_pred_pos_lt.\nnow apply generic_format_opp.\nnow apply generic_format_opp.\nsplit.\nrewrite <- Ropp_0; now apply Ropp_le_contravar.\nnow apply Ropp_lt_contravar.\napply Rle_trans with (-0)%R.\napply Ropp_le_contravar.\napply pred_pos_ge_0.\nrewrite <- Ropp_0; now apply Ropp_lt_contravar.\nnow apply generic_format_opp.\nrewrite Ropp_0; now left."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) : (- pred_pos (- x) <= y)%R.","proofString":"case (Rle_or_lt y 0); intros Hy.\nrewrite <- (Ropp_involutive y).\napply Ropp_le_contravar.\napply le_pred_pos_lt.\nnow apply generic_format_opp.\nnow apply generic_format_opp.\nsplit.\nrewrite <- Ropp_0; now apply Ropp_le_contravar.\nnow apply Ropp_lt_contravar.\napply Rle_trans with (-0)%R.\napply Ropp_le_contravar.\napply pred_pos_ge_0.\nrewrite <- Ropp_0; now apply Ropp_lt_contravar.\nnow apply generic_format_opp.\nrewrite Ropp_0; now left."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (y <= 0)%R) : (- pred_pos (- x) <= y)%R.","proofString":"rewrite <- (Ropp_involutive y).\napply Ropp_le_contravar.\napply le_pred_pos_lt.\nnow apply generic_format_opp.\nnow apply generic_format_opp.\nsplit.\nrewrite <- Ropp_0; now apply Ropp_le_contravar.\nnow apply Ropp_lt_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (y <= 0)%R) : (- pred_pos (- x) <= - - y)%R.","proofString":"apply Ropp_le_contravar.\napply le_pred_pos_lt.\nnow apply generic_format_opp.\nnow apply generic_format_opp.\nsplit.\nrewrite <- Ropp_0; now apply Ropp_le_contravar.\nnow apply Ropp_lt_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (y <= 0)%R) : (- y <= pred_pos (- x))%R.","proofString":"apply le_pred_pos_lt.\nnow apply generic_format_opp.\nnow apply generic_format_opp.\nsplit.\nrewrite <- Ropp_0; now apply Ropp_le_contravar.\nnow apply Ropp_lt_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (y <= 0)%R) : F (- y).","proofString":"now apply generic_format_opp."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (y <= 0)%R) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (y <= 0)%R) : (0 <= - y < - x)%R.","proofString":"split.\nrewrite <- Ropp_0; now apply Ropp_le_contravar.\nnow apply Ropp_lt_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (y <= 0)%R) : (0 <= - y)%R.","proofString":"rewrite <- Ropp_0; now apply Ropp_le_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (y <= 0)%R) : (- y < - x)%R.","proofString":"now apply Ropp_lt_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (0 < y)%R) : (- pred_pos (- x) <= y)%R.","proofString":"apply Rle_trans with (-0)%R.\napply Ropp_le_contravar.\napply pred_pos_ge_0.\nrewrite <- Ropp_0; now apply Ropp_lt_contravar.\nnow apply generic_format_opp.\nrewrite Ropp_0; now left."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (0 < y)%R) : (- pred_pos (- x) <= - 0)%R.","proofString":"apply Ropp_le_contravar.\napply pred_pos_ge_0.\nrewrite <- Ropp_0; now apply Ropp_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (0 < y)%R) : (0 <= pred_pos (- x))%R.","proofString":"apply pred_pos_ge_0.\nrewrite <- Ropp_0; now apply Ropp_lt_contravar.\nnow apply generic_format_opp."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (0 < y)%R) : (0 < - x)%R.","proofString":"rewrite <- Ropp_0; now apply Ropp_lt_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (0 < y)%R) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (H : (x < y)%R) (Hx : (x < 0)%R) (Hy : (0 < y)%R) : (- 0 <= y)%R.","proofString":"rewrite Ropp_0; now left."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) : (x <= pred y)%R.","proofString":"rewrite <- (Ropp_involutive x).\nunfold pred; apply Ropp_le_contravar.\napply succ_le_lt.\nnow apply generic_format_opp.\nnow apply generic_format_opp.\nnow apply Ropp_lt_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) : (- - x <= pred y)%R.","proofString":"unfold pred; apply Ropp_le_contravar.\napply succ_le_lt.\nnow apply generic_format_opp.\nnow apply generic_format_opp.\nnow apply Ropp_lt_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) : (succ (- y) <= - x)%R.","proofString":"apply succ_le_lt.\nnow apply generic_format_opp.\nnow apply generic_format_opp.\nnow apply Ropp_lt_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) : F (- y).","proofString":"now apply generic_format_opp."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) : (- y < - x)%R.","proofString":"now apply Ropp_lt_contravar."},{"statement":"(x y : R) (Zy : y <> 0%R) (Hxy : (x <= y)%R) : (x < succ y)%R.","proofString":"apply Rle_lt_trans with (1 := Hxy).\nnow apply succ_gt_id."},{"statement":"(x y : R) (Zy : y <> 0%R) (Hxy : (x <= y)%R) : (y < succ y)%R.","proofString":"now apply succ_gt_id."},{"statement":"(x y : R) (Zy : x <> 0%R) (Hxy : (x <= y)%R) : (pred x < y)%R.","proofString":"apply Rlt_le_trans with (2 := Hxy).\nnow apply pred_lt_id."},{"statement":"(x y : R) (Zy : x <> 0%R) (Hxy : (x <= y)%R) : (pred x < x)%R.","proofString":"now apply pred_lt_id."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : succ (pred x) = x.","proofString":"rewrite pred_eq_pos by now left.\nrewrite succ_eq_pos by now apply pred_pos_ge_0.\nnow apply pred_pos_plus_ulp."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : succ (pred_pos x) = x.","proofString":"rewrite succ_eq_pos by now apply pred_pos_ge_0.\nnow apply pred_pos_plus_ulp."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : (pred_pos x + ulp (pred_pos x))%R = x.","proofString":"now apply pred_pos_plus_ulp."},{"statement":"(if Rle_bool 0 0 then (0 + ulp 0)%R else (- pred_pos (- 0))%R) = ulp 0.","proofString":"rewrite Rle_bool_true.\napply Rplus_0_l.\napply Rle_refl."},{"statement":"(0 + ulp 0)%R = ulp 0.","proofString":"apply Rplus_0_l."},{"statement":"(0 <= 0)%R.","proofString":"apply Rle_refl."},{"statement":"pred 0 = (- succ 0)%R.","proofString":"rewrite <- Ropp_0 at 1.\napply pred_opp."},{"statement":"pred (- 0) = (- succ 0)%R.","proofString":"apply pred_opp."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : pred (succ x) = x.","proofString":"apply Rle_antisym.\napply Rnot_lt_le.\nintros H.\napply succ_le_lt with (1 := Fx) in H.\nrevert H.\napply Rlt_not_le.\napply pred_lt_id.\napply Rgt_not_eq.\napply Rlt_le_trans with (1 := Hx).\napply succ_ge_id.\nnow apply generic_format_pred, generic_format_succ.\napply pred_ge_gt with (1 := Fx).\nnow apply generic_format_succ.\napply succ_gt_id.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : (pred (succ x) <= x)%R.","proofString":"apply Rnot_lt_le.\nintros H.\napply succ_le_lt with (1 := Fx) in H.\nrevert H.\napply Rlt_not_le.\napply pred_lt_id.\napply Rgt_not_eq.\napply Rlt_le_trans with (1 := Hx).\napply succ_ge_id.\nnow apply generic_format_pred, generic_format_succ."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : ~ (x < pred (succ x))%R.","proofString":"intros H.\napply succ_le_lt with (1 := Fx) in H.\nrevert H.\napply Rlt_not_le.\napply pred_lt_id.\napply Rgt_not_eq.\napply Rlt_le_trans with (1 := Hx).\napply succ_ge_id.\nnow apply generic_format_pred, generic_format_succ."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) (H : (x < pred (succ x))%R) : False.","proofString":"apply succ_le_lt with (1 := Fx) in H.\nrevert H.\napply Rlt_not_le.\napply pred_lt_id.\napply Rgt_not_eq.\napply Rlt_le_trans with (1 := Hx).\napply succ_ge_id.\nnow apply generic_format_pred, generic_format_succ."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) (H : (succ x <= pred (succ x))%R) : False.","proofString":"revert H.\napply Rlt_not_le.\napply pred_lt_id.\napply Rgt_not_eq.\napply Rlt_le_trans with (1 := Hx).\napply succ_ge_id."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : (succ x <= pred (succ x))%R -> False.","proofString":"apply Rlt_not_le.\napply pred_lt_id.\napply Rgt_not_eq.\napply Rlt_le_trans with (1 := Hx).\napply succ_ge_id."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : (pred (succ x) < succ x)%R.","proofString":"apply pred_lt_id.\napply Rgt_not_eq.\napply Rlt_le_trans with (1 := Hx).\napply succ_ge_id."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : succ x <> 0%R.","proofString":"apply Rgt_not_eq.\napply Rlt_le_trans with (1 := Hx).\napply succ_ge_id."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : (succ x > 0)%R.","proofString":"apply Rlt_le_trans with (1 := Hx).\napply succ_ge_id."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : (x <= succ x)%R.","proofString":"apply succ_ge_id."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) (H : (x < pred (succ x))%R) : F (pred (succ x)).","proofString":"now apply generic_format_pred, generic_format_succ."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : (x <= pred (succ x))%R.","proofString":"apply pred_ge_gt with (1 := Fx).\nnow apply generic_format_succ.\napply succ_gt_id.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : F (succ x).","proofString":"now apply generic_format_succ."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : (x < succ x)%R.","proofString":"apply succ_gt_id.\nnow apply Rgt_not_eq."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : x <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(x : R) (Fx : F x) : succ (pred x) = x.","proofString":"destruct (Rle_or_lt 0 x) as [[Hx|Hx]|Hx].\nnow apply succ_pred_pos.\nrewrite <- Hx.\nrewrite pred_0, succ_opp, pred_ulp_0.\napply Ropp_0.\nunfold pred.\nrewrite succ_opp, pred_succ_pos.\napply Ropp_involutive.\nnow apply generic_format_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) (Hx : (0 < x)%R) : succ (pred x) = x.","proofString":"now apply succ_pred_pos."},{"statement":"(x : R) (Fx : F x) (Hx : 0%R = x) : succ (pred x) = x.","proofString":"rewrite <- Hx.\nrewrite pred_0, succ_opp, pred_ulp_0.\napply Ropp_0."},{"statement":"(x : R) (Fx : F x) (Hx : 0%R = x) : succ (pred 0) = 0%R.","proofString":"rewrite pred_0, succ_opp, pred_ulp_0.\napply Ropp_0."},{"statement":"(x : R) (Fx : F x) (Hx : 0%R = x) : (- 0)%R = 0%R.","proofString":"apply Ropp_0."},{"statement":"(x : R) (Fx : F x) (Hx : (x < 0)%R) : succ (pred x) = x.","proofString":"unfold pred.\nrewrite succ_opp, pred_succ_pos.\napply Ropp_involutive.\nnow apply generic_format_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) (Hx : (x < 0)%R) : succ (- succ (- x)) = x.","proofString":"rewrite succ_opp, pred_succ_pos.\napply Ropp_involutive.\nnow apply generic_format_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) (Hx : (x < 0)%R) : (- - x)%R = x.","proofString":"apply Ropp_involutive."},{"statement":"(x : R) (Fx : F x) (Hx : (x < 0)%R) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (Hx : (x < 0)%R) : (0 < - x)%R.","proofString":"now apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) : pred (succ x) = x.","proofString":"rewrite <- (Ropp_involutive x).\nrewrite succ_opp, pred_opp.\napply f_equal, succ_pred.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) : pred (succ (- - x)) = (- - x)%R.","proofString":"rewrite succ_opp, pred_opp.\napply f_equal, succ_pred.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) : (- succ (pred (- x)))%R = (- - x)%R.","proofString":"apply f_equal, succ_pred.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : round beta fexp Zceil (pred x + eps) = x.","proofString":"rewrite round_UP_plus_eps.\nnow apply succ_pred.\nnow apply generic_format_pred.\nunfold pred at 4.\nrewrite Ropp_involutive, pred_succ.\nrewrite ulp_opp.\ngeneralize Heps; case (Rle_bool_spec x 0); intros H1 H2.\nrewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (2:=H1).\napply pred_lt_id.\nnow apply Rlt_not_eq.\nrewrite H1'; unfold pred, succ.\nrewrite Ropp_0; rewrite Rle_bool_true;[idtac|now right].\nrewrite Rplus_0_l.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\napply Rlt_le_trans with (1:=proj1 H2).\napply Rle_trans with (1:=proj2 H2).\nrewrite Ropp_0, H1'.\nnow right.\nrewrite Rle_bool_true; trivial.\nnow apply pred_ge_0.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : succ (pred x) = x.","proofString":"now apply succ_pred."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : F (pred x).","proofString":"now apply generic_format_pred."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : (0 < eps <=\n (if Rle_bool 0 (pred x) then ulp (pred x) else ulp (pred (- pred x))))%R.","proofString":"unfold pred at 4.\nrewrite Ropp_involutive, pred_succ.\nrewrite ulp_opp.\ngeneralize Heps; case (Rle_bool_spec x 0); intros H1 H2.\nrewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (2:=H1).\napply pred_lt_id.\nnow apply Rlt_not_eq.\nrewrite H1'; unfold pred, succ.\nrewrite Ropp_0; rewrite Rle_bool_true;[idtac|now right].\nrewrite Rplus_0_l.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\napply Rlt_le_trans with (1:=proj1 H2).\napply Rle_trans with (1:=proj2 H2).\nrewrite Ropp_0, H1'.\nnow right.\nrewrite Rle_bool_true; trivial.\nnow apply pred_ge_0.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : (0 < eps <=\n (if Rle_bool 0 (pred x) then ulp (pred x) else ulp (pred (- - succ (- x)))))%R.","proofString":"rewrite Ropp_involutive, pred_succ.\nrewrite ulp_opp.\ngeneralize Heps; case (Rle_bool_spec x 0); intros H1 H2.\nrewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (2:=H1).\napply pred_lt_id.\nnow apply Rlt_not_eq.\nrewrite H1'; unfold pred, succ.\nrewrite Ropp_0; rewrite Rle_bool_true;[idtac|now right].\nrewrite Rplus_0_l.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\napply Rlt_le_trans with (1:=proj1 H2).\napply Rle_trans with (1:=proj2 H2).\nrewrite Ropp_0, H1'.\nnow right.\nrewrite Rle_bool_true; trivial.\nnow apply pred_ge_0.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : (0 < eps <= (if Rle_bool 0 (pred x) then ulp (pred x) else ulp (- x)))%R.","proofString":"rewrite ulp_opp.\ngeneralize Heps; case (Rle_bool_spec x 0); intros H1 H2.\nrewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (2:=H1).\napply pred_lt_id.\nnow apply Rlt_not_eq.\nrewrite H1'; unfold pred, succ.\nrewrite Ropp_0; rewrite Rle_bool_true;[idtac|now right].\nrewrite Rplus_0_l.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\napply Rlt_le_trans with (1:=proj1 H2).\napply Rle_trans with (1:=proj2 H2).\nrewrite Ropp_0, H1'.\nnow right.\nrewrite Rle_bool_true; trivial.\nnow apply pred_ge_0."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : (0 < eps <= (if Rle_bool 0 (pred x) then ulp (pred x) else ulp x))%R.","proofString":"generalize Heps; case (Rle_bool_spec x 0); intros H1 H2.\nrewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (2:=H1).\napply pred_lt_id.\nnow apply Rlt_not_eq.\nrewrite H1'; unfold pred, succ.\nrewrite Ropp_0; rewrite Rle_bool_true;[idtac|now right].\nrewrite Rplus_0_l.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\napply Rlt_le_trans with (1:=proj1 H2).\napply Rle_trans with (1:=proj2 H2).\nrewrite Ropp_0, H1'.\nnow right.\nrewrite Rle_bool_true; trivial.\nnow apply pred_ge_0."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) : (0 < eps <= (if Rle_bool 0 (pred x) then ulp (pred x) else ulp x))%R.","proofString":"rewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (2:=H1).\napply pred_lt_id.\nnow apply Rlt_not_eq.\nrewrite H1'; unfold pred, succ.\nrewrite Ropp_0; rewrite Rle_bool_true;[idtac|now right].\nrewrite Rplus_0_l.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\napply Rlt_le_trans with (1:=proj1 H2).\napply Rle_trans with (1:=proj2 H2).\nrewrite Ropp_0, H1'.\nnow right."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) : (pred x < 0)%R.","proofString":"case H1; intros H1'.\napply Rlt_le_trans with (2:=H1).\napply pred_lt_id.\nnow apply Rlt_not_eq.\nrewrite H1'; unfold pred, succ.\nrewrite Ropp_0; rewrite Rle_bool_true;[idtac|now right].\nrewrite Rplus_0_l.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\napply Rlt_le_trans with (1:=proj1 H2).\napply Rle_trans with (1:=proj2 H2).\nrewrite Ropp_0, H1'.\nnow right."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : (x < 0)%R) : (pred x < 0)%R.","proofString":"apply Rlt_le_trans with (2:=H1).\napply pred_lt_id.\nnow apply Rlt_not_eq."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : (x < 0)%R) : (pred x < x)%R.","proofString":"apply pred_lt_id.\nnow apply Rlt_not_eq."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : (x < 0)%R) : x <> 0%R.","proofString":"now apply Rlt_not_eq."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : x = 0%R) : (pred x < 0)%R.","proofString":"rewrite H1'; unfold pred, succ.\nrewrite Ropp_0; rewrite Rle_bool_true;[idtac|now right].\nrewrite Rplus_0_l.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\napply Rlt_le_trans with (1:=proj1 H2).\napply Rle_trans with (1:=proj2 H2).\nrewrite Ropp_0, H1'.\nnow right."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : x = 0%R) : (- (if Rle_bool 0 (- 0) then - 0 + ulp (- 0) else - pred_pos (- - 0)) < 0)%R.","proofString":"rewrite Ropp_0; rewrite Rle_bool_true;[idtac|now right].\nrewrite Rplus_0_l.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\napply Rlt_le_trans with (1:=proj1 H2).\napply Rle_trans with (1:=proj2 H2).\nrewrite Ropp_0, H1'.\nnow right."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : x = 0%R) : (- (0 + ulp 0) < 0)%R.","proofString":"rewrite Rplus_0_l.\nrewrite <- Ropp_0; apply Ropp_lt_contravar.\napply Rlt_le_trans with (1:=proj1 H2).\napply Rle_trans with (1:=proj2 H2).\nrewrite Ropp_0, H1'.\nnow right."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : x = 0%R) : (- ulp 0 < 0)%R.","proofString":"rewrite <- Ropp_0; apply Ropp_lt_contravar.\napply Rlt_le_trans with (1:=proj1 H2).\napply Rle_trans with (1:=proj2 H2).\nrewrite Ropp_0, H1'.\nnow right."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : x = 0%R) : (0 < ulp (- 0))%R.","proofString":"apply Rlt_le_trans with (1:=proj1 H2).\napply Rle_trans with (1:=proj2 H2).\nrewrite Ropp_0, H1'.\nnow right."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : x = 0%R) : (eps <= ulp (- 0))%R.","proofString":"apply Rle_trans with (1:=proj2 H2).\nrewrite Ropp_0, H1'.\nnow right."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : x = 0%R) : (ulp x <= ulp (- 0))%R.","proofString":"rewrite Ropp_0, H1'.\nnow right."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : x = 0%R) : (ulp 0 <= ulp 0)%R.","proofString":"now right."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (0 < x)%R) (H2 : (0 < eps <= ulp (pred x))%R) : (0 < eps <= (if Rle_bool 0 (pred x) then ulp (pred x) else ulp x))%R.","proofString":"rewrite Rle_bool_true; trivial.\nnow apply pred_ge_0."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (0 < x)%R) (H2 : (0 < eps <= ulp (pred x))%R) : (0 <= pred x)%R.","proofString":"now apply pred_ge_0."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : round beta fexp Zfloor (x - eps) = pred x.","proofString":"replace (x-eps)%R with (-(-x+eps))%R by ring.\nrewrite round_DN_opp.\nunfold pred; apply f_equal.\npattern (-x)%R at 1; rewrite <- (pred_succ (-x)).\napply round_UP_pred_plus_eps.\nnow apply generic_format_succ, generic_format_opp.\nrewrite pred_succ.\nrewrite ulp_opp.\ngeneralize Heps; case (Rle_bool_spec x 0); intros H1 H2.\nrewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (-x)%R.\nnow apply Ropp_0_gt_lt_contravar.\napply succ_ge_id.\nrewrite H1', Ropp_0, succ_eq_pos;[idtac|now right].\nrewrite Rplus_0_l.\napply Rlt_le_trans with (1:=proj1 H2).\nrewrite H1' in H2; apply H2.\nrewrite Rle_bool_true.\nnow rewrite succ_opp, ulp_opp.\nrewrite succ_opp.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nnow apply pred_ge_0.\nnow apply generic_format_opp.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : round beta fexp Zfloor (- (- x + eps)) = pred x.","proofString":"rewrite round_DN_opp.\nunfold pred; apply f_equal.\npattern (-x)%R at 1; rewrite <- (pred_succ (-x)).\napply round_UP_pred_plus_eps.\nnow apply generic_format_succ, generic_format_opp.\nrewrite pred_succ.\nrewrite ulp_opp.\ngeneralize Heps; case (Rle_bool_spec x 0); intros H1 H2.\nrewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (-x)%R.\nnow apply Ropp_0_gt_lt_contravar.\napply succ_ge_id.\nrewrite H1', Ropp_0, succ_eq_pos;[idtac|now right].\nrewrite Rplus_0_l.\napply Rlt_le_trans with (1:=proj1 H2).\nrewrite H1' in H2; apply H2.\nrewrite Rle_bool_true.\nnow rewrite succ_opp, ulp_opp.\nrewrite succ_opp.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nnow apply pred_ge_0.\nnow apply generic_format_opp.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : (- round beta fexp Zceil (- x + eps))%R = pred x.","proofString":"unfold pred; apply f_equal.\npattern (-x)%R at 1; rewrite <- (pred_succ (-x)).\napply round_UP_pred_plus_eps.\nnow apply generic_format_succ, generic_format_opp.\nrewrite pred_succ.\nrewrite ulp_opp.\ngeneralize Heps; case (Rle_bool_spec x 0); intros H1 H2.\nrewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (-x)%R.\nnow apply Ropp_0_gt_lt_contravar.\napply succ_ge_id.\nrewrite H1', Ropp_0, succ_eq_pos;[idtac|now right].\nrewrite Rplus_0_l.\napply Rlt_le_trans with (1:=proj1 H2).\nrewrite H1' in H2; apply H2.\nrewrite Rle_bool_true.\nnow rewrite succ_opp, ulp_opp.\nrewrite succ_opp.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nnow apply pred_ge_0.\nnow apply generic_format_opp.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : round beta fexp Zceil (- x + eps) = succ (- x).","proofString":"pattern (-x)%R at 1; rewrite <- (pred_succ (-x)).\napply round_UP_pred_plus_eps.\nnow apply generic_format_succ, generic_format_opp.\nrewrite pred_succ.\nrewrite ulp_opp.\ngeneralize Heps; case (Rle_bool_spec x 0); intros H1 H2.\nrewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (-x)%R.\nnow apply Ropp_0_gt_lt_contravar.\napply succ_ge_id.\nrewrite H1', Ropp_0, succ_eq_pos;[idtac|now right].\nrewrite Rplus_0_l.\napply Rlt_le_trans with (1:=proj1 H2).\nrewrite H1' in H2; apply H2.\nrewrite Rle_bool_true.\nnow rewrite succ_opp, ulp_opp.\nrewrite succ_opp.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nnow apply pred_ge_0.\nnow apply generic_format_opp.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : round beta fexp Zceil (pred (succ (- x)) + eps) = succ (- x).","proofString":"apply round_UP_pred_plus_eps.\nnow apply generic_format_succ, generic_format_opp.\nrewrite pred_succ.\nrewrite ulp_opp.\ngeneralize Heps; case (Rle_bool_spec x 0); intros H1 H2.\nrewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (-x)%R.\nnow apply Ropp_0_gt_lt_contravar.\napply succ_ge_id.\nrewrite H1', Ropp_0, succ_eq_pos;[idtac|now right].\nrewrite Rplus_0_l.\napply Rlt_le_trans with (1:=proj1 H2).\nrewrite H1' in H2; apply H2.\nrewrite Rle_bool_true.\nnow rewrite succ_opp, ulp_opp.\nrewrite succ_opp.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nnow apply pred_ge_0.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : F (succ (- x)).","proofString":"now apply generic_format_succ, generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : (0 < eps <=\n (if Rle_bool (succ (- x)) 0\n  then ulp (succ (- x))\n  else ulp (pred (succ (- x)))))%R.","proofString":"rewrite pred_succ.\nrewrite ulp_opp.\ngeneralize Heps; case (Rle_bool_spec x 0); intros H1 H2.\nrewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (-x)%R.\nnow apply Ropp_0_gt_lt_contravar.\napply succ_ge_id.\nrewrite H1', Ropp_0, succ_eq_pos;[idtac|now right].\nrewrite Rplus_0_l.\napply Rlt_le_trans with (1:=proj1 H2).\nrewrite H1' in H2; apply H2.\nrewrite Rle_bool_true.\nnow rewrite succ_opp, ulp_opp.\nrewrite succ_opp.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nnow apply pred_ge_0.\nnow apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : (0 < eps <= (if Rle_bool (succ (- x)) 0 then ulp (succ (- x)) else ulp (- x)))%R.","proofString":"rewrite ulp_opp.\ngeneralize Heps; case (Rle_bool_spec x 0); intros H1 H2.\nrewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (-x)%R.\nnow apply Ropp_0_gt_lt_contravar.\napply succ_ge_id.\nrewrite H1', Ropp_0, succ_eq_pos;[idtac|now right].\nrewrite Rplus_0_l.\napply Rlt_le_trans with (1:=proj1 H2).\nrewrite H1' in H2; apply H2.\nrewrite Rle_bool_true.\nnow rewrite succ_opp, ulp_opp.\nrewrite succ_opp.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nnow apply pred_ge_0."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : (0 < eps <= (if Rle_bool (succ (- x)) 0 then ulp (succ (- x)) else ulp x))%R.","proofString":"generalize Heps; case (Rle_bool_spec x 0); intros H1 H2.\nrewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (-x)%R.\nnow apply Ropp_0_gt_lt_contravar.\napply succ_ge_id.\nrewrite H1', Ropp_0, succ_eq_pos;[idtac|now right].\nrewrite Rplus_0_l.\napply Rlt_le_trans with (1:=proj1 H2).\nrewrite H1' in H2; apply H2.\nrewrite Rle_bool_true.\nnow rewrite succ_opp, ulp_opp.\nrewrite succ_opp.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nnow apply pred_ge_0."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) : (0 < eps <= (if Rle_bool (succ (- x)) 0 then ulp (succ (- x)) else ulp x))%R.","proofString":"rewrite Rle_bool_false; trivial.\ncase H1; intros H1'.\napply Rlt_le_trans with (-x)%R.\nnow apply Ropp_0_gt_lt_contravar.\napply succ_ge_id.\nrewrite H1', Ropp_0, succ_eq_pos;[idtac|now right].\nrewrite Rplus_0_l.\napply Rlt_le_trans with (1:=proj1 H2).\nrewrite H1' in H2; apply H2."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) : (0 < succ (- x))%R.","proofString":"case H1; intros H1'.\napply Rlt_le_trans with (-x)%R.\nnow apply Ropp_0_gt_lt_contravar.\napply succ_ge_id.\nrewrite H1', Ropp_0, succ_eq_pos;[idtac|now right].\nrewrite Rplus_0_l.\napply Rlt_le_trans with (1:=proj1 H2).\nrewrite H1' in H2; apply H2."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : (x < 0)%R) : (0 < succ (- x))%R.","proofString":"apply Rlt_le_trans with (-x)%R.\nnow apply Ropp_0_gt_lt_contravar.\napply succ_ge_id."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : (x < 0)%R) : (0 < - x)%R.","proofString":"now apply Ropp_0_gt_lt_contravar."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : (x < 0)%R) : (- x <= succ (- x))%R.","proofString":"apply succ_ge_id."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : x = 0%R) : (0 < succ (- x))%R.","proofString":"rewrite H1', Ropp_0, succ_eq_pos;[idtac|now right].\nrewrite Rplus_0_l.\napply Rlt_le_trans with (1:=proj1 H2).\nrewrite H1' in H2; apply H2."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : x = 0%R) : (0 < 0 + ulp 0)%R.","proofString":"rewrite Rplus_0_l.\napply Rlt_le_trans with (1:=proj1 H2).\nrewrite H1' in H2; apply H2."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : x = 0%R) : (0 < ulp 0)%R.","proofString":"apply Rlt_le_trans with (1:=proj1 H2).\nrewrite H1' in H2; apply H2."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (x <= 0)%R) (H2 : (0 < eps <= ulp x)%R) (H1' : x = 0%R) : (eps <= ulp 0)%R.","proofString":"rewrite H1' in H2; apply H2."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (0 < x)%R) (H2 : (0 < eps <= ulp (pred x))%R) : (0 < eps <= (if Rle_bool (succ (- x)) 0 then ulp (succ (- x)) else ulp x))%R.","proofString":"rewrite Rle_bool_true.\nnow rewrite succ_opp, ulp_opp.\nrewrite succ_opp.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nnow apply pred_ge_0."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (0 < x)%R) (H2 : (0 < eps <= ulp (pred x))%R) : (0 < eps <= ulp (succ (- x)))%R.","proofString":"now rewrite succ_opp, ulp_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (0 < x)%R) (H2 : (0 < eps <= ulp (pred x))%R) : (succ (- x) <= 0)%R.","proofString":"rewrite succ_opp.\nrewrite <- Ropp_0; apply Ropp_le_contravar.\nnow apply pred_ge_0."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (0 < x)%R) (H2 : (0 < eps <= ulp (pred x))%R) : (- pred x <= 0)%R.","proofString":"rewrite <- Ropp_0; apply Ropp_le_contravar.\nnow apply pred_ge_0."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) (H1 : (0 < x)%R) (H2 : (0 < eps <= ulp (pred x))%R) : (0 <= pred x)%R.","proofString":"now apply pred_ge_0."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x : R) (Fx : F x) (eps : R) (Heps : (0 < eps <= (if Rle_bool x 0 then ulp x else ulp (pred x)))%R) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (Hx : F x) : (Rabs (x - x) < ulp x)%R.","proofString":"unfold Rminus.\nrewrite Rplus_opp_r, Rabs_R0.\nrewrite ulp_neq_0; trivial.\napply bpow_gt_0."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (Hx : F x) : (Rabs (x + - x) < ulp x)%R.","proofString":"rewrite Rplus_opp_r, Rabs_R0.\nrewrite ulp_neq_0; trivial.\napply bpow_gt_0."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (Hx : F x) : (0 < ulp x)%R.","proofString":"rewrite ulp_neq_0; trivial.\napply bpow_gt_0."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (Hx : F x) : (0 < bpow (cexp beta fexp x))%R.","proofString":"apply bpow_gt_0."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (Hx : ~ F x) (Hu : (x < round beta fexp Zceil x)%R) : (x < round beta fexp Zceil x)%R.","proofString":"exact Hu."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (Hx : ~ F x) (Hd : (round beta fexp Zfloor x < x)%R) : (round beta fexp Zfloor x < x)%R.","proofString":"exact Hd."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : x = 0%R) : (Rabs (0 - 0) <= ulp 0)%R.","proofString":"unfold Rminus; rewrite Rplus_0_l, Ropp_0, Rabs_R0.\napply ulp_ge_0."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : x = 0%R) : (0 <= ulp 0)%R.","proofString":"apply ulp_ge_0."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) : x <> 0%R -> (Rabs (round beta fexp rnd x - x) <= ulp x)%R.","proofString":"intros Zx; left.\nnow apply error_lt_ulp."},{"statement":"(rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) : (Rabs (round beta fexp rnd x - x) < ulp x)%R.","proofString":"now apply error_lt_ulp."},{"statement":"(choice : Z -> bool) (x : R) (Hx : F x) : (Rabs (x - x) <= / 2 * ulp x)%R.","proofString":"unfold Rminus.\nrewrite Rplus_opp_r, Rabs_R0.\napply Rmult_le_pos.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply ulp_ge_0."},{"statement":"(choice : Z -> bool) (x : R) (Hx : F x) : (Rabs (x + - x) <= / 2 * ulp x)%R.","proofString":"rewrite Rplus_opp_r, Rabs_R0.\napply Rmult_le_pos.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply ulp_ge_0."},{"statement":"(choice : Z -> bool) (x : R) (Hx : F x) : (0 <= / 2 * ulp x)%R.","proofString":"apply Rmult_le_pos.\napply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt.\napply ulp_ge_0."},{"statement":"(choice : Z -> bool) (x : R) (Hx : F x) : (0 <= / 2)%R.","proofString":"apply Rlt_le.\napply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(choice : Z -> bool) (x : R) (Hx : F x) : (0 < / 2)%R.","proofString":"apply Rinv_0_lt_compat.\nnow apply IZR_lt."},{"statement":"(choice : Z -> bool) (x : R) (Hx : F x) : (0 < 2)%R.","proofString":"now apply IZR_lt."},{"statement":"(choice : Z -> bool) (x : R) (Hx : F x) : (0 <= ulp x)%R.","proofString":"apply ulp_ge_0."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) : (Rabs (round beta fexp (Znearest choice) x - x) <= / 2 * ulp x)%R.","proofString":"set (d := round beta fexp Zfloor x).\ndestruct (round_N_pt beta fexp choice x) as (Hr1, Hr2).\ndestruct (Rle_or_lt (x - d) (d + ulp x - x)) as [H|H].\napply Rle_trans with (Rabs (d - x)).\napply Hr2.\napply (round_DN_pt beta fexp x).\nrewrite Rabs_left1.\nrewrite Ropp_minus_distr.\napply Rmult_le_reg_r with 2%R.\nnow apply IZR_lt.\napply Rplus_le_reg_r with (d - x)%R.\nring_simplify.\napply Rle_trans with (1 := H).\nright.\nfield.\napply Rle_minus.\napply (round_DN_pt beta fexp x).\nassert (Hu: (d + ulp x)%R = round beta fexp Zceil x).\nunfold d.\nnow rewrite <- round_UP_DN_ulp.\napply Rle_trans with (Rabs (d + ulp x - x)).\napply Hr2.\nrewrite Hu.\napply (round_UP_pt beta fexp x).\nrewrite Rabs_pos_eq.\napply Rmult_le_reg_r with 2%R.\nnow apply IZR_lt.\napply Rplus_le_reg_r with (- (d + ulp x - x))%R.\nring_simplify.\napply Rlt_le.\napply Rlt_le_trans with (1 := H).\nright.\nfield.\napply Rle_0_minus.\nrewrite Hu.\napply (round_UP_pt beta fexp x)."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (x - d <= d + ulp x - x)%R) : (- (d - x) <= / 2 * ulp x)%R.","proofString":"rewrite Ropp_minus_distr.\napply Rmult_le_reg_r with 2%R.\nnow apply IZR_lt.\napply Rplus_le_reg_r with (d - x)%R.\nring_simplify.\napply Rle_trans with (1 := H).\nright.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (x - d <= d + ulp x - x)%R) : (x - d <= / 2 * ulp x)%R.","proofString":"apply Rmult_le_reg_r with 2%R.\nnow apply IZR_lt.\napply Rplus_le_reg_r with (d - x)%R.\nring_simplify.\napply Rle_trans with (1 := H).\nright.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (x - d <= d + ulp x - x)%R) : (0 < 2)%R.","proofString":"now apply IZR_lt."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (x - d <= d + ulp x - x)%R) : ((x - d) * 2 <= / 2 * ulp x * 2)%R.","proofString":"apply Rplus_le_reg_r with (d - x)%R.\nring_simplify.\napply Rle_trans with (1 := H).\nright.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (x - d <= d + ulp x - x)%R) : ((x - d) * 2 + (d - x) <= / 2 * ulp x * 2 + (d - x))%R.","proofString":"ring_simplify.\napply Rle_trans with (1 := H).\nright.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (x - d <= d + ulp x - x)%R) : (x - d <= - x + d + 2 * / 2 * ulp x)%R.","proofString":"apply Rle_trans with (1 := H).\nright.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (x - d <= d + ulp x - x)%R) : (d + ulp x - x <= - x + d + 2 * / 2 * ulp x)%R.","proofString":"right.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (x - d <= d + ulp x - x)%R) : (d + ulp x - x)%R = (- x + d + 2 * / 2 * ulp x)%R.","proofString":"field."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) : (round beta fexp Zfloor x + ulp x)%R = round beta fexp Zceil x.","proofString":"now rewrite <- round_UP_DN_ulp."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : (Rabs (round beta fexp (Znearest choice) x - x) <= / 2 * ulp x)%R.","proofString":"apply Rle_trans with (Rabs (d + ulp x - x)).\napply Hr2.\nrewrite Hu.\napply (round_UP_pt beta fexp x).\nrewrite Rabs_pos_eq.\napply Rmult_le_reg_r with 2%R.\nnow apply IZR_lt.\napply Rplus_le_reg_r with (- (d + ulp x - x))%R.\nring_simplify.\napply Rlt_le.\napply Rlt_le_trans with (1 := H).\nright.\nfield.\napply Rle_0_minus.\nrewrite Hu.\napply (round_UP_pt beta fexp x)."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (d + ulp x - x))%R.","proofString":"apply Hr2.\nrewrite Hu.\napply (round_UP_pt beta fexp x)."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : F (d + ulp x).","proofString":"rewrite Hu.\napply (round_UP_pt beta fexp x)."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : F (round beta fexp Zceil x).","proofString":"apply (round_UP_pt beta fexp x)."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : (Rabs (d + ulp x - x) <= / 2 * ulp x)%R.","proofString":"rewrite Rabs_pos_eq.\napply Rmult_le_reg_r with 2%R.\nnow apply IZR_lt.\napply Rplus_le_reg_r with (- (d + ulp x - x))%R.\nring_simplify.\napply Rlt_le.\napply Rlt_le_trans with (1 := H).\nright.\nfield.\napply Rle_0_minus.\nrewrite Hu.\napply (round_UP_pt beta fexp x)."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : (d + ulp x - x <= / 2 * ulp x)%R.","proofString":"apply Rmult_le_reg_r with 2%R.\nnow apply IZR_lt.\napply Rplus_le_reg_r with (- (d + ulp x - x))%R.\nring_simplify.\napply Rlt_le.\napply Rlt_le_trans with (1 := H).\nright.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : (0 < 2)%R.","proofString":"now apply IZR_lt."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : ((d + ulp x - x) * 2 <= / 2 * ulp x * 2)%R.","proofString":"apply Rplus_le_reg_r with (- (d + ulp x - x))%R.\nring_simplify.\napply Rlt_le.\napply Rlt_le_trans with (1 := H).\nright.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : ((d + ulp x - x) * 2 + - (d + ulp x - x) <=\n / 2 * ulp x * 2 + - (d + ulp x - x))%R.","proofString":"ring_simplify.\napply Rlt_le.\napply Rlt_le_trans with (1 := H).\nright.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : (d + ulp x - x <= - d + 2 * ulp x * / 2 - ulp x + x)%R.","proofString":"apply Rlt_le.\napply Rlt_le_trans with (1 := H).\nright.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : (d + ulp x - x < - d + 2 * ulp x * / 2 - ulp x + x)%R.","proofString":"apply Rlt_le_trans with (1 := H).\nright.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : (x - d <= - d + 2 * ulp x * / 2 - ulp x + x)%R.","proofString":"right.\nfield."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : (x - d)%R = (- d + 2 * ulp x * / 2 - ulp x + x)%R.","proofString":"field."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : (0 <= d + ulp x - x)%R.","proofString":"apply Rle_0_minus.\nrewrite Hu.\napply (round_UP_pt beta fexp x)."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : (x <= d + ulp x)%R.","proofString":"rewrite Hu.\napply (round_UP_pt beta fexp x)."},{"statement":"(choice : Z -> bool) (x : R) (Hx : ~ F x) (d : R) (Hr1 : F (round beta fexp (Znearest choice) x)) (Hr2 : forall g : R,\nF g -> (Rabs (round beta fexp (Znearest choice) x - x) <= Rabs (g - x))%R) (H : (d + ulp x - x < x - d)%R) (Hu : (d + ulp x)%R = round beta fexp Zceil x) : (x <= round beta fexp Zceil x)%R.","proofString":"apply (round_UP_pt beta fexp x)."},{"statement":"(x : R) (Hx : (0 < x)%R) : ulp (round beta fexp Zfloor x) = ulp x.","proofString":"rewrite (ulp_neq_0 x) by now apply Rgt_not_eq.\ndestruct (round_ge_generic beta fexp Zfloor 0 x) as [Hd|Hd].\napply generic_format_0.\nnow apply Rlt_le.\nrewrite ulp_neq_0 by now apply Rgt_not_eq.\nnow rewrite cexp_DN with (2 := Hd).\nrewrite <- Hd.\nunfold cexp.\ndestruct (mag beta x) as [e He].\nsimpl.\nspecialize (He (Rgt_not_eq _ _ Hx)).\napply sym_eq in Hd.\nassert (H := exp_small_round_0 _ _ _ _ _ He Hd).\nunfold ulp.\nrewrite Req_bool_true by easy.\ndestruct negligible_exp_spec as [H0|k Hk].\nnow elim Zlt_not_le with (1 := H0 e).\nnow apply f_equal, fexp_negligible_exp_eq."},{"statement":"(x : R) (Hx : (0 < x)%R) : ulp (round beta fexp Zfloor x) = bpow (cexp beta fexp x).","proofString":"destruct (round_ge_generic beta fexp Zfloor 0 x) as [Hd|Hd].\napply generic_format_0.\nnow apply Rlt_le.\nrewrite ulp_neq_0 by now apply Rgt_not_eq.\nnow rewrite cexp_DN with (2 := Hd).\nrewrite <- Hd.\nunfold cexp.\ndestruct (mag beta x) as [e He].\nsimpl.\nspecialize (He (Rgt_not_eq _ _ Hx)).\napply sym_eq in Hd.\nassert (H := exp_small_round_0 _ _ _ _ _ He Hd).\nunfold ulp.\nrewrite Req_bool_true by easy.\ndestruct negligible_exp_spec as [H0|k Hk].\nnow elim Zlt_not_le with (1 := H0 e).\nnow apply f_equal, fexp_negligible_exp_eq."},{"statement":"(x : R) (Hx : (0 < x)%R) : F 0.","proofString":"apply generic_format_0."},{"statement":"(x : R) (Hx : (0 < x)%R) : (0 <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : (0 < round beta fexp Zfloor x)%R) : ulp (round beta fexp Zfloor x) = bpow (cexp beta fexp x).","proofString":"rewrite ulp_neq_0 by now apply Rgt_not_eq.\nnow rewrite cexp_DN with (2 := Hd)."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : (0 < round beta fexp Zfloor x)%R) : bpow (cexp beta fexp (round beta fexp Zfloor x)) = bpow (cexp beta fexp x).","proofString":"now rewrite cexp_DN with (2 := Hd)."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : 0%R = round beta fexp Zfloor x) : ulp (round beta fexp Zfloor x) = bpow (cexp beta fexp x).","proofString":"rewrite <- Hd.\nunfold cexp.\ndestruct (mag beta x) as [e He].\nsimpl.\nspecialize (He (Rgt_not_eq _ _ Hx)).\napply sym_eq in Hd.\nassert (H := exp_small_round_0 _ _ _ _ _ He Hd).\nunfold ulp.\nrewrite Req_bool_true by easy.\ndestruct negligible_exp_spec as [H0|k Hk].\nnow elim Zlt_not_le with (1 := H0 e).\nnow apply f_equal, fexp_negligible_exp_eq."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : 0%R = round beta fexp Zfloor x) : ulp 0 = bpow (cexp beta fexp x).","proofString":"unfold cexp.\ndestruct (mag beta x) as [e He].\nsimpl.\nspecialize (He (Rgt_not_eq _ _ Hx)).\napply sym_eq in Hd.\nassert (H := exp_small_round_0 _ _ _ _ _ He Hd).\nunfold ulp.\nrewrite Req_bool_true by easy.\ndestruct negligible_exp_spec as [H0|k Hk].\nnow elim Zlt_not_le with (1 := H0 e).\nnow apply f_equal, fexp_negligible_exp_eq."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : 0%R = round beta fexp Zfloor x) : ulp 0 = bpow (fexp (mag beta x)).","proofString":"destruct (mag beta x) as [e He].\nsimpl.\nspecialize (He (Rgt_not_eq _ _ Hx)).\napply sym_eq in Hd.\nassert (H := exp_small_round_0 _ _ _ _ _ He Hd).\nunfold ulp.\nrewrite Req_bool_true by easy.\ndestruct negligible_exp_spec as [H0|k Hk].\nnow elim Zlt_not_le with (1 := H0 e).\nnow apply f_equal, fexp_negligible_exp_eq."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : 0%R = round beta fexp Zfloor x) (e : Z) (He : x <> 0%R -> (bpow (e - 1) <= Rabs x < bpow e)%R) : ulp 0 = bpow (fexp (Build_mag_prop beta x e He)).","proofString":"simpl.\nspecialize (He (Rgt_not_eq _ _ Hx)).\napply sym_eq in Hd.\nassert (H := exp_small_round_0 _ _ _ _ _ He Hd).\nunfold ulp.\nrewrite Req_bool_true by easy.\ndestruct negligible_exp_spec as [H0|k Hk].\nnow elim Zlt_not_le with (1 := H0 e).\nnow apply f_equal, fexp_negligible_exp_eq."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : 0%R = round beta fexp Zfloor x) (e : Z) (He : x <> 0%R -> (bpow (e - 1) <= Rabs x < bpow e)%R) : ulp 0 = bpow (fexp e).","proofString":"specialize (He (Rgt_not_eq _ _ Hx)).\napply sym_eq in Hd.\nassert (H := exp_small_round_0 _ _ _ _ _ He Hd).\nunfold ulp.\nrewrite Req_bool_true by easy.\ndestruct negligible_exp_spec as [H0|k Hk].\nnow elim Zlt_not_le with (1 := H0 e).\nnow apply f_equal, fexp_negligible_exp_eq."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : 0%R = round beta fexp Zfloor x) (e : Z) (He : (bpow (e - 1) <= Rabs x < bpow e)%R) : ulp 0 = bpow (fexp e).","proofString":"apply sym_eq in Hd.\nassert (H := exp_small_round_0 _ _ _ _ _ He Hd).\nunfold ulp.\nrewrite Req_bool_true by easy.\ndestruct negligible_exp_spec as [H0|k Hk].\nnow elim Zlt_not_le with (1 := H0 e).\nnow apply f_equal, fexp_negligible_exp_eq."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : round beta fexp Zfloor x = 0%R) (e : Z) (He : (bpow (e - 1) <= Rabs x < bpow e)%R) : ulp 0 = bpow (fexp e).","proofString":"assert (H := exp_small_round_0 _ _ _ _ _ He Hd).\nunfold ulp.\nrewrite Req_bool_true by easy.\ndestruct negligible_exp_spec as [H0|k Hk].\nnow elim Zlt_not_le with (1 := H0 e).\nnow apply f_equal, fexp_negligible_exp_eq."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : round beta fexp Zfloor x = 0%R) (e : Z) (He : (bpow (e - 1) <= Rabs x < bpow e)%R) (H : (e <= fexp e)%Z) : ulp 0 = bpow (fexp e).","proofString":"unfold ulp.\nrewrite Req_bool_true by easy.\ndestruct negligible_exp_spec as [H0|k Hk].\nnow elim Zlt_not_le with (1 := H0 e).\nnow apply f_equal, fexp_negligible_exp_eq."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : round beta fexp Zfloor x = 0%R) (e : Z) (He : (bpow (e - 1) <= Rabs x < bpow e)%R) (H : (e <= fexp e)%Z) : (if Req_bool 0 0\n then match negligible_exp with\n      | Some n => bpow (fexp n)\n      | None => 0%R\n      end\n else bpow (cexp beta fexp 0)) = bpow (fexp e).","proofString":"rewrite Req_bool_true by easy.\ndestruct negligible_exp_spec as [H0|k Hk].\nnow elim Zlt_not_le with (1 := H0 e).\nnow apply f_equal, fexp_negligible_exp_eq."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : round beta fexp Zfloor x = 0%R) (e : Z) (He : (bpow (e - 1) <= Rabs x < bpow e)%R) (H : (e <= fexp e)%Z) : match negligible_exp with\n| Some n => bpow (fexp n)\n| None => 0%R\nend = bpow (fexp e).","proofString":"destruct negligible_exp_spec as [H0|k Hk].\nnow elim Zlt_not_le with (1 := H0 e).\nnow apply f_equal, fexp_negligible_exp_eq."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : round beta fexp Zfloor x = 0%R) (e : Z) (He : (bpow (e - 1) <= Rabs x < bpow e)%R) (H : (e <= fexp e)%Z) (H0 : forall n : Z, (fexp n < n)%Z) : 0%R = bpow (fexp e).","proofString":"now elim Zlt_not_le with (1 := H0 e)."},{"statement":"(x : R) (Hx : (0 < x)%R) (Hd : round beta fexp Zfloor x = 0%R) (e : Z) (He : (bpow (e - 1) <= Rabs x < bpow e)%R) (H : (e <= fexp e)%Z) (k : Z) (Hk : (k <= fexp k)%Z) : bpow (fexp k) = bpow (fexp e).","proofString":"now apply f_equal, fexp_negligible_exp_eq."},{"statement":"(H : negligible_exp = None) (rndn : R -> Z) (Hrnd : Valid_rnd rndn) (x : R) (Hx : x <> 0%R) (K : round beta fexp rndn x = 0%R) (Hn : forall n : Z, (fexp n < n)%Z) (e : Z) (He : x <> 0%R -> (bpow (e - 1) <= Rabs x < bpow e)%R) : (fexp e < e)%Z.","proofString":"apply (Hn e)."},{"statement":"(H : negligible_exp = None) (rndn : R -> Z) (Hrnd : Valid_rnd rndn) (x : R) (Hx : x <> 0%R) (K : round beta fexp rndn x = 0%R) : (exists n : Z, negligible_exp = Some n /\\ (n <= fexp n)%Z) -> False.","proofString":"intros (n,(H1,_)).\nrewrite H in H1; discriminate."},{"statement":"(H : negligible_exp = None) (rndn : R -> Z) (Hrnd : Valid_rnd rndn) (x : R) (Hx : x <> 0%R) (K : round beta fexp rndn x = 0%R) (n : Z) (H1 : negligible_exp = Some n) : False.","proofString":"rewrite H in H1; discriminate."},{"statement":"(Hm : Monotone_exp fexp) : (forall rnd : R -> Z,\n Valid_rnd rnd ->\n forall x : R,\n (0 < x)%R ->\n (Rabs (round beta fexp rnd x - x) < ulp (round beta fexp rnd x))%R) ->\nforall rnd : R -> Z,\nValid_rnd rnd ->\nforall x : R,\nx <> 0%R ->\n(Rabs (round beta fexp rnd x - x) < ulp (round beta fexp rnd x))%R.","proofString":"intros M rnd Hrnd x Zx.\ncase (Rle_or_lt 0 x).\nintros H; destruct H.\nnow apply M.\ncontradict H; now apply sym_not_eq.\nintros H.\nrewrite <- (Ropp_involutive x).\nrewrite round_opp, ulp_opp.\nreplace (- round beta fexp (Zrnd_opp rnd) (- x) - - - x)%R with    (-(round beta fexp (Zrnd_opp rnd) (- x) - (-x)))%R by ring.\nrewrite Rabs_Ropp.\napply M.\nnow apply valid_rnd_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(Hm : Monotone_exp fexp) (M : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 < x0)%R ->\n(Rabs (round beta fexp rnd0 x0 - x0) < ulp (round beta fexp rnd0 x0))%R) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) : (Rabs (round beta fexp rnd x - x) < ulp (round beta fexp rnd x))%R.","proofString":"case (Rle_or_lt 0 x).\nintros H; destruct H.\nnow apply M.\ncontradict H; now apply sym_not_eq.\nintros H.\nrewrite <- (Ropp_involutive x).\nrewrite round_opp, ulp_opp.\nreplace (- round beta fexp (Zrnd_opp rnd) (- x) - - - x)%R with    (-(round beta fexp (Zrnd_opp rnd) (- x) - (-x)))%R by ring.\nrewrite Rabs_Ropp.\napply M.\nnow apply valid_rnd_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(Hm : Monotone_exp fexp) (M : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 < x0)%R ->\n(Rabs (round beta fexp rnd0 x0 - x0) < ulp (round beta fexp rnd0 x0))%R) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) : (0 <= x)%R ->\n(Rabs (round beta fexp rnd x - x) < ulp (round beta fexp rnd x))%R.","proofString":"intros H; destruct H.\nnow apply M.\ncontradict H; now apply sym_not_eq."},{"statement":"(Hm : Monotone_exp fexp) (M : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 < x0)%R ->\n(Rabs (round beta fexp rnd0 x0 - x0) < ulp (round beta fexp rnd0 x0))%R) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (H : (0 < x)%R) : (Rabs (round beta fexp rnd x - x) < ulp (round beta fexp rnd x))%R.","proofString":"now apply M."},{"statement":"(Hm : Monotone_exp fexp) (M : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 < x0)%R ->\n(Rabs (round beta fexp rnd0 x0 - x0) < ulp (round beta fexp rnd0 x0))%R) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (H : 0%R = x) : (Rabs (round beta fexp rnd x - x) < ulp (round beta fexp rnd x))%R.","proofString":"contradict H; now apply sym_not_eq."},{"statement":"(Hm : Monotone_exp fexp) (M : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 < x0)%R ->\n(Rabs (round beta fexp rnd0 x0 - x0) < ulp (round beta fexp rnd0 x0))%R) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) : (x < 0)%R ->\n(Rabs (round beta fexp rnd x - x) < ulp (round beta fexp rnd x))%R.","proofString":"intros H.\nrewrite <- (Ropp_involutive x).\nrewrite round_opp, ulp_opp.\nreplace (- round beta fexp (Zrnd_opp rnd) (- x) - - - x)%R with    (-(round beta fexp (Zrnd_opp rnd) (- x) - (-x)))%R by ring.\nrewrite Rabs_Ropp.\napply M.\nnow apply valid_rnd_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(Hm : Monotone_exp fexp) (M : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 < x0)%R ->\n(Rabs (round beta fexp rnd0 x0 - x0) < ulp (round beta fexp rnd0 x0))%R) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (H : (x < 0)%R) : (Rabs (round beta fexp rnd x - x) < ulp (round beta fexp rnd x))%R.","proofString":"rewrite <- (Ropp_involutive x).\nrewrite round_opp, ulp_opp.\nreplace (- round beta fexp (Zrnd_opp rnd) (- x) - - - x)%R with    (-(round beta fexp (Zrnd_opp rnd) (- x) - (-x)))%R by ring.\nrewrite Rabs_Ropp.\napply M.\nnow apply valid_rnd_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(Hm : Monotone_exp fexp) (M : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 < x0)%R ->\n(Rabs (round beta fexp rnd0 x0 - x0) < ulp (round beta fexp rnd0 x0))%R) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (H : (x < 0)%R) : (Rabs (round beta fexp rnd (- - x) - - - x) <\n ulp (round beta fexp rnd (- - x)))%R.","proofString":"rewrite round_opp, ulp_opp.\nreplace (- round beta fexp (Zrnd_opp rnd) (- x) - - - x)%R with    (-(round beta fexp (Zrnd_opp rnd) (- x) - (-x)))%R by ring.\nrewrite Rabs_Ropp.\napply M.\nnow apply valid_rnd_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(Hm : Monotone_exp fexp) (M : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 < x0)%R ->\n(Rabs (round beta fexp rnd0 x0 - x0) < ulp (round beta fexp rnd0 x0))%R) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (H : (x < 0)%R) : (Rabs (- round beta fexp (Zrnd_opp rnd) (- x) - - - x) <\n ulp (round beta fexp (Zrnd_opp rnd) (- x)))%R.","proofString":"replace (- round beta fexp (Zrnd_opp rnd) (- x) - - - x)%R with    (-(round beta fexp (Zrnd_opp rnd) (- x) - (-x)))%R by ring.\nrewrite Rabs_Ropp.\napply M.\nnow apply valid_rnd_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(Hm : Monotone_exp fexp) (M : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 < x0)%R ->\n(Rabs (round beta fexp rnd0 x0 - x0) < ulp (round beta fexp rnd0 x0))%R) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (H : (x < 0)%R) : (Rabs (- (round beta fexp (Zrnd_opp rnd) (- x) - - x)) <\n ulp (round beta fexp (Zrnd_opp rnd) (- x)))%R.","proofString":"rewrite Rabs_Ropp.\napply M.\nnow apply valid_rnd_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(Hm : Monotone_exp fexp) (M : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 < x0)%R ->\n(Rabs (round beta fexp rnd0 x0 - x0) < ulp (round beta fexp rnd0 x0))%R) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (H : (x < 0)%R) : (Rabs (round beta fexp (Zrnd_opp rnd) (- x) - - x) <\n ulp (round beta fexp (Zrnd_opp rnd) (- x)))%R.","proofString":"apply M.\nnow apply valid_rnd_opp.\nnow apply Ropp_0_gt_lt_contravar."},{"statement":"(Hm : Monotone_exp fexp) (M : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 < x0)%R ->\n(Rabs (round beta fexp rnd0 x0 - x0) < ulp (round beta fexp rnd0 x0))%R) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (H : (x < 0)%R) : Valid_rnd (Zrnd_opp rnd).","proofString":"now apply valid_rnd_opp."},{"statement":"(Hm : Monotone_exp fexp) (M : forall rnd0 : R -> Z,\nValid_rnd rnd0 ->\nforall x0 : R,\n(0 < x0)%R ->\n(Rabs (round beta fexp rnd0 x0 - x0) < ulp (round beta fexp rnd0 x0))%R) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Zx : x <> 0%R) (H : (x < 0)%R) : (0 < - x)%R.","proofString":"now apply Ropp_0_gt_lt_contravar."},{"statement":"(Hm : Monotone_exp fexp) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Hx : (0 < x)%R) : x <> 0%R.","proofString":"now apply Rgt_not_eq."},{"statement":"(Hm : Monotone_exp fexp) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Hx : (0 < x)%R) : F 0.","proofString":"apply generic_format_0."},{"statement":"(Hm : Monotone_exp fexp) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Hx : (0 < x)%R) : (0 <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(Hm : Monotone_exp fexp) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Hx : (0 < x)%R) (V : round beta fexp rnd x = round beta fexp Zfloor x) : (round beta fexp Zfloor x <= round beta fexp Zfloor x)%R.","proofString":"apply Rle_refl."},{"statement":"(Hm : Monotone_exp fexp) (rnd : R -> Z) (Hrnd : Valid_rnd rnd) (x : R) (Hx : (0 < x)%R) : (0 <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(Mexp : Monotone_exp fexp) (rnd : R -> Z) (Vrnd : Valid_rnd rnd) (x : R) : (Rabs (round beta fexp rnd x - x) <= ulp (round beta fexp rnd x))%R.","proofString":"destruct (Req_dec x 0) as [Zx|Nzx].\nrewrite Zx, round_0; [|exact Vrnd].\nunfold Rminus; rewrite Ropp_0, Rplus_0_l, Rabs_R0; apply ulp_ge_0.\nnow apply Rlt_le, error_lt_ulp_round."},{"statement":"(Mexp : Monotone_exp fexp) (rnd : R -> Z) (Vrnd : Valid_rnd rnd) (x : R) (Zx : x = 0%R) : (Rabs (round beta fexp rnd x - x) <= ulp (round beta fexp rnd x))%R.","proofString":"rewrite Zx, round_0; [|exact Vrnd].\nunfold Rminus; rewrite Ropp_0, Rplus_0_l, Rabs_R0; apply ulp_ge_0."},{"statement":"(Mexp : Monotone_exp fexp) (rnd : R -> Z) (Vrnd : Valid_rnd rnd) (x : R) (Zx : x = 0%R) : (Rabs (0 - 0) <= ulp 0)%R.","proofString":"unfold Rminus; rewrite Ropp_0, Rplus_0_l, Rabs_R0; apply ulp_ge_0."},{"statement":"(Mexp : Monotone_exp fexp) (rnd : R -> Z) (Vrnd : Valid_rnd rnd) (x : R) (Nzx : x <> 0%R) : (Rabs (round beta fexp rnd x - x) <= ulp (round beta fexp rnd x))%R.","proofString":"now apply Rlt_le, error_lt_ulp_round."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x = 0%R) (Hx : x = 0%R) : (/ 2 * ulp 0 <= / 2 * ulp 0)%R.","proofString":"right; ring."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x = 0%R) (Hx : x <> 0%R) (N : (Rabs x <= / 2 * ulp x)%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) : (mag beta x - 1 < fexp n)%Z -> (mag beta x <= fexp n)%Z.","proofString":"lia."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x = 0%R) (Hx : x <> 0%R) (N : (Rabs x <= / 2 * ulp x)%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) (e : Z) (He : x <> 0%R -> (bpow (e - 1) <= Rabs x < bpow e)%R) : (bpow (e - 1) <= Rabs x)%R.","proofString":"now apply He."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x = 0%R) (Hx : x <> 0%R) (N : (Rabs x <= / 2 * ulp x)%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) (e : Z) (He : x <> 0%R -> (bpow (e - 1) <= Rabs x < bpow e)%R) : (Rabs x <= Rabs (round beta fexp (Znearest choice) x - x))%R.","proofString":"right; rewrite Hfx; unfold Rminus; rewrite Rplus_0_l.\napply sym_eq, Rabs_Ropp."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x = 0%R) (Hx : x <> 0%R) (N : (Rabs x <= / 2 * ulp x)%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) (e : Z) (He : x <> 0%R -> (bpow (e - 1) <= Rabs x < bpow e)%R) : Rabs x = Rabs (- x).","proofString":"apply sym_eq, Rabs_Ropp."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x = 0%R) (Hx : x <> 0%R) (N : (Rabs x <= / 2 * ulp x)%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) (e : Z) (He : x <> 0%R -> (bpow (e - 1) <= Rabs x < bpow e)%R) : (ulp 0 <= bpow (fexp n))%R.","proofString":"unfold ulp; rewrite Req_bool_true, H1; trivial.\nnow right."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x = 0%R) (Hx : x <> 0%R) (N : (Rabs x <= / 2 * ulp x)%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) (e : Z) (He : x <> 0%R -> (bpow (e - 1) <= Rabs x < bpow e)%R) : (bpow (fexp n) <= bpow (fexp n))%R.","proofString":"now right."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zfloor x) (H : (0 <= x)%R) : (Rabs (round beta fexp (Znearest choice) x - x) <=\n / 2 * ulp (round beta fexp (Znearest choice) x))%R.","proofString":"rewrite Hx at 2.\nrewrite ulp_DN by easy.\napply error_le_half_ulp."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zfloor x) (H : (0 <= x)%R) : (Rabs (round beta fexp (Znearest choice) x - x) <=\n / 2 * ulp (round beta fexp Zfloor x))%R.","proofString":"rewrite ulp_DN by easy.\napply error_le_half_ulp."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zfloor x) (H : (0 <= x)%R) : (Rabs (round beta fexp (Znearest choice) x - x) <= / 2 * ulp x)%R.","proofString":"apply error_le_half_ulp."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zfloor x) (H : (x < 0)%R) : (0 <= / 2)%R.","proofString":"apply Rlt_le, pos_half_prf."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zfloor x) (H : (x < 0)%R) : F 0.","proofString":"apply generic_format_0."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zfloor x) (H : (x < 0)%R) : (x <= 0)%R.","proofString":"now apply Rlt_le."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) : (Rabs (round beta fexp (Znearest choice) x - x) <=\n / 2 * ulp (round beta fexp (Znearest choice) x))%R.","proofString":"destruct (Rle_or_lt 0 x) as [H|H].\napply Rle_trans with (1:=error_le_half_ulp _ _).\napply Rmult_le_compat_l.\napply Rlt_le, pos_half_prf.\napply ulp_le_pos; trivial.\nrewrite Hx; apply (round_UP_pt beta fexp x).\nrewrite Hx at 2; rewrite <- (ulp_opp (round beta fexp Zceil x)).\nrewrite <- round_DN_opp.\nrewrite ulp_DN; trivial.\npattern x at 1 2; rewrite <- Ropp_involutive.\nrewrite round_N_opp.\nunfold Rminus.\nrewrite <- Ropp_plus_distr, Rabs_Ropp.\napply error_le_half_ulp.\nrewrite <- Ropp_0.\napply Ropp_le_contravar.\nnow apply Rlt_le."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (0 <= x)%R) : (Rabs (round beta fexp (Znearest choice) x - x) <=\n / 2 * ulp (round beta fexp (Znearest choice) x))%R.","proofString":"apply Rle_trans with (1:=error_le_half_ulp _ _).\napply Rmult_le_compat_l.\napply Rlt_le, pos_half_prf.\napply ulp_le_pos; trivial.\nrewrite Hx; apply (round_UP_pt beta fexp x)."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (0 <= x)%R) : (/ 2 * ulp x <= / 2 * ulp (round beta fexp (Znearest choice) x))%R.","proofString":"apply Rmult_le_compat_l.\napply Rlt_le, pos_half_prf.\napply ulp_le_pos; trivial.\nrewrite Hx; apply (round_UP_pt beta fexp x)."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (0 <= x)%R) : (0 <= / 2)%R.","proofString":"apply Rlt_le, pos_half_prf."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (0 <= x)%R) : (ulp x <= ulp (round beta fexp (Znearest choice) x))%R.","proofString":"apply ulp_le_pos; trivial.\nrewrite Hx; apply (round_UP_pt beta fexp x)."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (0 <= x)%R) : (x <= round beta fexp (Znearest choice) x)%R.","proofString":"rewrite Hx; apply (round_UP_pt beta fexp x)."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (x < 0)%R) : (Rabs (round beta fexp (Znearest choice) x - x) <=\n / 2 * ulp (round beta fexp (Znearest choice) x))%R.","proofString":"rewrite Hx at 2; rewrite <- (ulp_opp (round beta fexp Zceil x)).\nrewrite <- round_DN_opp.\nrewrite ulp_DN; trivial.\npattern x at 1 2; rewrite <- Ropp_involutive.\nrewrite round_N_opp.\nunfold Rminus.\nrewrite <- Ropp_plus_distr, Rabs_Ropp.\napply error_le_half_ulp.\nrewrite <- Ropp_0.\napply Ropp_le_contravar.\nnow apply Rlt_le."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (x < 0)%R) : (Rabs (round beta fexp (Znearest choice) x - x) <=\n / 2 * ulp (- round beta fexp Zceil x))%R.","proofString":"rewrite <- round_DN_opp.\nrewrite ulp_DN; trivial.\npattern x at 1 2; rewrite <- Ropp_involutive.\nrewrite round_N_opp.\nunfold Rminus.\nrewrite <- Ropp_plus_distr, Rabs_Ropp.\napply error_le_half_ulp.\nrewrite <- Ropp_0.\napply Ropp_le_contravar.\nnow apply Rlt_le."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (x < 0)%R) : (Rabs (round beta fexp (Znearest choice) x - x) <=\n / 2 * ulp (round beta fexp Zfloor (- x)))%R.","proofString":"rewrite ulp_DN; trivial.\npattern x at 1 2; rewrite <- Ropp_involutive.\nrewrite round_N_opp.\nunfold Rminus.\nrewrite <- Ropp_plus_distr, Rabs_Ropp.\napply error_le_half_ulp.\nrewrite <- Ropp_0.\napply Ropp_le_contravar.\nnow apply Rlt_le."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (x < 0)%R) : (Rabs (round beta fexp (Znearest choice) x - x) <= / 2 * ulp (- x))%R.","proofString":"pattern x at 1 2; rewrite <- Ropp_involutive.\nrewrite round_N_opp.\nunfold Rminus.\nrewrite <- Ropp_plus_distr, Rabs_Ropp.\napply error_le_half_ulp."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (x < 0)%R) : (Rabs (round beta fexp (Znearest choice) (- - x) - - - x) <= / 2 * ulp (- x))%R.","proofString":"rewrite round_N_opp.\nunfold Rminus.\nrewrite <- Ropp_plus_distr, Rabs_Ropp.\napply error_le_half_ulp."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (x < 0)%R) : (Rabs\n   (-\n    round beta fexp (Znearest (fun t : Z => negb (choice (- (t + 1))%Z)))\n      (- x) - - - x) <= / 2 * ulp (- x))%R.","proofString":"unfold Rminus.\nrewrite <- Ropp_plus_distr, Rabs_Ropp.\napply error_le_half_ulp."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (x < 0)%R) : (Rabs\n   (-\n    round beta fexp (Znearest (fun t : Z => negb (choice (- (t + 1))%Z)))\n      (- x) + - - - x) <= / 2 * ulp (- x))%R.","proofString":"rewrite <- Ropp_plus_distr, Rabs_Ropp.\napply error_le_half_ulp."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (x < 0)%R) : (Rabs\n   (round beta fexp (Znearest (fun t : Z => negb (choice (- (t + 1))%Z)))\n      (- x) + - - x) <= / 2 * ulp (- x))%R.","proofString":"apply error_le_half_ulp."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (x < 0)%R) : (0 <= - x)%R.","proofString":"rewrite <- Ropp_0.\napply Ropp_le_contravar.\nnow apply Rlt_le."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (x < 0)%R) : (- 0 <= - x)%R.","proofString":"apply Ropp_le_contravar.\nnow apply Rlt_le."},{"statement":"(Hm : Monotone_exp fexp) (choice : Z -> bool) (x : R) (Hfx : round beta fexp (Znearest choice) x <> 0%R) (Hx : round beta fexp (Znearest choice) x = round beta fexp Zceil x) (H : (x < 0)%R) : (x <= 0)%R.","proofString":"now apply Rlt_le."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x <= y)%R) : (succ x <= succ y)%R.","proofString":"apply Ropp_le_cancel.\nrewrite <- 2!pred_opp.\napply pred_le.\nnow apply generic_format_opp.\nnow apply generic_format_opp.\nnow apply Ropp_le_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x <= y)%R) : (- succ y <= - succ x)%R.","proofString":"rewrite <- 2!pred_opp.\napply pred_le.\nnow apply generic_format_opp.\nnow apply generic_format_opp.\nnow apply Ropp_le_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x <= y)%R) : (pred (- y) <= pred (- x))%R.","proofString":"apply pred_le.\nnow apply generic_format_opp.\nnow apply generic_format_opp.\nnow apply Ropp_le_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x <= y)%R) : F (- y).","proofString":"now apply generic_format_opp."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x <= y)%R) : F (- x).","proofString":"now apply generic_format_opp."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x <= y)%R) : (- y <= - x)%R.","proofString":"now apply Ropp_le_contravar."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (pred x <= pred y)%R) : (x <= y)%R.","proofString":"rewrite <- (succ_pred x), <- (succ_pred y); try assumption.\napply succ_le; trivial; now apply generic_format_pred."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (pred x <= pred y)%R) : (succ (pred x) <= succ (pred y))%R.","proofString":"apply succ_le; trivial; now apply generic_format_pred."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (succ x <= succ y)%R) : (x <= y)%R.","proofString":"rewrite <- (pred_succ x), <- (pred_succ y); try assumption.\napply pred_le; trivial; now apply generic_format_succ."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (succ x <= succ y)%R) : (pred (succ x) <= pred (succ y))%R.","proofString":"apply pred_le; trivial; now apply generic_format_succ."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) : (pred x < pred y)%R.","proofString":"apply Rnot_le_lt.\nintros H.\napply Rgt_not_le with (1 := Hxy).\nnow apply pred_le_inv."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) : ~ (pred y <= pred x)%R.","proofString":"intros H.\napply Rgt_not_le with (1 := Hxy).\nnow apply pred_le_inv."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) (H : (pred y <= pred x)%R) : False.","proofString":"apply Rgt_not_le with (1 := Hxy).\nnow apply pred_le_inv."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) (H : (pred y <= pred x)%R) : (y <= x)%R.","proofString":"now apply pred_le_inv."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) : (succ x < succ y)%R.","proofString":"apply Rnot_le_lt.\nintros H.\napply Rgt_not_le with (1 := Hxy).\nnow apply succ_le_inv."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) : ~ (succ y <= succ x)%R.","proofString":"intros H.\napply Rgt_not_le with (1 := Hxy).\nnow apply succ_le_inv."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) (H : (succ y <= succ x)%R) : False.","proofString":"apply Rgt_not_le with (1 := Hxy).\nnow apply succ_le_inv."},{"statement":"(x y : R) (Fx : F x) (Fy : F y) (Hxy : (x < y)%R) (H : (succ y <= succ x)%R) : (y <= x)%R.","proofString":"now apply succ_le_inv."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) : (succ x <= x + ulp x)%R.","proofString":"destruct (Rle_or_lt 0 x) as [Px|Nx]; [now right; apply succ_eq_pos|].\nreplace (_ + _)%R with (- (-x - ulp x))%R by ring.\nunfold succ; rewrite (Rle_bool_false _ _ Nx), <-ulp_opp.\napply Ropp_le_contravar; unfold pred_pos.\ndestruct (Req_dec (-x) (bpow (mag beta (-x) - 1))) as [Hx|Hx].\nrewrite (Req_bool_true _ _ Hx).\napply (Rplus_le_reg_r x); ring_simplify; apply Ropp_le_contravar.\nunfold ulp; rewrite Req_bool_false; [|lra].\napply bpow_le, Mexp; lia.\nnow rewrite (Req_bool_false _ _ Hx); right."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Nx : (x < 0)%R) : (succ x <= x + ulp x)%R.","proofString":"replace (_ + _)%R with (- (-x - ulp x))%R by ring.\nunfold succ; rewrite (Rle_bool_false _ _ Nx), <-ulp_opp.\napply Ropp_le_contravar; unfold pred_pos.\ndestruct (Req_dec (-x) (bpow (mag beta (-x) - 1))) as [Hx|Hx].\nrewrite (Req_bool_true _ _ Hx).\napply (Rplus_le_reg_r x); ring_simplify; apply Ropp_le_contravar.\nunfold ulp; rewrite Req_bool_false; [|lra].\napply bpow_le, Mexp; lia.\nnow rewrite (Req_bool_false _ _ Hx); right."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Nx : (x < 0)%R) : (succ x <= - (- x - ulp x))%R.","proofString":"unfold succ; rewrite (Rle_bool_false _ _ Nx), <-ulp_opp.\napply Ropp_le_contravar; unfold pred_pos.\ndestruct (Req_dec (-x) (bpow (mag beta (-x) - 1))) as [Hx|Hx].\nrewrite (Req_bool_true _ _ Hx).\napply (Rplus_le_reg_r x); ring_simplify; apply Ropp_le_contravar.\nunfold ulp; rewrite Req_bool_false; [|lra].\napply bpow_le, Mexp; lia.\nnow rewrite (Req_bool_false _ _ Hx); right."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Nx : (x < 0)%R) : (- pred_pos (- x) <= - (- x - ulp (- x)))%R.","proofString":"apply Ropp_le_contravar; unfold pred_pos.\ndestruct (Req_dec (-x) (bpow (mag beta (-x) - 1))) as [Hx|Hx].\nrewrite (Req_bool_true _ _ Hx).\napply (Rplus_le_reg_r x); ring_simplify; apply Ropp_le_contravar.\nunfold ulp; rewrite Req_bool_false; [|lra].\napply bpow_le, Mexp; lia.\nnow rewrite (Req_bool_false _ _ Hx); right."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Nx : (x < 0)%R) : (- x - ulp (- x) <=\n (if Req_bool (- x) (bpow (mag beta (- x) - 1))\n  then - x - bpow (fexp (mag beta (- x) - 1))\n  else - x - ulp (- x)))%R.","proofString":"destruct (Req_dec (-x) (bpow (mag beta (-x) - 1))) as [Hx|Hx].\nrewrite (Req_bool_true _ _ Hx).\napply (Rplus_le_reg_r x); ring_simplify; apply Ropp_le_contravar.\nunfold ulp; rewrite Req_bool_false; [|lra].\napply bpow_le, Mexp; lia.\nnow rewrite (Req_bool_false _ _ Hx); right."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Nx : (x < 0)%R) (Hx : (- x)%R = bpow (mag beta (- x) - 1)) : (- x - ulp (- x) <=\n (if Req_bool (- x) (bpow (mag beta (- x) - 1))\n  then - x - bpow (fexp (mag beta (- x) - 1))\n  else - x - ulp (- x)))%R.","proofString":"rewrite (Req_bool_true _ _ Hx).\napply (Rplus_le_reg_r x); ring_simplify; apply Ropp_le_contravar.\nunfold ulp; rewrite Req_bool_false; [|lra].\napply bpow_le, Mexp; lia."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Nx : (x < 0)%R) (Hx : (- x)%R = bpow (mag beta (- x) - 1)) : (- x - ulp (- x) <= - x - bpow (fexp (mag beta (- x) - 1)))%R.","proofString":"apply (Rplus_le_reg_r x); ring_simplify; apply Ropp_le_contravar.\nunfold ulp; rewrite Req_bool_false; [|lra].\napply bpow_le, Mexp; lia."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Nx : (x < 0)%R) (Hx : (- x)%R = bpow (mag beta (- x) - 1)) : (bpow (fexp (mag beta (- x) - 1)) <= ulp (- x))%R.","proofString":"unfold ulp; rewrite Req_bool_false; [|lra].\napply bpow_le, Mexp; lia."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Nx : (x < 0)%R) (Hx : (- x)%R = bpow (mag beta (- x) - 1)) : (bpow (fexp (mag beta (- x) - 1)) <= bpow (cexp beta fexp (- x)))%R.","proofString":"apply bpow_le, Mexp; lia."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Nx : (x < 0)%R) (Hx : (- x)%R <> bpow (mag beta (- x) - 1)) : (- x - ulp (- x) <=\n (if Req_bool (- x) (bpow (mag beta (- x) - 1))\n  then - x - bpow (fexp (mag beta (- x) - 1))\n  else - x - ulp (- x)))%R.","proofString":"now rewrite (Req_bool_false _ _ Hx); right."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F x) : F (x + ulp x).","proofString":"destruct (Rle_or_lt 0 x) as [Px|Nx].\nnow rewrite <-(succ_eq_pos _ Px); apply generic_format_succ.\napply generic_format_opp in Fx.\nreplace (_ + _)%R with (- (-x - ulp x))%R by ring.\napply generic_format_opp; rewrite <-ulp_opp.\ndestruct (Req_dec (-x) (bpow (mag beta (-x) - 1))) as [Hx|Hx].\nunfold ulp; rewrite Req_bool_false; [|lra].\nrewrite Hx at 1.\nunfold cexp.\nset (e := mag _ _).\nassert (Hfe : (fexp e < e)%Z).\nnow apply mag_generic_gt; [|lra|].\nreplace (e - 1)%Z with (e - 1 - fexp e + fexp e)%Z by ring.\nrewrite bpow_plus.\nset (m := bpow (_ - _)).\nreplace (_ - _)%R with ((m - 1) * bpow (fexp e))%R; [|unfold m; ring].\ncase_eq (e - 1 - fexp e)%Z.\nintro He; unfold m; rewrite He; simpl; ring_simplify (1 - 1)%R.\nrewrite Rmult_0_l; apply generic_format_0.\nintros p Hp; unfold m; rewrite Hp; simpl.\npose (f := {| Defs.Fnum := (Z.pow_pos beta p - 1)%Z;                  Defs.Fexp := fexp e |} : Defs.float beta).\napply (generic_format_F2R' _ _ _ f); [|intro Hm'; unfold f; simpl].\nnow unfold Defs.F2R; simpl; rewrite minus_IZR.\nunfold cexp.\nreplace (IZR _) with (bpow (Z.pos p)); [|now simpl].\nrewrite <-Hp.\nassert (He : (1 <= e - 1 - fexp e)%Z); [lia|].\nset (e' := mag _ (_ * _)).\nassert (H : (e' = e - 1 :> Z)%Z); [|rewrite H; apply Mexp; lia].\nunfold e'; apply mag_unique.\nrewrite Rabs_mult, (Rabs_pos_eq (bpow _)); [|apply bpow_ge_0].\nrewrite Rabs_pos_eq;      [|apply (Rplus_le_reg_r 1); ring_simplify;        change 1%R with (bpow 0); apply bpow_le; lia].\nassert (beta_pos : (0 < IZR beta)%R).\napply (Rlt_le_trans _ 2); [lra|].\napply IZR_le, Z.leb_le, radix_prop.\nsplit.\nreplace (e - 1 - 1)%Z with (e - 1 - fexp e + -1  + fexp e)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r; [apply bpow_ge_0|].\nrewrite bpow_plus; simpl; unfold Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply (Rmult_le_reg_r _ _ _ beta_pos).\nrewrite Rmult_assoc, Rinv_l; [|lra]; rewrite Rmult_1_r.\napply (Rplus_le_reg_r (IZR beta)); ring_simplify.\napply (Rle_trans _ (2 * bpow (e - 1 - fexp e))).\nchange 2%R with (1 + 1)%R; rewrite Rmult_plus_distr_r, Rmult_1_l.\napply Rplus_le_compat_l.\nrewrite <-bpow_1; apply bpow_le; lia.\nrewrite Rmult_comm; apply Rmult_le_compat_l; [apply bpow_ge_0|].\napply IZR_le, Z.leb_le, radix_prop.\napply (Rmult_lt_reg_r (bpow (- fexp e))); [apply bpow_gt_0|].\nrewrite Rmult_assoc, <-!bpow_plus.\nreplace (fexp e + - fexp e)%Z with 0%Z by ring; simpl.\nrewrite Rmult_1_r; unfold Zminus; lra.\nintros p Hp; exfalso; lia.\nreplace (_ - _)%R with (pred_pos (-x)).\nnow apply generic_format_pred_pos; [|lra].\nnow unfold pred_pos; rewrite Req_bool_false."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F x) (Px : (0 <= x)%R) : F (x + ulp x).","proofString":"now rewrite <-(succ_eq_pos _ Px); apply generic_format_succ."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F x) (Nx : (x < 0)%R) : F (x + ulp x).","proofString":"apply generic_format_opp in Fx.\nreplace (_ + _)%R with (- (-x - ulp x))%R by ring.\napply generic_format_opp; rewrite <-ulp_opp.\ndestruct (Req_dec (-x) (bpow (mag beta (-x) - 1))) as [Hx|Hx].\nunfold ulp; rewrite Req_bool_false; [|lra].\nrewrite Hx at 1.\nunfold cexp.\nset (e := mag _ _).\nassert (Hfe : (fexp e < e)%Z).\nnow apply mag_generic_gt; [|lra|].\nreplace (e - 1)%Z with (e - 1 - fexp e + fexp e)%Z by ring.\nrewrite bpow_plus.\nset (m := bpow (_ - _)).\nreplace (_ - _)%R with ((m - 1) * bpow (fexp e))%R; [|unfold m; ring].\ncase_eq (e - 1 - fexp e)%Z.\nintro He; unfold m; rewrite He; simpl; ring_simplify (1 - 1)%R.\nrewrite Rmult_0_l; apply generic_format_0.\nintros p Hp; unfold m; rewrite Hp; simpl.\npose (f := {| Defs.Fnum := (Z.pow_pos beta p - 1)%Z;                  Defs.Fexp := fexp e |} : Defs.float beta).\napply (generic_format_F2R' _ _ _ f); [|intro Hm'; unfold f; simpl].\nnow unfold Defs.F2R; simpl; rewrite minus_IZR.\nunfold cexp.\nreplace (IZR _) with (bpow (Z.pos p)); [|now simpl].\nrewrite <-Hp.\nassert (He : (1 <= e - 1 - fexp e)%Z); [lia|].\nset (e' := mag _ (_ * _)).\nassert (H : (e' = e - 1 :> Z)%Z); [|rewrite H; apply Mexp; lia].\nunfold e'; apply mag_unique.\nrewrite Rabs_mult, (Rabs_pos_eq (bpow _)); [|apply bpow_ge_0].\nrewrite Rabs_pos_eq;      [|apply (Rplus_le_reg_r 1); ring_simplify;        change 1%R with (bpow 0); apply bpow_le; lia].\nassert (beta_pos : (0 < IZR beta)%R).\napply (Rlt_le_trans _ 2); [lra|].\napply IZR_le, Z.leb_le, radix_prop.\nsplit.\nreplace (e - 1 - 1)%Z with (e - 1 - fexp e + -1  + fexp e)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r; [apply bpow_ge_0|].\nrewrite bpow_plus; simpl; unfold Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply (Rmult_le_reg_r _ _ _ beta_pos).\nrewrite Rmult_assoc, Rinv_l; [|lra]; rewrite Rmult_1_r.\napply (Rplus_le_reg_r (IZR beta)); ring_simplify.\napply (Rle_trans _ (2 * bpow (e - 1 - fexp e))).\nchange 2%R with (1 + 1)%R; rewrite Rmult_plus_distr_r, Rmult_1_l.\napply Rplus_le_compat_l.\nrewrite <-bpow_1; apply bpow_le; lia.\nrewrite Rmult_comm; apply Rmult_le_compat_l; [apply bpow_ge_0|].\napply IZR_le, Z.leb_le, radix_prop.\napply (Rmult_lt_reg_r (bpow (- fexp e))); [apply bpow_gt_0|].\nrewrite Rmult_assoc, <-!bpow_plus.\nreplace (fexp e + - fexp e)%Z with 0%Z by ring; simpl.\nrewrite Rmult_1_r; unfold Zminus; lra.\nintros p Hp; exfalso; lia.\nreplace (_ - _)%R with (pred_pos (-x)).\nnow apply generic_format_pred_pos; [|lra].\nnow unfold pred_pos; rewrite Req_bool_false."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F (- x)) (Nx : (x < 0)%R) : F (x + ulp x).","proofString":"replace (_ + _)%R with (- (-x - ulp x))%R by ring.\napply generic_format_opp; rewrite <-ulp_opp.\ndestruct (Req_dec (-x) (bpow (mag beta (-x) - 1))) as [Hx|Hx].\nunfold ulp; rewrite Req_bool_false; [|lra].\nrewrite Hx at 1.\nunfold cexp.\nset (e := mag _ _).\nassert (Hfe : (fexp e < e)%Z).\nnow apply mag_generic_gt; [|lra|].\nreplace (e - 1)%Z with (e - 1 - fexp e + fexp e)%Z by ring.\nrewrite bpow_plus.\nset (m := bpow (_ - _)).\nreplace (_ - _)%R with ((m - 1) * bpow (fexp e))%R; [|unfold m; ring].\ncase_eq (e - 1 - fexp e)%Z.\nintro He; unfold m; rewrite He; simpl; ring_simplify (1 - 1)%R.\nrewrite Rmult_0_l; apply generic_format_0.\nintros p Hp; unfold m; rewrite Hp; simpl.\npose (f := {| Defs.Fnum := (Z.pow_pos beta p - 1)%Z;                  Defs.Fexp := fexp e |} : Defs.float beta).\napply (generic_format_F2R' _ _ _ f); [|intro Hm'; unfold f; simpl].\nnow unfold Defs.F2R; simpl; rewrite minus_IZR.\nunfold cexp.\nreplace (IZR _) with (bpow (Z.pos p)); [|now simpl].\nrewrite <-Hp.\nassert (He : (1 <= e - 1 - fexp e)%Z); [lia|].\nset (e' := mag _ (_ * _)).\nassert (H : (e' = e - 1 :> Z)%Z); [|rewrite H; apply Mexp; lia].\nunfold e'; apply mag_unique.\nrewrite Rabs_mult, (Rabs_pos_eq (bpow _)); [|apply bpow_ge_0].\nrewrite Rabs_pos_eq;      [|apply (Rplus_le_reg_r 1); ring_simplify;        change 1%R with (bpow 0); apply bpow_le; lia].\nassert (beta_pos : (0 < IZR beta)%R).\napply (Rlt_le_trans _ 2); [lra|].\napply IZR_le, Z.leb_le, radix_prop.\nsplit.\nreplace (e - 1 - 1)%Z with (e - 1 - fexp e + -1  + fexp e)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r; [apply bpow_ge_0|].\nrewrite bpow_plus; simpl; unfold Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply (Rmult_le_reg_r _ _ _ beta_pos).\nrewrite Rmult_assoc, Rinv_l; [|lra]; rewrite Rmult_1_r.\napply (Rplus_le_reg_r (IZR beta)); ring_simplify.\napply (Rle_trans _ (2 * bpow (e - 1 - fexp e))).\nchange 2%R with (1 + 1)%R; rewrite Rmult_plus_distr_r, Rmult_1_l.\napply Rplus_le_compat_l.\nrewrite <-bpow_1; apply bpow_le; lia.\nrewrite Rmult_comm; apply Rmult_le_compat_l; [apply bpow_ge_0|].\napply IZR_le, Z.leb_le, radix_prop.\napply (Rmult_lt_reg_r (bpow (- fexp e))); [apply bpow_gt_0|].\nrewrite Rmult_assoc, <-!bpow_plus.\nreplace (fexp e + - fexp e)%Z with 0%Z by ring; simpl.\nrewrite Rmult_1_r; unfold Zminus; lra.\nintros p Hp; exfalso; lia.\nreplace (_ - _)%R with (pred_pos (-x)).\nnow apply generic_format_pred_pos; [|lra].\nnow unfold pred_pos; rewrite Req_bool_false."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F (- x)) (Nx : (x < 0)%R) : F (- (- x - ulp x)).","proofString":"apply generic_format_opp; rewrite <-ulp_opp.\ndestruct (Req_dec (-x) (bpow (mag beta (-x) - 1))) as [Hx|Hx].\nunfold ulp; rewrite Req_bool_false; [|lra].\nrewrite Hx at 1.\nunfold cexp.\nset (e := mag _ _).\nassert (Hfe : (fexp e < e)%Z).\nnow apply mag_generic_gt; [|lra|].\nreplace (e - 1)%Z with (e - 1 - fexp e + fexp e)%Z by ring.\nrewrite bpow_plus.\nset (m := bpow (_ - _)).\nreplace (_ - _)%R with ((m - 1) * bpow (fexp e))%R; [|unfold m; ring].\ncase_eq (e - 1 - fexp e)%Z.\nintro He; unfold m; rewrite He; simpl; ring_simplify (1 - 1)%R.\nrewrite Rmult_0_l; apply generic_format_0.\nintros p Hp; unfold m; rewrite Hp; simpl.\npose (f := {| Defs.Fnum := (Z.pow_pos beta p - 1)%Z;                  Defs.Fexp := fexp e |} : Defs.float beta).\napply (generic_format_F2R' _ _ _ f); [|intro Hm'; unfold f; simpl].\nnow unfold Defs.F2R; simpl; rewrite minus_IZR.\nunfold cexp.\nreplace (IZR _) with (bpow (Z.pos p)); [|now simpl].\nrewrite <-Hp.\nassert (He : (1 <= e - 1 - fexp e)%Z); [lia|].\nset (e' := mag _ (_ * _)).\nassert (H : (e' = e - 1 :> Z)%Z); [|rewrite H; apply Mexp; lia].\nunfold e'; apply mag_unique.\nrewrite Rabs_mult, (Rabs_pos_eq (bpow _)); [|apply bpow_ge_0].\nrewrite Rabs_pos_eq;      [|apply (Rplus_le_reg_r 1); ring_simplify;        change 1%R with (bpow 0); apply bpow_le; lia].\nassert (beta_pos : (0 < IZR beta)%R).\napply (Rlt_le_trans _ 2); [lra|].\napply IZR_le, Z.leb_le, radix_prop.\nsplit.\nreplace (e - 1 - 1)%Z with (e - 1 - fexp e + -1  + fexp e)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r; [apply bpow_ge_0|].\nrewrite bpow_plus; simpl; unfold Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply (Rmult_le_reg_r _ _ _ beta_pos).\nrewrite Rmult_assoc, Rinv_l; [|lra]; rewrite Rmult_1_r.\napply (Rplus_le_reg_r (IZR beta)); ring_simplify.\napply (Rle_trans _ (2 * bpow (e - 1 - fexp e))).\nchange 2%R with (1 + 1)%R; rewrite Rmult_plus_distr_r, Rmult_1_l.\napply Rplus_le_compat_l.\nrewrite <-bpow_1; apply bpow_le; lia.\nrewrite Rmult_comm; apply Rmult_le_compat_l; [apply bpow_ge_0|].\napply IZR_le, Z.leb_le, radix_prop.\napply (Rmult_lt_reg_r (bpow (- fexp e))); [apply bpow_gt_0|].\nrewrite Rmult_assoc, <-!bpow_plus.\nreplace (fexp e + - fexp e)%Z with 0%Z by ring; simpl.\nrewrite Rmult_1_r; unfold Zminus; lra.\nintros p Hp; exfalso; lia.\nreplace (_ - _)%R with (pred_pos (-x)).\nnow apply generic_format_pred_pos; [|lra].\nnow unfold pred_pos; rewrite Req_bool_false."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F (- x)) (Nx : (x < 0)%R) : F (- x - ulp (- x)).","proofString":"destruct (Req_dec (-x) (bpow (mag beta (-x) - 1))) as [Hx|Hx].\nunfold ulp; rewrite Req_bool_false; [|lra].\nrewrite Hx at 1.\nunfold cexp.\nset (e := mag _ _).\nassert (Hfe : (fexp e < e)%Z).\nnow apply mag_generic_gt; [|lra|].\nreplace (e - 1)%Z with (e - 1 - fexp e + fexp e)%Z by ring.\nrewrite bpow_plus.\nset (m := bpow (_ - _)).\nreplace (_ - _)%R with ((m - 1) * bpow (fexp e))%R; [|unfold m; ring].\ncase_eq (e - 1 - fexp e)%Z.\nintro He; unfold m; rewrite He; simpl; ring_simplify (1 - 1)%R.\nrewrite Rmult_0_l; apply generic_format_0.\nintros p Hp; unfold m; rewrite Hp; simpl.\npose (f := {| Defs.Fnum := (Z.pow_pos beta p - 1)%Z;                  Defs.Fexp := fexp e |} : Defs.float beta).\napply (generic_format_F2R' _ _ _ f); [|intro Hm'; unfold f; simpl].\nnow unfold Defs.F2R; simpl; rewrite minus_IZR.\nunfold cexp.\nreplace (IZR _) with (bpow (Z.pos p)); [|now simpl].\nrewrite <-Hp.\nassert (He : (1 <= e - 1 - fexp e)%Z); [lia|].\nset (e' := mag _ (_ * _)).\nassert (H : (e' = e - 1 :> Z)%Z); [|rewrite H; apply Mexp; lia].\nunfold e'; apply mag_unique.\nrewrite Rabs_mult, (Rabs_pos_eq (bpow _)); [|apply bpow_ge_0].\nrewrite Rabs_pos_eq;      [|apply (Rplus_le_reg_r 1); ring_simplify;        change 1%R with (bpow 0); apply bpow_le; lia].\nassert (beta_pos : (0 < IZR beta)%R).\napply (Rlt_le_trans _ 2); [lra|].\napply IZR_le, Z.leb_le, radix_prop.\nsplit.\nreplace (e - 1 - 1)%Z with (e - 1 - fexp e + -1  + fexp e)%Z by ring.\nrewrite bpow_plus.\napply Rmult_le_compat_r; [apply bpow_ge_0|].\nrewrite bpow_plus; simpl; unfold Z.pow_pos; simpl.\nrewrite Zmult_1_r.\napply (Rmult_le_reg_r _ _ _ beta_pos).\nrewrite Rmult_assoc, Rinv_l; [|lra]; rewrite Rmult_1_r.\napply (Rplus_le_reg_r (IZR beta)); ring_simplify.\napply (Rle_trans _ (2 * bpow (e - 1 - fexp e))).\nchange 2%R with (1 + 1)%R; rewrite Rmult_plus_distr_r, Rmult_1_l.\napply Rplus_le_compat_l.\nrewrite <-bpow_1; apply bpow_le; lia.\nrewrite Rmult_comm; apply Rmult_le_compat_l; [apply bpow_ge_0|].\napply IZR_le, Z.leb_le, radix_prop.\napply (Rmult_lt_reg_r (bpow (- fexp e))); [apply bpow_gt_0|].\nrewrite Rmult_assoc, <-!bpow_plus.\nreplace (fexp e + - fexp e)%Z with 0%Z by ring; simpl.\nrewrite Rmult_1_r; unfold Zminus; lra.\nintros p Hp; exfalso; lia.\nreplace (_ - _)%R with (pred_pos (-x)).\nnow apply generic_format_pred_pos; [|lra].\nnow unfold pred_pos; rewrite Req_bool_false."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F (- x)) (Nx : (x < 0)%R) (Hx : (- x)%R = bpow (mag beta (- x) - 1)) (e : mag_prop beta (- x)) (Hfe : (fexp e < e)%Z) (m : R) (He : (e - 1 - fexp e)%Z = 0%Z) : F (0 * bpow (fexp e)).","proofString":"rewrite Rmult_0_l; apply generic_format_0."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F (- x)) (Nx : (x < 0)%R) (Hx : (- x)%R = bpow (mag beta (- x) - 1)) (e : mag_prop beta (- x)) (Hfe : (fexp e < e)%Z) (m : R) (p : positive) (Hp : (e - 1 - fexp e)%Z = Z.pos p) (f : float beta) (Hm' : ((IZR (Z.pow_pos beta p) - 1) * bpow (fexp e))%R <> 0%R) (e' : mag_prop beta ((bpow (e - 1 - fexp e) - 1) * bpow (fexp e))) : (0 < IZR beta)%R.","proofString":"apply (Rlt_le_trans _ 2); [lra|].\napply IZR_le, Z.leb_le, radix_prop."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F (- x)) (Nx : (x < 0)%R) (Hx : (- x)%R = bpow (mag beta (- x) - 1)) (e : mag_prop beta (- x)) (Hfe : (fexp e < e)%Z) (m : R) (p : positive) (Hp : (e - 1 - fexp e)%Z = Z.pos p) (f : float beta) (Hm' : ((IZR (Z.pow_pos beta p) - 1) * bpow (fexp e))%R <> 0%R) (e' : mag_prop beta ((bpow (e - 1 - fexp e) - 1) * bpow (fexp e))) : (2 <= IZR beta)%R.","proofString":"apply IZR_le, Z.leb_le, radix_prop."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F (- x)) (Nx : (x < 0)%R) (Hx : (- x)%R = bpow (mag beta (- x) - 1)) (e : mag_prop beta (- x)) (Hfe : (fexp e < e)%Z) (m : R) (p : positive) (Hp : (e - 1 - fexp e)%Z = Z.pos p) (f : float beta) (Hm' : ((IZR (Z.pow_pos beta p) - 1) * bpow (fexp e))%R <> 0%R) (e' : mag_prop beta ((bpow (e - 1 - fexp e) - 1) * bpow (fexp e))) (beta_pos : (0 < IZR beta)%R) : (2 <= IZR beta)%R.","proofString":"apply IZR_le, Z.leb_le, radix_prop."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F (- x)) (Nx : (x < 0)%R) (Hx : (- x)%R = bpow (mag beta (- x) - 1)) (e : mag_prop beta (- x)) (Hfe : (fexp e < e)%Z) (m : R) (p : positive) (Hp : (e - 1 - fexp e)%Z = Z.pos p) (f : float beta) (Hm' : ((IZR (Z.pow_pos beta p) - 1) * bpow (fexp e))%R <> 0%R) (e' : mag_prop beta ((bpow (e - 1 - fexp e) - 1) * bpow (fexp e))) (beta_pos : (0 < IZR beta)%R) : ((bpow (e - 1 - fexp e) - 1) * bpow (fexp e) * bpow (- fexp e) <\n bpow (e - 1) * bpow (- fexp e))%R.","proofString":"rewrite Rmult_assoc, <-!bpow_plus.\nreplace (fexp e + - fexp e)%Z with 0%Z by ring; simpl.\nrewrite Rmult_1_r; unfold Zminus; lra."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F (- x)) (Nx : (x < 0)%R) (Hx : (- x)%R = bpow (mag beta (- x) - 1)) (e : mag_prop beta (- x)) (Hfe : (fexp e < e)%Z) (m : R) (p : positive) (Hp : (e - 1 - fexp e)%Z = Z.pos p) (f : float beta) (Hm' : ((IZR (Z.pow_pos beta p) - 1) * bpow (fexp e))%R <> 0%R) (e' : mag_prop beta ((bpow (e - 1 - fexp e) - 1) * bpow (fexp e))) (beta_pos : (0 < IZR beta)%R) : ((bpow (e - 1 - fexp e) - 1) * bpow (fexp e + - fexp e) <\n bpow (e - 1 + - fexp e))%R.","proofString":"replace (fexp e + - fexp e)%Z with 0%Z by ring; simpl.\nrewrite Rmult_1_r; unfold Zminus; lra."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F (- x)) (Nx : (x < 0)%R) (Hx : (- x)%R = bpow (mag beta (- x) - 1)) (e : mag_prop beta (- x)) (Hfe : (fexp e < e)%Z) (m : R) (p : positive) (Hp : (e - 1 - fexp e)%Z = Z.pos p) (f : float beta) (Hm' : ((IZR (Z.pow_pos beta p) - 1) * bpow (fexp e))%R <> 0%R) (e' : mag_prop beta ((bpow (e - 1 - fexp e) - 1) * bpow (fexp e))) (beta_pos : (0 < IZR beta)%R) : ((bpow (e - 1 - fexp e) - 1) * 1 < bpow (e - 1 + - fexp e))%R.","proofString":"rewrite Rmult_1_r; unfold Zminus; lra."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F (- x)) (Nx : (x < 0)%R) (Hx : (- x)%R <> bpow (mag beta (- x) - 1)) : F (pred_pos (- x)).","proofString":"now apply generic_format_pred_pos; [|lra]."},{"statement":"(Mexp : Monotone_exp fexp) (x : R) (Fx : F (- x)) (Nx : (x < 0)%R) (Hx : (- x)%R <> bpow (mag beta (- x) - 1)) : pred_pos (- x) = (- x - ulp (- x))%R.","proofString":"now unfold pred_pos; rewrite Req_bool_false."},{"statement":"(x y : R) (Fy : F y) (Hlt : (x < y)%R) : (x <= y)%R.","proofString":"now apply Rlt_le."},{"statement":"(x y : R) (Fy : F y) (Hlt : (y < x)%R) : (y <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(x : R) (Fx : F x) : (pred x <= x)%R.","proofString":"apply pred_le_id."},{"statement":"(x : R) (Fx : ~ F x) (H1 : negligible_exp = None) (H2 : forall n : Z, (fexp n < n)%Z) : x <> 0%R.","proofString":"intros L; apply Fx; rewrite L; apply generic_format_0."},{"statement":"(x : R) (Fx : ~ F x) (Zx : round beta fexp Zceil x = 0%R) : (exists n : Z, negligible_exp = Some n /\\ (n <= fexp n)%Z) ->\n(- match negligible_exp with\n   | Some n => bpow (fexp n)\n   | None => 0\n   end <= round beta fexp Zfloor x)%R.","proofString":"intros (n,(H1,Hn)); rewrite H1.\ncase (Rle_or_lt (- bpow (fexp n)) (round beta fexp Zfloor x)); trivial; intros K.\nabsurd (round beta fexp Zceil x <= - bpow (fexp n))%R.\napply Rlt_not_le.\nrewrite Zx, <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0.\napply round_UP_le_DN_lt; try assumption.\napply generic_format_opp, generic_format_bpow.\nnow apply valid_exp."},{"statement":"(x : R) (Fx : ~ F x) (Zx : round beta fexp Zceil x = 0%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) : (- bpow (fexp n) <= round beta fexp Zfloor x)%R.","proofString":"case (Rle_or_lt (- bpow (fexp n)) (round beta fexp Zfloor x)); trivial; intros K.\nabsurd (round beta fexp Zceil x <= - bpow (fexp n))%R.\napply Rlt_not_le.\nrewrite Zx, <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0.\napply round_UP_le_DN_lt; try assumption.\napply generic_format_opp, generic_format_bpow.\nnow apply valid_exp."},{"statement":"(x : R) (Fx : ~ F x) (Zx : round beta fexp Zceil x = 0%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) (K : (round beta fexp Zfloor x < - bpow (fexp n))%R) : (- bpow (fexp n) <= round beta fexp Zfloor x)%R.","proofString":"absurd (round beta fexp Zceil x <= - bpow (fexp n))%R.\napply Rlt_not_le.\nrewrite Zx, <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0.\napply round_UP_le_DN_lt; try assumption.\napply generic_format_opp, generic_format_bpow.\nnow apply valid_exp."},{"statement":"(x : R) (Fx : ~ F x) (Zx : round beta fexp Zceil x = 0%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) (K : (round beta fexp Zfloor x < - bpow (fexp n))%R) : ~ (round beta fexp Zceil x <= - bpow (fexp n))%R.","proofString":"apply Rlt_not_le.\nrewrite Zx, <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0."},{"statement":"(x : R) (Fx : ~ F x) (Zx : round beta fexp Zceil x = 0%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) (K : (round beta fexp Zfloor x < - bpow (fexp n))%R) : (- bpow (fexp n) < round beta fexp Zceil x)%R.","proofString":"rewrite Zx, <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0."},{"statement":"(x : R) (Fx : ~ F x) (Zx : round beta fexp Zceil x = 0%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) (K : (round beta fexp Zfloor x < - bpow (fexp n))%R) : (- bpow (fexp n) < - 0)%R.","proofString":"apply Ropp_lt_contravar, bpow_gt_0."},{"statement":"(x : R) (Fx : ~ F x) (Zx : round beta fexp Zceil x = 0%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) (K : (round beta fexp Zfloor x < - bpow (fexp n))%R) : (round beta fexp Zceil x <= - bpow (fexp n))%R.","proofString":"apply round_UP_le_DN_lt; try assumption.\napply generic_format_opp, generic_format_bpow.\nnow apply valid_exp."},{"statement":"(x : R) (Fx : ~ F x) (Zx : round beta fexp Zceil x = 0%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) (K : (round beta fexp Zfloor x < - bpow (fexp n))%R) : F (- bpow (fexp n)).","proofString":"apply generic_format_opp, generic_format_bpow.\nnow apply valid_exp."},{"statement":"(x : R) (Fx : ~ F x) (Zx : round beta fexp Zceil x = 0%R) (n : Z) (H1 : negligible_exp = Some n) (Hn : (n <= fexp n)%Z) (K : (round beta fexp Zfloor x < - bpow (fexp n))%R) : (fexp (fexp n + 1) <= fexp n)%Z.","proofString":"now apply valid_exp."},{"statement":"(x : R) (Fx : ~ F x) (Zx : round beta fexp Zceil x <> 0%R) : let u := round beta fexp Zceil x in (pred u < u)%R.","proofString":"now apply pred_lt_id."},{"statement":"(x : R) (Fx : ~ F x) (Zx : round beta fexp Zceil x <> 0%R) (Hup : let u := round beta fexp Zceil x in (pred u < u)%R) : F (pred (round beta fexp Zceil x)).","proofString":"apply generic_format_pred...\nnow apply round_UP_pt."},{"statement":"(x : R) (Fx : ~ F x) (Zx : round beta fexp Zceil x <> 0%R) (Hup : let u := round beta fexp Zceil x in (pred u < u)%R) : F (round beta fexp Zceil x).","proofString":"now apply round_UP_pt."},{"statement":"(x : R) : (round beta fexp Zceil x <= succ (round beta fexp Zfloor x))%R.","proofString":"rewrite <- (Ropp_involutive x).\nrewrite round_DN_opp, round_UP_opp, succ_opp.\napply Ropp_le_contravar.\napply pred_UP_le_DN."},{"statement":"(x : R) : (round beta fexp Zceil (- - x) <= succ (round beta fexp Zfloor (- - x)))%R.","proofString":"rewrite round_DN_opp, round_UP_opp, succ_opp.\napply Ropp_le_contravar.\napply pred_UP_le_DN."},{"statement":"(x : R) : (- round beta fexp Zfloor (- x) <= - pred (round beta fexp Zceil (- x)))%R.","proofString":"apply Ropp_le_contravar.\napply pred_UP_le_DN."},{"statement":"(x : R) : (pred (round beta fexp Zceil (- x)) <= round beta fexp Zfloor (- x))%R.","proofString":"apply pred_UP_le_DN."},{"statement":"(x : R) (Fx : ~ F x) : (pred (round beta fexp Zceil x) <= round beta fexp Zfloor x)%R.","proofString":"now apply pred_UP_le_DN."},{"statement":"(x : R) (Fx : ~ F x) : (round beta fexp Zfloor x < round beta fexp Zceil x)%R.","proofString":"pose proof round_DN_UP_lt _ _ _ Fx as HE.\nnow apply Rlt_trans with (1 := proj1 HE) (2 := proj2 HE)."},{"statement":"(x : R) (Fx : ~ F x) (HE : (round beta fexp Zfloor x < x < round beta fexp Zceil x)%R) : (round beta fexp Zfloor x < round beta fexp Zceil x)%R.","proofString":"now apply Rlt_trans with (1 := proj1 HE) (2 := proj2 HE)."},{"statement":"(x d : R) (Fd : F d) (Hxd1 : (d <= x)%R) (Hxd2 : (x < succ d)%R) (T1 : F (round beta fexp Zfloor x)) (T2 : (round beta fexp Zfloor x <= x)%R) (T3 : forall g : R, F g -> (g <= x)%R -> (g <= round beta fexp Zfloor x)%R) : (d <= round beta fexp Zfloor x)%R.","proofString":"now apply T3."},{"statement":"(x d : R) (Fd : F d) (Hxd1 : (d <= x)%R) (Hxd2 : (x < succ d)%R) (T1 : F (round beta fexp Zfloor x)) (T2 : (round beta fexp Zfloor x <= x)%R) (T3 : forall g : R, F g -> (g <= x)%R -> (g <= round beta fexp Zfloor x)%R) (NFx : ~ F x) : (x <= succ d)%R.","proofString":"now left."},{"statement":"(x u : R) (Fu : F u) (Hux : (pred u < x <= u)%R) : round beta fexp Zceil x = u.","proofString":"rewrite <- (Ropp_involutive (round beta fexp Zceil x)).\nrewrite <- round_DN_opp.\nrewrite <- (Ropp_involutive u).\napply f_equal.\napply round_DN_eq; try assumption.\nnow apply generic_format_opp.\nsplit;[now apply Ropp_le_contravar|idtac].\nrewrite succ_opp.\nnow apply Ropp_lt_contravar."},{"statement":"(x u : R) (Fu : F u) (Hux : (pred u < x <= u)%R) : (- - round beta fexp Zceil x)%R = u.","proofString":"rewrite <- round_DN_opp.\nrewrite <- (Ropp_involutive u).\napply f_equal.\napply round_DN_eq; try assumption.\nnow apply generic_format_opp.\nsplit;[now apply Ropp_le_contravar|idtac].\nrewrite succ_opp.\nnow apply Ropp_lt_contravar."},{"statement":"(x u : R) (Fu : F u) (Hux : (pred u < x <= u)%R) : (- round beta fexp Zfloor (- x))%R = u.","proofString":"rewrite <- (Ropp_involutive u).\napply f_equal.\napply round_DN_eq; try assumption.\nnow apply generic_format_opp.\nsplit;[now apply Ropp_le_contravar|idtac].\nrewrite succ_opp.\nnow apply Ropp_lt_contravar."},{"statement":"(x u : R) (Fu : F u) (Hux : (pred u < x <= u)%R) : (- round beta fexp Zfloor (- x))%R = (- - u)%R.","proofString":"apply f_equal.\napply round_DN_eq; try assumption.\nnow apply generic_format_opp.\nsplit;[now apply Ropp_le_contravar|idtac].\nrewrite succ_opp.\nnow apply Ropp_lt_contravar."},{"statement":"(x u : R) (Fu : F u) (Hux : (pred u < x <= u)%R) : round beta fexp Zfloor (- x) = (- u)%R.","proofString":"apply round_DN_eq; try assumption.\nnow apply generic_format_opp.\nsplit;[now apply Ropp_le_contravar|idtac].\nrewrite succ_opp.\nnow apply Ropp_lt_contravar."},{"statement":"(x u : R) (Fu : F u) (Hux : (pred u < x <= u)%R) : F (- u).","proofString":"now apply generic_format_opp."},{"statement":"(x u : R) (Fu : F u) (Hux : (pred u < x <= u)%R) : (- u <= - x < succ (- u))%R.","proofString":"split;[now apply Ropp_le_contravar|idtac].\nrewrite succ_opp.\nnow apply Ropp_lt_contravar."},{"statement":"(x u : R) (Fu : F u) (Hux : (pred u < x <= u)%R) : (- x < succ (- u))%R.","proofString":"rewrite succ_opp.\nnow apply Ropp_lt_contravar."},{"statement":"(x u : R) (Fu : F u) (Hux : (pred u < x <= u)%R) : (- x < - pred u)%R.","proofString":"now apply Ropp_lt_contravar."},{"statement":"(H : Exp_not_FTZ fexp) : negligible_exp = None /\\ (forall n : Z, (fexp n < n)%Z) ->\nulp (ulp 0) = ulp 0.","proofString":"intros (K1,K2).\nreplace (ulp 0) with 0%R at 1; try easy.\napply sym_eq; unfold ulp; rewrite Req_bool_true; try easy.\nnow rewrite K1."},{"statement":"(H : Exp_not_FTZ fexp) (K1 : negligible_exp = None) (K2 : forall n : Z, (fexp n < n)%Z) : ulp (ulp 0) = ulp 0.","proofString":"replace (ulp 0) with 0%R at 1; try easy.\napply sym_eq; unfold ulp; rewrite Req_bool_true; try easy.\nnow rewrite K1."},{"statement":"(H : Exp_not_FTZ fexp) (K1 : negligible_exp = None) (K2 : forall n : Z, (fexp n < n)%Z) : 0%R = ulp 0.","proofString":"apply sym_eq; unfold ulp; rewrite Req_bool_true; try easy.\nnow rewrite K1."},{"statement":"(H : Exp_not_FTZ fexp) (K1 : negligible_exp = None) (K2 : forall n : Z, (fexp n < n)%Z) : match negligible_exp with\n| Some n => bpow (fexp n)\n| None => 0%R\nend = 0%R.","proofString":"now rewrite K1."},{"statement":"(H : Exp_not_FTZ fexp) : (exists n : Z, negligible_exp = Some n /\\ (n <= fexp n)%Z) ->\nulp (ulp 0) = ulp 0.","proofString":"intros (n,(Hn1,Hn2)).\napply Rle_antisym.\nreplace (ulp 0) with (bpow (fexp n)).\nrewrite ulp_bpow.\napply bpow_le.\nnow apply valid_exp.\nunfold ulp; rewrite Req_bool_true; try easy.\nrewrite Hn1; easy.\nnow apply ulp_ge_ulp_0."},{"statement":"(H : Exp_not_FTZ fexp) (n : Z) (Hn1 : negligible_exp = Some n) (Hn2 : (n <= fexp n)%Z) : ulp (ulp 0) = ulp 0.","proofString":"apply Rle_antisym.\nreplace (ulp 0) with (bpow (fexp n)).\nrewrite ulp_bpow.\napply bpow_le.\nnow apply valid_exp.\nunfold ulp; rewrite Req_bool_true; try easy.\nrewrite Hn1; easy.\nnow apply ulp_ge_ulp_0."},{"statement":"(H : Exp_not_FTZ fexp) (n : Z) (Hn1 : negligible_exp = Some n) (Hn2 : (n <= fexp n)%Z) : (ulp (ulp 0) <= ulp 0)%R.","proofString":"replace (ulp 0) with (bpow (fexp n)).\nrewrite ulp_bpow.\napply bpow_le.\nnow apply valid_exp.\nunfold ulp; rewrite Req_bool_true; try easy.\nrewrite Hn1; easy."},{"statement":"(H : Exp_not_FTZ fexp) (n : Z) (Hn1 : negligible_exp = Some n) (Hn2 : (n <= fexp n)%Z) : (ulp (bpow (fexp n)) <= bpow (fexp n))%R.","proofString":"rewrite ulp_bpow.\napply bpow_le.\nnow apply valid_exp."},{"statement":"(H : Exp_not_FTZ fexp) (n : Z) (Hn1 : negligible_exp = Some n) (Hn2 : (n <= fexp n)%Z) : (bpow (fexp (fexp n + 1)) <= bpow (fexp n))%R.","proofString":"apply bpow_le.\nnow apply valid_exp."},{"statement":"(H : Exp_not_FTZ fexp) (n : Z) (Hn1 : negligible_exp = Some n) (Hn2 : (n <= fexp n)%Z) : (fexp (fexp n + 1) <= fexp n)%Z.","proofString":"now apply valid_exp."},{"statement":"(H : Exp_not_FTZ fexp) (n : Z) (Hn1 : negligible_exp = Some n) (Hn2 : (n <= fexp n)%Z) : bpow (fexp n) = ulp 0.","proofString":"unfold ulp; rewrite Req_bool_true; try easy.\nrewrite Hn1; easy."},{"statement":"(H : Exp_not_FTZ fexp) (n : Z) (Hn1 : negligible_exp = Some n) (Hn2 : (n <= fexp n)%Z) : bpow (fexp n) =\nmatch negligible_exp with\n| Some n0 => bpow (fexp n0)\n| None => 0%R\nend.","proofString":"rewrite Hn1; easy."},{"statement":"(H : Exp_not_FTZ fexp) (n : Z) (Hn1 : negligible_exp = Some n) (Hn2 : (n <= fexp n)%Z) : (ulp 0 <= ulp (ulp 0))%R.","proofString":"now apply ulp_ge_ulp_0."},{"statement":"(Not_FTZ_ : Exp_not_FTZ fexp) (rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : (x < 0)%R) : (0 < - x)%R.","proofString":"now apply Ropp_0_gt_lt_contravar."},{"statement":"(Not_FTZ_ : Exp_not_FTZ fexp) (rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : (x < 0)%R) : ulp (round beta fexp (Zrnd_opp rnd) (- x)) = ulp (- x) ->\nulp (round beta fexp rnd x) = ulp x \\/\nRabs (round beta fexp rnd x) = bpow (mag beta x).","proofString":"rewrite ulp_opp, <- ulp_opp.\nrewrite <- round_opp, Ropp_involutive.\nintros Y;now left."},{"statement":"(Not_FTZ_ : Exp_not_FTZ fexp) (rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : (x < 0)%R) : ulp (- round beta fexp (Zrnd_opp rnd) (- x)) = ulp x ->\nulp (round beta fexp rnd x) = ulp x \\/\nRabs (round beta fexp rnd x) = bpow (mag beta x).","proofString":"rewrite <- round_opp, Ropp_involutive.\nintros Y;now left."},{"statement":"(Not_FTZ_ : Exp_not_FTZ fexp) (rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : (x < 0)%R) : ulp (round beta fexp rnd x) = ulp x ->\nulp (round beta fexp rnd x) = ulp x \\/\nRabs (round beta fexp rnd x) = bpow (mag beta x).","proofString":"intros Y;now left."},{"statement":"(Not_FTZ_ : Exp_not_FTZ fexp) (rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : (x < 0)%R) (Y : round beta fexp (Zrnd_opp rnd) (- x) = bpow (mag beta x)) : (bpow (mag beta x) >= 0)%R.","proofString":"apply Rle_ge, bpow_ge_0."},{"statement":"(Not_FTZ_ : Exp_not_FTZ fexp) (rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : (x > 0)%R) : F 0.","proofString":"apply generic_format_0..."},{"statement":"(Not_FTZ_ : Exp_not_FTZ fexp) (rnd : R -> Z) (Zrnd : Valid_rnd rnd) (x : R) (Zx : (x > 0)%R) : (0 <= x)%R.","proofString":"now apply Rlt_le."},{"statement":"(rnd : R -> Z) (Vrnd : Valid_rnd rnd) (x : R) : (x <= succ (round beta fexp rnd x))%R.","proofString":"apply (Rle_trans _ (round beta fexp Raux.Zceil x)).\nnow apply round_UP_pt.\ndestruct (round_DN_or_UP beta fexp rnd x) as [Hr|Hr]; rewrite Hr.\nnow apply UP_le_succ_DN.\napply succ_ge_id."},{"statement":"(rnd : R -> Z) (Vrnd : Valid_rnd rnd) (x : R) : (x <= round beta fexp Zceil x)%R.","proofString":"now apply round_UP_pt."},{"statement":"(rnd : R -> Z) (Vrnd : Valid_rnd rnd) (x : R) : (round beta fexp Zceil x <= succ (round beta fexp rnd x))%R.","proofString":"destruct (round_DN_or_UP beta fexp rnd x) as [Hr|Hr]; rewrite Hr.\nnow apply UP_le_succ_DN.\napply succ_ge_id."},{"statement":"(rnd : R -> Z) (Vrnd : Valid_rnd rnd) (x : R) (Hr : round beta fexp rnd x = round beta fexp Zfloor x) : (round beta fexp Zceil x <= succ (round beta fexp Zfloor x))%R.","proofString":"now apply UP_le_succ_DN."},{"statement":"(rnd : R -> Z) (Vrnd : Valid_rnd rnd) (x : R) (Hr : round beta fexp rnd x = round beta fexp Zceil x) : (round beta fexp Zceil x <= succ (round beta fexp Zceil x))%R.","proofString":"apply succ_ge_id."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) : succ u = 0%R /\\ u = 0%R \\/ (u < succ u)%R.","proofString":"specialize (succ_ge_id u); intros P; destruct P as [P|P].\nnow right.\ncase (Req_dec u 0); intros Zu.\nleft; split; trivial.\nnow rewrite <- P.\nright; now apply succ_gt_id."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) (P : (u < succ u)%R) : succ u = 0%R /\\ u = 0%R \\/ (u < succ u)%R.","proofString":"now right."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) (P : u = succ u) : succ u = 0%R /\\ u = 0%R \\/ (u < succ u)%R.","proofString":"case (Req_dec u 0); intros Zu.\nleft; split; trivial.\nnow rewrite <- P.\nright; now apply succ_gt_id."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) (P : u = succ u) (Zu : u = 0%R) : succ u = 0%R /\\ u = 0%R \\/ (u < succ u)%R.","proofString":"left; split; trivial.\nnow rewrite <- P."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) (P : u = succ u) (Zu : u = 0%R) : succ u = 0%R.","proofString":"now rewrite <- P."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) (P : u = succ u) (Zu : u <> 0%R) : succ u = 0%R /\\ u = 0%R \\/ (u < succ u)%R.","proofString":"right; now apply succ_gt_id."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) (V1 : succ u = 0%R) (V2 : u = 0%R) : F 0.","proofString":"apply generic_format_0."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) (V1 : succ u = 0%R) (V2 : u = 0%R) : (v <= 0)%R.","proofString":"left; apply Rlt_le_trans with (1:=H).\nrewrite V1,V2; right; field."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) (V1 : succ u = 0%R) (V2 : u = 0%R) : ((u + succ u) / 2 <= 0)%R.","proofString":"rewrite V1,V2; right; field."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) (V : (u < succ u)%R) (T1 : (u < (u + succ u) / 2)%R) (T2 : ((u + succ u) / 2 < succ u)%R) : round beta fexp Zfloor ((u + succ u) / 2) = u.","proofString":"apply round_DN_eq; trivial.\nsplit; try left; assumption."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) (V : (u < succ u)%R) (T1 : (u < (u + succ u) / 2)%R) (T2 : ((u + succ u) / 2 < succ u)%R) : (u <= (u + succ u) / 2 < succ u)%R.","proofString":"split; try left; assumption."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) (V : (u < succ u)%R) (T1 : (u < (u + succ u) / 2)%R) (T2 : ((u + succ u) / 2 < succ u)%R) : (pred (succ u) < (u + succ u) / 2 <= succ u)%R.","proofString":"rewrite pred_succ; trivial.\nsplit; try left; assumption."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) (V : (u < succ u)%R) (T1 : (u < (u + succ u) / 2)%R) (T2 : ((u + succ u) / 2 < succ u)%R) : (u < (u + succ u) / 2 <= succ u)%R.","proofString":"split; try left; assumption."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : (v < (u + succ u) / 2)%R) (V : (u < succ u)%R) (T1 : (u < (u + succ u) / 2)%R) (T2 : ((u + succ u) / 2 < succ u)%R) : ((u + succ u) / 2 - u <= succ u - (u + succ u) / 2)%R.","proofString":"right; field."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : ((u + pred u) / 2 < v)%R) : (u <= round beta fexp (Znearest choice) v)%R.","proofString":"rewrite <- (Ropp_involutive v).\nrewrite round_N_opp.\nrewrite <- (Ropp_involutive u).\napply Ropp_le_contravar.\napply round_N_le_midp.\nnow apply generic_format_opp.\napply Ropp_lt_cancel.\nrewrite Ropp_involutive.\napply Rle_lt_trans with (2:=H).\nunfold pred.\nright; field."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : ((u + pred u) / 2 < v)%R) : (u <= round beta fexp (Znearest choice) (- - v))%R.","proofString":"rewrite round_N_opp.\nrewrite <- (Ropp_involutive u).\napply Ropp_le_contravar.\napply round_N_le_midp.\nnow apply generic_format_opp.\napply Ropp_lt_cancel.\nrewrite Ropp_involutive.\napply Rle_lt_trans with (2:=H).\nunfold pred.\nright; field."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : ((u + pred u) / 2 < v)%R) : (u <=\n -\n round beta fexp (Znearest (fun t : Z => negb (choice (- (t + 1))%Z))) (- v))%R.","proofString":"rewrite <- (Ropp_involutive u).\napply Ropp_le_contravar.\napply round_N_le_midp.\nnow apply generic_format_opp.\napply Ropp_lt_cancel.\nrewrite Ropp_involutive.\napply Rle_lt_trans with (2:=H).\nunfold pred.\nright; field."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : ((u + pred u) / 2 < v)%R) : (- - u <=\n -\n round beta fexp (Znearest (fun t : Z => negb (choice (- (t + 1))%Z))) (- v))%R.","proofString":"apply Ropp_le_contravar.\napply round_N_le_midp.\nnow apply generic_format_opp.\napply Ropp_lt_cancel.\nrewrite Ropp_involutive.\napply Rle_lt_trans with (2:=H).\nunfold pred.\nright; field."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : ((u + pred u) / 2 < v)%R) : (round beta fexp (Znearest (fun t : Z => negb (choice (- (t + 1))%Z))) (- v) <=\n - u)%R.","proofString":"apply round_N_le_midp.\nnow apply generic_format_opp.\napply Ropp_lt_cancel.\nrewrite Ropp_involutive.\napply Rle_lt_trans with (2:=H).\nunfold pred.\nright; field."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : ((u + pred u) / 2 < v)%R) : F (- u).","proofString":"now apply generic_format_opp."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : ((u + pred u) / 2 < v)%R) : (- v < (- u + succ (- u)) / 2)%R.","proofString":"apply Ropp_lt_cancel.\nrewrite Ropp_involutive.\napply Rle_lt_trans with (2:=H).\nunfold pred.\nright; field."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : ((u + pred u) / 2 < v)%R) : (- ((- u + succ (- u)) / 2) < - - v)%R.","proofString":"rewrite Ropp_involutive.\napply Rle_lt_trans with (2:=H).\nunfold pred.\nright; field."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : ((u + pred u) / 2 < v)%R) : (- ((- u + succ (- u)) / 2) < v)%R.","proofString":"apply Rle_lt_trans with (2:=H).\nunfold pred.\nright; field."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : ((u + pred u) / 2 < v)%R) : (- ((- u + succ (- u)) / 2) <= (u + pred u) / 2)%R.","proofString":"unfold pred.\nright; field."},{"statement":"(choice : Z -> bool) (u v : R) (Fu : F u) (H : ((u + pred u) / 2 < v)%R) : (- ((- u + succ (- u)) / 2) <= (u + - succ (- u)) / 2)%R.","proofString":"right; field."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (H2 : (u <= round beta fexp (Znearest choice) v)%R) (Zu : u = 0%R) : u = 0%R /\\ negligible_exp = None \\/ (pred u < u)%R.","proofString":"case_eq (negligible_exp).\nintros n Hn; right.\nrewrite Zu, pred_0.\nunfold ulp; rewrite Req_bool_true, Hn; try easy.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0.\nintros _; left; split; easy."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (H2 : (u <= round beta fexp (Znearest choice) v)%R) (Zu : u = 0%R) : forall z : Z,\nnegligible_exp = Some z -> u = 0%R /\\ Some z = None \\/ (pred u < u)%R.","proofString":"intros n Hn; right.\nrewrite Zu, pred_0.\nunfold ulp; rewrite Req_bool_true, Hn; try easy.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (H2 : (u <= round beta fexp (Znearest choice) v)%R) (Zu : u = 0%R) (n : Z) (Hn : negligible_exp = Some n) : (pred u < u)%R.","proofString":"rewrite Zu, pred_0.\nunfold ulp; rewrite Req_bool_true, Hn; try easy.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (H2 : (u <= round beta fexp (Znearest choice) v)%R) (Zu : u = 0%R) (n : Z) (Hn : negligible_exp = Some n) : (- ulp 0 < 0)%R.","proofString":"unfold ulp; rewrite Req_bool_true, Hn; try easy.\nrewrite <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (H2 : (u <= round beta fexp (Znearest choice) v)%R) (Zu : u = 0%R) (n : Z) (Hn : negligible_exp = Some n) : (- bpow (fexp n) < 0)%R.","proofString":"rewrite <- Ropp_0.\napply Ropp_lt_contravar, bpow_gt_0."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (H2 : (u <= round beta fexp (Znearest choice) v)%R) (Zu : u = 0%R) (n : Z) (Hn : negligible_exp = Some n) : (- bpow (fexp n) < - 0)%R.","proofString":"apply Ropp_lt_contravar, bpow_gt_0."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (K : u = 0%R /\\ negligible_exp = None \\/ (pred u < u)%R) (K1 : u = 0%R) (K2 : negligible_exp = None) (H3 : (v < 0)%R) : F 0.","proofString":"apply generic_format_0..."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (K : u = 0%R /\\ negligible_exp = None \\/ (pred u < u)%R) (K1 : u = 0%R) (K2 : negligible_exp = None) (H3 : (v < 0)%R) : (v <= 0)%R.","proofString":"now left."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (H2 : (u <= round beta fexp (Znearest choice) v)%R) (K : u = 0%R /\\ negligible_exp = None \\/ (pred u < u)%R) (K1 : (pred u < u)%R) (H3 : (v < (u + pred u) / 2)%R) : (v < (pred u + u) / 2)%R.","proofString":"apply Rlt_le_trans with (1:=H3).\nright; f_equal; ring."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (H2 : (u <= round beta fexp (Znearest choice) v)%R) (K : u = 0%R /\\ negligible_exp = None \\/ (pred u < u)%R) (K1 : (pred u < u)%R) (H3 : (v < (u + pred u) / 2)%R) : ((u + pred u) / 2 <= (pred u + u) / 2)%R.","proofString":"right; f_equal; ring."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (H2 : (round beta fexp (Znearest choice) v <= u)%R) : (- ((u + succ u) / 2) <= (- u + pred (- u)) / 2)%R.","proofString":"rewrite pred_opp; right; field."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (H2 : (round beta fexp (Znearest choice) v <= u)%R) : (- u <=\n round beta fexp (Znearest (fun t : Z => negb (choice (- (t + 1))%Z))) (- v))%R.","proofString":"rewrite <- (Ropp_involutive (round _ _ _ _)).\nrewrite <- round_N_opp, Ropp_involutive.\napply Ropp_le_contravar; easy."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (H2 : (round beta fexp (Znearest choice) v <= u)%R) : (- u <=\n -\n -\n round beta fexp (Znearest (fun t : Z => negb (choice (- (t + 1))%Z))) (- v))%R.","proofString":"rewrite <- round_N_opp, Ropp_involutive.\napply Ropp_le_contravar; easy."},{"statement":"(choice : Z -> bool) (u v : R) (Hu : F u) (H2 : (round beta fexp (Znearest choice) v <= u)%R) : (- u <= - round beta fexp (Znearest choice) v)%R.","proofString":"apply Ropp_le_contravar; easy."},{"statement":"(Hm : Monotone_exp fexp) (choice1 choice2 : Z -> bool) (x : R) : let rx := round beta fexp (Znearest choice2) x in\n(x <= round beta fexp (Znearest choice1) (rx + ulp rx))%R.","proofString":"simpl.\nset (rx := round _ _ _ x).\nassert (Vrnd1 : Valid_rnd (Znearest choice1)) by now apply valid_rnd_N.\nassert (Vrnd2 : Valid_rnd (Znearest choice2)) by now apply valid_rnd_N.\napply (Rle_trans _ (succ rx)); [now apply succ_round_ge_id|].\nrewrite round_generic; [now apply succ_le_plus_ulp|now simpl|].\nnow apply generic_format_plus_ulp, generic_format_round."},{"statement":"(Hm : Monotone_exp fexp) (choice1 choice2 : Z -> bool) (x : R) : (x <=\n round beta fexp (Znearest choice1)\n   (round beta fexp (Znearest choice2) x +\n    ulp (round beta fexp (Znearest choice2) x)))%R.","proofString":"set (rx := round _ _ _ x).\nassert (Vrnd1 : Valid_rnd (Znearest choice1)) by now apply valid_rnd_N.\nassert (Vrnd2 : Valid_rnd (Znearest choice2)) by now apply valid_rnd_N.\napply (Rle_trans _ (succ rx)); [now apply succ_round_ge_id|].\nrewrite round_generic; [now apply succ_le_plus_ulp|now simpl|].\nnow apply generic_format_plus_ulp, generic_format_round."}]}