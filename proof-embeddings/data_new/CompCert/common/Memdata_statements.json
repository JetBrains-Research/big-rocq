{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Memdata.v","fileSamples":[{"statement":"(chunk : memory_chunk) : size_chunk chunk > 0.","conclusion":"size_chunk chunk > 0","hypotheses":"(chunk : memory_chunk)","proofString":"destruct chunk; simpl; lia."},{"statement":"(chunk : memory_chunk) : size_chunk chunk = Z.of_nat (size_chunk_nat chunk).","conclusion":"size_chunk chunk = Z.of_nat (size_chunk_nat chunk)","hypotheses":"(chunk : memory_chunk)","proofString":"destruct chunk; reflexivity."},{"statement":"(chunk : memory_chunk) : exists n : nat, size_chunk_nat chunk = S n.","conclusion":"exists n : nat, size_chunk_nat chunk = S n","hypotheses":"(chunk : memory_chunk)","proofString":"generalize (size_chunk_pos chunk).\nrewrite size_chunk_conv.\ndestruct (size_chunk_nat chunk).\nsimpl; intros; extlia.\nintros; exists n; auto."},{"statement":"(chunk : memory_chunk) : size_chunk chunk > 0 -> exists n : nat, size_chunk_nat chunk = S n.","conclusion":"size_chunk chunk > 0 -> exists n : nat, size_chunk_nat chunk = S n","hypotheses":"(chunk : memory_chunk)","proofString":"rewrite size_chunk_conv.\ndestruct (size_chunk_nat chunk).\nsimpl; intros; extlia.\nintros; exists n; auto."},{"statement":"(chunk : memory_chunk) : Z.of_nat (size_chunk_nat chunk) > 0 ->\nexists n : nat, size_chunk_nat chunk = S n.","conclusion":"Z.of_nat (size_chunk_nat chunk) > 0 ->\nexists n : nat, size_chunk_nat chunk = S n","hypotheses":"(chunk : memory_chunk)","proofString":"destruct (size_chunk_nat chunk).\nsimpl; intros; extlia.\nintros; exists n; auto."},{"statement":"(chunk : memory_chunk) : Z.of_nat 0 > 0 -> exists n : nat, 0%nat = S n.","conclusion":"Z.of_nat 0 > 0 -> exists n : nat, 0%nat = S n","hypotheses":"(chunk : memory_chunk)","proofString":"simpl; intros; extlia."},{"statement":"(chunk : memory_chunk) (n : nat) : Z.of_nat (S n) > 0 -> exists n0 : nat, S n = S n0.","conclusion":"Z.of_nat (S n) > 0 -> exists n0 : nat, S n = S n0","hypotheses":"(chunk : memory_chunk) (n : nat)","proofString":"intros; exists n; auto."},{"statement":"(chunk : memory_chunk) : align_chunk chunk > 0.","conclusion":"align_chunk chunk > 0","hypotheses":"(chunk : memory_chunk)","proofString":"destruct chunk; simpl; lia."},{"statement":"(chunk : memory_chunk) : (align_chunk chunk | size_chunk chunk).","conclusion":"(align_chunk chunk | size_chunk chunk)","hypotheses":"(chunk : memory_chunk)","proofString":"destruct chunk; simpl; try apply Z.divide_refl; exists 2; auto."},{"statement":"(chunk1 chunk2 : memory_chunk) (H : align_chunk chunk1 <= align_chunk chunk2) : (align_chunk chunk1 | align_chunk chunk2).","conclusion":"(align_chunk chunk1 | align_chunk chunk2)","hypotheses":"(chunk1 chunk2 : memory_chunk) (H : align_chunk chunk1 <= align_chunk chunk2)","proofString":"destruct chunk1; destruct chunk2; simpl in *;  solve [ extlia        | apply Z.divide_refl        | exists 2; reflexivity        | exists 4; reflexivity        | exists 8; reflexivity ]."},{"statement":"(q : quantity) : exists n : nat, size_quantity_nat q = S n.","conclusion":"exists n : nat, size_quantity_nat q = S n","hypotheses":"(q : quantity)","proofString":"destruct q; [exists 3%nat | exists 7%nat]; auto."},{"statement":"(x : Z) : 0%nat = 0%nat.","conclusion":"0%nat = 0%nat","hypotheses":"(x : Z)","proofString":"auto."},{"statement":"(n : nat) (IHn : forall x0 : Z, Datatypes.length (bytes_of_int n x0) = n) (x : Z) : S (Datatypes.length (bytes_of_int n (x / 256))) = S n.","conclusion":"S (Datatypes.length (bytes_of_int n (x / 256))) = S n","hypotheses":"(n : nat) (IHn : forall x0 : Z, Datatypes.length (bytes_of_int n x0) = n) (x : Z)","proofString":"decEq.\nauto."},{"statement":"(n : nat) (IHn : forall x0 : Z, Datatypes.length (bytes_of_int n x0) = n) (x : Z) : Datatypes.length (bytes_of_int n (x / 256)) = n.","conclusion":"Datatypes.length (bytes_of_int n (x / 256)) = n","hypotheses":"(n : nat) (IHn : forall x0 : Z, Datatypes.length (bytes_of_int n x0) = n) (x : Z)","proofString":"auto."},{"statement":"(l : list byte) : Datatypes.length (rev l) = Datatypes.length l.","conclusion":"Datatypes.length (rev l) = Datatypes.length l","hypotheses":"(l : list byte)","proofString":"apply List.rev_length."},{"statement":"(l : list byte) : Datatypes.length l = Datatypes.length l.","conclusion":"Datatypes.length l = Datatypes.length l","hypotheses":"(l : list byte)","proofString":"auto."},{"statement":"(sz : nat) (x : Z) : Datatypes.length (encode_int sz x) = sz.","conclusion":"Datatypes.length (encode_int sz x) = sz","hypotheses":"(sz : nat) (x : Z)","proofString":"unfold encode_int.\nrewrite rev_if_be_length.\napply length_bytes_of_int."},{"statement":"(sz : nat) (x : Z) : Datatypes.length (rev_if_be (bytes_of_int sz x)) = sz.","conclusion":"Datatypes.length (rev_if_be (bytes_of_int sz x)) = sz","hypotheses":"(sz : nat) (x : Z)","proofString":"rewrite rev_if_be_length.\napply length_bytes_of_int."},{"statement":"(sz : nat) (x : Z) : Datatypes.length (bytes_of_int sz x) = sz.","conclusion":"Datatypes.length (bytes_of_int sz x) = sz","hypotheses":"(sz : nat) (x : Z)","proofString":"apply length_bytes_of_int."},{"statement":"(l : list byte) : rev (rev l) = l.","conclusion":"rev (rev l) = l","hypotheses":"(l : list byte)","proofString":"apply List.rev_involutive."},{"statement":"(l : list byte) : l = l.","conclusion":"l = l","hypotheses":"(l : list byte)","proofString":"auto."},{"statement":"(n : nat) (x : Z) : int_of_bytes (rev_if_be (rev_if_be (bytes_of_int n x))) =\nx mod two_p (Z.of_nat n * 8).","conclusion":"int_of_bytes (rev_if_be (rev_if_be (bytes_of_int n x))) =\nx mod two_p (Z.of_nat n * 8)","hypotheses":"(n : nat) (x : Z)","proofString":"rewrite rev_if_be_involutive.\napply int_of_bytes_of_int."},{"statement":"(n : nat) (x : Z) : int_of_bytes (bytes_of_int n x) = x mod two_p (Z.of_nat n * 8).","conclusion":"int_of_bytes (bytes_of_int n x) = x mod two_p (Z.of_nat n * 8)","hypotheses":"(n : nat) (x : Z)","proofString":"apply int_of_bytes_of_int."},{"statement":"(x : int) : Int.repr (decode_int (encode_int 1 (Int.unsigned x))) = Int.zero_ext 8 x.","conclusion":"Int.repr (decode_int (encode_int 1 (Int.unsigned x))) = Int.zero_ext 8 x","hypotheses":"(x : int)","proofString":"rewrite decode_encode_int.\nrewrite <- (Int.repr_unsigned (Int.zero_ext 8 x)).\ndecEq.\nsymmetry.\napply Int.zero_ext_mod.\ncompute.\nintuition congruence."},{"statement":"(x : int) : Int.repr (Int.unsigned x mod two_p (Z.of_nat 1 * 8)) = Int.zero_ext 8 x.","conclusion":"Int.repr (Int.unsigned x mod two_p (Z.of_nat 1 * 8)) = Int.zero_ext 8 x","hypotheses":"(x : int)","proofString":"rewrite <- (Int.repr_unsigned (Int.zero_ext 8 x)).\ndecEq.\nsymmetry.\napply Int.zero_ext_mod.\ncompute.\nintuition congruence."},{"statement":"(x : int) : Int.repr (Int.unsigned x mod two_p (Z.of_nat 1 * 8)) =\nInt.repr (Int.unsigned (Int.zero_ext 8 x)).","conclusion":"Int.repr (Int.unsigned x mod two_p (Z.of_nat 1 * 8)) =\nInt.repr (Int.unsigned (Int.zero_ext 8 x))","hypotheses":"(x : int)","proofString":"decEq.\nsymmetry.\napply Int.zero_ext_mod.\ncompute.\nintuition congruence."},{"statement":"(x : int) : Int.unsigned x mod two_p (Z.of_nat 1 * 8) = Int.unsigned (Int.zero_ext 8 x).","conclusion":"Int.unsigned x mod two_p (Z.of_nat 1 * 8) = Int.unsigned (Int.zero_ext 8 x)","hypotheses":"(x : int)","proofString":"symmetry.\napply Int.zero_ext_mod.\ncompute.\nintuition congruence."},{"statement":"(x : int) : Int.unsigned (Int.zero_ext 8 x) = Int.unsigned x mod two_p (Z.of_nat 1 * 8).","conclusion":"Int.unsigned (Int.zero_ext 8 x) = Int.unsigned x mod two_p (Z.of_nat 1 * 8)","hypotheses":"(x : int)","proofString":"apply Int.zero_ext_mod.\ncompute.\nintuition congruence."},{"statement":"(x : int) : 0 <= Z.of_nat 1 * 8 < Int.zwordsize.","conclusion":"0 <= Z.of_nat 1 * 8 < Int.zwordsize","hypotheses":"(x : int)","proofString":"compute.\nintuition congruence."},{"statement":"(x : int) : (Lt = Gt -> False) /\\ Lt = Lt.","conclusion":"(Lt = Gt -> False) /\\ Lt = Lt","hypotheses":"(x : int)","proofString":"intuition congruence."},{"statement":"(x : int) : Int.repr (decode_int (encode_int 2 (Int.unsigned x))) = Int.zero_ext 16 x.","conclusion":"Int.repr (decode_int (encode_int 2 (Int.unsigned x))) = Int.zero_ext 16 x","hypotheses":"(x : int)","proofString":"rewrite decode_encode_int.\nrewrite <- (Int.repr_unsigned (Int.zero_ext 16 x)).\ndecEq.\nsymmetry.\napply Int.zero_ext_mod.\ncompute; intuition congruence."},{"statement":"(x : int) : Int.repr (Int.unsigned x mod two_p (Z.of_nat 2 * 8)) = Int.zero_ext 16 x.","conclusion":"Int.repr (Int.unsigned x mod two_p (Z.of_nat 2 * 8)) = Int.zero_ext 16 x","hypotheses":"(x : int)","proofString":"rewrite <- (Int.repr_unsigned (Int.zero_ext 16 x)).\ndecEq.\nsymmetry.\napply Int.zero_ext_mod.\ncompute; intuition congruence."},{"statement":"(x : int) : Int.repr (Int.unsigned x mod two_p (Z.of_nat 2 * 8)) =\nInt.repr (Int.unsigned (Int.zero_ext 16 x)).","conclusion":"Int.repr (Int.unsigned x mod two_p (Z.of_nat 2 * 8)) =\nInt.repr (Int.unsigned (Int.zero_ext 16 x))","hypotheses":"(x : int)","proofString":"decEq.\nsymmetry.\napply Int.zero_ext_mod.\ncompute; intuition congruence."},{"statement":"(x : int) : Int.unsigned x mod two_p (Z.of_nat 2 * 8) = Int.unsigned (Int.zero_ext 16 x).","conclusion":"Int.unsigned x mod two_p (Z.of_nat 2 * 8) = Int.unsigned (Int.zero_ext 16 x)","hypotheses":"(x : int)","proofString":"symmetry.\napply Int.zero_ext_mod.\ncompute; intuition congruence."},{"statement":"(x : int) : Int.unsigned (Int.zero_ext 16 x) = Int.unsigned x mod two_p (Z.of_nat 2 * 8).","conclusion":"Int.unsigned (Int.zero_ext 16 x) = Int.unsigned x mod two_p (Z.of_nat 2 * 8)","hypotheses":"(x : int)","proofString":"apply Int.zero_ext_mod.\ncompute; intuition congruence."},{"statement":"(x : int) : 0 <= Z.of_nat 2 * 8 < Int.zwordsize.","conclusion":"0 <= Z.of_nat 2 * 8 < Int.zwordsize","hypotheses":"(x : int)","proofString":"compute; intuition congruence."},{"statement":"(x : int) : Int.repr (decode_int (encode_int 4 (Int.unsigned x))) = x.","conclusion":"Int.repr (decode_int (encode_int 4 (Int.unsigned x))) = x","hypotheses":"(x : int)","proofString":"rewrite decode_encode_int.\ntransitivity (Int.repr (Int.unsigned x)).\ndecEq.\napply Z.mod_small.\napply Int.unsigned_range.\napply Int.repr_unsigned."},{"statement":"(x : int) : Int.repr (Int.unsigned x mod two_p (Z.of_nat 4 * 8)) = x.","conclusion":"Int.repr (Int.unsigned x mod two_p (Z.of_nat 4 * 8)) = x","hypotheses":"(x : int)","proofString":"transitivity (Int.repr (Int.unsigned x)).\ndecEq.\napply Z.mod_small.\napply Int.unsigned_range.\napply Int.repr_unsigned."},{"statement":"(x : int) : Int.repr (Int.unsigned x mod two_p (Z.of_nat 4 * 8)) =\nInt.repr (Int.unsigned x).","conclusion":"Int.repr (Int.unsigned x mod two_p (Z.of_nat 4 * 8)) =\nInt.repr (Int.unsigned x)","hypotheses":"(x : int)","proofString":"decEq.\napply Z.mod_small.\napply Int.unsigned_range."},{"statement":"(x : int) : Int.unsigned x mod two_p (Z.of_nat 4 * 8) = Int.unsigned x.","conclusion":"Int.unsigned x mod two_p (Z.of_nat 4 * 8) = Int.unsigned x","hypotheses":"(x : int)","proofString":"apply Z.mod_small.\napply Int.unsigned_range."},{"statement":"(x : int) : 0 <= Int.unsigned x < two_p (Z.of_nat 4 * 8).","conclusion":"0 <= Int.unsigned x < two_p (Z.of_nat 4 * 8)","hypotheses":"(x : int)","proofString":"apply Int.unsigned_range."},{"statement":"(x : int) : Int.repr (Int.unsigned x) = x.","conclusion":"Int.repr (Int.unsigned x) = x","hypotheses":"(x : int)","proofString":"apply Int.repr_unsigned."},{"statement":"(x : int64) : Int64.repr (decode_int (encode_int 8 (Int64.unsigned x))) = x.","conclusion":"Int64.repr (decode_int (encode_int 8 (Int64.unsigned x))) = x","hypotheses":"(x : int64)","proofString":"rewrite decode_encode_int.\ntransitivity (Int64.repr (Int64.unsigned x)).\ndecEq.\napply Z.mod_small.\napply Int64.unsigned_range.\napply Int64.repr_unsigned."},{"statement":"(x : int64) : Int64.repr (Int64.unsigned x mod two_p (Z.of_nat 8 * 8)) = x.","conclusion":"Int64.repr (Int64.unsigned x mod two_p (Z.of_nat 8 * 8)) = x","hypotheses":"(x : int64)","proofString":"transitivity (Int64.repr (Int64.unsigned x)).\ndecEq.\napply Z.mod_small.\napply Int64.unsigned_range.\napply Int64.repr_unsigned."},{"statement":"(x : int64) : Int64.repr (Int64.unsigned x mod two_p (Z.of_nat 8 * 8)) =\nInt64.repr (Int64.unsigned x).","conclusion":"Int64.repr (Int64.unsigned x mod two_p (Z.of_nat 8 * 8)) =\nInt64.repr (Int64.unsigned x)","hypotheses":"(x : int64)","proofString":"decEq.\napply Z.mod_small.\napply Int64.unsigned_range."},{"statement":"(x : int64) : Int64.unsigned x mod two_p (Z.of_nat 8 * 8) = Int64.unsigned x.","conclusion":"Int64.unsigned x mod two_p (Z.of_nat 8 * 8) = Int64.unsigned x","hypotheses":"(x : int64)","proofString":"apply Z.mod_small.\napply Int64.unsigned_range."},{"statement":"(x : int64) : 0 <= Int64.unsigned x < two_p (Z.of_nat 8 * 8).","conclusion":"0 <= Int64.unsigned x < two_p (Z.of_nat 8 * 8)","hypotheses":"(x : int64)","proofString":"apply Int64.unsigned_range."},{"statement":"(x : int64) : Int64.repr (Int64.unsigned x) = x.","conclusion":"Int64.repr (Int64.unsigned x) = x","hypotheses":"(x : int64)","proofString":"apply Int64.repr_unsigned."},{"statement":"forall x y : Z,\neqmod (two_p (Z.of_nat 0 * 8)) x y -> bytes_of_int 0 x = bytes_of_int 0 y.","conclusion":"forall x y : Z,\neqmod (two_p (Z.of_nat 0 * 8)) x y -> bytes_of_int 0 x = bytes_of_int 0 y","hypotheses":"","proofString":"intros; simpl; auto."},{"statement":"(n : nat) (IHn : forall x y : Z,\neqmod (two_p (Z.of_nat n * 8)) x y -> bytes_of_int n x = bytes_of_int n y) : forall x y : Z,\neqmod (two_p (Z.of_nat (S n) * 8)) x y ->\nbytes_of_int (S n) x = bytes_of_int (S n) y.","conclusion":"forall x y : Z,\neqmod (two_p (Z.of_nat (S n) * 8)) x y ->\nbytes_of_int (S n) x = bytes_of_int (S n) y","hypotheses":"(n : nat) (IHn : forall x y : Z,\neqmod (two_p (Z.of_nat n * 8)) x y -> bytes_of_int n x = bytes_of_int n y)","proofString":"intros until y.\nrewrite Nat2Z.inj_succ.\nreplace (Z.succ (Z.of_nat n) * 8) with (Z.of_nat n * 8 + 8) by lia.\nrewrite two_p_is_exp; try lia.\nintro EQM.\nsimpl; decEq.\napply Byte.eqm_samerepr.\nred.\neapply eqmod_divides; eauto.\napply Z.divide_factor_r.\napply IHn.\ndestruct EQM as [k EQ].\nexists k.\nrewrite EQ.\nrewrite <- Z_div_plus_full_l.\ndecEq.\nchange (two_p 8) with 256.\nring.\nlia."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) : eqmod (two_p (Z.of_nat (S n) * 8)) x y ->\nbytes_of_int (S n) x = bytes_of_int (S n) y.","conclusion":"eqmod (two_p (Z.of_nat (S n) * 8)) x y ->\nbytes_of_int (S n) x = bytes_of_int (S n) y","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z)","proofString":"rewrite Nat2Z.inj_succ.\nreplace (Z.succ (Z.of_nat n) * 8) with (Z.of_nat n * 8 + 8) by lia.\nrewrite two_p_is_exp; try lia.\nintro EQM.\nsimpl; decEq.\napply Byte.eqm_samerepr.\nred.\neapply eqmod_divides; eauto.\napply Z.divide_factor_r.\napply IHn.\ndestruct EQM as [k EQ].\nexists k.\nrewrite EQ.\nrewrite <- Z_div_plus_full_l.\ndecEq.\nchange (two_p 8) with 256.\nring.\nlia."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) : eqmod (two_p (Z.succ (Z.of_nat n) * 8)) x y ->\nbytes_of_int (S n) x = bytes_of_int (S n) y.","conclusion":"eqmod (two_p (Z.succ (Z.of_nat n) * 8)) x y ->\nbytes_of_int (S n) x = bytes_of_int (S n) y","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z)","proofString":"replace (Z.succ (Z.of_nat n) * 8) with (Z.of_nat n * 8 + 8) by lia.\nrewrite two_p_is_exp; try lia.\nintro EQM.\nsimpl; decEq.\napply Byte.eqm_samerepr.\nred.\neapply eqmod_divides; eauto.\napply Z.divide_factor_r.\napply IHn.\ndestruct EQM as [k EQ].\nexists k.\nrewrite EQ.\nrewrite <- Z_div_plus_full_l.\ndecEq.\nchange (two_p 8) with 256.\nring.\nlia."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) : eqmod (two_p (Z.of_nat n * 8 + 8)) x y ->\nbytes_of_int (S n) x = bytes_of_int (S n) y.","conclusion":"eqmod (two_p (Z.of_nat n * 8 + 8)) x y ->\nbytes_of_int (S n) x = bytes_of_int (S n) y","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z)","proofString":"rewrite two_p_is_exp; try lia.\nintro EQM.\nsimpl; decEq.\napply Byte.eqm_samerepr.\nred.\neapply eqmod_divides; eauto.\napply Z.divide_factor_r.\napply IHn.\ndestruct EQM as [k EQ].\nexists k.\nrewrite EQ.\nrewrite <- Z_div_plus_full_l.\ndecEq.\nchange (two_p 8) with 256.\nring.\nlia."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y ->\nbytes_of_int (S n) x = bytes_of_int (S n) y.","conclusion":"eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y ->\nbytes_of_int (S n) x = bytes_of_int (S n) y","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z)","proofString":"intro EQM.\nsimpl; decEq.\napply Byte.eqm_samerepr.\nred.\neapply eqmod_divides; eauto.\napply Z.divide_factor_r.\napply IHn.\ndestruct EQM as [k EQ].\nexists k.\nrewrite EQ.\nrewrite <- Z_div_plus_full_l.\ndecEq.\nchange (two_p 8) with 256.\nring.\nlia."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y) : bytes_of_int (S n) x = bytes_of_int (S n) y.","conclusion":"bytes_of_int (S n) x = bytes_of_int (S n) y","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y)","proofString":"simpl; decEq.\napply Byte.eqm_samerepr.\nred.\neapply eqmod_divides; eauto.\napply Z.divide_factor_r.\napply IHn.\ndestruct EQM as [k EQ].\nexists k.\nrewrite EQ.\nrewrite <- Z_div_plus_full_l.\ndecEq.\nchange (two_p 8) with 256.\nring.\nlia."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y) : Byte.repr x = Byte.repr y.","conclusion":"Byte.repr x = Byte.repr y","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y)","proofString":"apply Byte.eqm_samerepr.\nred.\neapply eqmod_divides; eauto.\napply Z.divide_factor_r."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y) : Byte.eqm x y.","conclusion":"Byte.eqm x y","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y)","proofString":"red.\neapply eqmod_divides; eauto.\napply Z.divide_factor_r."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y) : eqmod Byte.modulus x y.","conclusion":"eqmod Byte.modulus x y","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y)","proofString":"eapply eqmod_divides; eauto.\napply Z.divide_factor_r."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y) : (Byte.modulus | two_p (Z.of_nat n * 8) * two_p 8).","conclusion":"(Byte.modulus | two_p (Z.of_nat n * 8) * two_p 8)","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y)","proofString":"apply Z.divide_factor_r."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y) : bytes_of_int n (x / 256) = bytes_of_int n (y / 256).","conclusion":"bytes_of_int n (x / 256) = bytes_of_int n (y / 256)","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y)","proofString":"apply IHn.\ndestruct EQM as [k EQ].\nexists k.\nrewrite EQ.\nrewrite <- Z_div_plus_full_l.\ndecEq.\nchange (two_p 8) with 256.\nring.\nlia."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y) : eqmod (two_p (Z.of_nat n * 8)) (x / 256) (y / 256).","conclusion":"eqmod (two_p (Z.of_nat n * 8)) (x / 256) (y / 256)","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y : Z) (EQM : eqmod (two_p (Z.of_nat n * 8) * two_p 8) x y)","proofString":"destruct EQM as [k EQ].\nexists k.\nrewrite EQ.\nrewrite <- Z_div_plus_full_l.\ndecEq.\nchange (two_p 8) with 256.\nring.\nlia."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y) : eqmod (two_p (Z.of_nat n * 8)) (x / 256) (y / 256).","conclusion":"eqmod (two_p (Z.of_nat n * 8)) (x / 256) (y / 256)","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y)","proofString":"exists k.\nrewrite EQ.\nrewrite <- Z_div_plus_full_l.\ndecEq.\nchange (two_p 8) with 256.\nring.\nlia."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y) : x / 256 = k * two_p (Z.of_nat n * 8) + y / 256.","conclusion":"x / 256 = k * two_p (Z.of_nat n * 8) + y / 256","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y)","proofString":"rewrite EQ.\nrewrite <- Z_div_plus_full_l.\ndecEq.\nchange (two_p 8) with 256.\nring.\nlia."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y) : (k * (two_p (Z.of_nat n * 8) * two_p 8) + y) / 256 =\nk * two_p (Z.of_nat n * 8) + y / 256.","conclusion":"(k * (two_p (Z.of_nat n * 8) * two_p 8) + y) / 256 =\nk * two_p (Z.of_nat n * 8) + y / 256","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y)","proofString":"rewrite <- Z_div_plus_full_l.\ndecEq.\nchange (two_p 8) with 256.\nring.\nlia."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y) : (k * (two_p (Z.of_nat n * 8) * two_p 8) + y) / 256 =\n(k * two_p (Z.of_nat n * 8) * 256 + y) / 256.","conclusion":"(k * (two_p (Z.of_nat n * 8) * two_p 8) + y) / 256 =\n(k * two_p (Z.of_nat n * 8) * 256 + y) / 256","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y)","proofString":"decEq.\nchange (two_p 8) with 256.\nring."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y) : k * (two_p (Z.of_nat n * 8) * two_p 8) + y =\nk * two_p (Z.of_nat n * 8) * 256 + y.","conclusion":"k * (two_p (Z.of_nat n * 8) * two_p 8) + y =\nk * two_p (Z.of_nat n * 8) * 256 + y","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y)","proofString":"change (two_p 8) with 256.\nring."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y) : k * (two_p (Z.of_nat n * 8) * 256) + y = k * two_p (Z.of_nat n * 8) * 256 + y.","conclusion":"k * (two_p (Z.of_nat n * 8) * 256) + y = k * two_p (Z.of_nat n * 8) * 256 + y","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y)","proofString":"ring."},{"statement":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y) : 256 <> 0.","conclusion":"256 <> 0","hypotheses":"(n : nat) (IHn : forall x0 y0 : Z,\neqmod (two_p (Z.of_nat n * 8)) x0 y0 -> bytes_of_int n x0 = bytes_of_int n y0) (x y k : Z) (EQ : x = k * (two_p (Z.of_nat n * 8) * two_p 8) + y)","proofString":"lia."},{"statement":"(x y : Z) (H : eqmod (two_p 8) x y) : encode_int 1 x = encode_int 1 y.","conclusion":"encode_int 1 x = encode_int 1 y","hypotheses":"(x y : Z) (H : eqmod (two_p 8) x y)","proofString":"unfold encode_int.\ndecEq.\napply bytes_of_int_mod.\nauto."},{"statement":"(x y : Z) (H : eqmod (two_p 8) x y) : rev_if_be (bytes_of_int 1 x) = rev_if_be (bytes_of_int 1 y).","conclusion":"rev_if_be (bytes_of_int 1 x) = rev_if_be (bytes_of_int 1 y)","hypotheses":"(x y : Z) (H : eqmod (two_p 8) x y)","proofString":"decEq.\napply bytes_of_int_mod.\nauto."},{"statement":"(x y : Z) (H : eqmod (two_p 8) x y) : bytes_of_int 1 x = bytes_of_int 1 y.","conclusion":"bytes_of_int 1 x = bytes_of_int 1 y","hypotheses":"(x y : Z) (H : eqmod (two_p 8) x y)","proofString":"apply bytes_of_int_mod.\nauto."},{"statement":"(x y : Z) (H : eqmod (two_p 8) x y) : eqmod (two_p (Z.of_nat 1 * 8)) x y.","conclusion":"eqmod (two_p (Z.of_nat 1 * 8)) x y","hypotheses":"(x y : Z) (H : eqmod (two_p 8) x y)","proofString":"auto."},{"statement":"(x y : Z) (H : eqmod (two_p 16) x y) : encode_int 2 x = encode_int 2 y.","conclusion":"encode_int 2 x = encode_int 2 y","hypotheses":"(x y : Z) (H : eqmod (two_p 16) x y)","proofString":"unfold encode_int.\ndecEq.\napply bytes_of_int_mod.\nauto."},{"statement":"(x y : Z) (H : eqmod (two_p 16) x y) : rev_if_be (bytes_of_int 2 x) = rev_if_be (bytes_of_int 2 y).","conclusion":"rev_if_be (bytes_of_int 2 x) = rev_if_be (bytes_of_int 2 y)","hypotheses":"(x y : Z) (H : eqmod (two_p 16) x y)","proofString":"decEq.\napply bytes_of_int_mod.\nauto."},{"statement":"(x y : Z) (H : eqmod (two_p 16) x y) : bytes_of_int 2 x = bytes_of_int 2 y.","conclusion":"bytes_of_int 2 x = bytes_of_int 2 y","hypotheses":"(x y : Z) (H : eqmod (two_p 16) x y)","proofString":"apply bytes_of_int_mod.\nauto."},{"statement":"(x y : Z) (H : eqmod (two_p 16) x y) : eqmod (two_p (Z.of_nat 2 * 8)) x y.","conclusion":"eqmod (two_p (Z.of_nat 2 * 8)) x y","hypotheses":"(x y : Z) (H : eqmod (two_p 16) x y)","proofString":"auto."},{"statement":"(bl : list byte) : Datatypes.length (inj_bytes bl) = Datatypes.length bl.","conclusion":"Datatypes.length (inj_bytes bl) = Datatypes.length bl","hypotheses":"(bl : list byte)","proofString":"apply List.map_length."},{"statement":"(a : byte) (bl : list byte) (IHbl : proj_bytes (inj_bytes bl) = Some bl) : match proj_bytes (inj_bytes bl) with\n| Some bl0 => Some (a :: bl0)\n| None => None\nend = Some (a :: bl).","conclusion":"match proj_bytes (inj_bytes bl) with\n| Some bl0 => Some (a :: bl0)\n| None => None\nend = Some (a :: bl)","hypotheses":"(a : byte) (bl : list byte) (IHbl : proj_bytes (inj_bytes bl) = Some bl)","proofString":"rewrite IHbl.\nauto."},{"statement":"(a : byte) (bl : list byte) (IHbl : proj_bytes (inj_bytes bl) = Some bl) : Some (a :: bl) = Some (a :: bl).","conclusion":"Some (a :: bl) = Some (a :: bl)","hypotheses":"(a : byte) (bl : list byte) (IHbl : proj_bytes (inj_bytes bl) = Some bl)","proofString":"auto."},{"statement":"(bl : list byte) (H : Some nil = Some bl) : nil = inj_bytes bl.","conclusion":"nil = inj_bytes bl","hypotheses":"(bl : list byte) (H : Some nil = Some bl)","proofString":"inv H; auto."},{"statement":"(a : memval) (cl : list memval) (IHcl : forall bl0 : list byte, proj_bytes cl = Some bl0 -> cl = inj_bytes bl0) (bl : list byte) (H : match a with\n| Byte b =>\n    match proj_bytes cl with\n    | Some bl0 => Some (b :: bl0)\n    | None => None\n    end\n| _ => None\nend = Some bl) : a :: cl = inj_bytes bl.","conclusion":"a :: cl = inj_bytes bl","hypotheses":"(a : memval) (cl : list memval) (IHcl : forall bl0 : list byte, proj_bytes cl = Some bl0 -> cl = inj_bytes bl0) (bl : list byte) (H : match a with\n| Byte b =>\n    match proj_bytes cl with\n    | Some bl0 => Some (b :: bl0)\n    | None => None\n    end\n| _ => None\nend = Some bl)","proofString":"destruct a; try congruence.\ndestruct (proj_bytes cl); inv H.\nsimpl.\ndecEq.\nauto."},{"statement":"(i : byte) (cl : list memval) (IHcl : forall bl0 : list byte, proj_bytes cl = Some bl0 -> cl = inj_bytes bl0) (bl : list byte) (H : match proj_bytes cl with\n| Some bl0 => Some (i :: bl0)\n| None => None\nend = Some bl) : Byte i :: cl = inj_bytes bl.","conclusion":"Byte i :: cl = inj_bytes bl","hypotheses":"(i : byte) (cl : list memval) (IHcl : forall bl0 : list byte, proj_bytes cl = Some bl0 -> cl = inj_bytes bl0) (bl : list byte) (H : match proj_bytes cl with\n| Some bl0 => Some (i :: bl0)\n| None => None\nend = Some bl)","proofString":"destruct (proj_bytes cl); inv H.\nsimpl.\ndecEq.\nauto."},{"statement":"(i : byte) (cl : list memval) (l : list byte) (IHcl : forall bl : list byte, Some l = Some bl -> cl = inj_bytes bl) : Byte i :: cl = inj_bytes (i :: l).","conclusion":"Byte i :: cl = inj_bytes (i :: l)","hypotheses":"(i : byte) (cl : list memval) (l : list byte) (IHcl : forall bl : list byte, Some l = Some bl -> cl = inj_bytes bl)","proofString":"simpl.\ndecEq.\nauto."},{"statement":"(i : byte) (cl : list memval) (l : list byte) (IHcl : forall bl : list byte, Some l = Some bl -> cl = inj_bytes bl) : Byte i :: cl = Byte i :: inj_bytes l.","conclusion":"Byte i :: cl = Byte i :: inj_bytes l","hypotheses":"(i : byte) (cl : list memval) (l : list byte) (IHcl : forall bl : list byte, Some l = Some bl -> cl = inj_bytes bl)","proofString":"decEq.\nauto."},{"statement":"(i : byte) (cl : list memval) (l : list byte) (IHcl : forall bl : list byte, Some l = Some bl -> cl = inj_bytes bl) : cl = inj_bytes l.","conclusion":"cl = inj_bytes l","hypotheses":"(i : byte) (cl : list memval) (l : list byte) (IHcl : forall bl : list byte, Some l = Some bl -> cl = inj_bytes bl)","proofString":"auto."},{"statement":"(chunk : memory_chunk) (v : val) : Datatypes.length (encode_val chunk v) = size_chunk_nat chunk.","conclusion":"Datatypes.length (encode_val chunk v) = size_chunk_nat chunk","hypotheses":"(chunk : memory_chunk) (v : val)","proofString":"destruct v; simpl; destruct chunk; solve_encode_val_length."},{"statement":"(v : val) (q : quantity) : true = true.","conclusion":"true = true","hypotheses":"(v : val) (q : quantity)","proofString":"auto."},{"statement":"(v : val) (q : quantity) (n : nat) (IHn : check_value n v q (inj_value_rec n v q) = true) : Val.eq v v && quantity_eq q q && (n =? n)%nat &&\ncheck_value n v q (inj_value_rec n v q) = true.","conclusion":"Val.eq v v && quantity_eq q q && (n =? n)%nat &&\ncheck_value n v q (inj_value_rec n v q) = true","hypotheses":"(v : val) (q : quantity) (n : nat) (IHn : check_value n v q (inj_value_rec n v q) = true)","proofString":"unfold proj_sumbool.\nrewrite dec_eq_true.\nrewrite dec_eq_true.\nrewrite Nat.eqb_refl.\nsimpl; auto."},{"statement":"(v : val) (q : quantity) (n : nat) (IHn : check_value n v q (inj_value_rec n v q) = true) : (if Val.eq v v then true else false) &&\n(if quantity_eq q q then true else false) && (n =? n)%nat &&\ncheck_value n v q (inj_value_rec n v q) = true.","conclusion":"(if Val.eq v v then true else false) &&\n(if quantity_eq q q then true else false) && (n =? n)%nat &&\ncheck_value n v q (inj_value_rec n v q) = true","hypotheses":"(v : val) (q : quantity) (n : nat) (IHn : check_value n v q (inj_value_rec n v q) = true)","proofString":"rewrite dec_eq_true.\nrewrite dec_eq_true.\nrewrite Nat.eqb_refl.\nsimpl; auto."},{"statement":"(v : val) (q : quantity) (n : nat) (IHn : check_value n v q (inj_value_rec n v q) = true) : true && (if quantity_eq q q then true else false) && (n =? n)%nat &&\ncheck_value n v q (inj_value_rec n v q) = true.","conclusion":"true && (if quantity_eq q q then true else false) && (n =? n)%nat &&\ncheck_value n v q (inj_value_rec n v q) = true","hypotheses":"(v : val) (q : quantity) (n : nat) (IHn : check_value n v q (inj_value_rec n v q) = true)","proofString":"rewrite dec_eq_true.\nrewrite Nat.eqb_refl.\nsimpl; auto."},{"statement":"(v : val) (q : quantity) (n : nat) (IHn : check_value n v q (inj_value_rec n v q) = true) : true && true && (n =? n)%nat && check_value n v q (inj_value_rec n v q) =\ntrue.","conclusion":"true && true && (n =? n)%nat && check_value n v q (inj_value_rec n v q) =\ntrue","hypotheses":"(v : val) (q : quantity) (n : nat) (IHn : check_value n v q (inj_value_rec n v q) = true)","proofString":"rewrite Nat.eqb_refl.\nsimpl; auto."},{"statement":"(v : val) (q : quantity) (n : nat) (IHn : check_value n v q (inj_value_rec n v q) = true) : true && true && true && check_value n v q (inj_value_rec n v q) = true.","conclusion":"true && true && true && check_value n v q (inj_value_rec n v q) = true","hypotheses":"(v : val) (q : quantity) (n : nat) (IHn : check_value n v q (inj_value_rec n v q) = true)","proofString":"simpl; auto."},{"statement":"(q : quantity) (v : val) : proj_value q (inj_value q v) = v.","conclusion":"proj_value q (inj_value q v) = v","hypotheses":"(q : quantity) (v : val)","proofString":"unfold proj_value, inj_value.\ndestruct (size_quantity_nat_pos q) as [n EQ].\nrewrite EQ at 1.\nsimpl.\nrewrite check_inj_value.\nauto."},{"statement":"(q : quantity) (v : val) : match inj_value_rec (size_quantity_nat q) v q with\n| Fragment v0 _ _ :: _ =>\n    if\n     check_value (size_quantity_nat q) v0 q\n       (inj_value_rec (size_quantity_nat q) v q)\n    then v0\n    else Vundef\n| _ => Vundef\nend = v.","conclusion":"match inj_value_rec (size_quantity_nat q) v q with\n| Fragment v0 _ _ :: _ =>\n    if\n     check_value (size_quantity_nat q) v0 q\n       (inj_value_rec (size_quantity_nat q) v q)\n    then v0\n    else Vundef\n| _ => Vundef\nend = v","hypotheses":"(q : quantity) (v : val)","proofString":"destruct (size_quantity_nat_pos q) as [n EQ].\nrewrite EQ at 1.\nsimpl.\nrewrite check_inj_value.\nauto."},{"statement":"(q : quantity) (v : val) (n : nat) (EQ : size_quantity_nat q = S n) : match inj_value_rec (size_quantity_nat q) v q with\n| Fragment v0 _ _ :: _ =>\n    if\n     check_value (size_quantity_nat q) v0 q\n       (inj_value_rec (size_quantity_nat q) v q)\n    then v0\n    else Vundef\n| _ => Vundef\nend = v.","conclusion":"match inj_value_rec (size_quantity_nat q) v q with\n| Fragment v0 _ _ :: _ =>\n    if\n     check_value (size_quantity_nat q) v0 q\n       (inj_value_rec (size_quantity_nat q) v q)\n    then v0\n    else Vundef\n| _ => Vundef\nend = v","hypotheses":"(q : quantity) (v : val) (n : nat) (EQ : size_quantity_nat q = S n)","proofString":"rewrite EQ at 1.\nsimpl.\nrewrite check_inj_value.\nauto."},{"statement":"(q : quantity) (v : val) (n : nat) (EQ : size_quantity_nat q = S n) : match inj_value_rec (S n) v q with\n| Fragment v0 _ _ :: _ =>\n    if\n     check_value (size_quantity_nat q) v0 q\n       (inj_value_rec (size_quantity_nat q) v q)\n    then v0\n    else Vundef\n| _ => Vundef\nend = v.","conclusion":"match inj_value_rec (S n) v q with\n| Fragment v0 _ _ :: _ =>\n    if\n     check_value (size_quantity_nat q) v0 q\n       (inj_value_rec (size_quantity_nat q) v q)\n    then v0\n    else Vundef\n| _ => Vundef\nend = v","hypotheses":"(q : quantity) (v : val) (n : nat) (EQ : size_quantity_nat q = S n)","proofString":"simpl.\nrewrite check_inj_value.\nauto."},{"statement":"(q : quantity) (v : val) (n : nat) (EQ : size_quantity_nat q = S n) : (if\n  check_value (size_quantity_nat q) v q\n    (inj_value_rec (size_quantity_nat q) v q)\n then v\n else Vundef) = v.","conclusion":"(if\n  check_value (size_quantity_nat q) v q\n    (inj_value_rec (size_quantity_nat q) v q)\n then v\n else Vundef) = v","hypotheses":"(q : quantity) (v : val) (n : nat) (EQ : size_quantity_nat q = S n)","proofString":"rewrite check_inj_value.\nauto."},{"statement":"(q : quantity) (v : val) (n : nat) (EQ : size_quantity_nat q = S n) : v = v.","conclusion":"v = v","hypotheses":"(q : quantity) (v : val) (n : nat) (EQ : size_quantity_nat q = S n)","proofString":"auto."},{"statement":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) : proj_value q1 (inj_value q2 v) = Vundef.","conclusion":"proj_value q1 (inj_value q2 v) = Vundef","hypotheses":"(q1 q2 : quantity) (v : val) (H : q1 <> q2)","proofString":"unfold proj_value.\ndestruct (inj_value q2 v) eqn:V.\nauto.\ndestruct m; auto.\ndestruct (in_inj_value (Fragment v0 q n) v q2) as [n' EQ].\nrewrite V; auto with coqlib.\ninv EQ.\ndestruct (size_quantity_nat_pos q1) as [p EQ1]; rewrite EQ1; simpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\nrewrite dec_eq_false by congruence.\nauto."},{"statement":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) : match inj_value q2 v with\n| Fragment v0 _ _ :: _ =>\n    if check_value (size_quantity_nat q1) v0 q1 (inj_value q2 v)\n    then v0\n    else Vundef\n| _ => Vundef\nend = Vundef.","conclusion":"match inj_value q2 v with\n| Fragment v0 _ _ :: _ =>\n    if check_value (size_quantity_nat q1) v0 q1 (inj_value q2 v)\n    then v0\n    else Vundef\n| _ => Vundef\nend = Vundef","hypotheses":"(q1 q2 : quantity) (v : val) (H : q1 <> q2)","proofString":"destruct (inj_value q2 v) eqn:V.\nauto.\ndestruct m; auto.\ndestruct (in_inj_value (Fragment v0 q n) v q2) as [n' EQ].\nrewrite V; auto with coqlib.\ninv EQ.\ndestruct (size_quantity_nat_pos q1) as [p EQ1]; rewrite EQ1; simpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\nrewrite dec_eq_false by congruence.\nauto."},{"statement":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (V : inj_value q2 v = nil) : Vundef = Vundef.","conclusion":"Vundef = Vundef","hypotheses":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (V : inj_value q2 v = nil)","proofString":"auto."},{"statement":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (m : memval) (l : list memval) (V : inj_value q2 v = m :: l) : match m with\n| Fragment v0 _ _ =>\n    if check_value (size_quantity_nat q1) v0 q1 (m :: l) then v0 else Vundef\n| _ => Vundef\nend = Vundef.","conclusion":"match m with\n| Fragment v0 _ _ =>\n    if check_value (size_quantity_nat q1) v0 q1 (m :: l) then v0 else Vundef\n| _ => Vundef\nend = Vundef","hypotheses":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (m : memval) (l : list memval) (V : inj_value q2 v = m :: l)","proofString":"destruct m; auto.\ndestruct (in_inj_value (Fragment v0 q n) v q2) as [n' EQ].\nrewrite V; auto with coqlib.\ninv EQ.\ndestruct (size_quantity_nat_pos q1) as [p EQ1]; rewrite EQ1; simpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\nrewrite dec_eq_false by congruence.\nauto."},{"statement":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (v0 : val) (q : quantity) (n : nat) (l : list memval) (V : inj_value q2 v = Fragment v0 q n :: l) : (if check_value (size_quantity_nat q1) v0 q1 (Fragment v0 q n :: l)\n then v0\n else Vundef) = Vundef.","conclusion":"(if check_value (size_quantity_nat q1) v0 q1 (Fragment v0 q n :: l)\n then v0\n else Vundef) = Vundef","hypotheses":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (v0 : val) (q : quantity) (n : nat) (l : list memval) (V : inj_value q2 v = Fragment v0 q n :: l)","proofString":"destruct (in_inj_value (Fragment v0 q n) v q2) as [n' EQ].\nrewrite V; auto with coqlib.\ninv EQ.\ndestruct (size_quantity_nat_pos q1) as [p EQ1]; rewrite EQ1; simpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\nrewrite dec_eq_false by congruence.\nauto."},{"statement":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (v0 : val) (q : quantity) (n : nat) (l : list memval) (V : inj_value q2 v = Fragment v0 q n :: l) : In (Fragment v0 q n) (inj_value q2 v).","conclusion":"In (Fragment v0 q n) (inj_value q2 v)","hypotheses":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (v0 : val) (q : quantity) (n : nat) (l : list memval) (V : inj_value q2 v = Fragment v0 q n :: l)","proofString":"rewrite V; auto with coqlib."},{"statement":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (v0 : val) (q : quantity) (n : nat) (l : list memval) (V : inj_value q2 v = Fragment v0 q n :: l) (n' : nat) (EQ : Fragment v0 q n = Fragment v q2 n') : (if check_value (size_quantity_nat q1) v0 q1 (Fragment v0 q n :: l)\n then v0\n else Vundef) = Vundef.","conclusion":"(if check_value (size_quantity_nat q1) v0 q1 (Fragment v0 q n :: l)\n then v0\n else Vundef) = Vundef","hypotheses":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (v0 : val) (q : quantity) (n : nat) (l : list memval) (V : inj_value q2 v = Fragment v0 q n :: l) (n' : nat) (EQ : Fragment v0 q n = Fragment v q2 n')","proofString":"inv EQ.\ndestruct (size_quantity_nat_pos q1) as [p EQ1]; rewrite EQ1; simpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\nrewrite dec_eq_false by congruence.\nauto."},{"statement":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (l : list memval) (n' : nat) (V : inj_value q2 v = Fragment v q2 n' :: l) : (if check_value (size_quantity_nat q1) v q1 (Fragment v q2 n' :: l)\n then v\n else Vundef) = Vundef.","conclusion":"(if check_value (size_quantity_nat q1) v q1 (Fragment v q2 n' :: l)\n then v\n else Vundef) = Vundef","hypotheses":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (l : list memval) (n' : nat) (V : inj_value q2 v = Fragment v q2 n' :: l)","proofString":"destruct (size_quantity_nat_pos q1) as [p EQ1]; rewrite EQ1; simpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\nrewrite dec_eq_false by congruence.\nauto."},{"statement":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (l : list memval) (n' : nat) (V : inj_value q2 v = Fragment v q2 n' :: l) (p : nat) (EQ1 : size_quantity_nat q1 = S p) : (if Val.eq v v && quantity_eq q1 q2 && (p =? n')%nat && check_value p v q1 l\n then v\n else Vundef) = Vundef.","conclusion":"(if Val.eq v v && quantity_eq q1 q2 && (p =? n')%nat && check_value p v q1 l\n then v\n else Vundef) = Vundef","hypotheses":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (l : list memval) (n' : nat) (V : inj_value q2 v = Fragment v q2 n' :: l) (p : nat) (EQ1 : size_quantity_nat q1 = S p)","proofString":"unfold proj_sumbool.\nrewrite dec_eq_true.\nrewrite dec_eq_false by congruence.\nauto."},{"statement":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (l : list memval) (n' : nat) (V : inj_value q2 v = Fragment v q2 n' :: l) (p : nat) (EQ1 : size_quantity_nat q1 = S p) : (if\n  (if Val.eq v v then true else false) &&\n  (if quantity_eq q1 q2 then true else false) && (p =? n')%nat &&\n  check_value p v q1 l\n then v\n else Vundef) = Vundef.","conclusion":"(if\n  (if Val.eq v v then true else false) &&\n  (if quantity_eq q1 q2 then true else false) && (p =? n')%nat &&\n  check_value p v q1 l\n then v\n else Vundef) = Vundef","hypotheses":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (l : list memval) (n' : nat) (V : inj_value q2 v = Fragment v q2 n' :: l) (p : nat) (EQ1 : size_quantity_nat q1 = S p)","proofString":"rewrite dec_eq_true.\nrewrite dec_eq_false by congruence.\nauto."},{"statement":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (l : list memval) (n' : nat) (V : inj_value q2 v = Fragment v q2 n' :: l) (p : nat) (EQ1 : size_quantity_nat q1 = S p) : (if\n  true && (if quantity_eq q1 q2 then true else false) && (p =? n')%nat &&\n  check_value p v q1 l\n then v\n else Vundef) = Vundef.","conclusion":"(if\n  true && (if quantity_eq q1 q2 then true else false) && (p =? n')%nat &&\n  check_value p v q1 l\n then v\n else Vundef) = Vundef","hypotheses":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (l : list memval) (n' : nat) (V : inj_value q2 v = Fragment v q2 n' :: l) (p : nat) (EQ1 : size_quantity_nat q1 = S p)","proofString":"rewrite dec_eq_false by congruence.\nauto."},{"statement":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (l : list memval) (n' : nat) (V : inj_value q2 v = Fragment v q2 n' :: l) (p : nat) (EQ1 : size_quantity_nat q1 = S p) : (if true && false && (p =? n')%nat && check_value p v q1 l then v else Vundef) =\nVundef.","conclusion":"(if true && false && (p =? n')%nat && check_value p v q1 l then v else Vundef) =\nVundef","hypotheses":"(q1 q2 : quantity) (v : val) (H : q1 <> q2) (l : list memval) (n' : nat) (V : inj_value q2 v = Fragment v q2 n' :: l) (p : nat) (EQ1 : size_quantity_nat q1 = S p)","proofString":"auto."},{"statement":"(bl : list memval) (chunk : memory_chunk) : decode_val chunk (Undef :: bl) = Vundef.","conclusion":"decode_val chunk (Undef :: bl) = Vundef","hypotheses":"(bl : list memval) (chunk : memory_chunk)","proofString":"unfold decode_val.\nsimpl.\ndestruct chunk, Archi.ptr64; auto."},{"statement":"(bl : list memval) (chunk : memory_chunk) : match proj_bytes (Undef :: bl) with\n| Some bl0 =>\n    match chunk with\n    | Mbool =>\n        Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl0))))\n    | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl0)))\n    | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl0)))\n    | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl0)))\n    | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl0)))\n    | Mint32 => Vint (Int.repr (decode_int bl0))\n    | Mint64 => Vlong (Int64.repr (decode_int bl0))\n    | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl0)))\n    | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl0)))\n    | _ => Vundef\n    end\n| None =>\n    match chunk with\n    | Mint32 =>\n        if Archi.ptr64\n        then Vundef\n        else Val.load_result chunk (proj_value Q32 (Undef :: bl))\n    | Mint64 =>\n        if Archi.ptr64\n        then Val.load_result chunk (proj_value Q64 (Undef :: bl))\n        else Vundef\n    | Many32 => Val.load_result chunk (proj_value Q32 (Undef :: bl))\n    | Many64 => Val.load_result chunk (proj_value Q64 (Undef :: bl))\n    | _ => Vundef\n    end\nend = Vundef.","conclusion":"match proj_bytes (Undef :: bl) with\n| Some bl0 =>\n    match chunk with\n    | Mbool =>\n        Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl0))))\n    | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl0)))\n    | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl0)))\n    | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl0)))\n    | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl0)))\n    | Mint32 => Vint (Int.repr (decode_int bl0))\n    | Mint64 => Vlong (Int64.repr (decode_int bl0))\n    | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl0)))\n    | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl0)))\n    | _ => Vundef\n    end\n| None =>\n    match chunk with\n    | Mint32 =>\n        if Archi.ptr64\n        then Vundef\n        else Val.load_result chunk (proj_value Q32 (Undef :: bl))\n    | Mint64 =>\n        if Archi.ptr64\n        then Val.load_result chunk (proj_value Q64 (Undef :: bl))\n        else Vundef\n    | Many32 => Val.load_result chunk (proj_value Q32 (Undef :: bl))\n    | Many64 => Val.load_result chunk (proj_value Q64 (Undef :: bl))\n    | _ => Vundef\n    end\nend = Vundef","hypotheses":"(bl : list memval) (chunk : memory_chunk)","proofString":"simpl.\ndestruct chunk, Archi.ptr64; auto."},{"statement":"(bl : list memval) (chunk : memory_chunk) : match chunk with\n| Mint32 => if Archi.ptr64 then Vundef else Val.load_result chunk Vundef\n| Mint64 => if Archi.ptr64 then Val.load_result chunk Vundef else Vundef\n| Many32 | Many64 => Val.load_result chunk Vundef\n| _ => Vundef\nend = Vundef.","conclusion":"match chunk with\n| Mint32 => if Archi.ptr64 then Vundef else Val.load_result chunk Vundef\n| Mint64 => if Archi.ptr64 then Val.load_result chunk Vundef else Vundef\n| Many32 | Many64 => Val.load_result chunk Vundef\n| _ => Vundef\nend = Vundef","hypotheses":"(bl : list memval) (chunk : memory_chunk)","proofString":"destruct chunk, Archi.ptr64; auto."},{"statement":"(q : quantity) (v : val) : proj_bytes (inj_value q v) = None.","conclusion":"proj_bytes (inj_value q v) = None","hypotheses":"(q : quantity) (v : val)","proofString":"destruct q; reflexivity."},{"statement":"(v1 : val) (chunk1 chunk2 : memory_chunk) (v2 : val) (TY : type_of_chunk chunk1 = type_of_chunk chunk2) (SZ : size_chunk chunk1 = size_chunk chunk2) (DE : decode_encode_val v1 chunk1 chunk2 v2) : v2 = Val.load_result chunk2 v1.","conclusion":"v2 = Val.load_result chunk2 v1","hypotheses":"(v1 : val) (chunk1 chunk2 : memory_chunk) (v2 : val) (TY : type_of_chunk chunk1 = type_of_chunk chunk2) (SZ : size_chunk chunk1 = size_chunk chunk2) (DE : decode_encode_val v1 chunk1 chunk2 v2)","proofString":"unfold decode_encode_val in DE; destruct chunk1; destruct chunk2;  simpl in TY; try discriminate; simpl in SZ; try extlia;  destruct v1; auto."},{"statement":"(chunk : memory_chunk) (cl : list memval) : Val.has_type (decode_val chunk cl) (type_of_chunk chunk).","conclusion":"Val.has_type (decode_val chunk cl) (type_of_chunk chunk)","hypotheses":"(chunk : memory_chunk) (cl : list memval)","proofString":"rewrite <- proj_xtype_of_chunk.\napply Val.has_proj_xtype.\napply decode_val_xtype."},{"statement":"(chunk : memory_chunk) (cl : list memval) : Val.has_type (decode_val chunk cl) (proj_xtype (xtype_of_chunk chunk)).","conclusion":"Val.has_type (decode_val chunk cl) (proj_xtype (xtype_of_chunk chunk))","hypotheses":"(chunk : memory_chunk) (cl : list memval)","proofString":"apply Val.has_proj_xtype.\napply decode_val_xtype."},{"statement":"(chunk : memory_chunk) (cl : list memval) : Val.has_rettype (decode_val chunk cl) (xtype_of_chunk chunk).","conclusion":"Val.has_rettype (decode_val chunk cl) (xtype_of_chunk chunk)","hypotheses":"(chunk : memory_chunk) (cl : list memval)","proofString":"apply decode_val_xtype."},{"statement":"(v : val) : encode_val Mint8signed v = encode_val Mint8unsigned v.","conclusion":"encode_val Mint8signed v = encode_val Mint8unsigned v","hypotheses":"(v : val)","proofString":"destruct v; simpl; auto."},{"statement":"(v : val) : encode_val Mint16signed v = encode_val Mint16unsigned v.","conclusion":"encode_val Mint16signed v = encode_val Mint16unsigned v","hypotheses":"(v : val)","proofString":"destruct v; simpl; auto."},{"statement":"(n : int) : inj_bytes (encode_int 1 (Int.unsigned (Int.zero_ext 8 n))) =\ninj_bytes (encode_int 1 (Int.unsigned n)).","conclusion":"inj_bytes (encode_int 1 (Int.unsigned (Int.zero_ext 8 n))) =\ninj_bytes (encode_int 1 (Int.unsigned n))","hypotheses":"(n : int)","proofString":"decEq.\napply encode_int_8_mod.\napply Int.eqmod_zero_ext.\ncompute; intuition congruence."},{"statement":"(n : int) : encode_int 1 (Int.unsigned (Int.zero_ext 8 n)) =\nencode_int 1 (Int.unsigned n).","conclusion":"encode_int 1 (Int.unsigned (Int.zero_ext 8 n)) =\nencode_int 1 (Int.unsigned n)","hypotheses":"(n : int)","proofString":"apply encode_int_8_mod.\napply Int.eqmod_zero_ext.\ncompute; intuition congruence."},{"statement":"(n : int) : eqmod (two_p 8) (Int.unsigned (Int.zero_ext 8 n)) (Int.unsigned n).","conclusion":"eqmod (two_p 8) (Int.unsigned (Int.zero_ext 8 n)) (Int.unsigned n)","hypotheses":"(n : int)","proofString":"apply Int.eqmod_zero_ext.\ncompute; intuition congruence."},{"statement":"(n : int) : 0 <= 8 < Int.zwordsize.","conclusion":"0 <= 8 < Int.zwordsize","hypotheses":"(n : int)","proofString":"compute; intuition congruence."},{"statement":"(n : int) : inj_bytes (encode_int 1 (Int.unsigned (Int.sign_ext 8 n))) =\ninj_bytes (encode_int 1 (Int.unsigned n)).","conclusion":"inj_bytes (encode_int 1 (Int.unsigned (Int.sign_ext 8 n))) =\ninj_bytes (encode_int 1 (Int.unsigned n))","hypotheses":"(n : int)","proofString":"decEq.\napply encode_int_8_mod.\napply Int.eqmod_sign_ext'.\ncompute; auto."},{"statement":"(n : int) : encode_int 1 (Int.unsigned (Int.sign_ext 8 n)) =\nencode_int 1 (Int.unsigned n).","conclusion":"encode_int 1 (Int.unsigned (Int.sign_ext 8 n)) =\nencode_int 1 (Int.unsigned n)","hypotheses":"(n : int)","proofString":"apply encode_int_8_mod.\napply Int.eqmod_sign_ext'.\ncompute; auto."},{"statement":"(n : int) : eqmod (two_p 8) (Int.unsigned (Int.sign_ext 8 n)) (Int.unsigned n).","conclusion":"eqmod (two_p 8) (Int.unsigned (Int.sign_ext 8 n)) (Int.unsigned n)","hypotheses":"(n : int)","proofString":"apply Int.eqmod_sign_ext'.\ncompute; auto."},{"statement":"(n : int) : 0 < 8 < Int.zwordsize.","conclusion":"0 < 8 < Int.zwordsize","hypotheses":"(n : int)","proofString":"compute; auto."},{"statement":"(n : int) : inj_bytes (encode_int 2 (Int.unsigned (Int.zero_ext 16 n))) =\ninj_bytes (encode_int 2 (Int.unsigned n)).","conclusion":"inj_bytes (encode_int 2 (Int.unsigned (Int.zero_ext 16 n))) =\ninj_bytes (encode_int 2 (Int.unsigned n))","hypotheses":"(n : int)","proofString":"decEq.\napply encode_int_16_mod.\napply Int.eqmod_zero_ext.\ncompute; intuition congruence."},{"statement":"(n : int) : encode_int 2 (Int.unsigned (Int.zero_ext 16 n)) =\nencode_int 2 (Int.unsigned n).","conclusion":"encode_int 2 (Int.unsigned (Int.zero_ext 16 n)) =\nencode_int 2 (Int.unsigned n)","hypotheses":"(n : int)","proofString":"apply encode_int_16_mod.\napply Int.eqmod_zero_ext.\ncompute; intuition congruence."},{"statement":"(n : int) : eqmod (two_p 16) (Int.unsigned (Int.zero_ext 16 n)) (Int.unsigned n).","conclusion":"eqmod (two_p 16) (Int.unsigned (Int.zero_ext 16 n)) (Int.unsigned n)","hypotheses":"(n : int)","proofString":"apply Int.eqmod_zero_ext.\ncompute; intuition congruence."},{"statement":"(n : int) : 0 <= 16 < Int.zwordsize.","conclusion":"0 <= 16 < Int.zwordsize","hypotheses":"(n : int)","proofString":"compute; intuition congruence."},{"statement":"(n : int) : inj_bytes (encode_int 2 (Int.unsigned (Int.sign_ext 16 n))) =\ninj_bytes (encode_int 2 (Int.unsigned n)).","conclusion":"inj_bytes (encode_int 2 (Int.unsigned (Int.sign_ext 16 n))) =\ninj_bytes (encode_int 2 (Int.unsigned n))","hypotheses":"(n : int)","proofString":"decEq.\napply encode_int_16_mod.\napply Int.eqmod_sign_ext'.\ncompute; auto."},{"statement":"(n : int) : encode_int 2 (Int.unsigned (Int.sign_ext 16 n)) =\nencode_int 2 (Int.unsigned n).","conclusion":"encode_int 2 (Int.unsigned (Int.sign_ext 16 n)) =\nencode_int 2 (Int.unsigned n)","hypotheses":"(n : int)","proofString":"apply encode_int_16_mod.\napply Int.eqmod_sign_ext'.\ncompute; auto."},{"statement":"(n : int) : eqmod (two_p 16) (Int.unsigned (Int.sign_ext 16 n)) (Int.unsigned n).","conclusion":"eqmod (two_p 16) (Int.unsigned (Int.sign_ext 16 n)) (Int.unsigned n)","hypotheses":"(n : int)","proofString":"apply Int.eqmod_sign_ext'.\ncompute; auto."},{"statement":"(n : int) : 0 < 16 < Int.zwordsize.","conclusion":"0 < 16 < Int.zwordsize","hypotheses":"(n : int)","proofString":"compute; auto."},{"statement":"(chunk : memory_chunk) (l : list memval) (v : val) : match chunk with\n| Mbool =>\n    match proj_bytes l with\n    | Some bl =>\n        match chunk with\n        | Mbool =>\n            Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n        | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n        | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n        | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n        | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n        | Mint32 => Vint (Int.repr (decode_int bl))\n        | Mint64 => Vlong (Int64.repr (decode_int bl))\n        | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n        | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n        | _ => Vundef\n        end\n    | None =>\n        match chunk with\n        | Mint32 =>\n            if Archi.ptr64\n            then Vundef\n            else Val.load_result chunk (proj_value Q32 l)\n        | Mint64 =>\n            if Archi.ptr64\n            then Val.load_result chunk (proj_value Q64 l)\n            else Vundef\n        | Many32 => Val.load_result chunk (proj_value Q32 l)\n        | Many64 => Val.load_result chunk (proj_value Q64 l)\n        | _ => Vundef\n        end\n    end =\n    Val.norm_bool\n      match proj_bytes l with\n      | Some bl =>\n          match chunk with\n          | Mbool =>\n              Val.norm_bool\n                (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n          | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n          | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n          | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n          | Mint16unsigned =>\n              Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n          | Mint32 => Vint (Int.repr (decode_int bl))\n          | Mint64 => Vlong (Int64.repr (decode_int bl))\n          | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n          | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n          | _ => Vundef\n          end\n      | None =>\n          match chunk with\n          | Mint32 =>\n              if Archi.ptr64\n              then Vundef\n              else Val.load_result chunk (proj_value Q32 l)\n          | Mint64 =>\n              if Archi.ptr64\n              then Val.load_result chunk (proj_value Q64 l)\n              else Vundef\n          | Many32 => Val.load_result chunk (proj_value Q32 l)\n          | Many64 => Val.load_result chunk (proj_value Q64 l)\n          | _ => Vundef\n          end\n      end\n| Mint8signed =>\n    match proj_bytes l with\n    | Some bl =>\n        match chunk with\n        | Mbool =>\n            Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n        | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n        | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n        | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n        | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n        | Mint32 => Vint (Int.repr (decode_int bl))\n        | Mint64 => Vlong (Int64.repr (decode_int bl))\n        | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n        | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n        | _ => Vundef\n        end\n    | None =>\n        match chunk with\n        | Mint32 =>\n            if Archi.ptr64\n            then Vundef\n            else Val.load_result chunk (proj_value Q32 l)\n        | Mint64 =>\n            if Archi.ptr64\n            then Val.load_result chunk (proj_value Q64 l)\n            else Vundef\n        | Many32 => Val.load_result chunk (proj_value Q32 l)\n        | Many64 => Val.load_result chunk (proj_value Q64 l)\n        | _ => Vundef\n        end\n    end =\n    Val.sign_ext 8\n      match proj_bytes l with\n      | Some bl =>\n          match chunk with\n          | Mbool =>\n              Val.norm_bool\n                (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n          | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n          | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n          | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n          | Mint16unsigned =>\n              Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n          | Mint32 => Vint (Int.repr (decode_int bl))\n          | Mint64 => Vlong (Int64.repr (decode_int bl))\n          | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n          | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n          | _ => Vundef\n          end\n      | None =>\n          match chunk with\n          | Mint32 =>\n              if Archi.ptr64\n              then Vundef\n              else Val.load_result chunk (proj_value Q32 l)\n          | Mint64 =>\n              if Archi.ptr64\n              then Val.load_result chunk (proj_value Q64 l)\n              else Vundef\n          | Many32 => Val.load_result chunk (proj_value Q32 l)\n          | Many64 => Val.load_result chunk (proj_value Q64 l)\n          | _ => Vundef\n          end\n      end\n| Mint8unsigned =>\n    match proj_bytes l with\n    | Some bl =>\n        match chunk with\n        | Mbool =>\n            Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n        | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n        | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n        | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n        | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n        | Mint32 => Vint (Int.repr (decode_int bl))\n        | Mint64 => Vlong (Int64.repr (decode_int bl))\n        | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n        | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n        | _ => Vundef\n        end\n    | None =>\n        match chunk with\n        | Mint32 =>\n            if Archi.ptr64\n            then Vundef\n            else Val.load_result chunk (proj_value Q32 l)\n        | Mint64 =>\n            if Archi.ptr64\n            then Val.load_result chunk (proj_value Q64 l)\n            else Vundef\n        | Many32 => Val.load_result chunk (proj_value Q32 l)\n        | Many64 => Val.load_result chunk (proj_value Q64 l)\n        | _ => Vundef\n        end\n    end =\n    Val.zero_ext 8\n      match proj_bytes l with\n      | Some bl =>\n          match chunk with\n          | Mbool =>\n              Val.norm_bool\n                (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n          | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n          | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n          | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n          | Mint16unsigned =>\n              Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n          | Mint32 => Vint (Int.repr (decode_int bl))\n          | Mint64 => Vlong (Int64.repr (decode_int bl))\n          | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n          | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n          | _ => Vundef\n          end\n      | None =>\n          match chunk with\n          | Mint32 =>\n              if Archi.ptr64\n              then Vundef\n              else Val.load_result chunk (proj_value Q32 l)\n          | Mint64 =>\n              if Archi.ptr64\n              then Val.load_result chunk (proj_value Q64 l)\n              else Vundef\n          | Many32 => Val.load_result chunk (proj_value Q32 l)\n          | Many64 => Val.load_result chunk (proj_value Q64 l)\n          | _ => Vundef\n          end\n      end\n| Mint16signed =>\n    match proj_bytes l with\n    | Some bl =>\n        match chunk with\n        | Mbool =>\n            Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n        | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n        | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n        | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n        | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n        | Mint32 => Vint (Int.repr (decode_int bl))\n        | Mint64 => Vlong (Int64.repr (decode_int bl))\n        | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n        | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n        | _ => Vundef\n        end\n    | None =>\n        match chunk with\n        | Mint32 =>\n            if Archi.ptr64\n            then Vundef\n            else Val.load_result chunk (proj_value Q32 l)\n        | Mint64 =>\n            if Archi.ptr64\n            then Val.load_result chunk (proj_value Q64 l)\n            else Vundef\n        | Many32 => Val.load_result chunk (proj_value Q32 l)\n        | Many64 => Val.load_result chunk (proj_value Q64 l)\n        | _ => Vundef\n        end\n    end =\n    Val.sign_ext 16\n      match proj_bytes l with\n      | Some bl =>\n          match chunk with\n          | Mbool =>\n              Val.norm_bool\n                (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n          | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n          | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n          | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n          | Mint16unsigned =>\n              Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n          | Mint32 => Vint (Int.repr (decode_int bl))\n          | Mint64 => Vlong (Int64.repr (decode_int bl))\n          | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n          | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n          | _ => Vundef\n          end\n      | None =>\n          match chunk with\n          | Mint32 =>\n              if Archi.ptr64\n              then Vundef\n              else Val.load_result chunk (proj_value Q32 l)\n          | Mint64 =>\n              if Archi.ptr64\n              then Val.load_result chunk (proj_value Q64 l)\n              else Vundef\n          | Many32 => Val.load_result chunk (proj_value Q32 l)\n          | Many64 => Val.load_result chunk (proj_value Q64 l)\n          | _ => Vundef\n          end\n      end\n| Mint16unsigned =>\n    match proj_bytes l with\n    | Some bl =>\n        match chunk with\n        | Mbool =>\n            Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n        | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n        | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n        | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n        | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n        | Mint32 => Vint (Int.repr (decode_int bl))\n        | Mint64 => Vlong (Int64.repr (decode_int bl))\n        | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n        | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n        | _ => Vundef\n        end\n    | None =>\n        match chunk with\n        | Mint32 =>\n            if Archi.ptr64\n            then Vundef\n            else Val.load_result chunk (proj_value Q32 l)\n        | Mint64 =>\n            if Archi.ptr64\n            then Val.load_result chunk (proj_value Q64 l)\n            else Vundef\n        | Many32 => Val.load_result chunk (proj_value Q32 l)\n        | Many64 => Val.load_result chunk (proj_value Q64 l)\n        | _ => Vundef\n        end\n    end =\n    Val.zero_ext 16\n      match proj_bytes l with\n      | Some bl =>\n          match chunk with\n          | Mbool =>\n              Val.norm_bool\n                (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n          | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n          | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n          | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n          | Mint16unsigned =>\n              Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n          | Mint32 => Vint (Int.repr (decode_int bl))\n          | Mint64 => Vlong (Int64.repr (decode_int bl))\n          | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n          | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n          | _ => Vundef\n          end\n      | None =>\n          match chunk with\n          | Mint32 =>\n              if Archi.ptr64\n              then Vundef\n              else Val.load_result chunk (proj_value Q32 l)\n          | Mint64 =>\n              if Archi.ptr64\n              then Val.load_result chunk (proj_value Q64 l)\n              else Vundef\n          | Many32 => Val.load_result chunk (proj_value Q32 l)\n          | Many64 => Val.load_result chunk (proj_value Q64 l)\n          | _ => Vundef\n          end\n      end\n| _ => True\nend.","conclusion":"match chunk with\n| Mbool =>\n    match proj_bytes l with\n    | Some bl =>\n        match chunk with\n        | Mbool =>\n            Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n        | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n        | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n        | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n        | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n        | Mint32 => Vint (Int.repr (decode_int bl))\n        | Mint64 => Vlong (Int64.repr (decode_int bl))\n        | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n        | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n        | _ => Vundef\n        end\n    | None =>\n        match chunk with\n        | Mint32 =>\n            if Archi.ptr64\n            then Vundef\n            else Val.load_result chunk (proj_value Q32 l)\n        | Mint64 =>\n            if Archi.ptr64\n            then Val.load_result chunk (proj_value Q64 l)\n            else Vundef\n        | Many32 => Val.load_result chunk (proj_value Q32 l)\n        | Many64 => Val.load_result chunk (proj_value Q64 l)\n        | _ => Vundef\n        end\n    end =\n    Val.norm_bool\n      match proj_bytes l with\n      | Some bl =>\n          match chunk with\n          | Mbool =>\n              Val.norm_bool\n                (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n          | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n          | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n          | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n          | Mint16unsigned =>\n              Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n          | Mint32 => Vint (Int.repr (decode_int bl))\n          | Mint64 => Vlong (Int64.repr (decode_int bl))\n          | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n          | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n          | _ => Vundef\n          end\n      | None =>\n          match chunk with\n          | Mint32 =>\n              if Archi.ptr64\n              then Vundef\n              else Val.load_result chunk (proj_value Q32 l)\n          | Mint64 =>\n              if Archi.ptr64\n              then Val.load_result chunk (proj_value Q64 l)\n              else Vundef\n          | Many32 => Val.load_result chunk (proj_value Q32 l)\n          | Many64 => Val.load_result chunk (proj_value Q64 l)\n          | _ => Vundef\n          end\n      end\n| Mint8signed =>\n    match proj_bytes l with\n    | Some bl =>\n        match chunk with\n        | Mbool =>\n            Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n        | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n        | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n        | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n        | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n        | Mint32 => Vint (Int.repr (decode_int bl))\n        | Mint64 => Vlong (Int64.repr (decode_int bl))\n        | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n        | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n        | _ => Vundef\n        end\n    | None =>\n        match chunk with\n        | Mint32 =>\n            if Archi.ptr64\n            then Vundef\n            else Val.load_result chunk (proj_value Q32 l)\n        | Mint64 =>\n            if Archi.ptr64\n            then Val.load_result chunk (proj_value Q64 l)\n            else Vundef\n        | Many32 => Val.load_result chunk (proj_value Q32 l)\n        | Many64 => Val.load_result chunk (proj_value Q64 l)\n        | _ => Vundef\n        end\n    end =\n    Val.sign_ext 8\n      match proj_bytes l with\n      | Some bl =>\n          match chunk with\n          | Mbool =>\n              Val.norm_bool\n                (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n          | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n          | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n          | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n          | Mint16unsigned =>\n              Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n          | Mint32 => Vint (Int.repr (decode_int bl))\n          | Mint64 => Vlong (Int64.repr (decode_int bl))\n          | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n          | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n          | _ => Vundef\n          end\n      | None =>\n          match chunk with\n          | Mint32 =>\n              if Archi.ptr64\n              then Vundef\n              else Val.load_result chunk (proj_value Q32 l)\n          | Mint64 =>\n              if Archi.ptr64\n              then Val.load_result chunk (proj_value Q64 l)\n              else Vundef\n          | Many32 => Val.load_result chunk (proj_value Q32 l)\n          | Many64 => Val.load_result chunk (proj_value Q64 l)\n          | _ => Vundef\n          end\n      end\n| Mint8unsigned =>\n    match proj_bytes l with\n    | Some bl =>\n        match chunk with\n        | Mbool =>\n            Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n        | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n        | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n        | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n        | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n        | Mint32 => Vint (Int.repr (decode_int bl))\n        | Mint64 => Vlong (Int64.repr (decode_int bl))\n        | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n        | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n        | _ => Vundef\n        end\n    | None =>\n        match chunk with\n        | Mint32 =>\n            if Archi.ptr64\n            then Vundef\n            else Val.load_result chunk (proj_value Q32 l)\n        | Mint64 =>\n            if Archi.ptr64\n            then Val.load_result chunk (proj_value Q64 l)\n            else Vundef\n        | Many32 => Val.load_result chunk (proj_value Q32 l)\n        | Many64 => Val.load_result chunk (proj_value Q64 l)\n        | _ => Vundef\n        end\n    end =\n    Val.zero_ext 8\n      match proj_bytes l with\n      | Some bl =>\n          match chunk with\n          | Mbool =>\n              Val.norm_bool\n                (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n          | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n          | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n          | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n          | Mint16unsigned =>\n              Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n          | Mint32 => Vint (Int.repr (decode_int bl))\n          | Mint64 => Vlong (Int64.repr (decode_int bl))\n          | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n          | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n          | _ => Vundef\n          end\n      | None =>\n          match chunk with\n          | Mint32 =>\n              if Archi.ptr64\n              then Vundef\n              else Val.load_result chunk (proj_value Q32 l)\n          | Mint64 =>\n              if Archi.ptr64\n              then Val.load_result chunk (proj_value Q64 l)\n              else Vundef\n          | Many32 => Val.load_result chunk (proj_value Q32 l)\n          | Many64 => Val.load_result chunk (proj_value Q64 l)\n          | _ => Vundef\n          end\n      end\n| Mint16signed =>\n    match proj_bytes l with\n    | Some bl =>\n        match chunk with\n        | Mbool =>\n            Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n        | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n        | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n        | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n        | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n        | Mint32 => Vint (Int.repr (decode_int bl))\n        | Mint64 => Vlong (Int64.repr (decode_int bl))\n        | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n        | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n        | _ => Vundef\n        end\n    | None =>\n        match chunk with\n        | Mint32 =>\n            if Archi.ptr64\n            then Vundef\n            else Val.load_result chunk (proj_value Q32 l)\n        | Mint64 =>\n            if Archi.ptr64\n            then Val.load_result chunk (proj_value Q64 l)\n            else Vundef\n        | Many32 => Val.load_result chunk (proj_value Q32 l)\n        | Many64 => Val.load_result chunk (proj_value Q64 l)\n        | _ => Vundef\n        end\n    end =\n    Val.sign_ext 16\n      match proj_bytes l with\n      | Some bl =>\n          match chunk with\n          | Mbool =>\n              Val.norm_bool\n                (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n          | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n          | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n          | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n          | Mint16unsigned =>\n              Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n          | Mint32 => Vint (Int.repr (decode_int bl))\n          | Mint64 => Vlong (Int64.repr (decode_int bl))\n          | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n          | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n          | _ => Vundef\n          end\n      | None =>\n          match chunk with\n          | Mint32 =>\n              if Archi.ptr64\n              then Vundef\n              else Val.load_result chunk (proj_value Q32 l)\n          | Mint64 =>\n              if Archi.ptr64\n              then Val.load_result chunk (proj_value Q64 l)\n              else Vundef\n          | Many32 => Val.load_result chunk (proj_value Q32 l)\n          | Many64 => Val.load_result chunk (proj_value Q64 l)\n          | _ => Vundef\n          end\n      end\n| Mint16unsigned =>\n    match proj_bytes l with\n    | Some bl =>\n        match chunk with\n        | Mbool =>\n            Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n        | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n        | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n        | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n        | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n        | Mint32 => Vint (Int.repr (decode_int bl))\n        | Mint64 => Vlong (Int64.repr (decode_int bl))\n        | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n        | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n        | _ => Vundef\n        end\n    | None =>\n        match chunk with\n        | Mint32 =>\n            if Archi.ptr64\n            then Vundef\n            else Val.load_result chunk (proj_value Q32 l)\n        | Mint64 =>\n            if Archi.ptr64\n            then Val.load_result chunk (proj_value Q64 l)\n            else Vundef\n        | Many32 => Val.load_result chunk (proj_value Q32 l)\n        | Many64 => Val.load_result chunk (proj_value Q64 l)\n        | _ => Vundef\n        end\n    end =\n    Val.zero_ext 16\n      match proj_bytes l with\n      | Some bl =>\n          match chunk with\n          | Mbool =>\n              Val.norm_bool\n                (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n          | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n          | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n          | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n          | Mint16unsigned =>\n              Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n          | Mint32 => Vint (Int.repr (decode_int bl))\n          | Mint64 => Vlong (Int64.repr (decode_int bl))\n          | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n          | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n          | _ => Vundef\n          end\n      | None =>\n          match chunk with\n          | Mint32 =>\n              if Archi.ptr64\n              then Vundef\n              else Val.load_result chunk (proj_value Q32 l)\n          | Mint64 =>\n              if Archi.ptr64\n              then Val.load_result chunk (proj_value Q64 l)\n              else Vundef\n          | Many32 => Val.load_result chunk (proj_value Q32 l)\n          | Many64 => Val.load_result chunk (proj_value Q64 l)\n          | _ => Vundef\n          end\n      end\n| _ => True\nend","hypotheses":"(chunk : memory_chunk) (l : list memval) (v : val)","proofString":"destruct (proj_bytes l).\ndestruct chunk; simpl; rewrite ? Int.sign_ext_idem, ? Int.zero_ext_idem, ? Val.norm_bool_idem by lia; auto.\ndestruct chunk; auto."},{"statement":"(chunk : memory_chunk) (l : list memval) (v : val) (l0 : list byte) : match chunk with\n| Mbool =>\n    match chunk with\n    | Mbool =>\n        Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n    | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n    | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n    | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n    | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n    | Mint32 => Vint (Int.repr (decode_int l0))\n    | Mint64 => Vlong (Int64.repr (decode_int l0))\n    | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n    | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n    | _ => Vundef\n    end =\n    Val.norm_bool\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n      | Mint32 => Vint (Int.repr (decode_int l0))\n      | Mint64 => Vlong (Int64.repr (decode_int l0))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n      | _ => Vundef\n      end\n| Mint8signed =>\n    match chunk with\n    | Mbool =>\n        Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n    | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n    | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n    | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n    | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n    | Mint32 => Vint (Int.repr (decode_int l0))\n    | Mint64 => Vlong (Int64.repr (decode_int l0))\n    | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n    | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n    | _ => Vundef\n    end =\n    Val.sign_ext 8\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n      | Mint32 => Vint (Int.repr (decode_int l0))\n      | Mint64 => Vlong (Int64.repr (decode_int l0))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n      | _ => Vundef\n      end\n| Mint8unsigned =>\n    match chunk with\n    | Mbool =>\n        Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n    | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n    | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n    | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n    | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n    | Mint32 => Vint (Int.repr (decode_int l0))\n    | Mint64 => Vlong (Int64.repr (decode_int l0))\n    | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n    | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n    | _ => Vundef\n    end =\n    Val.zero_ext 8\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n      | Mint32 => Vint (Int.repr (decode_int l0))\n      | Mint64 => Vlong (Int64.repr (decode_int l0))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n      | _ => Vundef\n      end\n| Mint16signed =>\n    match chunk with\n    | Mbool =>\n        Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n    | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n    | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n    | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n    | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n    | Mint32 => Vint (Int.repr (decode_int l0))\n    | Mint64 => Vlong (Int64.repr (decode_int l0))\n    | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n    | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n    | _ => Vundef\n    end =\n    Val.sign_ext 16\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n      | Mint32 => Vint (Int.repr (decode_int l0))\n      | Mint64 => Vlong (Int64.repr (decode_int l0))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n      | _ => Vundef\n      end\n| Mint16unsigned =>\n    match chunk with\n    | Mbool =>\n        Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n    | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n    | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n    | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n    | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n    | Mint32 => Vint (Int.repr (decode_int l0))\n    | Mint64 => Vlong (Int64.repr (decode_int l0))\n    | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n    | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n    | _ => Vundef\n    end =\n    Val.zero_ext 16\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n      | Mint32 => Vint (Int.repr (decode_int l0))\n      | Mint64 => Vlong (Int64.repr (decode_int l0))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n      | _ => Vundef\n      end\n| _ => True\nend.","conclusion":"match chunk with\n| Mbool =>\n    match chunk with\n    | Mbool =>\n        Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n    | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n    | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n    | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n    | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n    | Mint32 => Vint (Int.repr (decode_int l0))\n    | Mint64 => Vlong (Int64.repr (decode_int l0))\n    | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n    | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n    | _ => Vundef\n    end =\n    Val.norm_bool\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n      | Mint32 => Vint (Int.repr (decode_int l0))\n      | Mint64 => Vlong (Int64.repr (decode_int l0))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n      | _ => Vundef\n      end\n| Mint8signed =>\n    match chunk with\n    | Mbool =>\n        Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n    | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n    | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n    | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n    | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n    | Mint32 => Vint (Int.repr (decode_int l0))\n    | Mint64 => Vlong (Int64.repr (decode_int l0))\n    | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n    | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n    | _ => Vundef\n    end =\n    Val.sign_ext 8\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n      | Mint32 => Vint (Int.repr (decode_int l0))\n      | Mint64 => Vlong (Int64.repr (decode_int l0))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n      | _ => Vundef\n      end\n| Mint8unsigned =>\n    match chunk with\n    | Mbool =>\n        Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n    | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n    | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n    | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n    | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n    | Mint32 => Vint (Int.repr (decode_int l0))\n    | Mint64 => Vlong (Int64.repr (decode_int l0))\n    | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n    | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n    | _ => Vundef\n    end =\n    Val.zero_ext 8\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n      | Mint32 => Vint (Int.repr (decode_int l0))\n      | Mint64 => Vlong (Int64.repr (decode_int l0))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n      | _ => Vundef\n      end\n| Mint16signed =>\n    match chunk with\n    | Mbool =>\n        Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n    | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n    | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n    | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n    | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n    | Mint32 => Vint (Int.repr (decode_int l0))\n    | Mint64 => Vlong (Int64.repr (decode_int l0))\n    | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n    | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n    | _ => Vundef\n    end =\n    Val.sign_ext 16\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n      | Mint32 => Vint (Int.repr (decode_int l0))\n      | Mint64 => Vlong (Int64.repr (decode_int l0))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n      | _ => Vundef\n      end\n| Mint16unsigned =>\n    match chunk with\n    | Mbool =>\n        Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n    | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n    | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n    | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n    | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n    | Mint32 => Vint (Int.repr (decode_int l0))\n    | Mint64 => Vlong (Int64.repr (decode_int l0))\n    | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n    | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n    | _ => Vundef\n    end =\n    Val.zero_ext 16\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int l0))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int l0)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int l0)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int l0)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int l0)))\n      | Mint32 => Vint (Int.repr (decode_int l0))\n      | Mint64 => Vlong (Int64.repr (decode_int l0))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int l0)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int l0)))\n      | _ => Vundef\n      end\n| _ => True\nend","hypotheses":"(chunk : memory_chunk) (l : list memval) (v : val) (l0 : list byte)","proofString":"destruct chunk; simpl; rewrite ? Int.sign_ext_idem, ? Int.zero_ext_idem, ? Val.norm_bool_idem by lia; auto."},{"statement":"(chunk : memory_chunk) (l : list memval) (v : val) : match chunk with\n| Mbool =>\n    match chunk with\n    | Mint32 =>\n        if Archi.ptr64\n        then Vundef\n        else Val.load_result chunk (proj_value Q32 l)\n    | Mint64 =>\n        if Archi.ptr64\n        then Val.load_result chunk (proj_value Q64 l)\n        else Vundef\n    | Many32 => Val.load_result chunk (proj_value Q32 l)\n    | Many64 => Val.load_result chunk (proj_value Q64 l)\n    | _ => Vundef\n    end =\n    Val.norm_bool\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 l)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 l)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 l)\n      | Many64 => Val.load_result chunk (proj_value Q64 l)\n      | _ => Vundef\n      end\n| Mint8signed =>\n    match chunk with\n    | Mint32 =>\n        if Archi.ptr64\n        then Vundef\n        else Val.load_result chunk (proj_value Q32 l)\n    | Mint64 =>\n        if Archi.ptr64\n        then Val.load_result chunk (proj_value Q64 l)\n        else Vundef\n    | Many32 => Val.load_result chunk (proj_value Q32 l)\n    | Many64 => Val.load_result chunk (proj_value Q64 l)\n    | _ => Vundef\n    end =\n    Val.sign_ext 8\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 l)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 l)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 l)\n      | Many64 => Val.load_result chunk (proj_value Q64 l)\n      | _ => Vundef\n      end\n| Mint8unsigned =>\n    match chunk with\n    | Mint32 =>\n        if Archi.ptr64\n        then Vundef\n        else Val.load_result chunk (proj_value Q32 l)\n    | Mint64 =>\n        if Archi.ptr64\n        then Val.load_result chunk (proj_value Q64 l)\n        else Vundef\n    | Many32 => Val.load_result chunk (proj_value Q32 l)\n    | Many64 => Val.load_result chunk (proj_value Q64 l)\n    | _ => Vundef\n    end =\n    Val.zero_ext 8\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 l)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 l)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 l)\n      | Many64 => Val.load_result chunk (proj_value Q64 l)\n      | _ => Vundef\n      end\n| Mint16signed =>\n    match chunk with\n    | Mint32 =>\n        if Archi.ptr64\n        then Vundef\n        else Val.load_result chunk (proj_value Q32 l)\n    | Mint64 =>\n        if Archi.ptr64\n        then Val.load_result chunk (proj_value Q64 l)\n        else Vundef\n    | Many32 => Val.load_result chunk (proj_value Q32 l)\n    | Many64 => Val.load_result chunk (proj_value Q64 l)\n    | _ => Vundef\n    end =\n    Val.sign_ext 16\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 l)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 l)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 l)\n      | Many64 => Val.load_result chunk (proj_value Q64 l)\n      | _ => Vundef\n      end\n| Mint16unsigned =>\n    match chunk with\n    | Mint32 =>\n        if Archi.ptr64\n        then Vundef\n        else Val.load_result chunk (proj_value Q32 l)\n    | Mint64 =>\n        if Archi.ptr64\n        then Val.load_result chunk (proj_value Q64 l)\n        else Vundef\n    | Many32 => Val.load_result chunk (proj_value Q32 l)\n    | Many64 => Val.load_result chunk (proj_value Q64 l)\n    | _ => Vundef\n    end =\n    Val.zero_ext 16\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 l)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 l)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 l)\n      | Many64 => Val.load_result chunk (proj_value Q64 l)\n      | _ => Vundef\n      end\n| _ => True\nend.","conclusion":"match chunk with\n| Mbool =>\n    match chunk with\n    | Mint32 =>\n        if Archi.ptr64\n        then Vundef\n        else Val.load_result chunk (proj_value Q32 l)\n    | Mint64 =>\n        if Archi.ptr64\n        then Val.load_result chunk (proj_value Q64 l)\n        else Vundef\n    | Many32 => Val.load_result chunk (proj_value Q32 l)\n    | Many64 => Val.load_result chunk (proj_value Q64 l)\n    | _ => Vundef\n    end =\n    Val.norm_bool\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 l)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 l)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 l)\n      | Many64 => Val.load_result chunk (proj_value Q64 l)\n      | _ => Vundef\n      end\n| Mint8signed =>\n    match chunk with\n    | Mint32 =>\n        if Archi.ptr64\n        then Vundef\n        else Val.load_result chunk (proj_value Q32 l)\n    | Mint64 =>\n        if Archi.ptr64\n        then Val.load_result chunk (proj_value Q64 l)\n        else Vundef\n    | Many32 => Val.load_result chunk (proj_value Q32 l)\n    | Many64 => Val.load_result chunk (proj_value Q64 l)\n    | _ => Vundef\n    end =\n    Val.sign_ext 8\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 l)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 l)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 l)\n      | Many64 => Val.load_result chunk (proj_value Q64 l)\n      | _ => Vundef\n      end\n| Mint8unsigned =>\n    match chunk with\n    | Mint32 =>\n        if Archi.ptr64\n        then Vundef\n        else Val.load_result chunk (proj_value Q32 l)\n    | Mint64 =>\n        if Archi.ptr64\n        then Val.load_result chunk (proj_value Q64 l)\n        else Vundef\n    | Many32 => Val.load_result chunk (proj_value Q32 l)\n    | Many64 => Val.load_result chunk (proj_value Q64 l)\n    | _ => Vundef\n    end =\n    Val.zero_ext 8\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 l)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 l)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 l)\n      | Many64 => Val.load_result chunk (proj_value Q64 l)\n      | _ => Vundef\n      end\n| Mint16signed =>\n    match chunk with\n    | Mint32 =>\n        if Archi.ptr64\n        then Vundef\n        else Val.load_result chunk (proj_value Q32 l)\n    | Mint64 =>\n        if Archi.ptr64\n        then Val.load_result chunk (proj_value Q64 l)\n        else Vundef\n    | Many32 => Val.load_result chunk (proj_value Q32 l)\n    | Many64 => Val.load_result chunk (proj_value Q64 l)\n    | _ => Vundef\n    end =\n    Val.sign_ext 16\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 l)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 l)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 l)\n      | Many64 => Val.load_result chunk (proj_value Q64 l)\n      | _ => Vundef\n      end\n| Mint16unsigned =>\n    match chunk with\n    | Mint32 =>\n        if Archi.ptr64\n        then Vundef\n        else Val.load_result chunk (proj_value Q32 l)\n    | Mint64 =>\n        if Archi.ptr64\n        then Val.load_result chunk (proj_value Q64 l)\n        else Vundef\n    | Many32 => Val.load_result chunk (proj_value Q32 l)\n    | Many64 => Val.load_result chunk (proj_value Q64 l)\n    | _ => Vundef\n    end =\n    Val.zero_ext 16\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 l)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 l)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 l)\n      | Many64 => Val.load_result chunk (proj_value Q64 l)\n      | _ => Vundef\n      end\n| _ => True\nend","hypotheses":"(chunk : memory_chunk) (l : list memval) (v : val)","proofString":"destruct chunk; auto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) : shape_decoding chunk (mv1 :: mvl) (decode_val chunk (mv1 :: mvl)).","conclusion":"shape_decoding chunk (mv1 :: mvl) (decode_val chunk (mv1 :: mvl))","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval)","proofString":"assert (A: forall mv mvs bs, proj_bytes mvs = Some bs -> In mv mvs ->                               exists b, mv = Byte b).\ninduction mvs; simpl; intros.\ncontradiction.\ndestruct a; try discriminate.\ndestruct H0.\nexists i; auto.\ndestruct (proj_bytes mvs); try discriminate.\neauto.\nassert (B: forall v q mv n mvs,             check_value n v q mvs = true -> In mv mvs -> (n < size_quantity_nat q)%nat ->             exists j, mv = Fragment v q j /\\ S j <> size_quantity_nat q).\ninduction n; destruct mvs; simpl; intros; try discriminate.\ncontradiction.\ndestruct m; try discriminate.\nInvBooleans.\napply Nat.eqb_eq in H4.\nsubst.\ndestruct H0.\nsubst mv.\nexists n0; split; auto.\nlia.\neapply IHn; eauto.\nlia.\nassert (U: forall mvs, shape_decoding chunk mvs (Val.load_result chunk Vundef)).\nintros.\nreplace (Val.load_result chunk Vundef) with Vundef.\nconstructor.\ndestruct chunk; auto.\nassert (C: forall q, size_quantity_nat q = size_chunk_nat chunk ->             (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) ->             shape_decoding chunk (mv1 :: mvl) (Val.load_result chunk (proj_value q (mv1 :: mvl)))).\nintros.\nunfold proj_value.\ndestruct mv1; auto.\ndestruct (size_quantity_nat_pos q) as [sz EQ].\nrewrite EQ.\nsimpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\ndestruct (quantity_eq q q0); auto.\ndestruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia.\nunfold decode_val.\ndestruct (proj_bytes (mv1 :: mvl)) as [bl|] eqn:PB.\nexploit (A mv1); eauto with coqlib.\nintros [b1 EQ1]; subst mv1.\ndestruct chunk; (apply shape_decoding_u || apply shape_decoding_b); eauto with coqlib.\nunfold Val.norm_bool; destruct Val.is_bool; auto.\ndestruct chunk, Archi.ptr64; (apply shape_decoding_u || apply C); auto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b.","conclusion":"forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval)","proofString":"induction mvs; simpl; intros.\ncontradiction.\ndestruct a; try discriminate.\ndestruct H0.\nexists i; auto.\ndestruct (proj_bytes mvs); try discriminate.\neauto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (mv : memval) (bs : list byte) (H : Some nil = Some bs) (H0 : False) : exists b : byte, mv = Byte b.","conclusion":"exists b : byte, mv = Byte b","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (mv : memval) (bs : list byte) (H : Some nil = Some bs) (H0 : False)","proofString":"contradiction."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (mv a : memval) (mvs : list memval) (IHmvs : forall bs0 : list byte,\nproj_bytes mvs = Some bs0 -> In mv mvs -> exists b : byte, mv = Byte b) (bs : list byte) (H : match a with\n| Byte b =>\n    match proj_bytes mvs with\n    | Some bl => Some (b :: bl)\n    | None => None\n    end\n| _ => None\nend = Some bs) (H0 : a = mv \\/ In mv mvs) : exists b : byte, mv = Byte b.","conclusion":"exists b : byte, mv = Byte b","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (mv a : memval) (mvs : list memval) (IHmvs : forall bs0 : list byte,\nproj_bytes mvs = Some bs0 -> In mv mvs -> exists b : byte, mv = Byte b) (bs : list byte) (H : match a with\n| Byte b =>\n    match proj_bytes mvs with\n    | Some bl => Some (b :: bl)\n    | None => None\n    end\n| _ => None\nend = Some bs) (H0 : a = mv \\/ In mv mvs)","proofString":"destruct a; try discriminate.\ndestruct H0.\nexists i; auto.\ndestruct (proj_bytes mvs); try discriminate.\neauto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (mv : memval) (i : byte) (mvs : list memval) (IHmvs : forall bs0 : list byte,\nproj_bytes mvs = Some bs0 -> In mv mvs -> exists b : byte, mv = Byte b) (bs : list byte) (H : match proj_bytes mvs with\n| Some bl => Some (i :: bl)\n| None => None\nend = Some bs) (H0 : Byte i = mv \\/ In mv mvs) : exists b : byte, mv = Byte b.","conclusion":"exists b : byte, mv = Byte b","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (mv : memval) (i : byte) (mvs : list memval) (IHmvs : forall bs0 : list byte,\nproj_bytes mvs = Some bs0 -> In mv mvs -> exists b : byte, mv = Byte b) (bs : list byte) (H : match proj_bytes mvs with\n| Some bl => Some (i :: bl)\n| None => None\nend = Some bs) (H0 : Byte i = mv \\/ In mv mvs)","proofString":"destruct H0.\nexists i; auto.\ndestruct (proj_bytes mvs); try discriminate.\neauto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (mv : memval) (i : byte) (mvs : list memval) (IHmvs : forall bs0 : list byte,\nproj_bytes mvs = Some bs0 -> In mv mvs -> exists b : byte, mv = Byte b) (bs : list byte) (H : match proj_bytes mvs with\n| Some bl => Some (i :: bl)\n| None => None\nend = Some bs) (H0 : Byte i = mv) : exists b : byte, mv = Byte b.","conclusion":"exists b : byte, mv = Byte b","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (mv : memval) (i : byte) (mvs : list memval) (IHmvs : forall bs0 : list byte,\nproj_bytes mvs = Some bs0 -> In mv mvs -> exists b : byte, mv = Byte b) (bs : list byte) (H : match proj_bytes mvs with\n| Some bl => Some (i :: bl)\n| None => None\nend = Some bs) (H0 : Byte i = mv)","proofString":"exists i; auto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (mv : memval) (i : byte) (mvs : list memval) (IHmvs : forall bs0 : list byte,\nproj_bytes mvs = Some bs0 -> In mv mvs -> exists b : byte, mv = Byte b) (bs : list byte) (H : match proj_bytes mvs with\n| Some bl => Some (i :: bl)\n| None => None\nend = Some bs) (H0 : In mv mvs) : exists b : byte, mv = Byte b.","conclusion":"exists b : byte, mv = Byte b","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (mv : memval) (i : byte) (mvs : list memval) (IHmvs : forall bs0 : list byte,\nproj_bytes mvs = Some bs0 -> In mv mvs -> exists b : byte, mv = Byte b) (bs : list byte) (H : match proj_bytes mvs with\n| Some bl => Some (i :: bl)\n| None => None\nend = Some bs) (H0 : In mv mvs)","proofString":"destruct (proj_bytes mvs); try discriminate.\neauto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (mv : memval) (i : byte) (mvs : list memval) (l : list byte) (IHmvs : forall bs0 : list byte,\nSome l = Some bs0 -> In mv mvs -> exists b : byte, mv = Byte b) (bs : list byte) (H : Some (i :: l) = Some bs) (H0 : In mv mvs) : exists b : byte, mv = Byte b.","conclusion":"exists b : byte, mv = Byte b","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (mv : memval) (i : byte) (mvs : list memval) (l : list byte) (IHmvs : forall bs0 : list byte,\nSome l = Some bs0 -> In mv mvs -> exists b : byte, mv = Byte b) (bs : list byte) (H : Some (i :: l) = Some bs) (H0 : In mv mvs)","proofString":"eauto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) : shape_decoding chunk (mv1 :: mvl) (decode_val chunk (mv1 :: mvl)).","conclusion":"shape_decoding chunk (mv1 :: mvl) (decode_val chunk (mv1 :: mvl))","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b)","proofString":"assert (B: forall v q mv n mvs,             check_value n v q mvs = true -> In mv mvs -> (n < size_quantity_nat q)%nat ->             exists j, mv = Fragment v q j /\\ S j <> size_quantity_nat q).\ninduction n; destruct mvs; simpl; intros; try discriminate.\ncontradiction.\ndestruct m; try discriminate.\nInvBooleans.\napply Nat.eqb_eq in H4.\nsubst.\ndestruct H0.\nsubst mv.\nexists n0; split; auto.\nlia.\neapply IHn; eauto.\nlia.\nassert (U: forall mvs, shape_decoding chunk mvs (Val.load_result chunk Vundef)).\nintros.\nreplace (Val.load_result chunk Vundef) with Vundef.\nconstructor.\ndestruct chunk; auto.\nassert (C: forall q, size_quantity_nat q = size_chunk_nat chunk ->             (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) ->             shape_decoding chunk (mv1 :: mvl) (Val.load_result chunk (proj_value q (mv1 :: mvl)))).\nintros.\nunfold proj_value.\ndestruct mv1; auto.\ndestruct (size_quantity_nat_pos q) as [sz EQ].\nrewrite EQ.\nsimpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\ndestruct (quantity_eq q q0); auto.\ndestruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia.\nunfold decode_val.\ndestruct (proj_bytes (mv1 :: mvl)) as [bl|] eqn:PB.\nexploit (A mv1); eauto with coqlib.\nintros [b1 EQ1]; subst mv1.\ndestruct chunk; (apply shape_decoding_u || apply shape_decoding_b); eauto with coqlib.\nunfold Val.norm_bool; destruct Val.is_bool; auto.\ndestruct chunk, Archi.ptr64; (apply shape_decoding_u || apply C); auto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q.","conclusion":"forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b)","proofString":"induction n; destruct mvs; simpl; intros; try discriminate.\ncontradiction.\ndestruct m; try discriminate.\nInvBooleans.\napply Nat.eqb_eq in H4.\nsubst.\ndestruct H0.\nsubst mv.\nexists n0; split; auto.\nlia.\neapply IHn; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv0 mvs -> exists b : byte, mv0 = Byte b) (v : val) (q : quantity) (mv : memval) (H : true = true) (H0 : False) (H1 : (0 < size_quantity_nat q)%nat) : exists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q.","conclusion":"exists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv0 mvs -> exists b : byte, mv0 = Byte b) (v : val) (q : quantity) (mv : memval) (H : true = true) (H0 : False) (H1 : (0 < size_quantity_nat q)%nat)","proofString":"contradiction."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (v : val) (q : quantity) (mv : memval) (n : nat) (IHn : forall mvs0 : list memval,\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (m : memval) (mvs : list memval) (H : match m with\n| Fragment v' q' m' =>\n    Val.eq v v' && quantity_eq q q' && (n =? m')%nat && check_value n v q mvs\n| _ => false\nend = true) (H0 : m = mv \\/ In mv mvs) (H1 : (S n < size_quantity_nat q)%nat) : exists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q.","conclusion":"exists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (v : val) (q : quantity) (mv : memval) (n : nat) (IHn : forall mvs0 : list memval,\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (m : memval) (mvs : list memval) (H : match m with\n| Fragment v' q' m' =>\n    Val.eq v v' && quantity_eq q q' && (n =? m')%nat && check_value n v q mvs\n| _ => false\nend = true) (H0 : m = mv \\/ In mv mvs) (H1 : (S n < size_quantity_nat q)%nat)","proofString":"destruct m; try discriminate.\nInvBooleans.\napply Nat.eqb_eq in H4.\nsubst.\ndestruct H0.\nsubst mv.\nexists n0; split; auto.\nlia.\neapply IHn; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (v : val) (q : quantity) (mv : memval) (n : nat) (IHn : forall mvs0 : list memval,\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (v0 : val) (q0 : quantity) (n0 : nat) (mvs : list memval) (H : Val.eq v v0 && quantity_eq q q0 && (n =? n0)%nat && check_value n v q mvs =\ntrue) (H0 : Fragment v0 q0 n0 = mv \\/ In mv mvs) (H1 : (S n < size_quantity_nat q)%nat) : exists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q.","conclusion":"exists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (v : val) (q : quantity) (mv : memval) (n : nat) (IHn : forall mvs0 : list memval,\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (v0 : val) (q0 : quantity) (n0 : nat) (mvs : list memval) (H : Val.eq v v0 && quantity_eq q q0 && (n =? n0)%nat && check_value n v q mvs =\ntrue) (H0 : Fragment v0 q0 n0 = mv \\/ In mv mvs) (H1 : (S n < size_quantity_nat q)%nat)","proofString":"InvBooleans.\napply Nat.eqb_eq in H4.\nsubst.\ndestruct H0.\nsubst mv.\nexists n0; split; auto.\nlia.\neapply IHn; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (v : val) (q : quantity) (mv : memval) (n : nat) (IHn : forall mvs0 : list memval,\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (v0 : val) (q0 : quantity) (n0 : nat) (mvs : list memval) (H0 : Fragment v0 q0 n0 = mv \\/ In mv mvs) (H1 : (S n < size_quantity_nat q)%nat) (H3 : check_value n v q mvs = true) (H4 : (n =? n0)%nat = true) (H : q = q0) (H2 : v = v0) : exists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q.","conclusion":"exists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (v : val) (q : quantity) (mv : memval) (n : nat) (IHn : forall mvs0 : list memval,\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (v0 : val) (q0 : quantity) (n0 : nat) (mvs : list memval) (H0 : Fragment v0 q0 n0 = mv \\/ In mv mvs) (H1 : (S n < size_quantity_nat q)%nat) (H3 : check_value n v q mvs = true) (H4 : (n =? n0)%nat = true) (H : q = q0) (H2 : v = v0)","proofString":"apply Nat.eqb_eq in H4.\nsubst.\ndestruct H0.\nsubst mv.\nexists n0; split; auto.\nlia.\neapply IHn; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (v : val) (q : quantity) (mv : memval) (n : nat) (IHn : forall mvs0 : list memval,\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (v0 : val) (q0 : quantity) (n0 : nat) (mvs : list memval) (H0 : Fragment v0 q0 n0 = mv \\/ In mv mvs) (H1 : (S n < size_quantity_nat q)%nat) (H3 : check_value n v q mvs = true) (H4 : n = n0) (H : q = q0) (H2 : v = v0) : exists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q.","conclusion":"exists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (v : val) (q : quantity) (mv : memval) (n : nat) (IHn : forall mvs0 : list memval,\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (v0 : val) (q0 : quantity) (n0 : nat) (mvs : list memval) (H0 : Fragment v0 q0 n0 = mv \\/ In mv mvs) (H1 : (S n < size_quantity_nat q)%nat) (H3 : check_value n v q mvs = true) (H4 : n = n0) (H : q = q0) (H2 : v = v0)","proofString":"subst.\ndestruct H0.\nsubst mv.\nexists n0; split; auto.\nlia.\neapply IHn; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (mv : memval) (n0 : nat) (q0 : quantity) (v0 : val) (IHn : forall mvs0 : list memval,\ncheck_value n0 v0 q0 mvs0 = true ->\nIn mv mvs0 ->\n(n0 < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (mvs : list memval) (H0 : Fragment v0 q0 n0 = mv \\/ In mv mvs) (H1 : (S n0 < size_quantity_nat q0)%nat) (H3 : check_value n0 v0 q0 mvs = true) : exists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0.","conclusion":"exists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (mv : memval) (n0 : nat) (q0 : quantity) (v0 : val) (IHn : forall mvs0 : list memval,\ncheck_value n0 v0 q0 mvs0 = true ->\nIn mv mvs0 ->\n(n0 < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (mvs : list memval) (H0 : Fragment v0 q0 n0 = mv \\/ In mv mvs) (H1 : (S n0 < size_quantity_nat q0)%nat) (H3 : check_value n0 v0 q0 mvs = true)","proofString":"destruct H0.\nsubst mv.\nexists n0; split; auto.\nlia.\neapply IHn; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (mv : memval) (n0 : nat) (q0 : quantity) (v0 : val) (IHn : forall mvs0 : list memval,\ncheck_value n0 v0 q0 mvs0 = true ->\nIn mv mvs0 ->\n(n0 < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (mvs : list memval) (H : Fragment v0 q0 n0 = mv) (H1 : (S n0 < size_quantity_nat q0)%nat) (H3 : check_value n0 v0 q0 mvs = true) : exists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0.","conclusion":"exists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (mv : memval) (n0 : nat) (q0 : quantity) (v0 : val) (IHn : forall mvs0 : list memval,\ncheck_value n0 v0 q0 mvs0 = true ->\nIn mv mvs0 ->\n(n0 < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (mvs : list memval) (H : Fragment v0 q0 n0 = mv) (H1 : (S n0 < size_quantity_nat q0)%nat) (H3 : check_value n0 v0 q0 mvs = true)","proofString":"subst mv.\nexists n0; split; auto.\nlia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv mvs0 -> exists b : byte, mv = Byte b) (n0 : nat) (q0 : quantity) (v0 : val) (IHn : forall mvs0 : list memval,\ncheck_value n0 v0 q0 mvs0 = true ->\nIn (Fragment v0 q0 n0) mvs0 ->\n(n0 < size_quantity_nat q0)%nat ->\nexists j : nat,\n  Fragment v0 q0 n0 = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (mvs : list memval) (H1 : (S n0 < size_quantity_nat q0)%nat) (H3 : check_value n0 v0 q0 mvs = true) : exists j : nat,\n  Fragment v0 q0 n0 = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0.","conclusion":"exists j : nat,\n  Fragment v0 q0 n0 = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv mvs0 -> exists b : byte, mv = Byte b) (n0 : nat) (q0 : quantity) (v0 : val) (IHn : forall mvs0 : list memval,\ncheck_value n0 v0 q0 mvs0 = true ->\nIn (Fragment v0 q0 n0) mvs0 ->\n(n0 < size_quantity_nat q0)%nat ->\nexists j : nat,\n  Fragment v0 q0 n0 = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (mvs : list memval) (H1 : (S n0 < size_quantity_nat q0)%nat) (H3 : check_value n0 v0 q0 mvs = true)","proofString":"exists n0; split; auto.\nlia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv mvs0 -> exists b : byte, mv = Byte b) (n0 : nat) (q0 : quantity) (v0 : val) (IHn : forall mvs0 : list memval,\ncheck_value n0 v0 q0 mvs0 = true ->\nIn (Fragment v0 q0 n0) mvs0 ->\n(n0 < size_quantity_nat q0)%nat ->\nexists j : nat,\n  Fragment v0 q0 n0 = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (mvs : list memval) (H1 : (S n0 < size_quantity_nat q0)%nat) (H3 : check_value n0 v0 q0 mvs = true) : S n0 <> size_quantity_nat q0.","conclusion":"S n0 <> size_quantity_nat q0","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv mvs0 -> exists b : byte, mv = Byte b) (n0 : nat) (q0 : quantity) (v0 : val) (IHn : forall mvs0 : list memval,\ncheck_value n0 v0 q0 mvs0 = true ->\nIn (Fragment v0 q0 n0) mvs0 ->\n(n0 < size_quantity_nat q0)%nat ->\nexists j : nat,\n  Fragment v0 q0 n0 = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (mvs : list memval) (H1 : (S n0 < size_quantity_nat q0)%nat) (H3 : check_value n0 v0 q0 mvs = true)","proofString":"lia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (mv : memval) (n0 : nat) (q0 : quantity) (v0 : val) (IHn : forall mvs0 : list memval,\ncheck_value n0 v0 q0 mvs0 = true ->\nIn mv mvs0 ->\n(n0 < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (mvs : list memval) (H : In mv mvs) (H1 : (S n0 < size_quantity_nat q0)%nat) (H3 : check_value n0 v0 q0 mvs = true) : exists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0.","conclusion":"exists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (mv : memval) (n0 : nat) (q0 : quantity) (v0 : val) (IHn : forall mvs0 : list memval,\ncheck_value n0 v0 q0 mvs0 = true ->\nIn mv mvs0 ->\n(n0 < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (mvs : list memval) (H : In mv mvs) (H1 : (S n0 < size_quantity_nat q0)%nat) (H3 : check_value n0 v0 q0 mvs = true)","proofString":"eapply IHn; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (mv : memval) (n0 : nat) (q0 : quantity) (v0 : val) (IHn : forall mvs0 : list memval,\ncheck_value n0 v0 q0 mvs0 = true ->\nIn mv mvs0 ->\n(n0 < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (mvs : list memval) (H : In mv mvs) (H1 : (S n0 < size_quantity_nat q0)%nat) (H3 : check_value n0 v0 q0 mvs = true) : (n0 < size_quantity_nat q0)%nat.","conclusion":"(n0 < size_quantity_nat q0)%nat","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv0 : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv0 mvs0 -> exists b : byte, mv0 = Byte b) (mv : memval) (n0 : nat) (q0 : quantity) (v0 : val) (IHn : forall mvs0 : list memval,\ncheck_value n0 v0 q0 mvs0 = true ->\nIn mv mvs0 ->\n(n0 < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (mvs : list memval) (H : In mv mvs) (H1 : (S n0 < size_quantity_nat q0)%nat) (H3 : check_value n0 v0 q0 mvs = true)","proofString":"lia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) : shape_decoding chunk (mv1 :: mvl) (decode_val chunk (mv1 :: mvl)).","conclusion":"shape_decoding chunk (mv1 :: mvl) (decode_val chunk (mv1 :: mvl))","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q)","proofString":"assert (U: forall mvs, shape_decoding chunk mvs (Val.load_result chunk Vundef)).\nintros.\nreplace (Val.load_result chunk Vundef) with Vundef.\nconstructor.\ndestruct chunk; auto.\nassert (C: forall q, size_quantity_nat q = size_chunk_nat chunk ->             (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) ->             shape_decoding chunk (mv1 :: mvl) (Val.load_result chunk (proj_value q (mv1 :: mvl)))).\nintros.\nunfold proj_value.\ndestruct mv1; auto.\ndestruct (size_quantity_nat_pos q) as [sz EQ].\nrewrite EQ.\nsimpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\ndestruct (quantity_eq q q0); auto.\ndestruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia.\nunfold decode_val.\ndestruct (proj_bytes (mv1 :: mvl)) as [bl|] eqn:PB.\nexploit (A mv1); eauto with coqlib.\nintros [b1 EQ1]; subst mv1.\ndestruct chunk; (apply shape_decoding_u || apply shape_decoding_b); eauto with coqlib.\nunfold Val.norm_bool; destruct Val.is_bool; auto.\ndestruct chunk, Archi.ptr64; (apply shape_decoding_u || apply C); auto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef).","conclusion":"forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q)","proofString":"intros.\nreplace (Val.load_result chunk Vundef) with Vundef.\nconstructor.\ndestruct chunk; auto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv mvs0 -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs0 : list memval),\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (mvs : list memval) : shape_decoding chunk mvs (Val.load_result chunk Vundef).","conclusion":"shape_decoding chunk mvs (Val.load_result chunk Vundef)","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv mvs0 -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs0 : list memval),\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (mvs : list memval)","proofString":"replace (Val.load_result chunk Vundef) with Vundef.\nconstructor.\ndestruct chunk; auto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv mvs0 -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs0 : list memval),\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (mvs : list memval) : shape_decoding chunk mvs Vundef.","conclusion":"shape_decoding chunk mvs Vundef","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv mvs0 -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs0 : list memval),\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (mvs : list memval)","proofString":"constructor."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv mvs0 -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs0 : list memval),\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (mvs : list memval) : Vundef = Val.load_result chunk Vundef.","conclusion":"Vundef = Val.load_result chunk Vundef","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs0 : list memval) (bs : list byte),\nproj_bytes mvs0 = Some bs -> In mv mvs0 -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs0 : list memval),\ncheck_value n v q mvs0 = true ->\nIn mv mvs0 ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (mvs : list memval)","proofString":"destruct chunk; auto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) : shape_decoding chunk (mv1 :: mvl) (decode_val chunk (mv1 :: mvl)).","conclusion":"shape_decoding chunk (mv1 :: mvl) (decode_val chunk (mv1 :: mvl))","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef))","proofString":"assert (C: forall q, size_quantity_nat q = size_chunk_nat chunk ->             (chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) ->             shape_decoding chunk (mv1 :: mvl) (Val.load_result chunk (proj_value q (mv1 :: mvl)))).\nintros.\nunfold proj_value.\ndestruct mv1; auto.\ndestruct (size_quantity_nat_pos q) as [sz EQ].\nrewrite EQ.\nsimpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\ndestruct (quantity_eq q q0); auto.\ndestruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia.\nunfold decode_val.\ndestruct (proj_bytes (mv1 :: mvl)) as [bl|] eqn:PB.\nexploit (A mv1); eauto with coqlib.\nintros [b1 EQ1]; subst mv1.\ndestruct chunk; (apply shape_decoding_u || apply shape_decoding_b); eauto with coqlib.\nunfold Val.norm_bool; destruct Val.is_bool; auto.\ndestruct chunk, Archi.ptr64; (apply shape_decoding_u || apply C); auto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl))).","conclusion":"forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl)))","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef))","proofString":"intros.\nunfold proj_value.\ndestruct mv1; auto.\ndestruct (size_quantity_nat_pos q) as [sz EQ].\nrewrite EQ.\nsimpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\ndestruct (quantity_eq q q0); auto.\ndestruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) : shape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl))).","conclusion":"shape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl)))","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","proofString":"unfold proj_value.\ndestruct mv1; auto.\ndestruct (size_quantity_nat_pos q) as [sz EQ].\nrewrite EQ.\nsimpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\ndestruct (quantity_eq q q0); auto.\ndestruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) : shape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk\n     match mv1 with\n     | Fragment v _ _ =>\n         if check_value (size_quantity_nat q) v q (mv1 :: mvl)\n         then v\n         else Vundef\n     | _ => Vundef\n     end).","conclusion":"shape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk\n     match mv1 with\n     | Fragment v _ _ =>\n         if check_value (size_quantity_nat q) v q (mv1 :: mvl)\n         then v\n         else Vundef\n     | _ => Vundef\n     end)","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","proofString":"destruct mv1; auto.\ndestruct (size_quantity_nat_pos q) as [sz EQ].\nrewrite EQ.\nsimpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\ndestruct (quantity_eq q q0); auto.\ndestruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) : shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if check_value (size_quantity_nat q) v q (Fragment v q0 n :: mvl)\n      then v\n      else Vundef)).","conclusion":"shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if check_value (size_quantity_nat q) v q (Fragment v q0 n :: mvl)\n      then v\n      else Vundef))","hypotheses":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64)","proofString":"destruct (size_quantity_nat_pos q) as [sz EQ].\nrewrite EQ.\nsimpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\ndestruct (quantity_eq q q0); auto.\ndestruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) : shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if check_value (size_quantity_nat q) v q (Fragment v q0 n :: mvl)\n      then v\n      else Vundef)).","conclusion":"shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if check_value (size_quantity_nat q) v q (Fragment v q0 n :: mvl)\n      then v\n      else Vundef))","hypotheses":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz)","proofString":"rewrite EQ.\nsimpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\ndestruct (quantity_eq q q0); auto.\ndestruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) : shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if check_value (S sz) v q (Fragment v q0 n :: mvl) then v else Vundef)).","conclusion":"shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if check_value (S sz) v q (Fragment v q0 n :: mvl) then v else Vundef))","hypotheses":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz)","proofString":"simpl.\nunfold proj_sumbool.\nrewrite dec_eq_true.\ndestruct (quantity_eq q q0); auto.\ndestruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) : shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if\n       Val.eq v v && quantity_eq q q0 && (sz =? n)%nat &&\n       check_value sz v q mvl\n      then v\n      else Vundef)).","conclusion":"shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if\n       Val.eq v v && quantity_eq q q0 && (sz =? n)%nat &&\n       check_value sz v q mvl\n      then v\n      else Vundef))","hypotheses":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz)","proofString":"unfold proj_sumbool.\nrewrite dec_eq_true.\ndestruct (quantity_eq q q0); auto.\ndestruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) : shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if\n       (if Val.eq v v then true else false) &&\n       (if quantity_eq q q0 then true else false) && \n       (sz =? n)%nat && check_value sz v q mvl\n      then v\n      else Vundef)).","conclusion":"shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if\n       (if Val.eq v v then true else false) &&\n       (if quantity_eq q q0 then true else false) && \n       (sz =? n)%nat && check_value sz v q mvl\n      then v\n      else Vundef))","hypotheses":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz)","proofString":"rewrite dec_eq_true.\ndestruct (quantity_eq q q0); auto.\ndestruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) : shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if\n       true && (if quantity_eq q q0 then true else false) && (sz =? n)%nat &&\n       check_value sz v q mvl\n      then v\n      else Vundef)).","conclusion":"shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if\n       true && (if quantity_eq q q0 then true else false) && (sz =? n)%nat &&\n       check_value sz v q mvl\n      then v\n      else Vundef))","hypotheses":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz)","proofString":"destruct (quantity_eq q q0); auto.\ndestruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (e : q = q0) : shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if true && true && (sz =? n)%nat && check_value sz v q mvl\n      then v\n      else Vundef)).","conclusion":"shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if true && true && (sz =? n)%nat && check_value sz v q mvl\n      then v\n      else Vundef))","hypotheses":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (e : q = q0)","proofString":"destruct (Nat.eqb sz n) eqn:EQN; auto.\ndestruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (e : q = q0) (EQN : (sz =? n)%nat = true) : shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if true && true && true && check_value sz v q mvl then v else Vundef)).","conclusion":"shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk\n     (if true && true && true && check_value sz v q mvl then v else Vundef))","hypotheses":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (e : q = q0) (EQN : (sz =? n)%nat = true)","proofString":"destruct (check_value sz v q mvl) eqn:CHECK; auto.\nsimpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (e : q = q0) (EQN : (sz =? n)%nat = true) (CHECK : check_value sz v q mvl = true) : shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk (if true && true && true && true then v else Vundef)).","conclusion":"shape_decoding chunk (Fragment v q0 n :: mvl)\n  (Val.load_result chunk (if true && true && true && true then v else Vundef))","hypotheses":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (e : q = q0) (EQN : (sz =? n)%nat = true) (CHECK : check_value sz v q mvl = true)","proofString":"simpl.\napply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (e : q = q0) (EQN : (sz =? n)%nat = true) (CHECK : check_value sz v q mvl = true) : shape_decoding chunk (Fragment v q0 n :: mvl) (Val.load_result chunk v).","conclusion":"shape_decoding chunk (Fragment v q0 n :: mvl) (Val.load_result chunk v)","hypotheses":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (e : q = q0) (EQN : (sz =? n)%nat = true) (CHECK : check_value sz v q mvl = true)","proofString":"apply Nat.eqb_eq in EQN.\nsubst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (e : q = q0) (EQN : sz = n) (CHECK : check_value sz v q mvl = true) : shape_decoding chunk (Fragment v q0 n :: mvl) (Val.load_result chunk v).","conclusion":"shape_decoding chunk (Fragment v q0 n :: mvl) (Val.load_result chunk v)","hypotheses":"(chunk : memory_chunk) (v : val) (q0 : quantity) (n : nat) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q1 : quantity) (mv : memval) (n0 : nat)\n  (mvs : list memval),\ncheck_value n0 v0 q1 mvs = true ->\nIn mv mvs ->\n(n0 < size_quantity_nat q1)%nat ->\nexists j : nat, mv = Fragment v0 q1 j /\\ S j <> size_quantity_nat q1) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (e : q = q0) (EQN : sz = n) (CHECK : check_value sz v q mvl = true)","proofString":"subst n q0.\nconstructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true) : shape_decoding chunk (Fragment v q sz :: mvl) (Val.load_result chunk v).","conclusion":"shape_decoding chunk (Fragment v q sz :: mvl) (Val.load_result chunk v)","hypotheses":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true)","proofString":"constructor.\nauto.\ndestruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate.\ncongruence.\nintros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true) : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64.","conclusion":"chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64","hypotheses":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true)","proofString":"auto."},{"statement":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true) : q = quantity_chunk chunk.","conclusion":"q = quantity_chunk chunk","hypotheses":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true)","proofString":"destruct H0 as [E|[E|[E|E]]]; subst chunk; destruct q; auto || discriminate."},{"statement":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true) : S sz = size_quantity_nat q.","conclusion":"S sz = size_quantity_nat q","hypotheses":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true)","proofString":"congruence."},{"statement":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true) : forall mv : memval,\nIn mv mvl ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q.","conclusion":"forall mv : memval,\nIn mv mvl ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q","hypotheses":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true)","proofString":"intros.\neapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv0 : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv0 mvs -> exists b : byte, mv0 = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv0 : memval) (n : nat)\n  (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv0 mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv0 = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true) (mv : memval) (H1 : In mv mvl) : exists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q.","conclusion":"exists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q","hypotheses":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv0 : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv0 mvs -> exists b : byte, mv0 = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv0 : memval) (n : nat)\n  (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv0 mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv0 = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true) (mv : memval) (H1 : In mv mvl)","proofString":"eapply B; eauto.\nlia."},{"statement":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv0 : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv0 mvs -> exists b : byte, mv0 = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv0 : memval) (n : nat)\n  (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv0 mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv0 = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true) (mv : memval) (H1 : In mv mvl) : (sz < size_quantity_nat q)%nat.","conclusion":"(sz < size_quantity_nat q)%nat","hypotheses":"(chunk : memory_chunk) (v : val) (mvl : list memval) (A : forall (mv0 : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv0 mvs -> exists b : byte, mv0 = Byte b) (B : forall (v0 : val) (q0 : quantity) (mv0 : memval) (n : nat)\n  (mvs : list memval),\ncheck_value n v0 q0 mvs = true ->\nIn mv0 mvs ->\n(n < size_quantity_nat q0)%nat ->\nexists j : nat, mv0 = Fragment v0 q0 j /\\ S j <> size_quantity_nat q0) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (q : quantity) (H : size_quantity_nat q = size_chunk_nat chunk) (H0 : chunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64) (sz : nat) (EQ : size_quantity_nat q = S sz) (CHECK : check_value sz v q mvl = true) (mv : memval) (H1 : In mv mvl)","proofString":"lia."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl)))) : shape_decoding chunk (mv1 :: mvl) (decode_val chunk (mv1 :: mvl)).","conclusion":"shape_decoding chunk (mv1 :: mvl) (decode_val chunk (mv1 :: mvl))","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl))))","proofString":"unfold decode_val.\ndestruct (proj_bytes (mv1 :: mvl)) as [bl|] eqn:PB.\nexploit (A mv1); eauto with coqlib.\nintros [b1 EQ1]; subst mv1.\ndestruct chunk; (apply shape_decoding_u || apply shape_decoding_b); eauto with coqlib.\nunfold Val.norm_bool; destruct Val.is_bool; auto.\ndestruct chunk, Archi.ptr64; (apply shape_decoding_u || apply C); auto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl)))) : shape_decoding chunk (mv1 :: mvl)\n  match proj_bytes (mv1 :: mvl) with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 (mv1 :: mvl))\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 (mv1 :: mvl))\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 (mv1 :: mvl))\n      | Many64 => Val.load_result chunk (proj_value Q64 (mv1 :: mvl))\n      | _ => Vundef\n      end\n  end.","conclusion":"shape_decoding chunk (mv1 :: mvl)\n  match proj_bytes (mv1 :: mvl) with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 (mv1 :: mvl))\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 (mv1 :: mvl))\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 (mv1 :: mvl))\n      | Many64 => Val.load_result chunk (proj_value Q64 (mv1 :: mvl))\n      | _ => Vundef\n      end\n  end","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl))))","proofString":"destruct (proj_bytes (mv1 :: mvl)) as [bl|] eqn:PB.\nexploit (A mv1); eauto with coqlib.\nintros [b1 EQ1]; subst mv1.\ndestruct chunk; (apply shape_decoding_u || apply shape_decoding_b); eauto with coqlib.\nunfold Val.norm_bool; destruct Val.is_bool; auto.\ndestruct chunk, Archi.ptr64; (apply shape_decoding_u || apply C); auto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl)))) (bl : list byte) (PB : proj_bytes (mv1 :: mvl) = Some bl) : shape_decoding chunk (mv1 :: mvl)\n  match chunk with\n  | Mbool => Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n  | Mint32 => Vint (Int.repr (decode_int bl))\n  | Mint64 => Vlong (Int64.repr (decode_int bl))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n  | _ => Vundef\n  end.","conclusion":"shape_decoding chunk (mv1 :: mvl)\n  match chunk with\n  | Mbool => Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n  | Mint32 => Vint (Int.repr (decode_int bl))\n  | Mint64 => Vlong (Int64.repr (decode_int bl))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n  | _ => Vundef\n  end","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl)))) (bl : list byte) (PB : proj_bytes (mv1 :: mvl) = Some bl)","proofString":"exploit (A mv1); eauto with coqlib.\nintros [b1 EQ1]; subst mv1.\ndestruct chunk; (apply shape_decoding_u || apply shape_decoding_b); eauto with coqlib.\nunfold Val.norm_bool; destruct Val.is_bool; auto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl)))) (bl : list byte) (PB : proj_bytes (mv1 :: mvl) = Some bl) : (exists b : byte, mv1 = Byte b) ->\nshape_decoding chunk (mv1 :: mvl)\n  match chunk with\n  | Mbool => Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n  | Mint32 => Vint (Int.repr (decode_int bl))\n  | Mint64 => Vlong (Int64.repr (decode_int bl))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n  | _ => Vundef\n  end.","conclusion":"(exists b : byte, mv1 = Byte b) ->\nshape_decoding chunk (mv1 :: mvl)\n  match chunk with\n  | Mbool => Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n  | Mint32 => Vint (Int.repr (decode_int bl))\n  | Mint64 => Vlong (Int64.repr (decode_int bl))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n  | _ => Vundef\n  end","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl)))) (bl : list byte) (PB : proj_bytes (mv1 :: mvl) = Some bl)","proofString":"intros [b1 EQ1]; subst mv1.\ndestruct chunk; (apply shape_decoding_u || apply shape_decoding_b); eauto with coqlib.\nunfold Val.norm_bool; destruct Val.is_bool; auto."},{"statement":"(chunk : memory_chunk) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (b1 : byte) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (Byte b1 :: mvl)\n  (Val.load_result chunk (proj_value q (Byte b1 :: mvl)))) (bl : list byte) (PB : proj_bytes (Byte b1 :: mvl) = Some bl) : shape_decoding chunk (Byte b1 :: mvl)\n  match chunk with\n  | Mbool => Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n  | Mint32 => Vint (Int.repr (decode_int bl))\n  | Mint64 => Vlong (Int64.repr (decode_int bl))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n  | _ => Vundef\n  end.","conclusion":"shape_decoding chunk (Byte b1 :: mvl)\n  match chunk with\n  | Mbool => Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n  | Mint32 => Vint (Int.repr (decode_int bl))\n  | Mint64 => Vlong (Int64.repr (decode_int bl))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n  | _ => Vundef\n  end","hypotheses":"(chunk : memory_chunk) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (b1 : byte) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (Byte b1 :: mvl)\n  (Val.load_result chunk (proj_value q (Byte b1 :: mvl)))) (bl : list byte) (PB : proj_bytes (Byte b1 :: mvl) = Some bl)","proofString":"destruct chunk; (apply shape_decoding_u || apply shape_decoding_b); eauto with coqlib.\nunfold Val.norm_bool; destruct Val.is_bool; auto."},{"statement":"(mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding Mbool mvs (Val.load_result Mbool Vundef)) (b1 : byte) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat Mbool ->\nMbool = Mint32 \\/ Mbool = Many32 \\/ Mbool = Mint64 \\/ Mbool = Many64 ->\nshape_decoding Mbool (Byte b1 :: mvl)\n  (Val.load_result Mbool (proj_value q (Byte b1 :: mvl)))) (bl : list byte) (PB : proj_bytes (Byte b1 :: mvl) = Some bl) : match Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))) with\n| Vptr _ _ => False\n| _ => True\nend.","conclusion":"match Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))) with\n| Vptr _ _ => False\n| _ => True\nend","hypotheses":"(mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding Mbool mvs (Val.load_result Mbool Vundef)) (b1 : byte) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat Mbool ->\nMbool = Mint32 \\/ Mbool = Many32 \\/ Mbool = Mint64 \\/ Mbool = Many64 ->\nshape_decoding Mbool (Byte b1 :: mvl)\n  (Val.load_result Mbool (proj_value q (Byte b1 :: mvl)))) (bl : list byte) (PB : proj_bytes (Byte b1 :: mvl) = Some bl)","proofString":"unfold Val.norm_bool; destruct Val.is_bool; auto."},{"statement":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl)))) (PB : proj_bytes (mv1 :: mvl) = None) : shape_decoding chunk (mv1 :: mvl)\n  match chunk with\n  | Mint32 =>\n      if Archi.ptr64\n      then Vundef\n      else Val.load_result chunk (proj_value Q32 (mv1 :: mvl))\n  | Mint64 =>\n      if Archi.ptr64\n      then Val.load_result chunk (proj_value Q64 (mv1 :: mvl))\n      else Vundef\n  | Many32 => Val.load_result chunk (proj_value Q32 (mv1 :: mvl))\n  | Many64 => Val.load_result chunk (proj_value Q64 (mv1 :: mvl))\n  | _ => Vundef\n  end.","conclusion":"shape_decoding chunk (mv1 :: mvl)\n  match chunk with\n  | Mint32 =>\n      if Archi.ptr64\n      then Vundef\n      else Val.load_result chunk (proj_value Q32 (mv1 :: mvl))\n  | Mint64 =>\n      if Archi.ptr64\n      then Val.load_result chunk (proj_value Q64 (mv1 :: mvl))\n      else Vundef\n  | Many32 => Val.load_result chunk (proj_value Q32 (mv1 :: mvl))\n  | Many64 => Val.load_result chunk (proj_value Q64 (mv1 :: mvl))\n  | _ => Vundef\n  end","hypotheses":"(chunk : memory_chunk) (mv1 : memval) (mvl : list memval) (A : forall (mv : memval) (mvs : list memval) (bs : list byte),\nproj_bytes mvs = Some bs -> In mv mvs -> exists b : byte, mv = Byte b) (B : forall (v : val) (q : quantity) (mv : memval) (n : nat) (mvs : list memval),\ncheck_value n v q mvs = true ->\nIn mv mvs ->\n(n < size_quantity_nat q)%nat ->\nexists j : nat, mv = Fragment v q j /\\ S j <> size_quantity_nat q) (U : forall mvs : list memval,\nshape_decoding chunk mvs (Val.load_result chunk Vundef)) (C : forall q : quantity,\nsize_quantity_nat q = size_chunk_nat chunk ->\nchunk = Mint32 \\/ chunk = Many32 \\/ chunk = Mint64 \\/ chunk = Many64 ->\nshape_decoding chunk (mv1 :: mvl)\n  (Val.load_result chunk (proj_value q (mv1 :: mvl)))) (PB : proj_bytes (mv1 :: mvl) = None)","proofString":"destruct chunk, Archi.ptr64; (apply shape_decoding_u || apply C); auto."},{"statement":"(f f' : meminj) (v1 v2 : memval) (H : memval_inject f v1 v2) (H0 : inject_incr f f') : memval_inject f' v1 v2.","conclusion":"memval_inject f' v1 v2","hypotheses":"(f f' : meminj) (v1 v2 : memval) (H : memval_inject f v1 v2) (H0 : inject_incr f f')","proofString":"inv H; econstructor.\neapply val_inject_incr; eauto."},{"statement":"(f f' : meminj) (H0 : inject_incr f f') (v0 v3 : val) (q : quantity) (n : nat) (H1 : Val.inject f v0 v3) : Val.inject f' v0 v3.","conclusion":"Val.inject f' v0 v3","hypotheses":"(f f' : meminj) (H0 : inject_incr f f') (v0 v3 : val) (q : quantity) (n : nat) (H1 : Val.inject f v0 v3)","proofString":"eapply val_inject_incr; eauto."},{"statement":"(f : meminj) : forall bl : list byte, Some nil = Some bl -> Some nil = Some bl.","conclusion":"forall bl : list byte, Some nil = Some bl -> Some nil = Some bl","hypotheses":"(f : meminj)","proofString":"congruence."},{"statement":"(f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall bl0 : list byte, proj_bytes al = Some bl0 -> proj_bytes bl = Some bl0) : forall bl0 : list byte,\nmatch a1 with\n| Byte b =>\n    match proj_bytes al with\n    | Some bl1 => Some (b :: bl1)\n    | None => None\n    end\n| _ => None\nend = Some bl0 ->\nmatch b1 with\n| Byte b =>\n    match proj_bytes bl with\n    | Some bl1 => Some (b :: bl1)\n    | None => None\n    end\n| _ => None\nend = Some bl0.","conclusion":"forall bl0 : list byte,\nmatch a1 with\n| Byte b =>\n    match proj_bytes al with\n    | Some bl1 => Some (b :: bl1)\n    | None => None\n    end\n| _ => None\nend = Some bl0 ->\nmatch b1 with\n| Byte b =>\n    match proj_bytes bl with\n    | Some bl1 => Some (b :: bl1)\n    | None => None\n    end\n| _ => None\nend = Some bl0","hypotheses":"(f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall bl0 : list byte, proj_bytes al = Some bl0 -> proj_bytes bl = Some bl0)","proofString":"inv H; try congruence.\ndestruct (proj_bytes al); intros.\ninv H.\nrewrite (IHlist_forall2 l); auto.\ncongruence."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall bl0 : list byte, proj_bytes al = Some bl0 -> proj_bytes bl = Some bl0) (n : byte) : forall bl0 : list byte,\nmatch proj_bytes al with\n| Some bl1 => Some (n :: bl1)\n| None => None\nend = Some bl0 ->\nmatch proj_bytes bl with\n| Some bl1 => Some (n :: bl1)\n| None => None\nend = Some bl0.","conclusion":"forall bl0 : list byte,\nmatch proj_bytes al with\n| Some bl1 => Some (n :: bl1)\n| None => None\nend = Some bl0 ->\nmatch proj_bytes bl with\n| Some bl1 => Some (n :: bl1)\n| None => None\nend = Some bl0","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall bl0 : list byte, proj_bytes al = Some bl0 -> proj_bytes bl = Some bl0) (n : byte)","proofString":"destruct (proj_bytes al); intros.\ninv H.\nrewrite (IHlist_forall2 l); auto.\ncongruence."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (l : list byte) (IHlist_forall2 : forall bl1 : list byte, Some l = Some bl1 -> proj_bytes bl = Some bl1) (n : byte) (bl0 : list byte) (H : Some (n :: l) = Some bl0) : match proj_bytes bl with\n| Some bl1 => Some (n :: bl1)\n| None => None\nend = Some bl0.","conclusion":"match proj_bytes bl with\n| Some bl1 => Some (n :: bl1)\n| None => None\nend = Some bl0","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (l : list byte) (IHlist_forall2 : forall bl1 : list byte, Some l = Some bl1 -> proj_bytes bl = Some bl1) (n : byte) (bl0 : list byte) (H : Some (n :: l) = Some bl0)","proofString":"inv H.\nrewrite (IHlist_forall2 l); auto."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (l : list byte) (IHlist_forall2 : forall bl0 : list byte, Some l = Some bl0 -> proj_bytes bl = Some bl0) (n : byte) : match proj_bytes bl with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend = Some (n :: l).","conclusion":"match proj_bytes bl with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend = Some (n :: l)","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (l : list byte) (IHlist_forall2 : forall bl0 : list byte, Some l = Some bl0 -> proj_bytes bl = Some bl0) (n : byte)","proofString":"rewrite (IHlist_forall2 l); auto."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall bl1 : list byte, None = Some bl1 -> proj_bytes bl = Some bl1) (n : byte) (bl0 : list byte) (H : None = Some bl0) : match proj_bytes bl with\n| Some bl1 => Some (n :: bl1)\n| None => None\nend = Some bl0.","conclusion":"match proj_bytes bl with\n| Some bl1 => Some (n :: bl1)\n| None => None\nend = Some bl0","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall bl1 : list byte, None = Some bl1 -> proj_bytes bl = Some bl1) (n : byte) (bl0 : list byte) (H : None = Some bl0)","proofString":"congruence."},{"statement":"(f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H1 : match a1 with\n| Fragment v'0 q' m' =>\n    Val.eq v v'0 && quantity_eq q q' && (n =? m')%nat && check_value n v q al\n| _ => false\nend = true) (H2 : Val.inject f v v') (H3 : v <> Vundef) : match b1 with\n| Fragment v'0 q' m' =>\n    Val.eq v' v'0 && quantity_eq q q' && (n =? m')%nat &&\n    check_value n v' q bl\n| _ => false\nend = true.","conclusion":"match b1 with\n| Fragment v'0 q' m' =>\n    Val.eq v' v'0 && quantity_eq q q' && (n =? m')%nat &&\n    check_value n v' q bl\n| _ => false\nend = true","hypotheses":"(f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H1 : match a1 with\n| Fragment v'0 q' m' =>\n    Val.eq v v'0 && quantity_eq q q' && (n =? m')%nat && check_value n v q al\n| _ => false\nend = true) (H2 : Val.inject f v v') (H3 : v <> Vundef)","proofString":"inv H; auto.\nInvBooleans.\nassert (n = n0) by (apply Nat.eqb_eq; auto).\nsubst v1 q0 n0.\nreplace v2 with v'.\nunfold proj_sumbool; rewrite ! dec_eq_true.\nrewrite Nat.eqb_refl.\nsimpl; eauto.\ninv H2; try discriminate; inv H4; congruence.\ndiscriminate."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q1 : quantity) (n1 : nat),\ncheck_value n1 v0 q1 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n1 v'0 q1 bl = true) (v v' : val) (q : quantity) (n : nat) (v1 : val) (q0 : quantity) (n0 : nat) (H1 : Val.eq v v1 && quantity_eq q q0 && (n =? n0)%nat && check_value n v q al =\ntrue) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v1 v2) : Val.eq v' v2 && quantity_eq q q0 && (n =? n0)%nat && check_value n v' q bl =\ntrue.","conclusion":"Val.eq v' v2 && quantity_eq q q0 && (n =? n0)%nat && check_value n v' q bl =\ntrue","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q1 : quantity) (n1 : nat),\ncheck_value n1 v0 q1 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n1 v'0 q1 bl = true) (v v' : val) (q : quantity) (n : nat) (v1 : val) (q0 : quantity) (n0 : nat) (H1 : Val.eq v v1 && quantity_eq q q0 && (n =? n0)%nat && check_value n v q al =\ntrue) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v1 v2)","proofString":"InvBooleans.\nassert (n = n0) by (apply Nat.eqb_eq; auto).\nsubst v1 q0 n0.\nreplace v2 with v'.\nunfold proj_sumbool; rewrite ! dec_eq_true.\nrewrite Nat.eqb_refl.\nsimpl; eauto.\ninv H2; try discriminate; inv H4; congruence."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q1 : quantity) (n1 : nat),\ncheck_value n1 v0 q1 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n1 v'0 q1 bl = true) (v v' : val) (q : quantity) (n : nat) (v1 : val) (q0 : quantity) (n0 : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v1 v2) (H5 : check_value n v q al = true) (H6 : (n =? n0)%nat = true) (H1 : q = q0) (H : v = v1) : Val.eq v' v2 && quantity_eq q q0 && (n =? n0)%nat && check_value n v' q bl =\ntrue.","conclusion":"Val.eq v' v2 && quantity_eq q q0 && (n =? n0)%nat && check_value n v' q bl =\ntrue","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q1 : quantity) (n1 : nat),\ncheck_value n1 v0 q1 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n1 v'0 q1 bl = true) (v v' : val) (q : quantity) (n : nat) (v1 : val) (q0 : quantity) (n0 : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v1 v2) (H5 : check_value n v q al = true) (H6 : (n =? n0)%nat = true) (H1 : q = q0) (H : v = v1)","proofString":"assert (n = n0) by (apply Nat.eqb_eq; auto).\nsubst v1 q0 n0.\nreplace v2 with v'.\nunfold proj_sumbool; rewrite ! dec_eq_true.\nrewrite Nat.eqb_refl.\nsimpl; eauto.\ninv H2; try discriminate; inv H4; congruence."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q1 : quantity) (n1 : nat),\ncheck_value n1 v0 q1 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n1 v'0 q1 bl = true) (v v' : val) (q : quantity) (n : nat) (v1 : val) (q0 : quantity) (n0 : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v1 v2) (H5 : check_value n v q al = true) (H6 : (n =? n0)%nat = true) (H1 : q = q0) (H : v = v1) (H7 : n = n0) : Val.eq v' v2 && quantity_eq q q0 && (n =? n0)%nat && check_value n v' q bl =\ntrue.","conclusion":"Val.eq v' v2 && quantity_eq q q0 && (n =? n0)%nat && check_value n v' q bl =\ntrue","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q1 : quantity) (n1 : nat),\ncheck_value n1 v0 q1 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n1 v'0 q1 bl = true) (v v' : val) (q : quantity) (n : nat) (v1 : val) (q0 : quantity) (n0 : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v1 v2) (H5 : check_value n v q al = true) (H6 : (n =? n0)%nat = true) (H1 : q = q0) (H : v = v1) (H7 : n = n0)","proofString":"subst v1 q0 n0.\nreplace v2 with v'.\nunfold proj_sumbool; rewrite ! dec_eq_true.\nrewrite Nat.eqb_refl.\nsimpl; eauto.\ninv H2; try discriminate; inv H4; congruence."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v v2) (H5 : check_value n v q al = true) (H6 : (n =? n)%nat = true) : Val.eq v' v2 && quantity_eq q q && (n =? n)%nat && check_value n v' q bl =\ntrue.","conclusion":"Val.eq v' v2 && quantity_eq q q && (n =? n)%nat && check_value n v' q bl =\ntrue","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v v2) (H5 : check_value n v q al = true) (H6 : (n =? n)%nat = true)","proofString":"replace v2 with v'.\nunfold proj_sumbool; rewrite ! dec_eq_true.\nrewrite Nat.eqb_refl.\nsimpl; eauto.\ninv H2; try discriminate; inv H4; congruence."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v v2) (H5 : check_value n v q al = true) (H6 : (n =? n)%nat = true) : Val.eq v' v' && quantity_eq q q && (n =? n)%nat && check_value n v' q bl =\ntrue.","conclusion":"Val.eq v' v' && quantity_eq q q && (n =? n)%nat && check_value n v' q bl =\ntrue","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v v2) (H5 : check_value n v q al = true) (H6 : (n =? n)%nat = true)","proofString":"unfold proj_sumbool; rewrite ! dec_eq_true.\nrewrite Nat.eqb_refl.\nsimpl; eauto."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v v2) (H5 : check_value n v q al = true) (H6 : (n =? n)%nat = true) : true && true && (n =? n)%nat && check_value n v' q bl = true.","conclusion":"true && true && (n =? n)%nat && check_value n v' q bl = true","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v v2) (H5 : check_value n v q al = true) (H6 : (n =? n)%nat = true)","proofString":"rewrite Nat.eqb_refl.\nsimpl; eauto."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v v2) (H5 : check_value n v q al = true) (H6 : (n =? n)%nat = true) : true && true && true && check_value n v' q bl = true.","conclusion":"true && true && true && check_value n v' q bl = true","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v v2) (H5 : check_value n v q al = true) (H6 : (n =? n)%nat = true)","proofString":"simpl; eauto."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v v2) (H5 : check_value n v q al = true) (H6 : (n =? n)%nat = true) : v' = v2.","conclusion":"v' = v2","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H2 : Val.inject f v v') (H3 : v <> Vundef) (v2 : val) (H4 : Val.inject f v v2) (H5 : check_value n v q al = true) (H6 : (n =? n)%nat = true)","proofString":"inv H2; try discriminate; inv H4; congruence."},{"statement":"(f : meminj) (al : list memval) (b1 : memval) (bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H1 : false = true) (H2 : Val.inject f v v') (H3 : v <> Vundef) : match b1 with\n| Fragment v'0 q' m' =>\n    Val.eq v' v'0 && quantity_eq q q' && (n =? m')%nat &&\n    check_value n v' q bl\n| _ => false\nend = true.","conclusion":"match b1 with\n| Fragment v'0 q' m' =>\n    Val.eq v' v'0 && quantity_eq q q' && (n =? m')%nat &&\n    check_value n v' q bl\n| _ => false\nend = true","hypotheses":"(f : meminj) (al : list memval) (b1 : memval) (bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : forall (v0 v'0 : val) (q0 : quantity) (n0 : nat),\ncheck_value n0 v0 q0 al = true ->\nVal.inject f v0 v'0 -> v0 <> Vundef -> check_value n0 v'0 q0 bl = true) (v v' : val) (q : quantity) (n : nat) (H1 : false = true) (H2 : Val.inject f v v') (H3 : v <> Vundef)","proofString":"discriminate."},{"statement":"(f : meminj) (q : quantity) (vl1 vl2 : list memval) (H : list_forall2 (memval_inject f) vl1 vl2) : Val.inject f (proj_value q vl1) (proj_value q vl2).","conclusion":"Val.inject f (proj_value q vl1) (proj_value q vl2)","hypotheses":"(f : meminj) (q : quantity) (vl1 vl2 : list memval) (H : list_forall2 (memval_inject f) vl1 vl2)","proofString":"unfold proj_value.\ninversion H; subst.\nauto.\ninversion H0; subst; auto.\ndestruct (check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al)) eqn:B; auto.\ndestruct (Val.eq v1 Vundef).\nsubst; auto.\nerewrite check_value_inject by eauto.\nauto."},{"statement":"(f : meminj) (q : quantity) (vl1 vl2 : list memval) (H : list_forall2 (memval_inject f) vl1 vl2) : Val.inject f\n  match vl1 with\n  | Fragment v _ _ :: _ =>\n      if check_value (size_quantity_nat q) v q vl1 then v else Vundef\n  | _ => Vundef\n  end\n  match vl2 with\n  | Fragment v _ _ :: _ =>\n      if check_value (size_quantity_nat q) v q vl2 then v else Vundef\n  | _ => Vundef\n  end.","conclusion":"Val.inject f\n  match vl1 with\n  | Fragment v _ _ :: _ =>\n      if check_value (size_quantity_nat q) v q vl1 then v else Vundef\n  | _ => Vundef\n  end\n  match vl2 with\n  | Fragment v _ _ :: _ =>\n      if check_value (size_quantity_nat q) v q vl2 then v else Vundef\n  | _ => Vundef\n  end","hypotheses":"(f : meminj) (q : quantity) (vl1 vl2 : list memval) (H : list_forall2 (memval_inject f) vl1 vl2)","proofString":"inversion H; subst.\nauto.\ninversion H0; subst; auto.\ndestruct (check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al)) eqn:B; auto.\ndestruct (Val.eq v1 Vundef).\nsubst; auto.\nerewrite check_value_inject by eauto.\nauto."},{"statement":"(f : meminj) (q : quantity) (H : list_forall2 (memval_inject f) nil nil) : Val.inject f Vundef Vundef.","conclusion":"Val.inject f Vundef Vundef","hypotheses":"(f : meminj) (q : quantity) (H : list_forall2 (memval_inject f) nil nil)","proofString":"auto."},{"statement":"(f : meminj) (q : quantity) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : list_forall2 (memval_inject f) (a1 :: al) (b1 :: bl)) (H0 : memval_inject f a1 b1) (H1 : list_forall2 (memval_inject f) al bl) : Val.inject f\n  match a1 with\n  | Fragment v _ _ =>\n      if check_value (size_quantity_nat q) v q (a1 :: al) then v else Vundef\n  | _ => Vundef\n  end\n  match b1 with\n  | Fragment v _ _ =>\n      if check_value (size_quantity_nat q) v q (b1 :: bl) then v else Vundef\n  | _ => Vundef\n  end.","conclusion":"Val.inject f\n  match a1 with\n  | Fragment v _ _ =>\n      if check_value (size_quantity_nat q) v q (a1 :: al) then v else Vundef\n  | _ => Vundef\n  end\n  match b1 with\n  | Fragment v _ _ =>\n      if check_value (size_quantity_nat q) v q (b1 :: bl) then v else Vundef\n  | _ => Vundef\n  end","hypotheses":"(f : meminj) (q : quantity) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : list_forall2 (memval_inject f) (a1 :: al) (b1 :: bl)) (H0 : memval_inject f a1 b1) (H1 : list_forall2 (memval_inject f) al bl)","proofString":"inversion H0; subst; auto.\ndestruct (check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al)) eqn:B; auto.\ndestruct (Val.eq v1 Vundef).\nsubst; auto.\nerewrite check_value_inject by eauto.\nauto."},{"statement":"(f : meminj) (q : quantity) (al bl : list memval) (v1 : val) (q0 : quantity) (n : nat) (v2 : val) (H : list_forall2 (memval_inject f) (Fragment v1 q0 n :: al)\n  (Fragment v2 q0 n :: bl)) (H0 : memval_inject f (Fragment v1 q0 n) (Fragment v2 q0 n)) (H1 : list_forall2 (memval_inject f) al bl) (H2 : Val.inject f v1 v2) : Val.inject f\n  (if check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al)\n   then v1\n   else Vundef)\n  (if check_value (size_quantity_nat q) v2 q (Fragment v2 q0 n :: bl)\n   then v2\n   else Vundef).","conclusion":"Val.inject f\n  (if check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al)\n   then v1\n   else Vundef)\n  (if check_value (size_quantity_nat q) v2 q (Fragment v2 q0 n :: bl)\n   then v2\n   else Vundef)","hypotheses":"(f : meminj) (q : quantity) (al bl : list memval) (v1 : val) (q0 : quantity) (n : nat) (v2 : val) (H : list_forall2 (memval_inject f) (Fragment v1 q0 n :: al)\n  (Fragment v2 q0 n :: bl)) (H0 : memval_inject f (Fragment v1 q0 n) (Fragment v2 q0 n)) (H1 : list_forall2 (memval_inject f) al bl) (H2 : Val.inject f v1 v2)","proofString":"destruct (check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al)) eqn:B; auto.\ndestruct (Val.eq v1 Vundef).\nsubst; auto.\nerewrite check_value_inject by eauto.\nauto."},{"statement":"(f : meminj) (q : quantity) (al bl : list memval) (v1 : val) (q0 : quantity) (n : nat) (v2 : val) (H : list_forall2 (memval_inject f) (Fragment v1 q0 n :: al)\n  (Fragment v2 q0 n :: bl)) (H0 : memval_inject f (Fragment v1 q0 n) (Fragment v2 q0 n)) (H1 : list_forall2 (memval_inject f) al bl) (H2 : Val.inject f v1 v2) (B : check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al) = true) : Val.inject f v1\n  (if check_value (size_quantity_nat q) v2 q (Fragment v2 q0 n :: bl)\n   then v2\n   else Vundef).","conclusion":"Val.inject f v1\n  (if check_value (size_quantity_nat q) v2 q (Fragment v2 q0 n :: bl)\n   then v2\n   else Vundef)","hypotheses":"(f : meminj) (q : quantity) (al bl : list memval) (v1 : val) (q0 : quantity) (n : nat) (v2 : val) (H : list_forall2 (memval_inject f) (Fragment v1 q0 n :: al)\n  (Fragment v2 q0 n :: bl)) (H0 : memval_inject f (Fragment v1 q0 n) (Fragment v2 q0 n)) (H1 : list_forall2 (memval_inject f) al bl) (H2 : Val.inject f v1 v2) (B : check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al) = true)","proofString":"destruct (Val.eq v1 Vundef).\nsubst; auto.\nerewrite check_value_inject by eauto.\nauto."},{"statement":"(f : meminj) (q : quantity) (al bl : list memval) (v1 : val) (q0 : quantity) (n : nat) (v2 : val) (H : list_forall2 (memval_inject f) (Fragment v1 q0 n :: al)\n  (Fragment v2 q0 n :: bl)) (H0 : memval_inject f (Fragment v1 q0 n) (Fragment v2 q0 n)) (H1 : list_forall2 (memval_inject f) al bl) (H2 : Val.inject f v1 v2) (B : check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al) = true) (e : v1 = Vundef) : Val.inject f v1\n  (if check_value (size_quantity_nat q) v2 q (Fragment v2 q0 n :: bl)\n   then v2\n   else Vundef).","conclusion":"Val.inject f v1\n  (if check_value (size_quantity_nat q) v2 q (Fragment v2 q0 n :: bl)\n   then v2\n   else Vundef)","hypotheses":"(f : meminj) (q : quantity) (al bl : list memval) (v1 : val) (q0 : quantity) (n : nat) (v2 : val) (H : list_forall2 (memval_inject f) (Fragment v1 q0 n :: al)\n  (Fragment v2 q0 n :: bl)) (H0 : memval_inject f (Fragment v1 q0 n) (Fragment v2 q0 n)) (H1 : list_forall2 (memval_inject f) al bl) (H2 : Val.inject f v1 v2) (B : check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al) = true) (e : v1 = Vundef)","proofString":"subst; auto."},{"statement":"(f : meminj) (q : quantity) (al bl : list memval) (v1 : val) (q0 : quantity) (n : nat) (v2 : val) (H : list_forall2 (memval_inject f) (Fragment v1 q0 n :: al)\n  (Fragment v2 q0 n :: bl)) (H0 : memval_inject f (Fragment v1 q0 n) (Fragment v2 q0 n)) (H1 : list_forall2 (memval_inject f) al bl) (H2 : Val.inject f v1 v2) (B : check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al) = true) (n0 : v1 <> Vundef) : Val.inject f v1\n  (if check_value (size_quantity_nat q) v2 q (Fragment v2 q0 n :: bl)\n   then v2\n   else Vundef).","conclusion":"Val.inject f v1\n  (if check_value (size_quantity_nat q) v2 q (Fragment v2 q0 n :: bl)\n   then v2\n   else Vundef)","hypotheses":"(f : meminj) (q : quantity) (al bl : list memval) (v1 : val) (q0 : quantity) (n : nat) (v2 : val) (H : list_forall2 (memval_inject f) (Fragment v1 q0 n :: al)\n  (Fragment v2 q0 n :: bl)) (H0 : memval_inject f (Fragment v1 q0 n) (Fragment v2 q0 n)) (H1 : list_forall2 (memval_inject f) al bl) (H2 : Val.inject f v1 v2) (B : check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al) = true) (n0 : v1 <> Vundef)","proofString":"erewrite check_value_inject by eauto.\nauto."},{"statement":"(f : meminj) (q : quantity) (al bl : list memval) (v1 : val) (q0 : quantity) (n : nat) (v2 : val) (H : list_forall2 (memval_inject f) (Fragment v1 q0 n :: al)\n  (Fragment v2 q0 n :: bl)) (H0 : memval_inject f (Fragment v1 q0 n) (Fragment v2 q0 n)) (H1 : list_forall2 (memval_inject f) al bl) (H2 : Val.inject f v1 v2) (B : check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al) = true) (n0 : v1 <> Vundef) : Val.inject f v1 v2.","conclusion":"Val.inject f v1 v2","hypotheses":"(f : meminj) (q : quantity) (al bl : list memval) (v1 : val) (q0 : quantity) (n : nat) (v2 : val) (H : list_forall2 (memval_inject f) (Fragment v1 q0 n :: al)\n  (Fragment v2 q0 n :: bl)) (H0 : memval_inject f (Fragment v1 q0 n) (Fragment v2 q0 n)) (H1 : list_forall2 (memval_inject f) al bl) (H2 : Val.inject f v1 v2) (B : check_value (size_quantity_nat q) v1 q (Fragment v1 q0 n :: al) = true) (n0 : v1 <> Vundef)","proofString":"auto."},{"statement":"(f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : proj_bytes al = None -> proj_bytes bl <> None -> In Undef al) (H1 : match a1 with\n| Byte b =>\n    match proj_bytes al with\n    | Some bl0 => Some (b :: bl0)\n    | None => None\n    end\n| _ => None\nend = None) (H2 : match b1 with\n| Byte b =>\n    match proj_bytes bl with\n    | Some bl0 => Some (b :: bl0)\n    | None => None\n    end\n| _ => None\nend <> None) : a1 = Undef \\/ In Undef al.","conclusion":"a1 = Undef \\/ In Undef al","hypotheses":"(f : meminj) (a1 : memval) (al : list memval) (b1 : memval) (bl : list memval) (H : memval_inject f a1 b1) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : proj_bytes al = None -> proj_bytes bl <> None -> In Undef al) (H1 : match a1 with\n| Byte b =>\n    match proj_bytes al with\n    | Some bl0 => Some (b :: bl0)\n    | None => None\n    end\n| _ => None\nend = None) (H2 : match b1 with\n| Byte b =>\n    match proj_bytes bl with\n    | Some bl0 => Some (b :: bl0)\n    | None => None\n    end\n| _ => None\nend <> None)","proofString":"inv H; try congruence.\nright.\napply IHlist_forall2.\ndestruct (proj_bytes al); congruence.\ndestruct (proj_bytes bl); congruence.\nauto."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : proj_bytes al = None -> proj_bytes bl <> None -> In Undef al) (n : byte) (H1 : match proj_bytes al with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend = None) (H2 : match proj_bytes bl with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend <> None) : Byte n = Undef \\/ In Undef al.","conclusion":"Byte n = Undef \\/ In Undef al","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : proj_bytes al = None -> proj_bytes bl <> None -> In Undef al) (n : byte) (H1 : match proj_bytes al with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend = None) (H2 : match proj_bytes bl with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend <> None)","proofString":"right.\napply IHlist_forall2.\ndestruct (proj_bytes al); congruence.\ndestruct (proj_bytes bl); congruence."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : proj_bytes al = None -> proj_bytes bl <> None -> In Undef al) (n : byte) (H1 : match proj_bytes al with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend = None) (H2 : match proj_bytes bl with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend <> None) : In Undef al.","conclusion":"In Undef al","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : proj_bytes al = None -> proj_bytes bl <> None -> In Undef al) (n : byte) (H1 : match proj_bytes al with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend = None) (H2 : match proj_bytes bl with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend <> None)","proofString":"apply IHlist_forall2.\ndestruct (proj_bytes al); congruence.\ndestruct (proj_bytes bl); congruence."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : proj_bytes al = None -> proj_bytes bl <> None -> In Undef al) (n : byte) (H1 : match proj_bytes al with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend = None) (H2 : match proj_bytes bl with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend <> None) : proj_bytes al = None.","conclusion":"proj_bytes al = None","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : proj_bytes al = None -> proj_bytes bl <> None -> In Undef al) (n : byte) (H1 : match proj_bytes al with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend = None) (H2 : match proj_bytes bl with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend <> None)","proofString":"destruct (proj_bytes al); congruence."},{"statement":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : proj_bytes al = None -> proj_bytes bl <> None -> In Undef al) (n : byte) (H1 : match proj_bytes al with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend = None) (H2 : match proj_bytes bl with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend <> None) : proj_bytes bl <> None.","conclusion":"proj_bytes bl <> None","hypotheses":"(f : meminj) (al bl : list memval) (H0 : list_forall2 (memval_inject f) al bl) (IHlist_forall2 : proj_bytes al = None -> proj_bytes bl <> None -> In Undef al) (n : byte) (H1 : match proj_bytes al with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend = None) (H2 : match proj_bytes bl with\n| Some bl0 => Some (n :: bl0)\n| None => None\nend <> None)","proofString":"destruct (proj_bytes bl); congruence."},{"statement":"(q : quantity) (v : val) (vl : list memval) (H : In Undef vl) : match vl with\n| nil => true\n| _ :: _ => false\nend = false.","conclusion":"match vl with\n| nil => true\n| _ :: _ => false\nend = false","hypotheses":"(q : quantity) (v : val) (vl : list memval) (H : In Undef vl)","proofString":"destruct vl.\nelim H.\nauto."},{"statement":"(q : quantity) (v : val) (H : In Undef nil) : true = false.","conclusion":"true = false","hypotheses":"(q : quantity) (v : val) (H : In Undef nil)","proofString":"elim H."},{"statement":"(q : quantity) (v : val) (m : memval) (vl : list memval) (H : In Undef (m :: vl)) : false = false.","conclusion":"false = false","hypotheses":"(q : quantity) (v : val) (m : memval) (vl : list memval) (H : In Undef (m :: vl))","proofString":"auto."},{"statement":"(n : nat) (IHn : forall (q0 : quantity) (v0 : val) (vl0 : list memval),\nIn Undef vl0 -> check_value n v0 q0 vl0 = false) (q : quantity) (v : val) (vl : list memval) (H : In Undef vl) : match vl with\n| Fragment v' q' m' :: vl' =>\n    Val.eq v v' && quantity_eq q q' && (n =? m')%nat && check_value n v q vl'\n| _ => false\nend = false.","conclusion":"match vl with\n| Fragment v' q' m' :: vl' =>\n    Val.eq v v' && quantity_eq q q' && (n =? m')%nat && check_value n v q vl'\n| _ => false\nend = false","hypotheses":"(n : nat) (IHn : forall (q0 : quantity) (v0 : val) (vl0 : list memval),\nIn Undef vl0 -> check_value n v0 q0 vl0 = false) (q : quantity) (v : val) (vl : list memval) (H : In Undef vl)","proofString":"destruct vl.\nauto.\ndestruct m; auto.\nsimpl in H; destruct H.\ncongruence.\nrewrite IHn; auto.\napply andb_false_r."},{"statement":"(n : nat) (IHn : forall (q0 : quantity) (v0 : val) (vl : list memval),\nIn Undef vl -> check_value n v0 q0 vl = false) (q : quantity) (v : val) (H : In Undef nil) : false = false.","conclusion":"false = false","hypotheses":"(n : nat) (IHn : forall (q0 : quantity) (v0 : val) (vl : list memval),\nIn Undef vl -> check_value n v0 q0 vl = false) (q : quantity) (v : val) (H : In Undef nil)","proofString":"auto."},{"statement":"(n : nat) (IHn : forall (q0 : quantity) (v0 : val) (vl0 : list memval),\nIn Undef vl0 -> check_value n v0 q0 vl0 = false) (q : quantity) (v : val) (m : memval) (vl : list memval) (H : In Undef (m :: vl)) : match m with\n| Fragment v' q' m' =>\n    Val.eq v v' && quantity_eq q q' && (n =? m')%nat && check_value n v q vl\n| _ => false\nend = false.","conclusion":"match m with\n| Fragment v' q' m' =>\n    Val.eq v v' && quantity_eq q q' && (n =? m')%nat && check_value n v q vl\n| _ => false\nend = false","hypotheses":"(n : nat) (IHn : forall (q0 : quantity) (v0 : val) (vl0 : list memval),\nIn Undef vl0 -> check_value n v0 q0 vl0 = false) (q : quantity) (v : val) (m : memval) (vl : list memval) (H : In Undef (m :: vl))","proofString":"destruct m; auto.\nsimpl in H; destruct H.\ncongruence.\nrewrite IHn; auto.\napply andb_false_r."},{"statement":"(n : nat) (IHn : forall (q1 : quantity) (v1 : val) (vl0 : list memval),\nIn Undef vl0 -> check_value n v1 q1 vl0 = false) (q : quantity) (v v0 : val) (q0 : quantity) (n0 : nat) (vl : list memval) (H : In Undef (Fragment v0 q0 n0 :: vl)) : Val.eq v v0 && quantity_eq q q0 && (n =? n0)%nat && check_value n v q vl =\nfalse.","conclusion":"Val.eq v v0 && quantity_eq q q0 && (n =? n0)%nat && check_value n v q vl =\nfalse","hypotheses":"(n : nat) (IHn : forall (q1 : quantity) (v1 : val) (vl0 : list memval),\nIn Undef vl0 -> check_value n v1 q1 vl0 = false) (q : quantity) (v v0 : val) (q0 : quantity) (n0 : nat) (vl : list memval) (H : In Undef (Fragment v0 q0 n0 :: vl))","proofString":"simpl in H; destruct H.\ncongruence.\nrewrite IHn; auto.\napply andb_false_r."},{"statement":"(n : nat) (IHn : forall (q1 : quantity) (v1 : val) (vl0 : list memval),\nIn Undef vl0 -> check_value n v1 q1 vl0 = false) (q : quantity) (v v0 : val) (q0 : quantity) (n0 : nat) (vl : list memval) (H : Fragment v0 q0 n0 = Undef) : Val.eq v v0 && quantity_eq q q0 && (n =? n0)%nat && check_value n v q vl =\nfalse.","conclusion":"Val.eq v v0 && quantity_eq q q0 && (n =? n0)%nat && check_value n v q vl =\nfalse","hypotheses":"(n : nat) (IHn : forall (q1 : quantity) (v1 : val) (vl0 : list memval),\nIn Undef vl0 -> check_value n v1 q1 vl0 = false) (q : quantity) (v v0 : val) (q0 : quantity) (n0 : nat) (vl : list memval) (H : Fragment v0 q0 n0 = Undef)","proofString":"congruence."},{"statement":"(n : nat) (IHn : forall (q1 : quantity) (v1 : val) (vl0 : list memval),\nIn Undef vl0 -> check_value n v1 q1 vl0 = false) (q : quantity) (v v0 : val) (q0 : quantity) (n0 : nat) (vl : list memval) (H : In Undef vl) : Val.eq v v0 && quantity_eq q q0 && (n =? n0)%nat && check_value n v q vl =\nfalse.","conclusion":"Val.eq v v0 && quantity_eq q q0 && (n =? n0)%nat && check_value n v q vl =\nfalse","hypotheses":"(n : nat) (IHn : forall (q1 : quantity) (v1 : val) (vl0 : list memval),\nIn Undef vl0 -> check_value n v1 q1 vl0 = false) (q : quantity) (v v0 : val) (q0 : quantity) (n0 : nat) (vl : list memval) (H : In Undef vl)","proofString":"rewrite IHn; auto.\napply andb_false_r."},{"statement":"(n : nat) (IHn : forall (q1 : quantity) (v1 : val) (vl0 : list memval),\nIn Undef vl0 -> check_value n v1 q1 vl0 = false) (q : quantity) (v v0 : val) (q0 : quantity) (n0 : nat) (vl : list memval) (H : In Undef vl) : Val.eq v v0 && quantity_eq q q0 && (n =? n0)%nat && false = false.","conclusion":"Val.eq v v0 && quantity_eq q q0 && (n =? n0)%nat && false = false","hypotheses":"(n : nat) (IHn : forall (q1 : quantity) (v1 : val) (vl0 : list memval),\nIn Undef vl0 -> check_value n v1 q1 vl0 = false) (q : quantity) (v v0 : val) (q0 : quantity) (n0 : nat) (vl : list memval) (H : In Undef vl)","proofString":"apply andb_false_r."},{"statement":"(q : quantity) (vl : list memval) (H : In Undef vl) : match vl with\n| Fragment v _ _ :: _ =>\n    if check_value (size_quantity_nat q) v q vl then v else Vundef\n| _ => Vundef\nend = Vundef.","conclusion":"match vl with\n| Fragment v _ _ :: _ =>\n    if check_value (size_quantity_nat q) v q vl then v else Vundef\n| _ => Vundef\nend = Vundef","hypotheses":"(q : quantity) (vl : list memval) (H : In Undef vl)","proofString":"destruct vl; auto.\ndestruct m; auto.\nrewrite check_value_undef.\nauto.\nauto."},{"statement":"(q : quantity) (m : memval) (vl : list memval) (H : In Undef (m :: vl)) : match m with\n| Fragment v _ _ =>\n    if check_value (size_quantity_nat q) v q (m :: vl) then v else Vundef\n| _ => Vundef\nend = Vundef.","conclusion":"match m with\n| Fragment v _ _ =>\n    if check_value (size_quantity_nat q) v q (m :: vl) then v else Vundef\n| _ => Vundef\nend = Vundef","hypotheses":"(q : quantity) (m : memval) (vl : list memval) (H : In Undef (m :: vl))","proofString":"destruct m; auto.\nrewrite check_value_undef.\nauto.\nauto."},{"statement":"(q : quantity) (v : val) (q0 : quantity) (n : nat) (vl : list memval) (H : In Undef (Fragment v q0 n :: vl)) : (if check_value (size_quantity_nat q) v q (Fragment v q0 n :: vl)\n then v\n else Vundef) = Vundef.","conclusion":"(if check_value (size_quantity_nat q) v q (Fragment v q0 n :: vl)\n then v\n else Vundef) = Vundef","hypotheses":"(q : quantity) (v : val) (q0 : quantity) (n : nat) (vl : list memval) (H : In Undef (Fragment v q0 n :: vl))","proofString":"rewrite check_value_undef.\nauto.\nauto."},{"statement":"(q : quantity) (v : val) (q0 : quantity) (n : nat) (vl : list memval) (H : In Undef (Fragment v q0 n :: vl)) : Vundef = Vundef.","conclusion":"Vundef = Vundef","hypotheses":"(q : quantity) (v : val) (q0 : quantity) (n : nat) (vl : list memval) (H : In Undef (Fragment v q0 n :: vl))","proofString":"auto."},{"statement":"(q : quantity) (v : val) (q0 : quantity) (n : nat) (vl : list memval) (H : In Undef (Fragment v q0 n :: vl)) : In Undef (Fragment v q0 n :: vl).","conclusion":"In Undef (Fragment v q0 n :: vl)","hypotheses":"(q : quantity) (v : val) (q0 : quantity) (n : nat) (vl : list memval) (H : In Undef (Fragment v q0 n :: vl))","proofString":"auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) : Val.inject f (decode_val chunk vl1) (decode_val chunk vl2).","conclusion":"Val.inject f (decode_val chunk vl1) (decode_val chunk vl2)","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2)","proofString":"unfold decode_val.\ndestruct (proj_bytes vl1) as [bl1|] eqn:PB1.\nexploit proj_bytes_inject; eauto.\nintros PB2.\nrewrite PB2.\ndestruct chunk; auto.\nunfold Val.norm_bool; destruct Val.is_bool; auto.\nassert (A: forall q fn,     Val.inject f (Val.load_result chunk (proj_value q vl1))                  (match proj_bytes vl2 with                   | Some bl => fn bl                   | None => Val.load_result chunk (proj_value q vl2)                   end)).\nintros.\ndestruct (proj_bytes vl2) as [bl2|] eqn:PB2.\nrewrite proj_value_undef.\ndestruct chunk; auto.\neapply proj_bytes_not_inject; eauto.\ncongruence.\napply Val.load_result_inject.\napply proj_value_inject; auto.\ndestruct chunk; destruct Archi.ptr64; auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) : Val.inject f\n  match proj_bytes vl1 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl1)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl1)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl1)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl1)\n      | _ => Vundef\n      end\n  end\n  match proj_bytes vl2 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl2)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl2)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl2)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl2)\n      | _ => Vundef\n      end\n  end.","conclusion":"Val.inject f\n  match proj_bytes vl1 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl1)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl1)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl1)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl1)\n      | _ => Vundef\n      end\n  end\n  match proj_bytes vl2 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl2)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl2)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl2)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl2)\n      | _ => Vundef\n      end\n  end","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2)","proofString":"destruct (proj_bytes vl1) as [bl1|] eqn:PB1.\nexploit proj_bytes_inject; eauto.\nintros PB2.\nrewrite PB2.\ndestruct chunk; auto.\nunfold Val.norm_bool; destruct Val.is_bool; auto.\nassert (A: forall q fn,     Val.inject f (Val.load_result chunk (proj_value q vl1))                  (match proj_bytes vl2 with                   | Some bl => fn bl                   | None => Val.load_result chunk (proj_value q vl2)                   end)).\nintros.\ndestruct (proj_bytes vl2) as [bl2|] eqn:PB2.\nrewrite proj_value_undef.\ndestruct chunk; auto.\neapply proj_bytes_not_inject; eauto.\ncongruence.\napply Val.load_result_inject.\napply proj_value_inject; auto.\ndestruct chunk; destruct Archi.ptr64; auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (bl1 : list byte) (PB1 : proj_bytes vl1 = Some bl1) : Val.inject f\n  match chunk with\n  | Mbool =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl1)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl1)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl1)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl1)))\n  | Mint32 => Vint (Int.repr (decode_int bl1))\n  | Mint64 => Vlong (Int64.repr (decode_int bl1))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl1)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl1)))\n  | _ => Vundef\n  end\n  match proj_bytes vl2 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl2)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl2)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl2)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl2)\n      | _ => Vundef\n      end\n  end.","conclusion":"Val.inject f\n  match chunk with\n  | Mbool =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl1)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl1)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl1)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl1)))\n  | Mint32 => Vint (Int.repr (decode_int bl1))\n  | Mint64 => Vlong (Int64.repr (decode_int bl1))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl1)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl1)))\n  | _ => Vundef\n  end\n  match proj_bytes vl2 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl2)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl2)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl2)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl2)\n      | _ => Vundef\n      end\n  end","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (bl1 : list byte) (PB1 : proj_bytes vl1 = Some bl1)","proofString":"exploit proj_bytes_inject; eauto.\nintros PB2.\nrewrite PB2.\ndestruct chunk; auto.\nunfold Val.norm_bool; destruct Val.is_bool; auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (bl1 : list byte) (PB1 : proj_bytes vl1 = Some bl1) : proj_bytes vl2 = Some bl1 ->\nVal.inject f\n  match chunk with\n  | Mbool =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl1)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl1)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl1)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl1)))\n  | Mint32 => Vint (Int.repr (decode_int bl1))\n  | Mint64 => Vlong (Int64.repr (decode_int bl1))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl1)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl1)))\n  | _ => Vundef\n  end\n  match proj_bytes vl2 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl2)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl2)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl2)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl2)\n      | _ => Vundef\n      end\n  end.","conclusion":"proj_bytes vl2 = Some bl1 ->\nVal.inject f\n  match chunk with\n  | Mbool =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl1)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl1)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl1)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl1)))\n  | Mint32 => Vint (Int.repr (decode_int bl1))\n  | Mint64 => Vlong (Int64.repr (decode_int bl1))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl1)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl1)))\n  | _ => Vundef\n  end\n  match proj_bytes vl2 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl2)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl2)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl2)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl2)\n      | _ => Vundef\n      end\n  end","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (bl1 : list byte) (PB1 : proj_bytes vl1 = Some bl1)","proofString":"intros PB2.\nrewrite PB2.\ndestruct chunk; auto.\nunfold Val.norm_bool; destruct Val.is_bool; auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (bl1 : list byte) (PB1 : proj_bytes vl1 = Some bl1) (PB2 : proj_bytes vl2 = Some bl1) : Val.inject f\n  match chunk with\n  | Mbool =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl1)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl1)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl1)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl1)))\n  | Mint32 => Vint (Int.repr (decode_int bl1))\n  | Mint64 => Vlong (Int64.repr (decode_int bl1))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl1)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl1)))\n  | _ => Vundef\n  end\n  match proj_bytes vl2 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl2)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl2)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl2)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl2)\n      | _ => Vundef\n      end\n  end.","conclusion":"Val.inject f\n  match chunk with\n  | Mbool =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl1)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl1)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl1)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl1)))\n  | Mint32 => Vint (Int.repr (decode_int bl1))\n  | Mint64 => Vlong (Int64.repr (decode_int bl1))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl1)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl1)))\n  | _ => Vundef\n  end\n  match proj_bytes vl2 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl2)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl2)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl2)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl2)\n      | _ => Vundef\n      end\n  end","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (bl1 : list byte) (PB1 : proj_bytes vl1 = Some bl1) (PB2 : proj_bytes vl2 = Some bl1)","proofString":"rewrite PB2.\ndestruct chunk; auto.\nunfold Val.norm_bool; destruct Val.is_bool; auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (bl1 : list byte) (PB1 : proj_bytes vl1 = Some bl1) (PB2 : proj_bytes vl2 = Some bl1) : Val.inject f\n  match chunk with\n  | Mbool =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl1)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl1)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl1)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl1)))\n  | Mint32 => Vint (Int.repr (decode_int bl1))\n  | Mint64 => Vlong (Int64.repr (decode_int bl1))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl1)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl1)))\n  | _ => Vundef\n  end\n  match chunk with\n  | Mbool =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl1)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl1)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl1)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl1)))\n  | Mint32 => Vint (Int.repr (decode_int bl1))\n  | Mint64 => Vlong (Int64.repr (decode_int bl1))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl1)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl1)))\n  | _ => Vundef\n  end.","conclusion":"Val.inject f\n  match chunk with\n  | Mbool =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl1)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl1)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl1)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl1)))\n  | Mint32 => Vint (Int.repr (decode_int bl1))\n  | Mint64 => Vlong (Int64.repr (decode_int bl1))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl1)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl1)))\n  | _ => Vundef\n  end\n  match chunk with\n  | Mbool =>\n      Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1))))\n  | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl1)))\n  | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl1)))\n  | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl1)))\n  | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl1)))\n  | Mint32 => Vint (Int.repr (decode_int bl1))\n  | Mint64 => Vlong (Int64.repr (decode_int bl1))\n  | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl1)))\n  | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl1)))\n  | _ => Vundef\n  end","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (bl1 : list byte) (PB1 : proj_bytes vl1 = Some bl1) (PB2 : proj_bytes vl2 = Some bl1)","proofString":"destruct chunk; auto.\nunfold Val.norm_bool; destruct Val.is_bool; auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (H : list_forall2 (memval_inject f) vl1 vl2) (bl1 : list byte) (PB1 : proj_bytes vl1 = Some bl1) (PB2 : proj_bytes vl2 = Some bl1) : Val.inject f\n  (Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1)))))\n  (Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1))))).","conclusion":"Val.inject f\n  (Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1)))))\n  (Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl1)))))","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (H : list_forall2 (memval_inject f) vl1 vl2) (bl1 : list byte) (PB1 : proj_bytes vl1 = Some bl1) (PB2 : proj_bytes vl2 = Some bl1)","proofString":"unfold Val.norm_bool; destruct Val.is_bool; auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) : Val.inject f\n  match chunk with\n  | Mint32 =>\n      if Archi.ptr64\n      then Vundef\n      else Val.load_result chunk (proj_value Q32 vl1)\n  | Mint64 =>\n      if Archi.ptr64\n      then Val.load_result chunk (proj_value Q64 vl1)\n      else Vundef\n  | Many32 => Val.load_result chunk (proj_value Q32 vl1)\n  | Many64 => Val.load_result chunk (proj_value Q64 vl1)\n  | _ => Vundef\n  end\n  match proj_bytes vl2 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl2)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl2)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl2)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl2)\n      | _ => Vundef\n      end\n  end.","conclusion":"Val.inject f\n  match chunk with\n  | Mint32 =>\n      if Archi.ptr64\n      then Vundef\n      else Val.load_result chunk (proj_value Q32 vl1)\n  | Mint64 =>\n      if Archi.ptr64\n      then Val.load_result chunk (proj_value Q64 vl1)\n      else Vundef\n  | Many32 => Val.load_result chunk (proj_value Q32 vl1)\n  | Many64 => Val.load_result chunk (proj_value Q64 vl1)\n  | _ => Vundef\n  end\n  match proj_bytes vl2 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl2)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl2)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl2)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl2)\n      | _ => Vundef\n      end\n  end","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None)","proofString":"assert (A: forall q fn,     Val.inject f (Val.load_result chunk (proj_value q vl1))                  (match proj_bytes vl2 with                   | Some bl => fn bl                   | None => Val.load_result chunk (proj_value q vl2)                   end)).\nintros.\ndestruct (proj_bytes vl2) as [bl2|] eqn:PB2.\nrewrite proj_value_undef.\ndestruct chunk; auto.\neapply proj_bytes_not_inject; eauto.\ncongruence.\napply Val.load_result_inject.\napply proj_value_inject; auto.\ndestruct chunk; destruct Archi.ptr64; auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) : forall (q : quantity) (fn : list byte -> val),\nVal.inject f (Val.load_result chunk (proj_value q vl1))\n  match proj_bytes vl2 with\n  | Some bl => fn bl\n  | None => Val.load_result chunk (proj_value q vl2)\n  end.","conclusion":"forall (q : quantity) (fn : list byte -> val),\nVal.inject f (Val.load_result chunk (proj_value q vl1))\n  match proj_bytes vl2 with\n  | Some bl => fn bl\n  | None => Val.load_result chunk (proj_value q vl2)\n  end","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None)","proofString":"intros.\ndestruct (proj_bytes vl2) as [bl2|] eqn:PB2.\nrewrite proj_value_undef.\ndestruct chunk; auto.\neapply proj_bytes_not_inject; eauto.\ncongruence.\napply Val.load_result_inject.\napply proj_value_inject; auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val) : Val.inject f (Val.load_result chunk (proj_value q vl1))\n  match proj_bytes vl2 with\n  | Some bl => fn bl\n  | None => Val.load_result chunk (proj_value q vl2)\n  end.","conclusion":"Val.inject f (Val.load_result chunk (proj_value q vl1))\n  match proj_bytes vl2 with\n  | Some bl => fn bl\n  | None => Val.load_result chunk (proj_value q vl2)\n  end","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val)","proofString":"destruct (proj_bytes vl2) as [bl2|] eqn:PB2.\nrewrite proj_value_undef.\ndestruct chunk; auto.\neapply proj_bytes_not_inject; eauto.\ncongruence.\napply Val.load_result_inject.\napply proj_value_inject; auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val) (bl2 : list byte) (PB2 : proj_bytes vl2 = Some bl2) : Val.inject f (Val.load_result chunk (proj_value q vl1)) (fn bl2).","conclusion":"Val.inject f (Val.load_result chunk (proj_value q vl1)) (fn bl2)","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val) (bl2 : list byte) (PB2 : proj_bytes vl2 = Some bl2)","proofString":"rewrite proj_value_undef.\ndestruct chunk; auto.\neapply proj_bytes_not_inject; eauto.\ncongruence."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val) (bl2 : list byte) (PB2 : proj_bytes vl2 = Some bl2) : Val.inject f (Val.load_result chunk Vundef) (fn bl2).","conclusion":"Val.inject f (Val.load_result chunk Vundef) (fn bl2)","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val) (bl2 : list byte) (PB2 : proj_bytes vl2 = Some bl2)","proofString":"destruct chunk; auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val) (bl2 : list byte) (PB2 : proj_bytes vl2 = Some bl2) : In Undef vl1.","conclusion":"In Undef vl1","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val) (bl2 : list byte) (PB2 : proj_bytes vl2 = Some bl2)","proofString":"eapply proj_bytes_not_inject; eauto.\ncongruence."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val) (bl2 : list byte) (PB2 : proj_bytes vl2 = Some bl2) : proj_bytes vl2 <> None.","conclusion":"proj_bytes vl2 <> None","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val) (bl2 : list byte) (PB2 : proj_bytes vl2 = Some bl2)","proofString":"congruence."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val) (PB2 : proj_bytes vl2 = None) : Val.inject f (Val.load_result chunk (proj_value q vl1))\n  (Val.load_result chunk (proj_value q vl2)).","conclusion":"Val.inject f (Val.load_result chunk (proj_value q vl1))\n  (Val.load_result chunk (proj_value q vl2))","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val) (PB2 : proj_bytes vl2 = None)","proofString":"apply Val.load_result_inject.\napply proj_value_inject; auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val) (PB2 : proj_bytes vl2 = None) : Val.inject f (proj_value q vl1) (proj_value q vl2).","conclusion":"Val.inject f (proj_value q vl1) (proj_value q vl2)","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (q : quantity) (fn : list byte -> val) (PB2 : proj_bytes vl2 = None)","proofString":"apply proj_value_inject; auto."},{"statement":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (A : forall (q : quantity) (fn : list byte -> val),\nVal.inject f (Val.load_result chunk (proj_value q vl1))\n  match proj_bytes vl2 with\n  | Some bl => fn bl\n  | None => Val.load_result chunk (proj_value q vl2)\n  end) : Val.inject f\n  match chunk with\n  | Mint32 =>\n      if Archi.ptr64\n      then Vundef\n      else Val.load_result chunk (proj_value Q32 vl1)\n  | Mint64 =>\n      if Archi.ptr64\n      then Val.load_result chunk (proj_value Q64 vl1)\n      else Vundef\n  | Many32 => Val.load_result chunk (proj_value Q32 vl1)\n  | Many64 => Val.load_result chunk (proj_value Q64 vl1)\n  | _ => Vundef\n  end\n  match proj_bytes vl2 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl2)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl2)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl2)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl2)\n      | _ => Vundef\n      end\n  end.","conclusion":"Val.inject f\n  match chunk with\n  | Mint32 =>\n      if Archi.ptr64\n      then Vundef\n      else Val.load_result chunk (proj_value Q32 vl1)\n  | Mint64 =>\n      if Archi.ptr64\n      then Val.load_result chunk (proj_value Q64 vl1)\n      else Vundef\n  | Many32 => Val.load_result chunk (proj_value Q32 vl1)\n  | Many64 => Val.load_result chunk (proj_value Q64 vl1)\n  | _ => Vundef\n  end\n  match proj_bytes vl2 with\n  | Some bl =>\n      match chunk with\n      | Mbool =>\n          Val.norm_bool (Vint (Int.zero_ext 8 (Int.repr (decode_int bl))))\n      | Mint8signed => Vint (Int.sign_ext 8 (Int.repr (decode_int bl)))\n      | Mint8unsigned => Vint (Int.zero_ext 8 (Int.repr (decode_int bl)))\n      | Mint16signed => Vint (Int.sign_ext 16 (Int.repr (decode_int bl)))\n      | Mint16unsigned => Vint (Int.zero_ext 16 (Int.repr (decode_int bl)))\n      | Mint32 => Vint (Int.repr (decode_int bl))\n      | Mint64 => Vlong (Int64.repr (decode_int bl))\n      | Mfloat32 => Vsingle (Float32.of_bits (Int.repr (decode_int bl)))\n      | Mfloat64 => Vfloat (Float.of_bits (Int64.repr (decode_int bl)))\n      | _ => Vundef\n      end\n  | None =>\n      match chunk with\n      | Mint32 =>\n          if Archi.ptr64\n          then Vundef\n          else Val.load_result chunk (proj_value Q32 vl2)\n      | Mint64 =>\n          if Archi.ptr64\n          then Val.load_result chunk (proj_value Q64 vl2)\n          else Vundef\n      | Many32 => Val.load_result chunk (proj_value Q32 vl2)\n      | Many64 => Val.load_result chunk (proj_value Q64 vl2)\n      | _ => Vundef\n      end\n  end","hypotheses":"(f : meminj) (vl1 vl2 : list memval) (chunk : memory_chunk) (H : list_forall2 (memval_inject f) vl1 vl2) (PB1 : proj_bytes vl1 = None) (A : forall (q : quantity) (fn : list byte -> val),\nVal.inject f (Val.load_result chunk (proj_value q vl1))\n  match proj_bytes vl2 with\n  | Some bl => fn bl\n  | None => Val.load_result chunk (proj_value q vl2)\n  end)","proofString":"destruct chunk; destruct Archi.ptr64; auto."},{"statement":"(f : meminj) (a : byte) (bl : list byte) (IHbl : list_forall2 (memval_inject f) (inj_bytes bl) (inj_bytes bl)) : memval_inject f (Byte a) (Byte a).","conclusion":"memval_inject f (Byte a) (Byte a)","hypotheses":"(f : meminj) (a : byte) (bl : list byte) (IHbl : list_forall2 (memval_inject f) (inj_bytes bl) (inj_bytes bl))","proofString":"constructor."},{"statement":"(f : meminj) (a : memval) (vl : list memval) (IHvl : list_forall2 (memval_inject f) (repeat Undef (Datatypes.length vl)) vl) : memval_inject f Undef a.","conclusion":"memval_inject f Undef a","hypotheses":"(f : meminj) (a : memval) (vl : list memval) (IHvl : list_forall2 (memval_inject f) (repeat Undef (Datatypes.length vl)) vl)","proofString":"constructor."},{"statement":"(f : meminj) (chunk : memory_chunk) (v : val) : list_forall2 (memval_inject f) (repeat Undef (size_chunk_nat chunk))\n  (encode_val chunk v).","conclusion":"list_forall2 (memval_inject f) (repeat Undef (size_chunk_nat chunk))\n  (encode_val chunk v)","hypotheses":"(f : meminj) (chunk : memory_chunk) (v : val)","proofString":"rewrite <- (encode_val_length chunk v).\napply repeat_Undef_inject_any."},{"statement":"(f : meminj) (chunk : memory_chunk) (v : val) : list_forall2 (memval_inject f)\n  (repeat Undef (Datatypes.length (encode_val chunk v))) \n  (encode_val chunk v).","conclusion":"list_forall2 (memval_inject f)\n  (repeat Undef (Datatypes.length (encode_val chunk v))) \n  (encode_val chunk v)","hypotheses":"(f : meminj) (chunk : memory_chunk) (v : val)","proofString":"apply repeat_Undef_inject_any."},{"statement":"(f : meminj) (n : nat) (IHn : list_forall2 (memval_inject f) (repeat Undef n) (repeat Undef n)) : memval_inject f Undef Undef.","conclusion":"memval_inject f Undef Undef","hypotheses":"(f : meminj) (n : nat) (IHn : list_forall2 (memval_inject f) (repeat Undef n) (repeat Undef n))","proofString":"constructor."},{"statement":"forall mv : memval, memval_inject inject_id mv mv.","conclusion":"forall mv : memval, memval_inject inject_id mv mv","hypotheses":"","proofString":"destruct mv; econstructor.\napply val_inject_id.\nauto."},{"statement":"(v : val) (q : quantity) (n : nat) : Val.inject inject_id v v.","conclusion":"Val.inject inject_id v v","hypotheses":"(v : val) (q : quantity) (n : nat)","proofString":"apply val_inject_id.\nauto."},{"statement":"(v : val) (q : quantity) (n : nat) : Val.lessdef v v.","conclusion":"Val.lessdef v v","hypotheses":"(v : val) (q : quantity) (n : nat)","proofString":"auto."},{"statement":"(f f' : meminj) (v1 v2 v3 : memval) (H : memval_inject f v1 v2) (H0 : memval_inject f' v2 v3) : memval_inject (compose_meminj f f') v1 v3.","conclusion":"memval_inject (compose_meminj f f') v1 v3","hypotheses":"(f f' : meminj) (v1 v2 v3 : memval) (H : memval_inject f v1 v2) (H0 : memval_inject f' v2 v3)","proofString":"inv H.\ninv H0.\nconstructor.\ninv H0.\neconstructor.\neapply val_inject_compose; eauto.\nconstructor."},{"statement":"(f f' : meminj) (v3 : memval) (n : byte) (H0 : memval_inject f' (Byte n) v3) : memval_inject (compose_meminj f f') (Byte n) v3.","conclusion":"memval_inject (compose_meminj f f') (Byte n) v3","hypotheses":"(f f' : meminj) (v3 : memval) (n : byte) (H0 : memval_inject f' (Byte n) v3)","proofString":"inv H0.\nconstructor."},{"statement":"(f f' : meminj) (n : byte) : memval_inject (compose_meminj f f') (Byte n) (Byte n).","conclusion":"memval_inject (compose_meminj f f') (Byte n) (Byte n)","hypotheses":"(f f' : meminj) (n : byte)","proofString":"constructor."},{"statement":"(f f' : meminj) (v3 : memval) (v4 : val) (q : quantity) (n : nat) (H0 : memval_inject f' (Fragment v4 q n) v3) (v0 : val) (H1 : Val.inject f v0 v4) : memval_inject (compose_meminj f f') (Fragment v0 q n) v3.","conclusion":"memval_inject (compose_meminj f f') (Fragment v0 q n) v3","hypotheses":"(f f' : meminj) (v3 : memval) (v4 : val) (q : quantity) (n : nat) (H0 : memval_inject f' (Fragment v4 q n) v3) (v0 : val) (H1 : Val.inject f v0 v4)","proofString":"inv H0.\neconstructor.\neapply val_inject_compose; eauto."},{"statement":"(f f' : meminj) (v4 : val) (q : quantity) (n : nat) (v0 : val) (H1 : Val.inject f v0 v4) (v2 : val) (H5 : Val.inject f' v4 v2) : memval_inject (compose_meminj f f') (Fragment v0 q n) (Fragment v2 q n).","conclusion":"memval_inject (compose_meminj f f') (Fragment v0 q n) (Fragment v2 q n)","hypotheses":"(f f' : meminj) (v4 : val) (q : quantity) (n : nat) (v0 : val) (H1 : Val.inject f v0 v4) (v2 : val) (H5 : Val.inject f' v4 v2)","proofString":"econstructor.\neapply val_inject_compose; eauto."},{"statement":"(f f' : meminj) (v4 : val) (q : quantity) (n : nat) (v0 : val) (H1 : Val.inject f v0 v4) (v2 : val) (H5 : Val.inject f' v4 v2) : Val.inject (compose_meminj f f') v0 v2.","conclusion":"Val.inject (compose_meminj f f') v0 v2","hypotheses":"(f f' : meminj) (v4 : val) (q : quantity) (n : nat) (v0 : val) (H1 : Val.inject f v0 v4) (v2 : val) (H5 : Val.inject f' v4 v2)","proofString":"eapply val_inject_compose; eauto."},{"statement":"(f f' : meminj) (v2 v3 : memval) (H0 : memval_inject f' v2 v3) : memval_inject (compose_meminj f f') Undef v3.","conclusion":"memval_inject (compose_meminj f f') Undef v3","hypotheses":"(f f' : meminj) (v2 v3 : memval) (H0 : memval_inject f' v2 v3)","proofString":"constructor."},{"statement":"(l2 : list byte) : int_of_bytes l2 = int_of_bytes l2 * 1.","conclusion":"int_of_bytes l2 = int_of_bytes l2 * 1","hypotheses":"(l2 : list byte)","proofString":"ring."},{"statement":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8)) : Byte.unsigned a + int_of_bytes (l1 ++ l2) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length (a :: l1)) * 8).","conclusion":"Byte.unsigned a + int_of_bytes (l1 ++ l2) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length (a :: l1)) * 8)","hypotheses":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8))","proofString":"simpl length.\nrewrite Nat2Z.inj_succ.\nreplace (Z.succ (Z.of_nat (length l1)) * 8) with (Z.of_nat (length l1) * 8 + 8) by lia.\nrewrite two_p_is_exp.\nchange (two_p 8) with 256.\nrewrite IHl1.\nring.\nlia.\nlia."},{"statement":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8)) : Byte.unsigned a + int_of_bytes (l1 ++ l2) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * two_p (Z.of_nat (S (Datatypes.length l1)) * 8).","conclusion":"Byte.unsigned a + int_of_bytes (l1 ++ l2) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * two_p (Z.of_nat (S (Datatypes.length l1)) * 8)","hypotheses":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8))","proofString":"rewrite Nat2Z.inj_succ.\nreplace (Z.succ (Z.of_nat (length l1)) * 8) with (Z.of_nat (length l1) * 8 + 8) by lia.\nrewrite two_p_is_exp.\nchange (two_p 8) with 256.\nrewrite IHl1.\nring.\nlia.\nlia."},{"statement":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8)) : Byte.unsigned a + int_of_bytes (l1 ++ l2) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * two_p (Z.succ (Z.of_nat (Datatypes.length l1)) * 8).","conclusion":"Byte.unsigned a + int_of_bytes (l1 ++ l2) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * two_p (Z.succ (Z.of_nat (Datatypes.length l1)) * 8)","hypotheses":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8))","proofString":"replace (Z.succ (Z.of_nat (length l1)) * 8) with (Z.of_nat (length l1) * 8 + 8) by lia.\nrewrite two_p_is_exp.\nchange (two_p 8) with 256.\nrewrite IHl1.\nring.\nlia.\nlia."},{"statement":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8)) : Byte.unsigned a + int_of_bytes (l1 ++ l2) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8 + 8).","conclusion":"Byte.unsigned a + int_of_bytes (l1 ++ l2) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8 + 8)","hypotheses":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8))","proofString":"rewrite two_p_is_exp.\nchange (two_p 8) with 256.\nrewrite IHl1.\nring.\nlia.\nlia."},{"statement":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8)) : Byte.unsigned a + int_of_bytes (l1 ++ l2) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * (two_p (Z.of_nat (Datatypes.length l1) * 8) * two_p 8).","conclusion":"Byte.unsigned a + int_of_bytes (l1 ++ l2) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * (two_p (Z.of_nat (Datatypes.length l1) * 8) * two_p 8)","hypotheses":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8))","proofString":"change (two_p 8) with 256.\nrewrite IHl1.\nring."},{"statement":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8)) : Byte.unsigned a + int_of_bytes (l1 ++ l2) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * (two_p (Z.of_nat (Datatypes.length l1) * 8) * 256).","conclusion":"Byte.unsigned a + int_of_bytes (l1 ++ l2) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * (two_p (Z.of_nat (Datatypes.length l1) * 8) * 256)","hypotheses":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8))","proofString":"rewrite IHl1.\nring."},{"statement":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8)) : Byte.unsigned a +\n(int_of_bytes l1 +\n int_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8)) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * (two_p (Z.of_nat (Datatypes.length l1) * 8) * 256).","conclusion":"Byte.unsigned a +\n(int_of_bytes l1 +\n int_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8)) * 256 =\nByte.unsigned a + int_of_bytes l1 * 256 +\nint_of_bytes l2 * (two_p (Z.of_nat (Datatypes.length l1) * 8) * 256)","hypotheses":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8))","proofString":"ring."},{"statement":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8)) : 0 <= Z.of_nat (Datatypes.length l1) * 8.","conclusion":"0 <= Z.of_nat (Datatypes.length l1) * 8","hypotheses":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8))","proofString":"lia."},{"statement":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8)) : 0 <= 8.","conclusion":"0 <= 8","hypotheses":"(l2 : list byte) (a : byte) (l1 : list byte) (IHl1 : int_of_bytes (l1 ++ l2) =\nint_of_bytes l1 +\nint_of_bytes l2 * two_p (Z.of_nat (Datatypes.length l1) * 8))","proofString":"lia."},{"statement":"0 <= 0 < 1.","conclusion":"0 <= 0 < 1","hypotheses":"","proofString":"lia."},{"statement":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8)) : 0 <= int_of_bytes (a :: l) < two_p (Z.of_nat (Datatypes.length (a :: l)) * 8).","conclusion":"0 <= int_of_bytes (a :: l) < two_p (Z.of_nat (Datatypes.length (a :: l)) * 8)","hypotheses":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8))","proofString":"simpl length.\nrewrite Nat2Z.inj_succ.\nreplace (Z.succ (Z.of_nat (length l)) * 8) with (Z.of_nat (length l) * 8 + 8) by lia.\nrewrite two_p_is_exp.\nchange (two_p 8) with 256.\nsimpl int_of_bytes.\ngeneralize (Byte.unsigned_range a).\nchange Byte.modulus with 256.\nlia.\nlia.\nlia."},{"statement":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8)) : 0 <= int_of_bytes (a :: l) < two_p (Z.of_nat (S (Datatypes.length l)) * 8).","conclusion":"0 <= int_of_bytes (a :: l) < two_p (Z.of_nat (S (Datatypes.length l)) * 8)","hypotheses":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8))","proofString":"rewrite Nat2Z.inj_succ.\nreplace (Z.succ (Z.of_nat (length l)) * 8) with (Z.of_nat (length l) * 8 + 8) by lia.\nrewrite two_p_is_exp.\nchange (two_p 8) with 256.\nsimpl int_of_bytes.\ngeneralize (Byte.unsigned_range a).\nchange Byte.modulus with 256.\nlia.\nlia.\nlia."},{"statement":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8)) : 0 <= int_of_bytes (a :: l) <\ntwo_p (Z.succ (Z.of_nat (Datatypes.length l)) * 8).","conclusion":"0 <= int_of_bytes (a :: l) <\ntwo_p (Z.succ (Z.of_nat (Datatypes.length l)) * 8)","hypotheses":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8))","proofString":"replace (Z.succ (Z.of_nat (length l)) * 8) with (Z.of_nat (length l) * 8 + 8) by lia.\nrewrite two_p_is_exp.\nchange (two_p 8) with 256.\nsimpl int_of_bytes.\ngeneralize (Byte.unsigned_range a).\nchange Byte.modulus with 256.\nlia.\nlia.\nlia."},{"statement":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8)) : 0 <= int_of_bytes (a :: l) < two_p (Z.of_nat (Datatypes.length l) * 8 + 8).","conclusion":"0 <= int_of_bytes (a :: l) < two_p (Z.of_nat (Datatypes.length l) * 8 + 8)","hypotheses":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8))","proofString":"rewrite two_p_is_exp.\nchange (two_p 8) with 256.\nsimpl int_of_bytes.\ngeneralize (Byte.unsigned_range a).\nchange Byte.modulus with 256.\nlia.\nlia.\nlia."},{"statement":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8)) : 0 <= int_of_bytes (a :: l) <\ntwo_p (Z.of_nat (Datatypes.length l) * 8) * two_p 8.","conclusion":"0 <= int_of_bytes (a :: l) <\ntwo_p (Z.of_nat (Datatypes.length l) * 8) * two_p 8","hypotheses":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8))","proofString":"change (two_p 8) with 256.\nsimpl int_of_bytes.\ngeneralize (Byte.unsigned_range a).\nchange Byte.modulus with 256.\nlia."},{"statement":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8)) : 0 <= int_of_bytes (a :: l) < two_p (Z.of_nat (Datatypes.length l) * 8) * 256.","conclusion":"0 <= int_of_bytes (a :: l) < two_p (Z.of_nat (Datatypes.length l) * 8) * 256","hypotheses":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8))","proofString":"simpl int_of_bytes.\ngeneralize (Byte.unsigned_range a).\nchange Byte.modulus with 256.\nlia."},{"statement":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8)) : 0 <= Byte.unsigned a + int_of_bytes l * 256 <\ntwo_p (Z.of_nat (Datatypes.length l) * 8) * 256.","conclusion":"0 <= Byte.unsigned a + int_of_bytes l * 256 <\ntwo_p (Z.of_nat (Datatypes.length l) * 8) * 256","hypotheses":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8))","proofString":"generalize (Byte.unsigned_range a).\nchange Byte.modulus with 256.\nlia."},{"statement":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8)) : 0 <= Byte.unsigned a < Byte.modulus ->\n0 <= Byte.unsigned a + int_of_bytes l * 256 <\ntwo_p (Z.of_nat (Datatypes.length l) * 8) * 256.","conclusion":"0 <= Byte.unsigned a < Byte.modulus ->\n0 <= Byte.unsigned a + int_of_bytes l * 256 <\ntwo_p (Z.of_nat (Datatypes.length l) * 8) * 256","hypotheses":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8))","proofString":"change Byte.modulus with 256.\nlia."},{"statement":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8)) : 0 <= Byte.unsigned a < 256 ->\n0 <= Byte.unsigned a + int_of_bytes l * 256 <\ntwo_p (Z.of_nat (Datatypes.length l) * 8) * 256.","conclusion":"0 <= Byte.unsigned a < 256 ->\n0 <= Byte.unsigned a + int_of_bytes l * 256 <\ntwo_p (Z.of_nat (Datatypes.length l) * 8) * 256","hypotheses":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8))","proofString":"lia."},{"statement":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8)) : 0 <= Z.of_nat (Datatypes.length l) * 8.","conclusion":"0 <= Z.of_nat (Datatypes.length l) * 8","hypotheses":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8))","proofString":"lia."},{"statement":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8)) : 0 <= 8.","conclusion":"0 <= 8","hypotheses":"(a : byte) (l : list byte) (IHl : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8))","proofString":"lia."},{"statement":"(b : list byte) (H : Some nil = Some b) : Datatypes.length b = 0%nat.","conclusion":"Datatypes.length b = 0%nat","hypotheses":"(b : list byte) (H : Some nil = Some b)","proofString":"inv H; auto."},{"statement":"(a : memval) (l : list memval) (IHl : forall b0 : list byte,\nproj_bytes l = Some b0 -> Datatypes.length b0 = Datatypes.length l) (b : list byte) (H : match a with\n| Byte b0 =>\n    match proj_bytes l with\n    | Some bl => Some (b0 :: bl)\n    | None => None\n    end\n| _ => None\nend = Some b) : Datatypes.length b = S (Datatypes.length l).","conclusion":"Datatypes.length b = S (Datatypes.length l)","hypotheses":"(a : memval) (l : list memval) (IHl : forall b0 : list byte,\nproj_bytes l = Some b0 -> Datatypes.length b0 = Datatypes.length l) (b : list byte) (H : match a with\n| Byte b0 =>\n    match proj_bytes l with\n    | Some bl => Some (b0 :: bl)\n    | None => None\n    end\n| _ => None\nend = Some b)","proofString":"destruct a; try discriminate.\ndestruct (proj_bytes l) eqn:E; inv H.\nsimpl.\nf_equal.\nauto."},{"statement":"(i : byte) (l : list memval) (IHl : forall b0 : list byte,\nproj_bytes l = Some b0 -> Datatypes.length b0 = Datatypes.length l) (b : list byte) (H : match proj_bytes l with\n| Some bl => Some (i :: bl)\n| None => None\nend = Some b) : Datatypes.length b = S (Datatypes.length l).","conclusion":"Datatypes.length b = S (Datatypes.length l)","hypotheses":"(i : byte) (l : list memval) (IHl : forall b0 : list byte,\nproj_bytes l = Some b0 -> Datatypes.length b0 = Datatypes.length l) (b : list byte) (H : match proj_bytes l with\n| Some bl => Some (i :: bl)\n| None => None\nend = Some b)","proofString":"destruct (proj_bytes l) eqn:E; inv H.\nsimpl.\nf_equal.\nauto."},{"statement":"(i : byte) (l : list memval) (l0 : list byte) (E : proj_bytes l = Some l0) (IHl : forall b : list byte,\nSome l0 = Some b -> Datatypes.length b = Datatypes.length l) : Datatypes.length (i :: l0) = S (Datatypes.length l).","conclusion":"Datatypes.length (i :: l0) = S (Datatypes.length l)","hypotheses":"(i : byte) (l : list memval) (l0 : list byte) (E : proj_bytes l = Some l0) (IHl : forall b : list byte,\nSome l0 = Some b -> Datatypes.length b = Datatypes.length l)","proofString":"simpl.\nf_equal.\nauto."},{"statement":"(i : byte) (l : list memval) (l0 : list byte) (E : proj_bytes l = Some l0) (IHl : forall b : list byte,\nSome l0 = Some b -> Datatypes.length b = Datatypes.length l) : S (Datatypes.length l0) = S (Datatypes.length l).","conclusion":"S (Datatypes.length l0) = S (Datatypes.length l)","hypotheses":"(i : byte) (l : list memval) (l0 : list byte) (E : proj_bytes l = Some l0) (IHl : forall b : list byte,\nSome l0 = Some b -> Datatypes.length b = Datatypes.length l)","proofString":"f_equal.\nauto."},{"statement":"(i : byte) (l : list memval) (l0 : list byte) (E : proj_bytes l = Some l0) (IHl : forall b : list byte,\nSome l0 = Some b -> Datatypes.length b = Datatypes.length l) : Datatypes.length l0 = Datatypes.length l.","conclusion":"Datatypes.length l0 = Datatypes.length l","hypotheses":"(i : byte) (l : list memval) (l0 : list byte) (E : proj_bytes l = Some l0) (IHl : forall b : list byte,\nSome l0 = Some b -> Datatypes.length b = Datatypes.length l)","proofString":"auto."},{"statement":"(l2 : list memval) : proj_bytes l2 =\nmatch proj_bytes l2 with\n| Some b2 => Some b2\n| None => None\nend.","conclusion":"proj_bytes l2 =\nmatch proj_bytes l2 with\n| Some b2 => Some b2\n| None => None\nend","hypotheses":"(l2 : list memval)","proofString":"destruct (proj_bytes l2); auto."},{"statement":"(l2 : list memval) (a : memval) (l1 : list memval) (IHl1 : proj_bytes (l1 ++ l2) =\nmatch proj_bytes l1 with\n| Some b1 =>\n    match proj_bytes l2 with\n    | Some b2 => Some (b1 ++ b2)\n    | None => None\n    end\n| None => None\nend) : match a with\n| Byte b =>\n    match proj_bytes (l1 ++ l2) with\n    | Some bl => Some (b :: bl)\n    | None => None\n    end\n| _ => None\nend =\nmatch\n  match a with\n  | Byte b =>\n      match proj_bytes l1 with\n      | Some bl => Some (b :: bl)\n      | None => None\n      end\n  | _ => None\n  end\nwith\n| Some b1 =>\n    match proj_bytes l2 with\n    | Some b2 => Some (b1 ++ b2)\n    | None => None\n    end\n| None => None\nend.","conclusion":"match a with\n| Byte b =>\n    match proj_bytes (l1 ++ l2) with\n    | Some bl => Some (b :: bl)\n    | None => None\n    end\n| _ => None\nend =\nmatch\n  match a with\n  | Byte b =>\n      match proj_bytes l1 with\n      | Some bl => Some (b :: bl)\n      | None => None\n      end\n  | _ => None\n  end\nwith\n| Some b1 =>\n    match proj_bytes l2 with\n    | Some b2 => Some (b1 ++ b2)\n    | None => None\n    end\n| None => None\nend","hypotheses":"(l2 : list memval) (a : memval) (l1 : list memval) (IHl1 : proj_bytes (l1 ++ l2) =\nmatch proj_bytes l1 with\n| Some b1 =>\n    match proj_bytes l2 with\n    | Some b2 => Some (b1 ++ b2)\n    | None => None\n    end\n| None => None\nend)","proofString":"destruct a; auto.\nrewrite IHl1.\ndestruct (proj_bytes l1); auto.\ndestruct (proj_bytes l2); auto."},{"statement":"(l2 : list memval) (i : byte) (l1 : list memval) (IHl1 : proj_bytes (l1 ++ l2) =\nmatch proj_bytes l1 with\n| Some b1 =>\n    match proj_bytes l2 with\n    | Some b2 => Some (b1 ++ b2)\n    | None => None\n    end\n| None => None\nend) : match proj_bytes (l1 ++ l2) with\n| Some bl => Some (i :: bl)\n| None => None\nend =\nmatch\n  match proj_bytes l1 with\n  | Some bl => Some (i :: bl)\n  | None => None\n  end\nwith\n| Some b1 =>\n    match proj_bytes l2 with\n    | Some b2 => Some (b1 ++ b2)\n    | None => None\n    end\n| None => None\nend.","conclusion":"match proj_bytes (l1 ++ l2) with\n| Some bl => Some (i :: bl)\n| None => None\nend =\nmatch\n  match proj_bytes l1 with\n  | Some bl => Some (i :: bl)\n  | None => None\n  end\nwith\n| Some b1 =>\n    match proj_bytes l2 with\n    | Some b2 => Some (b1 ++ b2)\n    | None => None\n    end\n| None => None\nend","hypotheses":"(l2 : list memval) (i : byte) (l1 : list memval) (IHl1 : proj_bytes (l1 ++ l2) =\nmatch proj_bytes l1 with\n| Some b1 =>\n    match proj_bytes l2 with\n    | Some b2 => Some (b1 ++ b2)\n    | None => None\n    end\n| None => None\nend)","proofString":"rewrite IHl1.\ndestruct (proj_bytes l1); auto.\ndestruct (proj_bytes l2); auto."},{"statement":"(l2 : list memval) (i : byte) (l1 : list memval) (IHl1 : proj_bytes (l1 ++ l2) =\nmatch proj_bytes l1 with\n| Some b1 =>\n    match proj_bytes l2 with\n    | Some b2 => Some (b1 ++ b2)\n    | None => None\n    end\n| None => None\nend) : match\n  match proj_bytes l1 with\n  | Some b1 =>\n      match proj_bytes l2 with\n      | Some b2 => Some (b1 ++ b2)\n      | None => None\n      end\n  | None => None\n  end\nwith\n| Some bl => Some (i :: bl)\n| None => None\nend =\nmatch\n  match proj_bytes l1 with\n  | Some bl => Some (i :: bl)\n  | None => None\n  end\nwith\n| Some b1 =>\n    match proj_bytes l2 with\n    | Some b2 => Some (b1 ++ b2)\n    | None => None\n    end\n| None => None\nend.","conclusion":"match\n  match proj_bytes l1 with\n  | Some b1 =>\n      match proj_bytes l2 with\n      | Some b2 => Some (b1 ++ b2)\n      | None => None\n      end\n  | None => None\n  end\nwith\n| Some bl => Some (i :: bl)\n| None => None\nend =\nmatch\n  match proj_bytes l1 with\n  | Some bl => Some (i :: bl)\n  | None => None\n  end\nwith\n| Some b1 =>\n    match proj_bytes l2 with\n    | Some b2 => Some (b1 ++ b2)\n    | None => None\n    end\n| None => None\nend","hypotheses":"(l2 : list memval) (i : byte) (l1 : list memval) (IHl1 : proj_bytes (l1 ++ l2) =\nmatch proj_bytes l1 with\n| Some b1 =>\n    match proj_bytes l2 with\n    | Some b2 => Some (b1 ++ b2)\n    | None => None\n    end\n| None => None\nend)","proofString":"destruct (proj_bytes l1); auto.\ndestruct (proj_bytes l2); auto."},{"statement":"(l2 : list memval) (i : byte) (l1 : list memval) (l : list byte) (IHl1 : proj_bytes (l1 ++ l2) =\nmatch proj_bytes l2 with\n| Some b2 => Some (l ++ b2)\n| None => None\nend) : match\n  match proj_bytes l2 with\n  | Some b2 => Some (l ++ b2)\n  | None => None\n  end\nwith\n| Some bl => Some (i :: bl)\n| None => None\nend =\nmatch proj_bytes l2 with\n| Some b2 => Some ((i :: l) ++ b2)\n| None => None\nend.","conclusion":"match\n  match proj_bytes l2 with\n  | Some b2 => Some (l ++ b2)\n  | None => None\n  end\nwith\n| Some bl => Some (i :: bl)\n| None => None\nend =\nmatch proj_bytes l2 with\n| Some b2 => Some ((i :: l) ++ b2)\n| None => None\nend","hypotheses":"(l2 : list memval) (i : byte) (l1 : list memval) (l : list byte) (IHl1 : proj_bytes (l1 ++ l2) =\nmatch proj_bytes l2 with\n| Some b2 => Some (l ++ b2)\n| None => None\nend)","proofString":"destruct (proj_bytes l2); auto."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) : Val.lessdef (decode_val Mint64 (l1 ++ l2))\n  (Val.longofwords (decode_val Mint32 (if Archi.big_endian then l1 else l2))\n     (decode_val Mint32 (if Archi.big_endian then l2 else l1))).","conclusion":"Val.lessdef (decode_val Mint64 (l1 ++ l2))\n  (Val.longofwords (decode_val Mint32 (if Archi.big_endian then l1 else l2))\n     (decode_val Mint32 (if Archi.big_endian then l2 else l1)))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false)","proofString":"unfold decode_val.\nrewrite H1.\nrewrite proj_bytes_append.\ndestruct (proj_bytes l1) as [b1|] eqn:B1; destruct (proj_bytes l2) as [b2|] eqn:B2; auto.\nexploit length_proj_bytes.\neexact B1.\nrewrite H; intro L1.\nexploit length_proj_bytes.\neexact B2.\nrewrite H0; intro L2.\nassert (UR: forall l, length l = 4%nat -> Int.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l).\nintros.\napply Int.unsigned_repr.\ngeneralize (int_of_bytes_range l).\nrewrite H2.\nchange (two_p (Z.of_nat 4 * 8)) with (Int.max_unsigned + 1).\nlia.\napply Val.lessdef_same.\nunfold decode_int, rev_if_be.\ndestruct Archi.big_endian; rewrite B1; rewrite B2.\nrewrite <- (rev_length b1) in L1.\nrewrite <- (rev_length b2) in L2.\nrewrite rev_app_distr.\nset (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) : Val.lessdef\n  match proj_bytes (l1 ++ l2) with\n  | Some bl => Vlong (Int64.repr (decode_int bl))\n  | None =>\n      if Archi.ptr64\n      then Val.load_result Mint64 (proj_value Q64 (l1 ++ l2))\n      else Vundef\n  end\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         if Archi.ptr64\n         then Vundef\n         else\n          Val.load_result Mint32\n            (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         if Archi.ptr64\n         then Vundef\n         else\n          Val.load_result Mint32\n            (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end).","conclusion":"Val.lessdef\n  match proj_bytes (l1 ++ l2) with\n  | Some bl => Vlong (Int64.repr (decode_int bl))\n  | None =>\n      if Archi.ptr64\n      then Val.load_result Mint64 (proj_value Q64 (l1 ++ l2))\n      else Vundef\n  end\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         if Archi.ptr64\n         then Vundef\n         else\n          Val.load_result Mint32\n            (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         if Archi.ptr64\n         then Vundef\n         else\n          Val.load_result Mint32\n            (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end)","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false)","proofString":"rewrite H1.\nrewrite proj_bytes_append.\ndestruct (proj_bytes l1) as [b1|] eqn:B1; destruct (proj_bytes l2) as [b2|] eqn:B2; auto.\nexploit length_proj_bytes.\neexact B1.\nrewrite H; intro L1.\nexploit length_proj_bytes.\neexact B2.\nrewrite H0; intro L2.\nassert (UR: forall l, length l = 4%nat -> Int.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l).\nintros.\napply Int.unsigned_repr.\ngeneralize (int_of_bytes_range l).\nrewrite H2.\nchange (two_p (Z.of_nat 4 * 8)) with (Int.max_unsigned + 1).\nlia.\napply Val.lessdef_same.\nunfold decode_int, rev_if_be.\ndestruct Archi.big_endian; rewrite B1; rewrite B2.\nrewrite <- (rev_length b1) in L1.\nrewrite <- (rev_length b2) in L2.\nrewrite rev_app_distr.\nset (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) : Val.lessdef\n  match proj_bytes (l1 ++ l2) with\n  | Some bl => Vlong (Int64.repr (decode_int bl))\n  | None => Vundef\n  end\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end).","conclusion":"Val.lessdef\n  match proj_bytes (l1 ++ l2) with\n  | Some bl => Vlong (Int64.repr (decode_int bl))\n  | None => Vundef\n  end\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end)","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false)","proofString":"rewrite proj_bytes_append.\ndestruct (proj_bytes l1) as [b1|] eqn:B1; destruct (proj_bytes l2) as [b2|] eqn:B2; auto.\nexploit length_proj_bytes.\neexact B1.\nrewrite H; intro L1.\nexploit length_proj_bytes.\neexact B2.\nrewrite H0; intro L2.\nassert (UR: forall l, length l = 4%nat -> Int.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l).\nintros.\napply Int.unsigned_repr.\ngeneralize (int_of_bytes_range l).\nrewrite H2.\nchange (two_p (Z.of_nat 4 * 8)) with (Int.max_unsigned + 1).\nlia.\napply Val.lessdef_same.\nunfold decode_int, rev_if_be.\ndestruct Archi.big_endian; rewrite B1; rewrite B2.\nrewrite <- (rev_length b1) in L1.\nrewrite <- (rev_length b2) in L2.\nrewrite rev_app_distr.\nset (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) : Val.lessdef\n  match\n    match proj_bytes l1 with\n    | Some b1 =>\n        match proj_bytes l2 with\n        | Some b2 => Some (b1 ++ b2)\n        | None => None\n        end\n    | None => None\n    end\n  with\n  | Some bl => Vlong (Int64.repr (decode_int bl))\n  | None => Vundef\n  end\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end).","conclusion":"Val.lessdef\n  match\n    match proj_bytes l1 with\n    | Some b1 =>\n        match proj_bytes l2 with\n        | Some b2 => Some (b1 ++ b2)\n        | None => None\n        end\n    | None => None\n    end\n  with\n  | Some bl => Vlong (Int64.repr (decode_int bl))\n  | None => Vundef\n  end\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end)","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false)","proofString":"destruct (proj_bytes l1) as [b1|] eqn:B1; destruct (proj_bytes l2) as [b2|] eqn:B2; auto.\nexploit length_proj_bytes.\neexact B1.\nrewrite H; intro L1.\nexploit length_proj_bytes.\neexact B2.\nrewrite H0; intro L2.\nassert (UR: forall l, length l = 4%nat -> Int.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l).\nintros.\napply Int.unsigned_repr.\ngeneralize (int_of_bytes_range l).\nrewrite H2.\nchange (two_p (Z.of_nat 4 * 8)) with (Int.max_unsigned + 1).\nlia.\napply Val.lessdef_same.\nunfold decode_int, rev_if_be.\ndestruct Archi.big_endian; rewrite B1; rewrite B2.\nrewrite <- (rev_length b1) in L1.\nrewrite <- (rev_length b2) in L2.\nrewrite rev_app_distr.\nset (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) : Val.lessdef (Vlong (Int64.repr (decode_int (b1 ++ b2))))\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end).","conclusion":"Val.lessdef (Vlong (Int64.repr (decode_int (b1 ++ b2))))\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end)","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2)","proofString":"exploit length_proj_bytes.\neexact B1.\nrewrite H; intro L1.\nexploit length_proj_bytes.\neexact B2.\nrewrite H0; intro L2.\nassert (UR: forall l, length l = 4%nat -> Int.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l).\nintros.\napply Int.unsigned_repr.\ngeneralize (int_of_bytes_range l).\nrewrite H2.\nchange (two_p (Z.of_nat 4 * 8)) with (Int.max_unsigned + 1).\nlia.\napply Val.lessdef_same.\nunfold decode_int, rev_if_be.\ndestruct Archi.big_endian; rewrite B1; rewrite B2.\nrewrite <- (rev_length b1) in L1.\nrewrite <- (rev_length b2) in L2.\nrewrite rev_app_distr.\nset (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) : Val.lessdef (Vlong (Int64.repr (decode_int (b1 ++ b2))))\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end).","conclusion":"Val.lessdef (Vlong (Int64.repr (decode_int (b1 ++ b2))))\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end)","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat)","proofString":"exploit length_proj_bytes.\neexact B2.\nrewrite H0; intro L2.\nassert (UR: forall l, length l = 4%nat -> Int.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l).\nintros.\napply Int.unsigned_repr.\ngeneralize (int_of_bytes_range l).\nrewrite H2.\nchange (two_p (Z.of_nat 4 * 8)) with (Int.max_unsigned + 1).\nlia.\napply Val.lessdef_same.\nunfold decode_int, rev_if_be.\ndestruct Archi.big_endian; rewrite B1; rewrite B2.\nrewrite <- (rev_length b1) in L1.\nrewrite <- (rev_length b2) in L2.\nrewrite rev_app_distr.\nset (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) : Val.lessdef (Vlong (Int64.repr (decode_int (b1 ++ b2))))\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end).","conclusion":"Val.lessdef (Vlong (Int64.repr (decode_int (b1 ++ b2))))\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end)","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat)","proofString":"assert (UR: forall l, length l = 4%nat -> Int.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l).\nintros.\napply Int.unsigned_repr.\ngeneralize (int_of_bytes_range l).\nrewrite H2.\nchange (two_p (Z.of_nat 4 * 8)) with (Int.max_unsigned + 1).\nlia.\napply Val.lessdef_same.\nunfold decode_int, rev_if_be.\ndestruct Archi.big_endian; rewrite B1; rewrite B2.\nrewrite <- (rev_length b1) in L1.\nrewrite <- (rev_length b2) in L2.\nrewrite rev_app_distr.\nset (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l.","conclusion":"forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat)","proofString":"intros.\napply Int.unsigned_repr.\ngeneralize (int_of_bytes_range l).\nrewrite H2.\nchange (two_p (Z.of_nat 4 * 8)) with (Int.max_unsigned + 1).\nlia."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (l : list byte) (H2 : Datatypes.length l = 4%nat) : Int.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l.","conclusion":"Int.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (l : list byte) (H2 : Datatypes.length l = 4%nat)","proofString":"apply Int.unsigned_repr.\ngeneralize (int_of_bytes_range l).\nrewrite H2.\nchange (two_p (Z.of_nat 4 * 8)) with (Int.max_unsigned + 1).\nlia."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (l : list byte) (H2 : Datatypes.length l = 4%nat) : 0 <= int_of_bytes l <= Int.max_unsigned.","conclusion":"0 <= int_of_bytes l <= Int.max_unsigned","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (l : list byte) (H2 : Datatypes.length l = 4%nat)","proofString":"generalize (int_of_bytes_range l).\nrewrite H2.\nchange (two_p (Z.of_nat 4 * 8)) with (Int.max_unsigned + 1).\nlia."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (l : list byte) (H2 : Datatypes.length l = 4%nat) : 0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8) ->\n0 <= int_of_bytes l <= Int.max_unsigned.","conclusion":"0 <= int_of_bytes l < two_p (Z.of_nat (Datatypes.length l) * 8) ->\n0 <= int_of_bytes l <= Int.max_unsigned","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (l : list byte) (H2 : Datatypes.length l = 4%nat)","proofString":"rewrite H2.\nchange (two_p (Z.of_nat 4 * 8)) with (Int.max_unsigned + 1).\nlia."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (l : list byte) (H2 : Datatypes.length l = 4%nat) : 0 <= int_of_bytes l < two_p (Z.of_nat 4 * 8) ->\n0 <= int_of_bytes l <= Int.max_unsigned.","conclusion":"0 <= int_of_bytes l < two_p (Z.of_nat 4 * 8) ->\n0 <= int_of_bytes l <= Int.max_unsigned","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (l : list byte) (H2 : Datatypes.length l = 4%nat)","proofString":"change (two_p (Z.of_nat 4 * 8)) with (Int.max_unsigned + 1).\nlia."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (l : list byte) (H2 : Datatypes.length l = 4%nat) : 0 <= int_of_bytes l < Int.max_unsigned + 1 ->\n0 <= int_of_bytes l <= Int.max_unsigned.","conclusion":"0 <= int_of_bytes l < Int.max_unsigned + 1 ->\n0 <= int_of_bytes l <= Int.max_unsigned","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (l : list byte) (H2 : Datatypes.length l = 4%nat)","proofString":"lia."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Val.lessdef (Vlong (Int64.repr (decode_int (b1 ++ b2))))\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end).","conclusion":"Val.lessdef (Vlong (Int64.repr (decode_int (b1 ++ b2))))\n  (Val.longofwords\n     match proj_bytes (if Archi.big_endian then l1 else l2) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l1 else l2))\n     end\n     match proj_bytes (if Archi.big_endian then l2 else l1) with\n     | Some bl => Vint (Int.repr (decode_int bl))\n     | None =>\n         Val.load_result Mint32\n           (proj_value Q32 (if Archi.big_endian then l2 else l1))\n     end)","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"apply Val.lessdef_same.\nunfold decode_int, rev_if_be.\ndestruct Archi.big_endian; rewrite B1; rewrite B2.\nrewrite <- (rev_length b1) in L1.\nrewrite <- (rev_length b2) in L2.\nrewrite rev_app_distr.\nset (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Vlong (Int64.repr (decode_int (b1 ++ b2))) =\nVal.longofwords\n  match proj_bytes (if Archi.big_endian then l1 else l2) with\n  | Some bl => Vint (Int.repr (decode_int bl))\n  | None =>\n      Val.load_result Mint32\n        (proj_value Q32 (if Archi.big_endian then l1 else l2))\n  end\n  match proj_bytes (if Archi.big_endian then l2 else l1) with\n  | Some bl => Vint (Int.repr (decode_int bl))\n  | None =>\n      Val.load_result Mint32\n        (proj_value Q32 (if Archi.big_endian then l2 else l1))\n  end.","conclusion":"Vlong (Int64.repr (decode_int (b1 ++ b2))) =\nVal.longofwords\n  match proj_bytes (if Archi.big_endian then l1 else l2) with\n  | Some bl => Vint (Int.repr (decode_int bl))\n  | None =>\n      Val.load_result Mint32\n        (proj_value Q32 (if Archi.big_endian then l1 else l2))\n  end\n  match proj_bytes (if Archi.big_endian then l2 else l1) with\n  | Some bl => Vint (Int.repr (decode_int bl))\n  | None =>\n      Val.load_result Mint32\n        (proj_value Q32 (if Archi.big_endian then l2 else l1))\n  end","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"unfold decode_int, rev_if_be.\ndestruct Archi.big_endian; rewrite B1; rewrite B2.\nrewrite <- (rev_length b1) in L1.\nrewrite <- (rev_length b2) in L2.\nrewrite rev_app_distr.\nset (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Vlong\n  (Int64.repr\n     (int_of_bytes (if Archi.big_endian then rev (b1 ++ b2) else b1 ++ b2))) =\nVal.longofwords\n  match proj_bytes (if Archi.big_endian then l1 else l2) with\n  | Some bl =>\n      Vint\n        (Int.repr (int_of_bytes (if Archi.big_endian then rev bl else bl)))\n  | None =>\n      Val.load_result Mint32\n        (proj_value Q32 (if Archi.big_endian then l1 else l2))\n  end\n  match proj_bytes (if Archi.big_endian then l2 else l1) with\n  | Some bl =>\n      Vint\n        (Int.repr (int_of_bytes (if Archi.big_endian then rev bl else bl)))\n  | None =>\n      Val.load_result Mint32\n        (proj_value Q32 (if Archi.big_endian then l2 else l1))\n  end.","conclusion":"Vlong\n  (Int64.repr\n     (int_of_bytes (if Archi.big_endian then rev (b1 ++ b2) else b1 ++ b2))) =\nVal.longofwords\n  match proj_bytes (if Archi.big_endian then l1 else l2) with\n  | Some bl =>\n      Vint\n        (Int.repr (int_of_bytes (if Archi.big_endian then rev bl else bl)))\n  | None =>\n      Val.load_result Mint32\n        (proj_value Q32 (if Archi.big_endian then l1 else l2))\n  end\n  match proj_bytes (if Archi.big_endian then l2 else l1) with\n  | Some bl =>\n      Vint\n        (Int.repr (int_of_bytes (if Archi.big_endian then rev bl else bl)))\n  | None =>\n      Val.load_result Mint32\n        (proj_value Q32 (if Archi.big_endian then l2 else l1))\n  end","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"destruct Archi.big_endian; rewrite B1; rewrite B2.\nrewrite <- (rev_length b1) in L1.\nrewrite <- (rev_length b2) in L2.\nrewrite rev_app_distr.\nset (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Vlong (Int64.repr (int_of_bytes (rev (b1 ++ b2)))) =\nVal.longofwords (Vint (Int.repr (int_of_bytes (rev b1))))\n  (Vint (Int.repr (int_of_bytes (rev b2)))).","conclusion":"Vlong (Int64.repr (int_of_bytes (rev (b1 ++ b2)))) =\nVal.longofwords (Vint (Int.repr (int_of_bytes (rev b1))))\n  (Vint (Int.repr (int_of_bytes (rev b2))))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"rewrite <- (rev_length b1) in L1.\nrewrite <- (rev_length b2) in L2.\nrewrite rev_app_distr.\nset (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length (rev b1) = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Vlong (Int64.repr (int_of_bytes (rev (b1 ++ b2)))) =\nVal.longofwords (Vint (Int.repr (int_of_bytes (rev b1))))\n  (Vint (Int.repr (int_of_bytes (rev b2)))).","conclusion":"Vlong (Int64.repr (int_of_bytes (rev (b1 ++ b2)))) =\nVal.longofwords (Vint (Int.repr (int_of_bytes (rev b1))))\n  (Vint (Int.repr (int_of_bytes (rev b2))))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length (rev b1) = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"rewrite <- (rev_length b2) in L2.\nrewrite rev_app_distr.\nset (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length (rev b1) = 4%nat) (L2 : Datatypes.length (rev b2) = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Vlong (Int64.repr (int_of_bytes (rev (b1 ++ b2)))) =\nVal.longofwords (Vint (Int.repr (int_of_bytes (rev b1))))\n  (Vint (Int.repr (int_of_bytes (rev b2)))).","conclusion":"Vlong (Int64.repr (int_of_bytes (rev (b1 ++ b2)))) =\nVal.longofwords (Vint (Int.repr (int_of_bytes (rev b1))))\n  (Vint (Int.repr (int_of_bytes (rev b2))))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length (rev b1) = 4%nat) (L2 : Datatypes.length (rev b2) = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"rewrite rev_app_distr.\nset (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length (rev b1) = 4%nat) (L2 : Datatypes.length (rev b2) = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Vlong (Int64.repr (int_of_bytes (rev b2 ++ rev b1))) =\nVal.longofwords (Vint (Int.repr (int_of_bytes (rev b1))))\n  (Vint (Int.repr (int_of_bytes (rev b2)))).","conclusion":"Vlong (Int64.repr (int_of_bytes (rev b2 ++ rev b1))) =\nVal.longofwords (Vint (Int.repr (int_of_bytes (rev b1))))\n  (Vint (Int.repr (int_of_bytes (rev b2))))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length (rev b1) = 4%nat) (L2 : Datatypes.length (rev b2) = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"set (b1' := rev b1) in *; set (b2' := rev b2) in *.\nunfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Vlong (Int64.repr (int_of_bytes (b2' ++ b1'))) =\nVal.longofwords (Vint (Int.repr (int_of_bytes b1')))\n  (Vint (Int.repr (int_of_bytes b2'))).","conclusion":"Vlong (Int64.repr (int_of_bytes (b2' ++ b1'))) =\nVal.longofwords (Vint (Int.repr (int_of_bytes b1')))\n  (Vint (Int.repr (int_of_bytes b2')))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"unfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Vlong (Int64.repr (int_of_bytes (b2' ++ b1'))) =\nVlong\n  (Int64.ofwords (Int.repr (int_of_bytes b1')) (Int.repr (int_of_bytes b2'))).","conclusion":"Vlong (Int64.repr (int_of_bytes (b2' ++ b1'))) =\nVlong\n  (Int64.ofwords (Int.repr (int_of_bytes b1')) (Int.repr (int_of_bytes b2')))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"f_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Int64.repr (int_of_bytes (b2' ++ b1')) =\nInt64.ofwords (Int.repr (int_of_bytes b1')) (Int.repr (int_of_bytes b2')).","conclusion":"Int64.repr (int_of_bytes (b2' ++ b1')) =\nInt64.ofwords (Int.repr (int_of_bytes b1')) (Int.repr (int_of_bytes b2'))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"rewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Int64.repr (int_of_bytes (b2' ++ b1')) =\nInt64.repr\n  (Int.unsigned (Int.repr (int_of_bytes b1')) * two_p 32 +\n   Int.unsigned (Int.repr (int_of_bytes b2'))).","conclusion":"Int64.repr (int_of_bytes (b2' ++ b1')) =\nInt64.repr\n  (Int.unsigned (Int.repr (int_of_bytes b1')) * two_p 32 +\n   Int.unsigned (Int.repr (int_of_bytes b2')))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"f_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : int_of_bytes (b2' ++ b1') =\nInt.unsigned (Int.repr (int_of_bytes b1')) * two_p 32 +\nInt.unsigned (Int.repr (int_of_bytes b2')).","conclusion":"int_of_bytes (b2' ++ b1') =\nInt.unsigned (Int.repr (int_of_bytes b1')) * two_p 32 +\nInt.unsigned (Int.repr (int_of_bytes b2'))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"rewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : int_of_bytes (b2' ++ b1') = int_of_bytes b1' * two_p 32 + int_of_bytes b2'.","conclusion":"int_of_bytes (b2' ++ b1') = int_of_bytes b1' * two_p 32 + int_of_bytes b2'","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"rewrite int_of_bytes_append.\nrewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : int_of_bytes b2' +\nint_of_bytes b1' * two_p (Z.of_nat (Datatypes.length b2') * 8) =\nint_of_bytes b1' * two_p 32 + int_of_bytes b2'.","conclusion":"int_of_bytes b2' +\nint_of_bytes b1' * two_p (Z.of_nat (Datatypes.length b2') * 8) =\nint_of_bytes b1' * two_p 32 + int_of_bytes b2'","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"rewrite L2.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : int_of_bytes b2' + int_of_bytes b1' * two_p (Z.of_nat 4 * 8) =\nint_of_bytes b1' * two_p 32 + int_of_bytes b2'.","conclusion":"int_of_bytes b2' + int_of_bytes b1' * two_p (Z.of_nat 4 * 8) =\nint_of_bytes b1' * two_p 32 + int_of_bytes b2'","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"change (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : int_of_bytes b2' + int_of_bytes b1' * two_p 32 =\nint_of_bytes b1' * two_p 32 + int_of_bytes b2'.","conclusion":"int_of_bytes b2' + int_of_bytes b1' * two_p 32 =\nint_of_bytes b1' * two_p 32 + int_of_bytes b2'","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (b1' : list byte) (L1 : Datatypes.length b1' = 4%nat) (b2' : list byte) (L2 : Datatypes.length b2' = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"ring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Vlong (Int64.repr (int_of_bytes (b1 ++ b2))) =\nVal.longofwords (Vint (Int.repr (int_of_bytes b2)))\n  (Vint (Int.repr (int_of_bytes b1))).","conclusion":"Vlong (Int64.repr (int_of_bytes (b1 ++ b2))) =\nVal.longofwords (Vint (Int.repr (int_of_bytes b2)))\n  (Vint (Int.repr (int_of_bytes b1)))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"unfold Val.longofwords.\nf_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Vlong (Int64.repr (int_of_bytes (b1 ++ b2))) =\nVlong\n  (Int64.ofwords (Int.repr (int_of_bytes b2)) (Int.repr (int_of_bytes b1))).","conclusion":"Vlong (Int64.repr (int_of_bytes (b1 ++ b2))) =\nVlong\n  (Int64.ofwords (Int.repr (int_of_bytes b2)) (Int.repr (int_of_bytes b1)))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"f_equal.\nrewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Int64.repr (int_of_bytes (b1 ++ b2)) =\nInt64.ofwords (Int.repr (int_of_bytes b2)) (Int.repr (int_of_bytes b1)).","conclusion":"Int64.repr (int_of_bytes (b1 ++ b2)) =\nInt64.ofwords (Int.repr (int_of_bytes b2)) (Int.repr (int_of_bytes b1))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"rewrite Int64.ofwords_add.\nf_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : Int64.repr (int_of_bytes (b1 ++ b2)) =\nInt64.repr\n  (Int.unsigned (Int.repr (int_of_bytes b2)) * two_p 32 +\n   Int.unsigned (Int.repr (int_of_bytes b1))).","conclusion":"Int64.repr (int_of_bytes (b1 ++ b2)) =\nInt64.repr\n  (Int.unsigned (Int.repr (int_of_bytes b2)) * two_p 32 +\n   Int.unsigned (Int.repr (int_of_bytes b1)))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"f_equal.\nrewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : int_of_bytes (b1 ++ b2) =\nInt.unsigned (Int.repr (int_of_bytes b2)) * two_p 32 +\nInt.unsigned (Int.repr (int_of_bytes b1)).","conclusion":"int_of_bytes (b1 ++ b2) =\nInt.unsigned (Int.repr (int_of_bytes b2)) * two_p 32 +\nInt.unsigned (Int.repr (int_of_bytes b1))","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"rewrite !UR by auto.\nrewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : int_of_bytes (b1 ++ b2) = int_of_bytes b2 * two_p 32 + int_of_bytes b1.","conclusion":"int_of_bytes (b1 ++ b2) = int_of_bytes b2 * two_p 32 + int_of_bytes b1","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"rewrite int_of_bytes_append.\nrewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : int_of_bytes b1 +\nint_of_bytes b2 * two_p (Z.of_nat (Datatypes.length b1) * 8) =\nint_of_bytes b2 * two_p 32 + int_of_bytes b1.","conclusion":"int_of_bytes b1 +\nint_of_bytes b2 * two_p (Z.of_nat (Datatypes.length b1) * 8) =\nint_of_bytes b2 * two_p 32 + int_of_bytes b1","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"rewrite L1.\nchange (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : int_of_bytes b1 + int_of_bytes b2 * two_p (Z.of_nat 4 * 8) =\nint_of_bytes b2 * two_p 32 + int_of_bytes b1.","conclusion":"int_of_bytes b1 + int_of_bytes b2 * two_p (Z.of_nat 4 * 8) =\nint_of_bytes b2 * two_p 32 + int_of_bytes b1","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"change (Z.of_nat 4 * 8) with 32.\nring."},{"statement":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l) : int_of_bytes b1 + int_of_bytes b2 * two_p 32 =\nint_of_bytes b2 * two_p 32 + int_of_bytes b1.","conclusion":"int_of_bytes b1 + int_of_bytes b2 * two_p 32 =\nint_of_bytes b2 * two_p 32 + int_of_bytes b1","hypotheses":"(l1 l2 : list memval) (H : Datatypes.length l1 = 4%nat) (H0 : Datatypes.length l2 = 4%nat) (H1 : Archi.ptr64 = false) (b1 : list byte) (B1 : proj_bytes l1 = Some b1) (b2 : list byte) (B2 : proj_bytes l2 = Some b2) (L1 : Datatypes.length b1 = 4%nat) (L2 : Datatypes.length b2 = 4%nat) (UR : forall l : list byte,\nDatatypes.length l = 4%nat ->\nInt.unsigned (Int.repr (int_of_bytes l)) = int_of_bytes l)","proofString":"ring."},{"statement":"(n2 : nat) (x2 x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat 0 * 8)) : bytes_of_int (0 + n2) (x1 + x2 * two_p (Z.of_nat 0 * 8)) =\nbytes_of_int 0 x1 ++ bytes_of_int n2 x2.","conclusion":"bytes_of_int (0 + n2) (x1 + x2 * two_p (Z.of_nat 0 * 8)) =\nbytes_of_int 0 x1 ++ bytes_of_int n2 x2","hypotheses":"(n2 : nat) (x2 x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat 0 * 8))","proofString":"simpl in *.\nf_equal.\nlia."},{"statement":"(n2 : nat) (x2 x1 : Z) (H : 0 <= x1 < 1) : bytes_of_int n2 (x1 + x2 * 1) = bytes_of_int n2 x2.","conclusion":"bytes_of_int n2 (x1 + x2 * 1) = bytes_of_int n2 x2","hypotheses":"(n2 : nat) (x2 x1 : Z) (H : 0 <= x1 < 1)","proofString":"f_equal.\nlia."},{"statement":"(n2 : nat) (x2 x1 : Z) (H : 0 <= x1 < 1) : x1 + x2 * 1 = x2.","conclusion":"x1 + x2 * 1 = x2","hypotheses":"(n2 : nat) (x2 x1 : Z) (H : 0 <= x1 < 1)","proofString":"lia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8)) : bytes_of_int (S n1 + n2) (x1 + x2 * two_p (Z.of_nat (S n1) * 8)) =\nbytes_of_int (S n1) x1 ++ bytes_of_int n2 x2.","conclusion":"bytes_of_int (S n1 + n2) (x1 + x2 * two_p (Z.of_nat (S n1) * 8)) =\nbytes_of_int (S n1) x1 ++ bytes_of_int n2 x2","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8))","proofString":"assert (E: two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256).\nrewrite Nat2Z.inj_succ.\nchange 256 with (two_p 8).\nrewrite <- two_p_is_exp.\nf_equal.\nlia.\nlia.\nlia.\nrewrite E in *.\nsimpl.\nf_equal.\napply Byte.eqm_samerepr.\nexists (x2 * two_p (Z.of_nat n1 * 8)).\nchange Byte.modulus with 256.\nring.\nrewrite Z.mul_assoc.\nrewrite Z_div_plus.\napply IHn1.\napply Zdiv_interval_1.\nlia.\napply two_p_gt_ZERO; lia.\nlia.\nassumption.\nlia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8)) : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256.","conclusion":"two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8))","proofString":"rewrite Nat2Z.inj_succ.\nchange 256 with (two_p 8).\nrewrite <- two_p_is_exp.\nf_equal.\nlia.\nlia.\nlia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8)) : two_p (Z.succ (Z.of_nat n1) * 8) = two_p (Z.of_nat n1 * 8) * 256.","conclusion":"two_p (Z.succ (Z.of_nat n1) * 8) = two_p (Z.of_nat n1 * 8) * 256","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8))","proofString":"change 256 with (two_p 8).\nrewrite <- two_p_is_exp.\nf_equal.\nlia.\nlia.\nlia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8)) : two_p (Z.succ (Z.of_nat n1) * 8) = two_p (Z.of_nat n1 * 8) * two_p 8.","conclusion":"two_p (Z.succ (Z.of_nat n1) * 8) = two_p (Z.of_nat n1 * 8) * two_p 8","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8))","proofString":"rewrite <- two_p_is_exp.\nf_equal.\nlia.\nlia.\nlia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8)) : two_p (Z.succ (Z.of_nat n1) * 8) = two_p (Z.of_nat n1 * 8 + 8).","conclusion":"two_p (Z.succ (Z.of_nat n1) * 8) = two_p (Z.of_nat n1 * 8 + 8)","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8))","proofString":"f_equal.\nlia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8)) : Z.succ (Z.of_nat n1) * 8 = Z.of_nat n1 * 8 + 8.","conclusion":"Z.succ (Z.of_nat n1) * 8 = Z.of_nat n1 * 8 + 8","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8))","proofString":"lia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8)) : 0 <= Z.of_nat n1 * 8.","conclusion":"0 <= Z.of_nat n1 * 8","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8))","proofString":"lia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8)) : 0 <= 8.","conclusion":"0 <= 8","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8))","proofString":"lia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8)) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : bytes_of_int (S n1 + n2) (x1 + x2 * two_p (Z.of_nat (S n1) * 8)) =\nbytes_of_int (S n1) x1 ++ bytes_of_int n2 x2.","conclusion":"bytes_of_int (S n1 + n2) (x1 + x2 * two_p (Z.of_nat (S n1) * 8)) =\nbytes_of_int (S n1) x1 ++ bytes_of_int n2 x2","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat (S n1) * 8)) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"rewrite E in *.\nsimpl.\nf_equal.\napply Byte.eqm_samerepr.\nexists (x2 * two_p (Z.of_nat n1 * 8)).\nchange Byte.modulus with 256.\nring.\nrewrite Z.mul_assoc.\nrewrite Z_div_plus.\napply IHn1.\napply Zdiv_interval_1.\nlia.\napply two_p_gt_ZERO; lia.\nlia.\nassumption.\nlia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : bytes_of_int (S n1 + n2) (x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256)) =\nbytes_of_int (S n1) x1 ++ bytes_of_int n2 x2.","conclusion":"bytes_of_int (S n1 + n2) (x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256)) =\nbytes_of_int (S n1) x1 ++ bytes_of_int n2 x2","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"simpl.\nf_equal.\napply Byte.eqm_samerepr.\nexists (x2 * two_p (Z.of_nat n1 * 8)).\nchange Byte.modulus with 256.\nring.\nrewrite Z.mul_assoc.\nrewrite Z_div_plus.\napply IHn1.\napply Zdiv_interval_1.\nlia.\napply two_p_gt_ZERO; lia.\nlia.\nassumption.\nlia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : Byte.repr (x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256))\n:: bytes_of_int (n1 + n2) ((x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256)) / 256) =\nByte.repr x1 :: bytes_of_int n1 (x1 / 256) ++ bytes_of_int n2 x2.","conclusion":"Byte.repr (x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256))\n:: bytes_of_int (n1 + n2) ((x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256)) / 256) =\nByte.repr x1 :: bytes_of_int n1 (x1 / 256) ++ bytes_of_int n2 x2","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"f_equal.\napply Byte.eqm_samerepr.\nexists (x2 * two_p (Z.of_nat n1 * 8)).\nchange Byte.modulus with 256.\nring.\nrewrite Z.mul_assoc.\nrewrite Z_div_plus.\napply IHn1.\napply Zdiv_interval_1.\nlia.\napply two_p_gt_ZERO; lia.\nlia.\nassumption.\nlia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : Byte.repr (x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256)) = Byte.repr x1.","conclusion":"Byte.repr (x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256)) = Byte.repr x1","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"apply Byte.eqm_samerepr.\nexists (x2 * two_p (Z.of_nat n1 * 8)).\nchange Byte.modulus with 256.\nring."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : Byte.eqm (x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256)) x1.","conclusion":"Byte.eqm (x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256)) x1","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"exists (x2 * two_p (Z.of_nat n1 * 8)).\nchange Byte.modulus with 256.\nring."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256) =\nx2 * two_p (Z.of_nat n1 * 8) * Byte.modulus + x1.","conclusion":"x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256) =\nx2 * two_p (Z.of_nat n1 * 8) * Byte.modulus + x1","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"change Byte.modulus with 256.\nring."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256) =\nx2 * two_p (Z.of_nat n1 * 8) * 256 + x1.","conclusion":"x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256) =\nx2 * two_p (Z.of_nat n1 * 8) * 256 + x1","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"ring."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : bytes_of_int (n1 + n2) ((x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256)) / 256) =\nbytes_of_int n1 (x1 / 256) ++ bytes_of_int n2 x2.","conclusion":"bytes_of_int (n1 + n2) ((x1 + x2 * (two_p (Z.of_nat n1 * 8) * 256)) / 256) =\nbytes_of_int n1 (x1 / 256) ++ bytes_of_int n2 x2","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"rewrite Z.mul_assoc.\nrewrite Z_div_plus.\napply IHn1.\napply Zdiv_interval_1.\nlia.\napply two_p_gt_ZERO; lia.\nlia.\nassumption.\nlia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : bytes_of_int (n1 + n2) ((x1 + x2 * two_p (Z.of_nat n1 * 8) * 256) / 256) =\nbytes_of_int n1 (x1 / 256) ++ bytes_of_int n2 x2.","conclusion":"bytes_of_int (n1 + n2) ((x1 + x2 * two_p (Z.of_nat n1 * 8) * 256) / 256) =\nbytes_of_int n1 (x1 / 256) ++ bytes_of_int n2 x2","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"rewrite Z_div_plus.\napply IHn1.\napply Zdiv_interval_1.\nlia.\napply two_p_gt_ZERO; lia.\nlia.\nassumption.\nlia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : bytes_of_int (n1 + n2) (x1 / 256 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 (x1 / 256) ++ bytes_of_int n2 x2.","conclusion":"bytes_of_int (n1 + n2) (x1 / 256 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 (x1 / 256) ++ bytes_of_int n2 x2","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"apply IHn1.\napply Zdiv_interval_1.\nlia.\napply two_p_gt_ZERO; lia.\nlia.\nassumption."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : 0 <= x1 / 256 < two_p (Z.of_nat n1 * 8).","conclusion":"0 <= x1 / 256 < two_p (Z.of_nat n1 * 8)","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"apply Zdiv_interval_1.\nlia.\napply two_p_gt_ZERO; lia.\nlia.\nassumption."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : 0 <= 0.","conclusion":"0 <= 0","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"lia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : two_p (Z.of_nat n1 * 8) > 0.","conclusion":"two_p (Z.of_nat n1 * 8) > 0","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"apply two_p_gt_ZERO; lia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : 256 > 0.","conclusion":"256 > 0","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"lia."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : 0 * 256 <= x1 < two_p (Z.of_nat n1 * 8) * 256.","conclusion":"0 * 256 <= x1 < two_p (Z.of_nat n1 * 8) * 256","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"assumption."},{"statement":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256) : 256 > 0.","conclusion":"256 > 0","hypotheses":"(n2 : nat) (x2 : Z) (n1 : nat) (IHn1 : forall x0 : Z,\n0 <= x0 < two_p (Z.of_nat n1 * 8) ->\nbytes_of_int (n1 + n2) (x0 + x2 * two_p (Z.of_nat n1 * 8)) =\nbytes_of_int n1 x0 ++ bytes_of_int n2 x2) (x1 : Z) (H : 0 <= x1 < two_p (Z.of_nat n1 * 8) * 256) (E : two_p (Z.of_nat (S n1) * 8) = two_p (Z.of_nat n1 * 8) * 256)","proofString":"lia."},{"statement":"(i : int64) : bytes_of_int 8 (Int64.unsigned i) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i)).","conclusion":"bytes_of_int 8 (Int64.unsigned i) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i))","hypotheses":"(i : int64)","proofString":"transitivity (bytes_of_int (4 + 4) (Int64.unsigned (Int64.ofwords (Int64.hiword i) (Int64.loword i)))).\nf_equal.\nf_equal.\nrewrite Int64.ofwords_recompose.\nauto.\nrewrite Int64.ofwords_add'.\nchange 32 with (Z.of_nat 4 * 8).\nrewrite Z.add_comm.\napply bytes_of_int_append.\napply Int.unsigned_range."},{"statement":"(i : int64) : bytes_of_int 8 (Int64.unsigned i) =\nbytes_of_int (4 + 4)\n  (Int64.unsigned (Int64.ofwords (Int64.hiword i) (Int64.loword i))).","conclusion":"bytes_of_int 8 (Int64.unsigned i) =\nbytes_of_int (4 + 4)\n  (Int64.unsigned (Int64.ofwords (Int64.hiword i) (Int64.loword i)))","hypotheses":"(i : int64)","proofString":"f_equal.\nf_equal.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(i : int64) : Int64.unsigned i =\nInt64.unsigned (Int64.ofwords (Int64.hiword i) (Int64.loword i)).","conclusion":"Int64.unsigned i =\nInt64.unsigned (Int64.ofwords (Int64.hiword i) (Int64.loword i))","hypotheses":"(i : int64)","proofString":"f_equal.\nrewrite Int64.ofwords_recompose.\nauto."},{"statement":"(i : int64) : i = Int64.ofwords (Int64.hiword i) (Int64.loword i).","conclusion":"i = Int64.ofwords (Int64.hiword i) (Int64.loword i)","hypotheses":"(i : int64)","proofString":"rewrite Int64.ofwords_recompose.\nauto."},{"statement":"(i : int64) : i = i.","conclusion":"i = i","hypotheses":"(i : int64)","proofString":"auto."},{"statement":"(i : int64) : bytes_of_int (4 + 4)\n  (Int64.unsigned (Int64.ofwords (Int64.hiword i) (Int64.loword i))) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i)).","conclusion":"bytes_of_int (4 + 4)\n  (Int64.unsigned (Int64.ofwords (Int64.hiword i) (Int64.loword i))) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i))","hypotheses":"(i : int64)","proofString":"rewrite Int64.ofwords_add'.\nchange 32 with (Z.of_nat 4 * 8).\nrewrite Z.add_comm.\napply bytes_of_int_append.\napply Int.unsigned_range."},{"statement":"(i : int64) : bytes_of_int (4 + 4)\n  (Int.unsigned (Int64.hiword i) * two_p 32 + Int.unsigned (Int64.loword i)) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i)).","conclusion":"bytes_of_int (4 + 4)\n  (Int.unsigned (Int64.hiword i) * two_p 32 + Int.unsigned (Int64.loword i)) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i))","hypotheses":"(i : int64)","proofString":"change 32 with (Z.of_nat 4 * 8).\nrewrite Z.add_comm.\napply bytes_of_int_append.\napply Int.unsigned_range."},{"statement":"(i : int64) : bytes_of_int (4 + 4)\n  (Int.unsigned (Int64.hiword i) * two_p (Z.of_nat 4 * 8) +\n   Int.unsigned (Int64.loword i)) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i)).","conclusion":"bytes_of_int (4 + 4)\n  (Int.unsigned (Int64.hiword i) * two_p (Z.of_nat 4 * 8) +\n   Int.unsigned (Int64.loword i)) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i))","hypotheses":"(i : int64)","proofString":"rewrite Z.add_comm.\napply bytes_of_int_append.\napply Int.unsigned_range."},{"statement":"(i : int64) : bytes_of_int (4 + 4)\n  (Int.unsigned (Int64.loword i) +\n   Int.unsigned (Int64.hiword i) * two_p (Z.of_nat 4 * 8)) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i)).","conclusion":"bytes_of_int (4 + 4)\n  (Int.unsigned (Int64.loword i) +\n   Int.unsigned (Int64.hiword i) * two_p (Z.of_nat 4 * 8)) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i))","hypotheses":"(i : int64)","proofString":"apply bytes_of_int_append.\napply Int.unsigned_range."},{"statement":"(i : int64) : 0 <= Int.unsigned (Int64.loword i) < two_p (Z.of_nat 4 * 8).","conclusion":"0 <= Int.unsigned (Int64.loword i) < two_p (Z.of_nat 4 * 8)","hypotheses":"(i : int64)","proofString":"apply Int.unsigned_range."},{"statement":"(v : val) (H : Archi.ptr64 = false) : encode_val Mint64 v =\nencode_val Mint32 (if Archi.big_endian then Val.hiword v else Val.loword v) ++\nencode_val Mint32 (if Archi.big_endian then Val.loword v else Val.hiword v).","conclusion":"encode_val Mint64 v =\nencode_val Mint32 (if Archi.big_endian then Val.hiword v else Val.loword v) ++\nencode_val Mint32 (if Archi.big_endian then Val.loword v else Val.hiword v)","hypotheses":"(v : val) (H : Archi.ptr64 = false)","proofString":"unfold encode_val.\nrewrite H.\ndestruct v; destruct Archi.big_endian eqn:BI; try reflexivity;  unfold Val.loword, Val.hiword, encode_val.\nunfold inj_bytes.\nrewrite <- map_app.\nf_equal.\nunfold encode_int, rev_if_be.\nrewrite BI.\nrewrite <- rev_app_distr.\nf_equal.\napply bytes_of_int64.\nunfold inj_bytes.\nrewrite <- map_app.\nf_equal.\nunfold encode_int, rev_if_be.\nrewrite BI.\napply bytes_of_int64."},{"statement":"(v : val) (H : Archi.ptr64 = false) : match v with\n| Vlong n => inj_bytes (encode_int 8 (Int64.unsigned n))\n| Vptr _ _ => if Archi.ptr64 then inj_value Q64 v else repeat Undef 8\n| _ => repeat Undef (size_chunk_nat Mint64)\nend =\nmatch (if Archi.big_endian then Val.hiword v else Val.loword v) with\n| Vint n => inj_bytes (encode_int 4 (Int.unsigned n))\n| Vptr _ _ =>\n    if Archi.ptr64\n    then repeat Undef 4\n    else\n     inj_value Q32 (if Archi.big_endian then Val.hiword v else Val.loword v)\n| _ => repeat Undef (size_chunk_nat Mint32)\nend ++\nmatch (if Archi.big_endian then Val.loword v else Val.hiword v) with\n| Vint n => inj_bytes (encode_int 4 (Int.unsigned n))\n| Vptr _ _ =>\n    if Archi.ptr64\n    then repeat Undef 4\n    else\n     inj_value Q32 (if Archi.big_endian then Val.loword v else Val.hiword v)\n| _ => repeat Undef (size_chunk_nat Mint32)\nend.","conclusion":"match v with\n| Vlong n => inj_bytes (encode_int 8 (Int64.unsigned n))\n| Vptr _ _ => if Archi.ptr64 then inj_value Q64 v else repeat Undef 8\n| _ => repeat Undef (size_chunk_nat Mint64)\nend =\nmatch (if Archi.big_endian then Val.hiword v else Val.loword v) with\n| Vint n => inj_bytes (encode_int 4 (Int.unsigned n))\n| Vptr _ _ =>\n    if Archi.ptr64\n    then repeat Undef 4\n    else\n     inj_value Q32 (if Archi.big_endian then Val.hiword v else Val.loword v)\n| _ => repeat Undef (size_chunk_nat Mint32)\nend ++\nmatch (if Archi.big_endian then Val.loword v else Val.hiword v) with\n| Vint n => inj_bytes (encode_int 4 (Int.unsigned n))\n| Vptr _ _ =>\n    if Archi.ptr64\n    then repeat Undef 4\n    else\n     inj_value Q32 (if Archi.big_endian then Val.loword v else Val.hiword v)\n| _ => repeat Undef (size_chunk_nat Mint32)\nend","hypotheses":"(v : val) (H : Archi.ptr64 = false)","proofString":"rewrite H.\ndestruct v; destruct Archi.big_endian eqn:BI; try reflexivity;  unfold Val.loword, Val.hiword, encode_val.\nunfold inj_bytes.\nrewrite <- map_app.\nf_equal.\nunfold encode_int, rev_if_be.\nrewrite BI.\nrewrite <- rev_app_distr.\nf_equal.\napply bytes_of_int64.\nunfold inj_bytes.\nrewrite <- map_app.\nf_equal.\nunfold encode_int, rev_if_be.\nrewrite BI.\napply bytes_of_int64."},{"statement":"(v : val) (H : Archi.ptr64 = false) : match v with\n| Vlong n => inj_bytes (encode_int 8 (Int64.unsigned n))\n| Vptr _ _ => repeat Undef 8\n| _ => repeat Undef (size_chunk_nat Mint64)\nend =\nmatch (if Archi.big_endian then Val.hiword v else Val.loword v) with\n| Vint n => inj_bytes (encode_int 4 (Int.unsigned n))\n| Vptr _ _ =>\n    inj_value Q32 (if Archi.big_endian then Val.hiword v else Val.loword v)\n| _ => repeat Undef (size_chunk_nat Mint32)\nend ++\nmatch (if Archi.big_endian then Val.loword v else Val.hiword v) with\n| Vint n => inj_bytes (encode_int 4 (Int.unsigned n))\n| Vptr _ _ =>\n    inj_value Q32 (if Archi.big_endian then Val.loword v else Val.hiword v)\n| _ => repeat Undef (size_chunk_nat Mint32)\nend.","conclusion":"match v with\n| Vlong n => inj_bytes (encode_int 8 (Int64.unsigned n))\n| Vptr _ _ => repeat Undef 8\n| _ => repeat Undef (size_chunk_nat Mint64)\nend =\nmatch (if Archi.big_endian then Val.hiword v else Val.loword v) with\n| Vint n => inj_bytes (encode_int 4 (Int.unsigned n))\n| Vptr _ _ =>\n    inj_value Q32 (if Archi.big_endian then Val.hiword v else Val.loword v)\n| _ => repeat Undef (size_chunk_nat Mint32)\nend ++\nmatch (if Archi.big_endian then Val.loword v else Val.hiword v) with\n| Vint n => inj_bytes (encode_int 4 (Int.unsigned n))\n| Vptr _ _ =>\n    inj_value Q32 (if Archi.big_endian then Val.loword v else Val.hiword v)\n| _ => repeat Undef (size_chunk_nat Mint32)\nend","hypotheses":"(v : val) (H : Archi.ptr64 = false)","proofString":"destruct v; destruct Archi.big_endian eqn:BI; try reflexivity;  unfold Val.loword, Val.hiword, encode_val.\nunfold inj_bytes.\nrewrite <- map_app.\nf_equal.\nunfold encode_int, rev_if_be.\nrewrite BI.\nrewrite <- rev_app_distr.\nf_equal.\napply bytes_of_int64.\nunfold inj_bytes.\nrewrite <- map_app.\nf_equal.\nunfold encode_int, rev_if_be.\nrewrite BI.\napply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true) : inj_bytes (encode_int 8 (Int64.unsigned i)) =\ninj_bytes (encode_int 4 (Int.unsigned (Int64.hiword i))) ++\ninj_bytes (encode_int 4 (Int.unsigned (Int64.loword i))).","conclusion":"inj_bytes (encode_int 8 (Int64.unsigned i)) =\ninj_bytes (encode_int 4 (Int.unsigned (Int64.hiword i))) ++\ninj_bytes (encode_int 4 (Int.unsigned (Int64.loword i)))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true)","proofString":"unfold inj_bytes.\nrewrite <- map_app.\nf_equal.\nunfold encode_int, rev_if_be.\nrewrite BI.\nrewrite <- rev_app_distr.\nf_equal.\napply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true) : map Byte (encode_int 8 (Int64.unsigned i)) =\nmap Byte (encode_int 4 (Int.unsigned (Int64.hiword i))) ++\nmap Byte (encode_int 4 (Int.unsigned (Int64.loword i))).","conclusion":"map Byte (encode_int 8 (Int64.unsigned i)) =\nmap Byte (encode_int 4 (Int.unsigned (Int64.hiword i))) ++\nmap Byte (encode_int 4 (Int.unsigned (Int64.loword i)))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true)","proofString":"rewrite <- map_app.\nf_equal.\nunfold encode_int, rev_if_be.\nrewrite BI.\nrewrite <- rev_app_distr.\nf_equal.\napply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true) : map Byte (encode_int 8 (Int64.unsigned i)) =\nmap Byte\n  (encode_int 4 (Int.unsigned (Int64.hiword i)) ++\n   encode_int 4 (Int.unsigned (Int64.loword i))).","conclusion":"map Byte (encode_int 8 (Int64.unsigned i)) =\nmap Byte\n  (encode_int 4 (Int.unsigned (Int64.hiword i)) ++\n   encode_int 4 (Int.unsigned (Int64.loword i)))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true)","proofString":"f_equal.\nunfold encode_int, rev_if_be.\nrewrite BI.\nrewrite <- rev_app_distr.\nf_equal.\napply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true) : encode_int 8 (Int64.unsigned i) =\nencode_int 4 (Int.unsigned (Int64.hiword i)) ++\nencode_int 4 (Int.unsigned (Int64.loword i)).","conclusion":"encode_int 8 (Int64.unsigned i) =\nencode_int 4 (Int.unsigned (Int64.hiword i)) ++\nencode_int 4 (Int.unsigned (Int64.loword i))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true)","proofString":"unfold encode_int, rev_if_be.\nrewrite BI.\nrewrite <- rev_app_distr.\nf_equal.\napply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true) : (if Archi.big_endian\n then rev (bytes_of_int 8 (Int64.unsigned i))\n else bytes_of_int 8 (Int64.unsigned i)) =\n(if Archi.big_endian\n then rev (bytes_of_int 4 (Int.unsigned (Int64.hiword i)))\n else bytes_of_int 4 (Int.unsigned (Int64.hiword i))) ++\n(if Archi.big_endian\n then rev (bytes_of_int 4 (Int.unsigned (Int64.loword i)))\n else bytes_of_int 4 (Int.unsigned (Int64.loword i))).","conclusion":"(if Archi.big_endian\n then rev (bytes_of_int 8 (Int64.unsigned i))\n else bytes_of_int 8 (Int64.unsigned i)) =\n(if Archi.big_endian\n then rev (bytes_of_int 4 (Int.unsigned (Int64.hiword i)))\n else bytes_of_int 4 (Int.unsigned (Int64.hiword i))) ++\n(if Archi.big_endian\n then rev (bytes_of_int 4 (Int.unsigned (Int64.loword i)))\n else bytes_of_int 4 (Int.unsigned (Int64.loword i)))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true)","proofString":"rewrite BI.\nrewrite <- rev_app_distr.\nf_equal.\napply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true) : rev (bytes_of_int 8 (Int64.unsigned i)) =\nrev (bytes_of_int 4 (Int.unsigned (Int64.hiword i))) ++\nrev (bytes_of_int 4 (Int.unsigned (Int64.loword i))).","conclusion":"rev (bytes_of_int 8 (Int64.unsigned i)) =\nrev (bytes_of_int 4 (Int.unsigned (Int64.hiword i))) ++\nrev (bytes_of_int 4 (Int.unsigned (Int64.loword i)))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true)","proofString":"rewrite <- rev_app_distr.\nf_equal.\napply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true) : rev (bytes_of_int 8 (Int64.unsigned i)) =\nrev\n  (bytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\n   bytes_of_int 4 (Int.unsigned (Int64.hiword i))).","conclusion":"rev (bytes_of_int 8 (Int64.unsigned i)) =\nrev\n  (bytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\n   bytes_of_int 4 (Int.unsigned (Int64.hiword i)))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true)","proofString":"f_equal.\napply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true) : bytes_of_int 8 (Int64.unsigned i) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i)).","conclusion":"bytes_of_int 8 (Int64.unsigned i) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = true)","proofString":"apply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = false) : inj_bytes (encode_int 8 (Int64.unsigned i)) =\ninj_bytes (encode_int 4 (Int.unsigned (Int64.loword i))) ++\ninj_bytes (encode_int 4 (Int.unsigned (Int64.hiword i))).","conclusion":"inj_bytes (encode_int 8 (Int64.unsigned i)) =\ninj_bytes (encode_int 4 (Int.unsigned (Int64.loword i))) ++\ninj_bytes (encode_int 4 (Int.unsigned (Int64.hiword i)))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = false)","proofString":"unfold inj_bytes.\nrewrite <- map_app.\nf_equal.\nunfold encode_int, rev_if_be.\nrewrite BI.\napply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = false) : map Byte (encode_int 8 (Int64.unsigned i)) =\nmap Byte (encode_int 4 (Int.unsigned (Int64.loword i))) ++\nmap Byte (encode_int 4 (Int.unsigned (Int64.hiword i))).","conclusion":"map Byte (encode_int 8 (Int64.unsigned i)) =\nmap Byte (encode_int 4 (Int.unsigned (Int64.loword i))) ++\nmap Byte (encode_int 4 (Int.unsigned (Int64.hiword i)))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = false)","proofString":"rewrite <- map_app.\nf_equal.\nunfold encode_int, rev_if_be.\nrewrite BI.\napply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = false) : map Byte (encode_int 8 (Int64.unsigned i)) =\nmap Byte\n  (encode_int 4 (Int.unsigned (Int64.loword i)) ++\n   encode_int 4 (Int.unsigned (Int64.hiword i))).","conclusion":"map Byte (encode_int 8 (Int64.unsigned i)) =\nmap Byte\n  (encode_int 4 (Int.unsigned (Int64.loword i)) ++\n   encode_int 4 (Int.unsigned (Int64.hiword i)))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = false)","proofString":"f_equal.\nunfold encode_int, rev_if_be.\nrewrite BI.\napply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = false) : encode_int 8 (Int64.unsigned i) =\nencode_int 4 (Int.unsigned (Int64.loword i)) ++\nencode_int 4 (Int.unsigned (Int64.hiword i)).","conclusion":"encode_int 8 (Int64.unsigned i) =\nencode_int 4 (Int.unsigned (Int64.loword i)) ++\nencode_int 4 (Int.unsigned (Int64.hiword i))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = false)","proofString":"unfold encode_int, rev_if_be.\nrewrite BI.\napply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = false) : (if Archi.big_endian\n then rev (bytes_of_int 8 (Int64.unsigned i))\n else bytes_of_int 8 (Int64.unsigned i)) =\n(if Archi.big_endian\n then rev (bytes_of_int 4 (Int.unsigned (Int64.loword i)))\n else bytes_of_int 4 (Int.unsigned (Int64.loword i))) ++\n(if Archi.big_endian\n then rev (bytes_of_int 4 (Int.unsigned (Int64.hiword i)))\n else bytes_of_int 4 (Int.unsigned (Int64.hiword i))).","conclusion":"(if Archi.big_endian\n then rev (bytes_of_int 8 (Int64.unsigned i))\n else bytes_of_int 8 (Int64.unsigned i)) =\n(if Archi.big_endian\n then rev (bytes_of_int 4 (Int.unsigned (Int64.loword i)))\n else bytes_of_int 4 (Int.unsigned (Int64.loword i))) ++\n(if Archi.big_endian\n then rev (bytes_of_int 4 (Int.unsigned (Int64.hiword i)))\n else bytes_of_int 4 (Int.unsigned (Int64.hiword i)))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = false)","proofString":"rewrite BI.\napply bytes_of_int64."},{"statement":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = false) : bytes_of_int 8 (Int64.unsigned i) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i)).","conclusion":"bytes_of_int 8 (Int64.unsigned i) =\nbytes_of_int 4 (Int.unsigned (Int64.loword i)) ++\nbytes_of_int 4 (Int.unsigned (Int64.hiword i))","hypotheses":"(i : int64) (H : Archi.ptr64 = false) (BI : Archi.big_endian = false)","proofString":"apply bytes_of_int64."}]}