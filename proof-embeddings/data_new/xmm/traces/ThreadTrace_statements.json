{"filePath":"/Users/Andrei.Kozyrev/MCS_Projects/coqpilotOther/big-rocq/dataset/xmm/src/traces/ThreadTrace.v","fileSamples":[{"statement":"(n : nat) (t : thread_id) : ThreadEvent t ↑₁ seq_set (1 + n)\n≡₁ ThreadEvent t ↑₁ seq_set n ∪₁ eq (ThreadEvent t n).","conclusion":"ThreadEvent t ↑₁ seq_set (1 + n)\n≡₁ ThreadEvent t ↑₁ seq_set n ∪₁ eq (ThreadEvent t n)","hypotheses":"(n : nat) (t : thread_id)","proofString":"rewrite seq_set_S, set_collect_union.\nbasic_solver."},{"statement":"(n : nat) (t : thread_id) : ThreadEvent t ↑₁ seq_set n ∪₁ ThreadEvent t ↑₁ eq n\n≡₁ ThreadEvent t ↑₁ seq_set n ∪₁ eq (ThreadEvent t n).","conclusion":"ThreadEvent t ↑₁ seq_set n ∪₁ ThreadEvent t ↑₁ eq n\n≡₁ ThreadEvent t ↑₁ seq_set n ∪₁ eq (ThreadEvent t n)","hypotheses":"(n : nat) (t : thread_id)","proofString":"basic_solver."},{"statement":"(t : thread_id) : set_size (thread_seq_set t 0) = NOnum 0.","conclusion":"set_size (thread_seq_set t 0) = NOnum 0","hypotheses":"(t : thread_id)","proofString":"apply set_size_empty.\nunfold thread_seq_set.\nrewrite seq_set_0.\nbasic_solver."},{"statement":"(t : thread_id) : thread_seq_set t 0 ≡₁ ∅.","conclusion":"thread_seq_set t 0 ≡₁ ∅","hypotheses":"(t : thread_id)","proofString":"unfold thread_seq_set.\nrewrite seq_set_0.\nbasic_solver."},{"statement":"(t : thread_id) : ThreadEvent t ↑₁ seq_set 0 ≡₁ ∅.","conclusion":"ThreadEvent t ↑₁ seq_set 0 ≡₁ ∅","hypotheses":"(t : thread_id)","proofString":"rewrite seq_set_0.\nbasic_solver."},{"statement":"(t : thread_id) : ThreadEvent t ↑₁ ∅ ≡₁ ∅.","conclusion":"ThreadEvent t ↑₁ ∅ ≡₁ ∅","hypotheses":"(t : thread_id)","proofString":"basic_solver."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) : set_size (thread_seq_set t (S n)) = NOnum (S n).","conclusion":"set_size (thread_seq_set t (S n)) = NOnum (S n)","hypotheses":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n)","proofString":"rewrite thread_set_S.\nerewrite set_size_union_disjoint with (a:=n) (b:=1);    auto using set_size_single.\nf_equal.\nlia.\nunfolder.\nins.\ndesf.\nlia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) : set_size (thread_seq_set t n ∪₁ eq (ThreadEvent t n)) = NOnum (S n).","conclusion":"set_size (thread_seq_set t n ∪₁ eq (ThreadEvent t n)) = NOnum (S n)","hypotheses":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n)","proofString":"erewrite set_size_union_disjoint with (a:=n) (b:=1);    auto using set_size_single.\nf_equal.\nlia.\nunfolder.\nins.\ndesf.\nlia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) : NOnum (n + 1) = NOnum (S n).","conclusion":"NOnum (n + 1) = NOnum (S n)","hypotheses":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n)","proofString":"f_equal.\nlia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) : n + 1 = S n.","conclusion":"n + 1 = S n","hypotheses":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n)","proofString":"lia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) : set_disjoint (thread_seq_set t n) (eq (ThreadEvent t n)).","conclusion":"set_disjoint (thread_seq_set t n) (eq (ThreadEvent t n))","hypotheses":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n)","proofString":"unfolder.\nins.\ndesf.\nlia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) : forall x : actid,\n(exists y : nat, y < n /\\ ThreadEvent t y = x) ->\nThreadEvent t n = x -> False.","conclusion":"forall x : actid,\n(exists y : nat, y < n /\\ ThreadEvent t y = x) ->\nThreadEvent t n = x -> False","hypotheses":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n)","proofString":"ins.\ndesf.\nlia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) (x : actid) (IN : exists y : nat, y < n /\\ ThreadEvent t y = x) (IN' : ThreadEvent t n = x) : False.","conclusion":"False","hypotheses":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) (x : actid) (IN : exists y : nat, y < n /\\ ThreadEvent t y = x) (IN' : ThreadEvent t n = x)","proofString":"desf.\nlia."},{"statement":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) (IN : n < n) : False.","conclusion":"False","hypotheses":"(t : thread_id) (n : nat) (IHn : set_size (thread_seq_set t n) = NOnum n) (IN : n < n)","proofString":"lia."},{"statement":"(t : thread_id) (n n' : nat) (EQ : NOnum n' = NOnum n) : thread_seq_set t n' ≡₁ thread_seq_set t n.","conclusion":"thread_seq_set t n' ≡₁ thread_seq_set t n","hypotheses":"(t : thread_id) (n n' : nat) (EQ : NOnum n' = NOnum n)","proofString":"desf."},{"statement":"(t : thread_id) (n n' : nat) (LE : n' <= n) : ThreadEvent t ↑₁ seq_set n' ⊆₁ ThreadEvent t ↑₁ seq_set n.","conclusion":"ThreadEvent t ↑₁ seq_set n' ⊆₁ ThreadEvent t ↑₁ seq_set n","hypotheses":"(t : thread_id) (n n' : nat) (LE : n' <= n)","proofString":"now apply set_subset_collect, seq_set_sub."},{"statement":"(t : thread_id) (k n : nat) (H : k < n) : exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t k.","conclusion":"exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t k","hypotheses":"(t : thread_id) (k n : nat) (H : k < n)","proofString":"eauto."},{"statement":"(t : thread_id) (k n : nat) : ~ (exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t k) -> n <= k.","conclusion":"~ (exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t k) -> n <= k","hypotheses":"(t : thread_id) (k n : nat)","proofString":"destruct (classic (k < n)) as [LT|LT]; try lia.\nins; exfalso; eauto."},{"statement":"(t : thread_id) (k n : nat) (LT : k < n) : ~ (exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t k) -> n <= k.","conclusion":"~ (exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t k) -> n <= k","hypotheses":"(t : thread_id) (k n : nat) (LT : k < n)","proofString":"ins; exfalso; eauto."},{"statement":"(t : thread_id) (k n : nat) : n <= k -> ~ (exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t k).","conclusion":"n <= k -> ~ (exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t k)","hypotheses":"(t : thread_id) (k n : nat)","proofString":"intros LE F; desf.\nlia."},{"statement":"(t : thread_id) (k n : nat) (LE : n <= k) (F : k < n) : False.","conclusion":"False","hypotheses":"(t : thread_id) (k n : nat) (LE : n <= k) (F : k < n)","proofString":"lia."},{"statement":"(t : thread_id) (n n' : nat) : thread_seq_set t n' \\₁ thread_seq_set t n\n≡₁ ThreadEvent t ↑₁ (seq_set n' \\₁ seq_set n).","conclusion":"thread_seq_set t n' \\₁ thread_seq_set t n\n≡₁ ThreadEvent t ↑₁ (seq_set n' \\₁ seq_set n)","hypotheses":"(t : thread_id) (n n' : nat)","proofString":"unfolder; split; ins; desf.\nexists y; split; try easy.\nsplit; try easy.\ndestruct (classic (y < n)) as [LT|LT]; eauto.\nsplit; eauto.\napply all_not_not_ex.\nintros n'' F; desf."},{"statement":"(t : thread_id) (n n' y : nat) (H : y < n') (H0 : ~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y)) : exists y0 : nat, (y0 < n' /\\ ~ y0 < n) /\\ ThreadEvent t y0 = ThreadEvent t y.","conclusion":"exists y0 : nat, (y0 < n' /\\ ~ y0 < n) /\\ ThreadEvent t y0 = ThreadEvent t y","hypotheses":"(t : thread_id) (n n' y : nat) (H : y < n') (H0 : ~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y))","proofString":"exists y; split; try easy.\nsplit; try easy.\ndestruct (classic (y < n)) as [LT|LT]; eauto."},{"statement":"(t : thread_id) (n n' y : nat) (H : y < n') (H0 : ~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y)) : y < n' /\\ ~ y < n.","conclusion":"y < n' /\\ ~ y < n","hypotheses":"(t : thread_id) (n n' y : nat) (H : y < n') (H0 : ~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y))","proofString":"split; try easy.\ndestruct (classic (y < n)) as [LT|LT]; eauto."},{"statement":"(t : thread_id) (n n' y : nat) (H : y < n') (H0 : ~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y)) : ~ y < n.","conclusion":"~ y < n","hypotheses":"(t : thread_id) (n n' y : nat) (H : y < n') (H0 : ~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y))","proofString":"destruct (classic (y < n)) as [LT|LT]; eauto."},{"statement":"(t : thread_id) (n n' y : nat) (H : y < n') (H1 : ~ y < n) : (exists y0 : nat, y0 < n' /\\ ThreadEvent t y0 = ThreadEvent t y) /\\\n~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y).","conclusion":"(exists y0 : nat, y0 < n' /\\ ThreadEvent t y0 = ThreadEvent t y) /\\\n~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y)","hypotheses":"(t : thread_id) (n n' y : nat) (H : y < n') (H1 : ~ y < n)","proofString":"split; eauto.\napply all_not_not_ex.\nintros n'' F; desf."},{"statement":"(t : thread_id) (n n' y : nat) (H : y < n') (H1 : ~ y < n) : ~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y).","conclusion":"~ (exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent t y)","hypotheses":"(t : thread_id) (n n' y : nat) (H : y < n') (H1 : ~ y < n)","proofString":"apply all_not_not_ex.\nintros n'' F; desf."},{"statement":"(t : thread_id) (n n' y : nat) (H : y < n') (H1 : ~ y < n) : forall n0 : nat, ~ (n0 < n /\\ ThreadEvent t n0 = ThreadEvent t y).","conclusion":"forall n0 : nat, ~ (n0 < n /\\ ThreadEvent t n0 = ThreadEvent t y)","hypotheses":"(t : thread_id) (n n' y : nat) (H : y < n') (H1 : ~ y < n)","proofString":"intros n'' F; desf."},{"statement":"(t : thread_id) (n : nat) : forall b : actid,\next_sb (ThreadEvent t (n - 1)) b /\\\n(exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t (n - 1)) /\\\n(exists y : nat, y < n /\\ ThreadEvent t y = b) -> False.","conclusion":"forall b : actid,\next_sb (ThreadEvent t (n - 1)) b /\\\n(exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t (n - 1)) /\\\n(exists y : nat, y < n /\\ ThreadEvent t y = b) -> False","hypotheses":"(t : thread_id) (n : nat)","proofString":"ins.\ndesf.\nlia."},{"statement":"(t : thread_id) (n : nat) (b : actid) (REL : match b with\n| InitEvent _ => False\n| ThreadEvent t' i' => t = t' /\\ n - 1 < i'\nend /\\\n(exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t (n - 1)) /\\\n(exists y : nat, y < n /\\ ThreadEvent t y = b)) : False.","conclusion":"False","hypotheses":"(t : thread_id) (n : nat) (b : actid) (REL : match b with\n| InitEvent _ => False\n| ThreadEvent t' i' => t = t' /\\ n - 1 < i'\nend /\\\n(exists y : nat, y < n /\\ ThreadEvent t y = ThreadEvent t (n - 1)) /\\\n(exists y : nat, y < n /\\ ThreadEvent t y = b))","proofString":"desf.\nlia."},{"statement":"(t : thread_id) (n y : nat) (REL : t = t /\\ n - 1 < y) (REL0 : n - 1 < n) (REL1 : y < n) : False.","conclusion":"False","hypotheses":"(t : thread_id) (n y : nat) (REL : t = t /\\ n - 1 < y) (REL0 : n - 1 < n) (REL1 : y < n)","proofString":"lia."},{"statement":"(t : thread_id) (n : nat) (e1 e2 : actid) (NINIT : ~ is_init e1) (HIN : exists y : nat, y < n /\\ ThreadEvent t y = e2) (SB : match e1 with\n| InitEvent _ =>\n    match e2 with\n    | InitEvent _ => False\n    | ThreadEvent _ _ => True\n    end\n| ThreadEvent t0 i =>\n    match e2 with\n    | InitEvent _ => False\n    | ThreadEvent t' i' => t0 = t' /\\ i < i'\n    end\nend) : exists y : nat, y < n /\\ ThreadEvent t y = e1.","conclusion":"exists y : nat, y < n /\\ ThreadEvent t y = e1","hypotheses":"(t : thread_id) (n : nat) (e1 e2 : actid) (NINIT : ~ is_init e1) (HIN : exists y : nat, y < n /\\ ThreadEvent t y = e2) (SB : match e1 with\n| InitEvent _ =>\n    match e2 with\n    | InitEvent _ => False\n    | ThreadEvent _ _ => True\n    end\n| ThreadEvent t0 i =>\n    match e2 with\n    | InitEvent _ => False\n    | ThreadEvent t' i' => t0 = t' /\\ i < i'\n    end\nend)","proofString":"desf.\nexists index; split; [lia| desf]."},{"statement":"(t : thread_id) (n : nat) (thread : thread_id) (index : nat) (NINIT : ~ is_init (ThreadEvent thread index)) (y : nat) (HIN : y < n) (SB : thread = t /\\ index < y) : exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent thread index.","conclusion":"exists y0 : nat, y0 < n /\\ ThreadEvent t y0 = ThreadEvent thread index","hypotheses":"(t : thread_id) (n : nat) (thread : thread_id) (index : nat) (NINIT : ~ is_init (ThreadEvent thread index)) (y : nat) (HIN : y < n) (SB : thread = t /\\ index < y)","proofString":"exists index; split; [lia| desf]."},{"statement":"(thr : thread_id) (K : nat) : (exists x : nat, ThreadEvent thr x = ThreadEvent thr K /\\ In x (List.seq 0 N)) <->\nIn K (List.seq 0 N).","conclusion":"(exists x : nat, ThreadEvent thr x = ThreadEvent thr K /\\ In x (List.seq 0 N)) <->\nIn K (List.seq 0 N)","hypotheses":"(thr : thread_id) (K : nat)","proofString":"split; ins; desf; eauto."},{"statement":"trace_map (ThreadEvent t)\n  match set_size Et with\n  | NOinfinity => trace_inf (fun x : nat => x)\n  | NOnum n => trace_fin (List.seq 0 n)\n  end = trace_map (ThreadEvent t) (trace_fin (List.seq 0 N)).","conclusion":"trace_map (ThreadEvent t)\n  match set_size Et with\n  | NOinfinity => trace_inf (fun x : nat => x)\n  | NOnum n => trace_fin (List.seq 0 n)\n  end = trace_map (ThreadEvent t) (trace_fin (List.seq 0 N))","hypotheses":"","proofString":"now rewrite THREAD_EVENTS, thread_seq_set_size."},{"statement":"(K : nat) : In (ThreadEvent t K) (map (ThreadEvent t) (List.seq 0 N)) <-> K < N.","conclusion":"In (ThreadEvent t K) (map (ThreadEvent t) (List.seq 0 N)) <-> K < N","hypotheses":"(K : nat)","proofString":"apply thread_seq_helper."},{"statement":"trace_length (trace_map (ThreadEvent t) (trace_fin (List.seq 0 N))) = NOnum N.","conclusion":"trace_length (trace_map (ThreadEvent t) (trace_fin (List.seq 0 N))) = NOnum N","hypotheses":"","proofString":"simpl.\nnow rewrite map_length, seq_length."},{"statement":"NOnum (length (map (ThreadEvent t) (List.seq 0 N))) = NOnum N.","conclusion":"NOnum (length (map (ThreadEvent t) (List.seq 0 N))) = NOnum N","hypotheses":"","proofString":"now rewrite map_length, seq_length."},{"statement":"(n : nat) (d : actid) (LT : n < N) : nth n (map (ThreadEvent t) (List.seq 0 N)) (ThreadEvent t 0) =\nThreadEvent t n.","conclusion":"nth n (map (ThreadEvent t) (List.seq 0 N)) (ThreadEvent t 0) =\nThreadEvent t n","hypotheses":"(n : nat) (d : actid) (LT : n < N)","proofString":"now rewrite map_nth, seq_nth."},{"statement":"thread_seq_set t N ≡₁ ThreadEvent t ↑₁ trace_elems (trace_fin (List.seq 0 N)).","conclusion":"thread_seq_set t N ≡₁ ThreadEvent t ↑₁ trace_elems (trace_fin (List.seq 0 N))","hypotheses":"","proofString":"unfold thread_seq_set.\nins.\napply set_collect_more; auto.\nunfolder; splits; intros x; by rewrite in_seq0_iff."},{"statement":"ThreadEvent t ↑₁ seq_set N\n≡₁ ThreadEvent t ↑₁ trace_elems (trace_fin (List.seq 0 N)).","conclusion":"ThreadEvent t ↑₁ seq_set N\n≡₁ ThreadEvent t ↑₁ trace_elems (trace_fin (List.seq 0 N))","hypotheses":"","proofString":"ins.\napply set_collect_more; auto.\nunfolder; splits; intros x; by rewrite in_seq0_iff."},{"statement":"ThreadEvent t ↑₁ seq_set N\n≡₁ ThreadEvent t ↑₁ (fun a : nat => In a (List.seq 0 N)).","conclusion":"ThreadEvent t ↑₁ seq_set N\n≡₁ ThreadEvent t ↑₁ (fun a : nat => In a (List.seq 0 N))","hypotheses":"","proofString":"apply set_collect_more; auto.\nunfolder; splits; intros x; by rewrite in_seq0_iff."},{"statement":"seq_set N ≡₁ (fun a : nat => In a (List.seq 0 N)).","conclusion":"seq_set N ≡₁ (fun a : nat => In a (List.seq 0 N))","hypotheses":"","proofString":"unfolder; splits; intros x; by rewrite in_seq0_iff."},{"statement":"forall i j : nat,\ni < j ->\nNOmega.lt_nat_l j (trace_length thread_actid_trace) ->\nforall d : actid,\ntrace_nth i thread_actid_trace d <> trace_nth j thread_actid_trace d.","conclusion":"forall i j : nat,\ni < j ->\nNOmega.lt_nat_l j (trace_length thread_actid_trace) ->\nforall d : actid,\ntrace_nth i thread_actid_trace d <> trace_nth j thread_actid_trace d","hypotheses":"","proofString":"rewrite thread_actid_trace_length.\nsimpl.\nintros i j LT SZ d.\nrewrite !thread_actid_trace_nth by lia.\ninjection; lia."},{"statement":"forall i j : nat,\ni < j ->\nNOmega.lt_nat_l j (NOnum N) ->\nforall d : actid,\ntrace_nth i thread_actid_trace d <> trace_nth j thread_actid_trace d.","conclusion":"forall i j : nat,\ni < j ->\nNOmega.lt_nat_l j (NOnum N) ->\nforall d : actid,\ntrace_nth i thread_actid_trace d <> trace_nth j thread_actid_trace d","hypotheses":"","proofString":"simpl.\nintros i j LT SZ d.\nrewrite !thread_actid_trace_nth by lia.\ninjection; lia."},{"statement":"forall i j : nat,\ni < j ->\nj < N ->\nforall d : actid,\ntrace_nth i thread_actid_trace d <> trace_nth j thread_actid_trace d.","conclusion":"forall i j : nat,\ni < j ->\nj < N ->\nforall d : actid,\ntrace_nth i thread_actid_trace d <> trace_nth j thread_actid_trace d","hypotheses":"","proofString":"intros i j LT SZ d.\nrewrite !thread_actid_trace_nth by lia.\ninjection; lia."},{"statement":"(i j : nat) (LT : i < j) (SZ : j < N) (d : actid) : trace_nth i thread_actid_trace d <> trace_nth j thread_actid_trace d.","conclusion":"trace_nth i thread_actid_trace d <> trace_nth j thread_actid_trace d","hypotheses":"(i j : nat) (LT : i < j) (SZ : j < N) (d : actid)","proofString":"rewrite !thread_actid_trace_nth by lia.\ninjection; lia."},{"statement":"(i j : nat) (LT : i < j) (SZ : j < N) (d : actid) : ThreadEvent t i <> ThreadEvent t j.","conclusion":"ThreadEvent t i <> ThreadEvent t j","hypotheses":"(i j : nat) (LT : i < j) (SZ : j < N) (d : actid)","proofString":"injection; lia."},{"statement":"lab ↑₁ Et ≡₁ trace_elems (trace_map lab thread_actid_trace).","conclusion":"lab ↑₁ Et ≡₁ trace_elems (trace_map lab thread_actid_trace)","hypotheses":"","proofString":"now rewrite trace_elems_map, trace_elems_eq_thread_events."},{"statement":"(n : nat) (d : label) (LT : n < N) : trace_nth n (trace_map lab thread_actid_trace) (lab (ThreadEvent t 0)) =\nlab (ThreadEvent t n).","conclusion":"trace_nth n (trace_map lab thread_actid_trace) (lab (ThreadEvent t 0)) =\nlab (ThreadEvent t n)","hypotheses":"(n : nat) (d : label) (LT : n < N)","proofString":"now rewrite trace_nth_map, thread_actid_trace_nth."},{"statement":"(n : nat) (d : label) (LT : n < N) : NOmega.lt_nat_l n (trace_length (trace_map lab thread_actid_trace)).","conclusion":"NOmega.lt_nat_l n (trace_length (trace_map lab thread_actid_trace))","hypotheses":"(n : nat) (d : label) (LT : n < N)","proofString":"rewrite trace_length_map, thread_actid_trace_length; ins."},{"statement":"(G : execution) (e : actid) (d : label) (NINIT : match e with\n| InitEvent _ => tid_init\n| ThreadEvent i _ => i\nend <> tid_init) (CONT : contigious_actids G) (IN : acts_set G e) : trace_nth (index e)\n  (thread_trace G\n     match e with\n     | InitEvent _ => tid_init\n     | ThreadEvent i _ => i\n     end) d = lab G e.","conclusion":"trace_nth (index e)\n  (thread_trace G\n     match e with\n     | InitEvent _ => tid_init\n     | ThreadEvent i _ => i\n     end) d = lab G e","hypotheses":"(G : execution) (e : actid) (d : label) (NINIT : match e with\n| InitEvent _ => tid_init\n| ThreadEvent i _ => i\nend <> tid_init) (CONT : contigious_actids G) (IN : acts_set G e)","proofString":"destruct e as [el | et en]; [congruence |].\nred in CONT.\ndestruct (CONT _ NINIT) as [N EQ].\nrewrite thread_trace_nth with (N := N); eauto.\nassert (IN' : (acts_set G ∩₁ (fun e => et = tid e)) (ThreadEvent et en)).\nbasic_solver.\nins.\nnow apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : contigious_actids G) (IN : acts_set G (ThreadEvent et en)) : trace_nth (index (ThreadEvent et en)) (thread_trace G et) d =\nlab G (ThreadEvent et en).","conclusion":"trace_nth (index (ThreadEvent et en)) (thread_trace G et) d =\nlab G (ThreadEvent et en)","hypotheses":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : contigious_actids G) (IN : acts_set G (ThreadEvent et en))","proofString":"red in CONT.\ndestruct (CONT _ NINIT) as [N EQ].\nrewrite thread_trace_nth with (N := N); eauto.\nassert (IN' : (acts_set G ∩₁ (fun e => et = tid e)) (ThreadEvent et en)).\nbasic_solver.\nins.\nnow apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N) (IN : acts_set G (ThreadEvent et en)) : trace_nth (index (ThreadEvent et en)) (thread_trace G et) d =\nlab G (ThreadEvent et en).","conclusion":"trace_nth (index (ThreadEvent et en)) (thread_trace G et) d =\nlab G (ThreadEvent et en)","hypotheses":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N) (IN : acts_set G (ThreadEvent et en))","proofString":"destruct (CONT _ NINIT) as [N EQ].\nrewrite thread_trace_nth with (N := N); eauto.\nassert (IN' : (acts_set G ∩₁ (fun e => et = tid e)) (ThreadEvent et en)).\nbasic_solver.\nins.\nnow apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) : trace_nth (index (ThreadEvent et en)) (thread_trace G et) d =\nlab G (ThreadEvent et en).","conclusion":"trace_nth (index (ThreadEvent et en)) (thread_trace G et) d =\nlab G (ThreadEvent et en)","hypotheses":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N)","proofString":"rewrite thread_trace_nth with (N := N); eauto.\nassert (IN' : (acts_set G ∩₁ (fun e => et = tid e)) (ThreadEvent et en)).\nbasic_solver.\nins.\nnow apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) : index (ThreadEvent et en) < N.","conclusion":"index (ThreadEvent et en) < N","hypotheses":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N)","proofString":"assert (IN' : (acts_set G ∩₁ (fun e => et = tid e)) (ThreadEvent et en)).\nbasic_solver.\nins.\nnow apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) : (acts_set G ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en).","conclusion":"(acts_set G ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en)","hypotheses":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N)","proofString":"basic_solver."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (IN' : (acts_set G ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en)) : index (ThreadEvent et en) < N.","conclusion":"index (ThreadEvent et en) < N","hypotheses":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (IN' : (acts_set G ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en))","proofString":"ins.\nnow apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (IN' : (acts_set G ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en)) : en < N.","conclusion":"en < N","hypotheses":"(G : execution) (et : thread_id) (en : nat) (d : label) (NINIT : et <> tid_init) (CONT : forall t : BinNums.positive,\nt <> tid_init ->\nexists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) (IN : acts_set G (ThreadEvent et en)) (N : nat) (EQ : acts_set G ∩₁ (fun e : actid => et = tid e) ≡₁ thread_seq_set et N) (IN' : (acts_set G ∩₁ (fun e : actid => et = tid e)) (ThreadEvent et en))","proofString":"now apply EQ, thread_set_iff in IN'."},{"statement":"(G : execution) (N : nat) (t : BinNums.positive) (EQ : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N) : acts_set G ∩₁ (fun e : actid => t = tid e) ⊆₁ acts_set G.","conclusion":"acts_set G ∩₁ (fun e : actid => t = tid e) ⊆₁ acts_set G","hypotheses":"(G : execution) (N : nat) (t : BinNums.positive) (EQ : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N)","proofString":"basic_solver."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e))).","conclusion":"le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e))","proofString":"now apply set_size_mori."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) : trace_prefix (thread_actid_trace G' t) (thread_actid_trace G t).","conclusion":"trace_prefix (thread_actid_trace G' t) (thread_actid_trace G t)","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e))))","proofString":"unfold thread_actid_trace; desf; ins.\nsetoid_rewrite Heq in LE.\nsetoid_rewrite Heq0 in LE.\neasy.\nrewrite nth_indep with (d' := ThreadEvent t 0); auto.\nrewrite map_nth, seq_nth; auto.\nnow autorewrite with calc_length in LLEN.\nsetoid_rewrite Heq in LE.\nsetoid_rewrite Heq0 in LE.\nunfold le_new in LE.\nexists (map (ThreadEvent t) (List.seq n (n0 - n))).\nrewrite <- map_app, <- seq_app.\ndo 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (n : nat) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n) : False.","conclusion":"False","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (n : nat) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n)","proofString":"setoid_rewrite Heq in LE.\nsetoid_rewrite Heq0 in LE.\neasy."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new NOinfinity (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (n : nat) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n) : False.","conclusion":"False","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new NOinfinity (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (n : nat) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n)","proofString":"setoid_rewrite Heq0 in LE.\neasy."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n : nat) (LE : le_new NOinfinity (NOnum n)) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n) : False.","conclusion":"False","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n : nat) (LE : le_new NOinfinity (NOnum n)) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n)","proofString":"easy."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (n : nat) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (i : nat) (LLEN : i < length (map (ThreadEvent t) (List.seq 0 n))) (d : actid) : ThreadEvent t i = nth i (map (ThreadEvent t) (List.seq 0 n)) d.","conclusion":"ThreadEvent t i = nth i (map (ThreadEvent t) (List.seq 0 n)) d","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (n : nat) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (i : nat) (LLEN : i < length (map (ThreadEvent t) (List.seq 0 n))) (d : actid)","proofString":"rewrite nth_indep with (d' := ThreadEvent t 0); auto.\nrewrite map_nth, seq_nth; auto.\nnow autorewrite with calc_length in LLEN."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (n : nat) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (i : nat) (LLEN : i < length (map (ThreadEvent t) (List.seq 0 n))) (d : actid) : ThreadEvent t i =\nnth i (map (ThreadEvent t) (List.seq 0 n)) (ThreadEvent t 0).","conclusion":"ThreadEvent t i =\nnth i (map (ThreadEvent t) (List.seq 0 n)) (ThreadEvent t 0)","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (n : nat) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (i : nat) (LLEN : i < length (map (ThreadEvent t) (List.seq 0 n))) (d : actid)","proofString":"rewrite map_nth, seq_nth; auto.\nnow autorewrite with calc_length in LLEN."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (n : nat) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (i : nat) (LLEN : i < length (map (ThreadEvent t) (List.seq 0 n))) (d : actid) : i < n.","conclusion":"i < n","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (n : nat) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOinfinity) (i : nat) (LLEN : i < length (map (ThreadEvent t) (List.seq 0 n))) (d : actid)","proofString":"now autorewrite with calc_length in LLEN."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (n : nat) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (n0 : nat) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : exists l'' : list actid,\n  map (ThreadEvent t) (List.seq 0 n0) =\n  map (ThreadEvent t) (List.seq 0 n) ++ l''.","conclusion":"exists l'' : list actid,\n  map (ThreadEvent t) (List.seq 0 n0) =\n  map (ThreadEvent t) (List.seq 0 n) ++ l''","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (LE : le_new (set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)))\n  (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (n : nat) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (n0 : nat) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0)","proofString":"setoid_rewrite Heq in LE.\nsetoid_rewrite Heq0 in LE.\nunfold le_new in LE.\nexists (map (ThreadEvent t) (List.seq n (n0 - n))).\nrewrite <- map_app, <- seq_app.\ndo 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n : nat) (LE : le_new (NOnum n) (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (n0 : nat) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : exists l'' : list actid,\n  map (ThreadEvent t) (List.seq 0 n0) =\n  map (ThreadEvent t) (List.seq 0 n) ++ l''.","conclusion":"exists l'' : list actid,\n  map (ThreadEvent t) (List.seq 0 n0) =\n  map (ThreadEvent t) (List.seq 0 n) ++ l''","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n : nat) (LE : le_new (NOnum n) (set_size (acts_set G ∩₁ (fun e : actid => t = tid e)))) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (n0 : nat) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0)","proofString":"setoid_rewrite Heq0 in LE.\nunfold le_new in LE.\nexists (map (ThreadEvent t) (List.seq n (n0 - n))).\nrewrite <- map_app, <- seq_app.\ndo 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : le_new (NOnum n) (NOnum n0)) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : exists l'' : list actid,\n  map (ThreadEvent t) (List.seq 0 n0) =\n  map (ThreadEvent t) (List.seq 0 n) ++ l''.","conclusion":"exists l'' : list actid,\n  map (ThreadEvent t) (List.seq 0 n0) =\n  map (ThreadEvent t) (List.seq 0 n) ++ l''","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : le_new (NOnum n) (NOnum n0)) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0)","proofString":"unfold le_new in LE.\nexists (map (ThreadEvent t) (List.seq n (n0 - n))).\nrewrite <- map_app, <- seq_app.\ndo 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : n <= n0) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : exists l'' : list actid,\n  map (ThreadEvent t) (List.seq 0 n0) =\n  map (ThreadEvent t) (List.seq 0 n) ++ l''.","conclusion":"exists l'' : list actid,\n  map (ThreadEvent t) (List.seq 0 n0) =\n  map (ThreadEvent t) (List.seq 0 n) ++ l''","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : n <= n0) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0)","proofString":"exists (map (ThreadEvent t) (List.seq n (n0 - n))).\nrewrite <- map_app, <- seq_app.\ndo 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : n <= n0) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : map (ThreadEvent t) (List.seq 0 n0) =\nmap (ThreadEvent t) (List.seq 0 n) ++\nmap (ThreadEvent t) (List.seq n (n0 - n)).","conclusion":"map (ThreadEvent t) (List.seq 0 n0) =\nmap (ThreadEvent t) (List.seq 0 n) ++\nmap (ThreadEvent t) (List.seq n (n0 - n))","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : n <= n0) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0)","proofString":"rewrite <- map_app, <- seq_app.\ndo 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : n <= n0) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : map (ThreadEvent t) (List.seq 0 n0) =\nmap (ThreadEvent t) (List.seq 0 (n + (n0 - n))).","conclusion":"map (ThreadEvent t) (List.seq 0 n0) =\nmap (ThreadEvent t) (List.seq 0 (n + (n0 - n)))","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : n <= n0) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0)","proofString":"do 2 f_equal.\nlia."},{"statement":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : n <= n0) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0) : n0 = n + (n0 - n).","conclusion":"n0 = n + (n0 - n)","hypotheses":"(t : BinNums.positive) (G G' : execution) (SUB : acts_set G' ∩₁ (fun e : actid => t = tid e)\n⊆₁ acts_set G ∩₁ (fun e : actid => t = tid e)) (n n0 : nat) (LE : n <= n0) (Heq : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum n) (Heq0 : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum n0)","proofString":"lia."},{"statement":"(N : nat) (t : BinNums.positive) (G : execution) (NOT_INIT : t <> tid_init) (CONT : contigious_actids G) (SZ_EQ : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum N) (CONT_APP : exists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N.","conclusion":"acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N","hypotheses":"(N : nat) (t : BinNums.positive) (G : execution) (NOT_INIT : t <> tid_init) (CONT : contigious_actids G) (SZ_EQ : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum N) (CONT_APP : exists N0 : nat,\n  acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0)","proofString":"desf.\nrewrite CONT_APP in SZ_EQ.\nrewrite CONT_APP, thread_seq_N_eq_set_size; eauto."},{"statement":"(N : nat) (t : BinNums.positive) (G : execution) (NOT_INIT : t <> tid_init) (CONT : contigious_actids G) (SZ_EQ : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum N) (N0 : nat) (CONT_APP : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N.","conclusion":"acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N","hypotheses":"(N : nat) (t : BinNums.positive) (G : execution) (NOT_INIT : t <> tid_init) (CONT : contigious_actids G) (SZ_EQ : set_size (acts_set G ∩₁ (fun e : actid => t = tid e)) = NOnum N) (N0 : nat) (CONT_APP : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0)","proofString":"rewrite CONT_APP in SZ_EQ.\nrewrite CONT_APP, thread_seq_N_eq_set_size; eauto."},{"statement":"(N : nat) (t : BinNums.positive) (G : execution) (NOT_INIT : t <> tid_init) (CONT : contigious_actids G) (N0 : nat) (SZ_EQ : set_size (thread_seq_set t N0) = NOnum N) (CONT_APP : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0) : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N.","conclusion":"acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N","hypotheses":"(N : nat) (t : BinNums.positive) (G : execution) (NOT_INIT : t <> tid_init) (CONT : contigious_actids G) (N0 : nat) (SZ_EQ : set_size (thread_seq_set t N0) = NOnum N) (CONT_APP : acts_set G ∩₁ (fun e : actid => t = tid e) ≡₁ thread_seq_set t N0)","proofString":"rewrite CONT_APP, thread_seq_N_eq_set_size; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : ThreadEvent t idx = ThreadEvent t N.","conclusion":"ThreadEvent t idx = ThreadEvent t N","hypotheses":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx))","proofString":"f_equal; enough (N <= idx < N + 1) by lia.\napply seq_set_diff.\nenough (HIN : (thread_seq_set t (N + 1) \\₁ thread_seq_set t N)          (ThreadEvent t idx)).\nunfolder in HIN; split; desf; eauto.\nsplit; [| intro F; eapply NEW, in_restr_acts, contactids_eq; eauto ].\neapply contactids_eq, in_restr_acts, ADD; eauto; try now right.\nchange (fun e => t = tid e) with (same_tid (ThreadEvent t idx)).\nerewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : N <= idx < N + 1.","conclusion":"N <= idx < N + 1","hypotheses":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx))","proofString":"apply seq_set_diff.\nenough (HIN : (thread_seq_set t (N + 1) \\₁ thread_seq_set t N)          (ThreadEvent t idx)).\nunfolder in HIN; split; desf; eauto.\nsplit; [| intro F; eapply NEW, in_restr_acts, contactids_eq; eauto ].\neapply contactids_eq, in_restr_acts, ADD; eauto; try now right.\nchange (fun e => t = tid e) with (same_tid (ThreadEvent t idx)).\nerewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : (seq_set (N + 1) \\₁ seq_set N) idx.","conclusion":"(seq_set (N + 1) \\₁ seq_set N) idx","hypotheses":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx))","proofString":"enough (HIN : (thread_seq_set t (N + 1) \\₁ thread_seq_set t N)          (ThreadEvent t idx)).\nunfolder in HIN; split; desf; eauto.\nsplit; [| intro F; eapply NEW, in_restr_acts, contactids_eq; eauto ].\neapply contactids_eq, in_restr_acts, ADD; eauto; try now right.\nchange (fun e => t = tid e) with (same_tid (ThreadEvent t idx)).\nerewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) (HIN : (thread_seq_set t (N + 1) \\₁ thread_seq_set t N) (ThreadEvent t idx)) : (seq_set (N + 1) \\₁ seq_set N) idx.","conclusion":"(seq_set (N + 1) \\₁ seq_set N) idx","hypotheses":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) (HIN : (thread_seq_set t (N + 1) \\₁ thread_seq_set t N) (ThreadEvent t idx))","proofString":"unfolder in HIN; split; desf; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : (thread_seq_set t (N + 1) \\₁ thread_seq_set t N) (ThreadEvent t idx).","conclusion":"(thread_seq_set t (N + 1) \\₁ thread_seq_set t N) (ThreadEvent t idx)","hypotheses":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx))","proofString":"split; [| intro F; eapply NEW, in_restr_acts, contactids_eq; eauto ].\neapply contactids_eq, in_restr_acts, ADD; eauto; try now right.\nchange (fun e => t = tid e) with (same_tid (ThreadEvent t idx)).\nerewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : thread_seq_set t (N + 1) (ThreadEvent t idx).","conclusion":"thread_seq_set t (N + 1) (ThreadEvent t idx)","hypotheses":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx))","proofString":"eapply contactids_eq, in_restr_acts, ADD; eauto; try now right.\nchange (fun e => t = tid e) with (same_tid (ThreadEvent t idx)).\nerewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum (N + 1).","conclusion":"set_size (acts_set G' ∩₁ (fun e : actid => t = tid e)) = NOnum (N + 1)","hypotheses":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx))","proofString":"change (fun e => t = tid e) with (same_tid (ThreadEvent t idx)).\nerewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx)) : set_size (acts_set G' ∩₁ same_tid (ThreadEvent t idx)) = NOnum (N + 1).","conclusion":"set_size (acts_set G' ∩₁ same_tid (ThreadEvent t idx)) = NOnum (N + 1)","hypotheses":"(t : thread_id) (idx N : nat) (G G' : execution) (NOT_INIT : t <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid (ThreadEvent t idx)) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G (ThreadEvent t idx)) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq (ThreadEvent t idx))","proofString":"erewrite new_event_plus, SZ_EQ; eauto."},{"statement":"(e : actid) (N : nat) (G : execution) (NOT_INIT : tid e <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (NOTIN : ~ acts_set G e) (F : trace_elems (thread_actid_trace G (tid e)) e) : False.","conclusion":"False","hypotheses":"(e : actid) (N : nat) (G : execution) (NOT_INIT : tid e <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (NOTIN : ~ acts_set G e) (F : trace_elems (thread_actid_trace G (tid e)) e)","proofString":"eapply trace_elems_eq_thread_events in F.\neapply NOTIN, in_restr_acts; eauto.\napply contactids_eq; eauto."},{"statement":"(e : actid) (N : nat) (G : execution) (NOT_INIT : tid e <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (NOTIN : ~ acts_set G e) (F : (acts_set G ∩₁ (fun e0 : actid => tid e = tid e0)) e) : False.","conclusion":"False","hypotheses":"(e : actid) (N : nat) (G : execution) (NOT_INIT : tid e <> tid_init) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (NOTIN : ~ acts_set G e) (F : (acts_set G ∩₁ (fun e0 : actid => tid e = tid e0)) e)","proofString":"eapply NOTIN, in_restr_acts; eauto."},{"statement":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) : trace_map (upd (lab G) e l)\n  (trace_app (thread_actid_trace G (tid e)) (trace_fin [e])) =\ntrace_app (trace_map (lab G) (thread_actid_trace G (tid e)))\n  (trace_fin [upd (lab G) e l e]).","conclusion":"trace_map (upd (lab G) e l)\n  (trace_app (thread_actid_trace G (tid e)) (trace_fin [e])) =\ntrace_app (trace_map (lab G) (thread_actid_trace G (tid e)))\n  (trace_fin [upd (lab G) e l e])","hypotheses":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e)","proofString":"destruct (thread_actid_trace G (tid e)) eqn:Heq; ins.\nrewrite map_app, map_upd_irr; ins.\nintro F; eapply event_not_in_actid_trace; eauto.\nrewrite Heq; ins.\nexfalso.\nerewrite thread_actid_trace_form in Heq; ins.\neapply contactids_eq; eauto."},{"statement":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (l0 : list actid) (Heq : thread_actid_trace G (tid e) = trace_fin l0) : trace_fin (map (upd (lab G) e l) (l0 ++ [e])) =\ntrace_fin (map (lab G) l0 ++ [upd (lab G) e l e]).","conclusion":"trace_fin (map (upd (lab G) e l) (l0 ++ [e])) =\ntrace_fin (map (lab G) l0 ++ [upd (lab G) e l e])","hypotheses":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (l0 : list actid) (Heq : thread_actid_trace G (tid e) = trace_fin l0)","proofString":"rewrite map_app, map_upd_irr; ins.\nintro F; eapply event_not_in_actid_trace; eauto.\nrewrite Heq; ins."},{"statement":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (l0 : list actid) (Heq : thread_actid_trace G (tid e) = trace_fin l0) : ~ In e l0.","conclusion":"~ In e l0","hypotheses":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (l0 : list actid) (Heq : thread_actid_trace G (tid e) = trace_fin l0)","proofString":"intro F; eapply event_not_in_actid_trace; eauto.\nrewrite Heq; ins."},{"statement":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (l0 : list actid) (Heq : thread_actid_trace G (tid e) = trace_fin l0) (F : In e l0) : trace_elems (thread_actid_trace G (tid e)) e.","conclusion":"trace_elems (thread_actid_trace G (tid e)) e","hypotheses":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (l0 : list actid) (Heq : thread_actid_trace G (tid e) = trace_fin l0) (F : In e l0)","proofString":"rewrite Heq; ins."},{"statement":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (fl : nat -> actid) (Heq : thread_actid_trace G (tid e) = trace_inf fl) : trace_inf (fun x : nat => upd (lab G) e l (fl x)) =\ntrace_inf (fun x : nat => lab G (fl x)).","conclusion":"trace_inf (fun x : nat => upd (lab G) e l (fl x)) =\ntrace_inf (fun x : nat => lab G (fl x))","hypotheses":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (fl : nat -> actid) (Heq : thread_actid_trace G (tid e) = trace_inf fl)","proofString":"exfalso.\nerewrite thread_actid_trace_form in Heq; ins.\neapply contactids_eq; eauto."},{"statement":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (fl : nat -> actid) (Heq : thread_actid_trace G (tid e) = trace_inf fl) : False.","conclusion":"False","hypotheses":"(e : actid) (l : label) (N : nat) (G G' : execution) (NOT_INIT : tid e <> tid_init) (LABEQ : lab G' = upd (lab G) e l) (SZ_EQ : set_size (acts_set G ∩₁ same_tid e) = NOnum N) (CONT : contigious_actids G) (CONT' : contigious_actids G') (NEW : ~ acts_set G e) (ADD : acts_set G' ≡₁ acts_set G ∪₁ eq e) (fl : nat -> actid) (Heq : thread_actid_trace G (tid e) = trace_inf fl)","proofString":"erewrite thread_actid_trace_form in Heq; ins.\neapply contactids_eq; eauto."}]}