[{"statement":"Lemma trav_prefix_in_exec_tls i\n        (DOMi: NOmega.le (NOnum i) (set_size dom)):\n    trav_prefix steps i ⊆₁ exec_tls G.","proof":"apply enumeratesE' in ENUM.\ncdes ENUM.\nunfold trav_prefix.\napply set_subset_bunion_l.\nintros.\nrewrite <- DOM_EXEC.\napply set_subset_single_l.\napply INSET.\nliaW (set_size dom).\n"},{"statement":"Lemma trav_prefix_step\n        i (DOMsi: NOmega.lt_nat_l i (set_size dom)):\n    iord_step G sc (trav_prefix steps i) (trav_prefix steps (S i)).","proof":"red.\nexists (steps i).\ndo 2 red.\nsplits; try by (red; eapply trav_prefix_r_closed; eauto; liaW (set_size dom)).\napply seq_eqv_l.\nsplit.\n{\neapply prefix_border; eauto.\n}\neapply trav_prefix_ext; eauto.\n"},{"statement":"Lemma trav_prefix_init_tls_iord_coherent i\n        (DOMi : NOmega.le (NOnum i) (set_size dom)):\n    iord_coherent G sc (trav_prefix steps i ∪₁ init_tls G).","proof":"red.\nrewrite id_union, seq_union_r, dom_union.\napply set_subset_union_l.\nsplit.\n{\napply set_subset_union_r.\nleft.\neapply trav_prefix_r_closed; eauto.\n}\nunfold \"iord\".\nrewrite init_tls_EI at 1.\nbasic_solver.\n"},{"statement":"Lemma tc_enum_tls_coherent WF i\n      (DOMi: NOmega.le (NOnum i) (set_size dom)):\n    tls_coherent G (tc_enum i).","proof":"unfold tc_enum.\nsplit; [basic_solver| ].\napply set_subset_union_l.\nsplit; [| basic_solver].\nerewrite sim_clos_mori.\n2: {\napply trav_prefix_in_exec_tls; eauto.\n}\npose proof (exec_tls_sim_coh WF).\nred in H.\nrewrite <- H.\nbasic_solver.\n"},{"statement":"Lemma trav_prefix_union_init_tls_coherent WF i\n      (DOMi: NOmega.le (NOnum i) (set_size dom)):\n    tls_coherent G (trav_prefix steps i ∪₁ init_tls G).","proof":"apply tls_coherent_defs_equiv.\nexists (trav_prefix steps i).\nsplit; [| basic_solver].\nnow apply trav_prefix_in_exec_tls.\n"},{"statement":"Lemma trav_prefix_step_ext\n        i (DOMsi: NOmega.lt_nat_l i (set_size dom)):\n    iord_step G sc (trav_prefix steps i ∪₁ init_tls G)\n              (trav_prefix steps (S i) ∪₁ init_tls G).","proof":"forward eapply trav_prefix_step as [l STEP]; eauto.\nred.\nexists l.\ndo 2 red.\nsplits; try by (apply trav_prefix_init_tls_iord_coherent; liaW (set_size dom)).\ndo 2 red in STEP.\ndesc.\napply seq_eqv_l in STEP.\ndesc.\napply seq_eqv_l.\nsplit.\n2: {\nrewrite STEP2.\nbasic_solver.\n}\napply set_compl_union.\nsplit; auto.\napply set_disjoint_eq_r.\neapply set_disjoint_mori; [reflexivity| ..].\n2: by apply init_exec_tls_disjoint.\nred.\nrewrite <- DOM_EXEC.\nforward eapply @trav_prefix_in_dom with (i := S i) as XX; eauto.\nrewrite <- XX.\nrewrite STEP2.\nbasic_solver.\n"},{"statement":"Lemma sim_traversal_next WF CONS:\n    forall i (DOMi: NOmega.lt_nat_l i (set_size dom)),\n      (sim_clos_step G sc)^* (tc_enum i) (tc_enum (1 + i)).","proof":"ins.\nunfold tc_enum.\nforward eapply init_tls_sim_coh as INIT_SCOH; eauto.\nred in INIT_SCOH.\nrewrite INIT_SCOH, <- !sim_clos_dist; auto.\napply iord_step_implies_sim_clos_step; auto.\nred.\nsplits; try by (apply trav_prefix_union_init_tls_coherent; liaW (set_size dom)).\napply trav_prefix_step_ext; auto.\n"},{"statement":"Lemma iord_enum_exists WF COMP WFSC CONS MF\n        (IMM_FAIR: imm_s_fair G sc)\n        (TB: fin_threads G)\n        dom:\n  exists (steps: nat -> trav_label),\n    enumerates steps dom /\\\n    respects_rel steps iord⁺ dom.","proof":"edestruct countable_ext with (s := dom) (r := ⦗event ↓₁ (set_compl is_init)⦘ ⨾ iord⁺)      as [| [steps [ENUM RESP]]].\n{\neapply countable_subset; [| by apply set_subset_full_r].\napply trav_label_countable.\n}\n{\nred.\nsplit.\n{\nrewrite inclusion_seq_eqv_l.\nby apply iord_acyclic.\n}\nred.\nintros ? ? ? ?%seq_eqv_l  ?%seq_eqv_l.\ndesc.\napply seq_eqv_l.\nsplit; auto.\neapply transitive_ct; eauto.\n}\n{\neapply iord_ct_fsupp; eauto.\n}\n{\nedestruct H.\nconstructor.\neconstructor; vauto.\n}\nexists steps.\nsplits; eauto.\nred.\nins.\napply RESP; auto.\n1, 2: by apply set_lt_size.\napply seq_eqv_l.\nsplit; auto.\napply enumeratesE' in ENUM.\ndesc.\napply INSET in DOMi.\napply ct_begin in Rij.\ngeneralize Rij.\nunfold iord.\nbasic_solver.\n"},{"statement":"Lemma sim_traversal_inf WF CONS\n        (FAIR: mem_fair G)\n        (IMM_FAIR: imm_s_fair G sc)\n        (TB: fin_threads G)\n        (dom: trav_label -> Prop)\n        (IORD_DOM: iord ⊆ dom × dom)\n        (DOM_EXEC: dom ⊆₁ exec_tls G)\n        (DOM_COVERS: eq ta_cover <*> (E \\₁ is_init) ⊆₁ dom)\n        (DOM_SIM_CLOSURE: forall (S: trav_label -> Prop) (S_DOM: S ⊆₁ dom),\n            (@sim_clos G S) ⊆₁ dom):\n    exists (sim_enum: nat -> (trav_label -> Prop)),\n      ⟪INIT: sim_enum 0 ≡₁ init_tls G ⟫ /\\\n      ⟪COH: forall i (DOMi: NOmega.le (NOnum i) (set_size dom)),\n          tls_coherent G (sim_enum i)⟫ /\\\n      ⟪STEPS: forall i (DOMi: NOmega.lt_nat_l i (set_size dom)),\n          (sim_clos_step G sc)^* (sim_enum i) (sim_enum (1 + i)) ⟫ /\\\n      ⟪ENUM: forall e (Ee: (E \\₁ is_init) e), exists i,\n           NOmega.le (NOnum i) (set_size dom) /\\\n             (sim_enum i) (mkTL ta_cover e)⟫ /\\\n      ⟪DOM: forall i (DOMi: NOmega.le (NOnum i) (set_size dom)),\n          sim_enum i ⊆₁ init_tls G ∪₁ dom⟫.","proof":"edestruct iord_enum_exists as [steps_enum [ENUM RESP]]; eauto.\n1, 2: by apply CONS.\nexists (tc_enum steps_enum).\nsplits.\n{\nunfold tc_enum.\nrewrite trav_prefix_init.\nrewrite sim_clos_empty.\nbasic_solver.\n}\n{\napply tc_enum_tls_coherent; eauto.\n}\n{\napply sim_traversal_next; auto.\n}\n{\nintros e Ee.\npose proof ENUM as ENUM'.\napply enumeratesE' in ENUM.\ndesc.\nspecialize (IND (mkTL ta_cover e)).\nspecialize_full IND.\n{\napply DOM_COVERS.\nvauto.\n}\ndesc.\nexists (S i).\nsplit; [by vauto| ].\neapply set_equiv_exp.\n{\nunfold tc_enum.\nrewrite trav_prefix_ext; eauto.\n}\nrewrite IND0.\nunfold sim_clos.\nbasic_solver 10.\n}\nins.\nunfold tc_enum.\nrewrite set_unionC.\napply set_subset_union; [done| ].\nrewrite <- DOM_SIM_CLOSURE; [reflexivity| ].\neapply trav_prefix_in_dom; eauto.\n"},{"statement":"Lemma sim_traversal_inf_cip WF CONS\n        (FAIR: mem_fair G)\n        (IMM_FAIR: imm_s_fair G sc)\n        (TB: fin_threads G) :\n    exists (sim_enum: nat -> (trav_label -> Prop)),\n      ⟪INIT: sim_enum 0 ≡₁ init_tls G ⟫ /\\\n      ⟪COH: forall i (DOMi: NOmega.le (NOnum i) (set_size (exec_tls_cip G))),\n          tls_coherent G (sim_enum i)⟫ /\\\n      ⟪STEPS: forall i (DOMi: NOmega.lt_nat_l i (set_size (exec_tls_cip G))),\n          (sim_clos_step G sc)^* (sim_enum i) (sim_enum (1 + i)) ⟫ /\\\n      ⟪ENUM: forall e (Ee: (E \\₁ is_init) e), exists i,\n           NOmega.le (NOnum i) (set_size (exec_tls_cip G)) /\\\n             (sim_enum i) (mkTL ta_cover e)⟫ /\\\n      ⟪DOM: forall i (DOMi: NOmega.le (NOnum i) (set_size (exec_tls_cip G))),\n          sim_enum i ⊆₁ init_tls G ∪₁ exec_tls_cip G⟫.","proof":"forward eapply sim_traversal_inf with (dom := exec_tls_cip G) as TRAV; eauto.\n{\napply dom_helper_3.\nrewrite <- restr_relE.\napply iord_exec_tls_cip.\n}\n{\nunfold exec_tls_cip, exec_tls.\nrewrite !set_pair_alt.\nbasic_solver 10.\n}\n{\nunfold exec_tls_cip, exec_tls.\nrewrite !set_pair_alt.\nbasic_solver 10.\n}\nins.\nrewrite exec_tls_cip_alt, set_minusE.\napply set_subset_inter_r.\nsplit.\n{\napply sim_clos_exec_tls; auto.\nrewrite S_DOM.\nrewrite exec_tls_cip_alt.\nbasic_solver.\n}\nunfold sim_clos.\nrepeat (apply set_subset_union_l; split).\n2, 3: unfold rmw_clos, rel_clos; iord_dom_solver.\nrewrite S_DOM, exec_tls_cip_alt.\nbasic_solver.\n"},{"statement":"Lemma sim_traversal_inf_full WF CONS\n        (FAIR: mem_fair G)\n        (IMM_FAIR: imm_s_fair G sc)\n        (TB: fin_threads G) :\n    exists (sim_enum: nat -> (trav_label -> Prop)),\n      ⟪INIT: sim_enum 0 ≡₁ init_tls G ⟫ /\\\n      ⟪COH: forall i (DOMi: NOmega.le (NOnum i) (set_size (exec_tls G))),\n          tls_coherent G (sim_enum i)⟫ /\\\n      ⟪STEPS: forall i (DOMi: NOmega.lt_nat_l i (set_size (exec_tls G))),\n          (sim_clos_step G sc)^* (sim_enum i) (sim_enum (1 + i)) ⟫ /\\\n       ⟪ENUM: forall e (Ee: (E \\₁ is_init) e), exists i,\n           NOmega.le (NOnum i) (set_size (exec_tls G)) /\\\n             (sim_enum i) (mkTL ta_cover e)⟫.","proof":"forward eapply sim_traversal_inf with (dom := exec_tls G) as TRAV; eauto.\n{\nrewrite iord_exec_tls.\nbasic_solver.\n}\n{\nunfold exec_tls.\nbasic_solver.\n}\n{\nins.\napply sim_clos_exec_tls; auto.\n}\ndesc.\neexists.\nsplits; eauto.\n"}]