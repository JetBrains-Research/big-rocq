{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/promising2ToImm/src/compilation/ReserveClosStep.v","fileSamples":[{"statement":"(r : relation actid) (s : actid -> Prop) (tc : trav_label -> Prop) (W_EX_IS_XACQ : W_ex G ⊆₁ W_ex G ∩₁ (fun a : actid => is_xacq (lab G) a)) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (RESEMPTC : reserved tc ⊆₁ issued tc) : dom_rel\n  (⦗W_ex G ∩₁ (fun a : actid => is_xacq (lab G) a)⦘ ⨾ sb G ⨾ ⦗issued tc⦘)\n⊆₁ issued tc.","proofString":"eapply dom_wex_sb_issued; eauto."},{"statement":"(r : relation actid) (s : actid -> Prop) (tc : trav_label -> Prop) (W_EX_IS_XACQ : W_ex G ⊆₁ W_ex G ∩₁ (fun a : actid => is_xacq (lab G) a)) (TCOH : tls_coherent G tc) (ICOH : iord_coherent G sc tc) (RESEMPTC : reserved tc ⊆₁ issued tc) : dom_rel (sb G ⨾ ⦗issued tc⦘) ∩₁ codom_rel (⦗s⦘ ⨾ r ⨾ rmw G ⨾ ⦗W_ex G⦘)\n⊆₁ dom_rel (⦗W_ex G⦘ ⨾ sb G ⨾ ⦗issued tc⦘).","proofString":"clear.\nbasic_solver."},{"statement":"(r : relation actid) (s : actid -> Prop) (tc : trav_label -> Prop) : dom_rel (sb G ⨾ ⦗issued tc⦘) ∩₁ codom_rel (⦗s⦘ ⨾ r ⨾ rmw G ⨾ ⦗W_ex G⦘)\n⊆₁ dom_rel (⦗W_ex G⦘ ⨾ sb G ⨾ ⦗issued tc⦘).","proofString":"basic_solver."},{"statement":"(tc1 : trav_action * actid -> Prop) (tc2 : trav_label -> Prop) (INIT1 : init_tls G ⊆₁ tc1) (TCOH2 : tls_coherent G tc2) (RESEMPTC2 : reserved tc2 ⊆₁ acts_set G ∩₁ (fun a : actid => is_init a)) (STEP : isim_clos_step G sc [] tc1 tc2) (SCOH1 : sim_coherent G tc1) (SCOH2 : sim_coherent G tc2) : (ext_sim_trav_step G sc)＊ (reserve_clos tc1) (reserve_clos tc2).","proofString":"inv STEP."},{"statement":"(tc1 : trav_action * actid -> Prop) (tc2 : trav_label -> Prop) (INIT1 : init_tls G ⊆₁ tc1) (TCOH2 : tls_coherent G tc2) (RESEMPTC2 : reserved tc2 ⊆₁ acts_set G ∩₁ (fun a0 : actid => is_init a0)) (a : trav_label) (tll : list trav_label) (SCOH1 : sim_coherent G tc1) (SCOH2 : sim_coherent G tc2) (STEP : (ext_isim_trav_step G sc (ta_label2thread a))＊ (reserve_clos tc1)\n  (reserve_clos tc2)) : ext_isim_trav_step G sc (ta_label2thread a) ⊆ ext_sim_trav_step G sc.","proofString":"unfold ext_sim_trav_step.\nclear.\nbasic_solver."},{"statement":"(tc1 : trav_action * actid -> Prop) (tc2 : trav_label -> Prop) (INIT1 : init_tls G ⊆₁ tc1) (TCOH2 : tls_coherent G tc2) (RESEMPTC2 : reserved tc2 ⊆₁ acts_set G ∩₁ (fun a0 : actid => is_init a0)) (a : trav_label) (tll : list trav_label) (SCOH1 : sim_coherent G tc1) (SCOH2 : sim_coherent G tc2) (STEP : (ext_isim_trav_step G sc (ta_label2thread a))＊ (reserve_clos tc1)\n  (reserve_clos tc2)) : ext_isim_trav_step G sc (ta_label2thread a)\n⊆ (fun T T' : trav_label -> Prop =>\n   exists thread : thread_id, ext_isim_trav_step G sc thread T T').","proofString":"clear.\nbasic_solver."},{"statement":"(a : trav_label) : ext_isim_trav_step G sc (ta_label2thread a)\n⊆ (fun T T' : trav_label -> Prop =>\n   exists thread : thread_id, ext_isim_trav_step G sc thread T T').","proofString":"basic_solver."},{"statement":"(tc1 : trav_action * actid -> Prop) (tc2 : trav_label -> Prop) (INIT1 : init_tls G ⊆₁ tc1) (TCOH2 : tls_coherent G tc2) (RESEMPTC2 : reserved tc2 ⊆₁ acts_set G ∩₁ (fun a0 : actid => is_init a0)) (a : trav_label) (tll : list trav_label) (SCOH1 : sim_coherent G tc1) (SCOH2 : sim_coherent G tc2) (STEP : (ext_isim_trav_step G sc (ta_label2thread a))＊ (reserve_clos tc1)\n  (reserve_clos tc2)) (HH : ext_isim_trav_step G sc (ta_label2thread a) ⊆ ext_sim_trav_step G sc) : (ext_sim_trav_step G sc)＊ (reserve_clos tc1) (reserve_clos tc2).","proofString":"eapply clos_refl_trans_mori; eauto."}]}