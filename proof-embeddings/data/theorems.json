[
    {
        "statement": "Lemma tid_set_dec thread :\n  (fun x => tid x = thread) ∪₁ (fun x => tid x <> thread) ≡₁ (fun x => True).",
        "proof": "unfolder; split; ins; desf; tauto.\n"
    },
    {
        "statement": "Lemma restr_eq_rel_same_tid r :  restr_eq_rel tid r  ≡ r ∩ same_tid.",
        "proof": "unfold same_tid; basic_solver.\n"
    },
    {
        "statement": "Lemma loceq_same_tid (r: relation actid) (H: funeq tid r):\n r ⊆ r ∩ same_tid.",
        "proof": "unfold same_tid; basic_solver.\n"
    },
    {
        "statement": "Lemma same_tid_loceq (r: relation actid) (H: r ⊆ r ∩ same_tid):\n funeq tid r.",
        "proof": "unfold same_tid; unfolder; firstorder.\n"
    },
    {
        "statement": "Lemma eq_dec_actid :\n  forall x y : actid, {x = y} + {x <> y}.",
        "proof": "repeat decide equality.\n"
    },
    {
        "statement": "Lemma lab_rwf a : is_r a \\/ is_w a \\/ is_f a.",
        "proof": "unfold is_r, is_w, is_f; destruct (lab a); auto.\n"
    },
    {
        "statement": "Lemma R_ex_in_R : R_ex ⊆₁ is_r.",
        "proof": "unfold R_ex, is_r; basic_solver.\n"
    },
    {
        "statement": "Lemma restr_eq_rel_same_loc r :  restr_eq_rel loc r  ≡ r ∩ same_loc.",
        "proof": "unfold same_loc; basic_solver.\n"
    },
    {
        "statement": "Lemma loceq_same_loc (r: relation A) (H: funeq loc r):\n r ⊆ r ∩ same_loc.",
        "proof": "unfold same_loc; basic_solver.\n"
    },
    {
        "statement": "Lemma same_loc_loceq (r: relation A) (H: r ⊆ r ∩ same_loc):\n funeq loc r.",
        "proof": "unfold same_loc; unfolder; firstorder.\n"
    },
    {
        "statement": "Lemma same_loc_trans : transitive same_loc.",
        "proof": "unfold same_loc; red; ins.\nby rewrite H.\n"
    },
    {
        "statement": "Lemma same_loc_sym : symmetric same_loc.",
        "proof": "unfold same_loc; red; ins.\n"
    },
    {
        "statement": "Lemma is_w_val x (WX : is_w x) : exists v, val x = Some v.",
        "proof": "unfold is_w, val in *; desf.\neexists; eauto.\n"
    },
    {
        "statement": "Lemma is_w_loc x (WX : is_w x) : exists l, loc x = Some l.",
        "proof": "unfold is_w, loc in *; desf.\neexists; eauto.\n"
    },
    {
        "statement": "Lemma is_r_val x (WX : is_r x) : exists v, val x = Some v.",
        "proof": "unfold is_r, val in *; desf.\neexists; eauto.\n"
    },
    {
        "statement": "Lemma is_r_loc x (WX : is_r x) : exists l, loc x = Some l.",
        "proof": "unfold is_r, loc in *; desf.\neexists; eauto.\n"
    },
    {
        "statement": "Lemma is_f_val x (FX : is_f x) : val x = None.",
        "proof": "unfold is_f, val in *; desf.\n"
    },
    {
        "statement": "Lemma is_f_loc x  (FX: is_f x): loc x = None.",
        "proof": "unfold is_f, loc in *; desf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_loc (SAME: same_lab_u2v_dom) :\n  eq_dom s (loc lab1) (loc lab2).",
        "proof": "same_lab_set_solver_f SAME.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_mod (SAME: same_lab_u2v_dom) :\n  eq_dom s (mod lab1) (mod lab2).",
        "proof": "same_lab_set_solver_f SAME.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_xmod (SAME: same_lab_u2v_dom) :\n  eq_dom s (xmod lab1) (xmod lab2).",
        "proof": "same_lab_set_solver_f SAME.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_is_r (SAME: same_lab_u2v_dom) :\n  s ∩₁ is_r lab1 ≡₁ s ∩₁ is_r lab2.",
        "proof": "same_lab_set_solver_s SAME.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_is_w (SAME: same_lab_u2v_dom) :\n  s ∩₁ is_w lab1 ≡₁ s ∩₁ is_w lab2.",
        "proof": "same_lab_set_solver_s SAME.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_is_f (SAME: same_lab_u2v_dom) :\n  s ∩₁ is_f lab1 ≡₁ s ∩₁ is_f lab2.",
        "proof": "same_lab_set_solver_s SAME.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_R_ex (SAME: same_lab_u2v_dom) :\n  s ∩₁ R_ex lab1 ≡₁ s ∩₁ R_ex lab2.",
        "proof": "same_lab_set_solver_s SAME; desf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_is_only_pln (SAME: same_lab_u2v_dom) :\n  s ∩₁ is_only_pln lab1 ≡₁ s ∩₁ is_only_pln lab2.",
        "proof": "same_lab_set_solver_s SAME; desf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_is_only_rlx (SAME: same_lab_u2v_dom) :\n  s ∩₁ is_only_rlx lab1 ≡₁ s ∩₁ is_only_rlx lab2.",
        "proof": "same_lab_set_solver_s SAME; desf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_is_rlx (SAME: same_lab_u2v_dom) :\n  s ∩₁ is_rlx lab1 ≡₁ s ∩₁ is_rlx lab2.",
        "proof": "same_lab_set_solver_s SAME; desf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_is_acq (SAME: same_lab_u2v_dom) :\n  s ∩₁ is_acq lab1 ≡₁ s ∩₁ is_acq lab2.",
        "proof": "same_lab_set_solver_s SAME; desf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_is_rel (SAME: same_lab_u2v_dom) :\n  s ∩₁ is_rel lab1 ≡₁ s ∩₁ is_rel lab2.",
        "proof": "same_lab_set_solver_s SAME; desf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_is_acqrel (SAME: same_lab_u2v_dom) :\n  s ∩₁ is_acqrel lab1 ≡₁ s ∩₁ is_acqrel lab2.",
        "proof": "same_lab_set_solver_s SAME; desf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_is_sc (SAME: same_lab_u2v_dom) :\n  s ∩₁ is_sc lab1 ≡₁ s ∩₁ is_sc lab2.",
        "proof": "same_lab_set_solver_s SAME; desf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_is_ra (SAME: same_lab_u2v_dom) :\n  s ∩₁ is_ra lab1 ≡₁ s ∩₁ is_ra lab2.",
        "proof": "same_lab_set_solver_s SAME; desf.\nall: by rewrite Bool.orb_true_r.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_is_xacq (SAME: same_lab_u2v_dom) :\n  s ∩₁ is_xacq lab1 ≡₁ s ∩₁ is_xacq lab2.",
        "proof": "same_lab_set_solver_s SAME; desf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_same_loc (SAME: same_lab_u2v_dom) :\n  restr_rel s (same_loc lab1) ≡ restr_rel s (same_loc lab2).",
        "proof": "unfolder.\nsplit.\nall: ins; desf; splits; auto.\nall: unfold same_loc, loc, same_lab_u2v_dom, same_label_u2v in *.\nall: set (SAMEY := SAME); specialize (SAMEY y H1).\nall: specialize (SAME x H0); desf; desf.\n"
    },
    {
        "statement": "Lemma same_label_u2v_val {A} (lab lab' : A -> label) x\n      (U2V : same_label_u2v (lab x) (lab' x))\n      (VAL : val lab x = val lab' x) :\n  lab x = lab' x.",
        "proof": "unfold same_label_u2v, val in *.\ndesf; desf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_loc (SAME: same_lab_u2v) :\n  loc lab1 = loc lab2.",
        "proof": "apply eq_dom_full_eq.\nby apply same_lab_u2v_dom_loc.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_mod (SAME: same_lab_u2v) :\n  mod lab1 = mod lab2.",
        "proof": "apply eq_dom_full_eq.\nby apply same_lab_u2v_dom_mod.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_xmod (SAME: same_lab_u2v) :\n  xmod lab1 = xmod lab2.",
        "proof": "apply eq_dom_full_eq.\nby apply same_lab_u2v_dom_xmod.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_is_r (SAME: same_lab_u2v) :\n  is_r lab1 ≡₁ is_r lab2.",
        "proof": "generalize (same_lab_u2v_dom_is_r SAME).\nrelsf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_is_w (SAME: same_lab_u2v) :\n  is_w lab1 ≡₁ is_w lab2.",
        "proof": "generalize (same_lab_u2v_dom_is_w SAME).\nrelsf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_is_f (SAME: same_lab_u2v) :\n  is_f lab1 ≡₁ is_f lab2.",
        "proof": "generalize (same_lab_u2v_dom_is_f SAME).\nrelsf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_R_ex (SAME: same_lab_u2v) :\n  R_ex lab1 ≡₁ R_ex lab2.",
        "proof": "generalize (same_lab_u2v_dom_R_ex SAME).\nrelsf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_is_only_pln (SAME: same_lab_u2v) :\n  is_only_pln lab1 ≡₁ is_only_pln lab2.",
        "proof": "generalize (same_lab_u2v_dom_is_only_pln SAME).\nrelsf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_is_only_rlx (SAME: same_lab_u2v) :\n  is_only_rlx lab1 ≡₁ is_only_rlx lab2.",
        "proof": "generalize (same_lab_u2v_dom_is_only_rlx SAME).\nrelsf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_is_rlx (SAME: same_lab_u2v) :\n  is_rlx lab1 ≡₁ is_rlx lab2.",
        "proof": "generalize (same_lab_u2v_dom_is_rlx SAME).\nrelsf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_is_acq (SAME: same_lab_u2v) :\n  is_acq lab1 ≡₁ is_acq lab2.",
        "proof": "generalize (same_lab_u2v_dom_is_acq SAME).\nrelsf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_is_rel (SAME: same_lab_u2v) :\n  is_rel lab1 ≡₁ is_rel lab2.",
        "proof": "generalize (same_lab_u2v_dom_is_rel SAME).\nrelsf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_is_acqrel (SAME: same_lab_u2v) :\n  is_acqrel lab1 ≡₁ is_acqrel lab2.",
        "proof": "generalize (same_lab_u2v_dom_is_acqrel SAME).\nrelsf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_is_sc (SAME: same_lab_u2v) :\n  is_sc lab1 ≡₁ is_sc lab2.",
        "proof": "generalize (same_lab_u2v_dom_is_sc SAME).\nrelsf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_is_ra (SAME: same_lab_u2v) :\n  is_ra lab1 ≡₁ is_ra lab2.",
        "proof": "generalize (same_lab_u2v_dom_is_ra SAME).\nrelsf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_is_xacq (SAME: same_lab_u2v) :\n  is_xacq lab1 ≡₁ is_xacq lab2.",
        "proof": "generalize (same_lab_u2v_dom_is_xacq SAME).\nrelsf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_same_loc (SAME: same_lab_u2v) :\n  same_loc lab1 ≡ same_loc lab2.",
        "proof": "generalize (same_lab_u2v_dom_same_loc SAME).\nby rewrite !restr_full.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_comm {A} (lab1 lab2 : A -> label)\n      (S1 : same_lab_u2v lab1 lab2) :\n  same_lab_u2v lab2 lab1.",
        "proof": "unfold same_lab_u2v, same_lab_u2v_dom.\nins.\nspecialize (S1 e EE).\nunfold same_label_u2v in *.\ndesf; desf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_follows_set {A} s (lab1 lab2 : A -> label)\n      (S1 : same_lab_u2v lab1 lab2) :\n  same_lab_u2v_dom s lab1 lab2.",
        "proof": "unfold same_lab_u2v, same_lab_u2v_dom in *.\nins.\nby apply S1.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_inclusion {A} s s' (lab lab' : A -> label)\n      (SS : s' ⊆₁ s)\n      (S1 : same_lab_u2v_dom s lab lab') :\n  same_lab_u2v_dom s' lab lab'.",
        "proof": "red.\nins.\napply S1.\nby apply SS.\n"
    },
    {
        "statement": "Lemma same_label_u2v_trans lbl1 lbl2 lbl3\n      (S1 : same_label_u2v lbl1 lbl2)\n      (S2 : same_label_u2v lbl2 lbl3) :\n  same_label_u2v lbl1 lbl3.",
        "proof": "unfold same_label_u2v in *.\ndesf; desf.\n"
    },
    {
        "statement": "Lemma same_label_u2v_comm lbl1 lbl2\n      (S1 : same_label_u2v lbl1 lbl2) :\n  same_label_u2v lbl2 lbl1.",
        "proof": "unfold same_label_u2v in *.\ndesf; desf.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_trans {A} (s : A -> Prop) lab1 lab2 lab3\n      (S1 : same_lab_u2v_dom s lab1 lab2)\n      (S2 : same_lab_u2v_dom s lab2 lab3) :\n  same_lab_u2v_dom s lab1 lab3.",
        "proof": "red.\nins.\nspecialize (S1 e EE).\nspecialize (S2 e EE).\neapply same_label_u2v_trans; eauto.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_comm {A} (s : A -> Prop) lab1 lab2\n      (S2 : same_lab_u2v_dom s lab1 lab2) :\n  same_lab_u2v_dom s lab2 lab1.",
        "proof": "red.\nins.\nspecialize (S2 e EE).\nby apply same_label_u2v_comm.\n"
    },
    {
        "statement": "Lemma same_lab_u2v_dom_same_mod {A} (lab lab' : A -> label) (s : A -> Prop)\n      (SAME: same_lab_u2v_dom s lab lab') :\n  restr_rel s (same_mod lab) ≡ restr_rel s (same_mod lab').",
        "proof": "unfolder.\nsplit.\nall: ins; desf; splits; auto.\nall: unfold same_mod, mod, same_lab_u2v_dom, same_label_u2v in *.\nall: set (SAMEY := SAME); specialize (SAMEY y H1).\nall: specialize (SAME x H0); desf; desf.\n"
    },
    {
        "statement": "Lemma ext_sb_trans : transitive ext_sb.",
        "proof": "unfold ext_sb; red; ins.\ndestruct x,y,z; ins; desf; splits; eauto.\nby rewrite H2.\n"
    },
    {
        "statement": "Lemma ext_sb_irr : irreflexive ext_sb.",
        "proof": "unfold ext_sb; red; ins.\ndestruct x; firstorder.\nlia.\n"
    },
    {
        "statement": "Lemma ext_sb_to_non_init : ext_sb ⊆ ext_sb ⨾  ⦗fun x => ~ is_init x⦘.",
        "proof": "unfold is_init, ext_sb; basic_solver.\n"
    },
    {
        "statement": "Lemma ext_sb_semi_total_l x y z \n  (N: ~ is_init x) (NEQ: index y <> index z) (XY: ext_sb x y) (XZ: ext_sb x z): \n  ext_sb y z \\/ ext_sb z y.",
        "proof": "unfold ext_sb in *.\ndestruct x,y,z; ins; desf.\ncut(index1 < index2 \\/ index2 < index1).\ntauto.\nlia.\n"
    },
    {
        "statement": "Lemma ext_sb_semi_total_r x y z \n  (NEQ: index y <> index z) (XY: ext_sb y x) (XZ: ext_sb z x): \n  ext_sb y z \\/ ext_sb z y.",
        "proof": "unfold ext_sb in *.\ndestruct x,y,z; ins; desf; eauto.\ncut(index1 < index2 \\/ index2 < index1).\ntauto.\nlia.\n"
    },
    {
        "statement": "Lemma ext_sb_tid_init x y (SB : ext_sb x y): tid x = tid y \\/ is_init x.",
        "proof": "unfold ext_sb in *; desf; ins; desf; eauto.\n"
    },
    {
        "statement": "Lemma ext_sb_tid_init': ext_sb ⊆ ext_sb ∩ same_tid ∪ ⦗is_init⦘ ⨾ ext_sb.",
        "proof": "generalize ext_sb_tid_init; firstorder.\n"
    },
    {
        "statement": "Lemma tid_ext_sb: same_tid ⊆ ext_sb^? ∪ ext_sb^{-1} ∪ (is_init × is_init).",
        "proof": "unfold ext_sb, same_tid, tid, is_init, cross_rel; unfolder.\nins; destruct x, y; desf; eauto.\ncut(index0 < index1 \\/ index1 < index0 \\/ index0 = index1).\nby ins; desf; eauto.\nlia.\n"
    },
    {
        "statement": "Lemma tid_n_init_ext_sb: same_tid ⨾ ⦗set_compl is_init⦘ ⊆ ext_sb^? ∪ ext_sb^{-1}.",
        "proof": "rewrite tid_ext_sb at 1.\nunfold cross_rel.\nbasic_solver 12.\n"
    },
    {
        "statement": "Lemma is_init_tid : \n  is_init ⊆₁ fun x => tid x = tid_init.",
        "proof": "unfolder.\nunfold is_init.\nins.\ndesf.\n"
    },
    {
        "statement": "Lemma initninit_in_ext_sb : is_init × (set_compl is_init) ⊆ ext_sb.",
        "proof": "unfold ext_sb.\nbasic_solver.\n"
    },
    {
        "statement": "Lemma actid_alt_isomorphic:\n    isomorphism (fun e => match e with\n                       | InitEvent l => inl l\n                       | ThreadEvent t i => inr (t, i)\n                       end)\n                (fun ae => match ae with\n                        | inl l => InitEvent l\n                        | inr (t, i) => ThreadEvent t i\n                        end).",
        "proof": "split; ins; [destruct a | destruct b as [? | [? ?]]]; auto.\n"
    },
    {
        "statement": "Lemma actid_countable: countable (@set_full actid).",
        "proof": "eapply countable_isomorphic.\n{\neapply isomorphism_sym, actid_alt_isomorphic.\n}\napply countable_sum.\n{\nSet Printing All.\nunfold location, Loc.Loc.t.\napply pos_countable.\n}\napply countable_prod.\n{\nunfold thread_id, Basic.Ident.t.\napply pos_countable.\n}\napply nat_countable.\n"
    },
    {
        "statement": "Lemma ntid_tid_set_inter s thread :\n  s ⊆₁ s ∩₁ NTid_ thread ∪₁ s ∩₁ Tid_ thread.",
        "proof": "ins.\nrewrite <- set_inter_union_r.\nunfolder.\nins.\nsplits; auto.\ndestruct (classic (tid x = thread)); eauto.\n"
    }
]