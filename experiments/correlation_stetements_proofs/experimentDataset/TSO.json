[{"statement":"Lemma CON_WF CON : Wf G.","proof":"apply CON.\n"},{"statement":"Lemma wf_ppoE WF: ppo ≡ ⦗E⦘ ⨾ ppo ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold ppo.\nrewrite (@wf_sbE G) at 1.\nbasic_solver 42.\n"},{"statement":"Lemma wf_fenceE WF: fence ≡ ⦗E⦘ ⨾ fence ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold fence.\nrewrite (@wf_sbE G) at 1 2.\nbasic_solver 42.\n"},{"statement":"Lemma wf_implied_fenceE WF: implied_fence ≡ ⦗E⦘ ⨾ implied_fence ⨾ ⦗E⦘.","proof":"split; [|basic_solver].\nunfold implied_fence.\nrewrite (@wf_sbE G) at 1 2.\nbasic_solver 42.\n"},{"statement":"Lemma wf_hbD WF : hb ≡ ⦗RW⦘ ⨾ hb ⨾ ⦗RW⦘.","proof":"split; [|basic_solver].\napply dom_helper_3.\nunfold hb.\nunfold ppo, fence, implied_fence.\nrewrite (wf_rmwD WF) at 1 2.\nrewrite (wf_rfeD WF) at 1.\nrewrite (wf_coD WF) at 1.\nrewrite (wf_frD WF) at 1.\ngeneralize (R_ex_in_R lab).\nbasic_solver 42.\n"},{"statement":"Lemma wf_ct_hbD WF : hb⁺ ≡ ⦗RW⦘ ⨾ hb⁺ ⨾ ⦗RW⦘.","proof":"split; [|basic_solver].\napply dom_helper_3.\nrewrite (wf_hbD WF).\nrewrite inclusion_ct_seq_eqv_l.\nrewrite inclusion_ct_seq_eqv_r.\nbasic_solver.\n"},{"statement":"Lemma ppo_alt : ppo ≡ \n  ⦗R⦘ ⨾ sb ⨾ ⦗RW⦘ ∪ ⦗W⦘ ⨾ sb ⨾ ⦗W⦘.","proof":"unfold ppo.\nsplit.\nby apply inclusion_minus_l; basic_solver 12.\nby unfolder; ins; desf; splits; eauto 10; intro; type_solver.\n"},{"statement":"Lemma ppo_in_sb : ppo ⊆ sb.","proof":"unfold ppo; basic_solver.\n"},{"statement":"Lemma rel_union_minus_alt {A: Type} (r r': relation A):\n  r ≡ r ∩ r' ∪ r \\ r'.","proof":"split; [| basic_solver].\nred.\nintros x y Rxy.\ndestruct (classic (r' x y)); basic_solver.\n"},{"statement":"Lemma TSO_sb_rf_acyclic WF (TSO: TSOConsistent):\n  acyclic (sb ∪ rf).","proof":"rewrite rfi_union_rfe, <- unionA.\nrewrite union_absorb_r with (r := rfi); [| unfold \"rfi\"; basic_solver].\napply acyclic_utt.\n{\nby apply sb_trans.\n}\n{\napply transitiveI.\nrewrite wf_rfeD; auto.\ntype_solver.\n}\nsplits.\n{\nby apply sb_irr.\n}\n{\nrewrite rfe_in_rf.\nby apply rf_irr.\n}\nrewrite wf_rfeD; [| done].\ndo 2 rewrite <- seqA.\nrewrite acyclic_rotl.\ncdes TSO.\nred.\nred in GHB.\neapply irreflexive_mori; [| by apply GHB].\nred.\nrewrite <- (ct_of_ct hb).\napply clos_trans_mori.\nrewrite <- ct_unit.\nrewrite <- seqA.\napply seq_mori; [| unfold hb; basic_solver].\nrewrite <- ct_step.\nrepeat apply inclusion_union_r1_search.\nunfold ppo.\nunfolder.\nins.\ndesc.\nsplits; vauto.\nintros [? ?].\ntype_solver.\n"}]