{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/MenhirLib/Interpreter.v","fileSamples":[{"statement":"(a : token) (l1 l2 : list token) (buf : buffer) (IH : (l1 ++ l2 ++ buf)%buf = ((l1 ++ l2) ++ buf)%buf) : (a :: l1 ++ l2 ++ buf)%buf = (a :: (l1 ++ l2) ++ buf)%buf.","proofString":"rewrite IH //."},{"statement":"(A : Type) (symbols_to_pop : list symbol) (stk' : stack) (res : A) : forall (stk : stack)\n  (Hp : thunkP (prefix symbols_to_pop (symb_stack_of_stack stk)))\n  (action0 : arrows_right A (map symbol_semantic_type symbols_to_pop)),\npop symbols_to_pop stk Hp action0 = (stk', res) <->\npop_spec symbols_to_pop stk action0 stk' res.","proofString":"induction symbols_to_pop as [|t symbols_to_pop IH]=>stk Hp action /=.\nsplit.\nintros [= <- <-].\nconstructor.\nintros H.\ninversion H.\nby subst_existT.\ndestruct stk as [|[st sem]]=>/=; [by destruct pop_subproof0|].\nremember (pop_subproof t symbols_to_pop stk st Hp) as EQ eqn:eq.\nclear eq.\ngeneralize EQ.\nrevert Hp action.\nrewrite <-(EQ I)=>Hp action ?.\nrewrite cast_eq.\nrewrite IH.\nsplit.\nintros.\nby constructor.\nintros H.\ninversion H.\nby subst_existT."},{"statement":"(A : Type) (stk' : stack) (res : A) (stk : stack) (Hp : thunkP (prefix [] (symb_stack_of_stack stk))) (action : arrows_right A (map symbol_semantic_type [])) : (stk, action) = (stk', res) <-> pop_spec [] stk action stk' res.","proofString":"split.\nintros [= <- <-].\nconstructor.\nintros H.\ninversion H.\nby subst_existT."},{"statement":"(A : Type) (stk' : stack) (res : A) (stk : stack) (Hp : thunkP (prefix [] (symb_stack_of_stack stk))) (action : arrows_right A (map symbol_semantic_type [])) : (stk, action) = (stk', res) -> pop_spec [] stk action stk' res.","proofString":"intros [= <- <-].\nconstructor."},{"statement":"(A : Type) (stk : stack) (Hp : thunkP (prefix [] (symb_stack_of_stack stk))) (action : arrows_right A (map symbol_semantic_type [])) : pop_spec [] stk action stk action.","proofString":"constructor."},{"statement":"(A : Type) (stk' : stack) (res : A) (stk : stack) (Hp : thunkP (prefix [] (symb_stack_of_stack stk))) (action : arrows_right A (map symbol_semantic_type [])) : pop_spec [] stk action stk' res -> (stk, action) = (stk', res).","proofString":"intros H.\ninversion H.\nby subst_existT."},{"statement":"(A : Type) (stk' : stack) (res : A) (stk : stack) (Hp : thunkP (prefix [] (symb_stack_of_stack stk))) (action : arrows_right A (map symbol_semantic_type [])) (H : pop_spec [] stk action stk' res) : (stk, action) = (stk', res).","proofString":"inversion H.\nby subst_existT."},{"statement":"(A : Type) (t : symbol) (symbols_to_pop : list symbol) (stk' : stack) (res : A) (IH : forall (stk0 : stack)\n  (Hp0 : thunkP (prefix symbols_to_pop (symb_stack_of_stack stk0)))\n  (action0 : arrows_right A (map symbol_semantic_type symbols_to_pop)),\npop symbols_to_pop stk0 Hp0 action0 = (stk', res) <->\npop_spec symbols_to_pop stk0 action0 stk' res) (stk : stack) (Hp : thunkP (prefix (t :: symbols_to_pop) (symb_stack_of_stack stk))) (action : arrows_right A (map symbol_semantic_type (t :: symbols_to_pop))) : match\n  stk as stk0\n  return\n    (thunkP (prefix (t :: symbols_to_pop) (symb_stack_of_stack stk0)) ->\n     stack * A)\nwith\n| [] =>\n    fun Hp0 : thunkP (prefix (t :: symbols_to_pop) []) =>\n    False_rect (stack * A) (pop_subproof0 t symbols_to_pop Hp0)\n| s :: stack_rec =>\n    let\n      (state_cur, sem) as s0\n       return\n         (thunkP\n            (prefix (t :: symbols_to_pop)\n               (last_symb_of_non_init_state (projT1 s0)\n                :: symb_stack_of_stack stack_rec)) -> \n          stack * A) := s in\n    fun\n      Hp0 : thunkP\n              (prefix (t :: symbols_to_pop)\n                 (last_symb_of_non_init_state state_cur\n                  :: symb_stack_of_stack stack_rec)) =>\n    pop symbols_to_pop stack_rec\n      (pop_subproof1 t symbols_to_pop stack_rec state_cur Hp0)\n      (action\n         (cast symbol_semantic_type\n            (pop_subproof t symbols_to_pop stack_rec state_cur Hp0) sem))\nend Hp = (stk', res) <-> pop_spec (t :: symbols_to_pop) stk action stk' res.","proofString":"destruct stk as [|[st sem]]=>/=; [by destruct pop_subproof0|].\nremember (pop_subproof t symbols_to_pop stk st Hp) as EQ eqn:eq.\nclear eq.\ngeneralize EQ.\nrevert Hp action.\nrewrite <-(EQ I)=>Hp action ?.\nrewrite cast_eq.\nrewrite IH.\nsplit.\nintros.\nby constructor.\nintros H.\ninversion H.\nby subst_existT."},{"statement":"(A : Type) (t : symbol) (symbols_to_pop : list symbol) (stk' : stack) (res : A) (IH : forall (stk0 : stack)\n  (Hp0 : thunkP (prefix symbols_to_pop (symb_stack_of_stack stk0)))\n  (action0 : arrows_right A (map symbol_semantic_type symbols_to_pop)),\npop symbols_to_pop stk0 Hp0 action0 = (stk', res) <->\npop_spec symbols_to_pop stk0 action0 stk' res) (st : noninitstate) (sem : noninitstate_type st) (stk : list {x : noninitstate & noninitstate_type x}) (Hp : thunkP\n  (prefix (t :: symbols_to_pop)\n     (symb_stack_of_stack (existT noninitstate_type st sem :: stk)))) (action : arrows_right A (map symbol_semantic_type (t :: symbols_to_pop))) : pop symbols_to_pop stk (pop_subproof1 t symbols_to_pop stk st Hp)\n  (action\n     (cast symbol_semantic_type (pop_subproof t symbols_to_pop stk st Hp) sem)) =\n(stk', res) <->\npop_spec (t :: symbols_to_pop) (existT noninitstate_type st sem :: stk)\n  action stk' res.","proofString":"remember (pop_subproof t symbols_to_pop stk st Hp) as EQ eqn:eq.\nclear eq.\ngeneralize EQ.\nrevert Hp action.\nrewrite <-(EQ I)=>Hp action ?.\nrewrite cast_eq.\nrewrite IH.\nsplit.\nintros.\nby constructor.\nintros H.\ninversion H.\nby subst_existT."},{"statement":"(A : Type) (t : symbol) (symbols_to_pop : list symbol) (stk' : stack) (res : A) (IH : forall (stk0 : stack)\n  (Hp0 : thunkP (prefix symbols_to_pop (symb_stack_of_stack stk0)))\n  (action0 : arrows_right A (map symbol_semantic_type symbols_to_pop)),\npop symbols_to_pop stk0 Hp0 action0 = (stk', res) <->\npop_spec symbols_to_pop stk0 action0 stk' res) (st : noninitstate) (sem : noninitstate_type st) (stk : list {x : noninitstate & noninitstate_type x}) (Hp : thunkP\n  (prefix (t :: symbols_to_pop)\n     (symb_stack_of_stack (existT noninitstate_type st sem :: stk)))) (action : arrows_right A (map symbol_semantic_type (t :: symbols_to_pop))) (EQ : thunkP (last_symb_of_non_init_state st = t)) (eq : EQ = pop_subproof t symbols_to_pop stk st Hp) : pop symbols_to_pop stk (pop_subproof1 t symbols_to_pop stk st Hp)\n  (action (cast symbol_semantic_type EQ sem)) = (stk', res) <->\npop_spec (t :: symbols_to_pop) (existT noninitstate_type st sem :: stk)\n  action stk' res.","proofString":"clear eq.\ngeneralize EQ.\nrevert Hp action.\nrewrite <-(EQ I)=>Hp action ?.\nrewrite cast_eq.\nrewrite IH.\nsplit.\nintros.\nby constructor.\nintros H.\ninversion H.\nby subst_existT."},{"statement":"(A : Type) (t : symbol) (symbols_to_pop : list symbol) (stk' : stack) (res : A) (IH : forall (stk0 : stack)\n  (Hp0 : thunkP (prefix symbols_to_pop (symb_stack_of_stack stk0)))\n  (action0 : arrows_right A (map symbol_semantic_type symbols_to_pop)),\npop symbols_to_pop stk0 Hp0 action0 = (stk', res) <->\npop_spec symbols_to_pop stk0 action0 stk' res) (st : noninitstate) (sem : noninitstate_type st) (stk : list {x : noninitstate & noninitstate_type x}) (Hp : thunkP\n  (prefix (t :: symbols_to_pop)\n     (symb_stack_of_stack (existT noninitstate_type st sem :: stk)))) (action : arrows_right A (map symbol_semantic_type (t :: symbols_to_pop))) (EQ : thunkP (last_symb_of_non_init_state st = t)) : pop symbols_to_pop stk (pop_subproof1 t symbols_to_pop stk st Hp)\n  (action (cast symbol_semantic_type EQ sem)) = (stk', res) <->\npop_spec (t :: symbols_to_pop) (existT noninitstate_type st sem :: stk)\n  action stk' res.","proofString":"generalize EQ.\nrevert Hp action.\nrewrite <-(EQ I)=>Hp action ?.\nrewrite cast_eq.\nrewrite IH.\nsplit.\nintros.\nby constructor.\nintros H.\ninversion H.\nby subst_existT."},{"statement":"(A : Type) (t : symbol) (symbols_to_pop : list symbol) (stk' : stack) (res : A) (IH : forall (stk0 : stack)\n  (Hp0 : thunkP (prefix symbols_to_pop (symb_stack_of_stack stk0)))\n  (action0 : arrows_right A (map symbol_semantic_type symbols_to_pop)),\npop symbols_to_pop stk0 Hp0 action0 = (stk', res) <->\npop_spec symbols_to_pop stk0 action0 stk' res) (st : noninitstate) (sem : noninitstate_type st) (stk : list {x : noninitstate & noninitstate_type x}) (Hp : thunkP\n  (prefix (t :: symbols_to_pop)\n     (symb_stack_of_stack (existT noninitstate_type st sem :: stk)))) (action : arrows_right A (map symbol_semantic_type (t :: symbols_to_pop))) (EQ : thunkP (last_symb_of_non_init_state st = t)) : forall EQ0 : thunkP (last_symb_of_non_init_state st = t),\npop symbols_to_pop stk (pop_subproof1 t symbols_to_pop stk st Hp)\n  (action (cast symbol_semantic_type EQ0 sem)) = (\nstk', res) <->\npop_spec (t :: symbols_to_pop) (existT noninitstate_type st sem :: stk)\n  action stk' res.","proofString":"revert Hp action.\nrewrite <-(EQ I)=>Hp action ?.\nrewrite cast_eq.\nrewrite IH.\nsplit.\nintros.\nby constructor.\nintros H.\ninversion H.\nby subst_existT."},{"statement":"(A : Type) (t : symbol) (symbols_to_pop : list symbol) (stk' : stack) (res : A) (IH : forall (stk0 : stack)\n  (Hp : thunkP (prefix symbols_to_pop (symb_stack_of_stack stk0)))\n  (action0 : arrows_right A (map symbol_semantic_type symbols_to_pop)),\npop symbols_to_pop stk0 Hp action0 = (stk', res) <->\npop_spec symbols_to_pop stk0 action0 stk' res) (st : noninitstate) (sem : noninitstate_type st) (stk : list {x : noninitstate & noninitstate_type x}) (EQ : thunkP (last_symb_of_non_init_state st = t)) : forall\n  (Hp : thunkP\n          (prefix (t :: symbols_to_pop)\n             (symb_stack_of_stack (existT noninitstate_type st sem :: stk))))\n  (action0 : arrows_right A (map symbol_semantic_type (t :: symbols_to_pop)))\n  (EQ0 : thunkP (last_symb_of_non_init_state st = t)),\npop symbols_to_pop stk (pop_subproof1 t symbols_to_pop stk st Hp)\n  (action0 (cast symbol_semantic_type EQ0 sem)) = (\nstk', res) <->\npop_spec (t :: symbols_to_pop) (existT noninitstate_type st sem :: stk)\n  action0 stk' res.","proofString":"rewrite <-(EQ I)=>Hp action ?.\nrewrite cast_eq.\nrewrite IH.\nsplit.\nintros.\nby constructor.\nintros H.\ninversion H.\nby subst_existT."},{"statement":"(symbols_to_pop : list symbol) : forall (stk : stack)\n  (Hp : thunkP (prefix symbols_to_pop (symb_stack_of_stack stk))) \n  (A : Type)\n  (action0 : arrows_right A (map symbol_semantic_type symbols_to_pop)),\nstack_invariant stk ->\nstack_invariant (fst (pop symbols_to_pop stk Hp action0)).","proofString":"induction symbols_to_pop as [|t q IH]=>//=.\nintros stk Hp A action Hi.\ndestruct Hi as [stack Hp' Hpp [|state st stk']].\ndestruct pop_subproof0.\nnow apply IH."},{"statement":"(t : symbol) (q : list symbol) (IH : forall (stk : stack) (Hp : thunkP (prefix q (symb_stack_of_stack stk)))\n  (A : Type) (action0 : arrows_right A (map symbol_semantic_type q)),\nstack_invariant stk -> stack_invariant (fst (pop q stk Hp action0))) : forall (stk : stack)\n  (Hp : thunkP (prefix (t :: q) (symb_stack_of_stack stk))) \n  (A : Type)\n  (action0 : symbol_semantic_type t ->\n             arrows_right A (map symbol_semantic_type q)),\nstack_invariant stk ->\nstack_invariant\n  (fst\n     (match\n        stk as stk0\n        return\n          (thunkP (prefix (t :: q) (symb_stack_of_stack stk0)) -> stack * A)\n      with\n      | [] =>\n          fun Hp0 : thunkP (prefix (t :: q) []) =>\n          False_rect (stack * A) (pop_subproof0 t q Hp0)\n      | s :: stack_rec =>\n          let\n            (state_cur, sem) as s0\n             return\n               (thunkP\n                  (prefix (t :: q)\n                     (last_symb_of_non_init_state (projT1 s0)\n                      :: symb_stack_of_stack stack_rec)) -> \n                stack * A) := s in\n          fun\n            Hp0 : thunkP\n                    (prefix (t :: q)\n                       (last_symb_of_non_init_state state_cur\n                        :: symb_stack_of_stack stack_rec)) =>\n          pop q stack_rec (pop_subproof1 t q stack_rec state_cur Hp0)\n            (action0\n               (cast symbol_semantic_type\n                  (pop_subproof t q stack_rec state_cur Hp0) sem))\n      end Hp)).","proofString":"intros stk Hp A action Hi.\ndestruct Hi as [stack Hp' Hpp [|state st stk']].\ndestruct pop_subproof0.\nnow apply IH."},{"statement":"(t : symbol) (q : list symbol) (IH : forall (stk0 : stack) (Hp0 : thunkP (prefix q (symb_stack_of_stack stk0)))\n  (A0 : Type) (action0 : arrows_right A0 (map symbol_semantic_type q)),\nstack_invariant stk0 -> stack_invariant (fst (pop q stk0 Hp0 action0))) (stk : stack) (Hp : thunkP (prefix (t :: q) (symb_stack_of_stack stk))) (A : Type) (action : symbol_semantic_type t -> arrows_right A (map symbol_semantic_type q)) (Hi : stack_invariant stk) : stack_invariant\n  (fst\n     (match\n        stk as stk0\n        return\n          (thunkP (prefix (t :: q) (symb_stack_of_stack stk0)) -> stack * A)\n      with\n      | [] =>\n          fun Hp0 : thunkP (prefix (t :: q) []) =>\n          False_rect (stack * A) (pop_subproof0 t q Hp0)\n      | s :: stack_rec =>\n          let\n            (state_cur, sem) as s0\n             return\n               (thunkP\n                  (prefix (t :: q)\n                     (last_symb_of_non_init_state (projT1 s0)\n                      :: symb_stack_of_stack stack_rec)) -> \n                stack * A) := s in\n          fun\n            Hp0 : thunkP\n                    (prefix (t :: q)\n                       (last_symb_of_non_init_state state_cur\n                        :: symb_stack_of_stack stack_rec)) =>\n          pop q stack_rec (pop_subproof1 t q stack_rec state_cur Hp0)\n            (action\n               (cast symbol_semantic_type\n                  (pop_subproof t q stack_rec state_cur Hp0) sem))\n      end Hp)).","proofString":"destruct Hi as [stack Hp' Hpp [|state st stk']].\ndestruct pop_subproof0.\nnow apply IH."},{"statement":"(t : symbol) (q : list symbol) (IH : forall (stk : Make.stack) (Hp0 : thunkP (prefix q (symb_stack_of_stack stk)))\n  (A0 : Type) (action0 : arrows_right A0 (map symbol_semantic_type q)),\nstack_invariant stk -> stack_invariant (fst (pop q stk Hp0 action0))) (Hp : thunkP (prefix (t :: q) (symb_stack_of_stack []))) (A : Type) (action : symbol_semantic_type t -> arrows_right A (map symbol_semantic_type q)) (stack : Make.stack) (Hp' : prefix (head_symbs_of_state (state_of_stack stack))\n  (symb_stack_of_stack stack)) (Hpp : prefix_pred (head_states_of_state (state_of_stack stack))\n  (state_stack_of_stack stack)) : stack_invariant (fst (False_rect (Make.stack * A) (pop_subproof0 t q Hp))).","proofString":"destruct pop_subproof0."},{"statement":"(t : symbol) (q : list symbol) (IH : forall (stk : Make.stack) (Hp0 : thunkP (prefix q (symb_stack_of_stack stk)))\n  (A0 : Type) (action0 : arrows_right A0 (map symbol_semantic_type q)),\nstack_invariant stk -> stack_invariant (fst (pop q stk Hp0 action0))) (state : noninitstate) (st : noninitstate_type state) (stk' : Make.stack) (Hp : thunkP\n  (prefix (t :: q)\n     (symb_stack_of_stack (existT noninitstate_type state st :: stk')))) (A : Type) (action : symbol_semantic_type t -> arrows_right A (map symbol_semantic_type q)) (stack : Make.stack) (Hp' : prefix (head_symbs_of_state (state_of_stack stack))\n  (symb_stack_of_stack stack)) (Hpp : prefix_pred (head_states_of_state (state_of_stack stack))\n  (state_stack_of_stack stack)) (H : stack_invariant stk') : stack_invariant\n  (fst\n     (pop q stk' (pop_subproof1 t q stk' state Hp)\n        (action\n           (cast symbol_semantic_type (pop_subproof t q stk' state Hp) st)))).","proofString":"now apply IH."},{"statement":"(symbols_to_pop : list symbol) : forall (stk : stack)\n  (Hp : thunkP (prefix symbols_to_pop (symb_stack_of_stack stk))) \n  (A : Type)\n  (action0 : arrows_right A (map symbol_semantic_type symbols_to_pop))\n  (lpred : list (state -> bool)),\nprefix_pred lpred (state_stack_of_stack stk) ->\nlet stk' := fst (pop symbols_to_pop stk Hp action0) in\nstate_valid_after_pop (state_of_stack stk') symbols_to_pop lpred.","proofString":"induction symbols_to_pop as [|t q IH]=>/=.\nintros stk Hp A a lpred Hpp.\ndestruct lpred as [|pred lpred]; constructor.\ninversion Hpp as [|? lpred' ? pred' Himpl Hpp' eq1 eq2]; subst.\nspecialize (Himpl (state_of_stack stk)).\ndestruct (pred' (state_of_stack stk)) as [] eqn:Heqpred'=>//.\ndestruct stk as [|[]]; simpl in *.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate.\nintros stk Hp A a lpred Hpp.\ndestruct stk as [|[] stk]=>//=.\ndestruct pop_subproof0.\ndestruct lpred as [|pred lpred]; [by constructor|].\nconstructor.\napply IH.\nby inversion Hpp."},{"statement":"forall stk : stack,\nthunkP (prefix [] (symb_stack_of_stack stk)) ->\nforall A : Type,\nA ->\nforall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk) [] lpred.","proofString":"intros stk Hp A a lpred Hpp.\ndestruct lpred as [|pred lpred]; constructor.\ninversion Hpp as [|? lpred' ? pred' Himpl Hpp' eq1 eq2]; subst.\nspecialize (Himpl (state_of_stack stk)).\ndestruct (pred' (state_of_stack stk)) as [] eqn:Heqpred'=>//.\ndestruct stk as [|[]]; simpl in *.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate."},{"statement":"(stk : stack) (Hp : thunkP (prefix [] (symb_stack_of_stack stk))) (A : Type) (a : A) (lpred : list (state -> bool)) (Hpp : prefix_pred lpred (state_stack_of_stack stk)) : state_valid_after_pop (state_of_stack stk) [] lpred.","proofString":"destruct lpred as [|pred lpred]; constructor.\ninversion Hpp as [|? lpred' ? pred' Himpl Hpp' eq1 eq2]; subst.\nspecialize (Himpl (state_of_stack stk)).\ndestruct (pred' (state_of_stack stk)) as [] eqn:Heqpred'=>//.\ndestruct stk as [|[]]; simpl in *.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate."},{"statement":"(stk : stack) (Hp : thunkP (prefix [] (symb_stack_of_stack stk))) (A : Type) (a : A) (pred : state -> bool) (lpred : list (state -> bool)) (Hpp : prefix_pred (pred :: lpred) (state_stack_of_stack stk)) : pred (state_of_stack stk) = true.","proofString":"inversion Hpp as [|? lpred' ? pred' Himpl Hpp' eq1 eq2]; subst.\nspecialize (Himpl (state_of_stack stk)).\ndestruct (pred' (state_of_stack stk)) as [] eqn:Heqpred'=>//.\ndestruct stk as [|[]]; simpl in *.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate."},{"statement":"(stk : stack) (Hp : thunkP (prefix [] (symb_stack_of_stack stk))) (A : Type) (a : A) (pred : state -> bool) (lpred : list (state -> bool)) (Hpp : prefix_pred (pred :: lpred) (state_stack_of_stack stk)) (lpred' : list (state -> bool)) (pred' : state -> bool) (Himpl : forall x : state, implb (pred' x) (pred x) = true) (Hpp' : prefix_pred lpred lpred') (eq2 : pred' :: lpred' = state_stack_of_stack stk) : pred (state_of_stack stk) = true.","proofString":"specialize (Himpl (state_of_stack stk)).\ndestruct (pred' (state_of_stack stk)) as [] eqn:Heqpred'=>//.\ndestruct stk as [|[]]; simpl in *.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate."},{"statement":"(stk : stack) (Hp : thunkP (prefix [] (symb_stack_of_stack stk))) (A : Type) (a : A) (pred : state -> bool) (lpred : list (state -> bool)) (Hpp : prefix_pred (pred :: lpred) (state_stack_of_stack stk)) (lpred' : list (state -> bool)) (pred' : state -> bool) (Himpl : implb (pred' (state_of_stack stk)) (pred (state_of_stack stk)) = true) (Hpp' : prefix_pred lpred lpred') (eq2 : pred' :: lpred' = state_stack_of_stack stk) : pred (state_of_stack stk) = true.","proofString":"destruct (pred' (state_of_stack stk)) as [] eqn:Heqpred'=>//.\ndestruct stk as [|[]]; simpl in *.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate."},{"statement":"(stk : stack) (Hp : thunkP (prefix [] (symb_stack_of_stack stk))) (A : Type) (a : A) (pred : state -> bool) (lpred : list (state -> bool)) (Hpp : prefix_pred (pred :: lpred) (state_stack_of_stack stk)) (lpred' : list (state -> bool)) (pred' : state -> bool) (Heqpred' : pred' (state_of_stack stk) = false) (Himpl : implb false (pred (state_of_stack stk)) = true) (Hpp' : prefix_pred lpred lpred') (eq2 : pred' :: lpred' = state_stack_of_stack stk) : pred (state_of_stack stk) = true.","proofString":"destruct stk as [|[]]; simpl in *.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate.\ninversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate."},{"statement":"(Hp : thunkP (prefix [] [])) (A : Type) (a : A) (pred : state -> bool) (lpred : list (state -> bool)) (Hpp : prefix_pred (pred :: lpred) (state_stack_of_stack [])) (lpred' : list (state -> bool)) (pred' : state -> bool) (Heqpred' : pred' init = false) (Himpl : true = true) (Hpp' : prefix_pred lpred lpred') (eq2 : pred' :: lpred' = state_stack_of_stack []) : pred init = true.","proofString":"inversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate."},{"statement":"(Hp : thunkP (prefix [] [])) (A : Type) (a : A) (pred : state -> bool) (lpred : list (state -> bool)) (Hpp : prefix_pred (pred :: lpred) (state_stack_of_stack [])) (Heqpred' : singleton_state_pred init init = false) (Himpl : true = true) (Hpp' : prefix_pred lpred []) : pred init = true.","proofString":"unfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate."},{"statement":"(Hp : thunkP (prefix [] [])) (A : Type) (a : A) (pred : state -> bool) (lpred : list (state -> bool)) (Hpp : prefix_pred (pred :: lpred) (state_stack_of_stack [])) (Heqpred' : match compare init init with\n| Eq => true\n| _ => false\nend = false) (Himpl : true = true) (Hpp' : prefix_pred lpred []) : pred init = true.","proofString":"now rewrite compare_refl in Heqpred'; discriminate."},{"statement":"(x : noninitstate) (n : noninitstate_type x) (stk : list {x : noninitstate & noninitstate_type x}) (Hp : thunkP (prefix [] (last_symb_of_non_init_state x :: symb_stack_of_stack stk))) (A : Type) (a : A) (pred : state -> bool) (lpred : list (state -> bool)) (Hpp : prefix_pred (pred :: lpred)\n  (state_stack_of_stack (existT noninitstate_type x n :: stk))) (lpred' : list (state -> bool)) (pred' : state -> bool) (Heqpred' : pred' x = false) (Himpl : true = true) (Hpp' : prefix_pred lpred lpred') (eq2 : pred' :: lpred' = state_stack_of_stack (existT noninitstate_type x n :: stk)) : pred x = true.","proofString":"inversion eq2; subst; clear eq2.\nunfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate."},{"statement":"(x : noninitstate) (n : noninitstate_type x) (stk : list {x : noninitstate & noninitstate_type x}) (Hp : thunkP (prefix [] (last_symb_of_non_init_state x :: symb_stack_of_stack stk))) (A : Type) (a : A) (pred : state -> bool) (lpred : list (state -> bool)) (Hpp : prefix_pred (pred :: lpred)\n  (state_stack_of_stack (existT noninitstate_type x n :: stk))) (Heqpred' : singleton_state_pred x x = false) (Himpl : true = true) (Hpp' : prefix_pred lpred\n  (map\n     (fun cell : {x : noninitstate & noninitstate_type x} =>\n      singleton_state_pred (projT1 cell)) stk ++ [\n   singleton_state_pred init])) : pred x = true.","proofString":"unfold singleton_state_pred in Heqpred'.\nnow rewrite compare_refl in Heqpred'; discriminate."},{"statement":"(x : noninitstate) (n : noninitstate_type x) (stk : list {x : noninitstate & noninitstate_type x}) (Hp : thunkP (prefix [] (last_symb_of_non_init_state x :: symb_stack_of_stack stk))) (A : Type) (a : A) (pred : state -> bool) (lpred : list (state -> bool)) (Hpp : prefix_pred (pred :: lpred)\n  (state_stack_of_stack (existT noninitstate_type x n :: stk))) (Heqpred' : match compare x x with\n| Eq => true\n| _ => false\nend = false) (Himpl : true = true) (Hpp' : prefix_pred lpred\n  (map\n     (fun cell : {x : noninitstate & noninitstate_type x} =>\n      singleton_state_pred (projT1 cell)) stk ++ [\n   singleton_state_pred init])) : pred x = true.","proofString":"now rewrite compare_refl in Heqpred'; discriminate."},{"statement":"(t : symbol) (q : list symbol) (IH : forall (stk : stack) (Hp : thunkP (prefix q (symb_stack_of_stack stk)))\n  (A : Type) (action0 : arrows_right A (map symbol_semantic_type q))\n  (lpred : list (state -> bool)),\nprefix_pred lpred (state_stack_of_stack stk) ->\nlet stk' := fst (pop q stk Hp action0) in\nstate_valid_after_pop (state_of_stack stk') q lpred) : forall (stk : stack)\n  (Hp : thunkP (prefix (t :: q) (symb_stack_of_stack stk))) \n  (A : Type)\n  (action0 : symbol_semantic_type t ->\n             arrows_right A (map symbol_semantic_type q))\n  (lpred : list (state -> bool)),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop\n  (state_of_stack\n     (fst\n        (match\n           stk as stk0\n           return\n             (thunkP (prefix (t :: q) (symb_stack_of_stack stk0)) ->\n              stack * A)\n         with\n         | [] =>\n             fun Hp0 : thunkP (prefix (t :: q) []) =>\n             False_rect (stack * A) (pop_subproof0 t q Hp0)\n         | s :: stack_rec =>\n             let\n               (state_cur, sem) as s0\n                return\n                  (thunkP\n                     (prefix (t :: q)\n                        (last_symb_of_non_init_state (projT1 s0)\n                         :: symb_stack_of_stack stack_rec)) -> \n                   stack * A) := s in\n             fun\n               Hp0 : thunkP\n                       (prefix (t :: q)\n                          (last_symb_of_non_init_state state_cur\n                           :: symb_stack_of_stack stack_rec)) =>\n             pop q stack_rec (pop_subproof1 t q stack_rec state_cur Hp0)\n               (action0\n                  (cast symbol_semantic_type\n                     (pop_subproof t q stack_rec state_cur Hp0) sem))\n         end Hp))) (t :: q) lpred.","proofString":"intros stk Hp A a lpred Hpp.\ndestruct stk as [|[] stk]=>//=.\ndestruct pop_subproof0.\ndestruct lpred as [|pred lpred]; [by constructor|].\nconstructor.\napply IH.\nby inversion Hpp."},{"statement":"(t : symbol) (q : list symbol) (IH : forall (stk0 : stack) (Hp0 : thunkP (prefix q (symb_stack_of_stack stk0)))\n  (A0 : Type) (action0 : arrows_right A0 (map symbol_semantic_type q))\n  (lpred0 : list (state -> bool)),\nprefix_pred lpred0 (state_stack_of_stack stk0) ->\nlet stk' := fst (pop q stk0 Hp0 action0) in\nstate_valid_after_pop (state_of_stack stk') q lpred0) (stk : stack) (Hp : thunkP (prefix (t :: q) (symb_stack_of_stack stk))) (A : Type) (a : symbol_semantic_type t -> arrows_right A (map symbol_semantic_type q)) (lpred : list (state -> bool)) (Hpp : prefix_pred lpred (state_stack_of_stack stk)) : state_valid_after_pop\n  (state_of_stack\n     (fst\n        (match\n           stk as stk0\n           return\n             (thunkP (prefix (t :: q) (symb_stack_of_stack stk0)) ->\n              stack * A)\n         with\n         | [] =>\n             fun Hp0 : thunkP (prefix (t :: q) []) =>\n             False_rect (stack * A) (pop_subproof0 t q Hp0)\n         | s :: stack_rec =>\n             let\n               (state_cur, sem) as s0\n                return\n                  (thunkP\n                     (prefix (t :: q)\n                        (last_symb_of_non_init_state (projT1 s0)\n                         :: symb_stack_of_stack stack_rec)) -> \n                   stack * A) := s in\n             fun\n               Hp0 : thunkP\n                       (prefix (t :: q)\n                          (last_symb_of_non_init_state state_cur\n                           :: symb_stack_of_stack stack_rec)) =>\n             pop q stack_rec (pop_subproof1 t q stack_rec state_cur Hp0)\n               (a\n                  (cast symbol_semantic_type\n                     (pop_subproof t q stack_rec state_cur Hp0) sem))\n         end Hp))) (t :: q) lpred.","proofString":"destruct stk as [|[] stk]=>//=.\ndestruct pop_subproof0.\ndestruct lpred as [|pred lpred]; [by constructor|].\nconstructor.\napply IH.\nby inversion Hpp."},{"statement":"(t : symbol) (q : list symbol) (IH : forall (stk : stack) (Hp0 : thunkP (prefix q (symb_stack_of_stack stk)))\n  (A0 : Type) (action0 : arrows_right A0 (map symbol_semantic_type q))\n  (lpred0 : list (state -> bool)),\nprefix_pred lpred0 (state_stack_of_stack stk) ->\nlet stk' := fst (pop q stk Hp0 action0) in\nstate_valid_after_pop (state_of_stack stk') q lpred0) (Hp : thunkP (prefix (t :: q) (symb_stack_of_stack []))) (A : Type) (a : symbol_semantic_type t -> arrows_right A (map symbol_semantic_type q)) (lpred : list (state -> bool)) (Hpp : prefix_pred lpred (state_stack_of_stack [])) : state_valid_after_pop\n  (state_of_stack (fst (False_rect (stack * A) (pop_subproof0 t q Hp))))\n  (t :: q) lpred.","proofString":"destruct pop_subproof0."},{"statement":"(t : symbol) (q : list symbol) (IH : forall (stk0 : stack) (Hp0 : thunkP (prefix q (symb_stack_of_stack stk0)))\n  (A0 : Type) (action0 : arrows_right A0 (map symbol_semantic_type q))\n  (lpred0 : list (state -> bool)),\nprefix_pred lpred0 (state_stack_of_stack stk0) ->\nlet stk' := fst (pop q stk0 Hp0 action0) in\nstate_valid_after_pop (state_of_stack stk') q lpred0) (x : noninitstate) (n : noninitstate_type x) (stk : list {x : noninitstate & noninitstate_type x}) (Hp : thunkP\n  (prefix (t :: q)\n     (symb_stack_of_stack (existT noninitstate_type x n :: stk)))) (A : Type) (a : symbol_semantic_type t -> arrows_right A (map symbol_semantic_type q)) (lpred : list (state -> bool)) (Hpp : prefix_pred lpred\n  (state_stack_of_stack (existT noninitstate_type x n :: stk))) : state_valid_after_pop\n  (state_of_stack\n     (fst\n        (pop q stk (pop_subproof1 t q stk x Hp)\n           (a (cast symbol_semantic_type (pop_subproof t q stk x Hp) n)))))\n  (t :: q) lpred.","proofString":"destruct lpred as [|pred lpred]; [by constructor|].\nconstructor.\napply IH.\nby inversion Hpp."},{"statement":"(t : symbol) (q : list symbol) (IH : forall (stk0 : stack) (Hp0 : thunkP (prefix q (symb_stack_of_stack stk0)))\n  (A0 : Type) (action0 : arrows_right A0 (map symbol_semantic_type q))\n  (lpred0 : list (state -> bool)),\nprefix_pred lpred0 (state_stack_of_stack stk0) ->\nlet stk' := fst (pop q stk0 Hp0 action0) in\nstate_valid_after_pop (state_of_stack stk') q lpred0) (x : noninitstate) (n : noninitstate_type x) (stk : list {x : noninitstate & noninitstate_type x}) (Hp : thunkP\n  (prefix (t :: q)\n     (symb_stack_of_stack (existT noninitstate_type x n :: stk)))) (A : Type) (a : symbol_semantic_type t -> arrows_right A (map symbol_semantic_type q)) (pred : state -> bool) (lpred : list (state -> bool)) (Hpp : prefix_pred (pred :: lpred)\n  (state_stack_of_stack (existT noninitstate_type x n :: stk))) : state_valid_after_pop\n  (state_of_stack\n     (fst\n        (pop q stk (pop_subproof1 t q stk x Hp)\n           (a (cast symbol_semantic_type (pop_subproof t q stk x Hp) n)))))\n  (t :: q) (pred :: lpred).","proofString":"constructor.\napply IH.\nby inversion Hpp."},{"statement":"(t : symbol) (q : list symbol) (IH : forall (stk0 : stack) (Hp0 : thunkP (prefix q (symb_stack_of_stack stk0)))\n  (A0 : Type) (action0 : arrows_right A0 (map symbol_semantic_type q))\n  (lpred0 : list (state -> bool)),\nprefix_pred lpred0 (state_stack_of_stack stk0) ->\nlet stk' := fst (pop q stk0 Hp0 action0) in\nstate_valid_after_pop (state_of_stack stk') q lpred0) (x : noninitstate) (n : noninitstate_type x) (stk : list {x : noninitstate & noninitstate_type x}) (Hp : thunkP\n  (prefix (t :: q)\n     (symb_stack_of_stack (existT noninitstate_type x n :: stk)))) (A : Type) (a : symbol_semantic_type t -> arrows_right A (map symbol_semantic_type q)) (pred : state -> bool) (lpred : list (state -> bool)) (Hpp : prefix_pred (pred :: lpred)\n  (state_stack_of_stack (existT noninitstate_type x n :: stk))) : state_valid_after_pop\n  (state_of_stack\n     (fst\n        (pop q stk (pop_subproof1 t q stk x Hp)\n           (a (cast symbol_semantic_type (pop_subproof t q stk x Hp) n))))) q\n  lpred.","proofString":"apply IH.\nby inversion Hpp."},{"statement":"(t : symbol) (q : list symbol) (IH : forall (stk0 : stack) (Hp0 : thunkP (prefix q (symb_stack_of_stack stk0)))\n  (A0 : Type) (action0 : arrows_right A0 (map symbol_semantic_type q))\n  (lpred0 : list (state -> bool)),\nprefix_pred lpred0 (state_stack_of_stack stk0) ->\nlet stk' := fst (pop q stk0 Hp0 action0) in\nstate_valid_after_pop (state_of_stack stk') q lpred0) (x : noninitstate) (n : noninitstate_type x) (stk : list {x : noninitstate & noninitstate_type x}) (Hp : thunkP\n  (prefix (t :: q)\n     (symb_stack_of_stack (existT noninitstate_type x n :: stk)))) (A : Type) (a : symbol_semantic_type t -> arrows_right A (map symbol_semantic_type q)) (pred : state -> bool) (lpred : list (state -> bool)) (Hpp : prefix_pred (pred :: lpred)\n  (state_stack_of_stack (existT noninitstate_type x n :: stk))) : prefix_pred lpred (state_stack_of_stack stk).","proofString":"by inversion Hpp."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) : (let\n '(stk'0, sem) as ss :=\n  pop (prod_rhs_rev prod) stk (reduce_step_subproof stk prod Hv Hi)\n    (prod_action prod)\n  return\n    (thunkP\n       (state_valid_after_pop (state_of_stack (fst ss)) \n          (prod_rhs_rev prod) (head_states_of_state (state_of_stack stk))) ->\n     step_result) in\n  fun\n    Hval' : thunkP\n              (state_valid_after_pop (state_of_stack (fst (stk'0, sem)))\n                 (prod_rhs_rev prod)\n                 (head_states_of_state (state_of_stack stk))) =>\n  match\n    goto_table (state_of_stack stk'0) (prod_lhs prod) as goto\n    return\n      (thunkP\n         (goto = None ->\n          match state_of_stack stk'0 with\n          | Init i => prod_lhs prod = start_nt i\n          | Ninit _ => False\n          end) -> step_result)\n  with\n  | Some s =>\n      let\n        (state_new, e) as s0\n         return\n           (thunkP\n              (Some s0 = None ->\n               match state_of_stack stk'0 with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) -> step_result) := s in\n      fun\n        _ : thunkP\n              (Some\n                 (exist\n                    (fun s0 : noninitstate =>\n                     NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                    state_new e) = None ->\n               match state_of_stack stk'0 with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) =>\n      Progress_sr\n        (existT noninitstate_type state_new\n           (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n              (last_symb_of_non_init_state state_new) e) :: stk'0) buffer\n  | None =>\n      fun\n        Hval : thunkP\n                 (None = None ->\n                  match state_of_stack stk'0 with\n                  | Init i => prod_lhs prod = start_nt i\n                  | Ninit _ => False\n                  end) =>\n      Accept_sr\n        (cast symbol_semantic_type (reduce_step_subproof0 prod stk'0 Hval)\n           sem) buffer\n  end (fun _ : True => reduce_step_subproof1 stk prod Hv stk'0 Hval'))\n  (fun _ : True =>\n   pop_state_valid (prod_rhs_rev prod) stk\n     (reduce_step_subproof stk prod Hv Hi)\n     (symbol_semantic_type (NT (prod_lhs prod))) (prod_action prod)\n     (head_states_of_state (state_of_stack stk))\n     (reduce_step_subproof2 stk Hi)) = Progress_sr stk' buffer' ->\nstack_invariant stk'.","proofString":"match goal with  | |- context [pop ?symbols_to_pop stk ?Hp ?action] =>    assert (Hi':=pop_preserves_invariant symbols_to_pop stk Hp _ action (Hi I));    generalize (pop_state_valid symbols_to_pop stk Hp _ action)  end.\ndestruct pop as [stk0 sem]=>/=.\nsimpl in Hi'.\nintros Hv'.\nassert (Hgoto1:=goto_head_symbs (state_of_stack stk0) (prod_lhs prod)).\nassert (Hgoto2:=goto_past_state (state_of_stack stk0) (prod_lhs prod)).\nmatch goal with | |- context [fun _ : True => ?X] => generalize X end.\ndestruct goto_table as [[state_new e]|] eqn:EQgoto=>//.\nintros _ [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hgoto1.\nby destruct Hi'.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hgoto2.\nby destruct Hi'.\nby constructor."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (Hi' : stack_invariant\n  (fst\n     (pop (prod_rhs_rev prod) stk (reduce_step_subproof stk prod Hv Hi)\n        (prod_action prod)))) : forall\n  s : forall lpred : list (state -> bool),\n      prefix_pred lpred (state_stack_of_stack stk) ->\n      let stk'0 :=\n        fst\n          (pop (prod_rhs_rev prod) stk (reduce_step_subproof stk prod Hv Hi)\n             (prod_action prod)) in\n      state_valid_after_pop (state_of_stack stk'0) (prod_rhs_rev prod) lpred,\n(let\n '(stk'0, sem) as ss :=\n  pop (prod_rhs_rev prod) stk (reduce_step_subproof stk prod Hv Hi)\n    (prod_action prod)\n  return\n    (thunkP\n       (state_valid_after_pop (state_of_stack (fst ss)) \n          (prod_rhs_rev prod) (head_states_of_state (state_of_stack stk))) ->\n     step_result) in\n  fun\n    Hval' : thunkP\n              (state_valid_after_pop (state_of_stack (fst (stk'0, sem)))\n                 (prod_rhs_rev prod)\n                 (head_states_of_state (state_of_stack stk))) =>\n  match\n    goto_table (state_of_stack stk'0) (prod_lhs prod) as goto\n    return\n      (thunkP\n         (goto = None ->\n          match state_of_stack stk'0 with\n          | Init i => prod_lhs prod = start_nt i\n          | Ninit _ => False\n          end) -> step_result)\n  with\n  | Some s0 =>\n      let\n        (state_new, e) as s1\n         return\n           (thunkP\n              (Some s1 = None ->\n               match state_of_stack stk'0 with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) -> step_result) := s0 in\n      fun\n        _ : thunkP\n              (Some\n                 (exist\n                    (fun s1 : noninitstate =>\n                     NT (prod_lhs prod) = last_symb_of_non_init_state s1)\n                    state_new e) = None ->\n               match state_of_stack stk'0 with\n               | Init i => prod_lhs prod = start_nt i\n               | Ninit _ => False\n               end) =>\n      Progress_sr\n        (existT noninitstate_type state_new\n           (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n              (last_symb_of_non_init_state state_new) e) :: stk'0) buffer\n  | None =>\n      fun\n        Hval : thunkP\n                 (None = None ->\n                  match state_of_stack stk'0 with\n                  | Init i => prod_lhs prod = start_nt i\n                  | Ninit _ => False\n                  end) =>\n      Accept_sr\n        (cast symbol_semantic_type (reduce_step_subproof0 prod stk'0 Hval)\n           sem) buffer\n  end (fun _ : True => reduce_step_subproof1 stk prod Hv stk'0 Hval'))\n  (fun _ : True =>\n   s (head_states_of_state (state_of_stack stk))\n     (reduce_step_subproof2 stk Hi)) = Progress_sr stk' buffer' ->\nstack_invariant stk'.","proofString":"destruct pop as [stk0 sem]=>/=.\nsimpl in Hi'.\nintros Hv'.\nassert (Hgoto1:=goto_head_symbs (state_of_stack stk0) (prod_lhs prod)).\nassert (Hgoto2:=goto_past_state (state_of_stack stk0) (prod_lhs prod)).\nmatch goal with | |- context [fun _ : True => ?X] => generalize X end.\ndestruct goto_table as [[state_new e]|] eqn:EQgoto=>//.\nintros _ [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hgoto1.\nby destruct Hi'.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hgoto2.\nby destruct Hi'.\nby constructor."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant (fst (stk0, sem))) : forall\n  s : forall lpred : list (state -> bool),\n      prefix_pred lpred (state_stack_of_stack stk) ->\n      state_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred,\nmatch\n  goto_table (state_of_stack stk0) (prod_lhs prod) as goto\n  return\n    (thunkP\n       (goto = None ->\n        match state_of_stack stk0 with\n        | Init i => prod_lhs prod = start_nt i\n        | Ninit _ => False\n        end) -> step_result)\nwith\n| Some s0 =>\n    let\n      (state_new, e) as s1\n       return\n         (thunkP\n            (Some s1 = None ->\n             match state_of_stack stk0 with\n             | Init i => prod_lhs prod = start_nt i\n             | Ninit _ => False\n             end) -> step_result) := s0 in\n    fun\n      _ : thunkP\n            (Some\n               (exist\n                  (fun s1 : noninitstate =>\n                   NT (prod_lhs prod) = last_symb_of_non_init_state s1)\n                  state_new e) = None ->\n             match state_of_stack stk0 with\n             | Init i => prod_lhs prod = start_nt i\n             | Ninit _ => False\n             end) =>\n    Progress_sr\n      (existT noninitstate_type state_new\n         (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n            (last_symb_of_non_init_state state_new) e) :: stk0) buffer\n| None =>\n    fun\n      Hval : thunkP\n               (None = None ->\n                match state_of_stack stk0 with\n                | Init i => prod_lhs prod = start_nt i\n                | Ninit _ => False\n                end) =>\n    Accept_sr\n      (cast symbol_semantic_type (reduce_step_subproof0 prod stk0 Hval) sem)\n      buffer\nend\n  (fun _ : True =>\n   reduce_step_subproof1 stk prod Hv stk0\n     (fun _ : True =>\n      s (head_states_of_state (state_of_stack stk))\n        (reduce_step_subproof2 stk Hi))) = Progress_sr stk' buffer' ->\nstack_invariant stk'.","proofString":"simpl in Hi'.\nintros Hv'.\nassert (Hgoto1:=goto_head_symbs (state_of_stack stk0) (prod_lhs prod)).\nassert (Hgoto2:=goto_past_state (state_of_stack stk0) (prod_lhs prod)).\nmatch goal with | |- context [fun _ : True => ?X] => generalize X end.\ndestruct goto_table as [[state_new e]|] eqn:EQgoto=>//.\nintros _ [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hgoto1.\nby destruct Hi'.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hgoto2.\nby destruct Hi'.\nby constructor."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) : forall\n  s : forall lpred : list (state -> bool),\n      prefix_pred lpred (state_stack_of_stack stk) ->\n      state_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred,\nmatch\n  goto_table (state_of_stack stk0) (prod_lhs prod) as goto\n  return\n    (thunkP\n       (goto = None ->\n        match state_of_stack stk0 with\n        | Init i => prod_lhs prod = start_nt i\n        | Ninit _ => False\n        end) -> step_result)\nwith\n| Some s0 =>\n    let\n      (state_new, e) as s1\n       return\n         (thunkP\n            (Some s1 = None ->\n             match state_of_stack stk0 with\n             | Init i => prod_lhs prod = start_nt i\n             | Ninit _ => False\n             end) -> step_result) := s0 in\n    fun\n      _ : thunkP\n            (Some\n               (exist\n                  (fun s1 : noninitstate =>\n                   NT (prod_lhs prod) = last_symb_of_non_init_state s1)\n                  state_new e) = None ->\n             match state_of_stack stk0 with\n             | Init i => prod_lhs prod = start_nt i\n             | Ninit _ => False\n             end) =>\n    Progress_sr\n      (existT noninitstate_type state_new\n         (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n            (last_symb_of_non_init_state state_new) e) :: stk0) buffer\n| None =>\n    fun\n      Hval : thunkP\n               (None = None ->\n                match state_of_stack stk0 with\n                | Init i => prod_lhs prod = start_nt i\n                | Ninit _ => False\n                end) =>\n    Accept_sr\n      (cast symbol_semantic_type (reduce_step_subproof0 prod stk0 Hval) sem)\n      buffer\nend\n  (fun _ : True =>\n   reduce_step_subproof1 stk prod Hv stk0\n     (fun _ : True =>\n      s (head_states_of_state (state_of_stack stk))\n        (reduce_step_subproof2 stk Hi))) = Progress_sr stk' buffer' ->\nstack_invariant stk'.","proofString":"intros Hv'.\nassert (Hgoto1:=goto_head_symbs (state_of_stack stk0) (prod_lhs prod)).\nassert (Hgoto2:=goto_past_state (state_of_stack stk0) (prod_lhs prod)).\nmatch goal with | |- context [fun _ : True => ?X] => generalize X end.\ndestruct goto_table as [[state_new e]|] eqn:EQgoto=>//.\nintros _ [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hgoto1.\nby destruct Hi'.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hgoto2.\nby destruct Hi'.\nby constructor."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) (Hv' : forall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred) : match\n  goto_table (state_of_stack stk0) (prod_lhs prod) as goto\n  return\n    (thunkP\n       (goto = None ->\n        match state_of_stack stk0 with\n        | Init i => prod_lhs prod = start_nt i\n        | Ninit _ => False\n        end) -> step_result)\nwith\n| Some s =>\n    let\n      (state_new, e) as s0\n       return\n         (thunkP\n            (Some s0 = None ->\n             match state_of_stack stk0 with\n             | Init i => prod_lhs prod = start_nt i\n             | Ninit _ => False\n             end) -> step_result) := s in\n    fun\n      _ : thunkP\n            (Some\n               (exist\n                  (fun s0 : noninitstate =>\n                   NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                  state_new e) = None ->\n             match state_of_stack stk0 with\n             | Init i => prod_lhs prod = start_nt i\n             | Ninit _ => False\n             end) =>\n    Progress_sr\n      (existT noninitstate_type state_new\n         (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n            (last_symb_of_non_init_state state_new) e) :: stk0) buffer\n| None =>\n    fun\n      Hval : thunkP\n               (None = None ->\n                match state_of_stack stk0 with\n                | Init i => prod_lhs prod = start_nt i\n                | Ninit _ => False\n                end) =>\n    Accept_sr\n      (cast symbol_semantic_type (reduce_step_subproof0 prod stk0 Hval) sem)\n      buffer\nend\n  (fun _ : True =>\n   reduce_step_subproof1 stk prod Hv stk0\n     (fun _ : True =>\n      Hv' (head_states_of_state (state_of_stack stk))\n        (reduce_step_subproof2 stk Hi))) = Progress_sr stk' buffer' ->\nstack_invariant stk'.","proofString":"assert (Hgoto1:=goto_head_symbs (state_of_stack stk0) (prod_lhs prod)).\nassert (Hgoto2:=goto_past_state (state_of_stack stk0) (prod_lhs prod)).\nmatch goal with | |- context [fun _ : True => ?X] => generalize X end.\ndestruct goto_table as [[state_new e]|] eqn:EQgoto=>//.\nintros _ [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hgoto1.\nby destruct Hi'.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hgoto2.\nby destruct Hi'.\nby constructor."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) (Hv' : forall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred) (Hgoto1 : match goto_table (state_of_stack stk0) (prod_lhs prod) with\n| Some (exist _ s2 _) =>\n    prefix (past_symb_of_non_init_state s2)\n      (head_symbs_of_state (state_of_stack stk0))\n| None => True\nend) : match\n  goto_table (state_of_stack stk0) (prod_lhs prod) as goto\n  return\n    (thunkP\n       (goto = None ->\n        match state_of_stack stk0 with\n        | Init i => prod_lhs prod = start_nt i\n        | Ninit _ => False\n        end) -> step_result)\nwith\n| Some s =>\n    let\n      (state_new, e) as s0\n       return\n         (thunkP\n            (Some s0 = None ->\n             match state_of_stack stk0 with\n             | Init i => prod_lhs prod = start_nt i\n             | Ninit _ => False\n             end) -> step_result) := s in\n    fun\n      _ : thunkP\n            (Some\n               (exist\n                  (fun s0 : noninitstate =>\n                   NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                  state_new e) = None ->\n             match state_of_stack stk0 with\n             | Init i => prod_lhs prod = start_nt i\n             | Ninit _ => False\n             end) =>\n    Progress_sr\n      (existT noninitstate_type state_new\n         (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n            (last_symb_of_non_init_state state_new) e) :: stk0) buffer\n| None =>\n    fun\n      Hval : thunkP\n               (None = None ->\n                match state_of_stack stk0 with\n                | Init i => prod_lhs prod = start_nt i\n                | Ninit _ => False\n                end) =>\n    Accept_sr\n      (cast symbol_semantic_type (reduce_step_subproof0 prod stk0 Hval) sem)\n      buffer\nend\n  (fun _ : True =>\n   reduce_step_subproof1 stk prod Hv stk0\n     (fun _ : True =>\n      Hv' (head_states_of_state (state_of_stack stk))\n        (reduce_step_subproof2 stk Hi))) = Progress_sr stk' buffer' ->\nstack_invariant stk'.","proofString":"assert (Hgoto2:=goto_past_state (state_of_stack stk0) (prod_lhs prod)).\nmatch goal with | |- context [fun _ : True => ?X] => generalize X end.\ndestruct goto_table as [[state_new e]|] eqn:EQgoto=>//.\nintros _ [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hgoto1.\nby destruct Hi'.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hgoto2.\nby destruct Hi'.\nby constructor."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) (Hv' : forall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred) (Hgoto1 : match goto_table (state_of_stack stk0) (prod_lhs prod) with\n| Some (exist _ s2 _) =>\n    prefix (past_symb_of_non_init_state s2)\n      (head_symbs_of_state (state_of_stack stk0))\n| None => True\nend) (Hgoto2 : match goto_table (state_of_stack stk0) (prod_lhs prod) with\n| Some (exist _ s2 _) =>\n    prefix_pred (past_state_of_non_init_state s2)\n      (head_states_of_state (state_of_stack stk0))\n| None => True\nend) : match\n  goto_table (state_of_stack stk0) (prod_lhs prod) as goto\n  return\n    (thunkP\n       (goto = None ->\n        match state_of_stack stk0 with\n        | Init i => prod_lhs prod = start_nt i\n        | Ninit _ => False\n        end) -> step_result)\nwith\n| Some s =>\n    let\n      (state_new, e) as s0\n       return\n         (thunkP\n            (Some s0 = None ->\n             match state_of_stack stk0 with\n             | Init i => prod_lhs prod = start_nt i\n             | Ninit _ => False\n             end) -> step_result) := s in\n    fun\n      _ : thunkP\n            (Some\n               (exist\n                  (fun s0 : noninitstate =>\n                   NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                  state_new e) = None ->\n             match state_of_stack stk0 with\n             | Init i => prod_lhs prod = start_nt i\n             | Ninit _ => False\n             end) =>\n    Progress_sr\n      (existT noninitstate_type state_new\n         (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n            (last_symb_of_non_init_state state_new) e) :: stk0) buffer\n| None =>\n    fun\n      Hval : thunkP\n               (None = None ->\n                match state_of_stack stk0 with\n                | Init i => prod_lhs prod = start_nt i\n                | Ninit _ => False\n                end) =>\n    Accept_sr\n      (cast symbol_semantic_type (reduce_step_subproof0 prod stk0 Hval) sem)\n      buffer\nend\n  (fun _ : True =>\n   reduce_step_subproof1 stk prod Hv stk0\n     (fun _ : True =>\n      Hv' (head_states_of_state (state_of_stack stk))\n        (reduce_step_subproof2 stk Hi))) = Progress_sr stk' buffer' ->\nstack_invariant stk'.","proofString":"match goal with | |- context [fun _ : True => ?X] => generalize X end.\ndestruct goto_table as [[state_new e]|] eqn:EQgoto=>//.\nintros _ [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hgoto1.\nby destruct Hi'.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hgoto2.\nby destruct Hi'.\nby constructor."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) (Hv' : forall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred) (Hgoto1 : match goto_table (state_of_stack stk0) (prod_lhs prod) with\n| Some (exist _ s2 _) =>\n    prefix (past_symb_of_non_init_state s2)\n      (head_symbs_of_state (state_of_stack stk0))\n| None => True\nend) (Hgoto2 : match goto_table (state_of_stack stk0) (prod_lhs prod) with\n| Some (exist _ s2 _) =>\n    prefix_pred (past_state_of_non_init_state s2)\n      (head_states_of_state (state_of_stack stk0))\n| None => True\nend) : forall\n  y : goto_table (state_of_stack stk0) (prod_lhs prod) = None ->\n      match state_of_stack stk0 with\n      | Init i => prod_lhs prod = start_nt i\n      | Ninit _ => False\n      end,\nmatch\n  goto_table (state_of_stack stk0) (prod_lhs prod) as goto\n  return\n    (thunkP\n       (goto = None ->\n        match state_of_stack stk0 with\n        | Init i => prod_lhs prod = start_nt i\n        | Ninit _ => False\n        end) -> step_result)\nwith\n| Some s =>\n    let\n      (state_new, e) as s0\n       return\n         (thunkP\n            (Some s0 = None ->\n             match state_of_stack stk0 with\n             | Init i => prod_lhs prod = start_nt i\n             | Ninit _ => False\n             end) -> step_result) := s in\n    fun\n      _ : thunkP\n            (Some\n               (exist\n                  (fun s0 : noninitstate =>\n                   NT (prod_lhs prod) = last_symb_of_non_init_state s0)\n                  state_new e) = None ->\n             match state_of_stack stk0 with\n             | Init i => prod_lhs prod = start_nt i\n             | Ninit _ => False\n             end) =>\n    Progress_sr\n      (existT noninitstate_type state_new\n         (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n            (last_symb_of_non_init_state state_new) e) :: stk0) buffer\n| None =>\n    fun\n      Hval : thunkP\n               (None = None ->\n                match state_of_stack stk0 with\n                | Init i => prod_lhs prod = start_nt i\n                | Ninit _ => False\n                end) =>\n    Accept_sr\n      (cast symbol_semantic_type (reduce_step_subproof0 prod stk0 Hval) sem)\n      buffer\nend (fun _ : True => y) = Progress_sr stk' buffer' -> \nstack_invariant stk'.","proofString":"destruct goto_table as [[state_new e]|] eqn:EQgoto=>//.\nintros _ [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hgoto1.\nby destruct Hi'.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hgoto2.\nby destruct Hi'.\nby constructor."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) (Hv' : forall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred) (state_new : noninitstate) (e : NT (prod_lhs prod) = last_symb_of_non_init_state state_new) (EQgoto : goto_table (state_of_stack stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) state_new e)) (Hgoto1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk0))) (Hgoto2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk0))) : (Some\n   (exist\n      (fun s : noninitstate =>\n       NT (prod_lhs prod) = last_symb_of_non_init_state s) state_new e) =\n None ->\n match state_of_stack stk0 with\n | Init i => prod_lhs prod = start_nt i\n | Ninit _ => False\n end) ->\nProgress_sr\n  (existT noninitstate_type state_new\n     (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n        (last_symb_of_non_init_state state_new) e) :: stk0) buffer =\nProgress_sr stk' buffer' -> stack_invariant stk'.","proofString":"intros _ [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hgoto1.\nby destruct Hi'.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hgoto2.\nby destruct Hi'.\nby constructor."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) (Hv' : forall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred) (state_new : noninitstate) (e : NT (prod_lhs prod) = last_symb_of_non_init_state state_new) (EQgoto : goto_table (state_of_stack stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) state_new e)) (Hgoto1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk0))) (Hgoto2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk0))) : stack_invariant\n  (existT noninitstate_type state_new\n     (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n        (last_symb_of_non_init_state state_new) e) :: stk0).","proofString":"constructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hgoto1.\nby destruct Hi'.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hgoto2.\nby destruct Hi'.\nby constructor."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) (Hv' : forall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred) (state_new : noninitstate) (e : NT (prod_lhs prod) = last_symb_of_non_init_state state_new) (EQgoto : goto_table (state_of_stack stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) state_new e)) (Hgoto1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk0))) (Hgoto2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk0))) : prefix\n  (last_symb_of_non_init_state state_new\n   :: past_symb_of_non_init_state state_new)\n  (last_symb_of_non_init_state state_new :: symb_stack_of_stack stk0).","proofString":"constructor.\neapply prefix_trans.\napply Hgoto1.\nby destruct Hi'."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) (Hv' : forall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred) (state_new : noninitstate) (e : NT (prod_lhs prod) = last_symb_of_non_init_state state_new) (EQgoto : goto_table (state_of_stack stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) state_new e)) (Hgoto1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk0))) (Hgoto2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk0))) : prefix (past_symb_of_non_init_state state_new) (symb_stack_of_stack stk0).","proofString":"eapply prefix_trans.\napply Hgoto1.\nby destruct Hi'."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) (Hv' : forall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred) (state_new : noninitstate) (e : NT (prod_lhs prod) = last_symb_of_non_init_state state_new) (EQgoto : goto_table (state_of_stack stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) state_new e)) (Hgoto1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk0))) (Hgoto2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk0))) : prefix_pred (head_states_of_state state_new)\n  (state_stack_of_stack\n     (existT noninitstate_type state_new\n        (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n           (last_symb_of_non_init_state state_new) e) :: stk0)).","proofString":"unfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hgoto2.\nby destruct Hi'."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) (Hv' : forall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred) (state_new : noninitstate) (e : NT (prod_lhs prod) = last_symb_of_non_init_state state_new) (EQgoto : goto_table (state_of_stack stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) state_new e)) (Hgoto1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk0))) (Hgoto2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk0))) : forall x : state,\nimplb (singleton_state_pred state_new x) (singleton_state_pred state_new x) =\ntrue.","proofString":"intros ?.\nby destruct singleton_state_pred."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) (Hv' : forall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred) (state_new : noninitstate) (e : NT (prod_lhs prod) = last_symb_of_non_init_state state_new) (EQgoto : goto_table (state_of_stack stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) state_new e)) (Hgoto1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk0))) (Hgoto2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk0))) (x : state) : implb (singleton_state_pred state_new x) (singleton_state_pred state_new x) =\ntrue.","proofString":"by destruct singleton_state_pred."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) (Hv' : forall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred) (state_new : noninitstate) (e : NT (prod_lhs prod) = last_symb_of_non_init_state state_new) (EQgoto : goto_table (state_of_stack stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) state_new e)) (Hgoto1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk0))) (Hgoto2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk0))) : prefix_pred (past_state_of_state state_new)\n  (map\n     (fun cell : {x : noninitstate & noninitstate_type x} =>\n      singleton_state_pred (projT1 cell)) stk0 ++ [\n   singleton_state_pred init]).","proofString":"eapply prefix_pred_trans.\napply Hgoto2.\nby destruct Hi'."},{"statement":"(stk : stack) (prod : production) (buffer : Make.buffer) (Hv : thunkP (valid_for_reduce (state_of_stack stk) prod)) (Hi : thunkP (stack_invariant stk)) (stk0 : stack) (sem : symbol_semantic_type (NT (prod_lhs prod))) (Hi' : stack_invariant stk0) (Hv' : forall lpred : list (state -> bool),\nprefix_pred lpred (state_stack_of_stack stk) ->\nstate_valid_after_pop (state_of_stack stk0) (prod_rhs_rev prod) lpred) (state_new : noninitstate) (e : NT (prod_lhs prod) = last_symb_of_non_init_state state_new) (EQgoto : goto_table (state_of_stack stk0) (prod_lhs prod) =\nSome\n  (exist\n     (fun s : noninitstate =>\n      NT (prod_lhs prod) = last_symb_of_non_init_state s) state_new e)) (Hgoto1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk0))) (Hgoto2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk0))) : stack_invariant_next\n  (existT noninitstate_type state_new\n     (eq_rect (NT (prod_lhs prod)) symbol_semantic_type sem\n        (last_symb_of_non_init_state state_new) e) :: stk0).","proofString":"by constructor."},{"statement":"(stk : stack) (buffer : Make.buffer) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) : match\n  action_table (state_of_stack stk) as a\n  return\n    (thunkP\n       match a with\n       | Default_reduce_act prod =>\n           valid_for_reduce (state_of_stack stk) prod\n       | Lookahead_act awt =>\n           forall t : terminal,\n           match awt t with\n           | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n           | _ => True\n           end\n       end -> step_result)\nwith\n| Default_reduce_act prod =>\n    fun Hv : thunkP (valid_for_reduce (state_of_stack stk) prod) =>\n    reduce_step stk prod buffer Hv Hi\n| Lookahead_act awt =>\n    fun\n      Hv : thunkP\n             (forall t : terminal,\n              match awt t with\n              | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n              | _ => True\n              end) =>\n    match\n      awt (token_term (buf_head buffer)) as a\n      return\n        (thunkP\n           match a with\n           | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n           | _ => True\n           end -> step_result)\n    with\n    | Shift_act state_new e =>\n        fun _ : thunkP True =>\n        Progress_sr\n          (existT noninitstate_type state_new\n             (eq_rect (T (token_term (buf_head buffer))) symbol_semantic_type\n                (token_sem (buf_head buffer))\n                (last_symb_of_non_init_state state_new) e) :: stk)\n          (buf_tail buffer)\n    | Reduce_act prod =>\n        fun Hv0 : thunkP (valid_for_reduce (state_of_stack stk) prod) =>\n        reduce_step stk prod buffer Hv0 Hi\n    | Fail_act =>\n        fun _ : thunkP True =>\n        Fail_sr_full (state_of_stack stk) (buf_head buffer)\n    end (fun _ : True => Hv I (token_term (buf_head buffer)))\nend (fun _ : True => reduce_ok (state_of_stack stk)) =\nProgress_sr stk' buffer' -> stack_invariant stk'.","proofString":"generalize (reduce_ok (state_of_stack stk))=>Hred.\nassert (Hshift1 := shift_head_symbs (state_of_stack stk)).\nassert (Hshift2 := shift_past_state (state_of_stack stk)).\ndestruct action_table as [prod|awt]=>/=.\neauto using reduce_step_stack_invariant_preserved.\nset (term := token_term (buf_head buffer)).\ngeneralize (Hred term).\nclear Hred.\nintros Hred.\nspecialize (Hshift1 term).\nspecialize (Hshift2 term).\ndestruct (awt term) as [state_new e|prod|]=>//.\nintros [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hshift1.\nby destruct Hi.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hshift2.\nby destruct Hi.\nconstructor; by apply Hi.\neauto using reduce_step_stack_invariant_preserved."},{"statement":"(stk : stack) (buffer : Make.buffer) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (Hred : match action_table (state_of_stack stk) with\n| Default_reduce_act p => valid_for_reduce (state_of_stack stk) p\n| Lookahead_act awp =>\n    forall t : terminal,\n    match awp t with\n    | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n    | _ => True\n    end\nend) : match\n  action_table (state_of_stack stk) as a\n  return\n    (thunkP\n       match a with\n       | Default_reduce_act prod =>\n           valid_for_reduce (state_of_stack stk) prod\n       | Lookahead_act awt =>\n           forall t : terminal,\n           match awt t with\n           | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n           | _ => True\n           end\n       end -> step_result)\nwith\n| Default_reduce_act prod =>\n    fun Hv : thunkP (valid_for_reduce (state_of_stack stk) prod) =>\n    reduce_step stk prod buffer Hv Hi\n| Lookahead_act awt =>\n    fun\n      Hv : thunkP\n             (forall t : terminal,\n              match awt t with\n              | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n              | _ => True\n              end) =>\n    match\n      awt (token_term (buf_head buffer)) as a\n      return\n        (thunkP\n           match a with\n           | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n           | _ => True\n           end -> step_result)\n    with\n    | Shift_act state_new e =>\n        fun _ : thunkP True =>\n        Progress_sr\n          (existT noninitstate_type state_new\n             (eq_rect (T (token_term (buf_head buffer))) symbol_semantic_type\n                (token_sem (buf_head buffer))\n                (last_symb_of_non_init_state state_new) e) :: stk)\n          (buf_tail buffer)\n    | Reduce_act prod =>\n        fun Hv0 : thunkP (valid_for_reduce (state_of_stack stk) prod) =>\n        reduce_step stk prod buffer Hv0 Hi\n    | Fail_act =>\n        fun _ : thunkP True =>\n        Fail_sr_full (state_of_stack stk) (buf_head buffer)\n    end (fun _ : True => Hv I (token_term (buf_head buffer)))\nend (fun _ : True => Hred) = Progress_sr stk' buffer' -> \nstack_invariant stk'.","proofString":"assert (Hshift1 := shift_head_symbs (state_of_stack stk)).\nassert (Hshift2 := shift_past_state (state_of_stack stk)).\ndestruct action_table as [prod|awt]=>/=.\neauto using reduce_step_stack_invariant_preserved.\nset (term := token_term (buf_head buffer)).\ngeneralize (Hred term).\nclear Hred.\nintros Hred.\nspecialize (Hshift1 term).\nspecialize (Hshift2 term).\ndestruct (awt term) as [state_new e|prod|]=>//.\nintros [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hshift1.\nby destruct Hi.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hshift2.\nby destruct Hi.\nconstructor; by apply Hi.\neauto using reduce_step_stack_invariant_preserved."},{"statement":"(stk : stack) (buffer : Make.buffer) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (Hred : match action_table (state_of_stack stk) with\n| Default_reduce_act p => valid_for_reduce (state_of_stack stk) p\n| Lookahead_act awp =>\n    forall t : terminal,\n    match awp t with\n    | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n    | _ => True\n    end\nend) (Hshift1 : match action_table (state_of_stack stk) with\n| Default_reduce_act _ => True\n| Lookahead_act awp =>\n    forall t : terminal,\n    match awp t with\n    | Shift_act s2 _ =>\n        prefix (past_symb_of_non_init_state s2)\n          (head_symbs_of_state (state_of_stack stk))\n    | _ => True\n    end\nend) : match\n  action_table (state_of_stack stk) as a\n  return\n    (thunkP\n       match a with\n       | Default_reduce_act prod =>\n           valid_for_reduce (state_of_stack stk) prod\n       | Lookahead_act awt =>\n           forall t : terminal,\n           match awt t with\n           | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n           | _ => True\n           end\n       end -> step_result)\nwith\n| Default_reduce_act prod =>\n    fun Hv : thunkP (valid_for_reduce (state_of_stack stk) prod) =>\n    reduce_step stk prod buffer Hv Hi\n| Lookahead_act awt =>\n    fun\n      Hv : thunkP\n             (forall t : terminal,\n              match awt t with\n              | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n              | _ => True\n              end) =>\n    match\n      awt (token_term (buf_head buffer)) as a\n      return\n        (thunkP\n           match a with\n           | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n           | _ => True\n           end -> step_result)\n    with\n    | Shift_act state_new e =>\n        fun _ : thunkP True =>\n        Progress_sr\n          (existT noninitstate_type state_new\n             (eq_rect (T (token_term (buf_head buffer))) symbol_semantic_type\n                (token_sem (buf_head buffer))\n                (last_symb_of_non_init_state state_new) e) :: stk)\n          (buf_tail buffer)\n    | Reduce_act prod =>\n        fun Hv0 : thunkP (valid_for_reduce (state_of_stack stk) prod) =>\n        reduce_step stk prod buffer Hv0 Hi\n    | Fail_act =>\n        fun _ : thunkP True =>\n        Fail_sr_full (state_of_stack stk) (buf_head buffer)\n    end (fun _ : True => Hv I (token_term (buf_head buffer)))\nend (fun _ : True => Hred) = Progress_sr stk' buffer' -> \nstack_invariant stk'.","proofString":"assert (Hshift2 := shift_past_state (state_of_stack stk)).\ndestruct action_table as [prod|awt]=>/=.\neauto using reduce_step_stack_invariant_preserved.\nset (term := token_term (buf_head buffer)).\ngeneralize (Hred term).\nclear Hred.\nintros Hred.\nspecialize (Hshift1 term).\nspecialize (Hshift2 term).\ndestruct (awt term) as [state_new e|prod|]=>//.\nintros [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hshift1.\nby destruct Hi.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hshift2.\nby destruct Hi.\nconstructor; by apply Hi.\neauto using reduce_step_stack_invariant_preserved."},{"statement":"(stk : stack) (buffer : Make.buffer) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (Hred : match action_table (state_of_stack stk) with\n| Default_reduce_act p => valid_for_reduce (state_of_stack stk) p\n| Lookahead_act awp =>\n    forall t : terminal,\n    match awp t with\n    | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n    | _ => True\n    end\nend) (Hshift1 : match action_table (state_of_stack stk) with\n| Default_reduce_act _ => True\n| Lookahead_act awp =>\n    forall t : terminal,\n    match awp t with\n    | Shift_act s2 _ =>\n        prefix (past_symb_of_non_init_state s2)\n          (head_symbs_of_state (state_of_stack stk))\n    | _ => True\n    end\nend) (Hshift2 : match action_table (state_of_stack stk) with\n| Default_reduce_act _ => True\n| Lookahead_act awp =>\n    forall t : terminal,\n    match awp t with\n    | Shift_act s2 _ =>\n        prefix_pred (past_state_of_non_init_state s2)\n          (head_states_of_state (state_of_stack stk))\n    | _ => True\n    end\nend) : match\n  action_table (state_of_stack stk) as a\n  return\n    (thunkP\n       match a with\n       | Default_reduce_act prod =>\n           valid_for_reduce (state_of_stack stk) prod\n       | Lookahead_act awt =>\n           forall t : terminal,\n           match awt t with\n           | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n           | _ => True\n           end\n       end -> step_result)\nwith\n| Default_reduce_act prod =>\n    fun Hv : thunkP (valid_for_reduce (state_of_stack stk) prod) =>\n    reduce_step stk prod buffer Hv Hi\n| Lookahead_act awt =>\n    fun\n      Hv : thunkP\n             (forall t : terminal,\n              match awt t with\n              | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n              | _ => True\n              end) =>\n    match\n      awt (token_term (buf_head buffer)) as a\n      return\n        (thunkP\n           match a with\n           | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n           | _ => True\n           end -> step_result)\n    with\n    | Shift_act state_new e =>\n        fun _ : thunkP True =>\n        Progress_sr\n          (existT noninitstate_type state_new\n             (eq_rect (T (token_term (buf_head buffer))) symbol_semantic_type\n                (token_sem (buf_head buffer))\n                (last_symb_of_non_init_state state_new) e) :: stk)\n          (buf_tail buffer)\n    | Reduce_act prod =>\n        fun Hv0 : thunkP (valid_for_reduce (state_of_stack stk) prod) =>\n        reduce_step stk prod buffer Hv0 Hi\n    | Fail_act =>\n        fun _ : thunkP True =>\n        Fail_sr_full (state_of_stack stk) (buf_head buffer)\n    end (fun _ : True => Hv I (token_term (buf_head buffer)))\nend (fun _ : True => Hred) = Progress_sr stk' buffer' -> \nstack_invariant stk'.","proofString":"destruct action_table as [prod|awt]=>/=.\neauto using reduce_step_stack_invariant_preserved.\nset (term := token_term (buf_head buffer)).\ngeneralize (Hred term).\nclear Hred.\nintros Hred.\nspecialize (Hshift1 term).\nspecialize (Hshift2 term).\ndestruct (awt term) as [state_new e|prod|]=>//.\nintros [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hshift1.\nby destruct Hi.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hshift2.\nby destruct Hi.\nconstructor; by apply Hi.\neauto using reduce_step_stack_invariant_preserved."},{"statement":"(stk : stack) (buffer : Make.buffer) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (prod : production) (Hred : valid_for_reduce (state_of_stack stk) prod) (Hshift1 Hshift2 : True) : reduce_step stk prod buffer (fun _ : True => Hred) Hi =\nProgress_sr stk' buffer' -> stack_invariant stk'.","proofString":"eauto using reduce_step_stack_invariant_preserved."},{"statement":"(stk : stack) (buffer : Make.buffer) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (awt : forall term : terminal, lookahead_action term) (Hred : forall t : terminal,\nmatch awt t with\n| Reduce_act p => valid_for_reduce (state_of_stack stk) p\n| _ => True\nend) (Hshift1 : forall t : terminal,\nmatch awt t with\n| Shift_act s2 _ =>\n    prefix (past_symb_of_non_init_state s2)\n      (head_symbs_of_state (state_of_stack stk))\n| _ => True\nend) (Hshift2 : forall t : terminal,\nmatch awt t with\n| Shift_act s2 _ =>\n    prefix_pred (past_state_of_non_init_state s2)\n      (head_states_of_state (state_of_stack stk))\n| _ => True\nend) : match\n  awt (token_term (buf_head buffer)) as a\n  return\n    (thunkP\n       match a with\n       | Reduce_act p => valid_for_reduce (state_of_stack stk) p\n       | _ => True\n       end -> step_result)\nwith\n| Shift_act state_new e =>\n    fun _ : thunkP True =>\n    Progress_sr\n      (existT noninitstate_type state_new\n         (eq_rect (T (token_term (buf_head buffer))) symbol_semantic_type\n            (token_sem (buf_head buffer))\n            (last_symb_of_non_init_state state_new) e) :: stk)\n      (buf_tail buffer)\n| Reduce_act prod =>\n    fun Hv : thunkP (valid_for_reduce (state_of_stack stk) prod) =>\n    reduce_step stk prod buffer Hv Hi\n| Fail_act =>\n    fun _ : thunkP True =>\n    Fail_sr_full (state_of_stack stk) (buf_head buffer)\nend (fun _ : True => Hred (token_term (buf_head buffer))) =\nProgress_sr stk' buffer' -> stack_invariant stk'.","proofString":"set (term := token_term (buf_head buffer)).\ngeneralize (Hred term).\nclear Hred.\nintros Hred.\nspecialize (Hshift1 term).\nspecialize (Hshift2 term).\ndestruct (awt term) as [state_new e|prod|]=>//.\nintros [= <- <-].\nconstructor=>/=.\nconstructor.\neapply prefix_trans.\napply Hshift1.\nby destruct Hi.\nunfold state_stack_of_stack; simpl; constructor.\nintros ?.\nby destruct singleton_state_pred.\neapply prefix_pred_trans.\napply Hshift2.\nby destruct Hi.\nconstructor; by apply Hi.\neauto using reduce_step_stack_invariant_preserved."},{"statement":"(stk : stack) (buffer : Make.buffer) (Hi : thunkP (stack_invariant stk)) (awt : forall term0 : terminal, lookahead_action term0) (term : terminal) (state_new : noninitstate) (e : T term = last_symb_of_non_init_state state_new) (Hshift1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk))) (Hshift2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk))) (Hred : True) : prefix\n  (last_symb_of_non_init_state state_new\n   :: past_symb_of_non_init_state state_new)\n  (last_symb_of_non_init_state state_new :: symb_stack_of_stack stk).","proofString":"constructor.\neapply prefix_trans.\napply Hshift1.\nby destruct Hi."},{"statement":"(stk : stack) (buffer : Make.buffer) (Hi : thunkP (stack_invariant stk)) (awt : forall term0 : terminal, lookahead_action term0) (term : terminal) (state_new : noninitstate) (e : T term = last_symb_of_non_init_state state_new) (Hshift1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk))) (Hshift2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk))) (Hred : True) : prefix (past_symb_of_non_init_state state_new) (symb_stack_of_stack stk).","proofString":"eapply prefix_trans.\napply Hshift1.\nby destruct Hi."},{"statement":"(stk : stack) (buffer : Make.buffer) (Hi : thunkP (stack_invariant stk)) (awt : forall term0 : terminal, lookahead_action term0) (term : terminal) (state_new : noninitstate) (e : T term = last_symb_of_non_init_state state_new) (Hshift1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk))) (Hshift2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk))) (Hred : True) : forall x : state,\nimplb (singleton_state_pred state_new x) (singleton_state_pred state_new x) =\ntrue.","proofString":"intros ?.\nby destruct singleton_state_pred."},{"statement":"(stk : stack) (buffer : Make.buffer) (Hi : thunkP (stack_invariant stk)) (awt : forall term0 : terminal, lookahead_action term0) (term : terminal) (state_new : noninitstate) (e : T term = last_symb_of_non_init_state state_new) (Hshift1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk))) (Hshift2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk))) (Hred : True) (x : state) : implb (singleton_state_pred state_new x) (singleton_state_pred state_new x) =\ntrue.","proofString":"by destruct singleton_state_pred."},{"statement":"(stk : stack) (buffer : Make.buffer) (Hi : thunkP (stack_invariant stk)) (awt : forall term0 : terminal, lookahead_action term0) (term : terminal) (state_new : noninitstate) (e : T term = last_symb_of_non_init_state state_new) (Hshift1 : prefix (past_symb_of_non_init_state state_new)\n  (head_symbs_of_state (state_of_stack stk))) (Hshift2 : prefix_pred (past_state_of_non_init_state state_new)\n  (head_states_of_state (state_of_stack stk))) (Hred : True) : prefix_pred (past_state_of_state state_new)\n  (map\n     (fun cell : {x : noninitstate & noninitstate_type x} =>\n      singleton_state_pred (projT1 cell)) stk ++ [\n   singleton_state_pred init]).","proofString":"eapply prefix_pred_trans.\napply Hshift2.\nby destruct Hi."},{"statement":"(stk : stack) (buffer : Make.buffer) (Hi : thunkP (stack_invariant stk)) (stk' : stack) (buffer' : Make.buffer) (awt : forall term0 : terminal, lookahead_action term0) (term : terminal) (prod : production) (Hshift1 Hshift2 : True) (Hred : valid_for_reduce (state_of_stack stk) prod) : reduce_step stk prod buffer (fun _ : True => Hred) Hi =\nProgress_sr stk' buffer' -> stack_invariant stk'.","proofString":"eauto using reduce_step_stack_invariant_preserved."}]}