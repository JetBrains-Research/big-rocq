{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/backend/Inliningspec.v","fileSamples":[{"statement":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (id : positive) (g : globdef fundef unit) (H : forall (id1 : positive) (f0 : function),\nfenv ! id1 = Some f0 -> dm ! id1 = Some (Gfun (Internal f0))) (id0 : positive) (f : function) (H0 : (PTree.remove id fenv) ! id0 = Some f) : (PTree.set id g dm) ! id0 = Some (Gfun (Internal f)).","conclusion":"(PTree.set id g dm) ! id0 = Some (Gfun (Internal f))","hypotheses":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (id : positive) (g : globdef fundef unit) (H : forall (id1 : positive) (f0 : function),\nfenv ! id1 = Some f0 -> dm ! id1 = Some (Gfun (Internal f0))) (id0 : positive) (f : function) (H0 : (PTree.remove id fenv) ! id0 = Some f)","proofString":"rewrite PTree.grspec in H0.\ndestruct (PTree.elt_eq id0 id).\ndiscriminate.\nrewrite PTree.gso; auto."},{"statement":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (id : positive) (g : globdef fundef unit) (H : forall (id1 : positive) (f0 : function),\nfenv ! id1 = Some f0 -> dm ! id1 = Some (Gfun (Internal f0))) (id0 : positive) (f : function) (H0 : (if PTree.elt_eq id0 id then None else fenv ! id0) = Some f) : (PTree.set id g dm) ! id0 = Some (Gfun (Internal f)).","conclusion":"(PTree.set id g dm) ! id0 = Some (Gfun (Internal f))","hypotheses":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (id : positive) (g : globdef fundef unit) (H : forall (id1 : positive) (f0 : function),\nfenv ! id1 = Some f0 -> dm ! id1 = Some (Gfun (Internal f0))) (id0 : positive) (f : function) (H0 : (if PTree.elt_eq id0 id then None else fenv ! id0) = Some f)","proofString":"destruct (PTree.elt_eq id0 id).\ndiscriminate.\nrewrite PTree.gso; auto."},{"statement":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (id : positive) (g : globdef fundef unit) (H : forall (id1 : positive) (f0 : function),\nfenv ! id1 = Some f0 -> dm ! id1 = Some (Gfun (Internal f0))) (id0 : positive) (f : function) (e : id0 = id) (H0 : None = Some f) : (PTree.set id g dm) ! id0 = Some (Gfun (Internal f)).","conclusion":"(PTree.set id g dm) ! id0 = Some (Gfun (Internal f))","hypotheses":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (id : positive) (g : globdef fundef unit) (H : forall (id1 : positive) (f0 : function),\nfenv ! id1 = Some f0 -> dm ! id1 = Some (Gfun (Internal f0))) (id0 : positive) (f : function) (e : id0 = id) (H0 : None = Some f)","proofString":"discriminate."},{"statement":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (id : positive) (g : globdef fundef unit) (H : forall (id1 : positive) (f0 : function),\nfenv ! id1 = Some f0 -> dm ! id1 = Some (Gfun (Internal f0))) (id0 : positive) (f : function) (n : id0 <> id) (H0 : fenv ! id0 = Some f) : (PTree.set id g dm) ! id0 = Some (Gfun (Internal f)).","conclusion":"(PTree.set id g dm) ! id0 = Some (Gfun (Internal f))","hypotheses":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (id : positive) (g : globdef fundef unit) (H : forall (id1 : positive) (f0 : function),\nfenv ! id1 = Some f0 -> dm ! id1 = Some (Gfun (Internal f0))) (id0 : positive) (f : function) (n : id0 <> id) (H0 : fenv ! id0 = Some f)","proofString":"rewrite PTree.gso; auto."},{"statement":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (REMOVE : forall (dm : PTree.t (globdef fundef unit)) (fenv : funenv) \n  (id : positive) (g : globdef fundef unit),\nP dm fenv -> P (PTree.set id g dm) (PTree.remove id fenv)) (ADD : forall (io : inlining_info) (dm : PTree.t (globdef fundef unit))\n  (fenv : funenv) (idg : positive * globdef fundef unit),\nP dm fenv -> P (PTree.set (fst idg) (snd idg) dm) (add_globdef io fenv idg)) : forall (p : inlining_info) (l : list (positive * globdef fundef unit))\n  (dm : PTree.t (globdef fundef unit)) (fenv : funenv),\nP dm fenv ->\nP\n  (fold_left\n     (fun (x : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) x) l dm)\n  (fold_left (add_globdef p) l fenv).","conclusion":"forall (p : inlining_info) (l : list (positive * globdef fundef unit))\n  (dm : PTree.t (globdef fundef unit)) (fenv : funenv),\nP dm fenv ->\nP\n  (fold_left\n     (fun (x : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) x) l dm)\n  (fold_left (add_globdef p) l fenv)","hypotheses":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (REMOVE : forall (dm : PTree.t (globdef fundef unit)) (fenv : funenv) \n  (id : positive) (g : globdef fundef unit),\nP dm fenv -> P (PTree.set id g dm) (PTree.remove id fenv)) (ADD : forall (io : inlining_info) (dm : PTree.t (globdef fundef unit))\n  (fenv : funenv) (idg : positive * globdef fundef unit),\nP dm fenv -> P (PTree.set (fst idg) (snd idg) dm) (add_globdef io fenv idg))","proofString":"induction l; simpl; intros.\nauto.\napply IHl.\napply ADD; auto."},{"statement":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (REMOVE : forall (dm0 : PTree.t (globdef fundef unit)) (fenv0 : funenv) \n  (id : positive) (g : globdef fundef unit),\nP dm0 fenv0 -> P (PTree.set id g dm0) (PTree.remove id fenv0)) (ADD : forall (io : inlining_info) (dm0 : PTree.t (globdef fundef unit))\n  (fenv0 : funenv) (idg : positive * globdef fundef unit),\nP dm0 fenv0 ->\nP (PTree.set (fst idg) (snd idg) dm0) (add_globdef io fenv0 idg)) (p : inlining_info) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (H : P dm fenv) : P dm fenv.","conclusion":"P dm fenv","hypotheses":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (REMOVE : forall (dm0 : PTree.t (globdef fundef unit)) (fenv0 : funenv) \n  (id : positive) (g : globdef fundef unit),\nP dm0 fenv0 -> P (PTree.set id g dm0) (PTree.remove id fenv0)) (ADD : forall (io : inlining_info) (dm0 : PTree.t (globdef fundef unit))\n  (fenv0 : funenv) (idg : positive * globdef fundef unit),\nP dm0 fenv0 ->\nP (PTree.set (fst idg) (snd idg) dm0) (add_globdef io fenv0 idg)) (p : inlining_info) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (H : P dm fenv)","proofString":"auto."},{"statement":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (REMOVE : forall (dm0 : PTree.t (globdef fundef unit)) (fenv0 : funenv) \n  (id : positive) (g : globdef fundef unit),\nP dm0 fenv0 -> P (PTree.set id g dm0) (PTree.remove id fenv0)) (ADD : forall (io : inlining_info) (dm0 : PTree.t (globdef fundef unit))\n  (fenv0 : funenv) (idg : positive * globdef fundef unit),\nP dm0 fenv0 ->\nP (PTree.set (fst idg) (snd idg) dm0) (add_globdef io fenv0 idg)) (p : inlining_info) (a : positive * globdef fundef unit) (l : list (positive * globdef fundef unit)) (IHl : forall (dm0 : PTree.t (globdef fundef unit)) (fenv0 : funenv),\nP dm0 fenv0 ->\nP\n  (fold_left\n     (fun (x : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) x) l dm0)\n  (fold_left (add_globdef p) l fenv0)) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (H : P dm fenv) : P\n  (fold_left\n     (fun (x : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) x) l (PTree.set (fst a) (snd a) dm))\n  (fold_left (add_globdef p) l (add_globdef p fenv a)).","conclusion":"P\n  (fold_left\n     (fun (x : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) x) l (PTree.set (fst a) (snd a) dm))\n  (fold_left (add_globdef p) l (add_globdef p fenv a))","hypotheses":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (REMOVE : forall (dm0 : PTree.t (globdef fundef unit)) (fenv0 : funenv) \n  (id : positive) (g : globdef fundef unit),\nP dm0 fenv0 -> P (PTree.set id g dm0) (PTree.remove id fenv0)) (ADD : forall (io : inlining_info) (dm0 : PTree.t (globdef fundef unit))\n  (fenv0 : funenv) (idg : positive * globdef fundef unit),\nP dm0 fenv0 ->\nP (PTree.set (fst idg) (snd idg) dm0) (add_globdef io fenv0 idg)) (p : inlining_info) (a : positive * globdef fundef unit) (l : list (positive * globdef fundef unit)) (IHl : forall (dm0 : PTree.t (globdef fundef unit)) (fenv0 : funenv),\nP dm0 fenv0 ->\nP\n  (fold_left\n     (fun (x : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) x) l dm0)\n  (fold_left (add_globdef p) l fenv0)) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (H : P dm fenv)","proofString":"apply IHl.\napply ADD; auto."},{"statement":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (REMOVE : forall (dm0 : PTree.t (globdef fundef unit)) (fenv0 : funenv) \n  (id : positive) (g : globdef fundef unit),\nP dm0 fenv0 -> P (PTree.set id g dm0) (PTree.remove id fenv0)) (ADD : forall (io : inlining_info) (dm0 : PTree.t (globdef fundef unit))\n  (fenv0 : funenv) (idg : positive * globdef fundef unit),\nP dm0 fenv0 ->\nP (PTree.set (fst idg) (snd idg) dm0) (add_globdef io fenv0 idg)) (p : inlining_info) (a : positive * globdef fundef unit) (l : list (positive * globdef fundef unit)) (IHl : forall (dm0 : PTree.t (globdef fundef unit)) (fenv0 : funenv),\nP dm0 fenv0 ->\nP\n  (fold_left\n     (fun (x : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) x) l dm0)\n  (fold_left (add_globdef p) l fenv0)) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (H : P dm fenv) : P (PTree.set (fst a) (snd a) dm) (add_globdef p fenv a).","conclusion":"P (PTree.set (fst a) (snd a) dm) (add_globdef p fenv a)","hypotheses":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (REMOVE : forall (dm0 : PTree.t (globdef fundef unit)) (fenv0 : funenv) \n  (id : positive) (g : globdef fundef unit),\nP dm0 fenv0 -> P (PTree.set id g dm0) (PTree.remove id fenv0)) (ADD : forall (io : inlining_info) (dm0 : PTree.t (globdef fundef unit))\n  (fenv0 : funenv) (idg : positive * globdef fundef unit),\nP dm0 fenv0 ->\nP (PTree.set (fst idg) (snd idg) dm0) (add_globdef io fenv0 idg)) (p : inlining_info) (a : positive * globdef fundef unit) (l : list (positive * globdef fundef unit)) (IHl : forall (dm0 : PTree.t (globdef fundef unit)) (fenv0 : funenv),\nP dm0 fenv0 ->\nP\n  (fold_left\n     (fun (x : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) x) l dm0)\n  (fold_left (add_globdef p) l fenv0)) (dm : PTree.t (globdef fundef unit)) (fenv : funenv) (H : P dm fenv)","proofString":"apply ADD; auto."},{"statement":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (REMOVE : forall (dm : PTree.t (globdef fundef unit)) (fenv : funenv) \n  (id0 : positive) (g : globdef fundef unit),\nP dm fenv -> P (PTree.set id0 g dm) (PTree.remove id0 fenv)) (ADD : forall (io : inlining_info) (dm : PTree.t (globdef fundef unit))\n  (fenv : funenv) (idg : positive * globdef fundef unit),\nP dm fenv -> P (PTree.set (fst idg) (snd idg) dm) (add_globdef io fenv idg)) (REC : forall (p0 : inlining_info) (l : list (positive * globdef fundef unit))\n  (dm : PTree.t (globdef fundef unit)) (fenv : funenv),\nP dm fenv ->\nP\n  (fold_left\n     (fun (x : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) x) l dm)\n  (fold_left (add_globdef p0) l fenv)) (p : program) (id : positive) (f : function) (H : (PTree.empty function) ! id = Some f) : (PTree.empty (globdef fundef unit)) ! id = Some (Gfun (Internal f)).","conclusion":"(PTree.empty (globdef fundef unit)) ! id = Some (Gfun (Internal f))","hypotheses":"(P : PTree.t (globdef fundef unit) -> funenv -> Prop) (REMOVE : forall (dm : PTree.t (globdef fundef unit)) (fenv : funenv) \n  (id0 : positive) (g : globdef fundef unit),\nP dm fenv -> P (PTree.set id0 g dm) (PTree.remove id0 fenv)) (ADD : forall (io : inlining_info) (dm : PTree.t (globdef fundef unit))\n  (fenv : funenv) (idg : positive * globdef fundef unit),\nP dm fenv -> P (PTree.set (fst idg) (snd idg) dm) (add_globdef io fenv idg)) (REC : forall (p0 : inlining_info) (l : list (positive * globdef fundef unit))\n  (dm : PTree.t (globdef fundef unit)) (fenv : funenv),\nP dm fenv ->\nP\n  (fold_left\n     (fun (x : PTree.tree (globdef fundef unit))\n        (idg : positive * globdef fundef unit) =>\n      PTree.set (fst idg) (snd idg) x) l dm)\n  (fold_left (add_globdef p0) l fenv)) (p : program) (id : positive) (f : function) (H : (PTree.empty function) ! id = Some f)","proofString":"rewrite PTree.gempty in H; discriminate."},{"statement":"(cunit prog : program) (fenv : funenv) (H : linkorder cunit prog) (H0 : fenv_compat cunit fenv) (id : positive) (f : function) (H1 : fenv ! id = Some f) : (prog_defmap prog) ! id = Some (Gfun (Internal f)).","conclusion":"(prog_defmap prog) ! id = Some (Gfun (Internal f))","hypotheses":"(cunit prog : program) (fenv : funenv) (H : linkorder cunit prog) (H0 : fenv_compat cunit fenv) (id : positive) (f : function) (H1 : fenv ! id = Some f)","proofString":"apply H0 in H1.\ndestruct (prog_defmap_linkorder _ _ _ _ H H1) as (gd' & P & Q).\ninv Q.\ninv H3.\nauto."},{"statement":"(cunit prog : program) (fenv : funenv) (H : linkorder cunit prog) (H0 : fenv_compat cunit fenv) (id : positive) (f : function) (H1 : (prog_defmap cunit) ! id = Some (Gfun (Internal f))) : (prog_defmap prog) ! id = Some (Gfun (Internal f)).","conclusion":"(prog_defmap prog) ! id = Some (Gfun (Internal f))","hypotheses":"(cunit prog : program) (fenv : funenv) (H : linkorder cunit prog) (H0 : fenv_compat cunit fenv) (id : positive) (f : function) (H1 : (prog_defmap cunit) ! id = Some (Gfun (Internal f)))","proofString":"destruct (prog_defmap_linkorder _ _ _ _ H H1) as (gd' & P & Q).\ninv Q.\ninv H3.\nauto."},{"statement":"(cunit prog : program) (fenv : funenv) (H : linkorder cunit prog) (H0 : fenv_compat cunit fenv) (id : positive) (f : function) (H1 : (prog_defmap cunit) ! id = Some (Gfun (Internal f))) (gd' : globdef fundef unit) (P : (prog_defmap prog) ! id = Some gd') (Q : linkorder (Gfun (Internal f)) gd') : (prog_defmap prog) ! id = Some (Gfun (Internal f)).","conclusion":"(prog_defmap prog) ! id = Some (Gfun (Internal f))","hypotheses":"(cunit prog : program) (fenv : funenv) (H : linkorder cunit prog) (H0 : fenv_compat cunit fenv) (id : positive) (f : function) (H1 : (prog_defmap cunit) ! id = Some (Gfun (Internal f))) (gd' : globdef fundef unit) (P : (prog_defmap prog) ! id = Some gd') (Q : linkorder (Gfun (Internal f)) gd')","proofString":"inv Q.\ninv H3.\nauto."},{"statement":"(cunit prog : program) (fenv : funenv) (H : linkorder cunit prog) (H0 : fenv_compat cunit fenv) (id : positive) (f : function) (H1 : (prog_defmap cunit) ! id = Some (Gfun (Internal f))) (fd2 : fundef) (P : (prog_defmap prog) ! id = Some (Gfun fd2)) (H3 : linkorder (Internal f) fd2) : (prog_defmap prog) ! id = Some (Gfun (Internal f)).","conclusion":"(prog_defmap prog) ! id = Some (Gfun (Internal f))","hypotheses":"(cunit prog : program) (fenv : funenv) (H : linkorder cunit prog) (H0 : fenv_compat cunit fenv) (id : positive) (f : function) (H1 : (prog_defmap cunit) ! id = Some (Gfun (Internal f))) (fd2 : fundef) (P : (prog_defmap prog) ! id = Some (Gfun fd2)) (H3 : linkorder (Internal f) fd2)","proofString":"inv H3.\nauto."},{"statement":"(cunit prog : program) (fenv : funenv) (H : linkorder cunit prog) (H0 : fenv_compat cunit fenv) (id : positive) (f : function) (H1 : (prog_defmap cunit) ! id = Some (Gfun (Internal f))) (P : (prog_defmap prog) ! id = Some (Gfun (Internal f))) : (prog_defmap prog) ! id = Some (Gfun (Internal f)).","conclusion":"(prog_defmap prog) ! id = Some (Gfun (Internal f))","hypotheses":"(cunit prog : program) (fenv : funenv) (H : linkorder cunit prog) (H0 : fenv_compat cunit fenv) (id : positive) (f : function) (H1 : (prog_defmap cunit) ! id = Some (Gfun (Internal f))) (P : (prog_defmap prog) ! id = Some (Gfun (Internal f)))","proofString":"auto."},{"statement":"(x y : positive) : Z.pos (shiftpos x y) = Z.pos x + Z.pos y - 1.","conclusion":"Z.pos (shiftpos x y) = Z.pos x + Z.pos y - 1","hypotheses":"(x y : positive)","proofString":"unfold shiftpos.\nzify.\ntry rewrite Pos2Z.inj_sub.\nauto.\nzify.\nlia."},{"statement":"(x y : positive) : Z.pos (Pos.pred (x + y)) = Z.pos x + Z.pos y - 1.","conclusion":"Z.pos (Pos.pred (x + y)) = Z.pos x + Z.pos y - 1","hypotheses":"(x y : positive)","proofString":"zify.\ntry rewrite Pos2Z.inj_sub.\nauto.\nzify.\nlia."},{"statement":"(x y : positive) (cstr : 0 < Z.pos y) (cstr0 : 0 < Z.pos x) (z1 : Z) (H1 : 1 < Z.pos x + Z.pos y - 1 /\\ z1 = Z.pos x + Z.pos y - 1 \\/\nZ.pos x + Z.pos y - 1 <= 1 /\\ z1 = 1) : z1 = Z.pos x + Z.pos y - 1.","conclusion":"z1 = Z.pos x + Z.pos y - 1","hypotheses":"(x y : positive) (cstr : 0 < Z.pos y) (cstr0 : 0 < Z.pos x) (z1 : Z) (H1 : 1 < Z.pos x + Z.pos y - 1 /\\ z1 = Z.pos x + Z.pos y - 1 \\/\nZ.pos x + Z.pos y - 1 <= 1 /\\ z1 = 1)","proofString":"try rewrite Pos2Z.inj_sub.\nauto.\nzify.\nlia."},{"statement":"(x y : positive) (cstr : 0 < Z.pos y) (cstr0 : 0 < Z.pos x) (z1 : Z) (H1 : 1 < Z.pos x + Z.pos y - 1 /\\ z1 = Z.pos x + Z.pos y - 1 \\/\nZ.pos x + Z.pos y - 1 <= 1 /\\ z1 = 1) : z1 = Z.pos x + Z.pos y - 1.","conclusion":"z1 = Z.pos x + Z.pos y - 1","hypotheses":"(x y : positive) (cstr : 0 < Z.pos y) (cstr0 : 0 < Z.pos x) (z1 : Z) (H1 : 1 < Z.pos x + Z.pos y - 1 /\\ z1 = Z.pos x + Z.pos y - 1 \\/\nZ.pos x + Z.pos y - 1 <= 1 /\\ z1 = 1)","proofString":"auto.\nzify.\nlia."},{"statement":"(x y : positive) (cstr : 0 < Z.pos y) (cstr0 : 0 < Z.pos x) (z1 : Z) (H1 : 1 < Z.pos x + Z.pos y - 1 /\\ z1 = Z.pos x + Z.pos y - 1 \\/\nZ.pos x + Z.pos y - 1 <= 1 /\\ z1 = 1) : z1 = Z.pos x + Z.pos y - 1.","conclusion":"z1 = Z.pos x + Z.pos y - 1","hypotheses":"(x y : positive) (cstr : 0 < Z.pos y) (cstr0 : 0 < Z.pos x) (z1 : Z) (H1 : 1 < Z.pos x + Z.pos y - 1 /\\ z1 = Z.pos x + Z.pos y - 1 \\/\nZ.pos x + Z.pos y - 1 <= 1 /\\ z1 = 1)","proofString":"zify.\nlia."},{"statement":"(x y : positive) (cstr : 0 < Z.pos y) (cstr0 : 0 < Z.pos x) (z1 : Z) (H1 : 1 < Z.pos x + Z.pos y - 1 /\\ z1 = Z.pos x + Z.pos y - 1 \\/\nZ.pos x + Z.pos y - 1 <= 1 /\\ z1 = 1) : z1 = Z.pos x + Z.pos y - 1.","conclusion":"z1 = Z.pos x + Z.pos y - 1","hypotheses":"(x y : positive) (cstr : 0 < Z.pos y) (cstr0 : 0 < Z.pos x) (z1 : Z) (H1 : 1 < Z.pos x + Z.pos y - 1 /\\ z1 = Z.pos x + Z.pos y - 1 \\/\nZ.pos x + Z.pos y - 1 <= 1 /\\ z1 = 1)","proofString":"lia."},{"statement":"(x y n : positive) (H : shiftpos x n = shiftpos y n) : x = y.","conclusion":"x = y","hypotheses":"(x y n : positive) (H : shiftpos x n = shiftpos y n)","proofString":"assert (Zpos (shiftpos x n) = Zpos (shiftpos y n)) by congruence.\nrewrite ! shiftpos_eq in H0.\nassert (Z.pos x = Z.pos y) by lia.\ncongruence."},{"statement":"(x y n : positive) (H : shiftpos x n = shiftpos y n) (H0 : Z.pos (shiftpos x n) = Z.pos (shiftpos y n)) : x = y.","conclusion":"x = y","hypotheses":"(x y n : positive) (H : shiftpos x n = shiftpos y n) (H0 : Z.pos (shiftpos x n) = Z.pos (shiftpos y n))","proofString":"rewrite ! shiftpos_eq in H0.\nassert (Z.pos x = Z.pos y) by lia.\ncongruence."},{"statement":"(x y n : positive) (H : shiftpos x n = shiftpos y n) (H0 : Z.pos x + Z.pos n - 1 = Z.pos y + Z.pos n - 1) : x = y.","conclusion":"x = y","hypotheses":"(x y n : positive) (H : shiftpos x n = shiftpos y n) (H0 : Z.pos x + Z.pos n - 1 = Z.pos y + Z.pos n - 1)","proofString":"assert (Z.pos x = Z.pos y) by lia.\ncongruence."},{"statement":"(x y n : positive) (H : shiftpos x n = shiftpos y n) (H0 : Z.pos x + Z.pos n - 1 = Z.pos y + Z.pos n - 1) (H1 : Z.pos x = Z.pos y) : x = y.","conclusion":"x = y","hypotheses":"(x y n : positive) (H : shiftpos x n = shiftpos y n) (H0 : Z.pos x + Z.pos n - 1 = Z.pos y + Z.pos n - 1) (H1 : Z.pos x = Z.pos y)","proofString":"congruence."},{"statement":"(x y n : positive) (H : x <> y) (H0 : shiftpos x n = shiftpos y n) : False.","conclusion":"False","hypotheses":"(x y n : positive) (H : x <> y) (H0 : shiftpos x n = shiftpos y n)","proofString":"elim H.\neapply shiftpos_inj; eauto."},{"statement":"(x y n : positive) (H : x <> y) (H0 : shiftpos x n = shiftpos y n) : x = y.","conclusion":"x = y","hypotheses":"(x y n : positive) (H : x <> y) (H0 : shiftpos x n = shiftpos y n)","proofString":"eapply shiftpos_inj; eauto."},{"statement":"(x n : positive) : Ple n (shiftpos x n).","conclusion":"Ple n (shiftpos x n)","hypotheses":"(x n : positive)","proofString":"unfold Ple; zify.\nrewrite shiftpos_eq.\nextlia."},{"statement":"(x n : positive) (cstr : 0 < Z.pos n) (cstr0 : 0 < Z.pos (shiftpos x n)) : Z.pos n <= Z.pos (shiftpos x n).","conclusion":"Z.pos n <= Z.pos (shiftpos x n)","hypotheses":"(x n : positive) (cstr : 0 < Z.pos n) (cstr0 : 0 < Z.pos (shiftpos x n))","proofString":"rewrite shiftpos_eq.\nextlia."},{"statement":"(x n : positive) (cstr : 0 < Z.pos n) (cstr0 : 0 < Z.pos (shiftpos x n)) : Z.pos n <= Z.pos x + Z.pos n - 1.","conclusion":"Z.pos n <= Z.pos x + Z.pos n - 1","hypotheses":"(x n : positive) (cstr : 0 < Z.pos n) (cstr0 : 0 < Z.pos (shiftpos x n))","proofString":"extlia."},{"statement":"(x n : positive) (H : Plt (shiftpos x n) n) : False.","conclusion":"False","hypotheses":"(x n : positive) (H : Plt (shiftpos x n) n)","proofString":"generalize (shiftpos_above x n).\nextlia."},{"statement":"(x n : positive) (H : Plt (shiftpos x n) n) : Ple n (shiftpos x n) -> False.","conclusion":"Ple n (shiftpos x n) -> False","hypotheses":"(x n : positive) (H : Plt (shiftpos x n) n)","proofString":"extlia."},{"statement":"(x n : positive) : Plt (shiftpos x n) (x + n).","conclusion":"Plt (shiftpos x n) (x + n)","hypotheses":"(x n : positive)","proofString":"unfold Plt; zify.\nrewrite shiftpos_eq.\nlia."},{"statement":"(x n : positive) (cstr : 0 < Z.pos n) (cstr0 : 0 < Z.pos (shiftpos x n)) (cstr1 : 0 < Z.pos x) : Z.pos (shiftpos x n) < Z.pos x + Z.pos n.","conclusion":"Z.pos (shiftpos x n) < Z.pos x + Z.pos n","hypotheses":"(x n : positive) (cstr : 0 < Z.pos n) (cstr0 : 0 < Z.pos (shiftpos x n)) (cstr1 : 0 < Z.pos x)","proofString":"rewrite shiftpos_eq.\nlia."},{"statement":"(x n : positive) (cstr : 0 < Z.pos n) (cstr0 : 0 < Z.pos (shiftpos x n)) (cstr1 : 0 < Z.pos x) : Z.pos x + Z.pos n - 1 < Z.pos x + Z.pos n.","conclusion":"Z.pos x + Z.pos n - 1 < Z.pos x + Z.pos n","hypotheses":"(x n : positive) (cstr : 0 < Z.pos n) (cstr0 : 0 < Z.pos (shiftpos x n)) (cstr1 : 0 < Z.pos x)","proofString":"lia."},{"statement":"(x y n : positive) (H : Ple x y) : Ple (shiftpos x n) (shiftpos y n).","conclusion":"Ple (shiftpos x n) (shiftpos y n)","hypotheses":"(x y n : positive) (H : Ple x y)","proofString":"unfold Ple in *; zify.\nrewrite ! shiftpos_eq.\nlia."},{"statement":"(x y n : positive) (H : Z.pos x <= Z.pos y) (cstr : 0 < Z.pos y) (cstr0 : 0 < Z.pos (shiftpos x n)) (cstr1 : 0 < Z.pos x) (cstr2 : 0 < Z.pos (shiftpos y n)) : Z.pos (shiftpos x n) <= Z.pos (shiftpos y n).","conclusion":"Z.pos (shiftpos x n) <= Z.pos (shiftpos y n)","hypotheses":"(x y n : positive) (H : Z.pos x <= Z.pos y) (cstr : 0 < Z.pos y) (cstr0 : 0 < Z.pos (shiftpos x n)) (cstr1 : 0 < Z.pos x) (cstr2 : 0 < Z.pos (shiftpos y n))","proofString":"rewrite ! shiftpos_eq.\nlia."},{"statement":"(x y n : positive) (H : Z.pos x <= Z.pos y) (cstr : 0 < Z.pos y) (cstr0 : 0 < Z.pos (shiftpos x n)) (cstr1 : 0 < Z.pos x) (cstr2 : 0 < Z.pos (shiftpos y n)) : Z.pos x + Z.pos n - 1 <= Z.pos y + Z.pos n - 1.","conclusion":"Z.pos x + Z.pos n - 1 <= Z.pos y + Z.pos n - 1","hypotheses":"(x y n : positive) (H : Z.pos x <= Z.pos y) (cstr : 0 < Z.pos y) (cstr0 : 0 < Z.pos (shiftpos x n)) (cstr1 : 0 < Z.pos x) (cstr2 : 0 < Z.pos (shiftpos y n))","proofString":"lia."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : sincr s1 s3) (H : match f s1 with\n| R vx s2 I1 =>\n    match g vx s2 with\n    | R vy s0 I2 => R vy s0 (sincr_trans s1 s2 s0 I1 I2)\n    end\nend = R y s3 i) : exists (x : A) (s2 : state) (i1 : sincr s1 s2) (i2 : sincr s2 s3),\n  f s1 = R x s2 i1 /\\ g x s2 = R y s3 i2.","conclusion":"exists (x : A) (s2 : state) (i1 : sincr s1 s2) (i2 : sincr s2 s3),\n  f s1 = R x s2 i1 /\\ g x s2 = R y s3 i2","hypotheses":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : sincr s1 s3) (H : match f s1 with\n| R vx s2 I1 =>\n    match g vx s2 with\n    | R vy s0 I2 => R vy s0 (sincr_trans s1 s2 s0 I1 I2)\n    end\nend = R y s3 i)","proofString":"destruct (f s1).\nexists x; exists s'; exists I.\ndestruct (g x s').\ninv H.\nexists I0; auto."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : sincr s1 s3) (x : A) (s' : state) (I : sincr s1 s') (H : match g x s' with\n| R vy s0 I2 => R vy s0 (sincr_trans s1 s' s0 I I2)\nend = R y s3 i) : exists (x0 : A) (s2 : state) (i1 : sincr s1 s2) (i2 : sincr s2 s3),\n  R x s' I = R x0 s2 i1 /\\ g x0 s2 = R y s3 i2.","conclusion":"exists (x0 : A) (s2 : state) (i1 : sincr s1 s2) (i2 : sincr s2 s3),\n  R x s' I = R x0 s2 i1 /\\ g x0 s2 = R y s3 i2","hypotheses":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : sincr s1 s3) (x : A) (s' : state) (I : sincr s1 s') (H : match g x s' with\n| R vy s0 I2 => R vy s0 (sincr_trans s1 s' s0 I I2)\nend = R y s3 i)","proofString":"exists x; exists s'; exists I.\ndestruct (g x s').\ninv H.\nexists I0; auto."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : sincr s1 s3) (x : A) (s' : state) (I : sincr s1 s') (H : match g x s' with\n| R vy s0 I2 => R vy s0 (sincr_trans s1 s' s0 I I2)\nend = R y s3 i) : exists i2 : sincr s' s3, R x s' I = R x s' I /\\ g x s' = R y s3 i2.","conclusion":"exists i2 : sincr s' s3, R x s' I = R x s' I /\\ g x s' = R y s3 i2","hypotheses":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : sincr s1 s3) (x : A) (s' : state) (I : sincr s1 s') (H : match g x s' with\n| R vy s0 I2 => R vy s0 (sincr_trans s1 s' s0 I I2)\nend = R y s3 i)","proofString":"destruct (g x s').\ninv H.\nexists I0; auto."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : sincr s1 s3) (x : A) (s' : state) (I : sincr s1 s') (x0 : B) (s'0 : state) (I0 : sincr s' s'0) (H : R x0 s'0 (sincr_trans s1 s' s'0 I I0) = R y s3 i) : exists i2 : sincr s' s3, R x s' I = R x s' I /\\ R x0 s'0 I0 = R y s3 i2.","conclusion":"exists i2 : sincr s' s3, R x s' I = R x s' I /\\ R x0 s'0 I0 = R y s3 i2","hypotheses":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : sincr s1 s3) (x : A) (s' : state) (I : sincr s1 s') (x0 : B) (s'0 : state) (I0 : sincr s' s'0) (H : R x0 s'0 (sincr_trans s1 s' s'0 I I0) = R y s3 i)","proofString":"inv H.\nexists I0; auto."},{"statement":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : sincr s1 s3) (x : A) (s' : state) (I : sincr s1 s') (I0 : sincr s' s3) : exists i2 : sincr s' s3, R x s' I = R x s' I /\\ R y s3 I0 = R y s3 i2.","conclusion":"exists i2 : sincr s' s3, R x s' I = R x s' I /\\ R y s3 I0 = R y s3 i2","hypotheses":"(A : Type) (B : Type) (f : mon A) (g : A -> mon B) (y : B) (s1 s3 : state) (i : sincr s1 s3) (x : A) (s' : state) (I : sincr s1 s') (I0 : sincr s' s3)","proofString":"exists I0; auto."},{"statement":"(A : Type) (B : Type) (f : A -> B -> mon unit) (s : state) : exists i : sincr s s, ret tt s = R tt s i.","conclusion":"exists i : sincr s s, ret tt s = R tt s i","hypotheses":"(A : Type) (B : Type) (f : A -> B -> mon unit) (s : state)","proofString":"exists (sincr_refl s); auto."},{"statement":"(A : Type) (B : Type) (f : A -> B -> mon unit) (a : A * B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a0 : state) (p : A * B) =>\n            match f (fst p) (snd p) a0 with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a0 : state) (p : A * B) =>\n        match f (fst p) (snd p) a0 with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state) : exists\n  i : sincr s\n        (fold_left\n           (fun (a0 : state) (p : A * B) =>\n            match f (fst p) (snd p) a0 with\n            | R _ s2 _ => s2\n            end) l match f (fst a) (snd a) s with\n                   | R _ s2 _ => s2\n                   end),\n  (let (x, y) := a in do _ <- f x y; mlist_iter2 f l) s =\n  R tt\n    (fold_left\n       (fun (a0 : state) (p : A * B) =>\n        match f (fst p) (snd p) a0 with\n        | R _ s2 _ => s2\n        end) l match f (fst a) (snd a) s with\n               | R _ s2 _ => s2\n               end) i.","conclusion":"exists\n  i : sincr s\n        (fold_left\n           (fun (a0 : state) (p : A * B) =>\n            match f (fst p) (snd p) a0 with\n            | R _ s2 _ => s2\n            end) l match f (fst a) (snd a) s with\n                   | R _ s2 _ => s2\n                   end),\n  (let (x, y) := a in do _ <- f x y; mlist_iter2 f l) s =\n  R tt\n    (fold_left\n       (fun (a0 : state) (p : A * B) =>\n        match f (fst p) (snd p) a0 with\n        | R _ s2 _ => s2\n        end) l match f (fst a) (snd a) s with\n               | R _ s2 _ => s2\n               end) i","hypotheses":"(A : Type) (B : Type) (f : A -> B -> mon unit) (a : A * B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a0 : state) (p : A * B) =>\n            match f (fst p) (snd p) a0 with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a0 : state) (p : A * B) =>\n        match f (fst p) (snd p) a0 with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state)","proofString":"destruct a as [x y].\nunfold bind.\nsimpl.\ndestruct (f x y s) as [xx s1 i1].\ndestruct (IHl s1) as [i2 EQ].\nrewrite EQ.\neconstructor; eauto."},{"statement":"(A : Type) (B : Type) (f : A -> B -> mon unit) (x : A) (y : B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state) : exists\n  i : sincr s\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l\n           match f (fst (x, y)) (snd (x, y)) s with\n           | R _ s2 _ => s2\n           end),\n  (do _ <- f x y; mlist_iter2 f l) s =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l match f (fst (x, y)) (snd (x, y)) s with\n               | R _ s2 _ => s2\n               end) i.","conclusion":"exists\n  i : sincr s\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l\n           match f (fst (x, y)) (snd (x, y)) s with\n           | R _ s2 _ => s2\n           end),\n  (do _ <- f x y; mlist_iter2 f l) s =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l match f (fst (x, y)) (snd (x, y)) s with\n               | R _ s2 _ => s2\n               end) i","hypotheses":"(A : Type) (B : Type) (f : A -> B -> mon unit) (x : A) (y : B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state)","proofString":"unfold bind.\nsimpl.\ndestruct (f x y s) as [xx s1 i1].\ndestruct (IHl s1) as [i2 EQ].\nrewrite EQ.\neconstructor; eauto."},{"statement":"(A : Type) (B : Type) (f : A -> B -> mon unit) (x : A) (y : B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state) : exists\n  i : sincr s\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l\n           match f (fst (x, y)) (snd (x, y)) s with\n           | R _ s2 _ => s2\n           end),\n  match f x y s with\n  | R _ s2 I1 =>\n      match mlist_iter2 f l s2 with\n      | R vy s3 I2 => R vy s3 (sincr_trans s s2 s3 I1 I2)\n      end\n  end =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l match f (fst (x, y)) (snd (x, y)) s with\n               | R _ s2 _ => s2\n               end) i.","conclusion":"exists\n  i : sincr s\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l\n           match f (fst (x, y)) (snd (x, y)) s with\n           | R _ s2 _ => s2\n           end),\n  match f x y s with\n  | R _ s2 I1 =>\n      match mlist_iter2 f l s2 with\n      | R vy s3 I2 => R vy s3 (sincr_trans s s2 s3 I1 I2)\n      end\n  end =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l match f (fst (x, y)) (snd (x, y)) s with\n               | R _ s2 _ => s2\n               end) i","hypotheses":"(A : Type) (B : Type) (f : A -> B -> mon unit) (x : A) (y : B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state)","proofString":"simpl.\ndestruct (f x y s) as [xx s1 i1].\ndestruct (IHl s1) as [i2 EQ].\nrewrite EQ.\neconstructor; eauto."},{"statement":"(A : Type) (B : Type) (f : A -> B -> mon unit) (x : A) (y : B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state) : exists\n  i : sincr s\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l match f x y s with\n                   | R _ s2 _ => s2\n                   end),\n  match f x y s with\n  | R _ s2 I1 =>\n      match mlist_iter2 f l s2 with\n      | R vy s3 I2 => R vy s3 (sincr_trans s s2 s3 I1 I2)\n      end\n  end =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l match f x y s with\n               | R _ s2 _ => s2\n               end) i.","conclusion":"exists\n  i : sincr s\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l match f x y s with\n                   | R _ s2 _ => s2\n                   end),\n  match f x y s with\n  | R _ s2 I1 =>\n      match mlist_iter2 f l s2 with\n      | R vy s3 I2 => R vy s3 (sincr_trans s s2 s3 I1 I2)\n      end\n  end =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l match f x y s with\n               | R _ s2 _ => s2\n               end) i","hypotheses":"(A : Type) (B : Type) (f : A -> B -> mon unit) (x : A) (y : B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state)","proofString":"destruct (f x y s) as [xx s1 i1].\ndestruct (IHl s1) as [i2 EQ].\nrewrite EQ.\neconstructor; eauto."},{"statement":"(A : Type) (B : Type) (f : A -> B -> mon unit) (x : A) (y : B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state) (xx : unit) (s1 : state) (i1 : sincr s s1) : exists\n  i : sincr s\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s1),\n  match mlist_iter2 f l s1 with\n  | R vy s3 I2 => R vy s3 (sincr_trans s s1 s3 i1 I2)\n  end =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s1) i.","conclusion":"exists\n  i : sincr s\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s1),\n  match mlist_iter2 f l s1 with\n  | R vy s3 I2 => R vy s3 (sincr_trans s s1 s3 i1 I2)\n  end =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s1) i","hypotheses":"(A : Type) (B : Type) (f : A -> B -> mon unit) (x : A) (y : B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state) (xx : unit) (s1 : state) (i1 : sincr s s1)","proofString":"destruct (IHl s1) as [i2 EQ].\nrewrite EQ.\neconstructor; eauto."},{"statement":"(A : Type) (B : Type) (f : A -> B -> mon unit) (x : A) (y : B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state) (xx : unit) (s1 : state) (i1 : sincr s s1) (i2 : sincr s1\n  (fold_left\n     (fun (a : state) (p : A * B) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) l s1)) (EQ : mlist_iter2 f l s1 =\nR tt\n  (fold_left\n     (fun (a : state) (p : A * B) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) l s1) i2) : exists\n  i : sincr s\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s1),\n  match mlist_iter2 f l s1 with\n  | R vy s3 I2 => R vy s3 (sincr_trans s s1 s3 i1 I2)\n  end =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s1) i.","conclusion":"exists\n  i : sincr s\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s1),\n  match mlist_iter2 f l s1 with\n  | R vy s3 I2 => R vy s3 (sincr_trans s s1 s3 i1 I2)\n  end =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s1) i","hypotheses":"(A : Type) (B : Type) (f : A -> B -> mon unit) (x : A) (y : B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state) (xx : unit) (s1 : state) (i1 : sincr s s1) (i2 : sincr s1\n  (fold_left\n     (fun (a : state) (p : A * B) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) l s1)) (EQ : mlist_iter2 f l s1 =\nR tt\n  (fold_left\n     (fun (a : state) (p : A * B) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) l s1) i2)","proofString":"rewrite EQ.\neconstructor; eauto."},{"statement":"(A : Type) (B : Type) (f : A -> B -> mon unit) (x : A) (y : B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state) (xx : unit) (s1 : state) (i1 : sincr s s1) (i2 : sincr s1\n  (fold_left\n     (fun (a : state) (p : A * B) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) l s1)) (EQ : mlist_iter2 f l s1 =\nR tt\n  (fold_left\n     (fun (a : state) (p : A * B) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) l s1) i2) : exists\n  i : sincr s\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s1),\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s1)\n    (sincr_trans s s1\n       (fold_left\n          (fun (a : state) (p : A * B) =>\n           match f (fst p) (snd p) a with\n           | R _ s2 _ => s2\n           end) l s1) i1 i2) =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s1) i.","conclusion":"exists\n  i : sincr s\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s1),\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s1)\n    (sincr_trans s s1\n       (fold_left\n          (fun (a : state) (p : A * B) =>\n           match f (fst p) (snd p) a with\n           | R _ s2 _ => s2\n           end) l s1) i1 i2) =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s1) i","hypotheses":"(A : Type) (B : Type) (f : A -> B -> mon unit) (x : A) (y : B) (l : list (A * B)) (IHl : forall s0 : state,\nexists\n  i : sincr s0\n        (fold_left\n           (fun (a : state) (p : A * B) =>\n            match f (fst p) (snd p) a with\n            | R _ s2 _ => s2\n            end) l s0),\n  mlist_iter2 f l s0 =\n  R tt\n    (fold_left\n       (fun (a : state) (p : A * B) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) l s0) i) (s : state) (xx : unit) (s1 : state) (i1 : sincr s s1) (i2 : sincr s1\n  (fold_left\n     (fun (a : state) (p : A * B) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) l s1)) (EQ : mlist_iter2 f l s1 =\nR tt\n  (fold_left\n     (fun (a : state) (p : A * B) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) l s1) i2)","proofString":"econstructor; eauto."},{"statement":"(A : Type) (f : positive -> A -> mon unit) (t : PTree.t A) (s : state) (x : unit) (s' : state) (i : sincr s s') (H : ptree_mfold f t s = R x s' i) : exists i' : sincr s s', mlist_iter2 f (PTree.elements t) s = R tt s' i'.","conclusion":"exists i' : sincr s s', mlist_iter2 f (PTree.elements t) s = R tt s' i'","hypotheses":"(A : Type) (f : positive -> A -> mon unit) (t : PTree.t A) (s : state) (x : unit) (s' : state) (i : sincr s s') (H : ptree_mfold f t s = R x s' i)","proofString":"destruct (mlist_iter2_fold _ _ f (PTree.elements t) s) as [i' EQ].\nunfold ptree_mfold in H.\ninv H.\nrewrite PTree.fold_spec.\neconstructor.\neexact EQ."},{"statement":"(A : Type) (f : positive -> A -> mon unit) (t : PTree.t A) (s : state) (x : unit) (s' : state) (i : sincr s s') (H : ptree_mfold f t s = R x s' i) (i' : sincr s\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s)) (EQ : mlist_iter2 f (PTree.elements t) s =\nR tt\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s) i') : exists i'0 : sincr s s', mlist_iter2 f (PTree.elements t) s = R tt s' i'0.","conclusion":"exists i'0 : sincr s s', mlist_iter2 f (PTree.elements t) s = R tt s' i'0","hypotheses":"(A : Type) (f : positive -> A -> mon unit) (t : PTree.t A) (s : state) (x : unit) (s' : state) (i : sincr s s') (H : ptree_mfold f t s = R x s' i) (i' : sincr s\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s)) (EQ : mlist_iter2 f (PTree.elements t) s =\nR tt\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s) i')","proofString":"unfold ptree_mfold in H.\ninv H.\nrewrite PTree.fold_spec.\neconstructor.\neexact EQ."},{"statement":"(A : Type) (f : positive -> A -> mon unit) (t : PTree.t A) (s : state) (x : unit) (s' : state) (i : sincr s s') (H : R tt\n  (PTree.fold\n     (fun (s1 : state) (k : positive) (v : A) =>\n      match f k v s1 with\n      | R _ s2 _ => s2\n      end) t s) (Inlining.ptree_mfold_obligation_1 A f t s) = \nR x s' i) (i' : sincr s\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s)) (EQ : mlist_iter2 f (PTree.elements t) s =\nR tt\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s) i') : exists i'0 : sincr s s', mlist_iter2 f (PTree.elements t) s = R tt s' i'0.","conclusion":"exists i'0 : sincr s s', mlist_iter2 f (PTree.elements t) s = R tt s' i'0","hypotheses":"(A : Type) (f : positive -> A -> mon unit) (t : PTree.t A) (s : state) (x : unit) (s' : state) (i : sincr s s') (H : R tt\n  (PTree.fold\n     (fun (s1 : state) (k : positive) (v : A) =>\n      match f k v s1 with\n      | R _ s2 _ => s2\n      end) t s) (Inlining.ptree_mfold_obligation_1 A f t s) = \nR x s' i) (i' : sincr s\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s)) (EQ : mlist_iter2 f (PTree.elements t) s =\nR tt\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s) i')","proofString":"inv H.\nrewrite PTree.fold_spec.\neconstructor.\neexact EQ."},{"statement":"(A : Type) (f : positive -> A -> mon unit) (t : PTree.t A) (s : state) (i : sincr s\n  (PTree.fold\n     (fun (s1 : state) (k : positive) (v : A) =>\n      match f k v s1 with\n      | R _ s2 _ => s2\n      end) t s)) (i' : sincr s\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s)) (EQ : mlist_iter2 f (PTree.elements t) s =\nR tt\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s) i') : exists\n  i'0 : sincr s\n          (PTree.fold\n             (fun (s1 : state) (k : positive) (v : A) =>\n              match f k v s1 with\n              | R _ s2 _ => s2\n              end) t s),\n  mlist_iter2 f (PTree.elements t) s =\n  R tt\n    (PTree.fold\n       (fun (s1 : state) (k : positive) (v : A) =>\n        match f k v s1 with\n        | R _ s2 _ => s2\n        end) t s) i'0.","conclusion":"exists\n  i'0 : sincr s\n          (PTree.fold\n             (fun (s1 : state) (k : positive) (v : A) =>\n              match f k v s1 with\n              | R _ s2 _ => s2\n              end) t s),\n  mlist_iter2 f (PTree.elements t) s =\n  R tt\n    (PTree.fold\n       (fun (s1 : state) (k : positive) (v : A) =>\n        match f k v s1 with\n        | R _ s2 _ => s2\n        end) t s) i'0","hypotheses":"(A : Type) (f : positive -> A -> mon unit) (t : PTree.t A) (s : state) (i : sincr s\n  (PTree.fold\n     (fun (s1 : state) (k : positive) (v : A) =>\n      match f k v s1 with\n      | R _ s2 _ => s2\n      end) t s)) (i' : sincr s\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s)) (EQ : mlist_iter2 f (PTree.elements t) s =\nR tt\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s) i')","proofString":"rewrite PTree.fold_spec.\neconstructor.\neexact EQ."},{"statement":"(A : Type) (f : positive -> A -> mon unit) (t : PTree.t A) (s : state) (i : sincr s\n  (PTree.fold\n     (fun (s1 : state) (k : positive) (v : A) =>\n      match f k v s1 with\n      | R _ s2 _ => s2\n      end) t s)) (i' : sincr s\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s)) (EQ : mlist_iter2 f (PTree.elements t) s =\nR tt\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s) i') : exists\n  i'0 : sincr s\n          (fold_left\n             (fun (a : state) (p : positive * A) =>\n              match f (fst p) (snd p) a with\n              | R _ s2 _ => s2\n              end) (PTree.elements t) s),\n  mlist_iter2 f (PTree.elements t) s =\n  R tt\n    (fold_left\n       (fun (a : state) (p : positive * A) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) (PTree.elements t) s) i'0.","conclusion":"exists\n  i'0 : sincr s\n          (fold_left\n             (fun (a : state) (p : positive * A) =>\n              match f (fst p) (snd p) a with\n              | R _ s2 _ => s2\n              end) (PTree.elements t) s),\n  mlist_iter2 f (PTree.elements t) s =\n  R tt\n    (fold_left\n       (fun (a : state) (p : positive * A) =>\n        match f (fst p) (snd p) a with\n        | R _ s2 _ => s2\n        end) (PTree.elements t) s) i'0","hypotheses":"(A : Type) (f : positive -> A -> mon unit) (t : PTree.t A) (s : state) (i : sincr s\n  (PTree.fold\n     (fun (s1 : state) (k : positive) (v : A) =>\n      match f k v s1 with\n      | R _ s2 _ => s2\n      end) t s)) (i' : sincr s\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s)) (EQ : mlist_iter2 f (PTree.elements t) s =\nR tt\n  (fold_left\n     (fun (a : state) (p : positive * A) =>\n      match f (fst p) (snd p) a with\n      | R _ s2 _ => s2\n      end) (PTree.elements t) s) i')","proofString":"econstructor.\neexact EQ."},{"statement":"(dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H : ret pc2 s = R pc1 s' i) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H : ret pc2 s = R pc1 s' i) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc)","proofString":"monadInv H.\nauto."},{"statement":"(dsts : list reg) (pc1 : node) (s' : state) (i : sincr s' s') (pc : positive) (H0 : Plt pc (st_nextnode s') \\/ Ple (st_nextnode s') pc) : (st_code s') ! pc = (st_code s') ! pc.","conclusion":"(st_code s') ! pc = (st_code s') ! pc","hypotheses":"(dsts : list reg) (pc1 : node) (s' : state) (i : sincr s' s') (pc : positive) (H0 : Plt pc (st_nextnode s') \\/ Ple (st_nextnode s') pc)","proofString":"auto."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s0) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s0) ! pc4) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H : match dsts with\n| nil => ret pc2\n| d1 :: dl =>\n    do n <- add_instr (Iop Omove (a :: nil) d1 pc2); add_moves srcs dl n\nend s = R pc1 s' i) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s0) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s0) ! pc4) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H : match dsts with\n| nil => ret pc2\n| d1 :: dl =>\n    do n <- add_instr (Iop Omove (a :: nil) d1 pc2); add_moves srcs dl n\nend s = R pc1 s' i) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc)","proofString":"destruct dsts; monadInv H.\nauto.\ntransitivity (st_code s0)!pc.\neapply IHsrcs; eauto.\nmonadInv EQ; simpl.\nextlia.\nmonadInv EQ; simpl.\napply PTree.gso.\ninversion INCR0; simpl in *.\nextlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts : list reg) (pc2 : node) (s : state) \n  (pc0 : node) (s'0 : state) (i0 : sincr s s'0) (pc3 : positive),\nadd_moves srcs dsts pc2 s = R pc0 s'0 i0 ->\nPlt pc3 (st_nextnode s) \\/ Ple (st_nextnode s'0) pc3 ->\n(st_code s'0) ! pc3 = (st_code s) ! pc3) (pc1 : node) (s' : state) (i : sincr s' s') (pc : positive) (H0 : Plt pc (st_nextnode s') \\/ Ple (st_nextnode s') pc) : (st_code s') ! pc = (st_code s') ! pc.","conclusion":"(st_code s') ! pc = (st_code s') ! pc","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts : list reg) (pc2 : node) (s : state) \n  (pc0 : node) (s'0 : state) (i0 : sincr s s'0) (pc3 : positive),\nadd_moves srcs dsts pc2 s = R pc0 s'0 i0 ->\nPlt pc3 (st_nextnode s) \\/ Ple (st_nextnode s'0) pc3 ->\n(st_code s'0) ! pc3 = (st_code s) ! pc3) (pc1 : node) (s' : state) (i : sincr s' s') (pc : positive) (H0 : Plt pc (st_nextnode s') \\/ Ple (st_nextnode s') pc)","proofString":"auto."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s1) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s1) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s1) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s1) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0)","proofString":"transitivity (st_code s0)!pc.\neapply IHsrcs; eauto.\nmonadInv EQ; simpl.\nextlia.\nmonadInv EQ; simpl.\napply PTree.gso.\ninversion INCR0; simpl in *.\nextlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s1) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s1) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0) : (st_code s') ! pc = (st_code s0) ! pc.","conclusion":"(st_code s') ! pc = (st_code s0) ! pc","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s1) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s1) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0)","proofString":"eapply IHsrcs; eauto.\nmonadInv EQ; simpl.\nextlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s1) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s1) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0) : Plt pc (st_nextnode s0) \\/ Ple (st_nextnode s') pc.","conclusion":"Plt pc (st_nextnode s0) \\/ Ple (st_nextnode s') pc","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s1) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s1) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0)","proofString":"monadInv EQ; simpl.\nextlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s0) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s0) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |}) : Plt pc (Pos.succ (st_nextnode s)) \\/ Ple (st_nextnode s') pc.","conclusion":"Plt pc (Pos.succ (st_nextnode s)) \\/ Ple (st_nextnode s') pc","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s0) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s0) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |})","proofString":"extlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s1) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s1) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0) : (st_code s0) ! pc = (st_code s) ! pc.","conclusion":"(st_code s0) ! pc = (st_code s) ! pc","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s1) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s1) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0)","proofString":"monadInv EQ; simpl.\napply PTree.gso.\ninversion INCR0; simpl in *.\nextlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s0) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s0) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |}) : (PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s)) ! pc =\n(st_code s) ! pc.","conclusion":"(PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s)) ! pc =\n(st_code s) ! pc","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s0) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s0) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |})","proofString":"apply PTree.gso.\ninversion INCR0; simpl in *.\nextlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s0) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s0) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |}) : pc <> st_nextnode s.","conclusion":"pc <> st_nextnode s","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s0) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s0) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |})","proofString":"inversion INCR0; simpl in *.\nextlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s0) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s0) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |}) (NEXTREG : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE : Ple (Pos.succ (st_nextnode s)) (st_nextnode s')) (STKSIZE : st_stksize s <= st_stksize s') : pc <> st_nextnode s.","conclusion":"pc <> st_nextnode s","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0) (pc4 : positive),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\nPlt pc4 (st_nextnode s0) \\/ Ple (st_nextnode s'0) pc4 ->\n(st_code s'0) ! pc4 = (st_code s0) ! pc4) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (pc : positive) (H0 : Plt pc (st_nextnode s) \\/ Ple (st_nextnode s') pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |}) (NEXTREG : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE : Ple (Pos.succ (st_nextnode s)) (st_nextnode s')) (STKSIZE : st_stksize s <= st_stksize s')","proofString":"extlia."},{"statement":"(dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : ret pc2 s = R pc1 s' i) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) : tr_moves c pc1 nil dsts pc2.","conclusion":"tr_moves c pc1 nil dsts pc2","hypotheses":"(dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : ret pc2 s = R pc1 s' i) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc)","proofString":"monadInv H.\napply tr_moves_nil; auto."},{"statement":"(dsts : list reg) (pc1 : node) (s' : state) (i : sincr s' s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s') pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) : tr_moves c pc1 nil dsts pc1.","conclusion":"tr_moves c pc1 nil dsts pc1","hypotheses":"(dsts : list reg) (pc1 : node) (s' : state) (i : sincr s' s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s') pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc)","proofString":"apply tr_moves_nil; auto."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : match dsts with\n| nil => ret pc2\n| d1 :: dl =>\n    do n <- add_instr (Iop Omove (a :: nil) d1 pc2); add_moves srcs dl n\nend s = R pc1 s' i) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) : tr_moves c pc1 (a :: srcs) dsts pc2.","conclusion":"tr_moves c pc1 (a :: srcs) dsts pc2","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : match dsts with\n| nil => ret pc2\n| d1 :: dl =>\n    do n <- add_instr (Iop Omove (a :: nil) d1 pc2); add_moves srcs dl n\nend s = R pc1 s' i) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc)","proofString":"destruct dsts; monadInv H.\napply tr_moves_nil; auto.\napply tr_moves_cons with x.\neapply IHsrcs; eauto.\nintros.\ninversion INCR.\napply H0; extlia.\nmonadInv EQ.\nrewrite H0.\nerewrite add_moves_unchanged; eauto.\nsimpl.\napply PTree.gss.\nsimpl.\nextlia.\nextlia.\ninversion INCR; inversion INCR0; simpl in *; extlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts : list reg) (pc2 : node) (s : state) \n  (pc0 : node) (s'0 : state) (i0 : sincr s s'0) (c0 : PTree.tree instruction),\nadd_moves srcs dsts pc2 s = R pc0 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc0 srcs dsts pc2) (pc1 : node) (s' : state) (i : sincr s' s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s') pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) : tr_moves c pc1 (a :: srcs) nil pc1.","conclusion":"tr_moves c pc1 (a :: srcs) nil pc1","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts : list reg) (pc2 : node) (s : state) \n  (pc0 : node) (s'0 : state) (i0 : sincr s s'0) (c0 : PTree.tree instruction),\nadd_moves srcs dsts pc2 s = R pc0 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc0 srcs dsts pc2) (pc1 : node) (s' : state) (i : sincr s' s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s') pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc)","proofString":"apply tr_moves_nil; auto."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s1) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0) : tr_moves c pc1 (a :: srcs) (r :: dsts) pc2.","conclusion":"tr_moves c pc1 (a :: srcs) (r :: dsts) pc2","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s1) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0)","proofString":"apply tr_moves_cons with x.\neapply IHsrcs; eauto.\nintros.\ninversion INCR.\napply H0; extlia.\nmonadInv EQ.\nrewrite H0.\nerewrite add_moves_unchanged; eauto.\nsimpl.\napply PTree.gss.\nsimpl.\nextlia.\nextlia.\ninversion INCR; inversion INCR0; simpl in *; extlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s1) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0) : tr_moves c pc1 srcs dsts x.","conclusion":"tr_moves c pc1 srcs dsts x","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s1) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0)","proofString":"eapply IHsrcs; eauto.\nintros.\ninversion INCR.\napply H0; extlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s1) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0) : forall pc : positive,\nPle (st_nextnode s0) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc.","conclusion":"forall pc : positive,\nPle (st_nextnode s0) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s1) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0)","proofString":"intros.\ninversion INCR.\napply H0; extlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\n(forall pc4 : positive,\n Ple (st_nextnode s1) pc4 ->\n Plt pc4 (st_nextnode s'0) -> c0 ! pc4 = (st_code s'0) ! pc4) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc0 : positive,\nPle (st_nextnode s) pc0 ->\nPlt pc0 (st_nextnode s') -> c ! pc0 = (st_code s') ! pc0) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0) (pc : positive) (H : Ple (st_nextnode s0) pc) (H1 : Plt pc (st_nextnode s')) : c ! pc = (st_code s') ! pc.","conclusion":"c ! pc = (st_code s') ! pc","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\n(forall pc4 : positive,\n Ple (st_nextnode s1) pc4 ->\n Plt pc4 (st_nextnode s'0) -> c0 ! pc4 = (st_code s'0) ! pc4) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc0 : positive,\nPle (st_nextnode s) pc0 ->\nPlt pc0 (st_nextnode s') -> c ! pc0 = (st_code s') ! pc0) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0) (pc : positive) (H : Ple (st_nextnode s0) pc) (H1 : Plt pc (st_nextnode s'))","proofString":"inversion INCR.\napply H0; extlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\n(forall pc4 : positive,\n Ple (st_nextnode s1) pc4 ->\n Plt pc4 (st_nextnode s'0) -> c0 ! pc4 = (st_code s'0) ! pc4) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc0 : positive,\nPle (st_nextnode s) pc0 ->\nPlt pc0 (st_nextnode s') -> c ! pc0 = (st_code s') ! pc0) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0) (pc : positive) (H : Ple (st_nextnode s0) pc) (H1 : Plt pc (st_nextnode s')) (NEXTREG : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE : st_stksize s <= st_stksize s0) : c ! pc = (st_code s') ! pc.","conclusion":"c ! pc = (st_code s') ! pc","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\n(forall pc4 : positive,\n Ple (st_nextnode s1) pc4 ->\n Plt pc4 (st_nextnode s'0) -> c0 ! pc4 = (st_code s'0) ! pc4) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc0 : positive,\nPle (st_nextnode s) pc0 ->\nPlt pc0 (st_nextnode s') -> c ! pc0 = (st_code s') ! pc0) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0) (pc : positive) (H : Ple (st_nextnode s0) pc) (H1 : Plt pc (st_nextnode s')) (NEXTREG : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE : st_stksize s <= st_stksize s0)","proofString":"apply H0; extlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s1) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0) : c ! x = Some (Iop Omove (a :: nil) r pc2).","conclusion":"c ! x = Some (Iop Omove (a :: nil) r pc2)","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s1 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s1 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s1) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (x : node) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : add_instr (Iop Omove (a :: nil) r pc2) s = R x s0 INCR) (EQ0 : add_moves srcs dsts x s0 = R pc1 s' INCR0)","proofString":"monadInv EQ.\nrewrite H0.\nerewrite add_moves_unchanged; eauto.\nsimpl.\napply PTree.gss.\nsimpl.\nextlia.\nextlia.\ninversion INCR; inversion INCR0; simpl in *; extlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |}) : c ! (st_nextnode s) = Some (Iop Omove (a :: nil) r pc2).","conclusion":"c ! (st_nextnode s) = Some (Iop Omove (a :: nil) r pc2)","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |})","proofString":"rewrite H0.\nerewrite add_moves_unchanged; eauto.\nsimpl.\napply PTree.gss.\nsimpl.\nextlia.\nextlia.\ninversion INCR; inversion INCR0; simpl in *; extlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |}) : (st_code s') ! (st_nextnode s) = Some (Iop Omove (a :: nil) r pc2).","conclusion":"(st_code s') ! (st_nextnode s) = Some (Iop Omove (a :: nil) r pc2)","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |})","proofString":"erewrite add_moves_unchanged; eauto.\nsimpl.\napply PTree.gss.\nsimpl.\nextlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |}) : (st_code\n   {|\n     st_nextreg := st_nextreg s;\n     st_nextnode := Pos.succ (st_nextnode s);\n     st_code :=\n       PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n     st_stksize := st_stksize s\n   |}) ! (st_nextnode s) = Some (Iop Omove (a :: nil) r pc2).","conclusion":"(st_code\n   {|\n     st_nextreg := st_nextreg s;\n     st_nextnode := Pos.succ (st_nextnode s);\n     st_code :=\n       PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n     st_stksize := st_stksize s\n   |}) ! (st_nextnode s) = Some (Iop Omove (a :: nil) r pc2)","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |})","proofString":"simpl.\napply PTree.gss."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |}) : (PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s))\n! (st_nextnode s) = Some (Iop Omove (a :: nil) r pc2).","conclusion":"(PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s))\n! (st_nextnode s) = Some (Iop Omove (a :: nil) r pc2)","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |})","proofString":"apply PTree.gss."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |}) : Plt (st_nextnode s)\n  (st_nextnode\n     {|\n       st_nextreg := st_nextreg s;\n       st_nextnode := Pos.succ (st_nextnode s);\n       st_code :=\n         PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n       st_stksize := st_stksize s\n     |}) \\/ Ple (st_nextnode s') (st_nextnode s).","conclusion":"Plt (st_nextnode s)\n  (st_nextnode\n     {|\n       st_nextreg := st_nextreg s;\n       st_nextnode := Pos.succ (st_nextnode s);\n       st_code :=\n         PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n       st_stksize := st_stksize s\n     |}) \\/ Ple (st_nextnode s') (st_nextnode s)","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |})","proofString":"simpl.\nextlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |}) : Plt (st_nextnode s) (Pos.succ (st_nextnode s)) \\/\nPle (st_nextnode s') (st_nextnode s).","conclusion":"Plt (st_nextnode s) (Pos.succ (st_nextnode s)) \\/\nPle (st_nextnode s') (st_nextnode s)","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |})","proofString":"extlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |}) : Ple (st_nextnode s) (st_nextnode s).","conclusion":"Ple (st_nextnode s) (st_nextnode s)","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |})","proofString":"extlia."},{"statement":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |}) : Plt (st_nextnode s) (st_nextnode s').","conclusion":"Plt (st_nextnode s) (st_nextnode s')","hypotheses":"(a : reg) (srcs : list reg) (IHsrcs : forall (dsts0 : list reg) (pc0 : node) (s0 : state) \n  (pc3 : node) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nadd_moves srcs dsts0 pc0 s0 = R pc3 s'0 i0 ->\n(forall pc : positive,\n Ple (st_nextnode s0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_moves c0 pc3 srcs dsts0 pc0) (r : reg) (dsts : list reg) (pc2 : node) (s : state) (pc1 : node) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : forall pc : positive,\nPle (st_nextnode s) pc ->\nPlt pc (st_nextnode s') -> c ! pc = (st_code s') ! pc) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} s') (EQ0 : add_moves srcs dsts (st_nextnode s)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |} = R pc1 s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := Pos.succ (st_nextnode s);\n    st_code :=\n      PTree.set (st_nextnode s) (Iop Omove (a :: nil) r pc2) (st_code s);\n    st_stksize := st_stksize s\n  |})","proofString":"inversion INCR; inversion INCR0; simpl in *; extlia."},{"statement":"(pc : node) (instr : instruction) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : node) (H : set_instr pc instr s = R x s' i) (H0 : pc' <> pc) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(pc : node) (instr : instruction) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : node) (H : set_instr pc instr s = R x s' i) (H0 : pc' <> pc)","proofString":"monadInv H; simpl.\napply PTree.gso; auto."},{"statement":"(pc : node) (instr : instruction) (s : state) (i : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := PTree.set pc instr (st_code s);\n    st_stksize := st_stksize s\n  |}) (pc' : node) (H0 : pc' <> pc) : (PTree.set pc instr (st_code s)) ! pc' = (st_code s) ! pc'.","conclusion":"(PTree.set pc instr (st_code s)) ! pc' = (st_code s) ! pc'","hypotheses":"(pc : node) (instr : instruction) (s : state) (i : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := PTree.set pc instr (st_code s);\n    st_stksize := st_stksize s\n  |}) (pc' : node) (H0 : pc' <> pc)","proofString":"apply PTree.gso; auto."},{"statement":"(pc : node) (instr : instruction) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : set_instr pc instr s = R x s' i) (H0 : c ! pc = (st_code s') ! pc) : c ! pc = Some instr.","conclusion":"c ! pc = Some instr","hypotheses":"(pc : node) (instr : instruction) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : set_instr pc instr s = R x s' i) (H0 : c ! pc = (st_code s') ! pc)","proofString":"rewrite H0.\nmonadInv H; simpl.\napply PTree.gss."},{"statement":"(pc : node) (instr : instruction) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : set_instr pc instr s = R x s' i) (H0 : c ! pc = (st_code s') ! pc) : (st_code s') ! pc = Some instr.","conclusion":"(st_code s') ! pc = Some instr","hypotheses":"(pc : node) (instr : instruction) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : set_instr pc instr s = R x s' i) (H0 : c ! pc = (st_code s') ! pc)","proofString":"monadInv H; simpl.\napply PTree.gss."},{"statement":"(pc : node) (instr : instruction) (s : state) (i : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := PTree.set pc instr (st_code s);\n    st_stksize := st_stksize s\n  |}) (c : PTree.tree instruction) (H0 : c ! pc =\n(st_code\n   {|\n     st_nextreg := st_nextreg s;\n     st_nextnode := st_nextnode s;\n     st_code := PTree.set pc instr (st_code s);\n     st_stksize := st_stksize s\n   |}) ! pc) : (PTree.set pc instr (st_code s)) ! pc = Some instr.","conclusion":"(PTree.set pc instr (st_code s)) ! pc = Some instr","hypotheses":"(pc : node) (instr : instruction) (s : state) (i : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := PTree.set pc instr (st_code s);\n    st_stksize := st_stksize s\n  |}) (c : PTree.tree instruction) (H0 : c ! pc =\n(st_code\n   {|\n     st_nextreg := st_nextreg s;\n     st_nextnode := st_nextnode s;\n     st_code := PTree.set pc instr (st_code s);\n     st_stksize := st_stksize s\n   |}) ! pc)","proofString":"apply PTree.gss."},{"statement":"(A : forall (pc : node) (instr : instruction) (s : state) \n  (x : unit) (s' : state) (i : sincr s s') (pc' : node),\nset_instr pc instr s = R x s' i ->\npc' <> pc -> (st_code s') ! pc' = (st_code s) ! pc') : forall (ctx : context) (pc : node) (instr : instruction) \n  (s : state) (x : unit) (s' : state) (i : sincr s s') \n  (pc' : positive),\nexpand_instr fe rec ctx pc instr s = R x s' i ->\nPle (dpc ctx) (st_nextnode s) ->\nPlt pc' (st_nextnode s) ->\npc' <> spc ctx pc -> (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"forall (ctx : context) (pc : node) (instr : instruction) \n  (s : state) (x : unit) (s' : state) (i : sincr s s') \n  (pc' : positive),\nexpand_instr fe rec ctx pc instr s = R x s' i ->\nPle (dpc ctx) (st_nextnode s) ->\nPlt pc' (st_nextnode s) ->\npc' <> spc ctx pc -> (st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc : node) (instr : instruction) (s : state) \n  (x : unit) (s' : state) (i : sincr s s') (pc' : node),\nset_instr pc instr s = R x s' i ->\npc' <> pc -> (st_code s') ! pc' = (st_code s) ! pc')","proofString":"intros.\nunfold expand_instr in H; destruct instr; eauto.\ndestruct (can_inline fe s1).\neauto.\nmonadInv H.\nunfold inline_function in EQ.\nmonadInv EQ.\ntransitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto.\ndestruct (can_inline fe s1).\ndestruct (retinfo ctx) as [[rpc rreg]|]; eauto.\nmonadInv H.\nunfold inline_tail_function in EQ.\nmonadInv EQ.\ntransitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto.\ndestruct (retinfo ctx) as [[rpc rreg]|]; eauto."},{"statement":"(A : forall (pc0 : node) (instr0 : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc'0 : node),\nset_instr pc0 instr0 s0 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s0) ! pc'0) (ctx : context) (pc : node) (instr : instruction) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (H : expand_instr fe rec ctx pc instr s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr0 : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc'0 : node),\nset_instr pc0 instr0 s0 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s0) ! pc'0) (ctx : context) (pc : node) (instr : instruction) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (H : expand_instr fe rec ctx pc instr s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc)","proofString":"unfold expand_instr in H; destruct instr; eauto.\ndestruct (can_inline fe s1).\neauto.\nmonadInv H.\nunfold inline_function in EQ.\nmonadInv EQ.\ntransitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto.\ndestruct (can_inline fe s1).\ndestruct (retinfo ctx) as [[rpc rreg]|]; eauto.\nmonadInv H.\nunfold inline_tail_function in EQ.\nmonadInv EQ.\ntransitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto.\ndestruct (retinfo ctx) as [[rpc rreg]|]; eauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (pc'0 : node),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s2) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (H : match can_inline fe s1 with\n| Cannot_inline _ _ =>\n    set_instr (spc ctx pc)\n      (Icall s0 (sros ctx s1) (sregs ctx l) (sreg ctx r) (spc ctx n))\n| Can_inline _ _ id f _ Q =>\n    do n0 <- inline_function fe rec ctx id f Q l n r;\n    set_instr (spc ctx pc) (Inop n0)\nend s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (pc'0 : node),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s2) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (H : match can_inline fe s1 with\n| Cannot_inline _ _ =>\n    set_instr (spc ctx pc)\n      (Icall s0 (sros ctx s1) (sregs ctx l) (sreg ctx r) (spc ctx n))\n| Can_inline _ _ id f _ Q =>\n    do n0 <- inline_function fe rec ctx id f Q l n r;\n    set_instr (spc ctx pc) (Inop n0)\nend s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc)","proofString":"destruct (can_inline fe s1).\neauto.\nmonadInv H.\nunfold inline_function in EQ.\nmonadInv EQ.\ntransitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (pc'0 : node),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s2) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (H : set_instr (spc ctx pc)\n  (Icall s0 (sros ctx s1) (sregs ctx l) (sreg ctx r) (spc ctx n)) s =\nR x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (pc'0 : node),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s2) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (H : set_instr (spc ctx pc)\n  (Icall s0 (sros ctx s1) (sregs ctx l) (sreg ctx r) (spc ctx n)) s =\nR x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc)","proofString":"eauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (pc'0 : node),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s2) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H : (do n0 <- inline_function fe rec ctx id f Q l n r;\n set_instr (spc ctx pc) (Inop n0)) s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (pc'0 : node),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s2) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H : (do n0 <- inline_function fe rec ctx id f Q l n r;\n set_instr (spc ctx pc) (Inop n0)) s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc)","proofString":"monadInv H.\nunfold inline_function in EQ.\nmonadInv EQ.\ntransitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s3 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s3 s'0) (pc'0 : node),\nset_instr pc0 instr s3 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s3) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ : inline_function fe rec ctx id f Q l n r s = R x0 s2 INCR) (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s3 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s3 s'0) (pc'0 : node),\nset_instr pc0 instr s3 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s3) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ : inline_function fe rec ctx id f Q l n r s = R x0 s2 INCR) (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0)","proofString":"unfold inline_function in EQ.\nmonadInv EQ.\ntransitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s3 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s3 s'0) (pc'0 : node),\nset_instr pc0 instr s3 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s3) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ : (do dpc <- reserve_nodes (max_pc_function f);\n do dreg <- reserve_regs (max_reg_function f);\n do _ <-\n rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n   (callcontext ctx dpc dreg (max_reg_function f) (fn_stacksize f) n r) f;\n add_moves (sregs ctx l)\n   (sregs\n      (callcontext ctx dpc dreg (max_reg_function f) (fn_stacksize f) n r)\n      (fn_params f))\n   (spc (callcontext ctx dpc dreg (max_reg_function f) (fn_stacksize f) n r)\n      (fn_entrypoint f))) s = R x0 s2 INCR) (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s3 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s3 s'0) (pc'0 : node),\nset_instr pc0 instr s3 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s3) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ : (do dpc <- reserve_nodes (max_pc_function f);\n do dreg <- reserve_regs (max_reg_function f);\n do _ <-\n rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n   (callcontext ctx dpc dreg (max_reg_function f) (fn_stacksize f) n r) f;\n add_moves (sregs ctx l)\n   (sregs\n      (callcontext ctx dpc dreg (max_reg_function f) (fn_stacksize f) n r)\n      (fn_params f))\n   (spc (callcontext ctx dpc dreg (max_reg_function f) (fn_stacksize f) n r)\n      (fn_entrypoint f))) s = R x0 s2 INCR) (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0)","proofString":"monadInv EQ.\ntransitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"transitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s') ! pc' = (st_code s2) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s2) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"eauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s2) ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s2) ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"transitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s2) ! pc' = (st_code s5) ! pc'.","conclusion":"(st_code s2) ! pc' = (st_code s5) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"eapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : Plt pc' (st_nextnode s5) \\/ Ple (st_nextnode s2) pc'.","conclusion":"Plt pc' (st_nextnode s5) \\/ Ple (st_nextnode s2) pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"left.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : Plt pc' (st_nextnode s5).","conclusion":"Plt pc' (st_nextnode s5)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"inversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s5)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s5)) (STKSIZE : st_stksize s4 <= st_stksize s5) : Plt pc' (st_nextnode s5).","conclusion":"Plt pc' (st_nextnode s5)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s5)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s5)) (STKSIZE : st_stksize s4 <= st_stksize s5)","proofString":"inversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s5)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s5)) (STKSIZE : st_stksize s4 <= st_stksize s5) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) : Plt pc' (st_nextnode s5).","conclusion":"Plt pc' (st_nextnode s5)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s5)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s5)) (STKSIZE : st_stksize s4 <= st_stksize s5) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4)","proofString":"monadInv EQ1; simpl in *.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x2 : positive) (s4 : state) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (callcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f) n r) (fn_params f))\n  (spc\n     (callcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f) n r) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx (st_nextnode s) x2 (max_reg_function f) \n     (fn_stacksize f) n r) f s4 = R x3 s5 INCR5) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s5)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s5)) (STKSIZE : st_stksize s4 <= st_stksize s5) (STKSIZE0 : st_stksize s <= st_stksize s4) (NEXTNODE0 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s4)) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s4)) : Plt pc' (st_nextnode s5).","conclusion":"Plt pc' (st_nextnode s5)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x2 : positive) (s4 : state) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (callcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f) n r) (fn_params f))\n  (spc\n     (callcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f) n r) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx (st_nextnode s) x2 (max_reg_function f) \n     (fn_stacksize f) n r) f s4 = R x3 s5 INCR5) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s5)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s5)) (STKSIZE : st_stksize s4 <= st_stksize s5) (STKSIZE0 : st_stksize s <= st_stksize s4) (NEXTNODE0 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s4)) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s4))","proofString":"extlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s5) ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s5) ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"transitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s5) ! pc' = (st_code s4) ! pc'.","conclusion":"(st_code s5) ! pc' = (st_code s4) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"eapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : Ple (dpc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r))\n  (st_nextnode s4).","conclusion":"Ple (dpc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r))\n  (st_nextnode s4)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"simpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : Ple x1 (st_nextnode s4).","conclusion":"Ple x1 (st_nextnode s4)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"monadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x2 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x2 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (INCR4 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s2) (INCR3 : sincr s3\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (callcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f) n r) (fn_params f))\n  (spc\n     (callcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f) n r) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 (st_nextreg s3) (max_reg_function f) \n     (fn_stacksize f) n r) f\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} = R x3 s5 INCR5) : Ple x1 (st_nextnode s3).","conclusion":"Ple x1 (st_nextnode s3)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x2 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x2 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (INCR4 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s2) (INCR3 : sincr s3\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (callcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f) n r) (fn_params f))\n  (spc\n     (callcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f) n r) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 (st_nextreg s3) (max_reg_function f) \n     (fn_stacksize f) n r) f\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} = R x3 s5 INCR5)","proofString":"monadInv EQ1; simpl.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |}) (INCR4 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s2) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (callcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f) n r) \n     (fn_params f))\n  (spc\n     (callcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f) n r) \n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx (st_nextnode s)\n     (st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}) (max_reg_function f) (fn_stacksize f) n r) f\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} = R x3 s5 INCR5) : Ple (st_nextnode s) (st_nextnode s + max_pc_function f).","conclusion":"Ple (st_nextnode s) (st_nextnode s + max_pc_function f)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |}) (INCR4 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s2) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (callcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f) n r) \n     (fn_params f))\n  (spc\n     (callcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f) n r) \n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx (st_nextnode s)\n     (st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}) (max_reg_function f) (fn_stacksize f) n r) f\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} = R x3 s5 INCR5)","proofString":"extlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : Plt pc'\n  (dpc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)).","conclusion":"Plt pc'\n  (dpc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r))","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : Plt pc' x1.","conclusion":"Plt pc' x1","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"monadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x2 : positive) (s4 : state) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (callcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f) n r) (fn_params f))\n  (spc\n     (callcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f) n r) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx (st_nextnode s) x2 (max_reg_function f) \n     (fn_stacksize f) n r) f s4 = R x3 s5 INCR5) : Plt pc' (st_nextnode s).","conclusion":"Plt pc' (st_nextnode s)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x2 : positive) (s4 : state) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (callcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f) n r) (fn_params f))\n  (spc\n     (callcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f) n r) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx (st_nextnode s) x2 (max_reg_function f) \n     (fn_stacksize f) n r) f s4 = R x3 s5 INCR5)","proofString":"auto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s4) ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s4) ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"monadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x2 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x2 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (INCR4 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s2) (INCR3 : sincr s3\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (callcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f) n r) (fn_params f))\n  (spc\n     (callcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f) n r) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 (st_nextreg s3) (max_reg_function f) \n     (fn_stacksize f) n r) f\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} = R x3 s5 INCR5) : (st_code s3) ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s3) ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x2 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x2 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (INCR4 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s2) (INCR3 : sincr s3\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (callcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f) n r) (fn_params f))\n  (spc\n     (callcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f) n r) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 (st_nextreg s3) (max_reg_function f) \n     (fn_stacksize f) n r) f\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} = R x3 s5 INCR5)","proofString":"monadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |}) (INCR4 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s2) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (callcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f) n r) \n     (fn_params f))\n  (spc\n     (callcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f) n r) \n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx (st_nextnode s)\n     (st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}) (max_reg_function f) (fn_stacksize f) n r) f\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} = R x3 s5 INCR5) : (st_code s) ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s) ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |}) (INCR4 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s2) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (callcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f) n r) \n     (fn_params f))\n  (spc\n     (callcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f) n r) \n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx (st_nextnode s)\n     (st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}) (max_reg_function f) (fn_stacksize f) n r) f\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} = R x3 s5 INCR5)","proofString":"auto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (pc'0 : node),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s2) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (H : match can_inline fe s1 with\n| Cannot_inline _ _ =>\n    match retinfo ctx with\n    | Some (rpc, rreg) =>\n        set_instr (spc ctx pc)\n          (Icall s0 (sros ctx s1) (sregs ctx l) rreg rpc)\n    | None =>\n        set_instr (spc ctx pc) (Itailcall s0 (sros ctx s1) (sregs ctx l))\n    end\n| Can_inline _ _ id f _ Q =>\n    do n <- inline_tail_function fe rec ctx id f Q l;\n    set_instr (spc ctx pc) (Inop n)\nend s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (pc'0 : node),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s2) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (H : match can_inline fe s1 with\n| Cannot_inline _ _ =>\n    match retinfo ctx with\n    | Some (rpc, rreg) =>\n        set_instr (spc ctx pc)\n          (Icall s0 (sros ctx s1) (sregs ctx l) rreg rpc)\n    | None =>\n        set_instr (spc ctx pc) (Itailcall s0 (sros ctx s1) (sregs ctx l))\n    end\n| Can_inline _ _ id f _ Q =>\n    do n <- inline_tail_function fe rec ctx id f Q l;\n    set_instr (spc ctx pc) (Inop n)\nend s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc)","proofString":"destruct (can_inline fe s1).\ndestruct (retinfo ctx) as [[rpc rreg]|]; eauto.\nmonadInv H.\nunfold inline_tail_function in EQ.\nmonadInv EQ.\ntransitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (pc'0 : node),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s2) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (H : match retinfo ctx with\n| Some (rpc, rreg) =>\n    set_instr (spc ctx pc) (Icall s0 (sros ctx s1) (sregs ctx l) rreg rpc)\n| None => set_instr (spc ctx pc) (Itailcall s0 (sros ctx s1) (sregs ctx l))\nend s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (pc'0 : node),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s2) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (H : match retinfo ctx with\n| Some (rpc, rreg) =>\n    set_instr (spc ctx pc) (Icall s0 (sros ctx s1) (sregs ctx l) rreg rpc)\n| None => set_instr (spc ctx pc) (Itailcall s0 (sros ctx s1) (sregs ctx l))\nend s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc)","proofString":"destruct (retinfo ctx) as [[rpc rreg]|]; eauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (pc'0 : node),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s2) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H : (do n <- inline_tail_function fe rec ctx id f Q l;\n set_instr (spc ctx pc) (Inop n)) s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (pc'0 : node),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s2) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H : (do n <- inline_tail_function fe rec ctx id f Q l;\n set_instr (spc ctx pc) (Inop n)) s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc)","proofString":"monadInv H.\nunfold inline_tail_function in EQ.\nmonadInv EQ.\ntransitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s3 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s3 s'0) (pc'0 : node),\nset_instr pc0 instr s3 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s3) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ : inline_tail_function fe rec ctx id f Q l s = R x0 s2 INCR) (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s3 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s3 s'0) (pc'0 : node),\nset_instr pc0 instr s3 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s3) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ : inline_tail_function fe rec ctx id f Q l s = R x0 s2 INCR) (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0)","proofString":"unfold inline_tail_function in EQ.\nmonadInv EQ.\ntransitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s3 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s3 s'0) (pc'0 : node),\nset_instr pc0 instr s3 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s3) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ : (do dpc <- reserve_nodes (max_pc_function f);\n do dreg <- reserve_regs (max_reg_function f);\n do _ <-\n rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n   (tailcontext ctx dpc dreg (max_reg_function f) (fn_stacksize f)) f;\n add_moves (sregs ctx l)\n   (sregs (tailcontext ctx dpc dreg (max_reg_function f) (fn_stacksize f))\n      (fn_params f))\n   (spc (tailcontext ctx dpc dreg (max_reg_function f) (fn_stacksize f))\n      (fn_entrypoint f))) s = R x0 s2 INCR) (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s3 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s3 s'0) (pc'0 : node),\nset_instr pc0 instr s3 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s3) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ : (do dpc <- reserve_nodes (max_pc_function f);\n do dreg <- reserve_regs (max_reg_function f);\n do _ <-\n rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n   (tailcontext ctx dpc dreg (max_reg_function f) (fn_stacksize f)) f;\n add_moves (sregs ctx l)\n   (sregs (tailcontext ctx dpc dreg (max_reg_function f) (fn_stacksize f))\n      (fn_params f))\n   (spc (tailcontext ctx dpc dreg (max_reg_function f) (fn_stacksize f))\n      (fn_entrypoint f))) s = R x0 s2 INCR) (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0)","proofString":"monadInv EQ.\ntransitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"transitivity (s2.(st_code)!pc').\neauto.\ntransitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s') ! pc' = (st_code s2) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s2) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"eauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s2) ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s2) ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"transitivity (s5.(st_code)!pc').\neapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia.\ntransitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s2) ! pc' = (st_code s5) ! pc'.","conclusion":"(st_code s2) ! pc' = (st_code s5) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"eapply add_moves_unchanged; eauto.\nleft.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : Plt pc' (st_nextnode s5) \\/ Ple (st_nextnode s2) pc'.","conclusion":"Plt pc' (st_nextnode s5) \\/ Ple (st_nextnode s2) pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"left.\ninversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : Plt pc' (st_nextnode s5).","conclusion":"Plt pc' (st_nextnode s5)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"inversion INCR5.\ninversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s5)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s5)) (STKSIZE : st_stksize s4 <= st_stksize s5) : Plt pc' (st_nextnode s5).","conclusion":"Plt pc' (st_nextnode s5)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s5)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s5)) (STKSIZE : st_stksize s4 <= st_stksize s5)","proofString":"inversion INCR3.\nmonadInv EQ1; simpl in *.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s5)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s5)) (STKSIZE : st_stksize s4 <= st_stksize s5) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) : Plt pc' (st_nextnode s5).","conclusion":"Plt pc' (st_nextnode s5)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s5)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s5)) (STKSIZE : st_stksize s4 <= st_stksize s5) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4)","proofString":"monadInv EQ1; simpl in *.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x2 : positive) (s4 : state) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (tailcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f)) (fn_params f))\n  (spc\n     (tailcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f)) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx (st_nextnode s) x2 (max_reg_function f) (fn_stacksize f))\n  f s4 = R x3 s5 INCR5) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s5)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s5)) (STKSIZE : st_stksize s4 <= st_stksize s5) (STKSIZE0 : st_stksize s <= st_stksize s4) (NEXTNODE0 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s4)) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s4)) : Plt pc' (st_nextnode s5).","conclusion":"Plt pc' (st_nextnode s5)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x2 : positive) (s4 : state) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (tailcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f)) (fn_params f))\n  (spc\n     (tailcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f)) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx (st_nextnode s) x2 (max_reg_function f) (fn_stacksize f))\n  f s4 = R x3 s5 INCR5) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s5)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s5)) (STKSIZE : st_stksize s4 <= st_stksize s5) (STKSIZE0 : st_stksize s <= st_stksize s4) (NEXTNODE0 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s4)) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s4))","proofString":"extlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s5) ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s5) ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"transitivity (s4.(st_code)!pc').\neapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s5) ! pc' = (st_code s4) ! pc'.","conclusion":"(st_code s5) ! pc' = (st_code s4) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"eapply rec_unchanged; eauto.\nsimpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia.\nsimpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : Ple (dpc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)))\n  (st_nextnode s4).","conclusion":"Ple (dpc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)))\n  (st_nextnode s4)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"simpl.\nmonadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : Ple x1 (st_nextnode s4).","conclusion":"Ple x1 (st_nextnode s4)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"monadInv EQ; simpl.\nmonadInv EQ1; simpl.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x2 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x2 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (INCR4 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s2) (INCR3 : sincr s3\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (tailcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f)) (fn_params f))\n  (spc\n     (tailcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f)) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 (st_nextreg s3) (max_reg_function f) (fn_stacksize f))\n  f\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} = R x3 s5 INCR5) : Ple x1 (st_nextnode s3).","conclusion":"Ple x1 (st_nextnode s3)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x2 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x2 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (INCR4 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s2) (INCR3 : sincr s3\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (tailcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f)) (fn_params f))\n  (spc\n     (tailcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f)) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 (st_nextreg s3) (max_reg_function f) (fn_stacksize f))\n  f\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} = R x3 s5 INCR5)","proofString":"monadInv EQ1; simpl.\nextlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |}) (INCR4 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s2) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (tailcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f)) \n     (fn_params f))\n  (spc\n     (tailcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f)) \n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx (st_nextnode s)\n     (st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}) (max_reg_function f) (fn_stacksize f)) f\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} = R x3 s5 INCR5) : Ple (st_nextnode s) (st_nextnode s + max_pc_function f).","conclusion":"Ple (st_nextnode s) (st_nextnode s + max_pc_function f)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |}) (INCR4 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s2) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (tailcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f)) \n     (fn_params f))\n  (spc\n     (tailcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f)) \n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx (st_nextnode s)\n     (st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}) (max_reg_function f) (fn_stacksize f)) f\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} = R x3 s5 INCR5)","proofString":"extlia."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : Plt pc' (dpc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))).","conclusion":"Plt pc' (dpc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)))","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : Plt pc' x1.","conclusion":"Plt pc' x1","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"monadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x2 : positive) (s4 : state) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (tailcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f)) (fn_params f))\n  (spc\n     (tailcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f)) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx (st_nextnode s) x2 (max_reg_function f) (fn_stacksize f))\n  f s4 = R x3 s5 INCR5) : Plt pc' (st_nextnode s).","conclusion":"Plt pc' (st_nextnode s)","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x2 : positive) (s4 : state) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (tailcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f)) (fn_params f))\n  (spc\n     (tailcontext ctx (st_nextnode s) x2 (max_reg_function f)\n        (fn_stacksize f)) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx (st_nextnode s) x2 (max_reg_function f) (fn_stacksize f))\n  f s4 = R x3 s5 INCR5)","proofString":"auto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) : (st_code s4) ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s4) ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s6 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s6 s'0) (pc'0 : node),\nset_instr pc0 instr s6 = R x4 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s6) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (x2 : positive) (s4 : state) (INCR3 : sincr s3 s4) (INCR4 : sincr s4 s2) (EQ : reserve_regs (max_reg_function f) s3 = R x2 s4 INCR3) (x3 : unit) (s5 : state) (INCR5 : sincr s4 s5) (INCR6 : sincr s5 s2) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s4 =\nR x3 s5 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s5 = R x0 s2 INCR6)","proofString":"monadInv EQ; simpl.\nmonadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x2 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x2 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (INCR4 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s2) (INCR3 : sincr s3\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (tailcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f)) (fn_params f))\n  (spc\n     (tailcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f)) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 (st_nextreg s3) (max_reg_function f) (fn_stacksize f))\n  f\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} = R x3 s5 INCR5) : (st_code s3) ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s3) ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x2 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x2 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (x1 : positive) (s3 : state) (INCR1 : sincr s s3) (INCR2 : sincr s3 s2) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s3 INCR1) (INCR4 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s2) (INCR3 : sincr s3\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (tailcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f)) (fn_params f))\n  (spc\n     (tailcontext ctx x1 (st_nextreg s3) (max_reg_function f)\n        (fn_stacksize f)) (fn_entrypoint f)) s5 = \nR x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 (st_nextreg s3) (max_reg_function f) (fn_stacksize f))\n  f\n  {|\n    st_nextreg := st_nextreg s3 + max_reg_function f;\n    st_nextnode := st_nextnode s3;\n    st_code := st_code s3;\n    st_stksize := st_stksize s3\n  |} = R x3 s5 INCR5)","proofString":"monadInv EQ1; simpl.\nauto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |}) (INCR4 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s2) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (tailcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f)) \n     (fn_params f))\n  (spc\n     (tailcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f)) \n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx (st_nextnode s)\n     (st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}) (max_reg_function f) (fn_stacksize f)) f\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} = R x3 s5 INCR5) : (st_code s) ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s) ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0) (pc'0 : node),\nset_instr pc0 instr s1 = R x1 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s1) ! pc'0) (ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (id : ident) (f : function) (Q : fe ! id = Some f) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) (x0 : node) (s2 : state) (INCR : sincr s s2) (INCR0 : sincr s2 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s2 = R x s' INCR0) (INCR3 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |}) (INCR4 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s2) (INCR2 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} s2) (INCR1 : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}) (x3 : unit) (s5 : state) (INCR5 : sincr\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} s5) (INCR6 : sincr s5 s2) (EQ4 : add_moves (sregs ctx l)\n  (sregs\n     (tailcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f)) \n     (fn_params f))\n  (spc\n     (tailcontext ctx (st_nextnode s)\n        (st_nextreg\n           {|\n             st_nextreg := st_nextreg s;\n             st_nextnode := st_nextnode s + max_pc_function f;\n             st_code := st_code s;\n             st_stksize := st_stksize s\n           |}) (max_reg_function f) (fn_stacksize f)) \n     (fn_entrypoint f)) s5 = R x0 s2 INCR6) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx (st_nextnode s)\n     (st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}) (max_reg_function f) (fn_stacksize f)) f\n  {|\n    st_nextreg :=\n      st_nextreg\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |} + max_reg_function f;\n    st_nextnode :=\n      st_nextnode\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_code :=\n      st_code\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |};\n    st_stksize :=\n      st_stksize\n        {|\n          st_nextreg := st_nextreg s;\n          st_nextnode := st_nextnode s + max_pc_function f;\n          st_code := st_code s;\n          st_stksize := st_stksize s\n        |}\n  |} = R x3 s5 INCR5)","proofString":"auto."},{"statement":"(A : forall (pc0 : node) (instr : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc'0 : node),\nset_instr pc0 instr s0 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s0) ! pc'0) (ctx : context) (pc : node) (o : option reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (H : match retinfo ctx with\n| Some rinfo => set_instr (spc ctx pc) (inline_return ctx o rinfo)\n| None => set_instr (spc ctx pc) (Ireturn (option_map (sreg ctx) o))\nend s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc) : (st_code s') ! pc' = (st_code s) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s) ! pc'","hypotheses":"(A : forall (pc0 : node) (instr : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc'0 : node),\nset_instr pc0 instr s0 = R x0 s'0 i0 ->\npc'0 <> pc0 -> (st_code s'0) ! pc'0 = (st_code s0) ! pc'0) (ctx : context) (pc : node) (o : option reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc' : positive) (H : match retinfo ctx with\n| Some rinfo => set_instr (spc ctx pc) (inline_return ctx o rinfo)\n| None => set_instr (spc ctx pc) (Ireturn (option_map (sreg ctx) o))\nend s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc' (st_nextnode s)) (H2 : pc' <> spc ctx pc)","proofString":"destruct (retinfo ctx) as [[rpc rreg]|]; eauto."},{"statement":"(ctx : context) (pc : positive) (a : node * instruction) (l : list (node * instruction)) (IHl : forall (s0 : state) (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s0 = R x0 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s0) ->\nPlt pc (st_nextnode s0) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s0) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H : (let (x0, y) := a in\n do _ <- expand_instr fe rec ctx x0 y;\n mlist_iter2 (expand_instr fe rec ctx) l) s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx (fst a) = pc \\/ In pc (map (spc ctx) (map fst l)))) (H3 : list_norepet (fst a :: map fst l)) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(ctx : context) (pc : positive) (a : node * instruction) (l : list (node * instruction)) (IHl : forall (s0 : state) (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s0 = R x0 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s0) ->\nPlt pc (st_nextnode s0) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s0) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H : (let (x0, y) := a in\n do _ <- expand_instr fe rec ctx x0 y;\n mlist_iter2 (expand_instr fe rec ctx) l) s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx (fst a) = pc \\/ In pc (map (spc ctx) (map fst l)))) (H3 : list_norepet (fst a :: map fst l))","proofString":"destruct a as [pc1 instr1]; simpl in *.\nmonadInv H.\ninv H3.\ntransitivity ((st_code s0)!pc).\neapply IHl; eauto.\ndestruct INCR; extlia.\ndestruct INCR; extlia.\neapply expand_instr_unchanged; eauto."},{"statement":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s0 : state) (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s0 = R x0 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s0) ->\nPlt pc (st_nextnode s0) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s0) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H : (do _ <- expand_instr fe rec ctx pc1 instr1;\n mlist_iter2 (expand_instr fe rec ctx) l) s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (H3 : list_norepet (pc1 :: map fst l)) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s0 : state) (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s0 = R x0 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s0) ->\nPlt pc (st_nextnode s0) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s0) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H : (do _ <- expand_instr fe rec ctx pc1 instr1;\n mlist_iter2 (expand_instr fe rec ctx) l) s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (H3 : list_norepet (pc1 :: map fst l))","proofString":"monadInv H.\ninv H3.\ntransitivity ((st_code s0)!pc).\neapply IHl; eauto.\ndestruct INCR; extlia.\ndestruct INCR; extlia.\neapply expand_instr_unchanged; eauto."},{"statement":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s1) ->\nPlt pc (st_nextnode s1) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s1) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (H3 : list_norepet (pc1 :: map fst l)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s1) ->\nPlt pc (st_nextnode s1) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s1) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (H3 : list_norepet (pc1 :: map fst l)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0)","proofString":"inv H3.\ntransitivity ((st_code s0)!pc).\neapply IHl; eauto.\ndestruct INCR; extlia.\ndestruct INCR; extlia.\neapply expand_instr_unchanged; eauto."},{"statement":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s1) ->\nPlt pc (st_nextnode s1) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s1) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0) (H5 : ~ In pc1 (map fst l)) (H6 : list_norepet (map fst l)) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s1) ->\nPlt pc (st_nextnode s1) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s1) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0) (H5 : ~ In pc1 (map fst l)) (H6 : list_norepet (map fst l))","proofString":"transitivity ((st_code s0)!pc).\neapply IHl; eauto.\ndestruct INCR; extlia.\ndestruct INCR; extlia.\neapply expand_instr_unchanged; eauto."},{"statement":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s1) ->\nPlt pc (st_nextnode s1) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s1) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0) (H5 : ~ In pc1 (map fst l)) (H6 : list_norepet (map fst l)) : (st_code s') ! pc = (st_code s0) ! pc.","conclusion":"(st_code s') ! pc = (st_code s0) ! pc","hypotheses":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s1) ->\nPlt pc (st_nextnode s1) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s1) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0) (H5 : ~ In pc1 (map fst l)) (H6 : list_norepet (map fst l))","proofString":"eapply IHl; eauto.\ndestruct INCR; extlia.\ndestruct INCR; extlia."},{"statement":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s1) ->\nPlt pc (st_nextnode s1) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s1) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0) (H5 : ~ In pc1 (map fst l)) (H6 : list_norepet (map fst l)) : Ple (dpc ctx) (st_nextnode s0).","conclusion":"Ple (dpc ctx) (st_nextnode s0)","hypotheses":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s1) ->\nPlt pc (st_nextnode s1) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s1) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0) (H5 : ~ In pc1 (map fst l)) (H6 : list_norepet (map fst l))","proofString":"destruct INCR; extlia."},{"statement":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s1) ->\nPlt pc (st_nextnode s1) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s1) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0) (H5 : ~ In pc1 (map fst l)) (H6 : list_norepet (map fst l)) : Plt pc (st_nextnode s0).","conclusion":"Plt pc (st_nextnode s0)","hypotheses":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s1) ->\nPlt pc (st_nextnode s1) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s1) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0) (H5 : ~ In pc1 (map fst l)) (H6 : list_norepet (map fst l))","proofString":"destruct INCR; extlia."},{"statement":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s1) ->\nPlt pc (st_nextnode s1) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s1) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0) (H5 : ~ In pc1 (map fst l)) (H6 : list_norepet (map fst l)) : (st_code s0) ! pc = (st_code s) ! pc.","conclusion":"(st_code s0) ! pc = (st_code s) ! pc","hypotheses":"(ctx : context) (pc : positive) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nPle (dpc ctx) (st_nextnode s1) ->\nPlt pc (st_nextnode s1) ->\n~ In pc (map (spc ctx) (map fst l)) ->\nlist_norepet (map fst l) -> (st_code s'0) ! pc = (st_code s1) ! pc) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (st_nextnode s)) (H2 : ~ (spc ctx pc1 = pc \\/ In pc (map (spc ctx) (map fst l)))) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0) (H5 : ~ In pc1 (map fst l)) (H6 : list_norepet (map fst l))","proofString":"eapply expand_instr_unchanged; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H : expand_cfg_rec fe rec ctx f s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H : expand_cfg_rec fe rec ctx f s = R x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx))","proofString":"unfold expand_cfg_rec in H.\nmonadInv H.\ninversion EQ.\ntransitivity ((st_code s0)!pc).\nexploit ptree_mfold_spec; eauto.\nintros [INCR' ITER].\neapply iter_expand_instr_unchanged; eauto.\nsubst s0; auto.\nsubst s0; simpl.\nextlia.\nred; intros.\nexploit list_in_map_inv; eauto.\nintros [pc1 [A B]].\nsubst pc.\nunfold spc in H1.\neapply shiftpos_not_below; eauto.\napply PTree.elements_keys_norepet.\nsubst s0; auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H : (do _ <- request_stack (dstk ctx + mstk ctx);\n ptree_mfold (expand_instr fe rec ctx) (fn_code f)) s = \nR x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H : (do _ <- request_stack (dstk ctx + mstk ctx);\n ptree_mfold (expand_instr fe rec ctx) (fn_code f)) s = \nR x s' i) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx))","proofString":"monadInv H.\ninversion EQ.\ntransitivity ((st_code s0)!pc).\nexploit ptree_mfold_spec; eauto.\nintros [INCR' ITER].\neapply iter_expand_instr_unchanged; eauto.\nsubst s0; auto.\nsubst s0; simpl.\nextlia.\nred; intros.\nexploit list_in_map_inv; eauto.\nintros [pc1 [A B]].\nsubst pc.\nunfold spc in H1.\neapply shiftpos_not_below; eauto.\napply PTree.elements_keys_norepet.\nsubst s0; auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0)","proofString":"inversion EQ.\ntransitivity ((st_code s0)!pc).\nexploit ptree_mfold_spec; eauto.\nintros [INCR' ITER].\neapply iter_expand_instr_unchanged; eauto.\nsubst s0; auto.\nsubst s0; simpl.\nextlia.\nred; intros.\nexploit list_in_map_inv; eauto.\nintros [pc1 [A B]].\nsubst pc.\nunfold spc in H1.\neapply shiftpos_not_below; eauto.\napply PTree.elements_keys_norepet.\nsubst s0; auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0)","proofString":"transitivity ((st_code s0)!pc).\nexploit ptree_mfold_spec; eauto.\nintros [INCR' ITER].\neapply iter_expand_instr_unchanged; eauto.\nsubst s0; auto.\nsubst s0; simpl.\nextlia.\nred; intros.\nexploit list_in_map_inv; eauto.\nintros [pc1 [A B]].\nsubst pc.\nunfold spc in H1.\neapply shiftpos_not_below; eauto.\napply PTree.elements_keys_norepet.\nsubst s0; auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) : (st_code s') ! pc = (st_code s0) ! pc.","conclusion":"(st_code s') ! pc = (st_code s0) ! pc","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0)","proofString":"exploit ptree_mfold_spec; eauto.\nintros [INCR' ITER].\neapply iter_expand_instr_unchanged; eauto.\nsubst s0; auto.\nsubst s0; simpl.\nextlia.\nred; intros.\nexploit list_in_map_inv; eauto.\nintros [pc1 [A B]].\nsubst pc.\nunfold spc in H1.\neapply shiftpos_not_below; eauto.\napply PTree.elements_keys_norepet."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) : (exists i' : sincr s0 s',\n   mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\n   R tt s' i') -> (st_code s') ! pc = (st_code s0) ! pc.","conclusion":"(exists i' : sincr s0 s',\n   mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\n   R tt s' i') -> (st_code s') ! pc = (st_code s0) ! pc","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0)","proofString":"intros [INCR' ITER].\neapply iter_expand_instr_unchanged; eauto.\nsubst s0; auto.\nsubst s0; simpl.\nextlia.\nred; intros.\nexploit list_in_map_inv; eauto.\nintros [pc1 [A B]].\nsubst pc.\nunfold spc in H1.\neapply shiftpos_not_below; eauto.\napply PTree.elements_keys_norepet."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') : (st_code s') ! pc = (st_code s0) ! pc.","conclusion":"(st_code s') ! pc = (st_code s0) ! pc","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR')","proofString":"eapply iter_expand_instr_unchanged; eauto.\nsubst s0; auto.\nsubst s0; simpl.\nextlia.\nred; intros.\nexploit list_in_map_inv; eauto.\nintros [pc1 [A B]].\nsubst pc.\nunfold spc in H1.\neapply shiftpos_not_below; eauto.\napply PTree.elements_keys_norepet."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') : Ple (dpc ctx) (st_nextnode s0).","conclusion":"Ple (dpc ctx) (st_nextnode s0)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR')","proofString":"subst s0; auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') : Plt pc (st_nextnode s0).","conclusion":"Plt pc (st_nextnode s0)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR')","proofString":"subst s0; simpl.\nextlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := st_code s;\n    st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n  |} s') (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := st_code s;\n    st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n  |} = R x s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := st_code s;\n    st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n  |}) (EQ : request_stack (dstk ctx + mstk ctx) s =\nR x0\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := st_code s;\n    st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n  |} INCR) (H2 : tt = x0) (INCR' : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := st_code s;\n    st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n  |} s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f))\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := st_code s;\n    st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n  |} = R tt s' INCR') : Plt pc (st_nextnode s).","conclusion":"Plt pc (st_nextnode s)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (INCR0 : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := st_code s;\n    st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n  |} s') (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := st_code s;\n    st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n  |} = R x s' INCR0) (INCR : sincr s\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := st_code s;\n    st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n  |}) (EQ : request_stack (dstk ctx + mstk ctx) s =\nR x0\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := st_code s;\n    st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n  |} INCR) (H2 : tt = x0) (INCR' : sincr\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := st_code s;\n    st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n  |} s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f))\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s;\n    st_code := st_code s;\n    st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n  |} = R tt s' INCR')","proofString":"extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') : ~ In pc (map (spc ctx) (map fst (PTree.elements (fn_code f)))).","conclusion":"~ In pc (map (spc ctx) (map fst (PTree.elements (fn_code f))))","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR')","proofString":"red; intros.\nexploit list_in_map_inv; eauto.\nintros [pc1 [A B]].\nsubst pc.\nunfold spc in H1.\neapply shiftpos_not_below; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (H : In pc (map (spc ctx) (map fst (PTree.elements (fn_code f))))) : False.","conclusion":"False","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (H : In pc (map (spc ctx) (map fst (PTree.elements (fn_code f)))))","proofString":"exploit list_in_map_inv; eauto.\nintros [pc1 [A B]].\nsubst pc.\nunfold spc in H1.\neapply shiftpos_not_below; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (H : In pc (map (spc ctx) (map fst (PTree.elements (fn_code f))))) : (exists x1 : node,\n   pc = spc ctx x1 /\\ In x1 (map fst (PTree.elements (fn_code f)))) -> False.","conclusion":"(exists x1 : node,\n   pc = spc ctx x1 /\\ In x1 (map fst (PTree.elements (fn_code f)))) -> False","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (H : In pc (map (spc ctx) (map fst (PTree.elements (fn_code f)))))","proofString":"intros [pc1 [A B]].\nsubst pc.\nunfold spc in H1.\neapply shiftpos_not_below; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (H : In pc (map (spc ctx) (map fst (PTree.elements (fn_code f))))) (pc1 : node) (A : pc = spc ctx pc1) (B : In pc1 (map fst (PTree.elements (fn_code f)))) : False.","conclusion":"False","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (H : In pc (map (spc ctx) (map fst (PTree.elements (fn_code f))))) (pc1 : node) (A : pc = spc ctx pc1) (B : In pc1 (map fst (PTree.elements (fn_code f))))","proofString":"subst pc.\nunfold spc in H1.\neapply shiftpos_not_below; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (pc1 : node) (H1 : Plt (spc ctx pc1) (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (H : In (spc ctx pc1) (map (spc ctx) (map fst (PTree.elements (fn_code f))))) (B : In pc1 (map fst (PTree.elements (fn_code f)))) : False.","conclusion":"False","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (pc1 : node) (H1 : Plt (spc ctx pc1) (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (H : In (spc ctx pc1) (map (spc ctx) (map fst (PTree.elements (fn_code f))))) (B : In pc1 (map fst (PTree.elements (fn_code f))))","proofString":"unfold spc in H1.\neapply shiftpos_not_below; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (pc1 : node) (H1 : Plt (shiftpos pc1 (dpc ctx)) (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (H : In (spc ctx pc1) (map (spc ctx) (map fst (PTree.elements (fn_code f))))) (B : In pc1 (map fst (PTree.elements (fn_code f)))) : False.","conclusion":"False","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (H0 : Ple (dpc ctx) (st_nextnode s)) (pc1 : node) (H1 : Plt (shiftpos pc1 (dpc ctx)) (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (H : In (spc ctx pc1) (map (spc ctx) (map fst (PTree.elements (fn_code f))))) (B : In pc1 (map fst (PTree.elements (fn_code f))))","proofString":"eapply shiftpos_not_below; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') : list_norepet (map fst (PTree.elements (fn_code f))).","conclusion":"list_norepet (map fst (PTree.elements (fn_code f)))","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR')","proofString":"apply PTree.elements_keys_norepet."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) : (st_code s0) ! pc = (st_code s) ! pc.","conclusion":"(st_code s0) ! pc = (st_code s) ! pc","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Ple (dpc ctx) (st_nextnode s)) (H1 : Plt pc (dpc ctx)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H2 : tt = x0) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0)","proofString":"subst s0; auto."},{"statement":"(sz : Z) : (if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8) >\n0.","conclusion":"(if zle sz 1 then 1 else if zle sz 2 then 2 else if zle sz 4 then 4 else 8) >\n0","hypotheses":"(sz : Z)","proofString":"destruct (zle sz 1).\nlia.\ndestruct (zle sz 2).\nlia.\ndestruct (zle sz 4); lia."},{"statement":"(sz : Z) (l : sz <= 1) : 1 > 0.","conclusion":"1 > 0","hypotheses":"(sz : Z) (l : sz <= 1)","proofString":"lia."},{"statement":"(sz : Z) (g : sz > 1) : (if zle sz 2 then 2 else if zle sz 4 then 4 else 8) > 0.","conclusion":"(if zle sz 2 then 2 else if zle sz 4 then 4 else 8) > 0","hypotheses":"(sz : Z) (g : sz > 1)","proofString":"destruct (zle sz 2).\nlia.\ndestruct (zle sz 4); lia."},{"statement":"(sz : Z) (g : sz > 1) (l : sz <= 2) : 2 > 0.","conclusion":"2 > 0","hypotheses":"(sz : Z) (g : sz > 1) (l : sz <= 2)","proofString":"lia."},{"statement":"(sz : Z) (g : sz > 1) (g0 : sz > 2) : (if zle sz 4 then 4 else 8) > 0.","conclusion":"(if zle sz 4 then 4 else 8) > 0","hypotheses":"(sz : Z) (g : sz > 1) (g0 : sz > 2)","proofString":"destruct (zle sz 4); lia."},{"statement":"(ctx : context) (pc : node) (instr : instruction) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : expand_instr fe rec ctx pc instr s = R x s' i) (DEFS : forall r : reg, instr_defs instr = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) : tr_instr ctx pc instr c.","conclusion":"tr_instr ctx pc instr c","hypotheses":"(ctx : context) (pc : node) (instr : instruction) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : expand_instr fe rec ctx pc instr s = R x s' i) (DEFS : forall r : reg, instr_defs instr = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc))","proofString":"generalize set_instr_same; intros BASE.\nunfold expand_instr in EXP; destruct instr; simpl in DEFS;  try (econstructor; eauto; fail).\ndestruct (can_inline fe s1) as [|id f P Q].\neapply tr_call; eauto.\nsubst s1.\nmonadInv EXP.\nunfold inline_function in EQ; monadInv EQ.\nset (ctx' := callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r).\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_call_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s2; simpl in *; extlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx + mstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code)!pc0).\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *.\nextlia.\nred; simpl.\nsplit.\nauto.\napply align_le.\napply min_alignment_pos.\ndestruct (can_inline fe s1) as [|id f P Q].\ndestruct (retinfo ctx) as [[rpc rreg] | ] eqn:?.\neapply tr_tailcall_call; eauto.\neapply tr_tailcall; eauto.\nsubst s1.\nmonadInv EXP.\nunfold inline_function in EQ; monadInv EQ.\nset (ctx' := tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) in *.\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_tailcall_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s3; simpl in *.\nsubst s2; simpl in *.\nextlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code))!pc0.\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *; extlia.\nred; auto.\neapply tr_builtin; eauto.\ndestruct b; eauto.\ndestruct (retinfo ctx) as [[rpc rreg] | ] eqn:?.\neapply tr_return_inlined; eauto.\neapply tr_return; eauto."},{"statement":"(ctx : context) (pc : node) (instr : instruction) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : expand_instr fe rec ctx pc instr s = R x s' i) (DEFS : forall r : reg, instr_defs instr = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr0 : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr0 s0 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr0) : tr_instr ctx pc instr c.","conclusion":"tr_instr ctx pc instr c","hypotheses":"(ctx : context) (pc : node) (instr : instruction) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : expand_instr fe rec ctx pc instr s = R x s' i) (DEFS : forall r : reg, instr_defs instr = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr0 : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr0 s0 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr0)","proofString":"unfold expand_instr in EXP; destruct instr; simpl in DEFS;  try (econstructor; eauto; fail).\ndestruct (can_inline fe s1) as [|id f P Q].\neapply tr_call; eauto.\nsubst s1.\nmonadInv EXP.\nunfold inline_function in EQ; monadInv EQ.\nset (ctx' := callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r).\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_call_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s2; simpl in *; extlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx + mstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code)!pc0).\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *.\nextlia.\nred; simpl.\nsplit.\nauto.\napply align_le.\napply min_alignment_pos.\ndestruct (can_inline fe s1) as [|id f P Q].\ndestruct (retinfo ctx) as [[rpc rreg] | ] eqn:?.\neapply tr_tailcall_call; eauto.\neapply tr_tailcall; eauto.\nsubst s1.\nmonadInv EXP.\nunfold inline_function in EQ; monadInv EQ.\nset (ctx' := tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) in *.\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_tailcall_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s3; simpl in *.\nsubst s2; simpl in *.\nextlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code))!pc0.\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *; extlia.\nred; auto.\neapply tr_builtin; eauto.\ndestruct b; eauto.\ndestruct (retinfo ctx) as [[rpc rreg] | ] eqn:?.\neapply tr_return_inlined; eauto.\neapply tr_return; eauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : match can_inline fe s1 with\n| Cannot_inline _ _ =>\n    set_instr (spc ctx pc)\n      (Icall s0 (sros ctx s1) (sregs ctx l) (sreg ctx r) (spc ctx n))\n| Can_inline _ _ id f _ Q =>\n    do n0 <- inline_function fe rec ctx id f Q l n r;\n    set_instr (spc ctx pc) (Inop n0)\nend s = R x s' i) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Icall s0 s1 l r n) c.","conclusion":"tr_instr ctx pc (Icall s0 s1 l r n) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : match can_inline fe s1 with\n| Cannot_inline _ _ =>\n    set_instr (spc ctx pc)\n      (Icall s0 (sros ctx s1) (sregs ctx l) (sreg ctx r) (spc ctx n))\n| Can_inline _ _ id f _ Q =>\n    do n0 <- inline_function fe rec ctx id f Q l n r;\n    set_instr (spc ctx pc) (Inop n0)\nend s = R x s' i) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"destruct (can_inline fe s1) as [|id f P Q].\neapply tr_call; eauto.\nsubst s1.\nmonadInv EXP.\nunfold inline_function in EQ; monadInv EQ.\nset (ctx' := callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r).\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_call_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s2; simpl in *; extlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx + mstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code)!pc0).\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *.\nextlia.\nred; simpl.\nsplit.\nauto.\napply align_le.\napply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : set_instr (spc ctx pc)\n  (Icall s0 (sros ctx s1) (sregs ctx l) (sreg ctx r) (spc ctx n)) s =\nR x s' i) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Icall s0 s1 l r n) c.","conclusion":"tr_instr ctx pc (Icall s0 s1 l r n) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : set_instr (spc ctx pc)\n  (Icall s0 (sros ctx s1) (sregs ctx l) (sreg ctx r) (spc ctx n)) s =\nR x s' i) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"eapply tr_call; eauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (EXP : (do n0 <- inline_function fe rec ctx id f Q l n r;\n set_instr (spc ctx pc) (Inop n0)) s = R x s' i) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Icall s0 s1 l r n) c.","conclusion":"tr_instr ctx pc (Icall s0 s1 l r n) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (EXP : (do n0 <- inline_function fe rec ctx id f Q l n r;\n set_instr (spc ctx pc) (Inop n0)) s = R x s' i) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"subst s1.\nmonadInv EXP.\nunfold inline_function in EQ; monadInv EQ.\nset (ctx' := callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r).\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_call_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s2; simpl in *; extlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx + mstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code)!pc0).\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *.\nextlia.\nred; simpl.\nsplit.\nauto.\napply align_le.\napply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (EXP : (do n0 <- inline_function fe rec ctx id f Q l n r;\n set_instr (spc ctx pc) (Inop n0)) s = R x s' i) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s1 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s1 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Icall s0 (inr id) l r n) c.","conclusion":"tr_instr ctx pc (Icall s0 (inr id) l r n) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (EXP : (do n0 <- inline_function fe rec ctx id f Q l n r;\n set_instr (spc ctx pc) (Inop n0)) s = R x s' i) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s1 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s1 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"monadInv EXP.\nunfold inline_function in EQ; monadInv EQ.\nset (ctx' := callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r).\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_call_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s2; simpl in *; extlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx + mstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code)!pc0).\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *.\nextlia.\nred; simpl.\nsplit.\nauto.\napply align_le.\napply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x1 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (INCR : sincr s s1) (INCR0 : sincr s1 s') (EQ : inline_function fe rec ctx id f Q l n r s = R x0 s1 INCR) (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 = R x s' INCR0) : tr_instr ctx pc (Icall s0 (inr id) l r n) c.","conclusion":"tr_instr ctx pc (Icall s0 (inr id) l r n) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x1 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (INCR : sincr s s1) (INCR0 : sincr s1 s') (EQ : inline_function fe rec ctx id f Q l n r s = R x0 s1 INCR) (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 = R x s' INCR0)","proofString":"unfold inline_function in EQ; monadInv EQ.\nset (ctx' := callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r).\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_call_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s2; simpl in *; extlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx + mstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code)!pc0).\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *.\nextlia.\nred; simpl.\nsplit.\nauto.\napply align_le.\napply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (INCR : sincr s s1) (INCR0 : sincr s1 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 = R x s' INCR0) (x1 : positive) (s2 : state) (INCR1 : sincr s s2) (INCR2 : sincr s2 s1) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s2 INCR1) (x2 : positive) (s3 : state) (INCR3 : sincr s2 s3) (INCR4 : sincr s3 s1) (EQ : reserve_regs (max_reg_function f) s2 = R x2 s3 INCR3) (x3 : unit) (s4 : state) (INCR5 : sincr s3 s4) (INCR6 : sincr s4 s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 INCR6) : tr_instr ctx pc (Icall s0 (inr id) l r n) c.","conclusion":"tr_instr ctx pc (Icall s0 (inr id) l r n) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (INCR : sincr s s1) (INCR0 : sincr s1 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 = R x s' INCR0) (x1 : positive) (s2 : state) (INCR1 : sincr s s2) (INCR2 : sincr s2 s1) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s2 INCR1) (x2 : positive) (s3 : state) (INCR3 : sincr s2 s3) (INCR4 : sincr s3 s1) (EQ : reserve_regs (max_reg_function f) s2 = R x2 s3 INCR3) (x3 : unit) (s4 : state) (INCR5 : sincr s3 s4) (INCR6 : sincr s4 s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 INCR6)","proofString":"set (ctx' := callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r).\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_call_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s2; simpl in *; extlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx + mstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code)!pc0).\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *.\nextlia.\nred; simpl.\nsplit.\nauto.\napply align_le.\napply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : c ! (spc ctx pc) = Some (Inop x0).","conclusion":"c ! (spc ctx pc) = Some (Inop x0)","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"eapply BASE; eauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : forall pc0 : positive,\nPle (st_nextnode s4) pc0 ->\nPlt pc0 (st_nextnode s1) -> c ! pc0 = (st_code s1) ! pc0.","conclusion":"forall pc0 : positive,\nPle (st_nextnode s4) pc0 ->\nPlt pc0 (st_nextnode s1) -> c ! pc0 = (st_code s1) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"intros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1)) : c ! pc0 = (st_code s1) ! pc0.","conclusion":"c ! pc0 = (st_code s1) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1))","proofString":"rewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1)) : (st_code s') ! pc0 = (st_code s1) ! pc0.","conclusion":"(st_code s') ! pc0 = (st_code s1) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1))","proofString":"eapply set_instr_other; eauto.\nunfold node; extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1)) : pc0 <> spc ctx pc.","conclusion":"pc0 <> spc ctx pc","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1))","proofString":"unfold node; extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1)) : Ple (st_nextnode s) pc0.","conclusion":"Ple (st_nextnode s) pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1))","proofString":"extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1)) : Plt pc0 (st_nextnode s').","conclusion":"Plt pc0 (st_nextnode s')","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1))","proofString":"extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : fenv_agree (PTree.remove id fe).","conclusion":"fenv_agree (PTree.remove id fe)","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"red; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (id0 : positive) (f0 : function) (H : (PTree.remove id fe) ! id0 = Some f0) : fenv ! id0 = Some f0.","conclusion":"fenv ! id0 = Some f0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (id0 : positive) (f0 : function) (H : (PTree.remove id fe) ! id0 = Some f0)","proofString":"rewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (id0 : positive) (f0 : function) (H : (if PTree.elt_eq id0 id then None else fe ! id0) = Some f0) : fenv ! id0 = Some f0.","conclusion":"fenv ! id0 = Some f0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (id0 : positive) (f0 : function) (H : (if PTree.elt_eq id0 id then None else fe ! id0) = Some f0)","proofString":"destruct (PTree.elt_eq id0 id); try discriminate.\nauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (id0 : positive) (f0 : function) (n0 : id0 <> id) (H : fe ! id0 = Some f0) : fenv ! id0 = Some f0.","conclusion":"fenv ! id0 = Some f0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (id0 : positive) (f0 : function) (n0 : id0 <> id) (H : fe ! id0 = Some f0)","proofString":"auto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : Ple (x1 + max_pc_function f) (st_nextnode s3).","conclusion":"Ple (x1 + max_pc_function f) (st_nextnode s3)","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"subst s2; simpl in *; extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : Ple (x2 + max_reg_function f) (st_nextreg s3).","conclusion":"Ple (x2 + max_reg_function f) (st_nextreg s3)","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"subst s3; simpl in *; extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : Z.max (fn_stacksize f) 0 >= 0.","conclusion":"Z.max (fn_stacksize f) 0 >= 0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : (min_alignment (fn_stacksize f)\n| align (dstk ctx + mstk ctx) (min_alignment (fn_stacksize f))).","conclusion":"(min_alignment (fn_stacksize f)\n| align (dstk ctx + mstk ctx) (min_alignment (fn_stacksize f)))","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"apply align_divides.\napply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : min_alignment (fn_stacksize f) > 0.","conclusion":"min_alignment (fn_stacksize f) > 0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"apply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : dstk ctx + mstk ctx <=\nalign (dstk ctx + mstk ctx) (min_alignment (fn_stacksize f)).","conclusion":"dstk ctx + mstk ctx <=\nalign (dstk ctx + mstk ctx) (min_alignment (fn_stacksize f))","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"apply align_le.\napply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : min_alignment (fn_stacksize f) > 0.","conclusion":"min_alignment (fn_stacksize f) > 0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"apply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (H : dstk ctx + mstk ctx <= dstk ctx') : dstk ctx' >= 0.","conclusion":"dstk ctx' >= 0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (H : dstk ctx + mstk ctx <= dstk ctx')","proofString":"lia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : st_stksize s4 <= stacksize.","conclusion":"st_stksize s4 <= stacksize","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"lia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : c ! pc0 = (st_code s4) ! pc0.","conclusion":"c ! pc0 = (st_code s4) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"rewrite S1.\ntransitivity (s1.(st_code)!pc0).\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : (st_code s') ! pc0 = (st_code s4) ! pc0.","conclusion":"(st_code s') ! pc0 = (st_code s4) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"transitivity (s1.(st_code)!pc0).\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : (st_code s') ! pc0 = (st_code s1) ! pc0.","conclusion":"(st_code s') ! pc0 = (st_code s1) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"eapply set_instr_other; eauto.\nunfold node in *; extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : pc0 <> spc ctx pc.","conclusion":"pc0 <> spc ctx pc","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"unfold node in *; extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : (st_code s1) ! pc0 = (st_code s4) ! pc0.","conclusion":"(st_code s1) ! pc0 = (st_code s4) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"eapply add_moves_unchanged; eauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : Ple (st_nextnode s) pc0.","conclusion":"Ple (st_nextnode s) pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"unfold node in *; extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : Plt pc0 (st_nextnode s').","conclusion":"Plt pc0 (st_nextnode s')","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : Ple (dreg ctx + mreg ctx) x2.","conclusion":"Ple (dreg ctx + mreg ctx) x2","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"subst s2; simpl in *.\nextlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (STKSIZE4 : st_stksize s <= st_stksize s) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s + max_pc_function f)) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s)) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  (Sincr s\n     {|\n       st_nextreg := st_nextreg s;\n       st_nextnode := st_nextnode s + max_pc_function f;\n       st_code := st_code s;\n       st_stksize := st_stksize s\n     |} NEXTREG4 NEXTNODE4 STKSIZE4)) (STKSIZE3 : st_stksize s <= st_stksize s1) (NEXTNODE3 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s1)) (NEXTREG3 : Ple (st_nextreg s) (st_nextreg s1)) (x2 : positive) (s3 : state) (STKSIZE2 : st_stksize s <= st_stksize s3) (NEXTNODE2 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s3)) (NEXTREG2 : Ple (st_nextreg s) (st_nextreg s3)) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} =\nR x2 s3\n  (Sincr\n     {|\n       st_nextreg := st_nextreg s;\n       st_nextnode := st_nextnode s + max_pc_function f;\n       st_code := st_code s;\n       st_stksize := st_stksize s\n     |} s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H5 : {|\n  st_nextreg := st_nextreg s + max_reg_function f;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s3) (H4 : st_nextreg s = x2) : Ple (dreg ctx + mreg ctx) x2.","conclusion":"Ple (dreg ctx + mreg ctx) x2","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (STKSIZE4 : st_stksize s <= st_stksize s) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s + max_pc_function f)) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s)) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  (Sincr s\n     {|\n       st_nextreg := st_nextreg s;\n       st_nextnode := st_nextnode s + max_pc_function f;\n       st_code := st_code s;\n       st_stksize := st_stksize s\n     |} NEXTREG4 NEXTNODE4 STKSIZE4)) (STKSIZE3 : st_stksize s <= st_stksize s1) (NEXTNODE3 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s1)) (NEXTREG3 : Ple (st_nextreg s) (st_nextreg s1)) (x2 : positive) (s3 : state) (STKSIZE2 : st_stksize s <= st_stksize s3) (NEXTNODE2 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s3)) (NEXTREG2 : Ple (st_nextreg s) (st_nextreg s3)) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} =\nR x2 s3\n  (Sincr\n     {|\n       st_nextreg := st_nextreg s;\n       st_nextnode := st_nextnode s + max_pc_function f;\n       st_code := st_code s;\n       st_stksize := st_stksize s\n     |} s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H5 : {|\n  st_nextreg := st_nextreg s + max_reg_function f;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s3) (H4 : st_nextreg s = x2)","proofString":"extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : mstk ctx >= 0 /\\\ndstk ctx + mstk ctx <=\nalign (dstk ctx + mstk ctx) (min_alignment (fn_stacksize f)).","conclusion":"mstk ctx >= 0 /\\\ndstk ctx + mstk ctx <=\nalign (dstk ctx + mstk ctx) (min_alignment (fn_stacksize f))","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"split.\nauto.\napply align_le.\napply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : mstk ctx >= 0.","conclusion":"mstk ctx >= 0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"auto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : dstk ctx + mstk ctx <=\nalign (dstk ctx + mstk ctx) (min_alignment (fn_stacksize f)).","conclusion":"dstk ctx + mstk ctx <=\nalign (dstk ctx + mstk ctx) (min_alignment (fn_stacksize f))","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"apply align_le.\napply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : min_alignment (fn_stacksize f) > 0.","conclusion":"min_alignment (fn_stacksize f) > 0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (r : reg) (n : node) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r0 : reg, Some r = Some r0 -> Ple r0 (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r) f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l)\n  (sregs (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_params f))\n  (spc (callcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f) n r)\n     (fn_entrypoint f)) s4 = R x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (ctx' : context) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"apply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : match can_inline fe s1 with\n| Cannot_inline _ _ =>\n    match retinfo ctx with\n    | Some (rpc, rreg) =>\n        set_instr (spc ctx pc)\n          (Icall s0 (sros ctx s1) (sregs ctx l) rreg rpc)\n    | None =>\n        set_instr (spc ctx pc) (Itailcall s0 (sros ctx s1) (sregs ctx l))\n    end\n| Can_inline _ _ id f _ Q =>\n    do n <- inline_tail_function fe rec ctx id f Q l;\n    set_instr (spc ctx pc) (Inop n)\nend s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Itailcall s0 s1 l) c.","conclusion":"tr_instr ctx pc (Itailcall s0 s1 l) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : match can_inline fe s1 with\n| Cannot_inline _ _ =>\n    match retinfo ctx with\n    | Some (rpc, rreg) =>\n        set_instr (spc ctx pc)\n          (Icall s0 (sros ctx s1) (sregs ctx l) rreg rpc)\n    | None =>\n        set_instr (spc ctx pc) (Itailcall s0 (sros ctx s1) (sregs ctx l))\n    end\n| Can_inline _ _ id f _ Q =>\n    do n <- inline_tail_function fe rec ctx id f Q l;\n    set_instr (spc ctx pc) (Inop n)\nend s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"destruct (can_inline fe s1) as [|id f P Q].\ndestruct (retinfo ctx) as [[rpc rreg] | ] eqn:?.\neapply tr_tailcall_call; eauto.\neapply tr_tailcall; eauto.\nsubst s1.\nmonadInv EXP.\nunfold inline_function in EQ; monadInv EQ.\nset (ctx' := tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) in *.\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_tailcall_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s3; simpl in *.\nsubst s2; simpl in *.\nextlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code))!pc0.\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *; extlia.\nred; auto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : match retinfo ctx with\n| Some (rpc, rreg) =>\n    set_instr (spc ctx pc) (Icall s0 (sros ctx s1) (sregs ctx l) rreg rpc)\n| None => set_instr (spc ctx pc) (Itailcall s0 (sros ctx s1) (sregs ctx l))\nend s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Itailcall s0 s1 l) c.","conclusion":"tr_instr ctx pc (Itailcall s0 s1 l) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : match retinfo ctx with\n| Some (rpc, rreg) =>\n    set_instr (spc ctx pc) (Icall s0 (sros ctx s1) (sregs ctx l) rreg rpc)\n| None => set_instr (spc ctx pc) (Itailcall s0 (sros ctx s1) (sregs ctx l))\nend s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"destruct (retinfo ctx) as [[rpc rreg] | ] eqn:?.\neapply tr_tailcall_call; eauto.\neapply tr_tailcall; eauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (rpc : node) (rreg : reg) (Heqo : retinfo ctx = Some (rpc, rreg)) (EXP : set_instr (spc ctx pc) (Icall s0 (sros ctx s1) (sregs ctx l) rreg rpc) s =\nR x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Itailcall s0 s1 l) c.","conclusion":"tr_instr ctx pc (Itailcall s0 s1 l) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (rpc : node) (rreg : reg) (Heqo : retinfo ctx = Some (rpc, rreg)) (EXP : set_instr (spc ctx pc) (Icall s0 (sros ctx s1) (sregs ctx l) rreg rpc) s =\nR x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"eapply tr_tailcall_call; eauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (Heqo : retinfo ctx = None) (EXP : set_instr (spc ctx pc) (Itailcall s0 (sros ctx s1) (sregs ctx l)) s =\nR x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Itailcall s0 s1 l) c.","conclusion":"tr_instr ctx pc (Itailcall s0 s1 l) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (Heqo : retinfo ctx = None) (EXP : set_instr (spc ctx pc) (Itailcall s0 (sros ctx s1) (sregs ctx l)) s =\nR x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"eapply tr_tailcall; eauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (EXP : (do n <- inline_tail_function fe rec ctx id f Q l;\n set_instr (spc ctx pc) (Inop n)) s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Itailcall s0 s1 l) c.","conclusion":"tr_instr ctx pc (Itailcall s0 s1 l) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (s1 : reg + ident) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (P : s1 = inr id) (Q : fe ! id = Some f) (EXP : (do n <- inline_tail_function fe rec ctx id f Q l;\n set_instr (spc ctx pc) (Inop n)) s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"subst s1.\nmonadInv EXP.\nunfold inline_function in EQ; monadInv EQ.\nset (ctx' := tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) in *.\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_tailcall_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s3; simpl in *.\nsubst s2; simpl in *.\nextlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code))!pc0.\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *; extlia.\nred; auto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (EXP : (do n <- inline_tail_function fe rec ctx id f Q l;\n set_instr (spc ctx pc) (Inop n)) s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s1 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s1 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Itailcall s0 (inr id) l) c.","conclusion":"tr_instr ctx pc (Itailcall s0 (inr id) l) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (EXP : (do n <- inline_tail_function fe rec ctx id f Q l;\n set_instr (spc ctx pc) (Inop n)) s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s1 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s1 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s1 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"monadInv EXP.\nunfold inline_function in EQ; monadInv EQ.\nset (ctx' := tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) in *.\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_tailcall_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s3; simpl in *.\nsubst s2; simpl in *.\nextlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code))!pc0.\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *; extlia.\nred; auto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x1 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (INCR : sincr s s1) (INCR0 : sincr s1 s') (EQ : inline_tail_function fe rec ctx id f Q l s = R x0 s1 INCR) (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 = R x s' INCR0) : tr_instr ctx pc (Itailcall s0 (inr id) l) c.","conclusion":"tr_instr ctx pc (Itailcall s0 (inr id) l) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x1 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (INCR : sincr s s1) (INCR0 : sincr s1 s') (EQ : inline_tail_function fe rec ctx id f Q l s = R x0 s1 INCR) (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 = R x s' INCR0)","proofString":"unfold inline_function in EQ; monadInv EQ.\nset (ctx' := tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) in *.\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_tailcall_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s3; simpl in *.\nsubst s2; simpl in *.\nextlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code))!pc0.\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *; extlia.\nred; auto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (INCR : sincr s s1) (INCR0 : sincr s1 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 = R x s' INCR0) (x1 : positive) (s2 : state) (INCR1 : sincr s s2) (INCR2 : sincr s2 s1) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s2 INCR1) (x2 : positive) (s3 : state) (INCR3 : sincr s2 s3) (INCR4 : sincr s3 s1) (EQ : reserve_regs (max_reg_function f) s2 = R x2 s3 INCR3) (x3 : unit) (s4 : state) (INCR5 : sincr s3 s4) (INCR6 : sincr s4 s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s3 =\nR x3 s4 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s4 = R x0 s1 INCR6) : tr_instr ctx pc (Itailcall s0 (inr id) l) c.","conclusion":"tr_instr ctx pc (Itailcall s0 (inr id) l) c","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i0 : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (INCR : sincr s s1) (INCR0 : sincr s1 s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 = R x s' INCR0) (x1 : positive) (s2 : state) (INCR1 : sincr s s2) (INCR2 : sincr s2 s1) (EQ1 : reserve_nodes (max_pc_function f) s = R x1 s2 INCR1) (x2 : positive) (s3 : state) (INCR3 : sincr s2 s3) (INCR4 : sincr s3 s1) (EQ : reserve_regs (max_reg_function f) s2 = R x2 s3 INCR3) (x3 : unit) (s4 : state) (INCR5 : sincr s3 s4) (INCR6 : sincr s4 s1) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q)\n  (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) f s3 =\nR x3 s4 INCR5) (EQ4 : add_moves (sregs ctx l)\n  (sregs (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_params f))\n  (spc (tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f))\n     (fn_entrypoint f)) s4 = R x0 s1 INCR6)","proofString":"set (ctx' := tailcontext ctx x1 x2 (max_reg_function f) (fn_stacksize f)) in *.\ninversion EQ0; inversion EQ1; inversion EQ.\ninv_incr.\napply tr_tailcall_inlined with (pc1 := x0) (ctx' := ctx') (f := f); auto.\neapply BASE; eauto.\neapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia.\neapply rec_spec; eauto.\nred; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto.\nsimpl.\nsubst s3; simpl in *.\nsubst s2; simpl in *.\nextlia.\nsimpl.\nsubst s3; simpl in *; extlia.\nsimpl.\nextlia.\nsimpl.\napply align_divides.\napply min_alignment_pos.\nassert (dstk ctx <= dstk ctx').\nsimpl.\napply align_le.\napply min_alignment_pos.\nlia.\nlia.\nintros.\nsimpl in H.\nrewrite S1.\ntransitivity (s1.(st_code))!pc0.\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia.\nred; simpl.\nsubst s2; simpl in *; extlia.\nred; auto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : c ! (spc ctx pc) = Some (Inop x0).","conclusion":"c ! (spc ctx pc) = Some (Inop x0)","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"eapply BASE; eauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : tr_moves c x0 (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)).","conclusion":"tr_moves c x0 (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f))","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"eapply add_moves_spec; eauto.\nintros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : forall pc0 : positive,\nPle (st_nextnode s4) pc0 ->\nPlt pc0 (st_nextnode s1) -> c ! pc0 = (st_code s1) ! pc0.","conclusion":"forall pc0 : positive,\nPle (st_nextnode s4) pc0 ->\nPlt pc0 (st_nextnode s1) -> c ! pc0 = (st_code s1) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"intros.\nrewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1)) : c ! pc0 = (st_code s1) ! pc0.","conclusion":"c ! pc0 = (st_code s1) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1))","proofString":"rewrite S1.\neapply set_instr_other; eauto.\nunfold node; extlia.\nextlia.\nextlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1)) : (st_code s') ! pc0 = (st_code s1) ! pc0.","conclusion":"(st_code s') ! pc0 = (st_code s1) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1))","proofString":"eapply set_instr_other; eauto.\nunfold node; extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1)) : pc0 <> spc ctx pc.","conclusion":"pc0 <> spc ctx pc","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1))","proofString":"unfold node; extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1)) : Ple (st_nextnode s) pc0.","conclusion":"Ple (st_nextnode s) pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1))","proofString":"extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1)) : Plt pc0 (st_nextnode s').","conclusion":"Plt pc0 (st_nextnode s')","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple (st_nextnode s4) pc0) (H6 : Plt pc0 (st_nextnode s1))","proofString":"extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : fenv_agree (PTree.remove id fe).","conclusion":"fenv_agree (PTree.remove id fe)","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"red; intros.\nrewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (id0 : positive) (f0 : function) (H : (PTree.remove id fe) ! id0 = Some f0) : fenv ! id0 = Some f0.","conclusion":"fenv ! id0 = Some f0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (id0 : positive) (f0 : function) (H : (PTree.remove id fe) ! id0 = Some f0)","proofString":"rewrite PTree.grspec in H.\ndestruct (PTree.elt_eq id0 id); try discriminate.\nauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (id0 : positive) (f0 : function) (H : (if PTree.elt_eq id0 id then None else fe ! id0) = Some f0) : fenv ! id0 = Some f0.","conclusion":"fenv ! id0 = Some f0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (id0 : positive) (f0 : function) (H : (if PTree.elt_eq id0 id then None else fe ! id0) = Some f0)","proofString":"destruct (PTree.elt_eq id0 id); try discriminate.\nauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (id0 : positive) (f0 : function) (n : id0 <> id) (H : fe ! id0 = Some f0) : fenv ! id0 = Some f0.","conclusion":"fenv ! id0 = Some f0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (id0 : positive) (f0 : function) (n : id0 <> id) (H : fe ! id0 = Some f0)","proofString":"auto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : Ple (x1 + max_pc_function f) (st_nextnode s3).","conclusion":"Ple (x1 + max_pc_function f) (st_nextnode s3)","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"subst s3; simpl in *.\nsubst s2; simpl in *.\nextlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s3 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s3 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s3 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (STKSIZE2 : st_stksize s2 <= st_stksize s2) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s2)) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s2 + max_reg_function f)) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2\n  {|\n    st_nextreg := st_nextreg s2 + max_reg_function f;\n    st_nextnode := st_nextnode s2;\n    st_code := st_code s2;\n    st_stksize := st_stksize s2\n  |}\n  (Sincr s2\n     {|\n       st_nextreg := st_nextreg s2 + max_reg_function f;\n       st_nextnode := st_nextnode s2;\n       st_code := st_code s2;\n       st_stksize := st_stksize s2\n     |} NEXTREG2 NEXTNODE2 STKSIZE2)) (STKSIZE1 : st_stksize s2 <= st_stksize s1) (NEXTNODE1 : Ple (st_nextnode s2) (st_nextnode s1)) (NEXTREG1 : Ple (st_nextreg s2 + max_reg_function f) (st_nextreg s1)) (x3 : unit) (s4 : state) (STKSIZE0 : st_stksize s2 <= st_stksize s4) (NEXTNODE0 : Ple (st_nextnode s2) (st_nextnode s4)) (NEXTREG0 : Ple (st_nextreg s2 + max_reg_function f) (st_nextreg s4)) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f\n  {|\n    st_nextreg := st_nextreg s2 + max_reg_function f;\n    st_nextnode := st_nextnode s2;\n    st_code := st_code s2;\n    st_stksize := st_stksize s2\n  |} =\nR x3 s4\n  (Sincr\n     {|\n       st_nextreg := st_nextreg s2 + max_reg_function f;\n       st_nextnode := st_nextnode s2;\n       st_code := st_code s2;\n       st_stksize := st_stksize s2\n     |} s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) : Ple (x1 + max_pc_function f) (st_nextnode s2).","conclusion":"Ple (x1 + max_pc_function f) (st_nextnode s2)","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s3 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s3 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s3 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (STKSIZE2 : st_stksize s2 <= st_stksize s2) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s2)) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s2 + max_reg_function f)) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2\n  {|\n    st_nextreg := st_nextreg s2 + max_reg_function f;\n    st_nextnode := st_nextnode s2;\n    st_code := st_code s2;\n    st_stksize := st_stksize s2\n  |}\n  (Sincr s2\n     {|\n       st_nextreg := st_nextreg s2 + max_reg_function f;\n       st_nextnode := st_nextnode s2;\n       st_code := st_code s2;\n       st_stksize := st_stksize s2\n     |} NEXTREG2 NEXTNODE2 STKSIZE2)) (STKSIZE1 : st_stksize s2 <= st_stksize s1) (NEXTNODE1 : Ple (st_nextnode s2) (st_nextnode s1)) (NEXTREG1 : Ple (st_nextreg s2 + max_reg_function f) (st_nextreg s1)) (x3 : unit) (s4 : state) (STKSIZE0 : st_stksize s2 <= st_stksize s4) (NEXTNODE0 : Ple (st_nextnode s2) (st_nextnode s4)) (NEXTREG0 : Ple (st_nextreg s2 + max_reg_function f) (st_nextreg s4)) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f\n  {|\n    st_nextreg := st_nextreg s2 + max_reg_function f;\n    st_nextnode := st_nextnode s2;\n    st_code := st_code s2;\n    st_stksize := st_stksize s2\n  |} =\nR x3 s4\n  (Sincr\n     {|\n       st_nextreg := st_nextreg s2 + max_reg_function f;\n       st_nextnode := st_nextnode s2;\n       st_code := st_code s2;\n       st_stksize := st_stksize s2\n     |} s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2)","proofString":"subst s2; simpl in *.\nextlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (STKSIZE4 : st_stksize s <= st_stksize s) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s + max_pc_function f)) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s)) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  (Sincr s\n     {|\n       st_nextreg := st_nextreg s;\n       st_nextnode := st_nextnode s + max_pc_function f;\n       st_code := st_code s;\n       st_stksize := st_stksize s\n     |} NEXTREG4 NEXTNODE4 STKSIZE4)) (STKSIZE3 : st_stksize s <= st_stksize s1) (NEXTNODE3 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s1)) (NEXTREG3 : Ple (st_nextreg s) (st_nextreg s1)) (x2 : positive) (NEXTREG1 : Ple (st_nextreg s + max_reg_function f) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s1)) (STKSIZE1 : st_stksize s <= st_stksize s1) (NEXTREG2 : Ple (st_nextreg s) (st_nextreg s + max_reg_function f)) (NEXTNODE2 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s + max_pc_function f)) (STKSIZE2 : st_stksize s <= st_stksize s) (EQ : reserve_regs (max_reg_function f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} =\nR x2\n  {|\n    st_nextreg := st_nextreg s + max_reg_function f;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  (Sincr\n     {|\n       st_nextreg := st_nextreg s;\n       st_nextnode := st_nextnode s + max_pc_function f;\n       st_code := st_code s;\n       st_stksize := st_stksize s\n     |}\n     {|\n       st_nextreg := st_nextreg s + max_reg_function f;\n       st_nextnode := st_nextnode s + max_pc_function f;\n       st_code := st_code s;\n       st_stksize := st_stksize s\n     |} NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s + max_reg_function f) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s4)) (STKSIZE0 : st_stksize s <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f\n  {|\n    st_nextreg := st_nextreg s + max_reg_function f;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} =\nR x3 s4\n  (Sincr\n     {|\n       st_nextreg := st_nextreg s + max_reg_function f;\n       st_nextnode := st_nextnode s + max_pc_function f;\n       st_code := st_code s;\n       st_stksize := st_stksize s\n     |} s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H4 : st_nextreg s = x2) : Ple (x1 + max_pc_function f) (st_nextnode s + max_pc_function f).","conclusion":"Ple (x1 + max_pc_function f) (st_nextnode s + max_pc_function f)","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s2 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s2 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s2 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (STKSIZE4 : st_stksize s <= st_stksize s) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s + max_pc_function f)) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s)) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  (Sincr s\n     {|\n       st_nextreg := st_nextreg s;\n       st_nextnode := st_nextnode s + max_pc_function f;\n       st_code := st_code s;\n       st_stksize := st_stksize s\n     |} NEXTREG4 NEXTNODE4 STKSIZE4)) (STKSIZE3 : st_stksize s <= st_stksize s1) (NEXTNODE3 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s1)) (NEXTREG3 : Ple (st_nextreg s) (st_nextreg s1)) (x2 : positive) (NEXTREG1 : Ple (st_nextreg s + max_reg_function f) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s1)) (STKSIZE1 : st_stksize s <= st_stksize s1) (NEXTREG2 : Ple (st_nextreg s) (st_nextreg s + max_reg_function f)) (NEXTNODE2 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s + max_pc_function f)) (STKSIZE2 : st_stksize s <= st_stksize s) (EQ : reserve_regs (max_reg_function f)\n  {|\n    st_nextreg := st_nextreg s;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} =\nR x2\n  {|\n    st_nextreg := st_nextreg s + max_reg_function f;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |}\n  (Sincr\n     {|\n       st_nextreg := st_nextreg s;\n       st_nextnode := st_nextnode s + max_pc_function f;\n       st_code := st_code s;\n       st_stksize := st_stksize s\n     |}\n     {|\n       st_nextreg := st_nextreg s + max_reg_function f;\n       st_nextnode := st_nextnode s + max_pc_function f;\n       st_code := st_code s;\n       st_stksize := st_stksize s\n     |} NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s + max_reg_function f) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s + max_pc_function f) (st_nextnode s4)) (STKSIZE0 : st_stksize s <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f\n  {|\n    st_nextreg := st_nextreg s + max_reg_function f;\n    st_nextnode := st_nextnode s + max_pc_function f;\n    st_code := st_code s;\n    st_stksize := st_stksize s\n  |} =\nR x3 s4\n  (Sincr\n     {|\n       st_nextreg := st_nextreg s + max_reg_function f;\n       st_nextnode := st_nextnode s + max_pc_function f;\n       st_code := st_code s;\n       st_stksize := st_stksize s\n     |} s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H4 : st_nextreg s = x2)","proofString":"extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : Ple (x2 + max_reg_function f) (st_nextreg s3).","conclusion":"Ple (x2 + max_reg_function f) (st_nextreg s3)","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"subst s3; simpl in *; extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : Z.max (fn_stacksize f) 0 >= 0.","conclusion":"Z.max (fn_stacksize f) 0 >= 0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : (min_alignment (fn_stacksize f)\n| align (dstk ctx) (min_alignment (fn_stacksize f))).","conclusion":"(min_alignment (fn_stacksize f)\n| align (dstk ctx) (min_alignment (fn_stacksize f)))","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"apply align_divides.\napply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : min_alignment (fn_stacksize f) > 0.","conclusion":"min_alignment (fn_stacksize f) > 0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"apply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : dstk ctx <= align (dstk ctx) (min_alignment (fn_stacksize f)).","conclusion":"dstk ctx <= align (dstk ctx) (min_alignment (fn_stacksize f))","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"apply align_le.\napply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : min_alignment (fn_stacksize f) > 0.","conclusion":"min_alignment (fn_stacksize f) > 0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"apply min_alignment_pos."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (H : dstk ctx <= dstk ctx') : dstk ctx' >= 0.","conclusion":"dstk ctx' >= 0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (H : dstk ctx <= dstk ctx')","proofString":"lia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : st_stksize s4 <= stacksize.","conclusion":"st_stksize s4 <= stacksize","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"lia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : c ! pc0 = (st_code s4) ! pc0.","conclusion":"c ! pc0 = (st_code s4) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"rewrite S1.\ntransitivity (s1.(st_code))!pc0.\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto.\nunfold node in *; extlia.\nextlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : (st_code s') ! pc0 = (st_code s4) ! pc0.","conclusion":"(st_code s') ! pc0 = (st_code s4) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"transitivity (s1.(st_code))!pc0.\neapply set_instr_other; eauto.\nunfold node in *; extlia.\neapply add_moves_unchanged; eauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : (st_code s') ! pc0 = (st_code s1) ! pc0.","conclusion":"(st_code s') ! pc0 = (st_code s1) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"eapply set_instr_other; eauto.\nunfold node in *; extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : pc0 <> spc ctx pc.","conclusion":"pc0 <> spc ctx pc","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"unfold node in *; extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : (st_code s1) ! pc0 = (st_code s4) ! pc0.","conclusion":"(st_code s1) ! pc0 = (st_code s4) ! pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"eapply add_moves_unchanged; eauto."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : Ple (st_nextnode s) pc0.","conclusion":"Ple (st_nextnode s) pc0","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"unfold node in *; extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4)) : Plt pc0 (st_nextnode s').","conclusion":"Plt pc0 (st_nextnode s')","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc1 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc1 instr s5 = R x4 s'0 i ->\nc0 ! pc1 = (st_code s'0) ! pc1 -> c0 ! pc1 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) (pc0 : positive) (H : Ple x1 pc0) (H6 : Plt pc0 (st_nextnode s4))","proofString":"extlia."},{"statement":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3) : Ple (dreg ctx + mreg ctx) x2.","conclusion":"Ple (dreg ctx + mreg ctx) x2","hypotheses":"(ctx : context) (pc : node) (s0 : signature) (l : list reg) (s : state) (x : unit) (s' : state) (NEXTREG7 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE7 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE7 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (id : ident) (f : function) (Q : fe ! id = Some f) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s5 : state) \n  (x4 : unit) (s'0 : state) (i : sincr s5 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s5 = R x4 s'0 i ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) (x0 : node) (s1 : state) (NEXTREG6 : Ple (st_nextreg s) (st_nextreg s1)) (NEXTNODE6 : Ple (st_nextnode s) (st_nextnode s1)) (STKSIZE6 : st_stksize s <= st_stksize s1) (NEXTREG5 : Ple (st_nextreg s1) (st_nextreg s')) (NEXTNODE5 : Ple (st_nextnode s1) (st_nextnode s')) (STKSIZE5 : st_stksize s1 <= st_stksize s') (EQ0 : set_instr (spc ctx pc) (Inop x0) s1 =\nR x s' (Sincr s1 s' NEXTREG5 NEXTNODE5 STKSIZE5)) (x1 : positive) (s2 : state) (NEXTREG4 : Ple (st_nextreg s) (st_nextreg s2)) (NEXTNODE4 : Ple (st_nextnode s) (st_nextnode s2)) (STKSIZE4 : st_stksize s <= st_stksize s2) (NEXTREG3 : Ple (st_nextreg s2) (st_nextreg s1)) (NEXTNODE3 : Ple (st_nextnode s2) (st_nextnode s1)) (STKSIZE3 : st_stksize s2 <= st_stksize s1) (EQ1 : reserve_nodes (max_pc_function f) s =\nR x1 s2 (Sincr s s2 NEXTREG4 NEXTNODE4 STKSIZE4)) (x2 : positive) (s3 : state) (NEXTREG2 : Ple (st_nextreg s2) (st_nextreg s3)) (NEXTNODE2 : Ple (st_nextnode s2) (st_nextnode s3)) (STKSIZE2 : st_stksize s2 <= st_stksize s3) (NEXTREG1 : Ple (st_nextreg s3) (st_nextreg s1)) (NEXTNODE1 : Ple (st_nextnode s3) (st_nextnode s1)) (STKSIZE1 : st_stksize s3 <= st_stksize s1) (EQ : reserve_regs (max_reg_function f) s2 =\nR x2 s3 (Sincr s2 s3 NEXTREG2 NEXTNODE2 STKSIZE2)) (x3 : unit) (s4 : state) (NEXTREG0 : Ple (st_nextreg s3) (st_nextreg s4)) (NEXTNODE0 : Ple (st_nextnode s3) (st_nextnode s4)) (STKSIZE0 : st_stksize s3 <= st_stksize s4) (NEXTREG : Ple (st_nextreg s4) (st_nextreg s1)) (NEXTNODE : Ple (st_nextnode s4) (st_nextnode s1)) (STKSIZE : st_stksize s4 <= st_stksize s1) (ctx' : context) (EQ2 : rec (PTree.remove id fe) (PTree_Properties.cardinal_remove Q) ctx' f s3 =\nR x3 s4 (Sincr s3 s4 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ4 : add_moves (sregs ctx l) (sregs ctx' (fn_params f))\n  (spc ctx' (fn_entrypoint f)) s4 =\nR x0 s1 (Sincr s4 s1 NEXTREG NEXTNODE STKSIZE)) (H0 : tt = x) (H1 : {|\n  st_nextreg := st_nextreg s1;\n  st_nextnode := st_nextnode s1;\n  st_code := PTree.set (spc ctx pc) (Inop x0) (st_code s1);\n  st_stksize := st_stksize s1\n|} = s') (H2 : st_nextnode s = x1) (H3 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s + max_pc_function f;\n  st_code := st_code s;\n  st_stksize := st_stksize s\n|} = s2) (H4 : st_nextreg s2 = x2) (H5 : {|\n  st_nextreg := st_nextreg s2 + max_reg_function f;\n  st_nextnode := st_nextnode s2;\n  st_code := st_code s2;\n  st_stksize := st_stksize s2\n|} = s3)","proofString":"subst s2; simpl in *; extlia."},{"statement":"(ctx : context) (pc : node) (e : external_function) (l : list (builtin_arg reg)) (b : builtin_res reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : set_instr (spc ctx pc)\n  (Ibuiltin e (map (sbuiltinarg ctx) l) (sbuiltinres ctx b) (spc ctx n)) s =\nR x s' i) (DEFS : forall r : reg,\nmatch b with\n| BR r0 => Some r0\n| _ => None\nend = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s0 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Ibuiltin e l b n) c.","conclusion":"tr_instr ctx pc (Ibuiltin e l b n) c","hypotheses":"(ctx : context) (pc : node) (e : external_function) (l : list (builtin_arg reg)) (b : builtin_res reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : set_instr (spc ctx pc)\n  (Ibuiltin e (map (sbuiltinarg ctx) l) (sbuiltinres ctx b) (spc ctx n)) s =\nR x s' i) (DEFS : forall r : reg,\nmatch b with\n| BR r0 => Some r0\n| _ => None\nend = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s0 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"eapply tr_builtin; eauto.\ndestruct b; eauto."},{"statement":"(ctx : context) (pc : node) (e : external_function) (l : list (builtin_arg reg)) (b : builtin_res reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : set_instr (spc ctx pc)\n  (Ibuiltin e (map (sbuiltinarg ctx) l) (sbuiltinres ctx b) (spc ctx n)) s =\nR x s' i) (DEFS : forall r : reg,\nmatch b with\n| BR r0 => Some r0\n| _ => None\nend = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s0 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : match b with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend.","conclusion":"match b with\n| BR r => Ple r (mreg ctx)\n| _ => True\nend","hypotheses":"(ctx : context) (pc : node) (e : external_function) (l : list (builtin_arg reg)) (b : builtin_res reg) (n : node) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : set_instr (spc ctx pc)\n  (Ibuiltin e (map (sbuiltinarg ctx) l) (sbuiltinres ctx b) (spc ctx n)) s =\nR x s' i) (DEFS : forall r : reg,\nmatch b with\n| BR r0 => Some r0\n| _ => None\nend = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s0 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"destruct b; eauto."},{"statement":"(ctx : context) (pc : node) (o : option reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : match retinfo ctx with\n| Some rinfo => set_instr (spc ctx pc) (inline_return ctx o rinfo)\n| None => set_instr (spc ctx pc) (Ireturn (option_map (sreg ctx) o))\nend s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s0 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Ireturn o) c.","conclusion":"tr_instr ctx pc (Ireturn o) c","hypotheses":"(ctx : context) (pc : node) (o : option reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (EXP : match retinfo ctx with\n| Some rinfo => set_instr (spc ctx pc) (inline_return ctx o rinfo)\n| None => set_instr (spc ctx pc) (Ireturn (option_map (sreg ctx) o))\nend s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s0 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"destruct (retinfo ctx) as [[rpc rreg] | ] eqn:?.\neapply tr_return_inlined; eauto.\neapply tr_return; eauto."},{"statement":"(ctx : context) (pc : node) (o : option reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (rpc : node) (rreg : reg) (Heqo0 : retinfo ctx = Some (rpc, rreg)) (EXP : set_instr (spc ctx pc) (inline_return ctx o (rpc, rreg)) s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s0 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Ireturn o) c.","conclusion":"tr_instr ctx pc (Ireturn o) c","hypotheses":"(ctx : context) (pc : node) (o : option reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (rpc : node) (rreg : reg) (Heqo0 : retinfo ctx = Some (rpc, rreg)) (EXP : set_instr (spc ctx pc) (inline_return ctx o (rpc, rreg)) s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s0 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"eapply tr_return_inlined; eauto."},{"statement":"(ctx : context) (pc : node) (o : option reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (Heqo0 : retinfo ctx = None) (EXP : set_instr (spc ctx pc) (Ireturn (option_map (sreg ctx) o)) s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s0 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr) : tr_instr ctx pc (Ireturn o) c.","conclusion":"tr_instr ctx pc (Ireturn o) c","hypotheses":"(ctx : context) (pc : node) (o : option reg) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (Heqo0 : retinfo ctx = None) (EXP : set_instr (spc ctx pc) (Ireturn (option_map (sreg ctx) o)) s = R x s' i) (DEFS : forall r : reg, None = Some r -> Ple r (mreg ctx)) (OPC : Plt (spc ctx pc) (st_nextnode s)) (OREG : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (STK1 : mstk ctx >= 0) (STK2 : dstk ctx >= 0) (STK3 : st_stksize s' <= stacksize) (S1 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (S2 : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)) (BASE : forall (pc0 : node) (instr : instruction) (s0 : state) \n  (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nset_instr pc0 instr s0 = R x0 s'0 i0 ->\nc0 ! pc0 = (st_code s'0) ! pc0 -> c0 ! pc0 = Some instr)","proofString":"eapply tr_return; eauto."},{"statement":"(ctx : context) (a : node * instruction) (l : list (node * instruction)) (IHl : forall (s0 : state) (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s0 = R x0 s'0 i0 ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s0)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s0) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : (let (x0, y) := a in\n do _ <- expand_instr fe rec ctx x0 y;\n mlist_iter2 (expand_instr fe rec ctx) l) s = R x s' i) (H0 : list_norepet (fst a :: map fst l)) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\na = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\na = (pc0, instr0) \\/ In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\na = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : a = (pc, instr) \\/ In (pc, instr) l) : tr_instr ctx pc instr c.","conclusion":"tr_instr ctx pc instr c","hypotheses":"(ctx : context) (a : node * instruction) (l : list (node * instruction)) (IHl : forall (s0 : state) (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s0 = R x0 s'0 i0 ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s0)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s0) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : (let (x0, y) := a in\n do _ <- expand_instr fe rec ctx x0 y;\n mlist_iter2 (expand_instr fe rec ctx) l) s = R x s' i) (H0 : list_norepet (fst a :: map fst l)) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\na = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\na = (pc0, instr0) \\/ In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\na = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : a = (pc, instr) \\/ In (pc, instr) l)","proofString":"destruct a as [pc1 instr1]; simpl in *.\ninv H0.\nmonadInv H.\ninv_incr.\nassert (A: Ple ctx.(dpc) s0.(st_nextnode)).\nassert (B: Plt (spc ctx pc) (st_nextnode s)) by eauto.\nunfold spc in B.\ngeneralize (shiftpos_above pc (dpc ctx)).\nextlia.\ndestruct H9.\ninv H.\neapply expand_instr_spec; eauto.\nlia.\nintros.\ntransitivity ((st_code s')!pc').\napply H7.\nauto.\nextlia.\neapply iter_expand_instr_unchanged; eauto.\nred; intros.\nrewrite list_map_compose in H9.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia.\ntransitivity ((st_code s')!(spc ctx pc)).\neapply H8; eauto.\neapply iter_expand_instr_unchanged; eauto.\nassert (Plt (spc ctx pc) (st_nextnode s)) by eauto.\nextlia.\nred; intros.\nrewrite list_map_compose in H.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto.\ninv_incr.\neapply IHl; eauto.\nintros.\neapply Pos.lt_le_trans.\neapply H2.\nright; eauto.\nextlia.\nintros; eapply Ple_trans; eauto.\nintros.\napply H7; auto.\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s0 : state) (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s0 = R x0 s'0 i0 ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s0)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s0) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : (do _ <- expand_instr fe rec ctx pc1 instr1;\n mlist_iter2 (expand_instr fe rec ctx) l) s = R x s' i) (H0 : list_norepet (pc1 :: map fst l)) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) : tr_instr ctx pc instr c.","conclusion":"tr_instr ctx pc instr c","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s0 : state) (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s0 = R x0 s'0 i0 ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s0)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s0) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : (do _ <- expand_instr fe rec ctx pc1 instr1;\n mlist_iter2 (expand_instr fe rec ctx) l) s = R x s' i) (H0 : list_norepet (pc1 :: map fst l)) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l)","proofString":"inv H0.\nmonadInv H.\ninv_incr.\nassert (A: Ple ctx.(dpc) s0.(st_nextnode)).\nassert (B: Plt (spc ctx pc) (st_nextnode s)) by eauto.\nunfold spc in B.\ngeneralize (shiftpos_above pc (dpc ctx)).\nextlia.\ndestruct H9.\ninv H.\neapply expand_instr_spec; eauto.\nlia.\nintros.\ntransitivity ((st_code s')!pc').\napply H7.\nauto.\nextlia.\neapply iter_expand_instr_unchanged; eauto.\nred; intros.\nrewrite list_map_compose in H9.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia.\ntransitivity ((st_code s')!(spc ctx pc)).\neapply H8; eauto.\neapply iter_expand_instr_unchanged; eauto.\nassert (Plt (spc ctx pc) (st_nextnode s)) by eauto.\nextlia.\nred; intros.\nrewrite list_map_compose in H.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto.\ninv_incr.\neapply IHl; eauto.\nintros.\neapply Pos.lt_le_trans.\neapply H2.\nright; eauto.\nextlia.\nintros; eapply Ple_trans; eauto.\nintros.\napply H7; auto.\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s0 : state) (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s0 = R x0 s'0 i0 ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s0)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s0) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : (do _ <- expand_instr fe rec ctx pc1 instr1;\n mlist_iter2 (expand_instr fe rec ctx) l) s = R x s' i) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) : tr_instr ctx pc instr c.","conclusion":"tr_instr ctx pc instr c","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s0 : state) (x0 : unit) (s'0 : state) (i0 : sincr s0 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s0 = R x0 s'0 i0 ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s0)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s0) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : (do _ <- expand_instr fe rec ctx pc1 instr1;\n mlist_iter2 (expand_instr fe rec ctx) l) s = R x s' i) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l))","proofString":"monadInv H.\ninv_incr.\nassert (A: Ple ctx.(dpc) s0.(st_nextnode)).\nassert (B: Plt (spc ctx pc) (st_nextnode s)) by eauto.\nunfold spc in B.\ngeneralize (shiftpos_above pc (dpc ctx)).\nextlia.\ndestruct H9.\ninv H.\neapply expand_instr_spec; eauto.\nlia.\nintros.\ntransitivity ((st_code s')!pc').\napply H7.\nauto.\nextlia.\neapply iter_expand_instr_unchanged; eauto.\nred; intros.\nrewrite list_map_compose in H9.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia.\ntransitivity ((st_code s')!(spc ctx pc)).\neapply H8; eauto.\neapply iter_expand_instr_unchanged; eauto.\nassert (Plt (spc ctx pc) (st_nextnode s)) by eauto.\nextlia.\nred; intros.\nrewrite list_map_compose in H.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto.\ninv_incr.\neapply IHl; eauto.\nintros.\neapply Pos.lt_le_trans.\neapply H2.\nright; eauto.\nextlia.\nintros; eapply Ple_trans; eauto.\nintros.\napply H7; auto.\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0) : tr_instr ctx pc instr c.","conclusion":"tr_instr ctx pc instr c","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i0 : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i0 ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : expand_instr fe rec ctx pc1 instr1 s = R x0 s0 INCR) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 = R x s' INCR0)","proofString":"inv_incr.\nassert (A: Ple ctx.(dpc) s0.(st_nextnode)).\nassert (B: Plt (spc ctx pc) (st_nextnode s)) by eauto.\nunfold spc in B.\ngeneralize (shiftpos_above pc (dpc ctx)).\nextlia.\ndestruct H9.\ninv H.\neapply expand_instr_spec; eauto.\nlia.\nintros.\ntransitivity ((st_code s')!pc').\napply H7.\nauto.\nextlia.\neapply iter_expand_instr_unchanged; eauto.\nred; intros.\nrewrite list_map_compose in H9.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia.\ntransitivity ((st_code s')!(spc ctx pc)).\neapply H8; eauto.\neapply iter_expand_instr_unchanged; eauto.\nassert (Plt (spc ctx pc) (st_nextnode s)) by eauto.\nextlia.\nred; intros.\nrewrite list_map_compose in H.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto.\ninv_incr.\neapply IHl; eauto.\nintros.\neapply Pos.lt_le_trans.\neapply H2.\nright; eauto.\nextlia.\nintros; eapply Ple_trans; eauto.\nintros.\napply H7; auto.\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) : tr_instr ctx pc instr c.","conclusion":"tr_instr ctx pc instr c","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE))","proofString":"assert (A: Ple ctx.(dpc) s0.(st_nextnode)).\nassert (B: Plt (spc ctx pc) (st_nextnode s)) by eauto.\nunfold spc in B.\ngeneralize (shiftpos_above pc (dpc ctx)).\nextlia.\ndestruct H9.\ninv H.\neapply expand_instr_spec; eauto.\nlia.\nintros.\ntransitivity ((st_code s')!pc').\napply H7.\nauto.\nextlia.\neapply iter_expand_instr_unchanged; eauto.\nred; intros.\nrewrite list_map_compose in H9.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia.\ntransitivity ((st_code s')!(spc ctx pc)).\neapply H8; eauto.\neapply iter_expand_instr_unchanged; eauto.\nassert (Plt (spc ctx pc) (st_nextnode s)) by eauto.\nextlia.\nred; intros.\nrewrite list_map_compose in H.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto.\ninv_incr.\neapply IHl; eauto.\nintros.\neapply Pos.lt_le_trans.\neapply H2.\nright; eauto.\nextlia.\nintros; eapply Ple_trans; eauto.\nintros.\napply H7; auto.\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) : Ple (dpc ctx) (st_nextnode s0).","conclusion":"Ple (dpc ctx) (st_nextnode s0)","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE))","proofString":"assert (B: Plt (spc ctx pc) (st_nextnode s)) by eauto.\nunfold spc in B.\ngeneralize (shiftpos_above pc (dpc ctx)).\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (B : Plt (spc ctx pc) (st_nextnode s)) : Ple (dpc ctx) (st_nextnode s0).","conclusion":"Ple (dpc ctx) (st_nextnode s0)","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (B : Plt (spc ctx pc) (st_nextnode s))","proofString":"unfold spc in B.\ngeneralize (shiftpos_above pc (dpc ctx)).\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (B : Plt (shiftpos pc (dpc ctx)) (st_nextnode s)) : Ple (dpc ctx) (st_nextnode s0).","conclusion":"Ple (dpc ctx) (st_nextnode s0)","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (B : Plt (shiftpos pc (dpc ctx)) (st_nextnode s))","proofString":"generalize (shiftpos_above pc (dpc ctx)).\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (B : Plt (shiftpos pc (dpc ctx)) (st_nextnode s)) : Ple (dpc ctx) (shiftpos pc (dpc ctx)) -> Ple (dpc ctx) (st_nextnode s0).","conclusion":"Ple (dpc ctx) (shiftpos pc (dpc ctx)) -> Ple (dpc ctx) (st_nextnode s0)","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (B : Plt (shiftpos pc (dpc ctx)) (st_nextnode s))","proofString":"extlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : tr_instr ctx pc instr c.","conclusion":"tr_instr ctx pc instr c","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H9 : (pc1, instr1) = (pc, instr) \\/ In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"destruct H9.\ninv H.\neapply expand_instr_spec; eauto.\nlia.\nintros.\ntransitivity ((st_code s')!pc').\napply H7.\nauto.\nextlia.\neapply iter_expand_instr_unchanged; eauto.\nred; intros.\nrewrite list_map_compose in H9.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia.\ntransitivity ((st_code s')!(spc ctx pc)).\neapply H8; eauto.\neapply iter_expand_instr_unchanged; eauto.\nassert (Plt (spc ctx pc) (st_nextnode s)) by eauto.\nextlia.\nred; intros.\nrewrite list_map_compose in H.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto.\ninv_incr.\neapply IHl; eauto.\nintros.\neapply Pos.lt_le_trans.\neapply H2.\nright; eauto.\nextlia.\nintros; eapply Ple_trans; eauto.\nintros.\napply H7; auto.\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : (pc1, instr1) = (pc, instr)) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : tr_instr ctx pc instr c.","conclusion":"tr_instr ctx pc instr c","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : (pc1, instr1) = (pc, instr)) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"inv H.\neapply expand_instr_spec; eauto.\nlia.\nintros.\ntransitivity ((st_code s')!pc').\napply H7.\nauto.\nextlia.\neapply iter_expand_instr_unchanged; eauto.\nred; intros.\nrewrite list_map_compose in H9.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia.\ntransitivity ((st_code s')!(spc ctx pc)).\neapply H8; eauto.\neapply iter_expand_instr_unchanged; eauto.\nassert (Plt (spc ctx pc) (st_nextnode s)) by eauto.\nextlia.\nred; intros.\nrewrite list_map_compose in H.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : tr_instr ctx pc instr c.","conclusion":"tr_instr ctx pc instr c","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"eapply expand_instr_spec; eauto.\nlia.\nintros.\ntransitivity ((st_code s')!pc').\napply H7.\nauto.\nextlia.\neapply iter_expand_instr_unchanged; eauto.\nred; intros.\nrewrite list_map_compose in H9.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia.\ntransitivity ((st_code s')!(spc ctx pc)).\neapply H8; eauto.\neapply iter_expand_instr_unchanged; eauto.\nassert (Plt (spc ctx pc) (st_nextnode s)) by eauto.\nextlia.\nred; intros.\nrewrite list_map_compose in H.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : st_stksize s0 <= stacksize.","conclusion":"st_stksize s0 <= stacksize","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"lia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s0) -> c ! pc' = (st_code s0) ! pc'.","conclusion":"forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s0) -> c ! pc' = (st_code s0) ! pc'","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"intros.\ntransitivity ((st_code s')!pc').\napply H7.\nauto.\nextlia.\neapply iter_expand_instr_unchanged; eauto.\nred; intros.\nrewrite list_map_compose in H9.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) : c ! pc' = (st_code s0) ! pc'.","conclusion":"c ! pc' = (st_code s0) ! pc'","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0))","proofString":"transitivity ((st_code s')!pc').\napply H7.\nauto.\nextlia.\neapply iter_expand_instr_unchanged; eauto.\nred; intros.\nrewrite list_map_compose in H9.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) : c ! pc' = (st_code s') ! pc'.","conclusion":"c ! pc' = (st_code s') ! pc'","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0))","proofString":"apply H7.\nauto.\nextlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) : Ple (st_nextnode s) pc'.","conclusion":"Ple (st_nextnode s) pc'","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0))","proofString":"auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) : Plt pc' (st_nextnode s').","conclusion":"Plt pc' (st_nextnode s')","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0))","proofString":"extlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) : (st_code s') ! pc' = (st_code s0) ! pc'.","conclusion":"(st_code s') ! pc' = (st_code s0) ! pc'","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0))","proofString":"eapply iter_expand_instr_unchanged; eauto.\nred; intros.\nrewrite list_map_compose in H9.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) : ~ In pc' (map (spc ctx) (map fst l)).","conclusion":"~ In pc' (map (spc ctx) (map fst l))","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0))","proofString":"red; intros.\nrewrite list_map_compose in H9.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) (H9 : In pc' (map (spc ctx) (map fst l))) : False.","conclusion":"False","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) (H9 : In pc' (map (spc ctx) (map fst l)))","proofString":"rewrite list_map_compose in H9.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) (H9 : In pc' (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) : False.","conclusion":"False","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) (H9 : In pc' (map (fun x1 : node * instruction => spc ctx (fst x1)) l))","proofString":"exploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) (H9 : In pc' (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) : (exists x1 : node * instruction,\n   pc' = (fun x2 : node * instruction => spc ctx (fst x2)) x1 /\\ In x1 l) ->\nFalse.","conclusion":"(exists x1 : node * instruction,\n   pc' = (fun x2 : node * instruction => spc ctx (fst x2)) x1 /\\ In x1 l) ->\nFalse","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) (H9 : In pc' (map (fun x1 : node * instruction => spc ctx (fst x1)) l))","proofString":"intros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc1 : node) (instr1 : instruction) (r : reg),\n In (pc1, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> Plt (spc ctx pc1) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> c0 ! (spc ctx pc1) = (st_code s'0) ! (spc ctx pc1)) ->\nforall (pc1 : node) (instr1 : instruction),\nIn (pc1, instr1) l -> tr_instr ctx pc1 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc1 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nPlt (spc ctx pc1) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nc ! (spc ctx pc1) = (st_code s') ! (spc ctx pc1)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) (H9 : In pc' (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (pc0 : node) (instr0 : instruction) (P : pc' = spc ctx (fst (pc0, instr0))) (Q : In (pc0, instr0) l) : False.","conclusion":"False","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc1 : node) (instr1 : instruction) (r : reg),\n In (pc1, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> Plt (spc ctx pc1) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> c0 ! (spc ctx pc1) = (st_code s'0) ! (spc ctx pc1)) ->\nforall (pc1 : node) (instr1 : instruction),\nIn (pc1, instr1) l -> tr_instr ctx pc1 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc1 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nPlt (spc ctx pc1) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nc ! (spc ctx pc1) = (st_code s') ! (spc ctx pc1)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) (H9 : In pc' (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (pc0 : node) (instr0 : instruction) (P : pc' = spc ctx (fst (pc0, instr0))) (Q : In (pc0, instr0) l)","proofString":"simpl in P.\nassert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc1 : node) (instr1 : instruction) (r : reg),\n In (pc1, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> Plt (spc ctx pc1) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> c0 ! (spc ctx pc1) = (st_code s'0) ! (spc ctx pc1)) ->\nforall (pc1 : node) (instr1 : instruction),\nIn (pc1, instr1) l -> tr_instr ctx pc1 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc1 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nPlt (spc ctx pc1) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nc ! (spc ctx pc1) = (st_code s') ! (spc ctx pc1)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) (H9 : In pc' (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (pc0 : node) (instr0 : instruction) (P : pc' = spc ctx pc0) (Q : In (pc0, instr0) l) : False.","conclusion":"False","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc1 : node) (instr1 : instruction) (r : reg),\n In (pc1, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> Plt (spc ctx pc1) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> c0 ! (spc ctx pc1) = (st_code s'0) ! (spc ctx pc1)) ->\nforall (pc1 : node) (instr1 : instruction),\nIn (pc1, instr1) l -> tr_instr ctx pc1 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc1 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nPlt (spc ctx pc1) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nc ! (spc ctx pc1) = (st_code s') ! (spc ctx pc1)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) (H9 : In pc' (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (pc0 : node) (instr0 : instruction) (P : pc' = spc ctx pc0) (Q : In (pc0, instr0) l)","proofString":"assert (Plt (spc ctx pc0) (st_nextnode s)) by eauto.\nextlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc1 : node) (instr1 : instruction) (r : reg),\n In (pc1, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> Plt (spc ctx pc1) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> c0 ! (spc ctx pc1) = (st_code s'0) ! (spc ctx pc1)) ->\nforall (pc1 : node) (instr1 : instruction),\nIn (pc1, instr1) l -> tr_instr ctx pc1 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc1 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nPlt (spc ctx pc1) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nc ! (spc ctx pc1) = (st_code s') ! (spc ctx pc1)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) (H9 : In pc' (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (pc0 : node) (instr0 : instruction) (P : pc' = spc ctx pc0) (Q : In (pc0, instr0) l) (H10 : Plt (spc ctx pc0) (st_nextnode s)) : False.","conclusion":"False","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc1 : node) (instr1 : instruction) (r : reg),\n In (pc1, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> Plt (spc ctx pc1) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> c0 ! (spc ctx pc1) = (st_code s'0) ! (spc ctx pc1)) ->\nforall (pc1 : node) (instr1 : instruction),\nIn (pc1, instr1) l -> tr_instr ctx pc1 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc1 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nPlt (spc ctx pc1) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nc ! (spc ctx pc1) = (st_code s') ! (spc ctx pc1)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H : Ple (st_nextnode s) pc') (H0 : Plt pc' (st_nextnode s0)) (H9 : In pc' (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (pc0 : node) (instr0 : instruction) (P : pc' = spc ctx pc0) (Q : In (pc0, instr0) l) (H10 : Plt (spc ctx pc0) (st_nextnode s))","proofString":"extlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : c ! (spc ctx pc) = (st_code s0) ! (spc ctx pc).","conclusion":"c ! (spc ctx pc) = (st_code s0) ! (spc ctx pc)","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"transitivity ((st_code s')!(spc ctx pc)).\neapply H8; eauto.\neapply iter_expand_instr_unchanged; eauto.\nassert (Plt (spc ctx pc) (st_nextnode s)) by eauto.\nextlia.\nred; intros.\nrewrite list_map_compose in H.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : c ! (spc ctx pc) = (st_code s') ! (spc ctx pc).","conclusion":"c ! (spc ctx pc) = (st_code s') ! (spc ctx pc)","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"eapply H8; eauto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : (st_code s') ! (spc ctx pc) = (st_code s0) ! (spc ctx pc).","conclusion":"(st_code s') ! (spc ctx pc) = (st_code s0) ! (spc ctx pc)","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"eapply iter_expand_instr_unchanged; eauto.\nassert (Plt (spc ctx pc) (st_nextnode s)) by eauto.\nextlia.\nred; intros.\nrewrite list_map_compose in H.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : Plt (spc ctx pc) (st_nextnode s0).","conclusion":"Plt (spc ctx pc) (st_nextnode s0)","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"assert (Plt (spc ctx pc) (st_nextnode s)) by eauto.\nextlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : Plt (spc ctx pc) (st_nextnode s)) : Plt (spc ctx pc) (st_nextnode s0).","conclusion":"Plt (spc ctx pc) (st_nextnode s0)","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : Plt (spc ctx pc) (st_nextnode s))","proofString":"extlia."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : ~ In (spc ctx pc) (map (spc ctx) (map fst l)).","conclusion":"~ In (spc ctx pc) (map (spc ctx) (map fst l))","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"red; intros.\nrewrite list_map_compose in H.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (spc ctx) (map fst l))) : False.","conclusion":"False","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (spc ctx) (map fst l)))","proofString":"rewrite list_map_compose in H.\nexploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) : False.","conclusion":"False","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l))","proofString":"exploit list_in_map_inv; eauto.\nintros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) : (exists x1 : node * instruction,\n   spc ctx pc = (fun x2 : node * instruction => spc ctx (fst x2)) x1 /\\\n   In x1 l) -> False.","conclusion":"(exists x1 : node * instruction,\n   spc ctx pc = (fun x2 : node * instruction => spc ctx (fst x2)) x1 /\\\n   In x1 l) -> False","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc, instr) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l))","proofString":"intros [[pc0 instr0] [P Q]].\nsimpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc1 : node) (instr1 : instruction) (r : reg),\n In (pc1, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> Plt (spc ctx pc1) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> c0 ! (spc ctx pc1) = (st_code s'0) ! (spc ctx pc1)) ->\nforall (pc1 : node) (instr1 : instruction),\nIn (pc1, instr1) l -> tr_instr ctx pc1 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc1 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nPlt (spc ctx pc1) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nc ! (spc ctx pc1) = (st_code s') ! (spc ctx pc1)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (pc0 : node) (instr0 : instruction) (P : spc ctx pc = spc ctx (fst (pc0, instr0))) (Q : In (pc0, instr0) l) : False.","conclusion":"False","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc1 : node) (instr1 : instruction) (r : reg),\n In (pc1, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> Plt (spc ctx pc1) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> c0 ! (spc ctx pc1) = (st_code s'0) ! (spc ctx pc1)) ->\nforall (pc1 : node) (instr1 : instruction),\nIn (pc1, instr1) l -> tr_instr ctx pc1 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc1 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nPlt (spc ctx pc1) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nc ! (spc ctx pc1) = (st_code s') ! (spc ctx pc1)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (pc0 : node) (instr0 : instruction) (P : spc ctx pc = spc ctx (fst (pc0, instr0))) (Q : In (pc0, instr0) l)","proofString":"simpl in P.\nassert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc1 : node) (instr1 : instruction) (r : reg),\n In (pc1, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> Plt (spc ctx pc1) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> c0 ! (spc ctx pc1) = (st_code s'0) ! (spc ctx pc1)) ->\nforall (pc1 : node) (instr1 : instruction),\nIn (pc1, instr1) l -> tr_instr ctx pc1 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc1 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nPlt (spc ctx pc1) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nc ! (spc ctx pc1) = (st_code s') ! (spc ctx pc1)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (pc0 : node) (instr0 : instruction) (P : spc ctx pc = spc ctx pc0) (Q : In (pc0, instr0) l) : False.","conclusion":"False","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc1 : node) (instr1 : instruction) (r : reg),\n In (pc1, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> Plt (spc ctx pc1) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> c0 ! (spc ctx pc1) = (st_code s'0) ! (spc ctx pc1)) ->\nforall (pc1 : node) (instr1 : instruction),\nIn (pc1, instr1) l -> tr_instr ctx pc1 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc1 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nPlt (spc ctx pc1) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nc ! (spc ctx pc1) = (st_code s') ! (spc ctx pc1)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (pc0 : node) (instr0 : instruction) (P : spc ctx pc = spc ctx pc0) (Q : In (pc0, instr0) l)","proofString":"assert (pc = pc0) by (eapply shiftpos_inj; eauto).\nsubst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc1 : node) (instr1 : instruction) (r : reg),\n In (pc1, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> Plt (spc ctx pc1) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> c0 ! (spc ctx pc1) = (st_code s'0) ! (spc ctx pc1)) ->\nforall (pc1 : node) (instr1 : instruction),\nIn (pc1, instr1) l -> tr_instr ctx pc1 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc1 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nPlt (spc ctx pc1) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nc ! (spc ctx pc1) = (st_code s') ! (spc ctx pc1)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (pc0 : node) (instr0 : instruction) (P : spc ctx pc = spc ctx pc0) (Q : In (pc0, instr0) l) (H0 : pc = pc0) : False.","conclusion":"False","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc1 : node) (instr1 : instruction) (r : reg),\n In (pc1, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> Plt (spc ctx pc1) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc1 : node) (instr1 : instruction),\n In (pc1, instr1) l -> c0 ! (spc ctx pc1) = (st_code s'0) ! (spc ctx pc1)) ->\nforall (pc1 : node) (instr1 : instruction),\nIn (pc1, instr1) l -> tr_instr ctx pc1 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc1 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nPlt (spc ctx pc1) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc1 : node) (instr1 : instruction),\n(pc, instr) = (pc1, instr1) \\/ In (pc1, instr1) l ->\nc ! (spc ctx pc1) = (st_code s') ! (spc ctx pc1)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (pc0 : node) (instr0 : instruction) (P : spc ctx pc = spc ctx pc0) (Q : In (pc0, instr0) l) (H0 : pc = pc0)","proofString":"subst pc0.\nelim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr1 : instruction) (r : reg),\n In (pc0, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr1 : instruction),\n In (pc0, instr1) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr1 : instruction),\n In (pc0, instr1) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr1 : instruction),\nIn (pc0, instr1) l -> tr_instr ctx pc0 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr1 : instruction),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr1 : instruction),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (instr0 : instruction) (Q : In (pc, instr0) l) (P : spc ctx pc = spc ctx pc) : False.","conclusion":"False","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr1 : instruction) (r : reg),\n In (pc0, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr1 : instruction),\n In (pc0, instr1) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr1 : instruction),\n In (pc0, instr1) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr1 : instruction),\nIn (pc0, instr1) l -> tr_instr ctx pc0 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr1 : instruction),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr1 : instruction),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (instr0 : instruction) (Q : In (pc, instr0) l) (P : spc ctx pc = spc ctx pc)","proofString":"elim H12.\nchange pc with (fst (pc, instr0)).\napply List.in_map; auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr1 : instruction) (r : reg),\n In (pc0, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr1 : instruction),\n In (pc0, instr1) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr1 : instruction),\n In (pc0, instr1) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr1 : instruction),\nIn (pc0, instr1) l -> tr_instr ctx pc0 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr1 : instruction),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr1 : instruction),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (instr0 : instruction) (Q : In (pc, instr0) l) (P : spc ctx pc = spc ctx pc) : In pc (map fst l).","conclusion":"In pc (map fst l)","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr1 : instruction) (r : reg),\n In (pc0, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr1 : instruction),\n In (pc0, instr1) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr1 : instruction),\n In (pc0, instr1) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr1 : instruction),\nIn (pc0, instr1) l -> tr_instr ctx pc0 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr1 : instruction),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr1 : instruction),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (instr0 : instruction) (Q : In (pc, instr0) l) (P : spc ctx pc = spc ctx pc)","proofString":"change pc with (fst (pc, instr0)).\napply List.in_map; auto."},{"statement":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr1 : instruction) (r : reg),\n In (pc0, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr1 : instruction),\n In (pc0, instr1) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr1 : instruction),\n In (pc0, instr1) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr1 : instruction),\nIn (pc0, instr1) l -> tr_instr ctx pc0 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr1 : instruction),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr1 : instruction),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (instr0 : instruction) (Q : In (pc, instr0) l) (P : spc ctx pc = spc ctx pc) : In (fst (pc, instr0)) (map fst l).","conclusion":"In (fst (pc, instr0)) (map fst l)","hypotheses":"(ctx : context) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr1 : instruction) (r : reg),\n In (pc0, instr1) l -> instr_defs instr1 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr1 : instruction),\n In (pc0, instr1) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr1 : instruction),\n In (pc0, instr1) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr1 : instruction),\nIn (pc0, instr1) l -> tr_instr ctx pc0 instr1 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (pc : node) (instr : instruction) (H1 : forall (pc0 : node) (instr1 : instruction) (r : reg),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\ninstr_defs instr1 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr1 : instruction),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr1 : instruction),\n(pc, instr) = (pc0, instr1) \\/ In (pc0, instr1) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (H12 : ~ In pc (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc instr s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (H : In (spc ctx pc) (map (fun x1 : node * instruction => spc ctx (fst x1)) l)) (instr0 : instruction) (Q : In (pc, instr0) l) (P : spc ctx pc = spc ctx pc)","proofString":"apply List.in_map; auto."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : tr_instr ctx pc instr c.","conclusion":"tr_instr ctx pc instr c","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"inv_incr.\neapply IHl; eauto.\nintros.\neapply Pos.lt_le_trans.\neapply H2.\nright; eauto.\nextlia.\nintros; eapply Ple_trans; eauto.\nintros.\napply H7; auto.\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : tr_instr ctx pc instr c.","conclusion":"tr_instr ctx pc instr c","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"eapply IHl; eauto.\nintros.\neapply Pos.lt_le_trans.\neapply H2.\nright; eauto.\nextlia.\nintros; eapply Ple_trans; eauto.\nintros.\napply H7; auto.\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : forall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s0).","conclusion":"forall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s0)","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"intros.\neapply Pos.lt_le_trans.\neapply H2.\nright; eauto.\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc2 : node) (instr2 : instruction) (r : reg),\n In (pc2, instr2) l -> instr_defs instr2 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc2 : node) (instr2 : instruction),\n In (pc2, instr2) l -> Plt (spc ctx pc2) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc2 : node) (instr2 : instruction),\n In (pc2, instr2) l -> c0 ! (spc ctx pc2) = (st_code s'0) ! (spc ctx pc2)) ->\nforall (pc2 : node) (instr2 : instruction),\nIn (pc2, instr2) l -> tr_instr ctx pc2 instr2 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc2 : node) (instr2 : instruction) (r : reg),\n(pc1, instr1) = (pc2, instr2) \\/ In (pc2, instr2) l ->\ninstr_defs instr2 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc2 : node) (instr2 : instruction),\n(pc1, instr1) = (pc2, instr2) \\/ In (pc2, instr2) l ->\nPlt (spc ctx pc2) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc2 : node) (instr2 : instruction),\n(pc1, instr1) = (pc2, instr2) \\/ In (pc2, instr2) l ->\nc ! (spc ctx pc2) = (st_code s') ! (spc ctx pc2)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc0 : node) (instr0 : instruction) (H0 : In (pc0, instr0) l) : Plt (spc ctx pc0) (st_nextnode s0).","conclusion":"Plt (spc ctx pc0) (st_nextnode s0)","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc2 : node) (instr2 : instruction) (r : reg),\n In (pc2, instr2) l -> instr_defs instr2 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc2 : node) (instr2 : instruction),\n In (pc2, instr2) l -> Plt (spc ctx pc2) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc2 : node) (instr2 : instruction),\n In (pc2, instr2) l -> c0 ! (spc ctx pc2) = (st_code s'0) ! (spc ctx pc2)) ->\nforall (pc2 : node) (instr2 : instruction),\nIn (pc2, instr2) l -> tr_instr ctx pc2 instr2 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc2 : node) (instr2 : instruction) (r : reg),\n(pc1, instr1) = (pc2, instr2) \\/ In (pc2, instr2) l ->\ninstr_defs instr2 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc2 : node) (instr2 : instruction),\n(pc1, instr1) = (pc2, instr2) \\/ In (pc2, instr2) l ->\nPlt (spc ctx pc2) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc2 : node) (instr2 : instruction),\n(pc1, instr1) = (pc2, instr2) \\/ In (pc2, instr2) l ->\nc ! (spc ctx pc2) = (st_code s') ! (spc ctx pc2)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc0 : node) (instr0 : instruction) (H0 : In (pc0, instr0) l)","proofString":"eapply Pos.lt_le_trans.\neapply H2.\nright; eauto.\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : Ple (dreg ctx + mreg ctx) (st_nextreg s0).","conclusion":"Ple (dreg ctx + mreg ctx) (st_nextreg s0)","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"intros; eapply Ple_trans; eauto."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) : forall pc' : positive,\nPle (st_nextnode s0) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc'.","conclusion":"forall pc' : positive,\nPle (st_nextnode s0) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc'","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (st_nextnode s1) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc' : positive,\nPle (st_nextnode s) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0))","proofString":"intros.\napply H7; auto.\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H0 : Ple (st_nextnode s0) pc') (H9 : Plt pc' (st_nextnode s')) : c ! pc' = (st_code s') ! pc'.","conclusion":"c ! pc' = (st_code s') ! pc'","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H0 : Ple (st_nextnode s0) pc') (H9 : Plt pc' (st_nextnode s'))","proofString":"apply H7; auto.\nextlia."},{"statement":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H0 : Ple (st_nextnode s0) pc') (H9 : Plt pc' (st_nextnode s')) : Ple (st_nextnode s) pc'.","conclusion":"Ple (st_nextnode s) pc'","hypotheses":"(ctx : context) (pc1 : node) (instr1 : instruction) (l : list (node * instruction)) (IHl : forall (s1 : state) (x1 : unit) (s'0 : state) (i : sincr s1 s'0)\n  (c0 : PTree.tree instruction),\nmlist_iter2 (expand_instr fe rec ctx) l s1 = R x1 s'0 i ->\nlist_norepet (map fst l) ->\n(forall (pc0 : node) (instr0 : instruction) (r : reg),\n In (pc0, instr0) l -> instr_defs instr0 = Some r -> Ple r (mreg ctx)) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> Plt (spc ctx pc0) (st_nextnode s1)) ->\nPle (dreg ctx + mreg ctx) (st_nextreg s1) ->\nmstk ctx >= 0 ->\ndstk ctx >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc'0 : positive,\n Ple (st_nextnode s1) pc'0 ->\n Plt pc'0 (st_nextnode s'0) -> c0 ! pc'0 = (st_code s'0) ! pc'0) ->\n(forall (pc0 : node) (instr0 : instruction),\n In (pc0, instr0) l -> c0 ! (spc ctx pc0) = (st_code s'0) ! (spc ctx pc0)) ->\nforall (pc0 : node) (instr0 : instruction),\nIn (pc0, instr0) l -> tr_instr ctx pc0 instr0 c0) (s : state) (x : unit) (s' : state) (NEXTREG1 : Ple (st_nextreg s) (st_nextreg s')) (NEXTNODE1 : Ple (st_nextnode s) (st_nextnode s')) (STKSIZE1 : st_stksize s <= st_stksize s') (c : PTree.tree instruction) (H1 : forall (pc0 : node) (instr0 : instruction) (r : reg),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\ninstr_defs instr0 = Some r -> Ple r (mreg ctx)) (H2 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nPlt (spc ctx pc0) (st_nextnode s)) (H3 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H4 : mstk ctx >= 0) (H5 : dstk ctx >= 0) (H6 : st_stksize s' <= stacksize) (H7 : forall pc'0 : positive,\nPle (st_nextnode s) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (H8 : forall (pc0 : node) (instr0 : instruction),\n(pc1, instr1) = (pc0, instr0) \\/ In (pc0, instr0) l ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)) (pc : node) (instr : instruction) (H : In (pc, instr) l) (H12 : ~ In pc1 (map fst l)) (H13 : list_norepet (map fst l)) (x0 : unit) (s0 : state) (NEXTREG0 : Ple (st_nextreg s) (st_nextreg s0)) (NEXTNODE0 : Ple (st_nextnode s) (st_nextnode s0)) (STKSIZE0 : st_stksize s <= st_stksize s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') (EQ : expand_instr fe rec ctx pc1 instr1 s =\nR x0 s0 (Sincr s s0 NEXTREG0 NEXTNODE0 STKSIZE0)) (EQ0 : mlist_iter2 (expand_instr fe rec ctx) l s0 =\nR x s' (Sincr s0 s' NEXTREG NEXTNODE STKSIZE)) (A : Ple (dpc ctx) (st_nextnode s0)) (pc' : positive) (H0 : Ple (st_nextnode s0) pc') (H9 : Plt pc' (st_nextnode s'))","proofString":"extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : expand_cfg_rec fe rec ctx f s = R x s' i) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') : tr_funbody ctx f c.","conclusion":"tr_funbody ctx f c","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : expand_cfg_rec fe rec ctx f s = R x s' i) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc')","proofString":"unfold expand_cfg_rec in H.\nmonadInv H.\ninversion EQ.\nconstructor.\nintros.\nrewrite H1.\neapply max_reg_function_params; eauto.\nintros.\nexploit ptree_mfold_spec; eauto.\nintros [INCR' ITER].\neapply iter_expand_instr_spec; eauto.\napply PTree.elements_keys_norepet.\nintros.\nrewrite H1.\neapply max_reg_function_def with (i := instr); eauto.\neapply PTree.elements_complete; eauto.\nintros.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\nsubst s0; simpl; extlia.\nsubst s0; simpl; auto.\nintros.\napply H8; auto.\nsubst s0; simpl in H11; extlia.\nintros.\napply H8.\napply shiftpos_above.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\ninversion i; extlia.\napply PTree.elements_correct; auto.\nauto.\nauto.\nauto.\ninversion INCR0.\nsubst s0; simpl in STKSIZE; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : (do _ <- request_stack (dstk ctx + mstk ctx);\n ptree_mfold (expand_instr fe rec ctx) (fn_code f)) s = \nR x s' i) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') : tr_funbody ctx f c.","conclusion":"tr_funbody ctx f c","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H : (do _ <- request_stack (dstk ctx + mstk ctx);\n ptree_mfold (expand_instr fe rec ctx) (fn_code f)) s = \nR x s' i) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc')","proofString":"monadInv H.\ninversion EQ.\nconstructor.\nintros.\nrewrite H1.\neapply max_reg_function_params; eauto.\nintros.\nexploit ptree_mfold_spec; eauto.\nintros [INCR' ITER].\neapply iter_expand_instr_spec; eauto.\napply PTree.elements_keys_norepet.\nintros.\nrewrite H1.\neapply max_reg_function_def with (i := instr); eauto.\neapply PTree.elements_complete; eauto.\nintros.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\nsubst s0; simpl; extlia.\nsubst s0; simpl; auto.\nintros.\napply H8; auto.\nsubst s0; simpl in H11; extlia.\nintros.\napply H8.\napply shiftpos_above.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\ninversion i; extlia.\napply PTree.elements_correct; auto.\nauto.\nauto.\nauto.\ninversion INCR0.\nsubst s0; simpl in STKSIZE; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) : tr_funbody ctx f c.","conclusion":"tr_funbody ctx f c","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0)","proofString":"inversion EQ.\nconstructor.\nintros.\nrewrite H1.\neapply max_reg_function_params; eauto.\nintros.\nexploit ptree_mfold_spec; eauto.\nintros [INCR' ITER].\neapply iter_expand_instr_spec; eauto.\napply PTree.elements_keys_norepet.\nintros.\nrewrite H1.\neapply max_reg_function_def with (i := instr); eauto.\neapply PTree.elements_complete; eauto.\nintros.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\nsubst s0; simpl; extlia.\nsubst s0; simpl; auto.\nintros.\napply H8; auto.\nsubst s0; simpl in H11; extlia.\nintros.\napply H8.\napply shiftpos_above.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\ninversion i; extlia.\napply PTree.elements_correct; auto.\nauto.\nauto.\nauto.\ninversion INCR0.\nsubst s0; simpl in STKSIZE; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) : tr_funbody ctx f c.","conclusion":"tr_funbody ctx f c","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0)","proofString":"constructor.\nintros.\nrewrite H1.\neapply max_reg_function_params; eauto.\nintros.\nexploit ptree_mfold_spec; eauto.\nintros [INCR' ITER].\neapply iter_expand_instr_spec; eauto.\napply PTree.elements_keys_norepet.\nintros.\nrewrite H1.\neapply max_reg_function_def with (i := instr); eauto.\neapply PTree.elements_complete; eauto.\nintros.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\nsubst s0; simpl; extlia.\nsubst s0; simpl; auto.\nintros.\napply H8; auto.\nsubst s0; simpl in H11; extlia.\nintros.\napply H8.\napply shiftpos_above.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\ninversion i; extlia.\napply PTree.elements_correct; auto.\nauto.\nauto.\nauto.\ninversion INCR0.\nsubst s0; simpl in STKSIZE; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) : forall r : reg, In r (fn_params f) -> Ple r (mreg ctx).","conclusion":"forall r : reg, In r (fn_params f) -> Ple r (mreg ctx)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0)","proofString":"intros.\nrewrite H1.\neapply max_reg_function_params; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (r : reg) (H : In r (fn_params f)) : Ple r (mreg ctx).","conclusion":"Ple r (mreg ctx)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (r : reg) (H : In r (fn_params f))","proofString":"rewrite H1.\neapply max_reg_function_params; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (r : reg) (H : In r (fn_params f)) : Ple r (max_reg_function f).","conclusion":"Ple r (max_reg_function f)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (r : reg) (H : In r (fn_params f))","proofString":"eapply max_reg_function_params; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) : forall (pc : positive) (i0 : instruction),\n(fn_code f) ! pc = Some i0 -> tr_instr ctx pc i0 c.","conclusion":"forall (pc : positive) (i0 : instruction),\n(fn_code f) ! pc = Some i0 -> tr_instr ctx pc i0 c","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0)","proofString":"intros.\nexploit ptree_mfold_spec; eauto.\nintros [INCR' ITER].\neapply iter_expand_instr_spec; eauto.\napply PTree.elements_keys_norepet.\nintros.\nrewrite H1.\neapply max_reg_function_def with (i := instr); eauto.\neapply PTree.elements_complete; eauto.\nintros.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\nsubst s0; simpl; extlia.\nsubst s0; simpl; auto.\nintros.\napply H8; auto.\nsubst s0; simpl in H11; extlia.\nintros.\napply H8.\napply shiftpos_above.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\ninversion i; extlia.\napply PTree.elements_correct; auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) : tr_instr ctx pc i0 c.","conclusion":"tr_instr ctx pc i0 c","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0)","proofString":"exploit ptree_mfold_spec; eauto.\nintros [INCR' ITER].\neapply iter_expand_instr_spec; eauto.\napply PTree.elements_keys_norepet.\nintros.\nrewrite H1.\neapply max_reg_function_def with (i := instr); eauto.\neapply PTree.elements_complete; eauto.\nintros.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\nsubst s0; simpl; extlia.\nsubst s0; simpl; auto.\nintros.\napply H8; auto.\nsubst s0; simpl in H11; extlia.\nintros.\napply H8.\napply shiftpos_above.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\ninversion i; extlia.\napply PTree.elements_correct; auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) : (exists i' : sincr s0 s',\n   mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\n   R tt s' i') -> tr_instr ctx pc i0 c.","conclusion":"(exists i' : sincr s0 s',\n   mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\n   R tt s' i') -> tr_instr ctx pc i0 c","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0)","proofString":"intros [INCR' ITER].\neapply iter_expand_instr_spec; eauto.\napply PTree.elements_keys_norepet.\nintros.\nrewrite H1.\neapply max_reg_function_def with (i := instr); eauto.\neapply PTree.elements_complete; eauto.\nintros.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\nsubst s0; simpl; extlia.\nsubst s0; simpl; auto.\nintros.\napply H8; auto.\nsubst s0; simpl in H11; extlia.\nintros.\napply H8.\napply shiftpos_above.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\ninversion i; extlia.\napply PTree.elements_correct; auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') : tr_instr ctx pc i0 c.","conclusion":"tr_instr ctx pc i0 c","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR')","proofString":"eapply iter_expand_instr_spec; eauto.\napply PTree.elements_keys_norepet.\nintros.\nrewrite H1.\neapply max_reg_function_def with (i := instr); eauto.\neapply PTree.elements_complete; eauto.\nintros.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\nsubst s0; simpl; extlia.\nsubst s0; simpl; auto.\nintros.\napply H8; auto.\nsubst s0; simpl in H11; extlia.\nintros.\napply H8.\napply shiftpos_above.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\ninversion i; extlia.\napply PTree.elements_correct; auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') : list_norepet (map fst (PTree.elements (fn_code f))).","conclusion":"list_norepet (map fst (PTree.elements (fn_code f)))","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR')","proofString":"apply PTree.elements_keys_norepet."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') : forall (pc0 : node) (instr : instruction) (r : reg),\nIn (pc0, instr) (PTree.elements (fn_code f)) ->\ninstr_defs instr = Some r -> Ple r (mreg ctx).","conclusion":"forall (pc0 : node) (instr : instruction) (r : reg),\nIn (pc0, instr) (PTree.elements (fn_code f)) ->\ninstr_defs instr = Some r -> Ple r (mreg ctx)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR')","proofString":"intros.\nrewrite H1.\neapply max_reg_function_def with (i := instr); eauto.\neapply PTree.elements_complete; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (r : reg) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) (H12 : instr_defs instr = Some r) : Ple r (mreg ctx).","conclusion":"Ple r (mreg ctx)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (r : reg) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) (H12 : instr_defs instr = Some r)","proofString":"rewrite H1.\neapply max_reg_function_def with (i := instr); eauto.\neapply PTree.elements_complete; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (r : reg) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) (H12 : instr_defs instr = Some r) : Ple r (max_reg_function f).","conclusion":"Ple r (max_reg_function f)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (r : reg) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) (H12 : instr_defs instr = Some r)","proofString":"eapply max_reg_function_def with (i := instr); eauto.\neapply PTree.elements_complete; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') : forall (pc0 : node) (instr : instruction),\nIn (pc0, instr) (PTree.elements (fn_code f)) ->\nPlt (spc ctx pc0) (st_nextnode s0).","conclusion":"forall (pc0 : node) (instr : instruction),\nIn (pc0, instr) (PTree.elements (fn_code f)) ->\nPlt (spc ctx pc0) (st_nextnode s0)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR')","proofString":"intros.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\nsubst s0; simpl; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) : Plt (spc ctx pc0) (st_nextnode s0).","conclusion":"Plt (spc ctx pc0) (st_nextnode s0)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f)))","proofString":"assert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\nsubst s0; simpl; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) : Ple pc0 (max_pc_function f).","conclusion":"Ple pc0 (max_pc_function f)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f)))","proofString":"eapply max_pc_function_sound.\neapply PTree.elements_complete; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) (H12 : Ple pc0 (max_pc_function f)) : Plt (spc ctx pc0) (st_nextnode s0).","conclusion":"Plt (spc ctx pc0) (st_nextnode s0)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) (H12 : Ple pc0 (max_pc_function f))","proofString":"eapply Pos.lt_le_trans.\napply shiftpos_below.\nsubst s0; simpl; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') : Ple (dreg ctx + mreg ctx) (st_nextreg s0).","conclusion":"Ple (dreg ctx + mreg ctx) (st_nextreg s0)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR')","proofString":"subst s0; simpl; auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') : forall pc' : positive,\nPle (st_nextnode s0) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc'.","conclusion":"forall pc' : positive,\nPle (st_nextnode s0) pc' ->\nPlt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc'","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR')","proofString":"intros.\napply H8; auto.\nsubst s0; simpl in H11; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc'0 : positive,\nPle (dpc ctx) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc' : positive) (H11 : Ple (st_nextnode s0) pc') (H12 : Plt pc' (st_nextnode s')) : c ! pc' = (st_code s') ! pc'.","conclusion":"c ! pc' = (st_code s') ! pc'","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc'0 : positive,\nPle (dpc ctx) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc' : positive) (H11 : Ple (st_nextnode s0) pc') (H12 : Plt pc' (st_nextnode s'))","proofString":"apply H8; auto.\nsubst s0; simpl in H11; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc'0 : positive,\nPle (dpc ctx) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc' : positive) (H11 : Ple (st_nextnode s0) pc') (H12 : Plt pc' (st_nextnode s')) : Ple (dpc ctx) pc'.","conclusion":"Ple (dpc ctx) pc'","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc'0 : positive,\nPle (dpc ctx) pc'0 ->\nPlt pc'0 (st_nextnode s') -> c ! pc'0 = (st_code s') ! pc'0) (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc' : positive) (H11 : Ple (st_nextnode s0) pc') (H12 : Plt pc' (st_nextnode s'))","proofString":"subst s0; simpl in H11; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') : forall (pc0 : node) (instr : instruction),\nIn (pc0, instr) (PTree.elements (fn_code f)) ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0).","conclusion":"forall (pc0 : node) (instr : instruction),\nIn (pc0, instr) (PTree.elements (fn_code f)) ->\nc ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR')","proofString":"intros.\napply H8.\napply shiftpos_above.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\ninversion i; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) : c ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0).","conclusion":"c ! (spc ctx pc0) = (st_code s') ! (spc ctx pc0)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f)))","proofString":"apply H8.\napply shiftpos_above.\nassert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\ninversion i; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) : Ple (dpc ctx) (spc ctx pc0).","conclusion":"Ple (dpc ctx) (spc ctx pc0)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f)))","proofString":"apply shiftpos_above."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) : Plt (spc ctx pc0) (st_nextnode s').","conclusion":"Plt (spc ctx pc0) (st_nextnode s')","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f)))","proofString":"assert (Ple pc0 (max_pc_function f)).\neapply max_pc_function_sound.\neapply PTree.elements_complete; eauto.\neapply Pos.lt_le_trans.\napply shiftpos_below.\ninversion i; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) : Ple pc0 (max_pc_function f).","conclusion":"Ple pc0 (max_pc_function f)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f)))","proofString":"eapply max_pc_function_sound.\neapply PTree.elements_complete; eauto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) (H12 : Ple pc0 (max_pc_function f)) : Plt (spc ctx pc0) (st_nextnode s').","conclusion":"Plt (spc ctx pc0) (st_nextnode s')","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') (pc0 : node) (instr : instruction) (H11 : In (pc0, instr) (PTree.elements (fn_code f))) (H12 : Ple pc0 (max_pc_function f))","proofString":"eapply Pos.lt_le_trans.\napply shiftpos_below.\ninversion i; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR') : In (pc, i0) (PTree.elements (fn_code f)).","conclusion":"In (pc, i0) (PTree.elements (fn_code f))","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (pc : positive) (i0 : instruction) (H : (fn_code f) ! pc = Some i0) (INCR' : sincr s0 s') (ITER : mlist_iter2 (expand_instr fe rec ctx) (PTree.elements (fn_code f)) s0 =\nR tt s' INCR')","proofString":"apply PTree.elements_correct; auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) : mstk ctx = Z.max (fn_stacksize f) 0.","conclusion":"mstk ctx = Z.max (fn_stacksize f) 0","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0)","proofString":"auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) : (min_alignment (fn_stacksize f) | dstk ctx).","conclusion":"(min_alignment (fn_stacksize f) | dstk ctx)","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0)","proofString":"auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) : dstk ctx >= 0.","conclusion":"dstk ctx >= 0","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0)","proofString":"auto."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) : dstk ctx + mstk ctx <= stacksize.","conclusion":"dstk ctx + mstk ctx <= stacksize","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0)","proofString":"inversion INCR0.\nsubst s0; simpl in STKSIZE; extlia."},{"statement":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s') : dstk ctx + mstk ctx <= stacksize.","conclusion":"dstk ctx + mstk ctx <= stacksize","hypotheses":"(ctx : context) (f : function) (s : state) (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H1 : mreg ctx = max_reg_function f) (H2 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H3 : mstk ctx >= 0) (H4 : mstk ctx = Z.max (fn_stacksize f) 0) (H5 : (min_alignment (fn_stacksize f) | dstk ctx)) (H6 : dstk ctx >= 0) (H7 : st_stksize s' <= stacksize) (H8 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (x0 : unit) (s0 : state) (INCR : sincr s s0) (INCR0 : sincr s0 s') (EQ : request_stack (dstk ctx + mstk ctx) s = R x0 s0 INCR) (EQ0 : ptree_mfold (expand_instr fe rec ctx) (fn_code f) s0 = R x s' INCR0) (H9 : tt = x0) (H10 : {|\n  st_nextreg := st_nextreg s;\n  st_nextnode := st_nextnode s;\n  st_code := st_code s;\n  st_stksize := Z.max (st_stksize s) (dstk ctx + mstk ctx)\n|} = s0) (NEXTREG : Ple (st_nextreg s0) (st_nextreg s')) (NEXTNODE : Ple (st_nextnode s0) (st_nextnode s')) (STKSIZE : st_stksize s0 <= st_stksize s')","proofString":"subst s0; simpl in STKSIZE; extlia."},{"statement":"(fe0 : funenv) : (fun f : funenv =>\n forall (ctx : context) (f0 : function) (s : state) \n   (x : unit) (s' : state) (i : sincr s s') (pc : positive),\n expand_cfg f ctx f0 s = R x s' i ->\n Ple (dpc ctx) (st_nextnode s) ->\n Plt pc (dpc ctx) -> (st_code s') ! pc = (st_code s) ! pc) fe0.","conclusion":"(fun f : funenv =>\n forall (ctx : context) (f0 : function) (s : state) \n   (x : unit) (s' : state) (i : sincr s s') (pc : positive),\n expand_cfg f ctx f0 s = R x s' i ->\n Ple (dpc ctx) (st_nextnode s) ->\n Plt pc (dpc ctx) -> (st_code s') ! pc = (st_code s) ! pc) fe0","hypotheses":"(fe0 : funenv)","proofString":"apply well_founded_ind with (R := ltof _ size_fenv).\napply well_founded_ltof.\nintros.\nunfold expand_cfg in H0.\nrewrite unroll_Fixm in H0.\neapply expand_cfg_rec_unchanged; eauto.\nassumption."},{"statement":"(fe0 : funenv) : well_founded (ltof funenv size_fenv).","conclusion":"well_founded (ltof funenv size_fenv)","hypotheses":"(fe0 : funenv)","proofString":"apply well_founded_ltof."},{"statement":"(fe0 : funenv) : forall x : funenv,\n(forall y : funenv,\n ltof funenv size_fenv y x ->\n forall (ctx : context) (f : function) (s : state) \n   (x0 : unit) (s' : state) (i : sincr s s') (pc : positive),\n expand_cfg y ctx f s = R x0 s' i ->\n Ple (dpc ctx) (st_nextnode s) ->\n Plt pc (dpc ctx) -> (st_code s') ! pc = (st_code s) ! pc) ->\nforall (ctx : context) (f : function) (s : state) \n  (x0 : unit) (s' : state) (i : sincr s s') (pc : positive),\nexpand_cfg x ctx f s = R x0 s' i ->\nPle (dpc ctx) (st_nextnode s) ->\nPlt pc (dpc ctx) -> (st_code s') ! pc = (st_code s) ! pc.","conclusion":"forall x : funenv,\n(forall y : funenv,\n ltof funenv size_fenv y x ->\n forall (ctx : context) (f : function) (s : state) \n   (x0 : unit) (s' : state) (i : sincr s s') (pc : positive),\n expand_cfg y ctx f s = R x0 s' i ->\n Ple (dpc ctx) (st_nextnode s) ->\n Plt pc (dpc ctx) -> (st_code s') ! pc = (st_code s) ! pc) ->\nforall (ctx : context) (f : function) (s : state) \n  (x0 : unit) (s' : state) (i : sincr s s') (pc : positive),\nexpand_cfg x ctx f s = R x0 s' i ->\nPle (dpc ctx) (st_nextnode s) ->\nPlt pc (dpc ctx) -> (st_code s') ! pc = (st_code s) ! pc","hypotheses":"(fe0 : funenv)","proofString":"intros.\nunfold expand_cfg in H0.\nrewrite unroll_Fixm in H0.\neapply expand_cfg_rec_unchanged; eauto.\nassumption."},{"statement":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc0 : positive),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc0 (dpc ctx0) -> (st_code s'0) ! pc0 = (st_code s0) ! pc0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : expand_cfg x ctx f s = R x0 s' i) (H1 : Ple (dpc ctx) (st_nextnode s)) (H2 : Plt pc (dpc ctx)) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc0 : positive),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc0 (dpc ctx0) -> (st_code s'0) ! pc0 = (st_code s0) ! pc0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : expand_cfg x ctx f s = R x0 s' i) (H1 : Ple (dpc ctx) (st_nextnode s)) (H2 : Plt pc (dpc ctx))","proofString":"unfold expand_cfg in H0.\nrewrite unroll_Fixm in H0.\neapply expand_cfg_rec_unchanged; eauto.\nassumption."},{"statement":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc0 : positive),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc0 (dpc ctx0) -> (st_code s'0) ! pc0 = (st_code s0) ! pc0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Fixm size_fenv expand_cfg_rec x ctx f s = R x0 s' i) (H1 : Ple (dpc ctx) (st_nextnode s)) (H2 : Plt pc (dpc ctx)) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc0 : positive),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc0 (dpc ctx0) -> (st_code s'0) ! pc0 = (st_code s0) ! pc0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : Fixm size_fenv expand_cfg_rec x ctx f s = R x0 s' i) (H1 : Ple (dpc ctx) (st_nextnode s)) (H2 : Plt pc (dpc ctx))","proofString":"rewrite unroll_Fixm in H0.\neapply expand_cfg_rec_unchanged; eauto.\nassumption."},{"statement":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc0 : positive),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc0 (dpc ctx0) -> (st_code s'0) ! pc0 = (st_code s0) ! pc0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : Ple (dpc ctx) (st_nextnode s)) (H2 : Plt pc (dpc ctx)) : (st_code s') ! pc = (st_code s) ! pc.","conclusion":"(st_code s') ! pc = (st_code s) ! pc","hypotheses":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc0 : positive),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc0 (dpc ctx0) -> (st_code s'0) ! pc0 = (st_code s0) ! pc0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : Ple (dpc ctx) (st_nextnode s)) (H2 : Plt pc (dpc ctx))","proofString":"eapply expand_cfg_rec_unchanged; eauto.\nassumption."},{"statement":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc0 : positive),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc0 (dpc ctx0) -> (st_code s'0) ! pc0 = (st_code s0) ! pc0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : Ple (dpc ctx) (st_nextnode s)) (H2 : Plt pc (dpc ctx)) : forall (fe' : funenv) (L : (size_fenv fe' < size_fenv x)%nat)\n  (ctx0 : context) (f0 : function) (s0 : state) (x1 : unit) \n  (s'0 : state) (i0 : sincr s0 s'0) (pc0 : positive),\n(fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n Fixm size_fenv expand_cfg_rec y) fe' L ctx0 f0 s0 = \nR x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc0 (dpc ctx0) -> (st_code s'0) ! pc0 = (st_code s0) ! pc0.","conclusion":"forall (fe' : funenv) (L : (size_fenv fe' < size_fenv x)%nat)\n  (ctx0 : context) (f0 : function) (s0 : state) (x1 : unit) \n  (s'0 : state) (i0 : sincr s0 s'0) (pc0 : positive),\n(fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n Fixm size_fenv expand_cfg_rec y) fe' L ctx0 f0 s0 = \nR x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc0 (dpc ctx0) -> (st_code s'0) ! pc0 = (st_code s0) ! pc0","hypotheses":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc0 : positive),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc0 (dpc ctx0) -> (st_code s'0) ! pc0 = (st_code s0) ! pc0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (pc : positive) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : Ple (dpc ctx) (st_nextnode s)) (H2 : Plt pc (dpc ctx))","proofString":"assumption."},{"statement":"(fe0 : funenv) : (fun f : funenv =>\n forall (ctx : context) (f0 : function) (s : state) \n   (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction),\n expand_cfg f ctx f0 s = R x s' i ->\n fenv_agree f ->\n Ple (dpc ctx + max_pc_function f0) (st_nextnode s) ->\n mreg ctx = max_reg_function f0 ->\n Ple (dreg ctx + mreg ctx) (st_nextreg s) ->\n mstk ctx >= 0 ->\n mstk ctx = Z.max (fn_stacksize f0) 0 ->\n (min_alignment (fn_stacksize f0) | dstk ctx) ->\n dstk ctx >= 0 ->\n st_stksize s' <= stacksize ->\n (forall pc' : positive,\n  Ple (dpc ctx) pc' ->\n  Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') ->\n tr_funbody ctx f0 c) fe0.","conclusion":"(fun f : funenv =>\n forall (ctx : context) (f0 : function) (s : state) \n   (x : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction),\n expand_cfg f ctx f0 s = R x s' i ->\n fenv_agree f ->\n Ple (dpc ctx + max_pc_function f0) (st_nextnode s) ->\n mreg ctx = max_reg_function f0 ->\n Ple (dreg ctx + mreg ctx) (st_nextreg s) ->\n mstk ctx >= 0 ->\n mstk ctx = Z.max (fn_stacksize f0) 0 ->\n (min_alignment (fn_stacksize f0) | dstk ctx) ->\n dstk ctx >= 0 ->\n st_stksize s' <= stacksize ->\n (forall pc' : positive,\n  Ple (dpc ctx) pc' ->\n  Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') ->\n tr_funbody ctx f0 c) fe0","hypotheses":"(fe0 : funenv)","proofString":"apply well_founded_ind with (R := ltof _ size_fenv).\napply well_founded_ltof.\nintros.\nunfold expand_cfg in H0.\nrewrite unroll_Fixm in H0.\neapply expand_cfg_rec_spec; eauto.\nsimpl.\nintros.\neapply expand_cfg_unchanged; eauto.\nassumption."},{"statement":"(fe0 : funenv) : well_founded (ltof funenv size_fenv).","conclusion":"well_founded (ltof funenv size_fenv)","hypotheses":"(fe0 : funenv)","proofString":"apply well_founded_ltof."},{"statement":"(fe0 : funenv) : forall x : funenv,\n(forall y : funenv,\n ltof funenv size_fenv y x ->\n forall (ctx : context) (f : function) (s : state) \n   (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction),\n expand_cfg y ctx f s = R x0 s' i ->\n fenv_agree y ->\n Ple (dpc ctx + max_pc_function f) (st_nextnode s) ->\n mreg ctx = max_reg_function f ->\n Ple (dreg ctx + mreg ctx) (st_nextreg s) ->\n mstk ctx >= 0 ->\n mstk ctx = Z.max (fn_stacksize f) 0 ->\n (min_alignment (fn_stacksize f) | dstk ctx) ->\n dstk ctx >= 0 ->\n st_stksize s' <= stacksize ->\n (forall pc' : positive,\n  Ple (dpc ctx) pc' ->\n  Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') ->\n tr_funbody ctx f c) ->\nforall (ctx : context) (f : function) (s : state) \n  (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction),\nexpand_cfg x ctx f s = R x0 s' i ->\nfenv_agree x ->\nPle (dpc ctx + max_pc_function f) (st_nextnode s) ->\nmreg ctx = max_reg_function f ->\nPle (dreg ctx + mreg ctx) (st_nextreg s) ->\nmstk ctx >= 0 ->\nmstk ctx = Z.max (fn_stacksize f) 0 ->\n(min_alignment (fn_stacksize f) | dstk ctx) ->\ndstk ctx >= 0 ->\nst_stksize s' <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx) pc' ->\n Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') ->\ntr_funbody ctx f c.","conclusion":"forall x : funenv,\n(forall y : funenv,\n ltof funenv size_fenv y x ->\n forall (ctx : context) (f : function) (s : state) \n   (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction),\n expand_cfg y ctx f s = R x0 s' i ->\n fenv_agree y ->\n Ple (dpc ctx + max_pc_function f) (st_nextnode s) ->\n mreg ctx = max_reg_function f ->\n Ple (dreg ctx + mreg ctx) (st_nextreg s) ->\n mstk ctx >= 0 ->\n mstk ctx = Z.max (fn_stacksize f) 0 ->\n (min_alignment (fn_stacksize f) | dstk ctx) ->\n dstk ctx >= 0 ->\n st_stksize s' <= stacksize ->\n (forall pc' : positive,\n  Ple (dpc ctx) pc' ->\n  Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') ->\n tr_funbody ctx f c) ->\nforall (ctx : context) (f : function) (s : state) \n  (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction),\nexpand_cfg x ctx f s = R x0 s' i ->\nfenv_agree x ->\nPle (dpc ctx + max_pc_function f) (st_nextnode s) ->\nmreg ctx = max_reg_function f ->\nPle (dreg ctx + mreg ctx) (st_nextreg s) ->\nmstk ctx >= 0 ->\nmstk ctx = Z.max (fn_stacksize f) 0 ->\n(min_alignment (fn_stacksize f) | dstk ctx) ->\ndstk ctx >= 0 ->\nst_stksize s' <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx) pc' ->\n Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') ->\ntr_funbody ctx f c","hypotheses":"(fe0 : funenv)","proofString":"intros.\nunfold expand_cfg in H0.\nrewrite unroll_Fixm in H0.\neapply expand_cfg_rec_spec; eauto.\nsimpl.\nintros.\neapply expand_cfg_unchanged; eauto.\nassumption."},{"statement":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nfenv_agree y ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\ntr_funbody ctx0 f0 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : expand_cfg x ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') : tr_funbody ctx f c.","conclusion":"tr_funbody ctx f c","hypotheses":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nfenv_agree y ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\ntr_funbody ctx0 f0 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : expand_cfg x ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc')","proofString":"unfold expand_cfg in H0.\nrewrite unroll_Fixm in H0.\neapply expand_cfg_rec_spec; eauto.\nsimpl.\nintros.\neapply expand_cfg_unchanged; eauto.\nassumption."},{"statement":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nfenv_agree y ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\ntr_funbody ctx0 f0 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Fixm size_fenv expand_cfg_rec x ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') : tr_funbody ctx f c.","conclusion":"tr_funbody ctx f c","hypotheses":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nfenv_agree y ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\ntr_funbody ctx0 f0 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : Fixm size_fenv expand_cfg_rec x ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc')","proofString":"rewrite unroll_Fixm in H0.\neapply expand_cfg_rec_spec; eauto.\nsimpl.\nintros.\neapply expand_cfg_unchanged; eauto.\nassumption."},{"statement":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nfenv_agree y ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\ntr_funbody ctx0 f0 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') : tr_funbody ctx f c.","conclusion":"tr_funbody ctx f c","hypotheses":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nfenv_agree y ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\ntr_funbody ctx0 f0 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc')","proofString":"eapply expand_cfg_rec_spec; eauto.\nsimpl.\nintros.\neapply expand_cfg_unchanged; eauto.\nassumption."},{"statement":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nfenv_agree y ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\ntr_funbody ctx0 f0 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') : forall (fe' : funenv) (L : (size_fenv fe' < size_fenv x)%nat)\n  (ctx0 : context) (f0 : function) (s0 : state) (x1 : unit) \n  (s'0 : state) (i0 : sincr s0 s'0) (pc : positive),\n(fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n Fixm size_fenv expand_cfg_rec y) fe' L ctx0 f0 s0 = \nR x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc (dpc ctx0) -> (st_code s'0) ! pc = (st_code s0) ! pc.","conclusion":"forall (fe' : funenv) (L : (size_fenv fe' < size_fenv x)%nat)\n  (ctx0 : context) (f0 : function) (s0 : state) (x1 : unit) \n  (s'0 : state) (i0 : sincr s0 s'0) (pc : positive),\n(fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n Fixm size_fenv expand_cfg_rec y) fe' L ctx0 f0 s0 = \nR x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc (dpc ctx0) -> (st_code s'0) ! pc = (st_code s0) ! pc","hypotheses":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nfenv_agree y ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\ntr_funbody ctx0 f0 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc')","proofString":"simpl.\nintros.\neapply expand_cfg_unchanged; eauto."},{"statement":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nfenv_agree y ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\ntr_funbody ctx0 f0 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') : forall fe' : funenv,\n(size_fenv fe' < size_fenv x)%nat ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc : positive),\nFixm size_fenv expand_cfg_rec fe' ctx0 f0 s0 = R x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc (dpc ctx0) -> (st_code s'0) ! pc = (st_code s0) ! pc.","conclusion":"forall fe' : funenv,\n(size_fenv fe' < size_fenv x)%nat ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc : positive),\nFixm size_fenv expand_cfg_rec fe' ctx0 f0 s0 = R x1 s'0 i0 ->\nPle (dpc ctx0) (st_nextnode s0) ->\nPlt pc (dpc ctx0) -> (st_code s'0) ! pc = (st_code s0) ! pc","hypotheses":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nfenv_agree y ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\ntr_funbody ctx0 f0 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc')","proofString":"intros.\neapply expand_cfg_unchanged; eauto."},{"statement":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx1 : context) (f1 : function) (s1 : state) \n  (x2 : unit) (s'1 : state) (i1 : sincr s1 s'1) (c0 : PTree.tree instruction),\nexpand_cfg y ctx1 f1 s1 = R x2 s'1 i1 ->\nfenv_agree y ->\nPle (dpc ctx1 + max_pc_function f1) (st_nextnode s1) ->\nmreg ctx1 = max_reg_function f1 ->\nPle (dreg ctx1 + mreg ctx1) (st_nextreg s1) ->\nmstk ctx1 >= 0 ->\nmstk ctx1 = Z.max (fn_stacksize f1) 0 ->\n(min_alignment (fn_stacksize f1) | dstk ctx1) ->\ndstk ctx1 >= 0 ->\nst_stksize s'1 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx1) pc' ->\n Plt pc' (st_nextnode s'1) -> c0 ! pc' = (st_code s'1) ! pc') ->\ntr_funbody ctx1 f1 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (fe' : funenv) (L : (size_fenv fe' < size_fenv x)%nat) (ctx0 : context) (f0 : function) (s0 : state) (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc : positive) (H11 : Fixm size_fenv expand_cfg_rec fe' ctx0 f0 s0 = R x1 s'0 i0) (H12 : Ple (dpc ctx0) (st_nextnode s0)) (H13 : Plt pc (dpc ctx0)) : (st_code s'0) ! pc = (st_code s0) ! pc.","conclusion":"(st_code s'0) ! pc = (st_code s0) ! pc","hypotheses":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx1 : context) (f1 : function) (s1 : state) \n  (x2 : unit) (s'1 : state) (i1 : sincr s1 s'1) (c0 : PTree.tree instruction),\nexpand_cfg y ctx1 f1 s1 = R x2 s'1 i1 ->\nfenv_agree y ->\nPle (dpc ctx1 + max_pc_function f1) (st_nextnode s1) ->\nmreg ctx1 = max_reg_function f1 ->\nPle (dreg ctx1 + mreg ctx1) (st_nextreg s1) ->\nmstk ctx1 >= 0 ->\nmstk ctx1 = Z.max (fn_stacksize f1) 0 ->\n(min_alignment (fn_stacksize f1) | dstk ctx1) ->\ndstk ctx1 >= 0 ->\nst_stksize s'1 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx1) pc' ->\n Plt pc' (st_nextnode s'1) -> c0 ! pc' = (st_code s'1) ! pc') ->\ntr_funbody ctx1 f1 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') (fe' : funenv) (L : (size_fenv fe' < size_fenv x)%nat) (ctx0 : context) (f0 : function) (s0 : state) (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (pc : positive) (H11 : Fixm size_fenv expand_cfg_rec fe' ctx0 f0 s0 = R x1 s'0 i0) (H12 : Ple (dpc ctx0) (st_nextnode s0)) (H13 : Plt pc (dpc ctx0))","proofString":"eapply expand_cfg_unchanged; eauto."},{"statement":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nfenv_agree y ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\ntr_funbody ctx0 f0 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc') : forall (fe' : funenv) (L : (size_fenv fe' < size_fenv x)%nat)\n  (ctx0 : context) (f0 : function) (s0 : state) (x1 : unit) \n  (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\n(fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n Fixm size_fenv expand_cfg_rec y) fe' L ctx0 f0 s0 = \nR x1 s'0 i0 ->\nfenv_agree fe' ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc : positive,\n Ple (dpc ctx0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_funbody ctx0 f0 c0.","conclusion":"forall (fe' : funenv) (L : (size_fenv fe' < size_fenv x)%nat)\n  (ctx0 : context) (f0 : function) (s0 : state) (x1 : unit) \n  (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\n(fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n Fixm size_fenv expand_cfg_rec y) fe' L ctx0 f0 s0 = \nR x1 s'0 i0 ->\nfenv_agree fe' ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc : positive,\n Ple (dpc ctx0) pc ->\n Plt pc (st_nextnode s'0) -> c0 ! pc = (st_code s'0) ! pc) ->\ntr_funbody ctx0 f0 c0","hypotheses":"(fe0 x : funenv) (H : forall y : funenv,\nltof funenv size_fenv y x ->\nforall (ctx0 : context) (f0 : function) (s0 : state) \n  (x1 : unit) (s'0 : state) (i0 : sincr s0 s'0) (c0 : PTree.tree instruction),\nexpand_cfg y ctx0 f0 s0 = R x1 s'0 i0 ->\nfenv_agree y ->\nPle (dpc ctx0 + max_pc_function f0) (st_nextnode s0) ->\nmreg ctx0 = max_reg_function f0 ->\nPle (dreg ctx0 + mreg ctx0) (st_nextreg s0) ->\nmstk ctx0 >= 0 ->\nmstk ctx0 = Z.max (fn_stacksize f0) 0 ->\n(min_alignment (fn_stacksize f0) | dstk ctx0) ->\ndstk ctx0 >= 0 ->\nst_stksize s'0 <= stacksize ->\n(forall pc' : positive,\n Ple (dpc ctx0) pc' ->\n Plt pc' (st_nextnode s'0) -> c0 ! pc' = (st_code s'0) ! pc') ->\ntr_funbody ctx0 f0 c0) (ctx : context) (f : function) (s : state) (x0 : unit) (s' : state) (i : sincr s s') (c : PTree.tree instruction) (H0 : expand_cfg_rec x\n  (fun (y : funenv) (_ : (size_fenv y < size_fenv x)%nat) =>\n   Fixm size_fenv expand_cfg_rec y) ctx f s = R x0 s' i) (H1 : fenv_agree x) (H2 : Ple (dpc ctx + max_pc_function f) (st_nextnode s)) (H3 : mreg ctx = max_reg_function f) (H4 : Ple (dreg ctx + mreg ctx) (st_nextreg s)) (H5 : mstk ctx >= 0) (H6 : mstk ctx = Z.max (fn_stacksize f) 0) (H7 : (min_alignment (fn_stacksize f) | dstk ctx)) (H8 : dstk ctx >= 0) (H9 : st_stksize s' <= stacksize) (H10 : forall pc' : positive,\nPle (dpc ctx) pc' -> Plt pc' (st_nextnode s') -> c ! pc' = (st_code s') ! pc')","proofString":"assumption."},{"statement":"(cunit prog : program) (f f' : function) (H : linkorder cunit prog) (H0 : tr_function cunit f f') : tr_function prog f f'.","conclusion":"tr_function prog f f'","hypotheses":"(cunit prog : program) (f f' : function) (H : linkorder cunit prog) (H0 : tr_function cunit f f')","proofString":"inv H0.\neconstructor; eauto.\neapply fenv_compat_linkorder; eauto."},{"statement":"(cunit prog : program) (f f' : function) (H : linkorder cunit prog) (fenv : funenv) (ctx : context) (H1 : fenv_compat cunit fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) : tr_function prog f f'.","conclusion":"tr_function prog f f'","hypotheses":"(cunit prog : program) (f f' : function) (H : linkorder cunit prog) (fenv : funenv) (ctx : context) (H1 : fenv_compat cunit fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned)","proofString":"econstructor; eauto.\neapply fenv_compat_linkorder; eauto."},{"statement":"(cunit prog : program) (f f' : function) (H : linkorder cunit prog) (fenv : funenv) (ctx : context) (H1 : fenv_compat cunit fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned) : fenv_compat prog fenv.","conclusion":"fenv_compat prog fenv","hypotheses":"(cunit prog : program) (f f' : function) (H : linkorder cunit prog) (fenv : funenv) (ctx : context) (H1 : fenv_compat cunit fenv) (H2 : tr_funbody fenv (fn_stacksize f') ctx f (fn_code f')) (H3 : dstk ctx = 0) (H4 : retinfo ctx = None) (H5 : fn_sig f' = fn_sig f) (H6 : fn_params f' = sregs ctx (fn_params f)) (H7 : fn_entrypoint f' = spc ctx (fn_entrypoint f)) (H8 : 0 <= fn_stacksize f' < Ptrofs.max_unsigned)","proofString":"eapply fenv_compat_linkorder; eauto."}]}