{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/xmm/src/sequentialization/Sequent.v","fileSamples":[{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) : Wf (WCore.init_exec threads).","proofString":"now apply WCore.wf_init_exec."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (x : actid) (DX : is_init x) : ((fun e : actid => tid e = t_2) ∘ id) x = (tid x = t_1).","proofString":"unfold compose.\nunfold is_init in DX.\ndesf.\nunfold tid.\ndesf.\nunfold not in *.\napply PropExtensionality.propositional_extensionality.\nsplit; ins; desf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (x : actid) (DX : is_init x) : (tid (id x) = t_2) = (tid x = t_1).","proofString":"unfold is_init in DX.\ndesf.\nunfold tid.\ndesf.\nunfold not in *.\napply PropExtensionality.propositional_extensionality.\nsplit; ins; desf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (x : actid) (DX : match x with\n| InitEvent _ => true\n| ThreadEvent _ _ => false\nend) : (tid (id x) = t_2) = (tid x = t_1).","proofString":"desf.\nunfold tid.\ndesf.\nunfold not in *.\napply PropExtensionality.propositional_extensionality.\nsplit; ins; desf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (l : location) (DX : true) : (tid (id (InitEvent l)) = t_2) = (tid (InitEvent l) = t_1).","proofString":"unfold tid.\ndesf.\nunfold not in *.\napply PropExtensionality.propositional_extensionality.\nsplit; ins; desf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (l : location) (DX : true) : (match id (InitEvent l) with\n | InitEvent _ => tid_init\n | ThreadEvent i _ => i\n end = t_2) = (tid_init = t_1).","proofString":"desf.\nunfold not in *.\napply PropExtensionality.propositional_extensionality.\nsplit; ins; desf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (l : location) (DX : true) (l0 : location) (Heq : id (InitEvent l) = InitEvent l0) : (tid_init = t_2) = (tid_init = t_1).","proofString":"unfold not in *.\napply PropExtensionality.propositional_extensionality.\nsplit; ins; desf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 = tid_init -> False) (NINIT2 : t_2 = tid_init -> False) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 = t_2 -> False) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (l : location) (DX : true) (l0 : location) (Heq : id (InitEvent l) = InitEvent l0) : (tid_init = t_2) = (tid_init = t_1).","proofString":"apply PropExtensionality.propositional_extensionality.\nsplit; ins; desf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 = tid_init -> False) (NINIT2 : t_2 = tid_init -> False) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 = t_2 -> False) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (l : location) (DX : true) (l0 : location) (Heq : id (InitEvent l) = InitEvent l0) : tid_init = t_2 <-> tid_init = t_1.","proofString":"split; ins; desf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) : (fun a : actid => is_init a) ⊆₁ id ↑₁ (fun a : actid => is_init a) /\\\nid ↑₁ (fun a : actid => is_init a) ⊆₁ (fun a : actid => is_init a).","proofString":"clear; basic_solver."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) : sb (WCore.init_exec threads)\n∪ po_seq {| WCore.G := WCore.init_exec threads; WCore.sc := ∅₂ |} t_1 t_2\n⊆ id ↑ sb (WCore.init_exec threads) /\\\nid ↑ sb (WCore.init_exec threads)\n⊆ sb (WCore.init_exec threads)\n  ∪ po_seq {| WCore.G := WCore.init_exec threads; WCore.sc := ∅₂ |} t_1 t_2.","proofString":"unfold po_seq; ins.\nassert (EMP1 : (fun e : actid => tid e = t_1)                    ∩₁ (fun a : actid => is_init a) ≡₁ ∅).\nsplit; [|basic_solver].\nintros x COND.\ndestruct COND as [TID ISINIT].\nunfold is_init in ISINIT.\ndesf.\nassert (EMP2 : (fun e : actid => tid e = t_2)                    ∩₁ (fun a : actid => is_init a) ≡₁ ∅).\nsplit; [|basic_solver].\nintros x COND.\ndestruct COND as [TID ISINIT].\nunfold is_init in ISINIT.\ndesf.\nrewrite EMP1, EMP2.\nclear; basic_solver 8."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) : sb (WCore.init_exec threads)\n∪ ((fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a))\n  × ((fun e : actid => tid e = t_2) ∩₁ (fun a : actid => is_init a))\n⊆ id ↑ sb (WCore.init_exec threads) /\\\nid ↑ sb (WCore.init_exec threads)\n⊆ sb (WCore.init_exec threads)\n  ∪ ((fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a))\n    × ((fun e : actid => tid e = t_2) ∩₁ (fun a : actid => is_init a)).","proofString":"assert (EMP1 : (fun e : actid => tid e = t_1)                    ∩₁ (fun a : actid => is_init a) ≡₁ ∅).\nsplit; [|basic_solver].\nintros x COND.\ndestruct COND as [TID ISINIT].\nunfold is_init in ISINIT.\ndesf.\nassert (EMP2 : (fun e : actid => tid e = t_2)                    ∩₁ (fun a : actid => is_init a) ≡₁ ∅).\nsplit; [|basic_solver].\nintros x COND.\ndestruct COND as [TID ISINIT].\nunfold is_init in ISINIT.\ndesf.\nrewrite EMP1, EMP2.\nclear; basic_solver 8."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) : (fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a) ≡₁ ∅.","proofString":"split; [|basic_solver].\nintros x COND.\ndestruct COND as [TID ISINIT].\nunfold is_init in ISINIT.\ndesf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) : (fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a) ⊆₁ ∅.","proofString":"intros x COND.\ndestruct COND as [TID ISINIT].\nunfold is_init in ISINIT.\ndesf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (x : actid) (COND : ((fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a)) x) : ∅ x.","proofString":"destruct COND as [TID ISINIT].\nunfold is_init in ISINIT.\ndesf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (x : actid) (TID : tid x = t_1) (ISINIT : is_init x) : ∅ x.","proofString":"unfold is_init in ISINIT.\ndesf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (x : actid) (TID : tid x = t_1) (ISINIT : match x with\n| InitEvent _ => true\n| ThreadEvent _ _ => false\nend) : ∅ x.","proofString":"desf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (EMP1 : (fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a) ≡₁ ∅) : sb (WCore.init_exec threads)\n∪ ((fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a))\n  × ((fun e : actid => tid e = t_2) ∩₁ (fun a : actid => is_init a))\n⊆ id ↑ sb (WCore.init_exec threads) /\\\nid ↑ sb (WCore.init_exec threads)\n⊆ sb (WCore.init_exec threads)\n  ∪ ((fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a))\n    × ((fun e : actid => tid e = t_2) ∩₁ (fun a : actid => is_init a)).","proofString":"assert (EMP2 : (fun e : actid => tid e = t_2)                    ∩₁ (fun a : actid => is_init a) ≡₁ ∅).\nsplit; [|basic_solver].\nintros x COND.\ndestruct COND as [TID ISINIT].\nunfold is_init in ISINIT.\ndesf.\nrewrite EMP1, EMP2.\nclear; basic_solver 8."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (EMP1 : (fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a) ≡₁ ∅) : (fun e : actid => tid e = t_2) ∩₁ (fun a : actid => is_init a) ≡₁ ∅.","proofString":"split; [|basic_solver].\nintros x COND.\ndestruct COND as [TID ISINIT].\nunfold is_init in ISINIT.\ndesf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (EMP1 : (fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a) ≡₁ ∅) : (fun e : actid => tid e = t_2) ∩₁ (fun a : actid => is_init a) ⊆₁ ∅.","proofString":"intros x COND.\ndestruct COND as [TID ISINIT].\nunfold is_init in ISINIT.\ndesf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (EMP1 : (fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a) ≡₁ ∅) (x : actid) (COND : ((fun e : actid => tid e = t_2) ∩₁ (fun a : actid => is_init a)) x) : ∅ x.","proofString":"destruct COND as [TID ISINIT].\nunfold is_init in ISINIT.\ndesf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (EMP1 : (fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a) ≡₁ ∅) (x : actid) (TID : tid x = t_2) (ISINIT : is_init x) : ∅ x.","proofString":"unfold is_init in ISINIT.\ndesf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (EMP1 : (fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a) ≡₁ ∅) (x : actid) (TID : tid x = t_2) (ISINIT : match x with\n| InitEvent _ => true\n| ThreadEvent _ _ => false\nend) : ∅ x.","proofString":"desf."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (EMP1 : (fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a) ≡₁ ∅) (EMP2 : (fun e : actid => tid e = t_2) ∩₁ (fun a : actid => is_init a) ≡₁ ∅) : sb (WCore.init_exec threads)\n∪ ((fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a))\n  × ((fun e : actid => tid e = t_2) ∩₁ (fun a : actid => is_init a))\n⊆ id ↑ sb (WCore.init_exec threads) /\\\nid ↑ sb (WCore.init_exec threads)\n⊆ sb (WCore.init_exec threads)\n  ∪ ((fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a))\n    × ((fun e : actid => tid e = t_2) ∩₁ (fun a : actid => is_init a)).","proofString":"rewrite EMP1, EMP2.\nclear; basic_solver 8."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (EMP1 : (fun e : actid => tid e = t_1) ∩₁ (fun a : actid => is_init a) ≡₁ ∅) (EMP2 : (fun e : actid => tid e = t_2) ∩₁ (fun a : actid => is_init a) ≡₁ ∅) : sb (WCore.init_exec threads) ∪ ∅ × ∅ ⊆ id ↑ sb (WCore.init_exec threads) /\\\nid ↑ sb (WCore.init_exec threads) ⊆ sb (WCore.init_exec threads) ∪ ∅ × ∅.","proofString":"clear; basic_solver 8."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) : threads ⊆₁ threads ∪₁ eq t_2 /\\ threads ∪₁ eq t_2 ⊆₁ threads.","proofString":"basic_solver."},{"statement":"(threads : thread_id -> Prop) (NINIT1 : t_1 <> tid_init) (NINIT2 : t_2 <> tid_init) (THRD1 : threads t_1) (THRD2 : threads t_2) (THRDNEQ : t_1 <> t_2) (INIT : threads tid_init) (IWF : Wf (WCore.init_exec threads)) (x : actid) (H : (id ↑₁ (fun a : actid => is_init a)) x) : is_init x.","proofString":"destruct H; basic_solver."}]}