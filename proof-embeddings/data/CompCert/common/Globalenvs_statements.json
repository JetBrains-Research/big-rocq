{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/common/Globalenvs.v","fileSamples":[{"statement":"(ge : t) (id : ident) (ofs delta : ptrofs) : symbol_address ge id (Ptrofs.add ofs delta) =\nVal.offset_ptr (symbol_address ge id ofs) delta.","proofString":"unfold symbol_address, Val.offset_ptr.\ndestruct (find_symbol ge id); auto."},{"statement":"(ge : t) (id : ident) (ofs delta : ptrofs) : match find_symbol ge id with\n| Some b => Vptr b (Ptrofs.add ofs delta)\n| None => Vundef\nend =\nmatch\n  match find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\nwith\n| Vptr b ofs0 => Vptr b (Ptrofs.add ofs0 delta)\n| _ => Vundef\nend.","proofString":"destruct (find_symbol ge id); auto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int) (H : Archi.ptr64 = false) : symbol_address ge id (Ptrofs.add ofs (Ptrofs.of_int n)) =\nVal.add (symbol_address ge id ofs) (Vint n).","proofString":"unfold symbol_address.\ndestruct (find_symbol ge id).\nunfold Val.add.\nrewrite H.\nauto.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int) (H : Archi.ptr64 = false) : match find_symbol ge id with\n| Some b => Vptr b (Ptrofs.add ofs (Ptrofs.of_int n))\n| None => Vundef\nend =\nVal.add\n  match find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end (Vint n).","proofString":"destruct (find_symbol ge id).\nunfold Val.add.\nrewrite H.\nauto.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int) (H : Archi.ptr64 = false) (b : block) : Vptr b (Ptrofs.add ofs (Ptrofs.of_int n)) = Val.add (Vptr b ofs) (Vint n).","proofString":"unfold Val.add.\nrewrite H.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int) (H : Archi.ptr64 = false) (b : block) : Vptr b (Ptrofs.add ofs (Ptrofs.of_int n)) =\n(if Archi.ptr64 then Vundef else Vptr b (Ptrofs.add ofs (Ptrofs.of_int n))).","proofString":"rewrite H.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int) (H : Archi.ptr64 = false) (b : block) : Vptr b (Ptrofs.add ofs (Ptrofs.of_int n)) =\nVptr b (Ptrofs.add ofs (Ptrofs.of_int n)).","proofString":"auto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int) (H : Archi.ptr64 = false) : Vundef = Val.add Vundef (Vint n).","proofString":"auto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int64) (H : Archi.ptr64 = true) : symbol_address ge id (Ptrofs.add ofs (Ptrofs.of_int64 n)) =\nVal.addl (symbol_address ge id ofs) (Vlong n).","proofString":"unfold symbol_address.\ndestruct (find_symbol ge id).\nunfold Val.addl.\nrewrite H.\nauto.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int64) (H : Archi.ptr64 = true) : match find_symbol ge id with\n| Some b => Vptr b (Ptrofs.add ofs (Ptrofs.of_int64 n))\n| None => Vundef\nend =\nVal.addl\n  match find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end (Vlong n).","proofString":"destruct (find_symbol ge id).\nunfold Val.addl.\nrewrite H.\nauto.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int64) (H : Archi.ptr64 = true) (b : block) : Vptr b (Ptrofs.add ofs (Ptrofs.of_int64 n)) = Val.addl (Vptr b ofs) (Vlong n).","proofString":"unfold Val.addl.\nrewrite H.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int64) (H : Archi.ptr64 = true) (b : block) : Vptr b (Ptrofs.add ofs (Ptrofs.of_int64 n)) =\n(if Archi.ptr64 then Vptr b (Ptrofs.add ofs (Ptrofs.of_int64 n)) else Vundef).","proofString":"rewrite H.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int64) (H : Archi.ptr64 = true) (b : block) : Vptr b (Ptrofs.add ofs (Ptrofs.of_int64 n)) =\nVptr b (Ptrofs.add ofs (Ptrofs.of_int64 n)).","proofString":"auto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int64) (H : Archi.ptr64 = true) : Vundef = Val.addl Vundef (Vlong n).","proofString":"auto."},{"statement":"(gl2 gl1 : list (ident * globdef F V)) (ge : t) : add_globals ge (gl1 ++ gl2) = add_globals (add_globals ge gl1) gl2.","proofString":"apply fold_left_app."},{"statement":"(ge : t) (H : forall (ge0 : t) (id : ident) (g : globdef F V),\nP ge0 -> False -> P (add_global ge0 (id, g))) (H0 : P ge) : P ge.","proofString":"auto."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall ge0 : t,\n(forall (ge1 : t) (id : ident) (g : globdef F V),\n P ge1 -> In (id, g) gl -> P (add_global ge1 (id, g))) ->\nP ge0 -> P (add_globals ge0 gl)) (ge : t) (H : forall (ge0 : t) (id : ident) (g : globdef F V),\nP ge0 -> a = (id, g) \\/ In (id, g) gl -> P (add_global ge0 (id, g))) (H0 : P ge) : P (add_globals (add_global ge a) gl).","proofString":"destruct a.\napply IHgl; auto."},{"statement":"(i : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall ge0 : t,\n(forall (ge1 : t) (id : ident) (g0 : globdef F V),\n P ge1 -> In (id, g0) gl -> P (add_global ge1 (id, g0))) ->\nP ge0 -> P (add_globals ge0 gl)) (ge : t) (H : forall (ge0 : t) (id : ident) (g0 : globdef F V),\nP ge0 -> (i, g) = (id, g0) \\/ In (id, g0) gl -> P (add_global ge0 (id, g0))) (H0 : P ge) : P (add_globals (add_global ge (i, g)) gl).","proofString":"apply IHgl; auto."},{"statement":"(id : ident) (g : globdef F V) (ge : t) (H : forall (ge0 : t) (id0 : ident) (g0 : globdef F V),\nP ge0 -> False -> P (add_global ge0 (id0, g0))) (H0 : forall ge0 : t, P (add_global ge0 (id, g))) (H1 : False) : P ge.","proofString":"contradiction."},{"statement":"(id : ident) (g : globdef F V) (a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall ge0 : t,\n(forall (ge1 : t) (id0 : ident) (g0 : globdef F V),\n P ge1 -> In (id0, g0) gl -> P (add_global ge1 (id0, g0))) ->\n(forall ge1 : t, P (add_global ge1 (id, g))) ->\nIn (id, g) gl -> P (add_globals ge0 gl)) (ge : t) (H : forall (ge0 : t) (id0 : ident) (g0 : globdef F V),\nP ge0 -> a = (id0, g0) \\/ In (id0, g0) gl -> P (add_global ge0 (id0, g0))) (H0 : forall ge0 : t, P (add_global ge0 (id, g))) (H1 : a = (id, g) \\/ In (id, g) gl) : P (add_globals (add_global ge a) gl).","proofString":"destruct H1.\nsubst a.\napply add_globals_preserves; auto.\napply IHgl; auto."},{"statement":"(id : ident) (g : globdef F V) (a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall ge0 : t,\n(forall (ge1 : t) (id0 : ident) (g0 : globdef F V),\n P ge1 -> In (id0, g0) gl -> P (add_global ge1 (id0, g0))) ->\n(forall ge1 : t, P (add_global ge1 (id, g))) ->\nIn (id, g) gl -> P (add_globals ge0 gl)) (ge : t) (H : forall (ge0 : t) (id0 : ident) (g0 : globdef F V),\nP ge0 -> a = (id0, g0) \\/ In (id0, g0) gl -> P (add_global ge0 (id0, g0))) (H0 : forall ge0 : t, P (add_global ge0 (id, g))) (H1 : a = (id, g)) : P (add_globals (add_global ge a) gl).","proofString":"subst a.\napply add_globals_preserves; auto."},{"statement":"(id : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall ge0 : t,\n(forall (ge1 : t) (id0 : ident) (g0 : globdef F V),\n P ge1 -> In (id0, g0) gl -> P (add_global ge1 (id0, g0))) ->\n(forall ge1 : t, P (add_global ge1 (id, g))) ->\nIn (id, g) gl -> P (add_globals ge0 gl)) (ge : t) (H : forall (ge0 : t) (id0 : ident) (g0 : globdef F V),\nP ge0 ->\n(id, g) = (id0, g0) \\/ In (id0, g0) gl -> P (add_global ge0 (id0, g0))) (H0 : forall ge0 : t, P (add_global ge0 (id, g))) : P (add_globals (add_global ge (id, g)) gl).","proofString":"apply add_globals_preserves; auto."},{"statement":"(id : ident) (g : globdef F V) (a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall ge0 : t,\n(forall (ge1 : t) (id0 : ident) (g0 : globdef F V),\n P ge1 -> In (id0, g0) gl -> P (add_global ge1 (id0, g0))) ->\n(forall ge1 : t, P (add_global ge1 (id, g))) ->\nIn (id, g) gl -> P (add_globals ge0 gl)) (ge : t) (H : forall (ge0 : t) (id0 : ident) (g0 : globdef F V),\nP ge0 -> a = (id0, g0) \\/ In (id0, g0) gl -> P (add_global ge0 (id0, g0))) (H0 : forall ge0 : t, P (add_global ge0 (id, g))) (H1 : In (id, g) gl) : P (add_globals (add_global ge a) gl).","proofString":"apply IHgl; auto."},{"statement":"(id : ident) (ge : t) (H : forall (ge0 : t) (id1 : ident) (g : globdef F V),\nP ge0 -> False -> id1 <> id -> P (add_global ge0 (id1, g))) (H0 : ~ False) (H1 : P ge) : P ge.","proofString":"auto."},{"statement":"(id : ident) (a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall ge0 : t,\n(forall (ge1 : t) (id1 : ident) (g : globdef F V),\n P ge1 -> In (id1, g) gl -> id1 <> id -> P (add_global ge1 (id1, g))) ->\n~ In id (map fst gl) -> P ge0 -> P (add_globals ge0 gl)) (ge : t) (H : forall (ge0 : t) (id1 : ident) (g : globdef F V),\nP ge0 ->\na = (id1, g) \\/ In (id1, g) gl -> id1 <> id -> P (add_global ge0 (id1, g))) (H0 : ~ (a#1 = id \\/ In id (map fst gl))) (H1 : P ge) : P (add_globals (add_global ge a) gl).","proofString":"destruct a.\napply IHgl; auto."},{"statement":"(id i : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall ge0 : t,\n(forall (ge1 : t) (id1 : ident) (g0 : globdef F V),\n P ge1 -> In (id1, g0) gl -> id1 <> id -> P (add_global ge1 (id1, g0))) ->\n~ In id (map fst gl) -> P ge0 -> P (add_globals ge0 gl)) (ge : t) (H : forall (ge0 : t) (id1 : ident) (g0 : globdef F V),\nP ge0 ->\n(i, g) = (id1, g0) \\/ In (id1, g0) gl ->\nid1 <> id -> P (add_global ge0 (id1, g0))) (H0 : ~ ((i, g)#1 = id \\/ In id (map fst gl))) (H1 : P ge) : P (add_globals (add_global ge (i, g)) gl).","proofString":"apply IHgl; auto."},{"statement":"(gl1 : list (ident * globdef F V)) (id : ident) (g : globdef F V) (gl2 : list (ident * globdef F V)) (ge : t) (H : forall (ge0 : t) (id1 : ident) (g1 : globdef F V),\nP ge0 -> In (id1, g1) gl2 -> id1 <> id -> P (add_global ge0 (id1, g1))) (H0 : forall ge0 : t, P (add_global ge0 (id, g))) (H1 : ~ In id (map fst gl2)) : P (add_globals ge (gl1 ++ (id, g) :: gl2)).","proofString":"rewrite add_globals_app.\nsimpl.\napply add_globals_unique_preserves with id; auto."},{"statement":"(gl1 : list (ident * globdef F V)) (id : ident) (g : globdef F V) (gl2 : list (ident * globdef F V)) (ge : t) (H : forall (ge0 : t) (id1 : ident) (g1 : globdef F V),\nP ge0 -> In (id1, g1) gl2 -> id1 <> id -> P (add_global ge0 (id1, g1))) (H0 : forall ge0 : t, P (add_global ge0 (id, g))) (H1 : ~ In id (map fst gl2)) : P (add_globals (add_globals ge gl1) ((id, g) :: gl2)).","proofString":"simpl.\napply add_globals_unique_preserves with id; auto."},{"statement":"(gl1 : list (ident * globdef F V)) (id : ident) (g : globdef F V) (gl2 : list (ident * globdef F V)) (ge : t) (H : forall (ge0 : t) (id1 : ident) (g1 : globdef F V),\nP ge0 -> In (id1, g1) gl2 -> id1 <> id -> P (add_global ge0 (id1, g1))) (H0 : forall ge0 : t, P (add_global ge0 (id, g))) (H1 : ~ In id (map fst gl2)) : P (add_globals (add_global (add_globals ge gl1) (id, g)) gl2).","proofString":"apply add_globals_unique_preserves with id; auto."},{"statement":"(id : ident) (g : globdef F V) (id1 : ident) (g1 : globdef F V) (gl : list (ident * globdef F V)) (IHgl : In (id, g) gl ->\nlist_norepet (map fst gl) ->\nexists gl1 gl2 : list (ident * globdef F V),\n  gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2)) (H : (id1, g1) = (id, g) \\/ In (id, g) gl) (H0 : list_norepet (id1 :: map fst gl)) : exists gl1 gl2 : list (ident * globdef F V),\n  (id1, g1) :: gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2).","proofString":"inv H0.\ndestruct H.\ninv H.\nexists nil, gl.\nauto.\nexploit IHgl; eauto.\nintros (gl1 & gl2 & X & Y).\nexists ((id1, g1) :: gl1), gl2; split; auto.\nrewrite X; auto."},{"statement":"(id : ident) (g : globdef F V) (id1 : ident) (g1 : globdef F V) (gl : list (ident * globdef F V)) (IHgl : In (id, g) gl ->\nlist_norepet (map fst gl) ->\nexists gl1 gl2 : list (ident * globdef F V),\n  gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2)) (H : (id1, g1) = (id, g) \\/ In (id, g) gl) (H3 : ~ In id1 (map fst gl)) (H4 : list_norepet (map fst gl)) : exists gl1 gl2 : list (ident * globdef F V),\n  (id1, g1) :: gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2).","proofString":"destruct H.\ninv H.\nexists nil, gl.\nauto.\nexploit IHgl; eauto.\nintros (gl1 & gl2 & X & Y).\nexists ((id1, g1) :: gl1), gl2; split; auto.\nrewrite X; auto."},{"statement":"(id : ident) (g : globdef F V) (id1 : ident) (g1 : globdef F V) (gl : list (ident * globdef F V)) (IHgl : In (id, g) gl ->\nlist_norepet (map fst gl) ->\nexists gl1 gl2 : list (ident * globdef F V),\n  gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2)) (H : (id1, g1) = (id, g)) (H3 : ~ In id1 (map fst gl)) (H4 : list_norepet (map fst gl)) : exists gl1 gl2 : list (ident * globdef F V),\n  (id1, g1) :: gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2).","proofString":"inv H.\nexists nil, gl.\nauto."},{"statement":"(id : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (IHgl : In (id, g) gl ->\nlist_norepet (map fst gl) ->\nexists gl1 gl2 : list (ident * globdef F V),\n  gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2)) (H3 : ~ In id (map fst gl)) (H4 : list_norepet (map fst gl)) : exists gl1 gl2 : list (ident * globdef F V),\n  (id, g) :: gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2).","proofString":"exists nil, gl.\nauto."},{"statement":"(id : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (IHgl : In (id, g) gl ->\nlist_norepet (map fst gl) ->\nexists gl1 gl2 : list (ident * globdef F V),\n  gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2)) (H3 : ~ In id (map fst gl)) (H4 : list_norepet (map fst gl)) : (id, g) :: gl = nil ++ (id, g) :: gl /\\ ~ In id (map fst gl).","proofString":"auto."},{"statement":"(id : ident) (g : globdef F V) (id1 : ident) (g1 : globdef F V) (gl : list (ident * globdef F V)) (IHgl : In (id, g) gl ->\nlist_norepet (map fst gl) ->\nexists gl1 gl2 : list (ident * globdef F V),\n  gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2)) (H : In (id, g) gl) (H3 : ~ In id1 (map fst gl)) (H4 : list_norepet (map fst gl)) : exists gl1 gl2 : list (ident * globdef F V),\n  (id1, g1) :: gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2).","proofString":"exploit IHgl; eauto.\nintros (gl1 & gl2 & X & Y).\nexists ((id1, g1) :: gl1), gl2; split; auto.\nrewrite X; auto."},{"statement":"(id : ident) (g : globdef F V) (id1 : ident) (g1 : globdef F V) (gl : list (ident * globdef F V)) (IHgl : In (id, g) gl ->\nlist_norepet (map fst gl) ->\nexists gl1 gl2 : list (ident * globdef F V),\n  gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2)) (H : In (id, g) gl) (H3 : ~ In id1 (map fst gl)) (H4 : list_norepet (map fst gl)) : (exists gl1 gl2 : list (ident * globdef F V),\n   gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2)) ->\nexists gl1 gl2 : list (ident * globdef F V),\n  (id1, g1) :: gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2).","proofString":"intros (gl1 & gl2 & X & Y).\nexists ((id1, g1) :: gl1), gl2; split; auto.\nrewrite X; auto."},{"statement":"(id : ident) (g : globdef F V) (id1 : ident) (g1 : globdef F V) (gl : list (ident * globdef F V)) (IHgl : In (id, g) gl ->\nlist_norepet (map fst gl) ->\nexists gl0 gl3 : list (ident * globdef F V),\n  gl = gl0 ++ (id, g) :: gl3 /\\ ~ In id (map fst gl3)) (H : In (id, g) gl) (H3 : ~ In id1 (map fst gl)) (H4 : list_norepet (map fst gl)) (gl1 gl2 : list (ident * globdef F V)) (X : gl = gl1 ++ (id, g) :: gl2) (Y : ~ In id (map fst gl2)) : exists gl0 gl3 : list (ident * globdef F V),\n  (id1, g1) :: gl = gl0 ++ (id, g) :: gl3 /\\ ~ In id (map fst gl3).","proofString":"exists ((id1, g1) :: gl1), gl2; split; auto.\nrewrite X; auto."},{"statement":"(id : ident) (g : globdef F V) (id1 : ident) (g1 : globdef F V) (gl : list (ident * globdef F V)) (IHgl : In (id, g) gl ->\nlist_norepet (map fst gl) ->\nexists gl0 gl3 : list (ident * globdef F V),\n  gl = gl0 ++ (id, g) :: gl3 /\\ ~ In id (map fst gl3)) (H : In (id, g) gl) (H3 : ~ In id1 (map fst gl)) (H4 : list_norepet (map fst gl)) (gl1 gl2 : list (ident * globdef F V)) (X : gl = gl1 ++ (id, g) :: gl2) (Y : ~ In id (map fst gl2)) : (id1, g1) :: gl = ((id1, g1) :: gl1) ++ (id, g) :: gl2.","proofString":"rewrite X; auto."},{"statement":"(id : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (ge : t) (H : forall (ge0 : t) (id1 : ident) (g1 : globdef F V),\nP ge0 -> In (id1, g1) gl -> id1 <> id -> P (add_global ge0 (id1, g1))) (H0 : forall ge0 : t, P (add_global ge0 (id, g))) (H1 : In (id, g) gl) (H2 : list_norepet (map fst gl)) : P (add_globals ge gl).","proofString":"exploit in_norepet_unique; eauto.\nintros (gl1 & gl2 & X & Y).\nsubst gl.\napply add_globals_unique_ensures; auto.\nintros.\neapply H; eauto.\napply in_or_app; simpl; auto."},{"statement":"(id : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (ge : t) (H : forall (ge0 : t) (id1 : ident) (g1 : globdef F V),\nP ge0 -> In (id1, g1) gl -> id1 <> id -> P (add_global ge0 (id1, g1))) (H0 : forall ge0 : t, P (add_global ge0 (id, g))) (H1 : In (id, g) gl) (H2 : list_norepet (map fst gl)) : (exists gl1 gl2 : list (ident * globdef F V),\n   gl = gl1 ++ (id, g) :: gl2 /\\ ~ In id (map fst gl2)) ->\nP (add_globals ge gl).","proofString":"intros (gl1 & gl2 & X & Y).\nsubst gl.\napply add_globals_unique_ensures; auto.\nintros.\neapply H; eauto.\napply in_or_app; simpl; auto."},{"statement":"(id : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (ge : t) (H : forall (ge0 : t) (id1 : ident) (g1 : globdef F V),\nP ge0 -> In (id1, g1) gl -> id1 <> id -> P (add_global ge0 (id1, g1))) (H0 : forall ge0 : t, P (add_global ge0 (id, g))) (H1 : In (id, g) gl) (H2 : list_norepet (map fst gl)) (gl1 gl2 : list (ident * globdef F V)) (X : gl = gl1 ++ (id, g) :: gl2) (Y : ~ In id (map fst gl2)) : P (add_globals ge gl).","proofString":"subst gl.\napply add_globals_unique_ensures; auto.\nintros.\neapply H; eauto.\napply in_or_app; simpl; auto."},{"statement":"(id : ident) (g : globdef F V) (ge : t) (gl1 gl2 : list (ident * globdef F V)) (H : forall (ge0 : t) (id1 : ident) (g1 : globdef F V),\nP ge0 ->\nIn (id1, g1) (gl1 ++ (id, g) :: gl2) ->\nid1 <> id -> P (add_global ge0 (id1, g1))) (H0 : forall ge0 : t, P (add_global ge0 (id, g))) (H2 : list_norepet (map fst (gl1 ++ (id, g) :: gl2))) (H1 : In (id, g) (gl1 ++ (id, g) :: gl2)) (Y : ~ In id (map fst gl2)) : P (add_globals ge (gl1 ++ (id, g) :: gl2)).","proofString":"apply add_globals_unique_ensures; auto.\nintros.\neapply H; eauto.\napply in_or_app; simpl; auto."},{"statement":"(id : ident) (g : globdef F V) (ge : t) (gl1 gl2 : list (ident * globdef F V)) (H : forall (ge0 : t) (id1 : ident) (g1 : globdef F V),\nP ge0 ->\nIn (id1, g1) (gl1 ++ (id, g) :: gl2) ->\nid1 <> id -> P (add_global ge0 (id1, g1))) (H0 : forall ge0 : t, P (add_global ge0 (id, g))) (H2 : list_norepet (map fst (gl1 ++ (id, g) :: gl2))) (H1 : In (id, g) (gl1 ++ (id, g) :: gl2)) (Y : ~ In id (map fst gl2)) : forall (ge0 : t) (id1 : ident) (g1 : globdef F V),\nP ge0 -> In (id1, g1) gl2 -> id1 <> id -> P (add_global ge0 (id1, g1)).","proofString":"intros.\neapply H; eauto.\napply in_or_app; simpl; auto."},{"statement":"(id : ident) (g : globdef F V) (ge : t) (gl1 gl2 : list (ident * globdef F V)) (H : forall (ge1 : t) (id0 : ident) (g0 : globdef F V),\nP ge1 ->\nIn (id0, g0) (gl1 ++ (id, g) :: gl2) ->\nid0 <> id -> P (add_global ge1 (id0, g0))) (H0 : forall ge1 : t, P (add_global ge1 (id, g))) (H2 : list_norepet (map fst (gl1 ++ (id, g) :: gl2))) (H1 : In (id, g) (gl1 ++ (id, g) :: gl2)) (Y : ~ In id (map fst gl2)) (ge0 : t) (id1 : ident) (g1 : globdef F V) (H3 : P ge0) (H4 : In (id1, g1) gl2) (H5 : id1 <> id) : P (add_global ge0 (id1, g1)).","proofString":"eapply H; eauto.\napply in_or_app; simpl; auto."},{"statement":"(id : ident) (g : globdef F V) (ge : t) (gl1 gl2 : list (ident * globdef F V)) (H : forall (ge1 : t) (id0 : ident) (g0 : globdef F V),\nP ge1 ->\nIn (id0, g0) (gl1 ++ (id, g) :: gl2) ->\nid0 <> id -> P (add_global ge1 (id0, g0))) (H0 : forall ge1 : t, P (add_global ge1 (id, g))) (H2 : list_norepet (map fst (gl1 ++ (id, g) :: gl2))) (H1 : In (id, g) (gl1 ++ (id, g) :: gl2)) (Y : ~ In id (map fst gl2)) (ge0 : t) (id1 : ident) (g1 : globdef F V) (H3 : P ge0) (H4 : In (id1, g1) gl2) (H5 : id1 <> id) : In (id1, g1) (gl1 ++ (id, g) :: gl2).","proofString":"apply in_or_app; simpl; auto."},{"statement":"(ge : t) (id : ident) (H : false = true) : exists b : block, None = Some b.","proofString":"discriminate."},{"statement":"(ge : t) (id : ident) (ofs delta : ptrofs) : symbol_address ge id (Ptrofs.add ofs delta) =\nVal.offset_ptr (symbol_address ge id ofs) delta.","proofString":"unfold symbol_address, Val.offset_ptr.\ndestruct (find_symbol ge id); auto."},{"statement":"(ge : t) (id : ident) (ofs delta : ptrofs) : match find_symbol ge id with\n| Some b => Vptr b (Ptrofs.add ofs delta)\n| None => Vundef\nend =\nmatch\n  match find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end\nwith\n| Vptr b ofs0 => Vptr b (Ptrofs.add ofs0 delta)\n| _ => Vundef\nend.","proofString":"destruct (find_symbol ge id); auto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int) (H : Archi.ptr64 = false) : symbol_address ge id (Ptrofs.add ofs (Ptrofs.of_int n)) =\nVal.add (symbol_address ge id ofs) (Vint n).","proofString":"unfold symbol_address.\ndestruct (find_symbol ge id).\nunfold Val.add.\nrewrite H.\nauto.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int) (H : Archi.ptr64 = false) : match find_symbol ge id with\n| Some b => Vptr b (Ptrofs.add ofs (Ptrofs.of_int n))\n| None => Vundef\nend =\nVal.add\n  match find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end (Vint n).","proofString":"destruct (find_symbol ge id).\nunfold Val.add.\nrewrite H.\nauto.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int) (H : Archi.ptr64 = false) (b : block) : Vptr b (Ptrofs.add ofs (Ptrofs.of_int n)) = Val.add (Vptr b ofs) (Vint n).","proofString":"unfold Val.add.\nrewrite H.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int) (H : Archi.ptr64 = false) (b : block) : Vptr b (Ptrofs.add ofs (Ptrofs.of_int n)) =\n(if Archi.ptr64 then Vundef else Vptr b (Ptrofs.add ofs (Ptrofs.of_int n))).","proofString":"rewrite H.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int) (H : Archi.ptr64 = false) (b : block) : Vptr b (Ptrofs.add ofs (Ptrofs.of_int n)) =\nVptr b (Ptrofs.add ofs (Ptrofs.of_int n)).","proofString":"auto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int) (H : Archi.ptr64 = false) : Vundef = Val.add Vundef (Vint n).","proofString":"auto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int64) (H : Archi.ptr64 = true) : symbol_address ge id (Ptrofs.add ofs (Ptrofs.of_int64 n)) =\nVal.addl (symbol_address ge id ofs) (Vlong n).","proofString":"unfold symbol_address.\ndestruct (find_symbol ge id).\nunfold Val.addl.\nrewrite H.\nauto.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int64) (H : Archi.ptr64 = true) : match find_symbol ge id with\n| Some b => Vptr b (Ptrofs.add ofs (Ptrofs.of_int64 n))\n| None => Vundef\nend =\nVal.addl\n  match find_symbol ge id with\n  | Some b => Vptr b ofs\n  | None => Vundef\n  end (Vlong n).","proofString":"destruct (find_symbol ge id).\nunfold Val.addl.\nrewrite H.\nauto.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int64) (H : Archi.ptr64 = true) (b : block) : Vptr b (Ptrofs.add ofs (Ptrofs.of_int64 n)) = Val.addl (Vptr b ofs) (Vlong n).","proofString":"unfold Val.addl.\nrewrite H.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int64) (H : Archi.ptr64 = true) (b : block) : Vptr b (Ptrofs.add ofs (Ptrofs.of_int64 n)) =\n(if Archi.ptr64 then Vptr b (Ptrofs.add ofs (Ptrofs.of_int64 n)) else Vundef).","proofString":"rewrite H.\nauto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int64) (H : Archi.ptr64 = true) (b : block) : Vptr b (Ptrofs.add ofs (Ptrofs.of_int64 n)) =\nVptr b (Ptrofs.add ofs (Ptrofs.of_int64 n)).","proofString":"auto."},{"statement":"(ge : t) (id : ident) (ofs : ptrofs) (n : int64) (H : Archi.ptr64 = true) : Vundef = Val.addl Vundef (Vlong n).","proofString":"auto."},{"statement":"(ge : t) (v : val) (f : F) : match v with\n| Vptr b ofs =>\n    if Ptrofs.eq_dec ofs Ptrofs.zero then find_funct_ptr ge b else None\n| _ => None\nend = Some f -> exists b : block, v = Vptr b Ptrofs.zero.","proofString":"destruct v; try congruence.\ndestruct (Ptrofs.eq_dec i Ptrofs.zero); try congruence.\nintros.\nexists b; congruence."},{"statement":"(ge : t) (b : block) (i : ptrofs) (f : F) : (if Ptrofs.eq_dec i Ptrofs.zero then find_funct_ptr ge b else None) = Some f ->\nexists b0 : block, Vptr b i = Vptr b0 Ptrofs.zero.","proofString":"destruct (Ptrofs.eq_dec i Ptrofs.zero); try congruence.\nintros.\nexists b; congruence."},{"statement":"(ge : t) (b : block) (i : ptrofs) (f : F) (e : i = Ptrofs.zero) : find_funct_ptr ge b = Some f ->\nexists b0 : block, Vptr b i = Vptr b0 Ptrofs.zero.","proofString":"intros.\nexists b; congruence."},{"statement":"(ge : t) (b : block) (i : ptrofs) (f : F) (e : i = Ptrofs.zero) (H : find_funct_ptr ge b = Some f) : exists b0 : block, Vptr b i = Vptr b0 Ptrofs.zero.","proofString":"exists b; congruence."},{"statement":"(ge : t) (b : block) : (if Ptrofs.eq_dec Ptrofs.zero Ptrofs.zero then find_funct_ptr ge b else None) =\nfind_funct_ptr ge b.","proofString":"apply dec_eq_true."},{"statement":"(ge : t) (b : block) (f : F) : find_funct_ptr ge b = Some f <-> find_def ge b = Some (Gfun f).","proofString":"unfold find_funct_ptr.\ndestruct (find_def ge b) as [[f1|v1]|]; intuition congruence."},{"statement":"(ge : t) (b : block) (f : F) : match find_def ge b with\n| Some (Gfun f0) => Some f0\n| _ => None\nend = Some f <-> find_def ge b = Some (Gfun f).","proofString":"destruct (find_def ge b) as [[f1|v1]|]; intuition congruence."},{"statement":"(ge : t) (b : block) (v : globvar V) : find_var_info ge b = Some v <-> find_def ge b = Some (Gvar v).","proofString":"unfold find_var_info.\ndestruct (find_def ge b) as [[f1|v1]|]; intuition congruence."},{"statement":"(ge : t) (b : block) (v : globvar V) : match find_def ge b with\n| Some (Gvar v0) => Some v0\n| _ => None\nend = Some v <-> find_def ge b = Some (Gvar v).","proofString":"destruct (find_def ge b) as [[f1|v1]|]; intuition congruence."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) : (prog_defmap p) ! id = Some g <->\n(exists b : block,\n   find_symbol (globalenv p) id = Some b /\\ find_def (globalenv p) b = Some g).","proofString":"set (P := fun m ge => m!id = Some g <-> exists b, find_symbol ge id = Some b /\\ find_def ge b = Some g).\nassert (REC: forall l m ge,            P m ge ->            P (fold_left (fun m idg => PTree.set idg#1 idg#2 m) l m)              (add_globals ge l)).\ninduction l as [ | [id1 g1] l]; intros; simpl.\nauto.\napply IHl.\nunfold P, add_global, find_symbol, find_def; simpl.\nrewrite ! PTree.gsspec.\ndestruct (peq id id1).\nsubst id1.\nsplit; intros.\ninv H0.\nexists (genv_next ge); split; auto.\napply PTree.gss.\ndestruct H0 as (b & A & B).\ninv A.\nrewrite PTree.gss in B.\nauto.\nred in H; rewrite H.\nsplit.\nintros (b & A & B).\nexists b; split; auto.\nrewrite PTree.gso; auto.\napply Plt_ne.\neapply genv_symb_range; eauto.\nintros (b & A & B).\nrewrite PTree.gso in B.\nexists b; auto.\napply Plt_ne.\neapply genv_symb_range; eauto.\napply REC.\nunfold P, find_symbol, find_def; simpl.\nrewrite ! PTree.gempty.\nsplit.\ncongruence.\nintros (b & A & B); congruence."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (m : PTree.tree (globdef F V)) (ge : t) (H : P m ge) : P m ge.","proofString":"auto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (id1 : positive) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : P m ge) (e : id = id1) : Some g1 = Some g <->\n(exists b : block,\n   Some (genv_next ge) = Some b /\\\n   (PTree.set (genv_next ge) g1 (genv_defs ge)) ! b = Some g).","proofString":"subst id1.\nsplit; intros.\ninv H0.\nexists (genv_next ge); split; auto.\napply PTree.gss.\ndestruct H0 as (b & A & B).\ninv A.\nrewrite PTree.gss in B.\nauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : P m ge) : Some g1 = Some g <->\n(exists b : block,\n   Some (genv_next ge) = Some b /\\\n   (PTree.set (genv_next ge) g1 (genv_defs ge)) ! b = Some g).","proofString":"split; intros.\ninv H0.\nexists (genv_next ge); split; auto.\napply PTree.gss.\ndestruct H0 as (b & A & B).\ninv A.\nrewrite PTree.gss in B.\nauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : P m ge) (H0 : Some g1 = Some g) : exists b : block,\n  Some (genv_next ge) = Some b /\\\n  (PTree.set (genv_next ge) g1 (genv_defs ge)) ! b = Some g.","proofString":"inv H0.\nexists (genv_next ge); split; auto.\napply PTree.gss."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : P m ge) : exists b : block,\n  Some (genv_next ge) = Some b /\\\n  (PTree.set (genv_next ge) g (genv_defs ge)) ! b = Some g.","proofString":"exists (genv_next ge); split; auto.\napply PTree.gss."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : P m ge) : (PTree.set (genv_next ge) g (genv_defs ge)) ! (genv_next ge) = Some g.","proofString":"apply PTree.gss."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : P m ge) (H0 : exists b : block,\n  Some (genv_next ge) = Some b /\\\n  (PTree.set (genv_next ge) g1 (genv_defs ge)) ! b = Some g) : Some g1 = Some g.","proofString":"destruct H0 as (b & A & B).\ninv A.\nrewrite PTree.gss in B.\nauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : P m ge) (b : block) (A : Some (genv_next ge) = Some b) (B : (PTree.set (genv_next ge) g1 (genv_defs ge)) ! b = Some g) : Some g1 = Some g.","proofString":"inv A.\nrewrite PTree.gss in B.\nauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : P m ge) (B : (PTree.set (genv_next ge) g1 (genv_defs ge)) ! (genv_next ge) = Some g) : Some g1 = Some g.","proofString":"rewrite PTree.gss in B.\nauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : P m ge) (B : Some g1 = Some g) : Some g1 = Some g.","proofString":"auto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (id1 : positive) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : m ! id = Some g <->\n(exists b : block, find_symbol ge id = Some b /\\ find_def ge b = Some g)) (n : id <> id1) : (exists b : block, find_symbol ge id = Some b /\\ find_def ge b = Some g) <->\n(exists b : block,\n   (genv_symb ge) ! id = Some b /\\\n   (PTree.set (genv_next ge) g1 (genv_defs ge)) ! b = Some g).","proofString":"split.\nintros (b & A & B).\nexists b; split; auto.\nrewrite PTree.gso; auto.\napply Plt_ne.\neapply genv_symb_range; eauto.\nintros (b & A & B).\nrewrite PTree.gso in B.\nexists b; auto.\napply Plt_ne.\neapply genv_symb_range; eauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (id1 : positive) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : m ! id = Some g <->\n(exists b : block, find_symbol ge id = Some b /\\ find_def ge b = Some g)) (n : id <> id1) : (exists b : block, find_symbol ge id = Some b /\\ find_def ge b = Some g) ->\nexists b : block,\n  (genv_symb ge) ! id = Some b /\\\n  (PTree.set (genv_next ge) g1 (genv_defs ge)) ! b = Some g.","proofString":"intros (b & A & B).\nexists b; split; auto.\nrewrite PTree.gso; auto.\napply Plt_ne.\neapply genv_symb_range; eauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (id1 : positive) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : m ! id = Some g <->\n(exists b0 : block, find_symbol ge id = Some b0 /\\ find_def ge b0 = Some g)) (n : id <> id1) (b : block) (A : find_symbol ge id = Some b) (B : find_def ge b = Some g) : exists b0 : block,\n  (genv_symb ge) ! id = Some b0 /\\\n  (PTree.set (genv_next ge) g1 (genv_defs ge)) ! b0 = Some g.","proofString":"exists b; split; auto.\nrewrite PTree.gso; auto.\napply Plt_ne.\neapply genv_symb_range; eauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (id1 : positive) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : m ! id = Some g <->\n(exists b0 : block, find_symbol ge id = Some b0 /\\ find_def ge b0 = Some g)) (n : id <> id1) (b : block) (A : find_symbol ge id = Some b) (B : find_def ge b = Some g) : (PTree.set (genv_next ge) g1 (genv_defs ge)) ! b = Some g.","proofString":"rewrite PTree.gso; auto.\napply Plt_ne.\neapply genv_symb_range; eauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (id1 : positive) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : m ! id = Some g <->\n(exists b0 : block, find_symbol ge id = Some b0 /\\ find_def ge b0 = Some g)) (n : id <> id1) (b : block) (A : find_symbol ge id = Some b) (B : find_def ge b = Some g) : b <> genv_next ge.","proofString":"apply Plt_ne.\neapply genv_symb_range; eauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (id1 : positive) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : m ! id = Some g <->\n(exists b0 : block, find_symbol ge id = Some b0 /\\ find_def ge b0 = Some g)) (n : id <> id1) (b : block) (A : find_symbol ge id = Some b) (B : find_def ge b = Some g) : Plt b (genv_next ge).","proofString":"eapply genv_symb_range; eauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (id1 : positive) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : m ! id = Some g <->\n(exists b : block, find_symbol ge id = Some b /\\ find_def ge b = Some g)) (n : id <> id1) : (exists b : block,\n   (genv_symb ge) ! id = Some b /\\\n   (PTree.set (genv_next ge) g1 (genv_defs ge)) ! b = Some g) ->\nexists b : block, find_symbol ge id = Some b /\\ find_def ge b = Some g.","proofString":"intros (b & A & B).\nrewrite PTree.gso in B.\nexists b; auto.\napply Plt_ne.\neapply genv_symb_range; eauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (id1 : positive) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : m ! id = Some g <->\n(exists b0 : block, find_symbol ge id = Some b0 /\\ find_def ge b0 = Some g)) (n : id <> id1) (b : block) (A : (genv_symb ge) ! id = Some b) (B : (PTree.set (genv_next ge) g1 (genv_defs ge)) ! b = Some g) : exists b0 : block, find_symbol ge id = Some b0 /\\ find_def ge b0 = Some g.","proofString":"rewrite PTree.gso in B.\nexists b; auto.\napply Plt_ne.\neapply genv_symb_range; eauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (id1 : positive) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : m ! id = Some g <->\n(exists b0 : block, find_symbol ge id = Some b0 /\\ find_def ge b0 = Some g)) (n : id <> id1) (b : block) (A : (genv_symb ge) ! id = Some b) (B : (genv_defs ge) ! b = Some g) : exists b0 : block, find_symbol ge id = Some b0 /\\ find_def ge b0 = Some g.","proofString":"exists b; auto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (id1 : positive) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : m ! id = Some g <->\n(exists b0 : block, find_symbol ge id = Some b0 /\\ find_def ge b0 = Some g)) (n : id <> id1) (b : block) (A : (genv_symb ge) ! id = Some b) (B : (PTree.set (genv_next ge) g1 (genv_defs ge)) ! b = Some g) : b <> genv_next ge.","proofString":"apply Plt_ne.\neapply genv_symb_range; eauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (id1 : positive) (g1 : globdef F V) (l : list (positive * globdef F V)) (IHl : forall (m0 : PTree.tree (globdef F V)) (ge0 : t),\nP m0 ge0 ->\nP\n  (fold_left\n     (fun (m1 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m1) l m0) (add_globals ge0 l)) (m : PTree.tree (globdef F V)) (ge : t) (H : m ! id = Some g <->\n(exists b0 : block, find_symbol ge id = Some b0 /\\ find_def ge b0 = Some g)) (n : id <> id1) (b : block) (A : (genv_symb ge) ! id = Some b) (B : (PTree.set (genv_next ge) g1 (genv_defs ge)) ! b = Some g) : Plt b (genv_next ge).","proofString":"eapply genv_symb_range; eauto."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (REC : forall (l : list (positive * globdef F V)) (m : PTree.tree (globdef F V))\n  (ge : t),\nP m ge ->\nP\n  (fold_left\n     (fun (m0 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m0) l m) (add_globals ge l)) : (PTree.empty (globdef F V)) ! id = Some g <->\n(exists b : block,\n   (PTree.empty block) ! id = Some b /\\\n   (PTree.empty (globdef F V)) ! b = Some g).","proofString":"rewrite ! PTree.gempty.\nsplit.\ncongruence.\nintros (b & A & B); congruence."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (REC : forall (l : list (positive * globdef F V)) (m : PTree.tree (globdef F V))\n  (ge : t),\nP m ge ->\nP\n  (fold_left\n     (fun (m0 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m0) l m) (add_globals ge l)) : None = Some g <->\n(exists b : block, None = Some b /\\ (PTree.empty (globdef F V)) ! b = Some g).","proofString":"split.\ncongruence.\nintros (b & A & B); congruence."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (REC : forall (l : list (positive * globdef F V)) (m : PTree.tree (globdef F V))\n  (ge : t),\nP m ge ->\nP\n  (fold_left\n     (fun (m0 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m0) l m) (add_globals ge l)) : None = Some g ->\nexists b : block, None = Some b /\\ (PTree.empty (globdef F V)) ! b = Some g.","proofString":"congruence."},{"statement":"(p : program F V) (id : positive) (g : globdef F V) (P : PTree.tree (globdef F V) -> t -> Prop) (REC : forall (l : list (positive * globdef F V)) (m : PTree.tree (globdef F V))\n  (ge : t),\nP m ge ->\nP\n  (fold_left\n     (fun (m0 : PTree.tree (globdef F V)) (idg : positive * globdef F V) =>\n      PTree.set idg#1 idg#2 m0) l m) (add_globals ge l)) : (exists b : block, None = Some b /\\ (PTree.empty (globdef F V)) ! b = Some g) ->\nNone = Some g.","proofString":"intros (b & A & B); congruence."},{"statement":"(p : program F V) (id : ident) (g : globdef F V) (H : In (id, g) (prog_defs p)) : exists b : block, find_symbol (globalenv p) id = Some b.","proofString":"unfold globalenv.\neapply add_globals_ensures; eauto.\nintros.\nunfold find_symbol; simpl.\nrewrite PTree.gsspec.\ndestruct (peq id id0).\neconstructor; eauto.\nauto.\nintros.\nunfold find_symbol; simpl.\nrewrite PTree.gss.\neconstructor; eauto."},{"statement":"(p : program F V) (id : ident) (g : globdef F V) (H : In (id, g) (prog_defs p)) : exists b : block,\n  find_symbol (add_globals (empty_genv (prog_public p)) (prog_defs p)) id =\n  Some b.","proofString":"eapply add_globals_ensures; eauto.\nintros.\nunfold find_symbol; simpl.\nrewrite PTree.gsspec.\ndestruct (peq id id0).\neconstructor; eauto.\nauto.\nintros.\nunfold find_symbol; simpl.\nrewrite PTree.gss.\neconstructor; eauto."},{"statement":"(p : program F V) (id : ident) (g : globdef F V) (H : In (id, g) (prog_defs p)) : forall (ge : t) (id0 : ident) (g0 : globdef F V),\n(exists b : block, find_symbol ge id = Some b) ->\nIn (id0, g0) (prog_defs p) ->\nexists b : block, find_symbol (add_global ge (id0, g0)) id = Some b.","proofString":"intros.\nunfold find_symbol; simpl.\nrewrite PTree.gsspec.\ndestruct (peq id id0).\neconstructor; eauto.\nauto."},{"statement":"(p : program F V) (id : ident) (g : globdef F V) (H : In (id, g) (prog_defs p)) (ge : t) (id0 : ident) (g0 : globdef F V) (H0 : exists b : block, find_symbol ge id = Some b) (H1 : In (id0, g0) (prog_defs p)) : exists b : block, find_symbol (add_global ge (id0, g0)) id = Some b.","proofString":"unfold find_symbol; simpl.\nrewrite PTree.gsspec.\ndestruct (peq id id0).\neconstructor; eauto.\nauto."},{"statement":"(p : program F V) (id : ident) (g : globdef F V) (H : In (id, g) (prog_defs p)) (ge : t) (id0 : ident) (g0 : globdef F V) (H0 : exists b : block, find_symbol ge id = Some b) (H1 : In (id0, g0) (prog_defs p)) : exists b : block, (PTree.set id0 (genv_next ge) (genv_symb ge)) ! id = Some b.","proofString":"rewrite PTree.gsspec.\ndestruct (peq id id0).\neconstructor; eauto.\nauto."},{"statement":"(p : program F V) (id : ident) (g : globdef F V) (H : In (id, g) (prog_defs p)) (ge : t) (id0 : ident) (g0 : globdef F V) (H0 : exists b : block, find_symbol ge id = Some b) (H1 : In (id0, g0) (prog_defs p)) : exists b : block,\n  (if peq id id0 then Some (genv_next ge) else (genv_symb ge) ! id) = Some b.","proofString":"destruct (peq id id0).\neconstructor; eauto.\nauto."},{"statement":"(p : program F V) (id : ident) (g : globdef F V) (H : In (id, g) (prog_defs p)) (ge : t) (id0 : ident) (g0 : globdef F V) (H0 : exists b : block, find_symbol ge id = Some b) (H1 : In (id0, g0) (prog_defs p)) (e : id = id0) : exists b : block, Some (genv_next ge) = Some b.","proofString":"econstructor; eauto."},{"statement":"(p : program F V) (id : ident) (g : globdef F V) (H : In (id, g) (prog_defs p)) (ge : t) (id0 : ident) (g0 : globdef F V) (H0 : exists b : block, find_symbol ge id = Some b) (H1 : In (id0, g0) (prog_defs p)) (n : id <> id0) : exists b : block, (genv_symb ge) ! id = Some b.","proofString":"auto."},{"statement":"(p : program F V) (id : ident) (g : globdef F V) (H : In (id, g) (prog_defs p)) : forall ge : t,\nexists b : block, find_symbol (add_global ge (id, g)) id = Some b.","proofString":"intros.\nunfold find_symbol; simpl.\nrewrite PTree.gss.\neconstructor; eauto."},{"statement":"(p : program F V) (id : ident) (g : globdef F V) (H : In (id, g) (prog_defs p)) (ge : t) : exists b : block, find_symbol (add_global ge (id, g)) id = Some b.","proofString":"unfold find_symbol; simpl.\nrewrite PTree.gss.\neconstructor; eauto."},{"statement":"(p : program F V) (id : ident) (g : globdef F V) (H : In (id, g) (prog_defs p)) (ge : t) : exists b : block, (PTree.set id (genv_next ge) (genv_symb ge)) ! id = Some b.","proofString":"rewrite PTree.gss.\neconstructor; eauto."},{"statement":"(p : program F V) (id : ident) (g : globdef F V) (H : In (id, g) (prog_defs p)) (ge : t) : exists b : block, Some (genv_next ge) = Some b.","proofString":"econstructor; eauto."},{"statement":"(p : program F V) (x : ident) (b : block) : find_symbol (add_globals (empty_genv (prog_public p)) (prog_defs p)) x =\nSome b -> In x (prog_defs_names p).","proofString":"eapply add_globals_preserves.\nunfold find_symbol; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x id).\nsubst x.\nchange id with (fst (id, g)).\napply List.in_map; auto.\nauto.\nunfold find_symbol; simpl; intros.\nrewrite PTree.gempty in H.\ndiscriminate."},{"statement":"(p : program F V) (x : ident) (b : block) : forall (ge : t) (id : ident) (g : globdef F V),\n(find_symbol ge x = Some b -> In x (prog_defs_names p)) ->\nIn (id, g) (prog_defs p) ->\nfind_symbol (add_global ge (id, g)) x = Some b -> In x (prog_defs_names p).","proofString":"unfold find_symbol; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq x id).\nsubst x.\nchange id with (fst (id, g)).\napply List.in_map; auto.\nauto."},{"statement":"(p : program F V) (x : ident) (b : block) (ge : t) (id : ident) (g : globdef F V) (H : (genv_symb ge) ! x = Some b -> In x (prog_defs_names p)) (H0 : In (id, g) (prog_defs p)) (H1 : (PTree.set id (genv_next ge) (genv_symb ge)) ! x = Some b) : In x (prog_defs_names p).","proofString":"rewrite PTree.gsspec in H1.\ndestruct (peq x id).\nsubst x.\nchange id with (fst (id, g)).\napply List.in_map; auto.\nauto."},{"statement":"(p : program F V) (x : ident) (b : block) (ge : t) (id : ident) (g : globdef F V) (H : (genv_symb ge) ! x = Some b -> In x (prog_defs_names p)) (H0 : In (id, g) (prog_defs p)) (H1 : (if peq x id then Some (genv_next ge) else (genv_symb ge) ! x) = Some b) : In x (prog_defs_names p).","proofString":"destruct (peq x id).\nsubst x.\nchange id with (fst (id, g)).\napply List.in_map; auto.\nauto."},{"statement":"(p : program F V) (x : ident) (b : block) (ge : t) (id : ident) (g : globdef F V) (H : (genv_symb ge) ! x = Some b -> In x (prog_defs_names p)) (H0 : In (id, g) (prog_defs p)) (e : x = id) (H1 : Some (genv_next ge) = Some b) : In x (prog_defs_names p).","proofString":"subst x.\nchange id with (fst (id, g)).\napply List.in_map; auto."},{"statement":"(p : program F V) (b : block) (ge : t) (id : ident) (g : globdef F V) (H : (genv_symb ge) ! id = Some b -> In id (prog_defs_names p)) (H0 : In (id, g) (prog_defs p)) (H1 : Some (genv_next ge) = Some b) : In id (prog_defs_names p).","proofString":"change id with (fst (id, g)).\napply List.in_map; auto."},{"statement":"(p : program F V) (b : block) (ge : t) (id : ident) (g : globdef F V) (H : (genv_symb ge) ! id = Some b -> In id (prog_defs_names p)) (H0 : In (id, g) (prog_defs p)) (H1 : Some (genv_next ge) = Some b) : In (id, g)#1 (prog_defs_names p).","proofString":"apply List.in_map; auto."},{"statement":"(p : program F V) (x : ident) (b : block) (ge : t) (id : ident) (g : globdef F V) (H : (genv_symb ge) ! x = Some b -> In x (prog_defs_names p)) (H0 : In (id, g) (prog_defs p)) (n : x <> id) (H1 : (genv_symb ge) ! x = Some b) : In x (prog_defs_names p).","proofString":"auto."},{"statement":"(p : program F V) (x : ident) (b : block) : find_symbol (empty_genv (prog_public p)) x = Some b ->\nIn x (prog_defs_names p).","proofString":"unfold find_symbol; simpl; intros.\nrewrite PTree.gempty in H.\ndiscriminate."},{"statement":"(p : program F V) (x : ident) (b : block) (H : (PTree.empty block) ! x = Some b) : In x (prog_defs_names p).","proofString":"rewrite PTree.gempty in H.\ndiscriminate."},{"statement":"(p : program F V) (x : ident) (b : block) (H : None = Some b) : In x (prog_defs_names p).","proofString":"discriminate."},{"statement":"(p : program F V) (b : block) (g : globdef F V) : find_def (globalenv p) b = Some g ->\nexists id : ident, In (id, g) (prog_defs p).","proofString":"unfold globalenv.\napply add_globals_preserves.\nunfold find_def; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq b (genv_next ge)).\ninv H1.\nexists id; auto.\nauto.\nunfold find_def; simpl; intros.\nrewrite PTree.gempty in H.\ndiscriminate."},{"statement":"(p : program F V) (b : block) (g : globdef F V) : find_def (add_globals (empty_genv (prog_public p)) (prog_defs p)) b = Some g ->\nexists id : ident, In (id, g) (prog_defs p).","proofString":"apply add_globals_preserves.\nunfold find_def; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq b (genv_next ge)).\ninv H1.\nexists id; auto.\nauto.\nunfold find_def; simpl; intros.\nrewrite PTree.gempty in H.\ndiscriminate."},{"statement":"(p : program F V) (b : block) (g : globdef F V) : forall (ge : t) (id : ident) (g0 : globdef F V),\n(find_def ge b = Some g -> exists id0 : ident, In (id0, g) (prog_defs p)) ->\nIn (id, g0) (prog_defs p) ->\nfind_def (add_global ge (id, g0)) b = Some g ->\nexists id0 : ident, In (id0, g) (prog_defs p).","proofString":"unfold find_def; simpl; intros.\nrewrite PTree.gsspec in H1.\ndestruct (peq b (genv_next ge)).\ninv H1.\nexists id; auto.\nauto."},{"statement":"(p : program F V) (b : block) (g : globdef F V) (ge : t) (id : ident) (g0 : globdef F V) (H : (genv_defs ge) ! b = Some g -> exists id0 : ident, In (id0, g) (prog_defs p)) (H0 : In (id, g0) (prog_defs p)) (H1 : (PTree.set (genv_next ge) g0 (genv_defs ge)) ! b = Some g) : exists id0 : ident, In (id0, g) (prog_defs p).","proofString":"rewrite PTree.gsspec in H1.\ndestruct (peq b (genv_next ge)).\ninv H1.\nexists id; auto.\nauto."},{"statement":"(p : program F V) (b : block) (g : globdef F V) (ge : t) (id : ident) (g0 : globdef F V) (H : (genv_defs ge) ! b = Some g -> exists id0 : ident, In (id0, g) (prog_defs p)) (H0 : In (id, g0) (prog_defs p)) (H1 : (if peq b (genv_next ge) then Some g0 else (genv_defs ge) ! b) = Some g) : exists id0 : ident, In (id0, g) (prog_defs p).","proofString":"destruct (peq b (genv_next ge)).\ninv H1.\nexists id; auto.\nauto."},{"statement":"(p : program F V) (b : block) (g : globdef F V) (ge : t) (id : ident) (g0 : globdef F V) (H : (genv_defs ge) ! b = Some g -> exists id0 : ident, In (id0, g) (prog_defs p)) (H0 : In (id, g0) (prog_defs p)) (e : b = genv_next ge) (H1 : Some g0 = Some g) : exists id0 : ident, In (id0, g) (prog_defs p).","proofString":"inv H1.\nexists id; auto."},{"statement":"(p : program F V) (g : globdef F V) (ge : t) (id : ident) (H : (genv_defs ge) ! (genv_next ge) = Some g ->\nexists id0 : ident, In (id0, g) (prog_defs p)) (H0 : In (id, g) (prog_defs p)) : exists id0 : ident, In (id0, g) (prog_defs p).","proofString":"exists id; auto."},{"statement":"(p : program F V) (b : block) (g : globdef F V) (ge : t) (id : ident) (g0 : globdef F V) (H : (genv_defs ge) ! b = Some g -> exists id0 : ident, In (id0, g) (prog_defs p)) (H0 : In (id, g0) (prog_defs p)) (n : b <> genv_next ge) (H1 : (genv_defs ge) ! b = Some g) : exists id0 : ident, In (id0, g) (prog_defs p).","proofString":"auto."},{"statement":"(p : program F V) (b : block) (g : globdef F V) : find_def (empty_genv (prog_public p)) b = Some g ->\nexists id : ident, In (id, g) (prog_defs p).","proofString":"unfold find_def; simpl; intros.\nrewrite PTree.gempty in H.\ndiscriminate."},{"statement":"(p : program F V) (b : block) (g : globdef F V) (H : (PTree.empty (globdef F V)) ! b = Some g) : exists id : ident, In (id, g) (prog_defs p).","proofString":"rewrite PTree.gempty in H.\ndiscriminate."},{"statement":"(p : program F V) (b : block) (g : globdef F V) (H : None = Some g) : exists id : ident, In (id, g) (prog_defs p).","proofString":"discriminate."},{"statement":"(p : program F V) (b : block) (f : F) (H : find_funct_ptr (globalenv p) b = Some f) : exists id : ident, In (id, Gfun f) (prog_defs p).","proofString":"apply find_def_inversion with b.\napply find_funct_ptr_iff; auto."},{"statement":"(p : program F V) (b : block) (f : F) (H : find_funct_ptr (globalenv p) b = Some f) : find_def (globalenv p) b = Some (Gfun f).","proofString":"apply find_funct_ptr_iff; auto."},{"statement":"(p : program F V) (v : val) (f : F) (H : find_funct (globalenv p) v = Some f) : exists id : ident, In (id, Gfun f) (prog_defs p).","proofString":"exploit find_funct_inv; eauto.\nintros [b EQ].\nsubst v.\nrewrite find_funct_find_funct_ptr in H.\neapply find_funct_ptr_inversion; eauto."},{"statement":"(p : program F V) (v : val) (f : F) (H : find_funct (globalenv p) v = Some f) : (exists b : block, v = Vptr b Ptrofs.zero) ->\nexists id : ident, In (id, Gfun f) (prog_defs p).","proofString":"intros [b EQ].\nsubst v.\nrewrite find_funct_find_funct_ptr in H.\neapply find_funct_ptr_inversion; eauto."},{"statement":"(p : program F V) (v : val) (f : F) (H : find_funct (globalenv p) v = Some f) (b : block) (EQ : v = Vptr b Ptrofs.zero) : exists id : ident, In (id, Gfun f) (prog_defs p).","proofString":"subst v.\nrewrite find_funct_find_funct_ptr in H.\neapply find_funct_ptr_inversion; eauto."},{"statement":"(p : program F V) (f : F) (b : block) (H : find_funct (globalenv p) (Vptr b Ptrofs.zero) = Some f) : exists id : ident, In (id, Gfun f) (prog_defs p).","proofString":"rewrite find_funct_find_funct_ptr in H.\neapply find_funct_ptr_inversion; eauto."},{"statement":"(p : program F V) (f : F) (b : block) (H : find_funct_ptr (globalenv p) b = Some f) : exists id : ident, In (id, Gfun f) (prog_defs p).","proofString":"eapply find_funct_ptr_inversion; eauto."},{"statement":"(P : F -> Prop) (p : program F V) (b : block) (f : F) (H : forall (id : ident) (f0 : F), In (id, Gfun f0) (prog_defs p) -> P f0) (H0 : find_funct_ptr (globalenv p) b = Some f) : P f.","proofString":"exploit find_funct_ptr_inversion; eauto.\nintros [id IN].\neauto."},{"statement":"(P : F -> Prop) (p : program F V) (b : block) (f : F) (H : forall (id : ident) (f0 : F), In (id, Gfun f0) (prog_defs p) -> P f0) (H0 : find_funct_ptr (globalenv p) b = Some f) : (exists id : ident, In (id, Gfun f) (prog_defs p)) -> P f.","proofString":"intros [id IN].\neauto."},{"statement":"(P : F -> Prop) (p : program F V) (b : block) (f : F) (H : forall (id0 : ident) (f0 : F), In (id0, Gfun f0) (prog_defs p) -> P f0) (H0 : find_funct_ptr (globalenv p) b = Some f) (id : ident) (IN : In (id, Gfun f) (prog_defs p)) : P f.","proofString":"eauto."},{"statement":"(P : F -> Prop) (p : program F V) (v : val) (f : F) (H : forall (id : ident) (f0 : F), In (id, Gfun f0) (prog_defs p) -> P f0) (H0 : find_funct (globalenv p) v = Some f) : P f.","proofString":"exploit find_funct_inversion; eauto.\nintros [id IN].\neauto."},{"statement":"(P : F -> Prop) (p : program F V) (v : val) (f : F) (H : forall (id : ident) (f0 : F), In (id, Gfun f0) (prog_defs p) -> P f0) (H0 : find_funct (globalenv p) v = Some f) : (exists id : ident, In (id, Gfun f) (prog_defs p)) -> P f.","proofString":"intros [id IN].\neauto."},{"statement":"(P : F -> Prop) (p : program F V) (v : val) (f : F) (H : forall (id0 : ident) (f0 : F), In (id0, Gfun f0) (prog_defs p) -> P f0) (H0 : find_funct (globalenv p) v = Some f) (id : ident) (IN : In (id, Gfun f) (prog_defs p)) : P f.","proofString":"eauto."},{"statement":"(ge : t) (id1 id2 : ident) (b1 b2 : block) (H : id1 <> id2) (H0 : find_symbol ge id1 = Some b1) (H1 : find_symbol ge id2 = Some b2) : b1 <> b2.","proofString":"red; intros; subst.\nelim H.\ndestruct ge.\neauto."},{"statement":"(ge : t) (id1 id2 : ident) (b2 : block) (H : id1 <> id2) (H0 : find_symbol ge id1 = Some b2) (H1 : find_symbol ge id2 = Some b2) : False.","proofString":"elim H.\ndestruct ge.\neauto."},{"statement":"(ge : t) (id1 id2 : ident) (b2 : block) (H : id1 <> id2) (H0 : find_symbol ge id1 = Some b2) (H1 : find_symbol ge id2 = Some b2) : id1 = id2.","proofString":"destruct ge.\neauto."},{"statement":"(genv_public0 : list ident) (genv_symb0 : PTree.t block) (genv_defs0 : PTree.t (globdef F V)) (genv_next0 : block) (genv_symb_range0 : forall (id : positive) (b : block),\ngenv_symb0 ! id = Some b -> Plt b genv_next0) (genv_defs_range0 : forall (b : positive) (g : globdef F V),\ngenv_defs0 ! b = Some g -> Plt b genv_next0) (genv_vars_inj0 : forall (id0 id3 : positive) (b : block),\ngenv_symb0 ! id0 = Some b -> genv_symb0 ! id3 = Some b -> id0 = id3) (id1 id2 : ident) (b2 : block) (H : id1 <> id2) (H0 : find_symbol\n  {|\n    genv_public := genv_public0;\n    genv_symb := genv_symb0;\n    genv_defs := genv_defs0;\n    genv_next := genv_next0;\n    genv_symb_range := genv_symb_range0;\n    genv_defs_range := genv_defs_range0;\n    genv_vars_inj := genv_vars_inj0\n  |} id1 = Some b2) (H1 : find_symbol\n  {|\n    genv_public := genv_public0;\n    genv_symb := genv_symb0;\n    genv_defs := genv_defs0;\n    genv_next := genv_next0;\n    genv_symb_range := genv_symb_range0;\n    genv_defs_range := genv_defs_range0;\n    genv_vars_inj := genv_vars_inj0\n  |} id2 = Some b2) : id1 = id2.","proofString":"eauto."},{"statement":"(ge : t) (id : ident) (b : block) : PTree.fold\n  (fun (res : option positive) (id0 b' : positive) =>\n   if eq_block b b' then Some id0 else res) (genv_symb ge) None = \nSome id -> (genv_symb ge) ! id = Some b.","proofString":"apply PTree_Properties.fold_rec.\nintros.\nrewrite H in H0; auto.\ncongruence.\nintros.\ndestruct (eq_block b v).\ninv H2.\napply PTree.gss.\nrewrite PTree.gsspec.\ndestruct (peq id k).\nsubst.\nassert (m!k = Some b) by auto.\ncongruence.\nauto."},{"statement":"(ge : t) (id : ident) (b : block) : forall (m m' : PTree.t positive) (a : option positive),\n(forall x : PTree.elt, m ! x = m' ! x) ->\n(a = Some id -> m ! id = Some b) -> a = Some id -> m' ! id = Some b.","proofString":"intros.\nrewrite H in H0; auto."},{"statement":"(ge : t) (id : ident) (b : block) (m m' : PTree.t positive) (a : option positive) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : a = Some id -> m ! id = Some b) (H1 : a = Some id) : m' ! id = Some b.","proofString":"rewrite H in H0; auto."},{"statement":"(ge : t) (id : ident) (b : block) : None = Some id -> (PTree.empty positive) ! id = Some b.","proofString":"congruence."},{"statement":"(ge : t) (id : ident) (b : block) : forall (m : PTree.t positive) (a : option positive) \n  (k : PTree.elt) (v : positive),\nm ! k = None ->\n(genv_symb ge) ! k = Some v ->\n(a = Some id -> m ! id = Some b) ->\n(if eq_block b v then Some k else a) = Some id ->\n(PTree.set k v m) ! id = Some b.","proofString":"intros.\ndestruct (eq_block b v).\ninv H2.\napply PTree.gss.\nrewrite PTree.gsspec.\ndestruct (peq id k).\nsubst.\nassert (m!k = Some b) by auto.\ncongruence.\nauto."},{"statement":"(ge : t) (id : ident) (b : block) (m : PTree.t positive) (a : option positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : a = Some id -> m ! id = Some b) (H2 : (if eq_block b v then Some k else a) = Some id) : (PTree.set k v m) ! id = Some b.","proofString":"destruct (eq_block b v).\ninv H2.\napply PTree.gss.\nrewrite PTree.gsspec.\ndestruct (peq id k).\nsubst.\nassert (m!k = Some b) by auto.\ncongruence.\nauto."},{"statement":"(ge : t) (id : ident) (b : block) (m : PTree.t positive) (a : option positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : a = Some id -> m ! id = Some b) (e : b = v) (H2 : Some k = Some id) : (PTree.set k v m) ! id = Some b.","proofString":"inv H2.\napply PTree.gss."},{"statement":"(ge : t) (id : ident) (m : PTree.t positive) (a : option positive) (v : positive) (H0 : (genv_symb ge) ! id = Some v) (H : m ! id = None) (H1 : a = Some id -> m ! id = Some v) : (PTree.set id v m) ! id = Some v.","proofString":"apply PTree.gss."},{"statement":"(ge : t) (id : ident) (b : block) (m : PTree.t positive) (a : option positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : a = Some id -> m ! id = Some b) (n : b <> v) (H2 : a = Some id) : (PTree.set k v m) ! id = Some b.","proofString":"rewrite PTree.gsspec.\ndestruct (peq id k).\nsubst.\nassert (m!k = Some b) by auto.\ncongruence.\nauto."},{"statement":"(ge : t) (id : ident) (b : block) (m : PTree.t positive) (a : option positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : a = Some id -> m ! id = Some b) (n : b <> v) (H2 : a = Some id) : (if peq id k then Some v else m ! id) = Some b.","proofString":"destruct (peq id k).\nsubst.\nassert (m!k = Some b) by auto.\ncongruence.\nauto."},{"statement":"(ge : t) (id : ident) (b : block) (m : PTree.t positive) (a : option positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : a = Some id -> m ! id = Some b) (n : b <> v) (H2 : a = Some id) (e : id = k) : Some v = Some b.","proofString":"subst.\nassert (m!k = Some b) by auto.\ncongruence."},{"statement":"(ge : t) (b : block) (m : PTree.t positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : Some k = Some k -> m ! k = Some b) (n : b <> v) : Some v = Some b.","proofString":"assert (m!k = Some b) by auto.\ncongruence."},{"statement":"(ge : t) (b : block) (m : PTree.t positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : Some k = Some k -> m ! k = Some b) (n : b <> v) (H2 : m ! k = Some b) : Some v = Some b.","proofString":"congruence."},{"statement":"(ge : t) (id : ident) (b : block) (m : PTree.t positive) (a : option positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : a = Some id -> m ! id = Some b) (n : b <> v) (H2 : a = Some id) (n0 : id <> k) : m ! id = Some b.","proofString":"auto."},{"statement":"(ge : t) (id : ident) (b : block) : find_symbol ge id = Some b -> invert_symbol ge b = Some id.","proofString":"assert (find_symbol ge id = Some b -> exists id', invert_symbol ge b = Some id').\nunfold find_symbol, invert_symbol.\napply PTree_Properties.fold_rec.\nintros.\nrewrite H in H0; auto.\nrewrite PTree.gempty; congruence.\nintros.\ndestruct (eq_block b v).\nexists k; auto.\nrewrite PTree.gsspec in H2.\ndestruct (peq id k).\ninv H2.\ncongruence.\nauto.\nintros; exploit H; eauto.\nintros [id' A].\nassert (id = id').\neapply genv_vars_inj; eauto.\napply invert_find_symbol; auto.\ncongruence."},{"statement":"(ge : t) (id : ident) (b : block) : find_symbol ge id = Some b ->\nexists id' : ident, invert_symbol ge b = Some id'.","proofString":"unfold find_symbol, invert_symbol.\napply PTree_Properties.fold_rec.\nintros.\nrewrite H in H0; auto.\nrewrite PTree.gempty; congruence.\nintros.\ndestruct (eq_block b v).\nexists k; auto.\nrewrite PTree.gsspec in H2.\ndestruct (peq id k).\ninv H2.\ncongruence.\nauto."},{"statement":"(ge : t) (id : ident) (b : block) : (genv_symb ge) ! id = Some b ->\nexists id' : ident,\n  PTree.fold\n    (fun (res : option positive) (id0 b' : positive) =>\n     if eq_block b b' then Some id0 else res) (genv_symb ge) None = \n  Some id'.","proofString":"apply PTree_Properties.fold_rec.\nintros.\nrewrite H in H0; auto.\nrewrite PTree.gempty; congruence.\nintros.\ndestruct (eq_block b v).\nexists k; auto.\nrewrite PTree.gsspec in H2.\ndestruct (peq id k).\ninv H2.\ncongruence.\nauto."},{"statement":"(ge : t) (id : ident) (b : block) : forall (m m' : PTree.t positive) (a : option positive),\n(forall x : PTree.elt, m ! x = m' ! x) ->\n(m ! id = Some b -> exists id' : ident, a = Some id') ->\nm' ! id = Some b -> exists id' : ident, a = Some id'.","proofString":"intros.\nrewrite H in H0; auto."},{"statement":"(ge : t) (id : ident) (b : block) (m m' : PTree.t positive) (a : option positive) (H : forall x : PTree.elt, m ! x = m' ! x) (H0 : m ! id = Some b -> exists id' : ident, a = Some id') (H1 : m' ! id = Some b) : exists id' : ident, a = Some id'.","proofString":"rewrite H in H0; auto."},{"statement":"(ge : t) (id : ident) (b : block) : (PTree.empty positive) ! id = Some b -> exists id' : ident, None = Some id'.","proofString":"rewrite PTree.gempty; congruence."},{"statement":"(ge : t) (id : ident) (b : block) : forall (m : PTree.t positive) (a : option positive) \n  (k : PTree.elt) (v : positive),\nm ! k = None ->\n(genv_symb ge) ! k = Some v ->\n(m ! id = Some b -> exists id' : ident, a = Some id') ->\n(PTree.set k v m) ! id = Some b ->\nexists id' : ident, (if eq_block b v then Some k else a) = Some id'.","proofString":"intros.\ndestruct (eq_block b v).\nexists k; auto.\nrewrite PTree.gsspec in H2.\ndestruct (peq id k).\ninv H2.\ncongruence.\nauto."},{"statement":"(ge : t) (id : ident) (b : block) (m : PTree.t positive) (a : option positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : m ! id = Some b -> exists id' : ident, a = Some id') (H2 : (PTree.set k v m) ! id = Some b) : exists id' : ident, (if eq_block b v then Some k else a) = Some id'.","proofString":"destruct (eq_block b v).\nexists k; auto.\nrewrite PTree.gsspec in H2.\ndestruct (peq id k).\ninv H2.\ncongruence.\nauto."},{"statement":"(ge : t) (id : ident) (b : block) (m : PTree.t positive) (a : option positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : m ! id = Some b -> exists id' : ident, a = Some id') (H2 : (PTree.set k v m) ! id = Some b) (e : b = v) : exists id' : ident, Some k = Some id'.","proofString":"exists k; auto."},{"statement":"(ge : t) (id : ident) (b : block) (m : PTree.t positive) (a : option positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : m ! id = Some b -> exists id' : ident, a = Some id') (H2 : (PTree.set k v m) ! id = Some b) (n : b <> v) : exists id' : ident, a = Some id'.","proofString":"rewrite PTree.gsspec in H2.\ndestruct (peq id k).\ninv H2.\ncongruence.\nauto."},{"statement":"(ge : t) (id : ident) (b : block) (m : PTree.t positive) (a : option positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : m ! id = Some b -> exists id' : ident, a = Some id') (H2 : (if peq id k then Some v else m ! id) = Some b) (n : b <> v) : exists id' : ident, a = Some id'.","proofString":"destruct (peq id k).\ninv H2.\ncongruence.\nauto."},{"statement":"(ge : t) (id : ident) (b : block) (m : PTree.t positive) (a : option positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : m ! id = Some b -> exists id' : ident, a = Some id') (e : id = k) (H2 : Some v = Some b) (n : b <> v) : exists id' : ident, a = Some id'.","proofString":"inv H2.\ncongruence."},{"statement":"(ge : t) (b : block) (m : PTree.t positive) (a : option positive) (k : PTree.elt) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some b) (H1 : m ! k = Some b -> exists id' : ident, a = Some id') (n : b <> b) : exists id' : ident, a = Some id'.","proofString":"congruence."},{"statement":"(ge : t) (id : ident) (b : block) (m : PTree.t positive) (a : option positive) (k : PTree.elt) (v : positive) (H : m ! k = None) (H0 : (genv_symb ge) ! k = Some v) (H1 : m ! id = Some b -> exists id' : ident, a = Some id') (n0 : id <> k) (H2 : m ! id = Some b) (n : b <> v) : exists id' : ident, a = Some id'.","proofString":"auto."},{"statement":"(ge : t) (id : ident) (b : block) (H : find_symbol ge id = Some b ->\nexists id' : ident, invert_symbol ge b = Some id') : find_symbol ge id = Some b -> invert_symbol ge b = Some id.","proofString":"intros; exploit H; eauto.\nintros [id' A].\nassert (id = id').\neapply genv_vars_inj; eauto.\napply invert_find_symbol; auto.\ncongruence."},{"statement":"(ge : t) (id : ident) (b : block) (H : find_symbol ge id = Some b ->\nexists id' : ident, invert_symbol ge b = Some id') (H0 : find_symbol ge id = Some b) : (exists id' : ident, invert_symbol ge b = Some id') ->\ninvert_symbol ge b = Some id.","proofString":"intros [id' A].\nassert (id = id').\neapply genv_vars_inj; eauto.\napply invert_find_symbol; auto.\ncongruence."},{"statement":"(ge : t) (id : ident) (b : block) (H : find_symbol ge id = Some b ->\nexists id'0 : ident, invert_symbol ge b = Some id'0) (H0 : find_symbol ge id = Some b) (id' : ident) (A : invert_symbol ge b = Some id') : invert_symbol ge b = Some id.","proofString":"assert (id = id').\neapply genv_vars_inj; eauto.\napply invert_find_symbol; auto.\ncongruence."},{"statement":"(ge : t) (id : ident) (b : block) (H : find_symbol ge id = Some b ->\nexists id'0 : ident, invert_symbol ge b = Some id'0) (H0 : find_symbol ge id = Some b) (id' : ident) (A : invert_symbol ge b = Some id') : id = id'.","proofString":"eapply genv_vars_inj; eauto.\napply invert_find_symbol; auto."},{"statement":"(ge : t) (id : ident) (b : block) (H : find_symbol ge id = Some b ->\nexists id'0 : ident, invert_symbol ge b = Some id'0) (H0 : find_symbol ge id = Some b) (id' : ident) (A : invert_symbol ge b = Some id') : (genv_symb ge) ! id' = Some b.","proofString":"apply invert_find_symbol; auto."},{"statement":"(ge : t) (id : ident) (b : block) (H : find_symbol ge id = Some b ->\nexists id'0 : ident, invert_symbol ge b = Some id'0) (H0 : find_symbol ge id = Some b) (id' : ident) (A : invert_symbol ge b = Some id') (H1 : id = id') : invert_symbol ge b = Some id.","proofString":"congruence."},{"statement":"(ge : t) : genv_next ge = genv_next ge.","proofString":"auto."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall ge0 : t,\ngenv_next (add_globals ge0 gl) = advance_next gl (genv_next ge0)) (ge : t) : genv_next (add_globals (add_global ge a) gl) =\nadvance_next gl (Pos.succ (genv_next ge)).","proofString":"rewrite IHgl.\nauto."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall ge0 : t,\ngenv_next (add_globals ge0 gl) = advance_next gl (genv_next ge0)) (ge : t) : advance_next gl (genv_next (add_global ge a)) =\nadvance_next gl (Pos.succ (genv_next ge)).","proofString":"auto."},{"statement":"(ge : t) : genv_public ge = genv_public ge.","proofString":"auto."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall ge0 : t, genv_public (add_globals ge0 gl) = genv_public ge0) (ge : t) : genv_public (add_globals (add_global ge a) gl) = genv_public ge.","proofString":"rewrite IHgl; auto."},{"statement":"(p : program F V) : genv_public (add_globals (empty_genv (prog_public p)) (prog_defs p)) =\nprog_public p.","proofString":"rewrite genv_public_add_globals.\nauto."},{"statement":"(p : program F V) : genv_public (empty_genv (prog_public p)) = prog_public p.","proofString":"auto."},{"statement":"(ge : t) (b : block) (H : match find_var_info ge b with\n| Some gv => gvar_volatile gv\n| None => false\nend = true) : Plt b (genv_next ge).","proofString":"destruct (find_var_info ge b) as [gv|] eqn:FV.\nrewrite find_var_info_iff in FV.\neapply genv_defs_range; eauto.\ndiscriminate."},{"statement":"(ge : t) (b : block) (gv : globvar V) (FV : find_var_info ge b = Some gv) (H : gvar_volatile gv = true) : Plt b (genv_next ge).","proofString":"rewrite find_var_info_iff in FV.\neapply genv_defs_range; eauto."},{"statement":"(ge : t) (b : block) (gv : globvar V) (FV : find_def ge b = Some (Gvar gv)) (H : gvar_volatile gv = true) : Plt b (genv_next ge).","proofString":"eapply genv_defs_range; eauto."},{"statement":"(ge : t) (b : block) (FV : find_var_info ge b = None) (H : false = true) : Plt b (genv_next ge).","proofString":"discriminate."},{"statement":"forall (gl2 : list (ident * globdef F V)) (m m1 : mem),\nalloc_globals m nil = Some m1 ->\nalloc_globals m1 gl2 = alloc_globals m (nil ++ gl2).","proofString":"simpl.\nintros.\ninversion H; subst.\nauto."},{"statement":"forall (gl2 : list (ident * globdef F V)) (m m1 : mem),\nSome m = Some m1 -> alloc_globals m1 gl2 = alloc_globals m gl2.","proofString":"intros.\ninversion H; subst.\nauto."},{"statement":"(gl2 : list (ident * globdef F V)) (m m1 : mem) (H : Some m = Some m1) : alloc_globals m1 gl2 = alloc_globals m gl2.","proofString":"inversion H; subst.\nauto."},{"statement":"(gl2 : list (ident * globdef F V)) (m1 : mem) (H : Some m1 = Some m1) : alloc_globals m1 gl2 = alloc_globals m1 gl2.","proofString":"auto."},{"statement":"(a : ident * globdef F V) (gl1 : list (ident * globdef F V)) (IHgl1 : forall (gl2 : list (ident * globdef F V)) (m m1 : mem),\nalloc_globals m gl1 = Some m1 ->\nalloc_globals m1 gl2 = alloc_globals m (gl1 ++ gl2)) : forall (gl2 : list (ident * globdef F V)) (m m1 : mem),\nalloc_globals m (a :: gl1) = Some m1 ->\nalloc_globals m1 gl2 = alloc_globals m ((a :: gl1) ++ gl2).","proofString":"simpl.\nintros.\ndestruct (alloc_global m a); eauto.\ninversion H."},{"statement":"(a : ident * globdef F V) (gl1 : list (ident * globdef F V)) (IHgl1 : forall (gl2 : list (ident * globdef F V)) (m m1 : mem),\nalloc_globals m gl1 = Some m1 ->\nalloc_globals m1 gl2 = alloc_globals m (gl1 ++ gl2)) : forall (gl2 : list (ident * globdef F V)) (m m1 : mem),\nmatch alloc_global m a with\n| Some m' => alloc_globals m' gl1\n| None => None\nend = Some m1 ->\nalloc_globals m1 gl2 =\nmatch alloc_global m a with\n| Some m' => alloc_globals m' (gl1 ++ gl2)\n| None => None\nend.","proofString":"intros.\ndestruct (alloc_global m a); eauto.\ninversion H."},{"statement":"(a : ident * globdef F V) (gl1 : list (ident * globdef F V)) (IHgl1 : forall (gl0 : list (ident * globdef F V)) (m0 m2 : mem),\nalloc_globals m0 gl1 = Some m2 ->\nalloc_globals m2 gl0 = alloc_globals m0 (gl1 ++ gl0)) (gl2 : list (ident * globdef F V)) (m m1 : mem) (H : match alloc_global m a with\n| Some m' => alloc_globals m' gl1\n| None => None\nend = Some m1) : alloc_globals m1 gl2 =\nmatch alloc_global m a with\n| Some m' => alloc_globals m' (gl1 ++ gl2)\n| None => None\nend.","proofString":"destruct (alloc_global m a); eauto.\ninversion H."},{"statement":"(a : ident * globdef F V) (gl1 : list (ident * globdef F V)) (IHgl1 : forall (gl0 : list (ident * globdef F V)) (m0 m2 : mem),\nalloc_globals m0 gl1 = Some m2 ->\nalloc_globals m2 gl0 = alloc_globals m0 (gl1 ++ gl0)) (gl2 : list (ident * globdef F V)) (m m1 : mem) (H : None = Some m1) : alloc_globals m1 gl2 = None.","proofString":"inversion H."},{"statement":"(m : mem) (b : block) (p n : Z) : forall m' : mem,\nstore_zeros m b p n = Some m' -> Mem.nextblock m' = Mem.nextblock m.","proofString":"functional induction (store_zeros m b p n); intros.\ninv H; auto.\nrewrite IHo; eauto with mem.\ncongruence."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H : Some m = Some m') : Mem.nextblock m' = Mem.nextblock m.","proofString":"inv H; auto."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nMem.nextblock m'1 = Mem.nextblock m') (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) : Mem.nextblock m'0 = Mem.nextblock m.","proofString":"rewrite IHo; eauto with mem."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (m' : mem) (H : None = Some m') : Mem.nextblock m' = Mem.nextblock m.","proofString":"congruence."},{"statement":"(b : block) (m : mem) (p : Z) (m' : mem) : Some m = Some m' -> Mem.nextblock m' = Mem.nextblock m.","proofString":"intros.\ncongruence."},{"statement":"(b : block) (m : mem) (p : Z) (m' : mem) (H : Some m = Some m') : Mem.nextblock m' = Mem.nextblock m.","proofString":"congruence."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (b0 : block) (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b0 p0 idl = Some m'0 ->\nMem.nextblock m'0 = Mem.nextblock m0) (b : block) (m : mem) (p : Z) (m' : mem) : match store_init_data m b p a with\n| Some m'0 => store_init_data_list m'0 b (p + init_data_size a) idl\n| None => None\nend = Some m' -> Mem.nextblock m' = Mem.nextblock m.","proofString":"caseEq (store_init_data m b p a); try congruence.\nintros.\ntransitivity (Mem.nextblock m0).\neauto.\ndestruct a; simpl in H; try (eapply Mem.nextblock_store; eauto; fail).\ncongruence.\ndestruct (find_symbol ge i); try congruence.\neapply Mem.nextblock_store; eauto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (b0 : block) (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b0 p0 idl = Some m'0 ->\nMem.nextblock m'0 = Mem.nextblock m0) (b : block) (m : mem) (p : Z) (m' : mem) : forall m0 : mem,\nstore_init_data m b p a = Some m0 ->\nstore_init_data_list m0 b (p + init_data_size a) idl = Some m' ->\nMem.nextblock m' = Mem.nextblock m.","proofString":"intros.\ntransitivity (Mem.nextblock m0).\neauto.\ndestruct a; simpl in H; try (eapply Mem.nextblock_store; eauto; fail).\ncongruence.\ndestruct (find_symbol ge i); try congruence.\neapply Mem.nextblock_store; eauto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (b0 : block) (m1 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m1 b0 p0 idl = Some m'0 ->\nMem.nextblock m'0 = Mem.nextblock m1) (b : block) (m : mem) (p : Z) (m' m0 : mem) (H : store_init_data m b p a = Some m0) (H0 : store_init_data_list m0 b (p + init_data_size a) idl = Some m') : Mem.nextblock m' = Mem.nextblock m.","proofString":"transitivity (Mem.nextblock m0).\neauto.\ndestruct a; simpl in H; try (eapply Mem.nextblock_store; eauto; fail).\ncongruence.\ndestruct (find_symbol ge i); try congruence.\neapply Mem.nextblock_store; eauto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (b0 : block) (m1 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m1 b0 p0 idl = Some m'0 ->\nMem.nextblock m'0 = Mem.nextblock m1) (b : block) (m : mem) (p : Z) (m' m0 : mem) (H : store_init_data m b p a = Some m0) (H0 : store_init_data_list m0 b (p + init_data_size a) idl = Some m') : Mem.nextblock m' = Mem.nextblock m0.","proofString":"eauto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (b0 : block) (m1 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m1 b0 p0 idl = Some m'0 ->\nMem.nextblock m'0 = Mem.nextblock m1) (b : block) (m : mem) (p : Z) (m' m0 : mem) (H : store_init_data m b p a = Some m0) (H0 : store_init_data_list m0 b (p + init_data_size a) idl = Some m') : Mem.nextblock m0 = Mem.nextblock m.","proofString":"destruct a; simpl in H; try (eapply Mem.nextblock_store; eauto; fail).\ncongruence.\ndestruct (find_symbol ge i); try congruence.\neapply Mem.nextblock_store; eauto."},{"statement":"(z : Z) (idl : list init_data) (IHidl : forall (b0 : block) (m1 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m1 b0 p0 idl = Some m'0 ->\nMem.nextblock m'0 = Mem.nextblock m1) (b : block) (m : mem) (p : Z) (m' m0 : mem) (H : Some m = Some m0) (H0 : store_init_data_list m0 b (p + init_data_size (Init_space z)) idl = Some m') : Mem.nextblock m0 = Mem.nextblock m.","proofString":"congruence."},{"statement":"(i : ident) (i0 : ptrofs) (idl : list init_data) (IHidl : forall (b0 : block) (m1 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m1 b0 p0 idl = Some m'0 ->\nMem.nextblock m'0 = Mem.nextblock m1) (b : block) (m : mem) (p : Z) (m' m0 : mem) (H : match find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m0) (H0 : store_init_data_list m0 b (p + init_data_size (Init_addrof i i0)) idl =\nSome m') : Mem.nextblock m0 = Mem.nextblock m.","proofString":"destruct (find_symbol ge i); try congruence.\neapply Mem.nextblock_store; eauto."},{"statement":"(i : ident) (i0 : ptrofs) (idl : list init_data) (IHidl : forall (b1 : block) (m1 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m1 b1 p0 idl = Some m'0 ->\nMem.nextblock m'0 = Mem.nextblock m1) (b : block) (m : mem) (p : Z) (m' m0 : mem) (b0 : block) (H : Mem.store Mptr m b p (Vptr b0 i0) = Some m0) (H0 : store_init_data_list m0 b (p + init_data_size (Init_addrof i i0)) idl =\nSome m') : Mem.nextblock m0 = Mem.nextblock m.","proofString":"eapply Mem.nextblock_store; eauto."},{"statement":"forall (g : ident * globdef F V) (m m' : mem),\n(let (_, g0) := g in\n match g0 with\n | Gfun _ =>\n     let (m1, b) := Mem.alloc m 0 1 in Mem.drop_perm m1 b 0 1 Nonempty\n | Gvar v =>\n     let (m1, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n     match store_zeros m1 b 0 (init_data_list_size (gvar_init v)) with\n     | Some m2 =>\n         match store_init_data_list m2 b 0 (gvar_init v) with\n         | Some m3 =>\n             Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n               (perm_globvar v)\n         | None => None\n         end\n     | None => None\n     end\n end) = Some m' -> Mem.nextblock m' = Pos.succ (Mem.nextblock m).","proofString":"intros.\ndestruct g as [id [f|v]].\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:?.\nerewrite Mem.nextblock_drop; eauto.\nerewrite Mem.nextblock_alloc; eauto.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nerewrite Mem.nextblock_drop; eauto.\nerewrite store_init_data_list_nextblock; eauto.\nerewrite store_zeros_nextblock; eauto.\nerewrite Mem.nextblock_alloc; eauto."},{"statement":"(g : ident * globdef F V) (m m' : mem) (H : (let (_, g0) := g in\n match g0 with\n | Gfun _ =>\n     let (m1, b) := Mem.alloc m 0 1 in Mem.drop_perm m1 b 0 1 Nonempty\n | Gvar v =>\n     let (m1, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n     match store_zeros m1 b 0 (init_data_list_size (gvar_init v)) with\n     | Some m2 =>\n         match store_init_data_list m2 b 0 (gvar_init v) with\n         | Some m3 =>\n             Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n               (perm_globvar v)\n         | None => None\n         end\n     | None => None\n     end\n end) = Some m') : Mem.nextblock m' = Pos.succ (Mem.nextblock m).","proofString":"destruct g as [id [f|v]].\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:?.\nerewrite Mem.nextblock_drop; eauto.\nerewrite Mem.nextblock_alloc; eauto.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nerewrite Mem.nextblock_drop; eauto.\nerewrite store_init_data_list_nextblock; eauto.\nerewrite store_zeros_nextblock; eauto.\nerewrite Mem.nextblock_alloc; eauto."},{"statement":"(id : ident) (f : F) (m m' : mem) (H : (let (m1, b) := Mem.alloc m 0 1 in Mem.drop_perm m1 b 0 1 Nonempty) = Some m') : Mem.nextblock m' = Pos.succ (Mem.nextblock m).","proofString":"destruct (Mem.alloc m 0 1) as [m1 b] eqn:?.\nerewrite Mem.nextblock_drop; eauto.\nerewrite Mem.nextblock_alloc; eauto."},{"statement":"(id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') : Mem.nextblock m' = Pos.succ (Mem.nextblock m).","proofString":"erewrite Mem.nextblock_drop; eauto.\nerewrite Mem.nextblock_alloc; eauto."},{"statement":"(id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') : Mem.nextblock m1 = Pos.succ (Mem.nextblock m).","proofString":"erewrite Mem.nextblock_alloc; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (H : (let (m1, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n match store_zeros m1 b 0 (init_data_list_size (gvar_init v)) with\n | Some m2 =>\n     match store_init_data_list m2 b 0 (gvar_init v) with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n           (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') : Mem.nextblock m' = Pos.succ (Mem.nextblock m).","proofString":"set (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nerewrite Mem.nextblock_drop; eauto.\nerewrite store_init_data_list_nextblock; eauto.\nerewrite store_zeros_nextblock; eauto.\nerewrite Mem.nextblock_alloc; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (H : (let (m1, b) := Mem.alloc m 0 (init_data_list_size init) in\n match store_zeros m1 b 0 (init_data_list_size init) with\n | Some m2 =>\n     match store_init_data_list m2 b 0 init with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size init) (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') : Mem.nextblock m' = Pos.succ (Mem.nextblock m).","proofString":"set (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nerewrite Mem.nextblock_drop; eauto.\nerewrite store_init_data_list_nextblock; eauto.\nerewrite store_zeros_nextblock; eauto.\nerewrite Mem.nextblock_alloc; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (H : (let (m1, b) := Mem.alloc m 0 sz in\n match store_zeros m1 b 0 sz with\n | Some m2 =>\n     match store_init_data_list m2 b 0 init with\n     | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') : Mem.nextblock m' = Pos.succ (Mem.nextblock m).","proofString":"destruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nerewrite Mem.nextblock_drop; eauto.\nerewrite store_init_data_list_nextblock; eauto.\nerewrite store_zeros_nextblock; eauto.\nerewrite Mem.nextblock_alloc; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (H : match store_zeros m1 b 0 sz with\n| Some m2 =>\n    match store_init_data_list m2 b 0 init with\n    | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n    | None => None\n    end\n| None => None\nend = Some m') : Mem.nextblock m' = Pos.succ (Mem.nextblock m).","proofString":"destruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nerewrite Mem.nextblock_drop; eauto.\nerewrite store_init_data_list_nextblock; eauto.\nerewrite store_zeros_nextblock; eauto.\nerewrite Mem.nextblock_alloc; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (H : match store_init_data_list m2 b 0 init with\n| Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n| None => None\nend = Some m') : Mem.nextblock m' = Pos.succ (Mem.nextblock m).","proofString":"destruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nerewrite Mem.nextblock_drop; eauto.\nerewrite store_init_data_list_nextblock; eauto.\nerewrite store_zeros_nextblock; eauto.\nerewrite Mem.nextblock_alloc; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') : Mem.nextblock m' = Pos.succ (Mem.nextblock m).","proofString":"erewrite Mem.nextblock_drop; eauto.\nerewrite store_init_data_list_nextblock; eauto.\nerewrite store_zeros_nextblock; eauto.\nerewrite Mem.nextblock_alloc; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') : Mem.nextblock m3 = Pos.succ (Mem.nextblock m).","proofString":"erewrite store_init_data_list_nextblock; eauto.\nerewrite store_zeros_nextblock; eauto.\nerewrite Mem.nextblock_alloc; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') : Mem.nextblock m2 = Pos.succ (Mem.nextblock m).","proofString":"erewrite store_zeros_nextblock; eauto.\nerewrite Mem.nextblock_alloc; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') : Mem.nextblock m1 = Pos.succ (Mem.nextblock m).","proofString":"erewrite Mem.nextblock_alloc; eauto."},{"statement":"(m m' : mem) (H : Some m = Some m') : Mem.nextblock m' = Mem.nextblock m.","proofString":"congruence."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 ->\nMem.nextblock m'0 = advance_next gl (Mem.nextblock m0)) (m m' : mem) (H : match alloc_global m a with\n| Some m'0 => alloc_globals m'0 gl\n| None => None\nend = Some m') : Mem.nextblock m' = advance_next gl (Pos.succ (Mem.nextblock m)).","proofString":"destruct (alloc_global m a) as [m1|] eqn:?; try discriminate.\nerewrite IHgl; eauto.\nerewrite alloc_global_nextblock; eauto."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 ->\nMem.nextblock m'0 = advance_next gl (Mem.nextblock m0)) (m m' m1 : mem) (Heqo : alloc_global m a = Some m1) (H : alloc_globals m1 gl = Some m') : Mem.nextblock m' = advance_next gl (Pos.succ (Mem.nextblock m)).","proofString":"erewrite IHgl; eauto.\nerewrite alloc_global_nextblock; eauto."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 ->\nMem.nextblock m'0 = advance_next gl (Mem.nextblock m0)) (m m' m1 : mem) (Heqo : alloc_global m a = Some m1) (H : alloc_globals m1 gl = Some m') : advance_next gl (Mem.nextblock m1) =\nadvance_next gl (Pos.succ (Mem.nextblock m)).","proofString":"erewrite alloc_global_nextblock; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (m : mem) (b : block) (p n : Z) : forall m' : mem,\nstore_zeros m b p n = Some m' ->\nMem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"functional induction (store_zeros m b p n); intros.\ninv H; tauto.\ndestruct (IHo _ H); intros.\nsplit; eauto with mem.\ncongruence."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (m : mem) (b : block) (p n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H : Some m = Some m') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"inv H; tauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nMem.perm m' b' q k prm <-> Mem.perm m'1 b' q k prm) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) : Mem.perm m b' q k prm <-> Mem.perm m'0 b' q k prm.","proofString":"destruct (IHo _ H); intros.\nsplit; eauto with mem."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nMem.perm m' b' q k prm <-> Mem.perm m'1 b' q k prm) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H0 : Mem.perm m' b' q k prm -> Mem.perm m'0 b' q k prm) (H1 : Mem.perm m'0 b' q k prm -> Mem.perm m' b' q k prm) : Mem.perm m b' q k prm <-> Mem.perm m'0 b' q k prm.","proofString":"split; eauto with mem."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (m' : mem) (H : None = Some m') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"congruence."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (i : init_data) (b : block) (m : mem) (p : Z) (m' : mem) (H : store_init_data m b p i = Some m') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"assert (forall chunk v,          Mem.store chunk m b p v = Some m' ->          (Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm)).\nintros; split; eauto with mem.\ndestruct i; simpl in H; eauto.\ninv H; tauto.\ndestruct (find_symbol ge i); try discriminate.\neauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (i : init_data) (b : block) (m : mem) (p : Z) (m' : mem) (H : store_init_data m b p i = Some m') : forall (chunk : memory_chunk) (v : val),\nMem.store chunk m b p v = Some m' ->\nMem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"intros; split; eauto with mem."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (i : init_data) (b : block) (m : mem) (p : Z) (m' : mem) (H : store_init_data m b p i = Some m') (H0 : forall (chunk : memory_chunk) (v : val),\nMem.store chunk m b p v = Some m' ->\nMem.perm m b' q k prm <-> Mem.perm m' b' q k prm) : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"destruct i; simpl in H; eauto.\ninv H; tauto.\ndestruct (find_symbol ge i); try discriminate.\neauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q z : Z) (b : block) (m : mem) (p : Z) (m' : mem) (H : Some m = Some m') (H0 : forall (chunk : memory_chunk) (v : val),\nMem.store chunk m b p v = Some m' ->\nMem.perm m b' q k prm <-> Mem.perm m' b' q k prm) : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"inv H; tauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (i : ident) (i0 : ptrofs) (b : block) (m : mem) (p : Z) (m' : mem) (H : match find_symbol ge i with\n| Some b'0 => Mem.store Mptr m b p (Vptr b'0 i0)\n| None => None\nend = Some m') (H0 : forall (chunk : memory_chunk) (v : val),\nMem.store chunk m b p v = Some m' ->\nMem.perm m b' q k prm <-> Mem.perm m' b' q k prm) : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"destruct (find_symbol ge i); try discriminate.\neauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (i : ident) (i0 : ptrofs) (b : block) (m : mem) (p : Z) (m' : mem) (b0 : block) (H : Mem.store Mptr m b p (Vptr b0 i0) = Some m') (H0 : forall (chunk : memory_chunk) (v : val),\nMem.store chunk m b p v = Some m' ->\nMem.perm m b' q k prm <-> Mem.perm m' b' q k prm) : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (b : block) (m : mem) (p : Z) (m' : mem) (H : Some m = Some m') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"inv H; tauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (i1 : init_data) (idl : list init_data) (IHidl : forall (b0 : block) (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b0 p0 idl = Some m'0 ->\nMem.perm m0 b' q k prm <-> Mem.perm m'0 b' q k prm) (b : block) (m : mem) (p : Z) (m' : mem) (H : match store_init_data m b p i1 with\n| Some m'0 => store_init_data_list m'0 b (p + init_data_size i1) idl\n| None => None\nend = Some m') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"destruct (store_init_data m b p i1) as [m1|] eqn:S1; try discriminate.\ntransitivity (Mem.perm m1 b' q k prm).\neapply store_init_data_perm; eauto.\neapply IHidl; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (i1 : init_data) (idl : list init_data) (IHidl : forall (b0 : block) (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b0 p0 idl = Some m'0 ->\nMem.perm m0 b' q k prm <-> Mem.perm m'0 b' q k prm) (b : block) (m : mem) (p : Z) (m' m1 : mem) (S1 : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) idl = Some m') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"transitivity (Mem.perm m1 b' q k prm).\neapply store_init_data_perm; eauto.\neapply IHidl; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (i1 : init_data) (idl : list init_data) (IHidl : forall (b0 : block) (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b0 p0 idl = Some m'0 ->\nMem.perm m0 b' q k prm <-> Mem.perm m'0 b' q k prm) (b : block) (m : mem) (p : Z) (m' m1 : mem) (S1 : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) idl = Some m') : Mem.perm m b' q k prm <-> Mem.perm m1 b' q k prm.","proofString":"eapply store_init_data_perm; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (i1 : init_data) (idl : list init_data) (IHidl : forall (b0 : block) (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b0 p0 idl = Some m'0 ->\nMem.perm m0 b' q k prm <-> Mem.perm m'0 b' q k prm) (b : block) (m : mem) (p : Z) (m' m1 : mem) (S1 : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) idl = Some m') : Mem.perm m1 b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"eapply IHidl; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (idg : ident * globdef F V) (m m' : mem) (H : alloc_global m idg = Some m') (H0 : Mem.valid_block m b') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"destruct idg as [id [f|v]]; simpl in H.\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:?.\nassert (b' <> b).\napply Mem.valid_not_valid_diff with m; eauto with mem.\nsplit; intros.\neapply Mem.perm_drop_3; eauto.\neapply Mem.perm_alloc_1; eauto.\neapply Mem.perm_alloc_4; eauto.\neapply Mem.perm_drop_4; eauto.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nassert (b' <> b).\napply Mem.valid_not_valid_diff with m; eauto with mem.\nsplit; intros.\neapply Mem.perm_drop_3; eauto.\nerewrite <- store_init_data_list_perm; [idtac|eauto].\nerewrite <- store_zeros_perm; [idtac|eauto].\neapply Mem.perm_alloc_1; eauto.\neapply Mem.perm_alloc_4; eauto.\nerewrite store_zeros_perm; [idtac|eauto].\nerewrite store_init_data_list_perm; [idtac|eauto].\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (f : F) (m m' : mem) (H : (let (m1, b) := Mem.alloc m 0 1 in Mem.drop_perm m1 b 0 1 Nonempty) = Some m') (H0 : Mem.valid_block m b') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"destruct (Mem.alloc m 0 1) as [m1 b] eqn:?.\nassert (b' <> b).\napply Mem.valid_not_valid_diff with m; eauto with mem.\nsplit; intros.\neapply Mem.perm_drop_3; eauto.\neapply Mem.perm_alloc_1; eauto.\neapply Mem.perm_alloc_4; eauto.\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H0 : Mem.valid_block m b') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"assert (b' <> b).\napply Mem.valid_not_valid_diff with m; eauto with mem.\nsplit; intros.\neapply Mem.perm_drop_3; eauto.\neapply Mem.perm_alloc_1; eauto.\neapply Mem.perm_alloc_4; eauto.\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H0 : Mem.valid_block m b') : b' <> b.","proofString":"apply Mem.valid_not_valid_diff with m; eauto with mem."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"split; intros.\neapply Mem.perm_drop_3; eauto.\neapply Mem.perm_alloc_1; eauto.\neapply Mem.perm_alloc_4; eauto.\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) (H2 : Mem.perm m b' q k prm) : Mem.perm m' b' q k prm.","proofString":"eapply Mem.perm_drop_3; eauto.\neapply Mem.perm_alloc_1; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) (H2 : Mem.perm m b' q k prm) : Mem.perm m1 b' q k prm.","proofString":"eapply Mem.perm_alloc_1; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) (H2 : Mem.perm m' b' q k prm) : Mem.perm m b' q k prm.","proofString":"eapply Mem.perm_alloc_4; eauto.\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) (H2 : Mem.perm m' b' q k prm) : Mem.perm m1 b' q k prm.","proofString":"eapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (H : (let (m1, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n match store_zeros m1 b 0 (init_data_list_size (gvar_init v)) with\n | Some m2 =>\n     match store_init_data_list m2 b 0 (gvar_init v) with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n           (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') (H0 : Mem.valid_block m b') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"set (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nassert (b' <> b).\napply Mem.valid_not_valid_diff with m; eauto with mem.\nsplit; intros.\neapply Mem.perm_drop_3; eauto.\nerewrite <- store_init_data_list_perm; [idtac|eauto].\nerewrite <- store_zeros_perm; [idtac|eauto].\neapply Mem.perm_alloc_1; eauto.\neapply Mem.perm_alloc_4; eauto.\nerewrite store_zeros_perm; [idtac|eauto].\nerewrite store_init_data_list_perm; [idtac|eauto].\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (H : (let (m1, b) := Mem.alloc m 0 (init_data_list_size init) in\n match store_zeros m1 b 0 (init_data_list_size init) with\n | Some m2 =>\n     match store_init_data_list m2 b 0 init with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size init) (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') (H0 : Mem.valid_block m b') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"set (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nassert (b' <> b).\napply Mem.valid_not_valid_diff with m; eauto with mem.\nsplit; intros.\neapply Mem.perm_drop_3; eauto.\nerewrite <- store_init_data_list_perm; [idtac|eauto].\nerewrite <- store_zeros_perm; [idtac|eauto].\neapply Mem.perm_alloc_1; eauto.\neapply Mem.perm_alloc_4; eauto.\nerewrite store_zeros_perm; [idtac|eauto].\nerewrite store_init_data_list_perm; [idtac|eauto].\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (H : (let (m1, b) := Mem.alloc m 0 sz in\n match store_zeros m1 b 0 sz with\n | Some m2 =>\n     match store_init_data_list m2 b 0 init with\n     | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') (H0 : Mem.valid_block m b') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"destruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nassert (b' <> b).\napply Mem.valid_not_valid_diff with m; eauto with mem.\nsplit; intros.\neapply Mem.perm_drop_3; eauto.\nerewrite <- store_init_data_list_perm; [idtac|eauto].\nerewrite <- store_zeros_perm; [idtac|eauto].\neapply Mem.perm_alloc_1; eauto.\neapply Mem.perm_alloc_4; eauto.\nerewrite store_zeros_perm; [idtac|eauto].\nerewrite store_init_data_list_perm; [idtac|eauto].\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (H : match store_zeros m1 b 0 sz with\n| Some m2 =>\n    match store_init_data_list m2 b 0 init with\n    | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n    | None => None\n    end\n| None => None\nend = Some m') (H0 : Mem.valid_block m b') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"destruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nassert (b' <> b).\napply Mem.valid_not_valid_diff with m; eauto with mem.\nsplit; intros.\neapply Mem.perm_drop_3; eauto.\nerewrite <- store_init_data_list_perm; [idtac|eauto].\nerewrite <- store_zeros_perm; [idtac|eauto].\neapply Mem.perm_alloc_1; eauto.\neapply Mem.perm_alloc_4; eauto.\nerewrite store_zeros_perm; [idtac|eauto].\nerewrite store_init_data_list_perm; [idtac|eauto].\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (H : match store_init_data_list m2 b 0 init with\n| Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n| None => None\nend = Some m') (H0 : Mem.valid_block m b') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"destruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nassert (b' <> b).\napply Mem.valid_not_valid_diff with m; eauto with mem.\nsplit; intros.\neapply Mem.perm_drop_3; eauto.\nerewrite <- store_init_data_list_perm; [idtac|eauto].\nerewrite <- store_zeros_perm; [idtac|eauto].\neapply Mem.perm_alloc_1; eauto.\neapply Mem.perm_alloc_4; eauto.\nerewrite store_zeros_perm; [idtac|eauto].\nerewrite store_init_data_list_perm; [idtac|eauto].\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.valid_block m b') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"assert (b' <> b).\napply Mem.valid_not_valid_diff with m; eauto with mem.\nsplit; intros.\neapply Mem.perm_drop_3; eauto.\nerewrite <- store_init_data_list_perm; [idtac|eauto].\nerewrite <- store_zeros_perm; [idtac|eauto].\neapply Mem.perm_alloc_1; eauto.\neapply Mem.perm_alloc_4; eauto.\nerewrite store_zeros_perm; [idtac|eauto].\nerewrite store_init_data_list_perm; [idtac|eauto].\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.valid_block m b') : b' <> b.","proofString":"apply Mem.valid_not_valid_diff with m; eauto with mem."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"split; intros.\neapply Mem.perm_drop_3; eauto.\nerewrite <- store_init_data_list_perm; [idtac|eauto].\nerewrite <- store_zeros_perm; [idtac|eauto].\neapply Mem.perm_alloc_1; eauto.\neapply Mem.perm_alloc_4; eauto.\nerewrite store_zeros_perm; [idtac|eauto].\nerewrite store_init_data_list_perm; [idtac|eauto].\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) (H2 : Mem.perm m b' q k prm) : Mem.perm m' b' q k prm.","proofString":"eapply Mem.perm_drop_3; eauto.\nerewrite <- store_init_data_list_perm; [idtac|eauto].\nerewrite <- store_zeros_perm; [idtac|eauto].\neapply Mem.perm_alloc_1; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) (H2 : Mem.perm m b' q k prm) : Mem.perm m3 b' q k prm.","proofString":"erewrite <- store_init_data_list_perm; [idtac|eauto].\nerewrite <- store_zeros_perm; [idtac|eauto].\neapply Mem.perm_alloc_1; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) (H2 : Mem.perm m b' q k prm) : Mem.perm m2 b' q k prm.","proofString":"erewrite <- store_zeros_perm; [idtac|eauto].\neapply Mem.perm_alloc_1; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) (H2 : Mem.perm m b' q k prm) : Mem.perm m1 b' q k prm.","proofString":"eapply Mem.perm_alloc_1; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) (H2 : Mem.perm m' b' q k prm) : Mem.perm m b' q k prm.","proofString":"eapply Mem.perm_alloc_4; eauto.\nerewrite store_zeros_perm; [idtac|eauto].\nerewrite store_init_data_list_perm; [idtac|eauto].\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) (H2 : Mem.perm m' b' q k prm) : Mem.perm m1 b' q k prm.","proofString":"erewrite store_zeros_perm; [idtac|eauto].\nerewrite store_init_data_list_perm; [idtac|eauto].\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) (H2 : Mem.perm m' b' q k prm) : Mem.perm m2 b' q k prm.","proofString":"erewrite store_init_data_list_perm; [idtac|eauto].\neapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.valid_block m b') (H1 : b' <> b) (H2 : Mem.perm m' b' q k prm) : Mem.perm m3 b' q k prm.","proofString":"eapply Mem.perm_drop_4; eauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) : forall m m' : mem,\nalloc_globals m nil = Some m' ->\nMem.valid_block m b' -> Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"simpl; intros.\ninv H.\ntauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (m m' : mem) (H : Some m = Some m') (H0 : Mem.valid_block m b') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"inv H.\ntauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (m' : mem) (H0 : Mem.valid_block m' b') : Mem.perm m' b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"tauto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m m' : mem,\nalloc_globals m gl = Some m' ->\nMem.valid_block m b' -> Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm) : forall m m' : mem,\nalloc_globals m (a :: gl) = Some m' ->\nMem.valid_block m b' -> Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"simpl; intros.\ndestruct (alloc_global m a) as [m1|] eqn:?; try discriminate.\nerewrite alloc_global_perm; eauto.\neapply IHgl; eauto.\nunfold Mem.valid_block in *.\nerewrite alloc_global_nextblock; eauto.\napply Plt_trans_succ; auto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 ->\nMem.valid_block m0 b' -> Mem.perm m0 b' q k prm <-> Mem.perm m'0 b' q k prm) (m m' : mem) (H : match alloc_global m a with\n| Some m'0 => alloc_globals m'0 gl\n| None => None\nend = Some m') (H0 : Mem.valid_block m b') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"destruct (alloc_global m a) as [m1|] eqn:?; try discriminate.\nerewrite alloc_global_perm; eauto.\neapply IHgl; eauto.\nunfold Mem.valid_block in *.\nerewrite alloc_global_nextblock; eauto.\napply Plt_trans_succ; auto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 ->\nMem.valid_block m0 b' -> Mem.perm m0 b' q k prm <-> Mem.perm m'0 b' q k prm) (m m' m1 : mem) (Heqo : alloc_global m a = Some m1) (H : alloc_globals m1 gl = Some m') (H0 : Mem.valid_block m b') : Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"erewrite alloc_global_perm; eauto.\neapply IHgl; eauto.\nunfold Mem.valid_block in *.\nerewrite alloc_global_nextblock; eauto.\napply Plt_trans_succ; auto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 ->\nMem.valid_block m0 b' -> Mem.perm m0 b' q k prm <-> Mem.perm m'0 b' q k prm) (m m' m1 : mem) (Heqo : alloc_global m a = Some m1) (H : alloc_globals m1 gl = Some m') (H0 : Mem.valid_block m b') : Mem.perm m1 b' q k prm <-> Mem.perm m' b' q k prm.","proofString":"eapply IHgl; eauto.\nunfold Mem.valid_block in *.\nerewrite alloc_global_nextblock; eauto.\napply Plt_trans_succ; auto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 ->\nMem.valid_block m0 b' -> Mem.perm m0 b' q k prm <-> Mem.perm m'0 b' q k prm) (m m' m1 : mem) (Heqo : alloc_global m a = Some m1) (H : alloc_globals m1 gl = Some m') (H0 : Mem.valid_block m b') : Mem.valid_block m1 b'.","proofString":"unfold Mem.valid_block in *.\nerewrite alloc_global_nextblock; eauto.\napply Plt_trans_succ; auto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 ->\nPlt b' (Mem.nextblock m0) ->\nMem.perm m0 b' q k prm <-> Mem.perm m'0 b' q k prm) (m m' m1 : mem) (Heqo : alloc_global m a = Some m1) (H : alloc_globals m1 gl = Some m') (H0 : Plt b' (Mem.nextblock m)) : Plt b' (Mem.nextblock m1).","proofString":"erewrite alloc_global_nextblock; eauto.\napply Plt_trans_succ; auto."},{"statement":"(k : perm_kind) (prm : permission) (b' : block) (q : Z) (a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 ->\nPlt b' (Mem.nextblock m0) ->\nMem.perm m0 b' q k prm <-> Mem.perm m'0 b' q k prm) (m m' m1 : mem) (Heqo : alloc_global m a = Some m1) (H : alloc_globals m1 gl = Some m') (H0 : Plt b' (Mem.nextblock m)) : Plt b' (Pos.succ (Mem.nextblock m)).","proofString":"apply Plt_trans_succ; auto."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (p n : Z) : forall m' : mem,\nstore_zeros m b p n = Some m' ->\n(forall i : Z, p <= i < p + n -> ~ P b i) -> Mem.unchanged_on P m m'.","proofString":"functional induction (store_zeros m b p n); intros.\ninv H; apply Mem.unchanged_on_refl.\napply Mem.unchanged_on_trans with m'.\neapply Mem.store_unchanged_on; eauto.\nsimpl.\nintros.\napply H0.\nlia.\napply IHo; auto.\nintros; apply H0; lia.\ndiscriminate."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (p n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H : Some m = Some m') (H0 : forall i : Z, p <= i < p + n -> ~ P b i) : Mem.unchanged_on P m m'.","proofString":"inv H; apply Mem.unchanged_on_refl."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\n(forall i : Z, p + 1 <= i < p + 1 + (n - 1) -> ~ P b i) ->\nMem.unchanged_on P m' m'1) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H0 : forall i : Z, p <= i < p + n -> ~ P b i) : Mem.unchanged_on P m m'0.","proofString":"apply Mem.unchanged_on_trans with m'.\neapply Mem.store_unchanged_on; eauto.\nsimpl.\nintros.\napply H0.\nlia.\napply IHo; auto.\nintros; apply H0; lia."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\n(forall i : Z, p + 1 <= i < p + 1 + (n - 1) -> ~ P b i) ->\nMem.unchanged_on P m' m'1) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H0 : forall i : Z, p <= i < p + n -> ~ P b i) : Mem.unchanged_on P m m'.","proofString":"eapply Mem.store_unchanged_on; eauto.\nsimpl.\nintros.\napply H0.\nlia."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\n(forall i : Z, p + 1 <= i < p + 1 + (n - 1) -> ~ P b i) ->\nMem.unchanged_on P m' m'1) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H0 : forall i : Z, p <= i < p + n -> ~ P b i) : forall i : Z, p <= i < p + size_chunk Mint8unsigned -> ~ P b i.","proofString":"simpl.\nintros.\napply H0.\nlia."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\n(forall i : Z, p + 1 <= i < p + 1 + (n - 1) -> ~ P b i) ->\nMem.unchanged_on P m' m'1) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H0 : forall i : Z, p <= i < p + n -> ~ P b i) : forall i : Z, p <= i < p + 1 -> ~ P b i.","proofString":"intros.\napply H0.\nlia."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\n(forall i0 : Z, p + 1 <= i0 < p + 1 + (n - 1) -> ~ P b i0) ->\nMem.unchanged_on P m' m'1) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H0 : forall i0 : Z, p <= i0 < p + n -> ~ P b i0) (i : Z) (H1 : p <= i < p + 1) : ~ P b i.","proofString":"apply H0.\nlia."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\n(forall i0 : Z, p + 1 <= i0 < p + 1 + (n - 1) -> ~ P b i0) ->\nMem.unchanged_on P m' m'1) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H0 : forall i0 : Z, p <= i0 < p + n -> ~ P b i0) (i : Z) (H1 : p <= i < p + 1) : p <= i < p + n.","proofString":"lia."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\n(forall i : Z, p + 1 <= i < p + 1 + (n - 1) -> ~ P b i) ->\nMem.unchanged_on P m' m'1) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H0 : forall i : Z, p <= i < p + n -> ~ P b i) : Mem.unchanged_on P m' m'0.","proofString":"apply IHo; auto.\nintros; apply H0; lia."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\n(forall i : Z, p + 1 <= i < p + 1 + (n - 1) -> ~ P b i) ->\nMem.unchanged_on P m' m'1) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H0 : forall i : Z, p <= i < p + n -> ~ P b i) : forall i : Z, p + 1 <= i < p + 1 + (n - 1) -> ~ P b i.","proofString":"intros; apply H0; lia."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (m' : mem) (H : None = Some m') (H0 : forall i : Z, p <= i < p + n -> ~ P b i) : Mem.unchanged_on P m m'.","proofString":"discriminate."},{"statement":"(P : block -> Z -> Prop) (b : block) (i : init_data) (m : mem) (p : Z) (m' : mem) (H : store_init_data m b p i = Some m') (H0 : forall ofs : Z, p <= ofs < p + init_data_size i -> ~ P b ofs) : Mem.unchanged_on P m m'.","proofString":"destruct i; simpl in *;  try (eapply Mem.store_unchanged_on; eauto; fail).\ninv H; apply Mem.unchanged_on_refl.\ndestruct (find_symbol ge i); try congruence.\neapply Mem.store_unchanged_on; eauto;  unfold Mptr; destruct Archi.ptr64; eauto."},{"statement":"(P : block -> Z -> Prop) (b : block) (z : Z) (m : mem) (p : Z) (m' : mem) (H : Some m = Some m') (H0 : forall ofs : Z, p <= ofs < p + Z.max z 0 -> ~ P b ofs) : Mem.unchanged_on P m m'.","proofString":"inv H; apply Mem.unchanged_on_refl."},{"statement":"(P : block -> Z -> Prop) (b : block) (i : ident) (i0 : ptrofs) (m : mem) (p : Z) (m' : mem) (H : match find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m') (H0 : forall ofs : Z, p <= ofs < p + (if Archi.ptr64 then 8 else 4) -> ~ P b ofs) : Mem.unchanged_on P m m'.","proofString":"destruct (find_symbol ge i); try congruence.\neapply Mem.store_unchanged_on; eauto;  unfold Mptr; destruct Archi.ptr64; eauto."},{"statement":"(P : block -> Z -> Prop) (b : block) (i : ident) (i0 : ptrofs) (m : mem) (p : Z) (m' : mem) (b0 : block) (H : Mem.store Mptr m b p (Vptr b0 i0) = Some m') (H0 : forall ofs : Z, p <= ofs < p + (if Archi.ptr64 then 8 else 4) -> ~ P b ofs) : Mem.unchanged_on P m m'.","proofString":"eapply Mem.store_unchanged_on; eauto;  unfold Mptr; destruct Archi.ptr64; eauto."},{"statement":"(P : block -> Z -> Prop) (b : block) (m : mem) (p : Z) (m' : mem) (H : Some m = Some m') (H0 : forall ofs : Z, p <= ofs -> ~ P b ofs) : Mem.unchanged_on P m m'.","proofString":"inv H.\napply Mem.unchanged_on_refl."},{"statement":"(P : block -> Z -> Prop) (b : block) (p : Z) (m' : mem) (H0 : forall ofs : Z, p <= ofs -> ~ P b ofs) : Mem.unchanged_on P m' m'.","proofString":"apply Mem.unchanged_on_refl."},{"statement":"(P : block -> Z -> Prop) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\n(forall ofs : Z, p0 <= ofs -> ~ P b ofs) -> Mem.unchanged_on P m0 m'0) (m : mem) (p : Z) (m' : mem) (H : match store_init_data m b p a with\n| Some m'0 => store_init_data_list m'0 b (p + init_data_size a) il\n| None => None\nend = Some m') (H0 : forall ofs : Z, p <= ofs -> ~ P b ofs) : Mem.unchanged_on P m m'.","proofString":"destruct (store_init_data m b p a) as [m1|] eqn:?; try congruence.\napply Mem.unchanged_on_trans with m1.\neapply store_init_data_unchanged; eauto.\nintros; apply H0; tauto.\neapply IHil; eauto.\nintros; apply H0.\ngeneralize (init_data_size_pos a); lia."},{"statement":"(P : block -> Z -> Prop) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\n(forall ofs : Z, p0 <= ofs -> ~ P b ofs) -> Mem.unchanged_on P m0 m'0) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : forall ofs : Z, p <= ofs -> ~ P b ofs) : Mem.unchanged_on P m m'.","proofString":"apply Mem.unchanged_on_trans with m1.\neapply store_init_data_unchanged; eauto.\nintros; apply H0; tauto.\neapply IHil; eauto.\nintros; apply H0.\ngeneralize (init_data_size_pos a); lia."},{"statement":"(P : block -> Z -> Prop) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\n(forall ofs : Z, p0 <= ofs -> ~ P b ofs) -> Mem.unchanged_on P m0 m'0) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : forall ofs : Z, p <= ofs -> ~ P b ofs) : Mem.unchanged_on P m m1.","proofString":"eapply store_init_data_unchanged; eauto.\nintros; apply H0; tauto."},{"statement":"(P : block -> Z -> Prop) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\n(forall ofs : Z, p0 <= ofs -> ~ P b ofs) -> Mem.unchanged_on P m0 m'0) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : forall ofs : Z, p <= ofs -> ~ P b ofs) : forall ofs : Z, p <= ofs < p + init_data_size a -> ~ P b ofs.","proofString":"intros; apply H0; tauto."},{"statement":"(P : block -> Z -> Prop) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\n(forall ofs : Z, p0 <= ofs -> ~ P b ofs) -> Mem.unchanged_on P m0 m'0) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : forall ofs : Z, p <= ofs -> ~ P b ofs) : Mem.unchanged_on P m1 m'.","proofString":"eapply IHil; eauto.\nintros; apply H0.\ngeneralize (init_data_size_pos a); lia."},{"statement":"(P : block -> Z -> Prop) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\n(forall ofs : Z, p0 <= ofs -> ~ P b ofs) -> Mem.unchanged_on P m0 m'0) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : forall ofs : Z, p <= ofs -> ~ P b ofs) : forall ofs : Z, p + init_data_size a <= ofs -> ~ P b ofs.","proofString":"intros; apply H0.\ngeneralize (init_data_size_pos a); lia."},{"statement":"(P : block -> Z -> Prop) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\n(forall ofs0 : Z, p0 <= ofs0 -> ~ P b ofs0) -> Mem.unchanged_on P m0 m'0) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : forall ofs0 : Z, p <= ofs0 -> ~ P b ofs0) (ofs : Z) (H1 : p + init_data_size a <= ofs) : p <= ofs.","proofString":"generalize (init_data_size_pos a); lia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H : Some m = Some m') (p0 : Z) (n0 : nat) (H0 : p <= p0) (H1 : p0 + Z.of_nat n0 <= p + n) : Mem.loadbytes m' b p0 (Z.of_nat n0) = Some (repeat (Byte Byte.zero) n0).","proofString":"destruct n0.\nsimpl.\napply Mem.loadbytes_empty.\nlia.\nrewrite Nat2Z.inj_succ in H1.\nextlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H : Some m = Some m') (p0 : Z) (H0 : p <= p0) (H1 : p0 + Z.of_nat 0 <= p + n) : Mem.loadbytes m' b p0 (Z.of_nat 0) = Some (repeat (Byte Byte.zero) 0).","proofString":"simpl.\napply Mem.loadbytes_empty.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H : Some m = Some m') (p0 : Z) (H0 : p <= p0) (H1 : p0 + Z.of_nat 0 <= p + n) : Mem.loadbytes m' b p0 0 = Some nil.","proofString":"apply Mem.loadbytes_empty.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H : Some m = Some m') (p0 : Z) (H0 : p <= p0) (H1 : p0 + Z.of_nat 0 <= p + n) : 0 <= 0.","proofString":"lia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H : Some m = Some m') (p0 : Z) (n0 : nat) (H0 : p <= p0) (H1 : p0 + Z.of_nat (S n0) <= p + n) : Mem.loadbytes m' b p0 (Z.of_nat (S n0)) =\nSome (repeat (Byte Byte.zero) (S n0)).","proofString":"rewrite Nat2Z.inj_succ in H1.\nextlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H : Some m = Some m') (p0 : Z) (n0 : nat) (H0 : p <= p0) (H1 : p0 + Z.succ (Z.of_nat n0) <= p + n) : Mem.loadbytes m' b p0 (Z.of_nat (S n0)) =\nSome (repeat (Byte Byte.zero) (S n0)).","proofString":"extlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (p0 : Z) (n0 : nat) (H0 : p <= p0) (H1 : p0 + Z.of_nat n0 <= p + n) : Mem.loadbytes m'0 b p0 (Z.of_nat n0) = Some (repeat (Byte Byte.zero) n0).","proofString":"destruct (zeq p0 p).\nsubst p0.\ndestruct n0.\nsimpl.\napply Mem.loadbytes_empty.\nlia.\nrewrite Nat2Z.inj_succ in H1.\nrewrite Nat2Z.inj_succ.\nreplace (Z.succ (Z.of_nat n0)) with (1 + Z.of_nat n0) by lia.\nchange (List.repeat (Byte Byte.zero) (S n0))      with ((Byte Byte.zero :: nil) ++ List.repeat (Byte Byte.zero) n0).\napply Mem.loadbytes_concat.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => ofs1 = p).\neapply store_zeros_unchanged; eauto.\nintros; lia.\nintros; lia.\nreplace (Byte Byte.zero :: nil) with (encode_val Mint8unsigned Vzero).\nchange 1 with (size_chunk Mint8unsigned).\neapply Mem.loadbytes_store_same; eauto.\nunfold encode_val; unfold encode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity.\neapply IHo; eauto.\nlia.\nlia.\nlia.\nlia.\neapply IHo; eauto.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (p0 : Z) (n0 : nat) (H0 : p <= p0) (H1 : p0 + Z.of_nat n0 <= p + n) (e1 : p0 = p) : Mem.loadbytes m'0 b p0 (Z.of_nat n0) = Some (repeat (Byte Byte.zero) n0).","proofString":"subst p0.\ndestruct n0.\nsimpl.\napply Mem.loadbytes_empty.\nlia.\nrewrite Nat2Z.inj_succ in H1.\nrewrite Nat2Z.inj_succ.\nreplace (Z.succ (Z.of_nat n0)) with (1 + Z.of_nat n0) by lia.\nchange (List.repeat (Byte Byte.zero) (S n0))      with ((Byte Byte.zero :: nil) ++ List.repeat (Byte Byte.zero) n0).\napply Mem.loadbytes_concat.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => ofs1 = p).\neapply store_zeros_unchanged; eauto.\nintros; lia.\nintros; lia.\nreplace (Byte Byte.zero :: nil) with (encode_val Mint8unsigned Vzero).\nchange 1 with (size_chunk Mint8unsigned).\neapply Mem.loadbytes_store_same; eauto.\nunfold encode_val; unfold encode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity.\neapply IHo; eauto.\nlia.\nlia.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.of_nat n0 <= p + n) (H0 : p <= p) : Mem.loadbytes m'0 b p (Z.of_nat n0) = Some (repeat (Byte Byte.zero) n0).","proofString":"destruct n0.\nsimpl.\napply Mem.loadbytes_empty.\nlia.\nrewrite Nat2Z.inj_succ in H1.\nrewrite Nat2Z.inj_succ.\nreplace (Z.succ (Z.of_nat n0)) with (1 + Z.of_nat n0) by lia.\nchange (List.repeat (Byte Byte.zero) (S n0))      with ((Byte Byte.zero :: nil) ++ List.repeat (Byte Byte.zero) n0).\napply Mem.loadbytes_concat.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => ofs1 = p).\neapply store_zeros_unchanged; eauto.\nintros; lia.\nintros; lia.\nreplace (Byte Byte.zero :: nil) with (encode_val Mint8unsigned Vzero).\nchange 1 with (size_chunk Mint8unsigned).\neapply Mem.loadbytes_store_same; eauto.\nunfold encode_val; unfold encode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity.\neapply IHo; eauto.\nlia.\nlia.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H1 : p + Z.of_nat 0 <= p + n) (H0 : p <= p) : Mem.loadbytes m'0 b p (Z.of_nat 0) = Some (repeat (Byte Byte.zero) 0).","proofString":"simpl.\napply Mem.loadbytes_empty.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H1 : p + Z.of_nat 0 <= p + n) (H0 : p <= p) : Mem.loadbytes m'0 b p 0 = Some nil.","proofString":"apply Mem.loadbytes_empty.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (H1 : p + Z.of_nat 0 <= p + n) (H0 : p <= p) : 0 <= 0.","proofString":"lia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.of_nat (S n0) <= p + n) (H0 : p <= p) : Mem.loadbytes m'0 b p (Z.of_nat (S n0)) =\nSome (repeat (Byte Byte.zero) (S n0)).","proofString":"rewrite Nat2Z.inj_succ in H1.\nrewrite Nat2Z.inj_succ.\nreplace (Z.succ (Z.of_nat n0)) with (1 + Z.of_nat n0) by lia.\nchange (List.repeat (Byte Byte.zero) (S n0))      with ((Byte Byte.zero :: nil) ++ List.repeat (Byte Byte.zero) n0).\napply Mem.loadbytes_concat.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => ofs1 = p).\neapply store_zeros_unchanged; eauto.\nintros; lia.\nintros; lia.\nreplace (Byte Byte.zero :: nil) with (encode_val Mint8unsigned Vzero).\nchange 1 with (size_chunk Mint8unsigned).\neapply Mem.loadbytes_store_same; eauto.\nunfold encode_val; unfold encode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity.\neapply IHo; eauto.\nlia.\nlia.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : Mem.loadbytes m'0 b p (Z.of_nat (S n0)) =\nSome (repeat (Byte Byte.zero) (S n0)).","proofString":"rewrite Nat2Z.inj_succ.\nreplace (Z.succ (Z.of_nat n0)) with (1 + Z.of_nat n0) by lia.\nchange (List.repeat (Byte Byte.zero) (S n0))      with ((Byte Byte.zero :: nil) ++ List.repeat (Byte Byte.zero) n0).\napply Mem.loadbytes_concat.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => ofs1 = p).\neapply store_zeros_unchanged; eauto.\nintros; lia.\nintros; lia.\nreplace (Byte Byte.zero :: nil) with (encode_val Mint8unsigned Vzero).\nchange 1 with (size_chunk Mint8unsigned).\neapply Mem.loadbytes_store_same; eauto.\nunfold encode_val; unfold encode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity.\neapply IHo; eauto.\nlia.\nlia.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : Mem.loadbytes m'0 b p (Z.succ (Z.of_nat n0)) =\nSome (repeat (Byte Byte.zero) (S n0)).","proofString":"replace (Z.succ (Z.of_nat n0)) with (1 + Z.of_nat n0) by lia.\nchange (List.repeat (Byte Byte.zero) (S n0))      with ((Byte Byte.zero :: nil) ++ List.repeat (Byte Byte.zero) n0).\napply Mem.loadbytes_concat.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => ofs1 = p).\neapply store_zeros_unchanged; eauto.\nintros; lia.\nintros; lia.\nreplace (Byte Byte.zero :: nil) with (encode_val Mint8unsigned Vzero).\nchange 1 with (size_chunk Mint8unsigned).\neapply Mem.loadbytes_store_same; eauto.\nunfold encode_val; unfold encode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity.\neapply IHo; eauto.\nlia.\nlia.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : Mem.loadbytes m'0 b p (1 + Z.of_nat n0) =\nSome (repeat (Byte Byte.zero) (S n0)).","proofString":"change (List.repeat (Byte Byte.zero) (S n0))      with ((Byte Byte.zero :: nil) ++ List.repeat (Byte Byte.zero) n0).\napply Mem.loadbytes_concat.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => ofs1 = p).\neapply store_zeros_unchanged; eauto.\nintros; lia.\nintros; lia.\nreplace (Byte Byte.zero :: nil) with (encode_val Mint8unsigned Vzero).\nchange 1 with (size_chunk Mint8unsigned).\neapply Mem.loadbytes_store_same; eauto.\nunfold encode_val; unfold encode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity.\neapply IHo; eauto.\nlia.\nlia.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : Mem.loadbytes m'0 b p (1 + Z.of_nat n0) =\nSome ((Byte Byte.zero :: nil) ++ repeat (Byte Byte.zero) n0).","proofString":"apply Mem.loadbytes_concat.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => ofs1 = p).\neapply store_zeros_unchanged; eauto.\nintros; lia.\nintros; lia.\nreplace (Byte Byte.zero :: nil) with (encode_val Mint8unsigned Vzero).\nchange 1 with (size_chunk Mint8unsigned).\neapply Mem.loadbytes_store_same; eauto.\nunfold encode_val; unfold encode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity.\neapply IHo; eauto.\nlia.\nlia.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : Mem.loadbytes m'0 b p 1 = Some (Byte Byte.zero :: nil).","proofString":"eapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => ofs1 = p).\neapply store_zeros_unchanged; eauto.\nintros; lia.\nintros; lia.\nreplace (Byte Byte.zero :: nil) with (encode_val Mint8unsigned Vzero).\nchange 1 with (size_chunk Mint8unsigned).\neapply Mem.loadbytes_store_same; eauto.\nunfold encode_val; unfold encode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : forall i : Z, p + 1 <= i < p + 1 + (n - 1) -> i <> p.","proofString":"intros; lia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : forall i : Z, p <= i < p + 1 -> i = p.","proofString":"intros; lia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : Mem.loadbytes m' b p 1 = Some (encode_val Mint8unsigned Vzero).","proofString":"change 1 with (size_chunk Mint8unsigned).\neapply Mem.loadbytes_store_same; eauto."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : Mem.loadbytes m' b p (size_chunk Mint8unsigned) =\nSome (encode_val Mint8unsigned Vzero).","proofString":"eapply Mem.loadbytes_store_same; eauto."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : encode_val Mint8unsigned Vzero = Byte Byte.zero :: nil.","proofString":"unfold encode_val; unfold encode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : Mem.loadbytes m'0 b (p + 1) (Z.of_nat n0) = Some (repeat (Byte Byte.zero) n0).","proofString":"eapply IHo; eauto.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : p + 1 <= p + 1.","proofString":"lia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : p + 1 + Z.of_nat n0 <= p + 1 + (n - 1).","proofString":"lia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : 1 >= 0.","proofString":"lia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (n0 : nat) (H1 : p + Z.succ (Z.of_nat n0) <= p + n) (H0 : p <= p) : Z.of_nat n0 >= 0.","proofString":"lia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (p0 : Z) (n0 : nat) (H0 : p <= p0) (H1 : p0 + Z.of_nat n0 <= p + n) (n1 : p0 <> p) : Mem.loadbytes m'0 b p0 (Z.of_nat n0) = Some (repeat (Byte Byte.zero) n0).","proofString":"eapply IHo; eauto.\nlia.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (p0 : Z) (n0 : nat) (H0 : p <= p0) (H1 : p0 + Z.of_nat n0 <= p + n) (n1 : p0 <> p) : p + 1 <= p0.","proofString":"lia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 ->\nreadbytes_as_zero m'1 b (p + 1) (n - 1)) (m'0 : mem) (H : store_zeros m' b (p + 1) (n - 1) = Some m'0) (p0 : Z) (n0 : nat) (H0 : p <= p0) (H1 : p0 + Z.of_nat n0 <= p + n) (n1 : p0 <> p) : p0 + Z.of_nat n0 <= p + 1 + (n - 1).","proofString":"lia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (m' : mem) (H : None = Some m') (p0 : Z) (n0 : nat) (H0 : p <= p0) (H1 : p0 + Z.of_nat n0 <= p + n) : Mem.loadbytes m' b p0 (Z.of_nat n0) = Some (repeat (Byte Byte.zero) n0).","proofString":"discriminate."},{"statement":"(id : ident) (ofs : ptrofs) : init_data_size (Init_addrof id ofs) = size_chunk Mptr.","proofString":"unfold Mptr.\nsimpl.\ndestruct Archi.ptr64; auto."},{"statement":"(id : ident) (ofs : ptrofs) : init_data_size (Init_addrof id ofs) =\nsize_chunk (if Archi.ptr64 then Mint64 else Mint32).","proofString":"simpl.\ndestruct Archi.ptr64; auto."},{"statement":"(id : ident) (ofs : ptrofs) : (if Archi.ptr64 then 8 else 4) =\nsize_chunk (if Archi.ptr64 then Mint64 else Mint32).","proofString":"destruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p z : Z) (m' : mem) (H : Some m = Some m') (H0 : readbytes_as_zero m b p (init_data_size (Init_space z))) : Mem.loadbytes m' b p (init_data_size (Init_space z)) =\nSome (bytes_of_init_data (Init_space z)).","proofString":"inv H.\nsimpl.\nassert (EQ: Z.of_nat (Z.to_nat z) = Z.max z 0).\ndestruct (zle 0 z).\nrewrite Z2Nat.id; extlia.\ndestruct z; try discriminate.\nsimpl.\nextlia.\nrewrite <- EQ.\napply H0.\nlia.\nsimpl.\nlia."},{"statement":"(b : block) (p z : Z) (m' : mem) (H0 : readbytes_as_zero m' b p (init_data_size (Init_space z))) : Mem.loadbytes m' b p (init_data_size (Init_space z)) =\nSome (bytes_of_init_data (Init_space z)).","proofString":"simpl.\nassert (EQ: Z.of_nat (Z.to_nat z) = Z.max z 0).\ndestruct (zle 0 z).\nrewrite Z2Nat.id; extlia.\ndestruct z; try discriminate.\nsimpl.\nextlia.\nrewrite <- EQ.\napply H0.\nlia.\nsimpl.\nlia."},{"statement":"(b : block) (p z : Z) (m' : mem) (H0 : readbytes_as_zero m' b p (init_data_size (Init_space z))) : Mem.loadbytes m' b p (Z.max z 0) =\nSome (repeat (Byte Byte.zero) (Z.to_nat z)).","proofString":"assert (EQ: Z.of_nat (Z.to_nat z) = Z.max z 0).\ndestruct (zle 0 z).\nrewrite Z2Nat.id; extlia.\ndestruct z; try discriminate.\nsimpl.\nextlia.\nrewrite <- EQ.\napply H0.\nlia.\nsimpl.\nlia."},{"statement":"(b : block) (p z : Z) (m' : mem) (H0 : readbytes_as_zero m' b p (init_data_size (Init_space z))) : Z.of_nat (Z.to_nat z) = Z.max z 0.","proofString":"destruct (zle 0 z).\nrewrite Z2Nat.id; extlia.\ndestruct z; try discriminate.\nsimpl.\nextlia."},{"statement":"(b : block) (p z : Z) (m' : mem) (H0 : readbytes_as_zero m' b p (init_data_size (Init_space z))) (l : 0 <= z) : Z.of_nat (Z.to_nat z) = Z.max z 0.","proofString":"rewrite Z2Nat.id; extlia."},{"statement":"(b : block) (p z : Z) (m' : mem) (H0 : readbytes_as_zero m' b p (init_data_size (Init_space z))) (g : 0 > z) : Z.of_nat (Z.to_nat z) = Z.max z 0.","proofString":"destruct z; try discriminate.\nsimpl.\nextlia."},{"statement":"(b : block) (p : Z) (p0 : positive) (m' : mem) (H0 : readbytes_as_zero m' b p (init_data_size (Init_space (Z.neg p0)))) (g : 0 > Z.neg p0) : Z.of_nat (Z.to_nat (Z.neg p0)) = Z.max (Z.neg p0) 0.","proofString":"simpl.\nextlia."},{"statement":"(b : block) (p : Z) (p0 : positive) (m' : mem) (H0 : readbytes_as_zero m' b p (init_data_size (Init_space (Z.neg p0)))) (g : 0 > Z.neg p0) : 0 = Z.max (Z.neg p0) 0.","proofString":"extlia."},{"statement":"(b : block) (p z : Z) (m' : mem) (H0 : readbytes_as_zero m' b p (init_data_size (Init_space z))) (EQ : Z.of_nat (Z.to_nat z) = Z.max z 0) : Mem.loadbytes m' b p (Z.max z 0) =\nSome (repeat (Byte Byte.zero) (Z.to_nat z)).","proofString":"rewrite <- EQ.\napply H0.\nlia.\nsimpl.\nlia."},{"statement":"(b : block) (p z : Z) (m' : mem) (H0 : readbytes_as_zero m' b p (init_data_size (Init_space z))) (EQ : Z.of_nat (Z.to_nat z) = Z.max z 0) : Mem.loadbytes m' b p (Z.of_nat (Z.to_nat z)) =\nSome (repeat (Byte Byte.zero) (Z.to_nat z)).","proofString":"apply H0.\nlia.\nsimpl.\nlia."},{"statement":"(b : block) (p z : Z) (m' : mem) (H0 : readbytes_as_zero m' b p (init_data_size (Init_space z))) (EQ : Z.of_nat (Z.to_nat z) = Z.max z 0) : p <= p.","proofString":"lia."},{"statement":"(b : block) (p z : Z) (m' : mem) (H0 : readbytes_as_zero m' b p (init_data_size (Init_space z))) (EQ : Z.of_nat (Z.to_nat z) = Z.max z 0) : p + Z.of_nat (Z.to_nat z) <= p + init_data_size (Init_space z).","proofString":"simpl.\nlia."},{"statement":"(b : block) (p z : Z) (m' : mem) (H0 : readbytes_as_zero m' b p (init_data_size (Init_space z))) (EQ : Z.of_nat (Z.to_nat z) = Z.max z 0) : p + Z.of_nat (Z.to_nat z) <= p + Z.max z 0.","proofString":"lia."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (H : match find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m') (H0 : readbytes_as_zero m b p (init_data_size (Init_addrof i i0))) : Mem.loadbytes m' b p (init_data_size (Init_addrof i i0)) =\nSome (bytes_of_init_data (Init_addrof i i0)).","proofString":"rewrite init_data_size_addrof.\nsimpl.\ndestruct (find_symbol ge i) as [b'|]; try discriminate.\nrewrite (Mem.loadbytes_store_same _ _ _ _ _ _ H).\nunfold encode_val, Mptr; destruct Archi.ptr64; reflexivity."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (H : match find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m') (H0 : readbytes_as_zero m b p (init_data_size (Init_addrof i i0))) : Mem.loadbytes m' b p (size_chunk Mptr) =\nSome (bytes_of_init_data (Init_addrof i i0)).","proofString":"simpl.\ndestruct (find_symbol ge i) as [b'|]; try discriminate.\nrewrite (Mem.loadbytes_store_same _ _ _ _ _ _ H).\nunfold encode_val, Mptr; destruct Archi.ptr64; reflexivity."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (H : match find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m') (H0 : readbytes_as_zero m b p (init_data_size (Init_addrof i i0))) : Mem.loadbytes m' b p (size_chunk Mptr) =\nSome\n  match find_symbol ge i with\n  | Some b0 => inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b0 i0)\n  | None => repeat Undef (if Archi.ptr64 then 8%nat else 4%nat)\n  end.","proofString":"destruct (find_symbol ge i) as [b'|]; try discriminate.\nrewrite (Mem.loadbytes_store_same _ _ _ _ _ _ H).\nunfold encode_val, Mptr; destruct Archi.ptr64; reflexivity."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (b' : block) (H : Mem.store Mptr m b p (Vptr b' i0) = Some m') (H0 : readbytes_as_zero m b p (init_data_size (Init_addrof i i0))) : Mem.loadbytes m' b p (size_chunk Mptr) =\nSome (inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b' i0)).","proofString":"rewrite (Mem.loadbytes_store_same _ _ _ _ _ _ H).\nunfold encode_val, Mptr; destruct Archi.ptr64; reflexivity."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (b' : block) (H : Mem.store Mptr m b p (Vptr b' i0) = Some m') (H0 : readbytes_as_zero m b p (init_data_size (Init_addrof i i0))) : Some (encode_val Mptr (Vptr b' i0)) =\nSome (inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b' i0)).","proofString":"unfold encode_val, Mptr; destruct Archi.ptr64; reflexivity."},{"statement":"(b : block) (m : mem) (p : Z) (m' : mem) (H : Some m = Some m') (H0 : readbytes_as_zero m b p 0) : Mem.loadbytes m' b p 0 = Some nil.","proofString":"apply Mem.loadbytes_empty.\nlia."},{"statement":"(b : block) (m : mem) (p : Z) (m' : mem) (H : Some m = Some m') (H0 : readbytes_as_zero m b p 0) : 0 <= 0.","proofString":"lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nreadbytes_as_zero m0 b p0 (init_data_list_size il) ->\nMem.loadbytes m'0 b p0 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' : mem) (H : match store_init_data m b p i1 with\n| Some m'0 => store_init_data_list m'0 b (p + init_data_size i1) il\n| None => None\nend = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) : Mem.loadbytes m' b p (init_data_size i1 + init_data_list_size il) =\nSome (bytes_of_init_data i1 ++ bytes_of_init_data_list il).","proofString":"generalize (init_data_size_pos i1) (init_data_list_size_pos il); intros P1 PL.\ndestruct (store_init_data m b p i1) as [m1|] eqn:S; try discriminate.\napply Mem.loadbytes_concat.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => ofs1 < p + init_data_size i1).\neapply store_init_data_list_unchanged; eauto.\nintros; lia.\nintros; lia.\neapply store_init_data_loadbytes; eauto.\nred; intros; apply H0.\nlia.\nlia.\napply IHil with m1; auto.\nred; intros.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => p + init_data_size i1 <= ofs1).\neapply store_init_data_unchanged; eauto.\nintros; lia.\nintros; lia.\napply H0.\nlia.\nlia.\nauto.\nauto."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nreadbytes_as_zero m0 b p0 (init_data_list_size il) ->\nMem.loadbytes m'0 b p0 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' : mem) (H : match store_init_data m b p i1 with\n| Some m'0 => store_init_data_list m'0 b (p + init_data_size i1) il\n| None => None\nend = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) : Mem.loadbytes m' b p (init_data_size i1 + init_data_list_size il) =\nSome (bytes_of_init_data i1 ++ bytes_of_init_data_list il).","proofString":"destruct (store_init_data m b p i1) as [m1|] eqn:S; try discriminate.\napply Mem.loadbytes_concat.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => ofs1 < p + init_data_size i1).\neapply store_init_data_list_unchanged; eauto.\nintros; lia.\nintros; lia.\neapply store_init_data_loadbytes; eauto.\nred; intros; apply H0.\nlia.\nlia.\napply IHil with m1; auto.\nred; intros.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => p + init_data_size i1 <= ofs1).\neapply store_init_data_unchanged; eauto.\nintros; lia.\nintros; lia.\napply H0.\nlia.\nlia.\nauto.\nauto."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nreadbytes_as_zero m0 b p0 (init_data_list_size il) ->\nMem.loadbytes m'0 b p0 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) : Mem.loadbytes m' b p (init_data_size i1 + init_data_list_size il) =\nSome (bytes_of_init_data i1 ++ bytes_of_init_data_list il).","proofString":"apply Mem.loadbytes_concat.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => ofs1 < p + init_data_size i1).\neapply store_init_data_list_unchanged; eauto.\nintros; lia.\nintros; lia.\neapply store_init_data_loadbytes; eauto.\nred; intros; apply H0.\nlia.\nlia.\napply IHil with m1; auto.\nred; intros.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => p + init_data_size i1 <= ofs1).\neapply store_init_data_unchanged; eauto.\nintros; lia.\nintros; lia.\napply H0.\nlia.\nlia.\nauto.\nauto."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nreadbytes_as_zero m0 b p0 (init_data_list_size il) ->\nMem.loadbytes m'0 b p0 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) : Mem.loadbytes m' b p (init_data_size i1) = Some (bytes_of_init_data i1).","proofString":"eapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => ofs1 < p + init_data_size i1).\neapply store_init_data_list_unchanged; eauto.\nintros; lia.\nintros; lia.\neapply store_init_data_loadbytes; eauto.\nred; intros; apply H0.\nlia.\nlia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nreadbytes_as_zero m0 b p0 (init_data_list_size il) ->\nMem.loadbytes m'0 b p0 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) : forall ofs : Z, p + init_data_size i1 <= ofs -> ~ ofs < p + init_data_size i1.","proofString":"intros; lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nreadbytes_as_zero m0 b p0 (init_data_list_size il) ->\nMem.loadbytes m'0 b p0 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) : forall i : Z, p <= i < p + init_data_size i1 -> i < p + init_data_size i1.","proofString":"intros; lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nreadbytes_as_zero m0 b p0 (init_data_list_size il) ->\nMem.loadbytes m'0 b p0 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) : readbytes_as_zero m b p (init_data_size i1).","proofString":"red; intros; apply H0.\nlia.\nlia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p1 : Z) (m'0 : mem),\nstore_init_data_list m0 b p1 il = Some m'0 ->\nreadbytes_as_zero m0 b p1 (init_data_list_size il) ->\nMem.loadbytes m'0 b p1 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) (p0 : Z) (n : nat) (H1 : p <= p0) (H2 : p0 + Z.of_nat n <= p + init_data_size i1) : p <= p0.","proofString":"lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p1 : Z) (m'0 : mem),\nstore_init_data_list m0 b p1 il = Some m'0 ->\nreadbytes_as_zero m0 b p1 (init_data_list_size il) ->\nMem.loadbytes m'0 b p1 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) (p0 : Z) (n : nat) (H1 : p <= p0) (H2 : p0 + Z.of_nat n <= p + init_data_size i1) : p0 + Z.of_nat n <= p + (init_data_size i1 + init_data_list_size il).","proofString":"lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nreadbytes_as_zero m0 b p0 (init_data_list_size il) ->\nMem.loadbytes m'0 b p0 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) : Mem.loadbytes m' b (p + init_data_size i1) (init_data_list_size il) =\nSome (bytes_of_init_data_list il).","proofString":"apply IHil with m1; auto.\nred; intros.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => p + init_data_size i1 <= ofs1).\neapply store_init_data_unchanged; eauto.\nintros; lia.\nintros; lia.\napply H0.\nlia.\nlia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nreadbytes_as_zero m0 b p0 (init_data_list_size il) ->\nMem.loadbytes m'0 b p0 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) : readbytes_as_zero m1 b (p + init_data_size i1) (init_data_list_size il).","proofString":"red; intros.\neapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => p + init_data_size i1 <= ofs1).\neapply store_init_data_unchanged; eauto.\nintros; lia.\nintros; lia.\napply H0.\nlia.\nlia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p1 : Z) (m'0 : mem),\nstore_init_data_list m0 b p1 il = Some m'0 ->\nreadbytes_as_zero m0 b p1 (init_data_list_size il) ->\nMem.loadbytes m'0 b p1 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) (p0 : Z) (n : nat) (H1 : p + init_data_size i1 <= p0) (H2 : p0 + Z.of_nat n <= p + init_data_size i1 + init_data_list_size il) : Mem.loadbytes m1 b p0 (Z.of_nat n) = Some (repeat (Byte Byte.zero) n).","proofString":"eapply Mem.loadbytes_unchanged_on with (P := fun b1 ofs1 => p + init_data_size i1 <= ofs1).\neapply store_init_data_unchanged; eauto.\nintros; lia.\nintros; lia.\napply H0.\nlia.\nlia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p1 : Z) (m'0 : mem),\nstore_init_data_list m0 b p1 il = Some m'0 ->\nreadbytes_as_zero m0 b p1 (init_data_list_size il) ->\nMem.loadbytes m'0 b p1 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) (p0 : Z) (n : nat) (H1 : p + init_data_size i1 <= p0) (H2 : p0 + Z.of_nat n <= p + init_data_size i1 + init_data_list_size il) : forall ofs : Z,\np <= ofs < p + init_data_size i1 -> ~ p + init_data_size i1 <= ofs.","proofString":"intros; lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p1 : Z) (m'0 : mem),\nstore_init_data_list m0 b p1 il = Some m'0 ->\nreadbytes_as_zero m0 b p1 (init_data_list_size il) ->\nMem.loadbytes m'0 b p1 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) (p0 : Z) (n : nat) (H1 : p + init_data_size i1 <= p0) (H2 : p0 + Z.of_nat n <= p + init_data_size i1 + init_data_list_size il) : forall i : Z, p0 <= i < p0 + Z.of_nat n -> p + init_data_size i1 <= i.","proofString":"intros; lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p1 : Z) (m'0 : mem),\nstore_init_data_list m0 b p1 il = Some m'0 ->\nreadbytes_as_zero m0 b p1 (init_data_list_size il) ->\nMem.loadbytes m'0 b p1 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) (p0 : Z) (n : nat) (H1 : p + init_data_size i1 <= p0) (H2 : p0 + Z.of_nat n <= p + init_data_size i1 + init_data_list_size il) : p <= p0.","proofString":"lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p1 : Z) (m'0 : mem),\nstore_init_data_list m0 b p1 il = Some m'0 ->\nreadbytes_as_zero m0 b p1 (init_data_list_size il) ->\nMem.loadbytes m'0 b p1 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) (p0 : Z) (n : nat) (H1 : p + init_data_size i1 <= p0) (H2 : p0 + Z.of_nat n <= p + init_data_size i1 + init_data_list_size il) : p0 + Z.of_nat n <= p + (init_data_size i1 + init_data_list_size il).","proofString":"lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nreadbytes_as_zero m0 b p0 (init_data_list_size il) ->\nMem.loadbytes m'0 b p0 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) : init_data_size i1 >= 0.","proofString":"auto."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nreadbytes_as_zero m0 b p0 (init_data_list_size il) ->\nMem.loadbytes m'0 b p0 (init_data_list_size il) =\nSome (bytes_of_init_data_list il)) (m : mem) (p : Z) (m' m1 : mem) (S : store_init_data m b p i1 = Some m1) (H : store_init_data_list m1 b (p + init_data_size i1) il = Some m') (H0 : readbytes_as_zero m b p (init_data_size i1 + init_data_list_size il)) (P1 : init_data_size i1 >= 0) (PL : init_data_list_size il >= 0) : init_data_list_size il >= 0.","proofString":"auto."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (ofs len : Z) (m' : mem) (H : read_as_zero m b ofs len) (H0 : Mem.unchanged_on P m m') (H1 : forall i : Z, ofs <= i < ofs + len -> P b i) (chunk : memory_chunk) (p : Z) (H2 : ofs <= p) (H3 : p + size_chunk chunk <= ofs + len) (H4 : (align_chunk chunk | p)) : Mem.load chunk m' b p =\nSome\n  match chunk with\n  | Mint64 => Vlong Int64.zero\n  | Mfloat32 => Vsingle Float32.zero\n  | Mfloat64 => Vfloat Float.zero\n  | Many32 | Many64 => Vundef\n  | _ => Vint Int.zero\n  end.","proofString":"eapply Mem.load_unchanged_on; eauto.\nintros; apply H1.\nlia."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (ofs len : Z) (m' : mem) (H : read_as_zero m b ofs len) (H0 : Mem.unchanged_on P m m') (H1 : forall i : Z, ofs <= i < ofs + len -> P b i) (chunk : memory_chunk) (p : Z) (H2 : ofs <= p) (H3 : p + size_chunk chunk <= ofs + len) (H4 : (align_chunk chunk | p)) : forall i : Z, p <= i < p + size_chunk chunk -> P b i.","proofString":"intros; apply H1.\nlia."},{"statement":"(P : block -> Z -> Prop) (m : mem) (b : block) (ofs len : Z) (m' : mem) (H : read_as_zero m b ofs len) (H0 : Mem.unchanged_on P m m') (H1 : forall i0 : Z, ofs <= i0 < ofs + len -> P b i0) (chunk : memory_chunk) (p : Z) (H2 : ofs <= p) (H3 : p + size_chunk chunk <= ofs + len) (H4 : (align_chunk chunk | p)) (i : Z) (H5 : p <= i < p + size_chunk chunk) : ofs <= i < ofs + len.","proofString":"lia."},{"statement":"(m : mem) (b : block) (p n : Z) (m' : mem) (H : store_zeros m b p n = Some m') (chunk : memory_chunk) (p0 : Z) (H0 : p <= p0) (H1 : p0 + size_chunk chunk <= p + n) (H2 : (align_chunk chunk | p0)) : Mem.load chunk m' b p0 =\nSome\n  match chunk with\n  | Mint64 => Vlong Int64.zero\n  | Mfloat32 => Vsingle Float32.zero\n  | Mfloat64 => Vfloat Float.zero\n  | Many32 | Many64 => Vundef\n  | _ => Vint Int.zero\n  end.","proofString":"transitivity (Some(decode_val chunk (List.repeat (Byte Byte.zero) (size_chunk_nat chunk)))).\napply Mem.loadbytes_load; auto.\nrewrite size_chunk_conv.\neapply store_zeros_loadbytes; eauto.\nrewrite <- size_chunk_conv; auto.\nf_equal.\ndestruct chunk; unfold decode_val; unfold decode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity."},{"statement":"(m : mem) (b : block) (p n : Z) (m' : mem) (H : store_zeros m b p n = Some m') (chunk : memory_chunk) (p0 : Z) (H0 : p <= p0) (H1 : p0 + size_chunk chunk <= p + n) (H2 : (align_chunk chunk | p0)) : Mem.load chunk m' b p0 =\nSome (decode_val chunk (repeat (Byte Byte.zero) (size_chunk_nat chunk))).","proofString":"apply Mem.loadbytes_load; auto.\nrewrite size_chunk_conv.\neapply store_zeros_loadbytes; eauto.\nrewrite <- size_chunk_conv; auto."},{"statement":"(m : mem) (b : block) (p n : Z) (m' : mem) (H : store_zeros m b p n = Some m') (chunk : memory_chunk) (p0 : Z) (H0 : p <= p0) (H1 : p0 + size_chunk chunk <= p + n) (H2 : (align_chunk chunk | p0)) : Mem.loadbytes m' b p0 (size_chunk chunk) =\nSome (repeat (Byte Byte.zero) (size_chunk_nat chunk)).","proofString":"rewrite size_chunk_conv.\neapply store_zeros_loadbytes; eauto.\nrewrite <- size_chunk_conv; auto."},{"statement":"(m : mem) (b : block) (p n : Z) (m' : mem) (H : store_zeros m b p n = Some m') (chunk : memory_chunk) (p0 : Z) (H0 : p <= p0) (H1 : p0 + size_chunk chunk <= p + n) (H2 : (align_chunk chunk | p0)) : Mem.loadbytes m' b p0 (Z.of_nat (size_chunk_nat chunk)) =\nSome (repeat (Byte Byte.zero) (size_chunk_nat chunk)).","proofString":"eapply store_zeros_loadbytes; eauto.\nrewrite <- size_chunk_conv; auto."},{"statement":"(m : mem) (b : block) (p n : Z) (m' : mem) (H : store_zeros m b p n = Some m') (chunk : memory_chunk) (p0 : Z) (H0 : p <= p0) (H1 : p0 + size_chunk chunk <= p + n) (H2 : (align_chunk chunk | p0)) : p0 + Z.of_nat (size_chunk_nat chunk) <= p + n.","proofString":"rewrite <- size_chunk_conv; auto."},{"statement":"(m : mem) (b : block) (p n : Z) (m' : mem) (H : store_zeros m b p n = Some m') (chunk : memory_chunk) (p0 : Z) (H0 : p <= p0) (H1 : p0 + size_chunk chunk <= p + n) (H2 : (align_chunk chunk | p0)) : Some (decode_val chunk (repeat (Byte Byte.zero) (size_chunk_nat chunk))) =\nSome\n  match chunk with\n  | Mint64 => Vlong Int64.zero\n  | Mfloat32 => Vsingle Float32.zero\n  | Mfloat64 => Vfloat Float.zero\n  | Many32 | Many64 => Vundef\n  | _ => Vint Int.zero\n  end.","proofString":"f_equal.\ndestruct chunk; unfold decode_val; unfold decode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity."},{"statement":"(m : mem) (b : block) (p n : Z) (m' : mem) (H : store_zeros m b p n = Some m') (chunk : memory_chunk) (p0 : Z) (H0 : p <= p0) (H1 : p0 + size_chunk chunk <= p + n) (H2 : (align_chunk chunk | p0)) : decode_val chunk (repeat (Byte Byte.zero) (size_chunk_nat chunk)) =\nmatch chunk with\n| Mint64 => Vlong Int64.zero\n| Mfloat32 => Vsingle Float32.zero\n| Mfloat64 => Vfloat Float.zero\n| Many32 | Many64 => Vundef\n| _ => Vint Int.zero\nend.","proofString":"destruct chunk; unfold decode_val; unfold decode_int; unfold rev_if_be; destruct Archi.big_endian; reflexivity."},{"statement":"forall (chunk : memory_chunk) (v : val) (m : mem) \n  (b : block) (p : Z) (m1 : mem) (il : list init_data) \n  (m' : mem),\nMem.store chunk m b p v = Some m1 ->\nstore_init_data_list m1 b (p + size_chunk chunk) il = Some m' ->\nMem.load chunk m' b p = Some (Val.load_result chunk v).","proofString":"intros.\neapply Mem.load_unchanged_on with (P := fun b' ofs' => ofs' < p + size_chunk chunk).\neapply store_init_data_list_unchanged; eauto.\nintros; lia.\nintros; tauto.\neapply Mem.load_store_same; eauto."},{"statement":"(chunk : memory_chunk) (v : val) (m : mem) (b : block) (p : Z) (m1 : mem) (il : list init_data) (m' : mem) (H : Mem.store chunk m b p v = Some m1) (H0 : store_init_data_list m1 b (p + size_chunk chunk) il = Some m') : Mem.load chunk m' b p = Some (Val.load_result chunk v).","proofString":"eapply Mem.load_unchanged_on with (P := fun b' ofs' => ofs' < p + size_chunk chunk).\neapply store_init_data_list_unchanged; eauto.\nintros; lia.\nintros; tauto.\neapply Mem.load_store_same; eauto."},{"statement":"(chunk : memory_chunk) (v : val) (m : mem) (b : block) (p : Z) (m1 : mem) (il : list init_data) (m' : mem) (H : Mem.store chunk m b p v = Some m1) (H0 : store_init_data_list m1 b (p + size_chunk chunk) il = Some m') : forall ofs : Z, p + size_chunk chunk <= ofs -> ~ ofs < p + size_chunk chunk.","proofString":"intros; lia."},{"statement":"(chunk : memory_chunk) (v : val) (m : mem) (b : block) (p : Z) (m1 : mem) (il : list init_data) (m' : mem) (H : Mem.store chunk m b p v = Some m1) (H0 : store_init_data_list m1 b (p + size_chunk chunk) il = Some m') : forall i : Z, p <= i < p + size_chunk chunk -> i < p + size_chunk chunk.","proofString":"intros; tauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m : mem) \n  (b : block) (p : Z) (m1 : mem) (il : list init_data) \n  (m' : mem),\nMem.store chunk m b p v = Some m1 ->\nstore_init_data_list m1 b (p + size_chunk chunk) il = Some m' ->\nMem.load chunk m' b p = Some (Val.load_result chunk v)) : forall (b : block) (il : list init_data) (m : mem) (p : Z) (m' : mem),\nstore_init_data_list m b p il = Some m' ->\nread_as_zero m b p (init_data_list_size il) -> load_store_init_data m' b p il.","proofString":"induction il; simpl.\nauto.\nintros.\ndestruct (store_init_data m b p a) as [m1|] eqn:?; try congruence.\nexploit IHil; eauto.\nset (P := fun (b': block) ofs' => p + init_data_size a <= ofs').\napply read_as_zero_unchanged with (m := m) (P := P).\nred; intros; apply H0; auto.\ngeneralize (init_data_size_pos a); lia.\nlia.\neapply store_init_data_unchanged with (P := P); eauto.\nintros; unfold P.\nlia.\nintros; unfold P.\nlia.\nintro D.\ndestruct a; simpl in Heqo.\nsplit; auto.\neapply (A Mint8unsigned (Vint i)); eauto.\nsplit; auto.\neapply (A Mint16unsigned (Vint i)); eauto.\nsplit; auto.\neapply (A Mint32 (Vint i)); eauto.\nsplit; auto.\neapply (A Mint64 (Vlong i)); eauto.\nsplit; auto.\neapply (A Mfloat32 (Vsingle f)); eauto.\nsplit; auto.\neapply (A Mfloat64 (Vfloat f)); eauto.\nsplit; auto.\nset (P := fun (b': block) ofs' => ofs' < p + init_data_size (Init_space z)).\ninv Heqo.\napply read_as_zero_unchanged with (m := m1) (P := P).\nred; intros.\napply H0; auto.\nsimpl.\ngeneralize (init_data_list_size_pos il); extlia.\neapply store_init_data_list_unchanged; eauto.\nintros; unfold P.\nlia.\nintros; unfold P.\nsimpl; extlia.\nrewrite init_data_size_addrof in *.\nsplit; auto.\ndestruct (find_symbol ge i); try congruence.\nexists b0; split; auto.\ntransitivity (Some (Val.load_result Mptr (Vptr b0 i0))).\neapply (A Mptr (Vptr b0 i0)); eauto.\nunfold Val.load_result, Mptr; destruct Archi.ptr64; auto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m : mem) \n  (b0 : block) (p : Z) (m1 : mem) (il : list init_data) \n  (m' : mem),\nMem.store chunk m b0 p v = Some m1 ->\nstore_init_data_list m1 b0 (p + size_chunk chunk) il = Some m' ->\nMem.load chunk m' b0 p = Some (Val.load_result chunk v)) (b : block) : forall (m : mem) (p : Z) (m' : mem),\nSome m = Some m' -> read_as_zero m b p 0 -> True.","proofString":"auto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m : mem) \n  (b0 : block) (p : Z) (m1 : mem) (il0 : list init_data) \n  (m' : mem),\nMem.store chunk m b0 p v = Some m1 ->\nstore_init_data_list m1 b0 (p + size_chunk chunk) il0 = Some m' ->\nMem.load chunk m' b0 p = Some (Val.load_result chunk v)) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m : mem) (p : Z) (m' : mem),\nstore_init_data_list m b p il = Some m' ->\nread_as_zero m b p (init_data_list_size il) -> load_store_init_data m' b p il) : forall (m : mem) (p : Z) (m' : mem),\nmatch store_init_data m b p a with\n| Some m'0 => store_init_data_list m'0 b (p + init_data_size a) il\n| None => None\nend = Some m' ->\nread_as_zero m b p (init_data_size a + init_data_list_size il) ->\nmatch a with\n| Init_int8 n =>\n    Mem.load Mint8unsigned m' b p = Some (Vint (Int.zero_ext 8 n)) /\\\n    load_store_init_data m' b (p + 1) il\n| Init_int16 n =>\n    Mem.load Mint16unsigned m' b p = Some (Vint (Int.zero_ext 16 n)) /\\\n    load_store_init_data m' b (p + 2) il\n| Init_int32 n =>\n    Mem.load Mint32 m' b p = Some (Vint n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_int64 n =>\n    Mem.load Mint64 m' b p = Some (Vlong n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_float32 n =>\n    Mem.load Mfloat32 m' b p = Some (Vsingle n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_float64 n =>\n    Mem.load Mfloat64 m' b p = Some (Vfloat n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_space n =>\n    read_as_zero m' b p n /\\ load_store_init_data m' b (p + Z.max n 0) il\n| Init_addrof symb ofs =>\n    (exists b' : block,\n       find_symbol ge symb = Some b' /\\\n       Mem.load Mptr m' b p = Some (Vptr b' ofs)) /\\\n    load_store_init_data m' b (p + size_chunk Mptr) il\nend.","proofString":"intros.\ndestruct (store_init_data m b p a) as [m1|] eqn:?; try congruence.\nexploit IHil; eauto.\nset (P := fun (b': block) ofs' => p + init_data_size a <= ofs').\napply read_as_zero_unchanged with (m := m) (P := P).\nred; intros; apply H0; auto.\ngeneralize (init_data_size_pos a); lia.\nlia.\neapply store_init_data_unchanged with (P := P); eauto.\nintros; unfold P.\nlia.\nintros; unfold P.\nlia.\nintro D.\ndestruct a; simpl in Heqo.\nsplit; auto.\neapply (A Mint8unsigned (Vint i)); eauto.\nsplit; auto.\neapply (A Mint16unsigned (Vint i)); eauto.\nsplit; auto.\neapply (A Mint32 (Vint i)); eauto.\nsplit; auto.\neapply (A Mint64 (Vlong i)); eauto.\nsplit; auto.\neapply (A Mfloat32 (Vsingle f)); eauto.\nsplit; auto.\neapply (A Mfloat64 (Vfloat f)); eauto.\nsplit; auto.\nset (P := fun (b': block) ofs' => ofs' < p + init_data_size (Init_space z)).\ninv Heqo.\napply read_as_zero_unchanged with (m := m1) (P := P).\nred; intros.\napply H0; auto.\nsimpl.\ngeneralize (init_data_list_size_pos il); extlia.\neapply store_init_data_list_unchanged; eauto.\nintros; unfold P.\nlia.\nintros; unfold P.\nsimpl; extlia.\nrewrite init_data_size_addrof in *.\nsplit; auto.\ndestruct (find_symbol ge i); try congruence.\nexists b0; split; auto.\ntransitivity (Some (Val.load_result Mptr (Vptr b0 i0))).\neapply (A Mptr (Vptr b0 i0)); eauto.\nunfold Val.load_result, Mptr; destruct Archi.ptr64; auto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m1 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m1 ->\nstore_init_data_list m1 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' : mem) (H : match store_init_data m b p a with\n| Some m'0 => store_init_data_list m'0 b (p + init_data_size a) il\n| None => None\nend = Some m') (H0 : read_as_zero m b p (init_data_size a + init_data_list_size il)) : match a with\n| Init_int8 n =>\n    Mem.load Mint8unsigned m' b p = Some (Vint (Int.zero_ext 8 n)) /\\\n    load_store_init_data m' b (p + 1) il\n| Init_int16 n =>\n    Mem.load Mint16unsigned m' b p = Some (Vint (Int.zero_ext 16 n)) /\\\n    load_store_init_data m' b (p + 2) il\n| Init_int32 n =>\n    Mem.load Mint32 m' b p = Some (Vint n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_int64 n =>\n    Mem.load Mint64 m' b p = Some (Vlong n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_float32 n =>\n    Mem.load Mfloat32 m' b p = Some (Vsingle n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_float64 n =>\n    Mem.load Mfloat64 m' b p = Some (Vfloat n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_space n =>\n    read_as_zero m' b p n /\\ load_store_init_data m' b (p + Z.max n 0) il\n| Init_addrof symb ofs =>\n    (exists b' : block,\n       find_symbol ge symb = Some b' /\\\n       Mem.load Mptr m' b p = Some (Vptr b' ofs)) /\\\n    load_store_init_data m' b (p + size_chunk Mptr) il\nend.","proofString":"destruct (store_init_data m b p a) as [m1|] eqn:?; try congruence.\nexploit IHil; eauto.\nset (P := fun (b': block) ofs' => p + init_data_size a <= ofs').\napply read_as_zero_unchanged with (m := m) (P := P).\nred; intros; apply H0; auto.\ngeneralize (init_data_size_pos a); lia.\nlia.\neapply store_init_data_unchanged with (P := P); eauto.\nintros; unfold P.\nlia.\nintros; unfold P.\nlia.\nintro D.\ndestruct a; simpl in Heqo.\nsplit; auto.\neapply (A Mint8unsigned (Vint i)); eauto.\nsplit; auto.\neapply (A Mint16unsigned (Vint i)); eauto.\nsplit; auto.\neapply (A Mint32 (Vint i)); eauto.\nsplit; auto.\neapply (A Mint64 (Vlong i)); eauto.\nsplit; auto.\neapply (A Mfloat32 (Vsingle f)); eauto.\nsplit; auto.\neapply (A Mfloat64 (Vfloat f)); eauto.\nsplit; auto.\nset (P := fun (b': block) ofs' => ofs' < p + init_data_size (Init_space z)).\ninv Heqo.\napply read_as_zero_unchanged with (m := m1) (P := P).\nred; intros.\napply H0; auto.\nsimpl.\ngeneralize (init_data_list_size_pos il); extlia.\neapply store_init_data_list_unchanged; eauto.\nintros; unfold P.\nlia.\nintros; unfold P.\nsimpl; extlia.\nrewrite init_data_size_addrof in *.\nsplit; auto.\ndestruct (find_symbol ge i); try congruence.\nexists b0; split; auto.\ntransitivity (Some (Val.load_result Mptr (Vptr b0 i0))).\neapply (A Mptr (Vptr b0 i0)); eauto.\nunfold Val.load_result, Mptr; destruct Archi.ptr64; auto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : read_as_zero m b p (init_data_size a + init_data_list_size il)) : match a with\n| Init_int8 n =>\n    Mem.load Mint8unsigned m' b p = Some (Vint (Int.zero_ext 8 n)) /\\\n    load_store_init_data m' b (p + 1) il\n| Init_int16 n =>\n    Mem.load Mint16unsigned m' b p = Some (Vint (Int.zero_ext 16 n)) /\\\n    load_store_init_data m' b (p + 2) il\n| Init_int32 n =>\n    Mem.load Mint32 m' b p = Some (Vint n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_int64 n =>\n    Mem.load Mint64 m' b p = Some (Vlong n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_float32 n =>\n    Mem.load Mfloat32 m' b p = Some (Vsingle n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_float64 n =>\n    Mem.load Mfloat64 m' b p = Some (Vfloat n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_space n =>\n    read_as_zero m' b p n /\\ load_store_init_data m' b (p + Z.max n 0) il\n| Init_addrof symb ofs =>\n    (exists b' : block,\n       find_symbol ge symb = Some b' /\\\n       Mem.load Mptr m' b p = Some (Vptr b' ofs)) /\\\n    load_store_init_data m' b (p + size_chunk Mptr) il\nend.","proofString":"exploit IHil; eauto.\nset (P := fun (b': block) ofs' => p + init_data_size a <= ofs').\napply read_as_zero_unchanged with (m := m) (P := P).\nred; intros; apply H0; auto.\ngeneralize (init_data_size_pos a); lia.\nlia.\neapply store_init_data_unchanged with (P := P); eauto.\nintros; unfold P.\nlia.\nintros; unfold P.\nlia.\nintro D.\ndestruct a; simpl in Heqo.\nsplit; auto.\neapply (A Mint8unsigned (Vint i)); eauto.\nsplit; auto.\neapply (A Mint16unsigned (Vint i)); eauto.\nsplit; auto.\neapply (A Mint32 (Vint i)); eauto.\nsplit; auto.\neapply (A Mint64 (Vlong i)); eauto.\nsplit; auto.\neapply (A Mfloat32 (Vsingle f)); eauto.\nsplit; auto.\neapply (A Mfloat64 (Vfloat f)); eauto.\nsplit; auto.\nset (P := fun (b': block) ofs' => ofs' < p + init_data_size (Init_space z)).\ninv Heqo.\napply read_as_zero_unchanged with (m := m1) (P := P).\nred; intros.\napply H0; auto.\nsimpl.\ngeneralize (init_data_list_size_pos il); extlia.\neapply store_init_data_list_unchanged; eauto.\nintros; unfold P.\nlia.\nintros; unfold P.\nsimpl; extlia.\nrewrite init_data_size_addrof in *.\nsplit; auto.\ndestruct (find_symbol ge i); try congruence.\nexists b0; split; auto.\ntransitivity (Some (Val.load_result Mptr (Vptr b0 i0))).\neapply (A Mptr (Vptr b0 i0)); eauto.\nunfold Val.load_result, Mptr; destruct Archi.ptr64; auto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : read_as_zero m b p (init_data_size a + init_data_list_size il)) : read_as_zero m1 b (p + init_data_size a) (init_data_list_size il).","proofString":"set (P := fun (b': block) ofs' => p + init_data_size a <= ofs').\napply read_as_zero_unchanged with (m := m) (P := P).\nred; intros; apply H0; auto.\ngeneralize (init_data_size_pos a); lia.\nlia.\neapply store_init_data_unchanged with (P := P); eauto.\nintros; unfold P.\nlia.\nintros; unfold P.\nlia."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : read_as_zero m b p (init_data_size a + init_data_list_size il)) (P : block -> Z -> Prop) : read_as_zero m b (p + init_data_size a) (init_data_list_size il).","proofString":"red; intros; apply H0; auto.\ngeneralize (init_data_size_pos a); lia.\nlia."},{"statement":"(A : forall (chunk0 : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p1 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk0 m0 b0 p1 v = Some m2 ->\nstore_init_data_list m2 b0 (p1 + size_chunk chunk0) il0 = Some m'0 ->\nMem.load chunk0 m'0 b0 p1 = Some (Val.load_result chunk0 v)) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p1 : Z) (m'0 : mem),\nstore_init_data_list m0 b p1 il = Some m'0 ->\nread_as_zero m0 b p1 (init_data_list_size il) ->\nload_store_init_data m'0 b p1 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : read_as_zero m b p (init_data_size a + init_data_list_size il)) (P : block -> Z -> Prop) (chunk : memory_chunk) (p0 : Z) (H1 : p + init_data_size a <= p0) (H2 : p0 + size_chunk chunk <= p + init_data_size a + init_data_list_size il) (H3 : (align_chunk chunk | p0)) : p <= p0.","proofString":"generalize (init_data_size_pos a); lia."},{"statement":"(A : forall (chunk0 : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p1 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk0 m0 b0 p1 v = Some m2 ->\nstore_init_data_list m2 b0 (p1 + size_chunk chunk0) il0 = Some m'0 ->\nMem.load chunk0 m'0 b0 p1 = Some (Val.load_result chunk0 v)) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p1 : Z) (m'0 : mem),\nstore_init_data_list m0 b p1 il = Some m'0 ->\nread_as_zero m0 b p1 (init_data_list_size il) ->\nload_store_init_data m'0 b p1 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : read_as_zero m b p (init_data_size a + init_data_list_size il)) (P : block -> Z -> Prop) (chunk : memory_chunk) (p0 : Z) (H1 : p + init_data_size a <= p0) (H2 : p0 + size_chunk chunk <= p + init_data_size a + init_data_list_size il) (H3 : (align_chunk chunk | p0)) : p0 + size_chunk chunk <= p + (init_data_size a + init_data_list_size il).","proofString":"lia."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : read_as_zero m b p (init_data_size a + init_data_list_size il)) (P : block -> Z -> Prop) (ofs : Z) (H1 : p <= ofs < p + init_data_size a) : ~ p + init_data_size a <= ofs.","proofString":"lia."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : read_as_zero m b p (init_data_size a + init_data_list_size il)) (P : block -> Z -> Prop) (i : Z) (H1 : p + init_data_size a <= i < p + init_data_size a + init_data_list_size il) : p + init_data_size a <= i.","proofString":"lia."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : read_as_zero m b p (init_data_size a + init_data_list_size il)) : load_store_init_data m' b (p + init_data_size a) il ->\nmatch a with\n| Init_int8 n =>\n    Mem.load Mint8unsigned m' b p = Some (Vint (Int.zero_ext 8 n)) /\\\n    load_store_init_data m' b (p + 1) il\n| Init_int16 n =>\n    Mem.load Mint16unsigned m' b p = Some (Vint (Int.zero_ext 16 n)) /\\\n    load_store_init_data m' b (p + 2) il\n| Init_int32 n =>\n    Mem.load Mint32 m' b p = Some (Vint n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_int64 n =>\n    Mem.load Mint64 m' b p = Some (Vlong n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_float32 n =>\n    Mem.load Mfloat32 m' b p = Some (Vsingle n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_float64 n =>\n    Mem.load Mfloat64 m' b p = Some (Vfloat n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_space n =>\n    read_as_zero m' b p n /\\ load_store_init_data m' b (p + Z.max n 0) il\n| Init_addrof symb ofs =>\n    (exists b' : block,\n       find_symbol ge symb = Some b' /\\\n       Mem.load Mptr m' b p = Some (Vptr b' ofs)) /\\\n    load_store_init_data m' b (p + size_chunk Mptr) il\nend.","proofString":"intro D.\ndestruct a; simpl in Heqo.\nsplit; auto.\neapply (A Mint8unsigned (Vint i)); eauto.\nsplit; auto.\neapply (A Mint16unsigned (Vint i)); eauto.\nsplit; auto.\neapply (A Mint32 (Vint i)); eauto.\nsplit; auto.\neapply (A Mint64 (Vlong i)); eauto.\nsplit; auto.\neapply (A Mfloat32 (Vsingle f)); eauto.\nsplit; auto.\neapply (A Mfloat64 (Vfloat f)); eauto.\nsplit; auto.\nset (P := fun (b': block) ofs' => ofs' < p + init_data_size (Init_space z)).\ninv Heqo.\napply read_as_zero_unchanged with (m := m1) (P := P).\nred; intros.\napply H0; auto.\nsimpl.\ngeneralize (init_data_list_size_pos il); extlia.\neapply store_init_data_list_unchanged; eauto.\nintros; unfold P.\nlia.\nintros; unfold P.\nsimpl; extlia.\nrewrite init_data_size_addrof in *.\nsplit; auto.\ndestruct (find_symbol ge i); try congruence.\nexists b0; split; auto.\ntransitivity (Some (Val.load_result Mptr (Vptr b0 i0))).\neapply (A Mptr (Vptr b0 i0)); eauto.\nunfold Val.load_result, Mptr; destruct Archi.ptr64; auto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (a : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : store_init_data m b p a = Some m1) (H : store_init_data_list m1 b (p + init_data_size a) il = Some m') (H0 : read_as_zero m b p (init_data_size a + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size a) il) : match a with\n| Init_int8 n =>\n    Mem.load Mint8unsigned m' b p = Some (Vint (Int.zero_ext 8 n)) /\\\n    load_store_init_data m' b (p + 1) il\n| Init_int16 n =>\n    Mem.load Mint16unsigned m' b p = Some (Vint (Int.zero_ext 16 n)) /\\\n    load_store_init_data m' b (p + 2) il\n| Init_int32 n =>\n    Mem.load Mint32 m' b p = Some (Vint n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_int64 n =>\n    Mem.load Mint64 m' b p = Some (Vlong n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_float32 n =>\n    Mem.load Mfloat32 m' b p = Some (Vsingle n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_float64 n =>\n    Mem.load Mfloat64 m' b p = Some (Vfloat n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_space n =>\n    read_as_zero m' b p n /\\ load_store_init_data m' b (p + Z.max n 0) il\n| Init_addrof symb ofs =>\n    (exists b' : block,\n       find_symbol ge symb = Some b' /\\\n       Mem.load Mptr m' b p = Some (Vptr b' ofs)) /\\\n    load_store_init_data m' b (p + size_chunk Mptr) il\nend.","proofString":"destruct a; simpl in Heqo.\nsplit; auto.\neapply (A Mint8unsigned (Vint i)); eauto.\nsplit; auto.\neapply (A Mint16unsigned (Vint i)); eauto.\nsplit; auto.\neapply (A Mint32 (Vint i)); eauto.\nsplit; auto.\neapply (A Mint64 (Vlong i)); eauto.\nsplit; auto.\neapply (A Mfloat32 (Vsingle f)); eauto.\nsplit; auto.\neapply (A Mfloat64 (Vfloat f)); eauto.\nsplit; auto.\nset (P := fun (b': block) ofs' => ofs' < p + init_data_size (Init_space z)).\ninv Heqo.\napply read_as_zero_unchanged with (m := m1) (P := P).\nred; intros.\napply H0; auto.\nsimpl.\ngeneralize (init_data_list_size_pos il); extlia.\neapply store_init_data_list_unchanged; eauto.\nintros; unfold P.\nlia.\nintros; unfold P.\nsimpl; extlia.\nrewrite init_data_size_addrof in *.\nsplit; auto.\ndestruct (find_symbol ge i); try congruence.\nexists b0; split; auto.\ntransitivity (Some (Val.load_result Mptr (Vptr b0 i0))).\neapply (A Mptr (Vptr b0 i0)); eauto.\nunfold Val.load_result, Mptr; destruct Archi.ptr64; auto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (i : int) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Mem.store Mint8unsigned m b p (Vint i) = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_int8 i)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_int8 i) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_int8 i)) il) : Mem.load Mint8unsigned m' b p = Some (Vint (Int.zero_ext 8 i)) /\\\nload_store_init_data m' b (p + 1) il.","proofString":"split; auto.\neapply (A Mint8unsigned (Vint i)); eauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (i : int) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Mem.store Mint8unsigned m b p (Vint i) = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_int8 i)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_int8 i) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_int8 i)) il) : Mem.load Mint8unsigned m' b p = Some (Vint (Int.zero_ext 8 i)).","proofString":"eapply (A Mint8unsigned (Vint i)); eauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (i : int) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Mem.store Mint16unsigned m b p (Vint i) = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_int16 i)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_int16 i) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_int16 i)) il) : Mem.load Mint16unsigned m' b p = Some (Vint (Int.zero_ext 16 i)) /\\\nload_store_init_data m' b (p + 2) il.","proofString":"split; auto.\neapply (A Mint16unsigned (Vint i)); eauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (i : int) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Mem.store Mint16unsigned m b p (Vint i) = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_int16 i)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_int16 i) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_int16 i)) il) : Mem.load Mint16unsigned m' b p = Some (Vint (Int.zero_ext 16 i)).","proofString":"eapply (A Mint16unsigned (Vint i)); eauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (i : int) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Mem.store Mint32 m b p (Vint i) = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_int32 i)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_int32 i) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_int32 i)) il) : Mem.load Mint32 m' b p = Some (Vint i) /\\\nload_store_init_data m' b (p + 4) il.","proofString":"split; auto.\neapply (A Mint32 (Vint i)); eauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (i : int) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Mem.store Mint32 m b p (Vint i) = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_int32 i)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_int32 i) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_int32 i)) il) : Mem.load Mint32 m' b p = Some (Vint i).","proofString":"eapply (A Mint32 (Vint i)); eauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (i : int64) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Mem.store Mint64 m b p (Vlong i) = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_int64 i)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_int64 i) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_int64 i)) il) : Mem.load Mint64 m' b p = Some (Vlong i) /\\\nload_store_init_data m' b (p + 8) il.","proofString":"split; auto.\neapply (A Mint64 (Vlong i)); eauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (i : int64) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Mem.store Mint64 m b p (Vlong i) = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_int64 i)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_int64 i) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_int64 i)) il) : Mem.load Mint64 m' b p = Some (Vlong i).","proofString":"eapply (A Mint64 (Vlong i)); eauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (f : float32) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Mem.store Mfloat32 m b p (Vsingle f) = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_float32 f)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_float32 f) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_float32 f)) il) : Mem.load Mfloat32 m' b p = Some (Vsingle f) /\\\nload_store_init_data m' b (p + 4) il.","proofString":"split; auto.\neapply (A Mfloat32 (Vsingle f)); eauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (f : float32) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Mem.store Mfloat32 m b p (Vsingle f) = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_float32 f)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_float32 f) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_float32 f)) il) : Mem.load Mfloat32 m' b p = Some (Vsingle f).","proofString":"eapply (A Mfloat32 (Vsingle f)); eauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (f : float) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Mem.store Mfloat64 m b p (Vfloat f) = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_float64 f)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_float64 f) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_float64 f)) il) : Mem.load Mfloat64 m' b p = Some (Vfloat f) /\\\nload_store_init_data m' b (p + 8) il.","proofString":"split; auto.\neapply (A Mfloat64 (Vfloat f)); eauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (f : float) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Mem.store Mfloat64 m b p (Vfloat f) = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_float64 f)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_float64 f) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_float64 f)) il) : Mem.load Mfloat64 m' b p = Some (Vfloat f).","proofString":"eapply (A Mfloat64 (Vfloat f)); eauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (z : Z) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Some m = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_space z)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_space z) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_space z)) il) : read_as_zero m' b p z /\\ load_store_init_data m' b (p + Z.max z 0) il.","proofString":"split; auto.\nset (P := fun (b': block) ofs' => ofs' < p + init_data_size (Init_space z)).\ninv Heqo.\napply read_as_zero_unchanged with (m := m1) (P := P).\nred; intros.\napply H0; auto.\nsimpl.\ngeneralize (init_data_list_size_pos il); extlia.\neapply store_init_data_list_unchanged; eauto.\nintros; unfold P.\nlia.\nintros; unfold P.\nsimpl; extlia."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (z : Z) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : Some m = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_space z)) il = Some m') (H0 : read_as_zero m b p (init_data_size (Init_space z) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_space z)) il) : read_as_zero m' b p z.","proofString":"set (P := fun (b': block) ofs' => ofs' < p + init_data_size (Init_space z)).\ninv Heqo.\napply read_as_zero_unchanged with (m := m1) (P := P).\nred; intros.\napply H0; auto.\nsimpl.\ngeneralize (init_data_list_size_pos il); extlia.\neapply store_init_data_list_unchanged; eauto.\nintros; unfold P.\nlia.\nintros; unfold P.\nsimpl; extlia."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m : mem) \n  (b0 : block) (p0 : Z) (m0 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m b0 p0 v = Some m0 ->\nstore_init_data_list m0 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (z : Z) (il : list init_data) (IHil : forall (m : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m b p0 il = Some m'0 ->\nread_as_zero m b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (p : Z) (m' m1 : mem) (H : store_init_data_list m1 b (p + init_data_size (Init_space z)) il = Some m') (H0 : read_as_zero m1 b p (init_data_size (Init_space z) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_space z)) il) (P : block -> Z -> Prop) : read_as_zero m1 b p z.","proofString":"red; intros.\napply H0; auto.\nsimpl.\ngeneralize (init_data_list_size_pos il); extlia."},{"statement":"(A : forall (chunk0 : memory_chunk) (v : val) (m : mem) \n  (b0 : block) (p1 : Z) (m0 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk0 m b0 p1 v = Some m0 ->\nstore_init_data_list m0 b0 (p1 + size_chunk chunk0) il0 = Some m'0 ->\nMem.load chunk0 m'0 b0 p1 = Some (Val.load_result chunk0 v)) (b : block) (z : Z) (il : list init_data) (IHil : forall (m : mem) (p1 : Z) (m'0 : mem),\nstore_init_data_list m b p1 il = Some m'0 ->\nread_as_zero m b p1 (init_data_list_size il) ->\nload_store_init_data m'0 b p1 il) (p : Z) (m' m1 : mem) (H : store_init_data_list m1 b (p + init_data_size (Init_space z)) il = Some m') (H0 : read_as_zero m1 b p (init_data_size (Init_space z) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_space z)) il) (P : block -> Z -> Prop) (chunk : memory_chunk) (p0 : Z) (H1 : p <= p0) (H2 : p0 + size_chunk chunk <= p + z) (H3 : (align_chunk chunk | p0)) : Mem.load chunk m1 b p0 =\nSome\n  match chunk with\n  | Mint64 => Vlong Int64.zero\n  | Mfloat32 => Vsingle Float32.zero\n  | Mfloat64 => Vfloat Float.zero\n  | Many32 | Many64 => Vundef\n  | _ => Vint Int.zero\n  end.","proofString":"apply H0; auto.\nsimpl.\ngeneralize (init_data_list_size_pos il); extlia."},{"statement":"(A : forall (chunk0 : memory_chunk) (v : val) (m : mem) \n  (b0 : block) (p1 : Z) (m0 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk0 m b0 p1 v = Some m0 ->\nstore_init_data_list m0 b0 (p1 + size_chunk chunk0) il0 = Some m'0 ->\nMem.load chunk0 m'0 b0 p1 = Some (Val.load_result chunk0 v)) (b : block) (z : Z) (il : list init_data) (IHil : forall (m : mem) (p1 : Z) (m'0 : mem),\nstore_init_data_list m b p1 il = Some m'0 ->\nread_as_zero m b p1 (init_data_list_size il) ->\nload_store_init_data m'0 b p1 il) (p : Z) (m' m1 : mem) (H : store_init_data_list m1 b (p + init_data_size (Init_space z)) il = Some m') (H0 : read_as_zero m1 b p (init_data_size (Init_space z) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_space z)) il) (P : block -> Z -> Prop) (chunk : memory_chunk) (p0 : Z) (H1 : p <= p0) (H2 : p0 + size_chunk chunk <= p + z) (H3 : (align_chunk chunk | p0)) : p0 + size_chunk chunk <=\np + (init_data_size (Init_space z) + init_data_list_size il).","proofString":"simpl.\ngeneralize (init_data_list_size_pos il); extlia."},{"statement":"(A : forall (chunk0 : memory_chunk) (v : val) (m : mem) \n  (b0 : block) (p1 : Z) (m0 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk0 m b0 p1 v = Some m0 ->\nstore_init_data_list m0 b0 (p1 + size_chunk chunk0) il0 = Some m'0 ->\nMem.load chunk0 m'0 b0 p1 = Some (Val.load_result chunk0 v)) (b : block) (z : Z) (il : list init_data) (IHil : forall (m : mem) (p1 : Z) (m'0 : mem),\nstore_init_data_list m b p1 il = Some m'0 ->\nread_as_zero m b p1 (init_data_list_size il) ->\nload_store_init_data m'0 b p1 il) (p : Z) (m' m1 : mem) (H : store_init_data_list m1 b (p + init_data_size (Init_space z)) il = Some m') (H0 : read_as_zero m1 b p (init_data_size (Init_space z) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_space z)) il) (P : block -> Z -> Prop) (chunk : memory_chunk) (p0 : Z) (H1 : p <= p0) (H2 : p0 + size_chunk chunk <= p + z) (H3 : (align_chunk chunk | p0)) : p0 + size_chunk chunk <= p + (Z.max z 0 + init_data_list_size il).","proofString":"generalize (init_data_list_size_pos il); extlia."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m : mem) \n  (b0 : block) (p0 : Z) (m0 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m b0 p0 v = Some m0 ->\nstore_init_data_list m0 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (z : Z) (il : list init_data) (IHil : forall (m : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m b p0 il = Some m'0 ->\nread_as_zero m b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (p : Z) (m' m1 : mem) (H : store_init_data_list m1 b (p + init_data_size (Init_space z)) il = Some m') (H0 : read_as_zero m1 b p (init_data_size (Init_space z) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_space z)) il) (P : block -> Z -> Prop) (ofs : Z) (H1 : p + init_data_size (Init_space z) <= ofs) : ~ ofs < p + init_data_size (Init_space z).","proofString":"lia."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m : mem) \n  (b0 : block) (p0 : Z) (m0 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m b0 p0 v = Some m0 ->\nstore_init_data_list m0 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (z : Z) (il : list init_data) (IHil : forall (m : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m b p0 il = Some m'0 ->\nread_as_zero m b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (p : Z) (m' m1 : mem) (H : store_init_data_list m1 b (p + init_data_size (Init_space z)) il = Some m') (H0 : read_as_zero m1 b p (init_data_size (Init_space z) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_space z)) il) (P : block -> Z -> Prop) (i : Z) (H1 : p <= i < p + z) : i < p + init_data_size (Init_space z).","proofString":"simpl; extlia."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (i : ident) (i0 : ptrofs) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : match find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m1) (H : store_init_data_list m1 b (p + init_data_size (Init_addrof i i0)) il =\nSome m') (H0 : read_as_zero m b p\n  (init_data_size (Init_addrof i i0) + init_data_list_size il)) (D : load_store_init_data m' b (p + init_data_size (Init_addrof i i0)) il) : (exists b' : block,\n   find_symbol ge i = Some b' /\\ Mem.load Mptr m' b p = Some (Vptr b' i0)) /\\\nload_store_init_data m' b (p + size_chunk Mptr) il.","proofString":"rewrite init_data_size_addrof in *.\nsplit; auto.\ndestruct (find_symbol ge i); try congruence.\nexists b0; split; auto.\ntransitivity (Some (Val.load_result Mptr (Vptr b0 i0))).\neapply (A Mptr (Vptr b0 i0)); eauto.\nunfold Val.load_result, Mptr; destruct Archi.ptr64; auto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (i : ident) (i0 : ptrofs) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : match find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m1) (H : store_init_data_list m1 b (p + size_chunk Mptr) il = Some m') (H0 : read_as_zero m b p (size_chunk Mptr + init_data_list_size il)) (D : load_store_init_data m' b (p + size_chunk Mptr) il) : (exists b' : block,\n   find_symbol ge i = Some b' /\\ Mem.load Mptr m' b p = Some (Vptr b' i0)) /\\\nload_store_init_data m' b (p + size_chunk Mptr) il.","proofString":"split; auto.\ndestruct (find_symbol ge i); try congruence.\nexists b0; split; auto.\ntransitivity (Some (Val.load_result Mptr (Vptr b0 i0))).\neapply (A Mptr (Vptr b0 i0)); eauto.\nunfold Val.load_result, Mptr; destruct Archi.ptr64; auto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b0 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b0 p0 v = Some m2 ->\nstore_init_data_list m2 b0 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b0 p0 = Some (Val.load_result chunk v)) (b : block) (i : ident) (i0 : ptrofs) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (Heqo : match find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m1) (H : store_init_data_list m1 b (p + size_chunk Mptr) il = Some m') (H0 : read_as_zero m b p (size_chunk Mptr + init_data_list_size il)) (D : load_store_init_data m' b (p + size_chunk Mptr) il) : exists b' : block,\n  find_symbol ge i = Some b' /\\ Mem.load Mptr m' b p = Some (Vptr b' i0).","proofString":"destruct (find_symbol ge i); try congruence.\nexists b0; split; auto.\ntransitivity (Some (Val.load_result Mptr (Vptr b0 i0))).\neapply (A Mptr (Vptr b0 i0)); eauto.\nunfold Val.load_result, Mptr; destruct Archi.ptr64; auto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b1 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b1 p0 v = Some m2 ->\nstore_init_data_list m2 b1 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b1 p0 = Some (Val.load_result chunk v)) (b : block) (i : ident) (i0 : ptrofs) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (b0 : block) (Heqo : Mem.store Mptr m b p (Vptr b0 i0) = Some m1) (H : store_init_data_list m1 b (p + size_chunk Mptr) il = Some m') (H0 : read_as_zero m b p (size_chunk Mptr + init_data_list_size il)) (D : load_store_init_data m' b (p + size_chunk Mptr) il) : exists b' : block,\n  Some b0 = Some b' /\\ Mem.load Mptr m' b p = Some (Vptr b' i0).","proofString":"exists b0; split; auto.\ntransitivity (Some (Val.load_result Mptr (Vptr b0 i0))).\neapply (A Mptr (Vptr b0 i0)); eauto.\nunfold Val.load_result, Mptr; destruct Archi.ptr64; auto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b1 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b1 p0 v = Some m2 ->\nstore_init_data_list m2 b1 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b1 p0 = Some (Val.load_result chunk v)) (b : block) (i : ident) (i0 : ptrofs) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (b0 : block) (Heqo : Mem.store Mptr m b p (Vptr b0 i0) = Some m1) (H : store_init_data_list m1 b (p + size_chunk Mptr) il = Some m') (H0 : read_as_zero m b p (size_chunk Mptr + init_data_list_size il)) (D : load_store_init_data m' b (p + size_chunk Mptr) il) : Mem.load Mptr m' b p = Some (Vptr b0 i0).","proofString":"transitivity (Some (Val.load_result Mptr (Vptr b0 i0))).\neapply (A Mptr (Vptr b0 i0)); eauto.\nunfold Val.load_result, Mptr; destruct Archi.ptr64; auto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b1 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b1 p0 v = Some m2 ->\nstore_init_data_list m2 b1 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b1 p0 = Some (Val.load_result chunk v)) (b : block) (i : ident) (i0 : ptrofs) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (b0 : block) (Heqo : Mem.store Mptr m b p (Vptr b0 i0) = Some m1) (H : store_init_data_list m1 b (p + size_chunk Mptr) il = Some m') (H0 : read_as_zero m b p (size_chunk Mptr + init_data_list_size il)) (D : load_store_init_data m' b (p + size_chunk Mptr) il) : Mem.load Mptr m' b p = Some (Val.load_result Mptr (Vptr b0 i0)).","proofString":"eapply (A Mptr (Vptr b0 i0)); eauto."},{"statement":"(A : forall (chunk : memory_chunk) (v : val) (m0 : mem) \n  (b1 : block) (p0 : Z) (m2 : mem) (il0 : list init_data) \n  (m'0 : mem),\nMem.store chunk m0 b1 p0 v = Some m2 ->\nstore_init_data_list m2 b1 (p0 + size_chunk chunk) il0 = Some m'0 ->\nMem.load chunk m'0 b1 p0 = Some (Val.load_result chunk v)) (b : block) (i : ident) (i0 : ptrofs) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list m0 b p0 il = Some m'0 ->\nread_as_zero m0 b p0 (init_data_list_size il) ->\nload_store_init_data m'0 b p0 il) (m : mem) (p : Z) (m' m1 : mem) (b0 : block) (Heqo : Mem.store Mptr m b p (Vptr b0 i0) = Some m1) (H : store_init_data_list m1 b (p + size_chunk Mptr) il = Some m') (H0 : read_as_zero m b p (size_chunk Mptr + init_data_list_size il)) (D : load_store_init_data m' b (p + size_chunk Mptr) il) : Some (Val.load_result Mptr (Vptr b0 i0)) = Some (Vptr b0 i0).","proofString":"unfold Val.load_result, Mptr; destruct Archi.ptr64; auto."},{"statement":"(P : block -> Z -> Prop) (m : mem) (id : ident) (g : globdef F V) (m' : mem) (H : alloc_global m (id, g) = Some m') : Mem.unchanged_on P m m'.","proofString":"destruct g as [f|v]; simpl in H.\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:?.\nset (Q := fun b' (ofs: Z) => b' <> b).\napply Mem.unchanged_on_implies with Q.\napply Mem.unchanged_on_trans with m1.\neapply Mem.alloc_unchanged_on; eauto.\neapply Mem.drop_perm_unchanged_on; eauto.\nintros; red.\napply Mem.valid_not_valid_diff with m; eauto with mem.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nset (Q := fun b' (ofs: Z) => b' <> b).\napply Mem.unchanged_on_implies with Q.\napply Mem.unchanged_on_trans with m1.\neapply Mem.alloc_unchanged_on; eauto.\napply Mem.unchanged_on_trans with m2.\neapply store_zeros_unchanged; eauto.\napply Mem.unchanged_on_trans with m3.\neapply store_init_data_list_unchanged; eauto.\neapply Mem.drop_perm_unchanged_on; eauto.\nintros; red.\napply Mem.valid_not_valid_diff with m; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m : mem) (id : ident) (f : F) (m' : mem) (H : (let (m1, b) := Mem.alloc m 0 1 in Mem.drop_perm m1 b 0 1 Nonempty) = Some m') : Mem.unchanged_on P m m'.","proofString":"destruct (Mem.alloc m 0 1) as [m1 b] eqn:?.\nset (Q := fun b' (ofs: Z) => b' <> b).\napply Mem.unchanged_on_implies with Q.\napply Mem.unchanged_on_trans with m1.\neapply Mem.alloc_unchanged_on; eauto.\neapply Mem.drop_perm_unchanged_on; eauto.\nintros; red.\napply Mem.valid_not_valid_diff with m; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m : mem) (id : ident) (f : F) (m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') : Mem.unchanged_on P m m'.","proofString":"set (Q := fun b' (ofs: Z) => b' <> b).\napply Mem.unchanged_on_implies with Q.\napply Mem.unchanged_on_trans with m1.\neapply Mem.alloc_unchanged_on; eauto.\neapply Mem.drop_perm_unchanged_on; eauto.\nintros; red.\napply Mem.valid_not_valid_diff with m; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m : mem) (id : ident) (f : F) (m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (Q : block -> Z -> Prop) : Mem.unchanged_on Q m m1.","proofString":"eapply Mem.alloc_unchanged_on; eauto."},{"statement":"(P : block -> Z -> Prop) (m : mem) (id : ident) (f : F) (m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (Q : block -> Z -> Prop) (b0 : block) (ofs : Z) (H0 : P b0 ofs) (H1 : Mem.valid_block m b0) : b0 <> b.","proofString":"apply Mem.valid_not_valid_diff with m; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m : mem) (id : ident) (v : globvar V) (m' : mem) (H : (let (m1, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n match store_zeros m1 b 0 (init_data_list_size (gvar_init v)) with\n | Some m2 =>\n     match store_init_data_list m2 b 0 (gvar_init v) with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n           (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') : Mem.unchanged_on P m m'.","proofString":"set (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nset (Q := fun b' (ofs: Z) => b' <> b).\napply Mem.unchanged_on_implies with Q.\napply Mem.unchanged_on_trans with m1.\neapply Mem.alloc_unchanged_on; eauto.\napply Mem.unchanged_on_trans with m2.\neapply store_zeros_unchanged; eauto.\napply Mem.unchanged_on_trans with m3.\neapply store_init_data_list_unchanged; eauto.\neapply Mem.drop_perm_unchanged_on; eauto.\nintros; red.\napply Mem.valid_not_valid_diff with m; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m : mem) (id : ident) (v : globvar V) (m' : mem) (init : list init_data) (H : (let (m1, b) := Mem.alloc m 0 (init_data_list_size init) in\n match store_zeros m1 b 0 (init_data_list_size init) with\n | Some m2 =>\n     match store_init_data_list m2 b 0 init with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size init) (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') : Mem.unchanged_on P m m'.","proofString":"set (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nset (Q := fun b' (ofs: Z) => b' <> b).\napply Mem.unchanged_on_implies with Q.\napply Mem.unchanged_on_trans with m1.\neapply Mem.alloc_unchanged_on; eauto.\napply Mem.unchanged_on_trans with m2.\neapply store_zeros_unchanged; eauto.\napply Mem.unchanged_on_trans with m3.\neapply store_init_data_list_unchanged; eauto.\neapply Mem.drop_perm_unchanged_on; eauto.\nintros; red.\napply Mem.valid_not_valid_diff with m; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m : mem) (id : ident) (v : globvar V) (m' : mem) (init : list init_data) (sz : Z) (H : (let (m1, b) := Mem.alloc m 0 sz in\n match store_zeros m1 b 0 sz with\n | Some m2 =>\n     match store_init_data_list m2 b 0 init with\n     | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') : Mem.unchanged_on P m m'.","proofString":"destruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nset (Q := fun b' (ofs: Z) => b' <> b).\napply Mem.unchanged_on_implies with Q.\napply Mem.unchanged_on_trans with m1.\neapply Mem.alloc_unchanged_on; eauto.\napply Mem.unchanged_on_trans with m2.\neapply store_zeros_unchanged; eauto.\napply Mem.unchanged_on_trans with m3.\neapply store_init_data_list_unchanged; eauto.\neapply Mem.drop_perm_unchanged_on; eauto.\nintros; red.\napply Mem.valid_not_valid_diff with m; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m : mem) (id : ident) (v : globvar V) (m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (H : match store_zeros m1 b 0 sz with\n| Some m2 =>\n    match store_init_data_list m2 b 0 init with\n    | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n    | None => None\n    end\n| None => None\nend = Some m') : Mem.unchanged_on P m m'.","proofString":"destruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nset (Q := fun b' (ofs: Z) => b' <> b).\napply Mem.unchanged_on_implies with Q.\napply Mem.unchanged_on_trans with m1.\neapply Mem.alloc_unchanged_on; eauto.\napply Mem.unchanged_on_trans with m2.\neapply store_zeros_unchanged; eauto.\napply Mem.unchanged_on_trans with m3.\neapply store_init_data_list_unchanged; eauto.\neapply Mem.drop_perm_unchanged_on; eauto.\nintros; red.\napply Mem.valid_not_valid_diff with m; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m : mem) (id : ident) (v : globvar V) (m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (H : match store_init_data_list m2 b 0 init with\n| Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n| None => None\nend = Some m') : Mem.unchanged_on P m m'.","proofString":"destruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nset (Q := fun b' (ofs: Z) => b' <> b).\napply Mem.unchanged_on_implies with Q.\napply Mem.unchanged_on_trans with m1.\neapply Mem.alloc_unchanged_on; eauto.\napply Mem.unchanged_on_trans with m2.\neapply store_zeros_unchanged; eauto.\napply Mem.unchanged_on_trans with m3.\neapply store_init_data_list_unchanged; eauto.\neapply Mem.drop_perm_unchanged_on; eauto.\nintros; red.\napply Mem.valid_not_valid_diff with m; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m : mem) (id : ident) (v : globvar V) (m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') : Mem.unchanged_on P m m'.","proofString":"set (Q := fun b' (ofs: Z) => b' <> b).\napply Mem.unchanged_on_implies with Q.\napply Mem.unchanged_on_trans with m1.\neapply Mem.alloc_unchanged_on; eauto.\napply Mem.unchanged_on_trans with m2.\neapply store_zeros_unchanged; eauto.\napply Mem.unchanged_on_trans with m3.\neapply store_init_data_list_unchanged; eauto.\neapply Mem.drop_perm_unchanged_on; eauto.\nintros; red.\napply Mem.valid_not_valid_diff with m; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m : mem) (id : ident) (v : globvar V) (m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (Q : block -> Z -> Prop) : Mem.unchanged_on Q m m1.","proofString":"eapply Mem.alloc_unchanged_on; eauto."},{"statement":"(P : block -> Z -> Prop) (m : mem) (id : ident) (v : globvar V) (m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (Q : block -> Z -> Prop) (b0 : block) (ofs : Z) (H0 : P b0 ofs) (H1 : Mem.valid_block m b0) : b0 <> b.","proofString":"apply Mem.valid_not_valid_diff with m; eauto with mem."},{"statement":"(P : block -> Z -> Prop) (m m' : mem) (H : Some m = Some m') : Mem.unchanged_on P m m'.","proofString":"inv H.\napply Mem.unchanged_on_refl."},{"statement":"(P : block -> Z -> Prop) (m' : mem) : Mem.unchanged_on P m' m'.","proofString":"apply Mem.unchanged_on_refl."},{"statement":"(P : block -> Z -> Prop) (a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 -> Mem.unchanged_on P m0 m'0) (m m' : mem) (H : match alloc_global m a with\n| Some m'0 => alloc_globals m'0 gl\n| None => None\nend = Some m') : Mem.unchanged_on P m m'.","proofString":"destruct (alloc_global m a) as [m''|] eqn:?; try discriminate.\ndestruct a as [id g].\napply Mem.unchanged_on_trans with m''.\neapply alloc_global_unchanged; eauto.\napply IHgl; auto."},{"statement":"(P : block -> Z -> Prop) (a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 -> Mem.unchanged_on P m0 m'0) (m m' m'' : mem) (Heqo : alloc_global m a = Some m'') (H : alloc_globals m'' gl = Some m') : Mem.unchanged_on P m m'.","proofString":"destruct a as [id g].\napply Mem.unchanged_on_trans with m''.\neapply alloc_global_unchanged; eauto.\napply IHgl; auto."},{"statement":"(P : block -> Z -> Prop) (id : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 -> Mem.unchanged_on P m0 m'0) (m m' m'' : mem) (Heqo : alloc_global m (id, g) = Some m'') (H : alloc_globals m'' gl = Some m') : Mem.unchanged_on P m m'.","proofString":"apply Mem.unchanged_on_trans with m''.\neapply alloc_global_unchanged; eauto.\napply IHgl; auto."},{"statement":"(P : block -> Z -> Prop) (id : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 -> Mem.unchanged_on P m0 m'0) (m m' m'' : mem) (Heqo : alloc_global m (id, g) = Some m'') (H : alloc_globals m'' gl = Some m') : Mem.unchanged_on P m m''.","proofString":"eapply alloc_global_unchanged; eauto."},{"statement":"(P : block -> Z -> Prop) (id : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals m0 gl = Some m'0 -> Mem.unchanged_on P m0 m'0) (m m' m'' : mem) (Heqo : alloc_global m (id, g) = Some m'') (H : alloc_globals m'' gl = Some m') : Mem.unchanged_on P m'' m'.","proofString":"apply IHgl; auto."},{"statement":"(m m' : mem) (b : block) (H : forall (chunk : memory_chunk) (ofs : Z),\nMem.load chunk m' b ofs = Mem.load chunk m b ofs) (p : Z) : True -> True.","proofString":"auto."},{"statement":"(m m' : mem) (b : block) (H : forall (chunk : memory_chunk) (ofs : Z),\nMem.load chunk m' b ofs = Mem.load chunk m b ofs) (a : init_data) (il : list init_data) (IHil : forall p0 : Z,\nload_store_init_data m b p0 il -> load_store_init_data m' b p0 il) (p : Z) : match a with\n| Init_int8 n =>\n    Mem.load Mint8unsigned m b p = Some (Vint (Int.zero_ext 8 n)) /\\\n    load_store_init_data m b (p + 1) il\n| Init_int16 n =>\n    Mem.load Mint16unsigned m b p = Some (Vint (Int.zero_ext 16 n)) /\\\n    load_store_init_data m b (p + 2) il\n| Init_int32 n =>\n    Mem.load Mint32 m b p = Some (Vint n) /\\\n    load_store_init_data m b (p + 4) il\n| Init_int64 n =>\n    Mem.load Mint64 m b p = Some (Vlong n) /\\\n    load_store_init_data m b (p + 8) il\n| Init_float32 n =>\n    Mem.load Mfloat32 m b p = Some (Vsingle n) /\\\n    load_store_init_data m b (p + 4) il\n| Init_float64 n =>\n    Mem.load Mfloat64 m b p = Some (Vfloat n) /\\\n    load_store_init_data m b (p + 8) il\n| Init_space n =>\n    read_as_zero m b p n /\\ load_store_init_data m b (p + Z.max n 0) il\n| Init_addrof symb ofs =>\n    (exists b' : block,\n       find_symbol ge symb = Some b' /\\\n       Mem.load Mptr m b p = Some (Vptr b' ofs)) /\\\n    load_store_init_data m b (p + size_chunk Mptr) il\nend ->\nmatch a with\n| Init_int8 n =>\n    Mem.load Mint8unsigned m' b p = Some (Vint (Int.zero_ext 8 n)) /\\\n    load_store_init_data m' b (p + 1) il\n| Init_int16 n =>\n    Mem.load Mint16unsigned m' b p = Some (Vint (Int.zero_ext 16 n)) /\\\n    load_store_init_data m' b (p + 2) il\n| Init_int32 n =>\n    Mem.load Mint32 m' b p = Some (Vint n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_int64 n =>\n    Mem.load Mint64 m' b p = Some (Vlong n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_float32 n =>\n    Mem.load Mfloat32 m' b p = Some (Vsingle n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_float64 n =>\n    Mem.load Mfloat64 m' b p = Some (Vfloat n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_space n =>\n    read_as_zero m' b p n /\\ load_store_init_data m' b (p + Z.max n 0) il\n| Init_addrof symb ofs =>\n    (exists b' : block,\n       find_symbol ge symb = Some b' /\\\n       Mem.load Mptr m' b p = Some (Vptr b' ofs)) /\\\n    load_store_init_data m' b (p + size_chunk Mptr) il\nend.","proofString":"rewrite ! H.\ndestruct a; intuition.\nred; intros; rewrite H; auto."},{"statement":"(m m' : mem) (b : block) (H : forall (chunk : memory_chunk) (ofs : Z),\nMem.load chunk m' b ofs = Mem.load chunk m b ofs) (a : init_data) (il : list init_data) (IHil : forall p0 : Z,\nload_store_init_data m b p0 il -> load_store_init_data m' b p0 il) (p : Z) : match a with\n| Init_int8 n =>\n    Mem.load Mint8unsigned m b p = Some (Vint (Int.zero_ext 8 n)) /\\\n    load_store_init_data m b (p + 1) il\n| Init_int16 n =>\n    Mem.load Mint16unsigned m b p = Some (Vint (Int.zero_ext 16 n)) /\\\n    load_store_init_data m b (p + 2) il\n| Init_int32 n =>\n    Mem.load Mint32 m b p = Some (Vint n) /\\\n    load_store_init_data m b (p + 4) il\n| Init_int64 n =>\n    Mem.load Mint64 m b p = Some (Vlong n) /\\\n    load_store_init_data m b (p + 8) il\n| Init_float32 n =>\n    Mem.load Mfloat32 m b p = Some (Vsingle n) /\\\n    load_store_init_data m b (p + 4) il\n| Init_float64 n =>\n    Mem.load Mfloat64 m b p = Some (Vfloat n) /\\\n    load_store_init_data m b (p + 8) il\n| Init_space n =>\n    read_as_zero m b p n /\\ load_store_init_data m b (p + Z.max n 0) il\n| Init_addrof symb ofs =>\n    (exists b' : block,\n       find_symbol ge symb = Some b' /\\\n       Mem.load Mptr m b p = Some (Vptr b' ofs)) /\\\n    load_store_init_data m b (p + size_chunk Mptr) il\nend ->\nmatch a with\n| Init_int8 n =>\n    Mem.load Mint8unsigned m b p = Some (Vint (Int.zero_ext 8 n)) /\\\n    load_store_init_data m' b (p + 1) il\n| Init_int16 n =>\n    Mem.load Mint16unsigned m b p = Some (Vint (Int.zero_ext 16 n)) /\\\n    load_store_init_data m' b (p + 2) il\n| Init_int32 n =>\n    Mem.load Mint32 m b p = Some (Vint n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_int64 n =>\n    Mem.load Mint64 m b p = Some (Vlong n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_float32 n =>\n    Mem.load Mfloat32 m b p = Some (Vsingle n) /\\\n    load_store_init_data m' b (p + 4) il\n| Init_float64 n =>\n    Mem.load Mfloat64 m b p = Some (Vfloat n) /\\\n    load_store_init_data m' b (p + 8) il\n| Init_space n =>\n    read_as_zero m' b p n /\\ load_store_init_data m' b (p + Z.max n 0) il\n| Init_addrof symb ofs =>\n    (exists b' : block,\n       find_symbol ge symb = Some b' /\\\n       Mem.load Mptr m b p = Some (Vptr b' ofs)) /\\\n    load_store_init_data m' b (p + size_chunk Mptr) il\nend.","proofString":"destruct a; intuition.\nred; intros; rewrite H; auto."},{"statement":"(m m' : mem) (b : block) (H : forall (chunk : memory_chunk) (ofs : Z),\nMem.load chunk m' b ofs = Mem.load chunk m b ofs) (z : Z) (il : list init_data) (IHil : forall p0 : Z,\nload_store_init_data m b p0 il -> load_store_init_data m' b p0 il) (p : Z) (H1 : read_as_zero m b p z) (H2 : load_store_init_data m b (p + Z.max z 0) il) : read_as_zero m' b p z.","proofString":"red; intros; rewrite H; auto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) : globals_initialized (add_global g (id, gd)) m' /\\\ngenv_next (add_global g (id, gd)) = Mem.nextblock m'.","proofString":"exploit alloc_global_nextblock; eauto.\nintros NB.\nsplit.\nred; intros.\nunfold find_def in H2; simpl in H2.\nrewrite PTree.gsspec in H2.\ndestruct (peq b (genv_next g)).\ninv H2.\ndestruct gd0 as [f|v]; simpl in H0.\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:ALLOC.\nexploit Mem.alloc_result; eauto.\nintros RES.\nrewrite H, <- RES.\nsplit.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nexploit Mem.alloc_result; eauto.\nintro RES.\nreplace (genv_next g) with b by congruence.\nsplit.\nred; intros.\neapply Mem.perm_drop_1; eauto.\nsplit.\nintros.\nassert (0 <= ofs < sz).\neapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto.\nsplit; auto.\neapply Mem.perm_drop_2; eauto.\nsplit.\nintros NOTVOL.\napply load_store_init_data_invariant with m3.\nintros.\neapply Mem.load_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_charact; eauto.\neapply store_zeros_read_as_zero; eauto.\nintros NOTVOL.\ntransitivity (Mem.loadbytes m3 b 0 sz).\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_loadbytes; eauto.\neapply store_zeros_loadbytes; eauto.\nassert (U: Mem.unchanged_on (fun _ _ => True) m m') by (eapply alloc_global_unchanged; eauto).\nassert (VALID: Mem.valid_block m b).\nred.\nrewrite <- H.\neapply genv_defs_range; eauto.\nexploit H1; eauto.\ndestruct gd0 as [f|v].\nintros [A B]; split; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros (A & B & C & D).\nsplit; [| split; [| split]].\nred; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\nintros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I.\nintros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I.\nsimpl.\ncongruence."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) : Mem.nextblock m' = Pos.succ (Mem.nextblock m) ->\nglobals_initialized (add_global g (id, gd)) m' /\\\ngenv_next (add_global g (id, gd)) = Mem.nextblock m'.","proofString":"intros NB.\nsplit.\nred; intros.\nunfold find_def in H2; simpl in H2.\nrewrite PTree.gsspec in H2.\ndestruct (peq b (genv_next g)).\ninv H2.\ndestruct gd0 as [f|v]; simpl in H0.\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:ALLOC.\nexploit Mem.alloc_result; eauto.\nintros RES.\nrewrite H, <- RES.\nsplit.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nexploit Mem.alloc_result; eauto.\nintro RES.\nreplace (genv_next g) with b by congruence.\nsplit.\nred; intros.\neapply Mem.perm_drop_1; eauto.\nsplit.\nintros.\nassert (0 <= ofs < sz).\neapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto.\nsplit; auto.\neapply Mem.perm_drop_2; eauto.\nsplit.\nintros NOTVOL.\napply load_store_init_data_invariant with m3.\nintros.\neapply Mem.load_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_charact; eauto.\neapply store_zeros_read_as_zero; eauto.\nintros NOTVOL.\ntransitivity (Mem.loadbytes m3 b 0 sz).\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_loadbytes; eauto.\neapply store_zeros_loadbytes; eauto.\nassert (U: Mem.unchanged_on (fun _ _ => True) m m') by (eapply alloc_global_unchanged; eauto).\nassert (VALID: Mem.valid_block m b).\nred.\nrewrite <- H.\neapply genv_defs_range; eauto.\nexploit H1; eauto.\ndestruct gd0 as [f|v].\nintros [A B]; split; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros (A & B & C & D).\nsplit; [| split; [| split]].\nred; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\nintros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I.\nintros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I.\nsimpl.\ncongruence."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) : globals_initialized (add_global g (id, gd)) m' /\\\ngenv_next (add_global g (id, gd)) = Mem.nextblock m'.","proofString":"split.\nred; intros.\nunfold find_def in H2; simpl in H2.\nrewrite PTree.gsspec in H2.\ndestruct (peq b (genv_next g)).\ninv H2.\ndestruct gd0 as [f|v]; simpl in H0.\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:ALLOC.\nexploit Mem.alloc_result; eauto.\nintros RES.\nrewrite H, <- RES.\nsplit.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nexploit Mem.alloc_result; eauto.\nintro RES.\nreplace (genv_next g) with b by congruence.\nsplit.\nred; intros.\neapply Mem.perm_drop_1; eauto.\nsplit.\nintros.\nassert (0 <= ofs < sz).\neapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto.\nsplit; auto.\neapply Mem.perm_drop_2; eauto.\nsplit.\nintros NOTVOL.\napply load_store_init_data_invariant with m3.\nintros.\neapply Mem.load_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_charact; eauto.\neapply store_zeros_read_as_zero; eauto.\nintros NOTVOL.\ntransitivity (Mem.loadbytes m3 b 0 sz).\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_loadbytes; eauto.\neapply store_zeros_loadbytes; eauto.\nassert (U: Mem.unchanged_on (fun _ _ => True) m m') by (eapply alloc_global_unchanged; eauto).\nassert (VALID: Mem.valid_block m b).\nred.\nrewrite <- H.\neapply genv_defs_range; eauto.\nexploit H1; eauto.\ndestruct gd0 as [f|v].\nintros [A B]; split; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros (A & B & C & D).\nsplit; [| split; [| split]].\nred; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\nintros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I.\nintros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I.\nsimpl.\ncongruence."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) : globals_initialized (add_global g (id, gd)) m'.","proofString":"red; intros.\nunfold find_def in H2; simpl in H2.\nrewrite PTree.gsspec in H2.\ndestruct (peq b (genv_next g)).\ninv H2.\ndestruct gd0 as [f|v]; simpl in H0.\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:ALLOC.\nexploit Mem.alloc_result; eauto.\nintros RES.\nrewrite H, <- RES.\nsplit.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nexploit Mem.alloc_result; eauto.\nintro RES.\nreplace (genv_next g) with b by congruence.\nsplit.\nred; intros.\neapply Mem.perm_drop_1; eauto.\nsplit.\nintros.\nassert (0 <= ofs < sz).\neapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto.\nsplit; auto.\neapply Mem.perm_drop_2; eauto.\nsplit.\nintros NOTVOL.\napply load_store_init_data_invariant with m3.\nintros.\neapply Mem.load_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_charact; eauto.\neapply store_zeros_read_as_zero; eauto.\nintros NOTVOL.\ntransitivity (Mem.loadbytes m3 b 0 sz).\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_loadbytes; eauto.\neapply store_zeros_loadbytes; eauto.\nassert (U: Mem.unchanged_on (fun _ _ => True) m m') by (eapply alloc_global_unchanged; eauto).\nassert (VALID: Mem.valid_block m b).\nred.\nrewrite <- H.\neapply genv_defs_range; eauto.\nexploit H1; eauto.\ndestruct gd0 as [f|v].\nintros [A B]; split; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros (A & B & C & D).\nsplit; [| split; [| split]].\nred; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\nintros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I.\nintros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (gd0 : globdef F V) (H2 : find_def (add_global g (id, gd)) b = Some gd0) : match gd0 with\n| Gfun _ =>\n    Mem.perm m' b 0 Cur Nonempty /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p -> ofs = 0 /\\ p = Nonempty)\n| Gvar v =>\n    Mem.range_perm m' b 0 (init_data_list_size (gvar_init v)) Cur\n      (perm_globvar v) /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p ->\n     0 <= ofs < init_data_list_size (gvar_init v) /\\\n     perm_order (perm_globvar v) p) /\\\n    (gvar_volatile v = false -> load_store_init_data m' b 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes m' b 0 (init_data_list_size (gvar_init v)) =\n     Some (bytes_of_init_data_list (gvar_init v)))\nend.","proofString":"unfold find_def in H2; simpl in H2.\nrewrite PTree.gsspec in H2.\ndestruct (peq b (genv_next g)).\ninv H2.\ndestruct gd0 as [f|v]; simpl in H0.\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:ALLOC.\nexploit Mem.alloc_result; eauto.\nintros RES.\nrewrite H, <- RES.\nsplit.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nexploit Mem.alloc_result; eauto.\nintro RES.\nreplace (genv_next g) with b by congruence.\nsplit.\nred; intros.\neapply Mem.perm_drop_1; eauto.\nsplit.\nintros.\nassert (0 <= ofs < sz).\neapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto.\nsplit; auto.\neapply Mem.perm_drop_2; eauto.\nsplit.\nintros NOTVOL.\napply load_store_init_data_invariant with m3.\nintros.\neapply Mem.load_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_charact; eauto.\neapply store_zeros_read_as_zero; eauto.\nintros NOTVOL.\ntransitivity (Mem.loadbytes m3 b 0 sz).\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_loadbytes; eauto.\neapply store_zeros_loadbytes; eauto.\nassert (U: Mem.unchanged_on (fun _ _ => True) m m') by (eapply alloc_global_unchanged; eauto).\nassert (VALID: Mem.valid_block m b).\nred.\nrewrite <- H.\neapply genv_defs_range; eauto.\nexploit H1; eauto.\ndestruct gd0 as [f|v].\nintros [A B]; split; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros (A & B & C & D).\nsplit; [| split; [| split]].\nred; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\nintros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I.\nintros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (gd0 : globdef F V) (H2 : (PTree.set (genv_next g) gd (genv_defs g)) ! b = Some gd0) : match gd0 with\n| Gfun _ =>\n    Mem.perm m' b 0 Cur Nonempty /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p -> ofs = 0 /\\ p = Nonempty)\n| Gvar v =>\n    Mem.range_perm m' b 0 (init_data_list_size (gvar_init v)) Cur\n      (perm_globvar v) /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p ->\n     0 <= ofs < init_data_list_size (gvar_init v) /\\\n     perm_order (perm_globvar v) p) /\\\n    (gvar_volatile v = false -> load_store_init_data m' b 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes m' b 0 (init_data_list_size (gvar_init v)) =\n     Some (bytes_of_init_data_list (gvar_init v)))\nend.","proofString":"rewrite PTree.gsspec in H2.\ndestruct (peq b (genv_next g)).\ninv H2.\ndestruct gd0 as [f|v]; simpl in H0.\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:ALLOC.\nexploit Mem.alloc_result; eauto.\nintros RES.\nrewrite H, <- RES.\nsplit.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nexploit Mem.alloc_result; eauto.\nintro RES.\nreplace (genv_next g) with b by congruence.\nsplit.\nred; intros.\neapply Mem.perm_drop_1; eauto.\nsplit.\nintros.\nassert (0 <= ofs < sz).\neapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto.\nsplit; auto.\neapply Mem.perm_drop_2; eauto.\nsplit.\nintros NOTVOL.\napply load_store_init_data_invariant with m3.\nintros.\neapply Mem.load_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_charact; eauto.\neapply store_zeros_read_as_zero; eauto.\nintros NOTVOL.\ntransitivity (Mem.loadbytes m3 b 0 sz).\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_loadbytes; eauto.\neapply store_zeros_loadbytes; eauto.\nassert (U: Mem.unchanged_on (fun _ _ => True) m m') by (eapply alloc_global_unchanged; eauto).\nassert (VALID: Mem.valid_block m b).\nred.\nrewrite <- H.\neapply genv_defs_range; eauto.\nexploit H1; eauto.\ndestruct gd0 as [f|v].\nintros [A B]; split; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros (A & B & C & D).\nsplit; [| split; [| split]].\nred; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\nintros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I.\nintros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (gd0 : globdef F V) (H2 : (if peq b (genv_next g) then Some gd else (genv_defs g) ! b) = Some gd0) : match gd0 with\n| Gfun _ =>\n    Mem.perm m' b 0 Cur Nonempty /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p -> ofs = 0 /\\ p = Nonempty)\n| Gvar v =>\n    Mem.range_perm m' b 0 (init_data_list_size (gvar_init v)) Cur\n      (perm_globvar v) /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p ->\n     0 <= ofs < init_data_list_size (gvar_init v) /\\\n     perm_order (perm_globvar v) p) /\\\n    (gvar_volatile v = false -> load_store_init_data m' b 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes m' b 0 (init_data_list_size (gvar_init v)) =\n     Some (bytes_of_init_data_list (gvar_init v)))\nend.","proofString":"destruct (peq b (genv_next g)).\ninv H2.\ndestruct gd0 as [f|v]; simpl in H0.\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:ALLOC.\nexploit Mem.alloc_result; eauto.\nintros RES.\nrewrite H, <- RES.\nsplit.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nexploit Mem.alloc_result; eauto.\nintro RES.\nreplace (genv_next g) with b by congruence.\nsplit.\nred; intros.\neapply Mem.perm_drop_1; eauto.\nsplit.\nintros.\nassert (0 <= ofs < sz).\neapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto.\nsplit; auto.\neapply Mem.perm_drop_2; eauto.\nsplit.\nintros NOTVOL.\napply load_store_init_data_invariant with m3.\nintros.\neapply Mem.load_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_charact; eauto.\neapply store_zeros_read_as_zero; eauto.\nintros NOTVOL.\ntransitivity (Mem.loadbytes m3 b 0 sz).\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_loadbytes; eauto.\neapply store_zeros_loadbytes; eauto.\nassert (U: Mem.unchanged_on (fun _ _ => True) m m') by (eapply alloc_global_unchanged; eauto).\nassert (VALID: Mem.valid_block m b).\nred.\nrewrite <- H.\neapply genv_defs_range; eauto.\nexploit H1; eauto.\ndestruct gd0 as [f|v].\nintros [A B]; split; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros (A & B & C & D).\nsplit; [| split; [| split]].\nred; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\nintros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I.\nintros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (gd0 : globdef F V) (e : b = genv_next g) (H2 : Some gd = Some gd0) : match gd0 with\n| Gfun _ =>\n    Mem.perm m' b 0 Cur Nonempty /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p -> ofs = 0 /\\ p = Nonempty)\n| Gvar v =>\n    Mem.range_perm m' b 0 (init_data_list_size (gvar_init v)) Cur\n      (perm_globvar v) /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p ->\n     0 <= ofs < init_data_list_size (gvar_init v) /\\\n     perm_order (perm_globvar v) p) /\\\n    (gvar_volatile v = false -> load_store_init_data m' b 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes m' b 0 (init_data_list_size (gvar_init v)) =\n     Some (bytes_of_init_data_list (gvar_init v)))\nend.","proofString":"inv H2.\ndestruct gd0 as [f|v]; simpl in H0.\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:ALLOC.\nexploit Mem.alloc_result; eauto.\nintros RES.\nrewrite H, <- RES.\nsplit.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nexploit Mem.alloc_result; eauto.\nintro RES.\nreplace (genv_next g) with b by congruence.\nsplit.\nred; intros.\neapply Mem.perm_drop_1; eauto.\nsplit.\nintros.\nassert (0 <= ofs < sz).\neapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto.\nsplit; auto.\neapply Mem.perm_drop_2; eauto.\nsplit.\nintros NOTVOL.\napply load_store_init_data_invariant with m3.\nintros.\neapply Mem.load_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_charact; eauto.\neapply store_zeros_read_as_zero; eauto.\nintros NOTVOL.\ntransitivity (Mem.loadbytes m3 b 0 sz).\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_loadbytes; eauto.\neapply store_zeros_loadbytes; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (gd0 : globdef F V) (H0 : alloc_global m (id, gd0) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) : match gd0 with\n| Gfun _ =>\n    Mem.perm m' (genv_next g) 0 Cur Nonempty /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' (genv_next g) ofs k p -> ofs = 0 /\\ p = Nonempty)\n| Gvar v =>\n    Mem.range_perm m' (genv_next g) 0 (init_data_list_size (gvar_init v)) Cur\n      (perm_globvar v) /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' (genv_next g) ofs k p ->\n     0 <= ofs < init_data_list_size (gvar_init v) /\\\n     perm_order (perm_globvar v) p) /\\\n    (gvar_volatile v = false ->\n     load_store_init_data m' (genv_next g) 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes m' (genv_next g) 0 (init_data_list_size (gvar_init v)) =\n     Some (bytes_of_init_data_list (gvar_init v)))\nend.","proofString":"destruct gd0 as [f|v]; simpl in H0.\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:ALLOC.\nexploit Mem.alloc_result; eauto.\nintros RES.\nrewrite H, <- RES.\nsplit.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nexploit Mem.alloc_result; eauto.\nintro RES.\nreplace (genv_next g) with b by congruence.\nsplit.\nred; intros.\neapply Mem.perm_drop_1; eauto.\nsplit.\nintros.\nassert (0 <= ofs < sz).\neapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto.\nsplit; auto.\neapply Mem.perm_drop_2; eauto.\nsplit.\nintros NOTVOL.\napply load_store_init_data_invariant with m3.\nintros.\neapply Mem.load_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_charact; eauto.\neapply store_zeros_read_as_zero; eauto.\nintros NOTVOL.\ntransitivity (Mem.loadbytes m3 b 0 sz).\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_loadbytes; eauto.\neapply store_zeros_loadbytes; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (H0 : (let (m1, b) := Mem.alloc m 0 1 in Mem.drop_perm m1 b 0 1 Nonempty) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) : Mem.perm m' (genv_next g) 0 Cur Nonempty /\\\n(forall (ofs : Z) (k : perm_kind) (p : permission),\n Mem.perm m' (genv_next g) ofs k p -> ofs = 0 /\\ p = Nonempty).","proofString":"destruct (Mem.alloc m 0 1) as [m1 b] eqn:ALLOC.\nexploit Mem.alloc_result; eauto.\nintros RES.\nrewrite H, <- RES.\nsplit.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) : Mem.perm m' (genv_next g) 0 Cur Nonempty /\\\n(forall (ofs : Z) (k : perm_kind) (p : permission),\n Mem.perm m' (genv_next g) ofs k p -> ofs = 0 /\\ p = Nonempty).","proofString":"exploit Mem.alloc_result; eauto.\nintros RES.\nrewrite H, <- RES.\nsplit.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) : b = Mem.nextblock m ->\nMem.perm m' (genv_next g) 0 Cur Nonempty /\\\n(forall (ofs : Z) (k : perm_kind) (p : permission),\n Mem.perm m' (genv_next g) ofs k p -> ofs = 0 /\\ p = Nonempty).","proofString":"intros RES.\nrewrite H, <- RES.\nsplit.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) : Mem.perm m' (genv_next g) 0 Cur Nonempty /\\\n(forall (ofs : Z) (k : perm_kind) (p : permission),\n Mem.perm m' (genv_next g) ofs k p -> ofs = 0 /\\ p = Nonempty).","proofString":"rewrite H, <- RES.\nsplit.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) : Mem.perm m' b 0 Cur Nonempty /\\\n(forall (ofs : Z) (k : perm_kind) (p : permission),\n Mem.perm m' b ofs k p -> ofs = 0 /\\ p = Nonempty).","proofString":"split.\neapply Mem.perm_drop_1; eauto.\nlia.\nintros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) : Mem.perm m' b 0 Cur Nonempty.","proofString":"eapply Mem.perm_drop_1; eauto.\nlia."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) : 0 <= 0 < 1.","proofString":"lia."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m' b ofs k p -> ofs = 0 /\\ p = Nonempty.","proofString":"intros.\nassert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m' b ofs k p) : ofs = 0 /\\ p = Nonempty.","proofString":"assert (0 <= ofs < 1).\neapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto.\nexploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m' b ofs k p) : 0 <= ofs < 1.","proofString":"eapply Mem.perm_alloc_3; eauto.\neapply Mem.perm_drop_4; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m' b ofs k p) (H3 : 0 <= ofs < 1) : ofs = 0 /\\ p = Nonempty.","proofString":"exploit Mem.perm_drop_2; eauto.\nintros ORD.\nsplit.\nlia.\ninv ORD; auto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m' b ofs k p) (H3 : 0 <= ofs < 1) : perm_order Nonempty p -> ofs = 0 /\\ p = Nonempty.","proofString":"intros ORD.\nsplit.\nlia.\ninv ORD; auto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m' b ofs k p) (H3 : 0 <= ofs < 1) (ORD : perm_order Nonempty p) : ofs = 0 /\\ p = Nonempty.","proofString":"split.\nlia.\ninv ORD; auto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m' b ofs k p) (H3 : 0 <= ofs < 1) (ORD : perm_order Nonempty p) : ofs = 0.","proofString":"lia."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (f : F) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (H0 : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m' b ofs k p) (H3 : 0 <= ofs < 1) (ORD : perm_order Nonempty p) : p = Nonempty.","proofString":"inv ORD; auto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (H0 : (let (m1, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n match store_zeros m1 b 0 (init_data_list_size (gvar_init v)) with\n | Some m2 =>\n     match store_init_data_list m2 b 0 (gvar_init v) with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n           (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) : Mem.range_perm m' (genv_next g) 0 (init_data_list_size (gvar_init v)) Cur\n  (perm_globvar v) /\\\n(forall (ofs : Z) (k : perm_kind) (p : permission),\n Mem.perm m' (genv_next g) ofs k p ->\n 0 <= ofs < init_data_list_size (gvar_init v) /\\\n perm_order (perm_globvar v) p) /\\\n(gvar_volatile v = false ->\n load_store_init_data m' (genv_next g) 0 (gvar_init v)) /\\\n(gvar_volatile v = false ->\n Mem.loadbytes m' (genv_next g) 0 (init_data_list_size (gvar_init v)) =\n Some (bytes_of_init_data_list (gvar_init v))).","proofString":"set (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nexploit Mem.alloc_result; eauto.\nintro RES.\nreplace (genv_next g) with b by congruence.\nsplit.\nred; intros.\neapply Mem.perm_drop_1; eauto.\nsplit.\nintros.\nassert (0 <= ofs < sz).\neapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto.\nsplit; auto.\neapply Mem.perm_drop_2; eauto.\nsplit.\nintros NOTVOL.\napply load_store_init_data_invariant with m3.\nintros.\neapply Mem.load_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_charact; eauto.\neapply store_zeros_read_as_zero; eauto.\nintros NOTVOL.\ntransitivity (Mem.loadbytes m3 b 0 sz).\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_loadbytes; eauto.\neapply store_zeros_loadbytes; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (H0 : (let (m1, b) := Mem.alloc m 0 (init_data_list_size init) in\n match store_zeros m1 b 0 (init_data_list_size init) with\n | Some m2 =>\n     match store_init_data_list m2 b 0 init with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size init) (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) : Mem.range_perm m' (genv_next g) 0 (init_data_list_size init) Cur\n  (perm_globvar v) /\\\n(forall (ofs : Z) (k : perm_kind) (p : permission),\n Mem.perm m' (genv_next g) ofs k p ->\n 0 <= ofs < init_data_list_size init /\\ perm_order (perm_globvar v) p) /\\\n(gvar_volatile v = false -> load_store_init_data m' (genv_next g) 0 init) /\\\n(gvar_volatile v = false ->\n Mem.loadbytes m' (genv_next g) 0 (init_data_list_size init) =\n Some (bytes_of_init_data_list init)).","proofString":"set (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list m2 b 0 init) as [m3|] eqn:?; try discriminate.\nexploit Mem.alloc_result; eauto.\nintro RES.\nreplace (genv_next g) with b by congruence.\nsplit.\nred; intros.\neapply Mem.perm_drop_1; eauto.\nsplit.\nintros.\nassert (0 <= ofs < sz).\neapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto.\nsplit; auto.\neapply Mem.perm_drop_2; eauto.\nsplit.\nintros NOTVOL.\napply load_store_init_data_invariant with m3.\nintros.\neapply Mem.load_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_charact; eauto.\neapply store_zeros_read_as_zero; eauto.\nintros NOTVOL.\ntransitivity (Mem.loadbytes m3 b 0 sz).\neapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem.\neapply store_init_data_list_loadbytes; eauto.\neapply store_zeros_loadbytes; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) : Mem.range_perm m' b 0 sz Cur (perm_globvar v).","proofString":"red; intros.\neapply Mem.perm_drop_1; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (ofs : Z) (H2 : 0 <= ofs < sz) : Mem.perm m' b ofs Cur (perm_globvar v).","proofString":"eapply Mem.perm_drop_1; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m' b ofs k p -> 0 <= ofs < sz /\\ perm_order (perm_globvar v) p.","proofString":"intros.\nassert (0 <= ofs < sz).\neapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto.\nsplit; auto.\neapply Mem.perm_drop_2; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m' b ofs k p) : 0 <= ofs < sz /\\ perm_order (perm_globvar v) p.","proofString":"assert (0 <= ofs < sz).\neapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto.\nsplit; auto.\neapply Mem.perm_drop_2; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m' b ofs k p) : 0 <= ofs < sz.","proofString":"eapply Mem.perm_alloc_3; eauto.\nerewrite store_zeros_perm by eauto.\nerewrite store_init_data_list_perm by eauto.\neapply Mem.perm_drop_4; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m' b ofs k p) (H3 : 0 <= ofs < sz) : 0 <= ofs < sz /\\ perm_order (perm_globvar v) p.","proofString":"split; auto.\neapply Mem.perm_drop_2; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (ofs : Z) (k : perm_kind) (p : permission) (H2 : Mem.perm m' b ofs k p) (H3 : 0 <= ofs < sz) : perm_order (perm_globvar v) p.","proofString":"eapply Mem.perm_drop_2; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (NOTVOL : gvar_volatile v = false) : forall (chunk : memory_chunk) (ofs : Z),\nMem.load chunk m' b ofs = Mem.load chunk m3 b ofs.","proofString":"intros.\neapply Mem.load_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (NOTVOL : gvar_volatile v = false) (chunk : memory_chunk) (ofs : Z) : Mem.load chunk m' b ofs = Mem.load chunk m3 b ofs.","proofString":"eapply Mem.load_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (NOTVOL : gvar_volatile v = false) (chunk : memory_chunk) (ofs : Z) : b <> b \\/\nofs + size_chunk chunk <= 0 \\/\nsz <= ofs \\/ perm_order (perm_globvar v) Readable.","proofString":"right; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (NOTVOL : gvar_volatile v = false) (chunk : memory_chunk) (ofs : Z) : perm_order (perm_globvar v) Readable.","proofString":"unfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (NOTVOL : gvar_volatile v = false) (chunk : memory_chunk) (ofs : Z) : perm_order\n  (if gvar_volatile v\n   then Nonempty\n   else if gvar_readonly v then Readable else Writable) Readable.","proofString":"rewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (NOTVOL : gvar_volatile v = false) (chunk : memory_chunk) (ofs : Z) : perm_order (if gvar_readonly v then Readable else Writable) Readable.","proofString":"destruct (gvar_readonly v); auto with mem."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (NOTVOL : gvar_volatile v = false) : Mem.loadbytes m' b 0 sz = Mem.loadbytes m3 b 0 sz.","proofString":"eapply Mem.loadbytes_drop; eauto.\nright; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (NOTVOL : gvar_volatile v = false) : b <> b \\/ 0 + sz <= 0 \\/ sz <= 0 \\/ perm_order (perm_globvar v) Readable.","proofString":"right; right; right.\nunfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (NOTVOL : gvar_volatile v = false) : perm_order (perm_globvar v) Readable.","proofString":"unfold perm_globvar.\nrewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (NOTVOL : gvar_volatile v = false) : perm_order\n  (if gvar_volatile v\n   then Nonempty\n   else if gvar_readonly v then Readable else Writable) Readable.","proofString":"rewrite NOTVOL.\ndestruct (gvar_readonly v); auto with mem."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (m' : mem) (H : genv_next g = Mem.nextblock m) (v : globvar V) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list m2 b 0 init = Some m3) (H0 : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (RES : b = Mem.nextblock m) (NOTVOL : gvar_volatile v = false) : perm_order (if gvar_readonly v then Readable else Writable) Readable.","proofString":"destruct (gvar_readonly v); auto with mem."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (gd0 : globdef F V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some gd0) : match gd0 with\n| Gfun _ =>\n    Mem.perm m' b 0 Cur Nonempty /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p -> ofs = 0 /\\ p = Nonempty)\n| Gvar v =>\n    Mem.range_perm m' b 0 (init_data_list_size (gvar_init v)) Cur\n      (perm_globvar v) /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p ->\n     0 <= ofs < init_data_list_size (gvar_init v) /\\\n     perm_order (perm_globvar v) p) /\\\n    (gvar_volatile v = false -> load_store_init_data m' b 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes m' b 0 (init_data_list_size (gvar_init v)) =\n     Some (bytes_of_init_data_list (gvar_init v)))\nend.","proofString":"assert (U: Mem.unchanged_on (fun _ _ => True) m m') by (eapply alloc_global_unchanged; eauto).\nassert (VALID: Mem.valid_block m b).\nred.\nrewrite <- H.\neapply genv_defs_range; eauto.\nexploit H1; eauto.\ndestruct gd0 as [f|v].\nintros [A B]; split; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros (A & B & C & D).\nsplit; [| split; [| split]].\nred; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\nintros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I.\nintros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (gd0 : globdef F V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some gd0) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') : match gd0 with\n| Gfun _ =>\n    Mem.perm m' b 0 Cur Nonempty /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p -> ofs = 0 /\\ p = Nonempty)\n| Gvar v =>\n    Mem.range_perm m' b 0 (init_data_list_size (gvar_init v)) Cur\n      (perm_globvar v) /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p ->\n     0 <= ofs < init_data_list_size (gvar_init v) /\\\n     perm_order (perm_globvar v) p) /\\\n    (gvar_volatile v = false -> load_store_init_data m' b 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes m' b 0 (init_data_list_size (gvar_init v)) =\n     Some (bytes_of_init_data_list (gvar_init v)))\nend.","proofString":"assert (VALID: Mem.valid_block m b).\nred.\nrewrite <- H.\neapply genv_defs_range; eauto.\nexploit H1; eauto.\ndestruct gd0 as [f|v].\nintros [A B]; split; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros (A & B & C & D).\nsplit; [| split; [| split]].\nred; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\nintros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I.\nintros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (gd0 : globdef F V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some gd0) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') : Mem.valid_block m b.","proofString":"red.\nrewrite <- H.\neapply genv_defs_range; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (gd0 : globdef F V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some gd0) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') : Plt b (Mem.nextblock m).","proofString":"rewrite <- H.\neapply genv_defs_range; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (gd0 : globdef F V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some gd0) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') : Plt b (genv_next g).","proofString":"eapply genv_defs_range; eauto."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (gd0 : globdef F V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some gd0) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) : match gd0 with\n| Gfun _ =>\n    Mem.perm m' b 0 Cur Nonempty /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p -> ofs = 0 /\\ p = Nonempty)\n| Gvar v =>\n    Mem.range_perm m' b 0 (init_data_list_size (gvar_init v)) Cur\n      (perm_globvar v) /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p ->\n     0 <= ofs < init_data_list_size (gvar_init v) /\\\n     perm_order (perm_globvar v) p) /\\\n    (gvar_volatile v = false -> load_store_init_data m' b 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes m' b 0 (init_data_list_size (gvar_init v)) =\n     Some (bytes_of_init_data_list (gvar_init v)))\nend.","proofString":"exploit H1; eauto.\ndestruct gd0 as [f|v].\nintros [A B]; split; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros (A & B & C & D).\nsplit; [| split; [| split]].\nred; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\nintros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I.\nintros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (gd0 : globdef F V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some gd0) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) : match gd0 with\n| Gfun _ =>\n    Mem.perm m b 0 Cur Nonempty /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m b ofs k p -> ofs = 0 /\\ p = Nonempty)\n| Gvar v =>\n    Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur\n      (perm_globvar v) /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m b ofs k p ->\n     0 <= ofs < init_data_list_size (gvar_init v) /\\\n     perm_order (perm_globvar v) p) /\\\n    (gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\n     Some (bytes_of_init_data_list (gvar_init v)))\nend ->\nmatch gd0 with\n| Gfun _ =>\n    Mem.perm m' b 0 Cur Nonempty /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p -> ofs = 0 /\\ p = Nonempty)\n| Gvar v =>\n    Mem.range_perm m' b 0 (init_data_list_size (gvar_init v)) Cur\n      (perm_globvar v) /\\\n    (forall (ofs : Z) (k : perm_kind) (p : permission),\n     Mem.perm m' b ofs k p ->\n     0 <= ofs < init_data_list_size (gvar_init v) /\\\n     perm_order (perm_globvar v) p) /\\\n    (gvar_volatile v = false -> load_store_init_data m' b 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes m' b 0 (init_data_list_size (gvar_init v)) =\n     Some (bytes_of_init_data_list (gvar_init v)))\nend.","proofString":"destruct gd0 as [f|v].\nintros [A B]; split; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros (A & B & C & D).\nsplit; [| split; [| split]].\nred; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\nintros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I.\nintros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (f : F) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gfun f)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) : Mem.perm m b 0 Cur Nonempty /\\\n(forall (ofs : Z) (k : perm_kind) (p : permission),\n Mem.perm m b ofs k p -> ofs = 0 /\\ p = Nonempty) ->\nMem.perm m' b 0 Cur Nonempty /\\\n(forall (ofs : Z) (k : perm_kind) (p : permission),\n Mem.perm m' b ofs k p -> ofs = 0 /\\ p = Nonempty).","proofString":"intros [A B]; split; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (f : F) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gfun f)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.perm m b 0 Cur Nonempty) (B : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs k p -> ofs = 0 /\\ p = Nonempty) : Mem.perm m' b 0 Cur Nonempty.","proofString":"eapply Mem.perm_unchanged_on; eauto.\nexact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (f : F) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gfun f)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.perm m b 0 Cur Nonempty) (B : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs k p -> ofs = 0 /\\ p = Nonempty) : (fun (_ : block) (_ : Z) => True) b 0.","proofString":"exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (f : F) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gfun f)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.perm m b 0 Cur Nonempty) (B : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m b ofs0 k0 p0 -> ofs0 = 0 /\\ p0 = Nonempty) (ofs : Z) (k : perm_kind) (p : permission) (H3 : Mem.perm m' b ofs k p) : ofs = 0 /\\ p = Nonempty.","proofString":"eapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (f : F) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gfun f)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.perm m b 0 Cur Nonempty) (B : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m b ofs0 k0 p0 -> ofs0 = 0 /\\ p0 = Nonempty) (ofs : Z) (k : perm_kind) (p : permission) (H3 : Mem.perm m' b ofs k p) : (fun (_ : block) (_ : Z) => True) b ofs.","proofString":"exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v) /\\\n(forall (ofs : Z) (k : perm_kind) (p : permission),\n Mem.perm m b ofs k p ->\n 0 <= ofs < init_data_list_size (gvar_init v) /\\\n perm_order (perm_globvar v) p) /\\\n(gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) /\\\n(gvar_volatile v = false ->\n Mem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\n Some (bytes_of_init_data_list (gvar_init v))) ->\nMem.range_perm m' b 0 (init_data_list_size (gvar_init v)) Cur\n  (perm_globvar v) /\\\n(forall (ofs : Z) (k : perm_kind) (p : permission),\n Mem.perm m' b ofs k p ->\n 0 <= ofs < init_data_list_size (gvar_init v) /\\\n perm_order (perm_globvar v) p) /\\\n(gvar_volatile v = false -> load_store_init_data m' b 0 (gvar_init v)) /\\\n(gvar_volatile v = false ->\n Mem.loadbytes m' b 0 (init_data_list_size (gvar_init v)) =\n Some (bytes_of_init_data_list (gvar_init v))).","proofString":"intros (A & B & C & D).\nsplit; [| split; [| split]].\nred; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\nintros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I.\nintros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs k p ->\n0 <= ofs < init_data_list_size (gvar_init v) /\\ perm_order (perm_globvar v) p) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) : Mem.range_perm m' b 0 (init_data_list_size (gvar_init v)) Cur\n  (perm_globvar v) /\\\n(forall (ofs : Z) (k : perm_kind) (p : permission),\n Mem.perm m' b ofs k p ->\n 0 <= ofs < init_data_list_size (gvar_init v) /\\\n perm_order (perm_globvar v) p) /\\\n(gvar_volatile v = false -> load_store_init_data m' b 0 (gvar_init v)) /\\\n(gvar_volatile v = false ->\n Mem.loadbytes m' b 0 (init_data_list_size (gvar_init v)) =\n Some (bytes_of_init_data_list (gvar_init v))).","proofString":"split; [| split; [| split]].\nred; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I.\nintros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I.\nintros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I.\nintros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs k p ->\n0 <= ofs < init_data_list_size (gvar_init v) /\\ perm_order (perm_globvar v) p) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) : Mem.range_perm m' b 0 (init_data_list_size (gvar_init v)) Cur\n  (perm_globvar v).","proofString":"red; intros.\neapply Mem.perm_unchanged_on; eauto.\nexact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs0 k p ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (perm_globvar v) p) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) (ofs : Z) (H3 : 0 <= ofs < init_data_list_size (gvar_init v)) : Mem.perm m' b ofs Cur (perm_globvar v).","proofString":"eapply Mem.perm_unchanged_on; eauto.\nexact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs0 k p ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (perm_globvar v) p) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) (ofs : Z) (H3 : 0 <= ofs < init_data_list_size (gvar_init v)) : (fun (_ : block) (_ : Z) => True) b ofs.","proofString":"exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs k p ->\n0 <= ofs < init_data_list_size (gvar_init v) /\\ perm_order (perm_globvar v) p) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m' b ofs k p ->\n0 <= ofs < init_data_list_size (gvar_init v) /\\ perm_order (perm_globvar v) p.","proofString":"intros.\neapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m b ofs0 k0 p0 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (perm_globvar v) p0) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) (ofs : Z) (k : perm_kind) (p : permission) (H3 : Mem.perm m' b ofs k p) : 0 <= ofs < init_data_list_size (gvar_init v) /\\ perm_order (perm_globvar v) p.","proofString":"eapply B.\neapply Mem.perm_unchanged_on_2; eauto.\nexact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs0 : Z) (k0 : perm_kind) (p0 : permission),\nMem.perm m b ofs0 k0 p0 ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (perm_globvar v) p0) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) (ofs : Z) (k : perm_kind) (p : permission) (H3 : Mem.perm m' b ofs k p) : (fun (_ : block) (_ : Z) => True) b ofs.","proofString":"exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs k p ->\n0 <= ofs < init_data_list_size (gvar_init v) /\\ perm_order (perm_globvar v) p) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) : gvar_volatile v = false -> load_store_init_data m' b 0 (gvar_init v).","proofString":"intros.\napply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs k p ->\n0 <= ofs < init_data_list_size (gvar_init v) /\\ perm_order (perm_globvar v) p) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) (H3 : gvar_volatile v = false) : load_store_init_data m' b 0 (gvar_init v).","proofString":"apply load_store_init_data_invariant with m; auto.\nintros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs k p ->\n0 <= ofs < init_data_list_size (gvar_init v) /\\ perm_order (perm_globvar v) p) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) (H3 : gvar_volatile v = false) : forall (chunk : memory_chunk) (ofs : Z),\nMem.load chunk m' b ofs = Mem.load chunk m b ofs.","proofString":"intros.\neapply Mem.load_unchanged_on_1; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs0 k p ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (perm_globvar v) p) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) (H3 : gvar_volatile v = false) (chunk : memory_chunk) (ofs : Z) : Mem.load chunk m' b ofs = Mem.load chunk m b ofs.","proofString":"eapply Mem.load_unchanged_on_1; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs0 : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs0 k p ->\n0 <= ofs0 < init_data_list_size (gvar_init v) /\\\nperm_order (perm_globvar v) p) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) (H3 : gvar_volatile v = false) (chunk : memory_chunk) (ofs : Z) : forall i : Z,\nofs <= i < ofs + size_chunk chunk -> (fun (_ : block) (_ : Z) => True) b i.","proofString":"intros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs k p ->\n0 <= ofs < init_data_list_size (gvar_init v) /\\ perm_order (perm_globvar v) p) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) : gvar_volatile v = false ->\nMem.loadbytes m' b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v)).","proofString":"intros.\neapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs k p ->\n0 <= ofs < init_data_list_size (gvar_init v) /\\ perm_order (perm_globvar v) p) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) (H3 : gvar_volatile v = false) : Mem.loadbytes m' b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v)).","proofString":"eapply Mem.loadbytes_unchanged_on; eauto.\nintros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) (b : block) (v : globvar V) (n : b <> genv_next g) (H2 : (genv_defs g) ! b = Some (Gvar v)) (U : Mem.unchanged_on (fun (_ : block) (_ : Z) => True) m m') (VALID : Mem.valid_block m b) (A : Mem.range_perm m b 0 (init_data_list_size (gvar_init v)) Cur (perm_globvar v)) (B : forall (ofs : Z) (k : perm_kind) (p : permission),\nMem.perm m b ofs k p ->\n0 <= ofs < init_data_list_size (gvar_init v) /\\ perm_order (perm_globvar v) p) (C : gvar_volatile v = false -> load_store_init_data m b 0 (gvar_init v)) (D : gvar_volatile v = false ->\nMem.loadbytes m b 0 (init_data_list_size (gvar_init v)) =\nSome (bytes_of_init_data_list (gvar_init v))) (H3 : gvar_volatile v = false) : forall i : Z,\n0 <= i < 0 + init_data_list_size (gvar_init v) ->\n(fun (_ : block) (_ : Z) => True) b i.","proofString":"intros; exact I."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) : genv_next (add_global g (id, gd)) = Mem.nextblock m'.","proofString":"simpl.\ncongruence."},{"statement":"(g : t) (m : Mem.mem') (id : ident) (gd : globdef F V) (m' : mem) (H : genv_next g = Mem.nextblock m) (H0 : alloc_global m (id, gd) = Some m') (H1 : globals_initialized g m) (NB : Mem.nextblock m' = Pos.succ (Mem.nextblock m)) : Pos.succ (genv_next g) = Mem.nextblock m'.","proofString":"congruence."},{"statement":"(ge0 : t) (m m' : mem) (H : Some m = Some m') (H0 : genv_next ge0 = Mem.nextblock m) (H1 : globals_initialized ge0 m) : globals_initialized ge0 m'.","proofString":"inv H; auto."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall (ge1 : t) (m0 m'0 : mem),\nalloc_globals m0 gl = Some m'0 ->\ngenv_next ge1 = Mem.nextblock m0 ->\nglobals_initialized ge1 m0 -> globals_initialized (add_globals ge1 gl) m'0) (ge0 : t) (m m' : mem) (H : match alloc_global m a with\n| Some m'0 => alloc_globals m'0 gl\n| None => None\nend = Some m') (H0 : genv_next ge0 = Mem.nextblock m) (H1 : globals_initialized ge0 m) : globals_initialized (add_globals (add_global ge0 a) gl) m'.","proofString":"destruct a as [id g].\ndestruct (alloc_global m (id, g)) as [m1|] eqn:?; try discriminate.\nexploit alloc_global_initialized; eauto.\nintros [P Q].\neapply IHgl; eauto."},{"statement":"(id : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall (ge1 : t) (m0 m'0 : mem),\nalloc_globals m0 gl = Some m'0 ->\ngenv_next ge1 = Mem.nextblock m0 ->\nglobals_initialized ge1 m0 -> globals_initialized (add_globals ge1 gl) m'0) (ge0 : t) (m m' : mem) (H : match alloc_global m (id, g) with\n| Some m'0 => alloc_globals m'0 gl\n| None => None\nend = Some m') (H0 : genv_next ge0 = Mem.nextblock m) (H1 : globals_initialized ge0 m) : globals_initialized (add_globals (add_global ge0 (id, g)) gl) m'.","proofString":"destruct (alloc_global m (id, g)) as [m1|] eqn:?; try discriminate.\nexploit alloc_global_initialized; eauto.\nintros [P Q].\neapply IHgl; eauto."},{"statement":"(id : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall (ge1 : t) (m0 m'0 : mem),\nalloc_globals m0 gl = Some m'0 ->\ngenv_next ge1 = Mem.nextblock m0 ->\nglobals_initialized ge1 m0 -> globals_initialized (add_globals ge1 gl) m'0) (ge0 : t) (m m' m1 : mem) (Heqo : alloc_global m (id, g) = Some m1) (H : alloc_globals m1 gl = Some m') (H0 : genv_next ge0 = Mem.nextblock m) (H1 : globals_initialized ge0 m) : globals_initialized (add_globals (add_global ge0 (id, g)) gl) m'.","proofString":"exploit alloc_global_initialized; eauto.\nintros [P Q].\neapply IHgl; eauto."},{"statement":"(id : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall (ge1 : t) (m0 m'0 : mem),\nalloc_globals m0 gl = Some m'0 ->\ngenv_next ge1 = Mem.nextblock m0 ->\nglobals_initialized ge1 m0 -> globals_initialized (add_globals ge1 gl) m'0) (ge0 : t) (m m' m1 : mem) (Heqo : alloc_global m (id, g) = Some m1) (H : alloc_globals m1 gl = Some m') (H0 : genv_next ge0 = Mem.nextblock m) (H1 : globals_initialized ge0 m) : globals_initialized (add_global ge0 (id, g)) m1 /\\\ngenv_next (add_global ge0 (id, g)) = Mem.nextblock m1 ->\nglobals_initialized (add_globals (add_global ge0 (id, g)) gl) m'.","proofString":"intros [P Q].\neapply IHgl; eauto."},{"statement":"(id : ident) (g : globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall (ge1 : t) (m0 m'0 : mem),\nalloc_globals m0 gl = Some m'0 ->\ngenv_next ge1 = Mem.nextblock m0 ->\nglobals_initialized ge1 m0 -> globals_initialized (add_globals ge1 gl) m'0) (ge0 : t) (m m' m1 : mem) (Heqo : alloc_global m (id, g) = Some m1) (H : alloc_globals m1 gl = Some m') (H0 : genv_next ge0 = Mem.nextblock m) (H1 : globals_initialized ge0 m) (P : globals_initialized (add_global ge0 (id, g)) m1) (Q : genv_next (add_global ge0 (id, g)) = Mem.nextblock m1) : globals_initialized (add_globals (add_global ge0 (id, g)) gl) m'.","proofString":"eapply IHgl; eauto."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) : genv_next (globalenv p) = Mem.nextblock m.","proofString":"exploit alloc_globals_nextblock; eauto.\nrewrite Mem.nextblock_empty.\nintro.\ngeneralize (genv_next_add_globals (prog_defs p) (empty_genv (prog_public p))).\nfold (globalenv p).\nsimpl genv_next.\nintros.\ncongruence."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) : Mem.nextblock m = advance_next (prog_defs p) (Mem.nextblock Mem.empty) ->\ngenv_next (globalenv p) = Mem.nextblock m.","proofString":"rewrite Mem.nextblock_empty.\nintro.\ngeneralize (genv_next_add_globals (prog_defs p) (empty_genv (prog_public p))).\nfold (globalenv p).\nsimpl genv_next.\nintros.\ncongruence."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) : Mem.nextblock m = advance_next (prog_defs p) 1 ->\ngenv_next (globalenv p) = Mem.nextblock m.","proofString":"intro.\ngeneralize (genv_next_add_globals (prog_defs p) (empty_genv (prog_public p))).\nfold (globalenv p).\nsimpl genv_next.\nintros.\ncongruence."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) (H0 : Mem.nextblock m = advance_next (prog_defs p) 1) : genv_next (globalenv p) = Mem.nextblock m.","proofString":"generalize (genv_next_add_globals (prog_defs p) (empty_genv (prog_public p))).\nfold (globalenv p).\nsimpl genv_next.\nintros.\ncongruence."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) (H0 : Mem.nextblock m = advance_next (prog_defs p) 1) : genv_next (add_globals (empty_genv (prog_public p)) (prog_defs p)) =\nadvance_next (prog_defs p) (genv_next (empty_genv (prog_public p))) ->\ngenv_next (globalenv p) = Mem.nextblock m.","proofString":"fold (globalenv p).\nsimpl genv_next.\nintros.\ncongruence."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) (H0 : Mem.nextblock m = advance_next (prog_defs p) 1) : genv_next (globalenv p) =\nadvance_next (prog_defs p) (genv_next (empty_genv (prog_public p))) ->\ngenv_next (globalenv p) = Mem.nextblock m.","proofString":"simpl genv_next.\nintros.\ncongruence."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) (H0 : Mem.nextblock m = advance_next (prog_defs p) 1) : genv_next (globalenv p) = advance_next (prog_defs p) 1 ->\ngenv_next (globalenv p) = Mem.nextblock m.","proofString":"intros.\ncongruence."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) (H0 : Mem.nextblock m = advance_next (prog_defs p) 1) (H1 : genv_next (globalenv p) = advance_next (prog_defs p) 1) : genv_next (globalenv p) = Mem.nextblock m.","proofString":"congruence."},{"statement":"(p : program F V) (id : ident) (b : block) (m : mem) (H : init_mem p = Some m) (H0 : find_symbol (globalenv p) id = Some b) : Mem.valid_block m b.","proofString":"red.\nerewrite <- init_mem_genv_next; eauto.\neapply genv_symb_range; eauto."},{"statement":"(p : program F V) (id : ident) (b : block) (m : mem) (H : init_mem p = Some m) (H0 : find_symbol (globalenv p) id = Some b) : Plt b (Mem.nextblock m).","proofString":"erewrite <- init_mem_genv_next; eauto.\neapply genv_symb_range; eauto."},{"statement":"(p : program F V) (id : ident) (b : block) (m : mem) (H : init_mem p = Some m) (H0 : find_symbol (globalenv p) id = Some b) : Plt b (genv_next (globalenv p)).","proofString":"eapply genv_symb_range; eauto."},{"statement":"(p : program F V) (b : block) (g : globdef F V) (m : mem) (H : init_mem p = Some m) (H0 : find_def (globalenv p) b = Some g) : Mem.valid_block m b.","proofString":"red.\nerewrite <- init_mem_genv_next; eauto.\neapply genv_defs_range; eauto."},{"statement":"(p : program F V) (b : block) (g : globdef F V) (m : mem) (H : init_mem p = Some m) (H0 : find_def (globalenv p) b = Some g) : Plt b (Mem.nextblock m).","proofString":"erewrite <- init_mem_genv_next; eauto.\neapply genv_defs_range; eauto."},{"statement":"(p : program F V) (b : block) (g : globdef F V) (m : mem) (H : init_mem p = Some m) (H0 : find_def (globalenv p) b = Some g) : Plt b (genv_next (globalenv p)).","proofString":"eapply genv_defs_range; eauto."},{"statement":"(p : program F V) (b : block) (f : F) (m : mem) (H : init_mem p = Some m) (H0 : find_funct_ptr (globalenv p) b = Some f) : Mem.valid_block m b.","proofString":"rewrite find_funct_ptr_iff in H0.\neapply find_def_not_fresh; eauto."},{"statement":"(p : program F V) (b : block) (f : F) (m : mem) (H : init_mem p = Some m) (H0 : find_def (globalenv p) b = Some (Gfun f)) : Mem.valid_block m b.","proofString":"eapply find_def_not_fresh; eauto."},{"statement":"(p : program F V) (b : block) (gv : globvar V) (m : mem) (H : init_mem p = Some m) (H0 : find_var_info (globalenv p) b = Some gv) : Mem.valid_block m b.","proofString":"rewrite find_var_info_iff in H0.\neapply find_def_not_fresh; eauto."},{"statement":"(p : program F V) (b : block) (gv : globvar V) (m : mem) (H : init_mem p = Some m) (H0 : find_def (globalenv p) b = Some (Gvar gv)) : Mem.valid_block m b.","proofString":"eapply find_def_not_fresh; eauto."},{"statement":"(p : program F V) (m : mem) (H : init_mem p = Some m) : globals_initialized (globalenv p) (globalenv p) m.","proofString":"apply alloc_globals_initialized with Mem.empty.\nauto.\nrewrite Mem.nextblock_empty.\nauto.\nred; intros.\nunfold find_def in H0; simpl in H0; rewrite PTree.gempty in H0; discriminate."},{"statement":"(p : program F V) (m : mem) (H : init_mem p = Some m) : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m.","proofString":"auto."},{"statement":"(p : program F V) (m : mem) (H : init_mem p = Some m) : genv_next (empty_genv (prog_public p)) = Mem.nextblock Mem.empty.","proofString":"rewrite Mem.nextblock_empty.\nauto."},{"statement":"(p : program F V) (m : mem) (H : init_mem p = Some m) : genv_next (empty_genv (prog_public p)) = 1%positive.","proofString":"auto."},{"statement":"(p : program F V) (m : mem) (H : init_mem p = Some m) : globals_initialized (globalenv p) (empty_genv (prog_public p)) Mem.empty.","proofString":"red; intros.\nunfold find_def in H0; simpl in H0; rewrite PTree.gempty in H0; discriminate."},{"statement":"(p : program F V) (m : mem) (H : init_mem p = Some m) (b : block) (gd : globdef F V) (H0 : find_def (empty_genv (prog_public p)) b = Some gd) : match gd with\n| Gfun _ =>\n    Mem.perm Mem.empty b 0 Cur Nonempty /\\\n    (forall (ofs : Z) (k : perm_kind) (p0 : permission),\n     Mem.perm Mem.empty b ofs k p0 -> ofs = 0 /\\ p0 = Nonempty)\n| Gvar v =>\n    Mem.range_perm Mem.empty b 0 (init_data_list_size (gvar_init v)) Cur\n      (perm_globvar v) /\\\n    (forall (ofs : Z) (k : perm_kind) (p0 : permission),\n     Mem.perm Mem.empty b ofs k p0 ->\n     0 <= ofs < init_data_list_size (gvar_init v) /\\\n     perm_order (perm_globvar v) p0) /\\\n    (gvar_volatile v = false ->\n     load_store_init_data (globalenv p) Mem.empty b 0 (gvar_init v)) /\\\n    (gvar_volatile v = false ->\n     Mem.loadbytes Mem.empty b 0 (init_data_list_size (gvar_init v)) =\n     Some (bytes_of_init_data_list (globalenv p) (gvar_init v)))\nend.","proofString":"unfold find_def in H0; simpl in H0; rewrite PTree.gempty in H0; discriminate."},{"statement":"(p : program F V) (b : block) (gv : globvar V) (m : mem) (H : find_var_info (globalenv p) b = Some gv) (H0 : init_mem p = Some m) : Mem.range_perm m b 0 (init_data_list_size (gvar_init gv)) Cur\n  (perm_globvar gv) /\\\n(forall (ofs : Z) (k : perm_kind) (p0 : permission),\n Mem.perm m b ofs k p0 ->\n 0 <= ofs < init_data_list_size (gvar_init gv) /\\\n perm_order (perm_globvar gv) p0) /\\\n(gvar_volatile gv = false ->\n load_store_init_data (globalenv p) m b 0 (gvar_init gv)) /\\\n(gvar_volatile gv = false ->\n Mem.loadbytes m b 0 (init_data_list_size (gvar_init gv)) =\n Some (bytes_of_init_data_list (globalenv p) (gvar_init gv))).","proofString":"rewrite find_var_info_iff in H.\nexploit init_mem_characterization_gen; eauto."},{"statement":"(p : program F V) (b : block) (gv : globvar V) (m : mem) (H : find_def (globalenv p) b = Some (Gvar gv)) (H0 : init_mem p = Some m) : Mem.range_perm m b 0 (init_data_list_size (gvar_init gv)) Cur\n  (perm_globvar gv) /\\\n(forall (ofs : Z) (k : perm_kind) (p0 : permission),\n Mem.perm m b ofs k p0 ->\n 0 <= ofs < init_data_list_size (gvar_init gv) /\\\n perm_order (perm_globvar gv) p0) /\\\n(gvar_volatile gv = false ->\n load_store_init_data (globalenv p) m b 0 (gvar_init gv)) /\\\n(gvar_volatile gv = false ->\n Mem.loadbytes m b 0 (init_data_list_size (gvar_init gv)) =\n Some (bytes_of_init_data_list (globalenv p) (gvar_init gv))).","proofString":"exploit init_mem_characterization_gen; eauto."},{"statement":"(p : program F V) (b : block) (fd : F) (m : mem) (H : find_funct_ptr (globalenv p) b = Some fd) (H0 : init_mem p = Some m) : Mem.perm m b 0 Cur Nonempty /\\\n(forall (ofs : Z) (k : perm_kind) (p0 : permission),\n Mem.perm m b ofs k p0 -> ofs = 0 /\\ p0 = Nonempty).","proofString":"rewrite find_funct_ptr_iff in H.\nexploit init_mem_characterization_gen; eauto."},{"statement":"(p : program F V) (b : block) (fd : F) (m : mem) (H : find_def (globalenv p) b = Some (Gfun fd)) (H0 : init_mem p = Some m) : Mem.perm m b 0 Cur Nonempty /\\\n(forall (ofs : Z) (k : perm_kind) (p0 : permission),\n Mem.perm m b ofs k p0 -> ofs = 0 /\\ p0 = Nonempty).","proofString":"exploit init_mem_characterization_gen; eauto."},{"statement":"(m : mem) (b : positive) (p n : Z) : forall m' : mem,\nMem.inject_neutral thr m ->\nPlt b thr -> store_zeros m b p n = Some m' -> Mem.inject_neutral thr m'.","proofString":"functional induction (store_zeros m b p n); intros.\ninv H1; auto.\napply IHo; auto.\neapply Mem.store_inject_neutral; eauto.\nconstructor.\ninv H1."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (m' : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (H1 : Some m = Some m') : Mem.inject_neutral thr m'.","proofString":"inv H1; auto."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nMem.inject_neutral thr m' ->\nPlt b thr ->\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 -> Mem.inject_neutral thr m'1) (m'0 : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (H1 : store_zeros m' b (p + 1) (n - 1) = Some m'0) : Mem.inject_neutral thr m'0.","proofString":"apply IHo; auto.\neapply Mem.store_inject_neutral; eauto.\nconstructor."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nMem.inject_neutral thr m' ->\nPlt b thr ->\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 -> Mem.inject_neutral thr m'1) (m'0 : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (H1 : store_zeros m' b (p + 1) (n - 1) = Some m'0) : Mem.inject_neutral thr m'.","proofString":"eapply Mem.store_inject_neutral; eauto.\nconstructor."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : forall m'1 : mem,\nMem.inject_neutral thr m' ->\nPlt b thr ->\nstore_zeros m' b (p + 1) (n - 1) = Some m'1 -> Mem.inject_neutral thr m'1) (m'0 : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (H1 : store_zeros m' b (p + 1) (n - 1) = Some m'0) : Val.inject (Mem.flat_inj thr) Vzero Vzero.","proofString":"constructor."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (m' : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (H1 : None = Some m') : Mem.inject_neutral thr m'.","proofString":"inv H1."},{"statement":"(m : mem) (b : positive) (p : Z) (id : init_data) (m' : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (H1 : store_init_data ge m b p id = Some m') : Mem.inject_neutral thr m'.","proofString":"destruct id; simpl in H1; try (eapply Mem.store_inject_neutral; eauto; fail).\ncongruence.\ndestruct (find_symbol ge i) as [b'|] eqn:E; try discriminate.\neapply Mem.store_inject_neutral; eauto.\neconstructor.\nunfold Mem.flat_inj.\napply pred_dec_true; auto.\neauto.\nrewrite Ptrofs.add_zero.\nauto."},{"statement":"(m : mem) (b : positive) (p z : Z) (m' : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (H1 : Some m = Some m') : Mem.inject_neutral thr m'.","proofString":"congruence."},{"statement":"(m : mem) (b : positive) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (H1 : match find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m') : Mem.inject_neutral thr m'.","proofString":"destruct (find_symbol ge i) as [b'|] eqn:E; try discriminate.\neapply Mem.store_inject_neutral; eauto.\neconstructor.\nunfold Mem.flat_inj.\napply pred_dec_true; auto.\neauto.\nrewrite Ptrofs.add_zero.\nauto."},{"statement":"(m : mem) (b : positive) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (b' : block) (E : find_symbol ge i = Some b') (H1 : Mem.store Mptr m b p (Vptr b' i0) = Some m') : Mem.inject_neutral thr m'.","proofString":"eapply Mem.store_inject_neutral; eauto.\neconstructor.\nunfold Mem.flat_inj.\napply pred_dec_true; auto.\neauto.\nrewrite Ptrofs.add_zero.\nauto."},{"statement":"(m : mem) (b : positive) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (b' : block) (E : find_symbol ge i = Some b') (H1 : Mem.store Mptr m b p (Vptr b' i0) = Some m') : Val.inject (Mem.flat_inj thr) (Vptr b' i0) (Vptr b' i0).","proofString":"econstructor.\nunfold Mem.flat_inj.\napply pred_dec_true; auto.\neauto.\nrewrite Ptrofs.add_zero.\nauto."},{"statement":"(m : mem) (b : positive) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (b' : block) (E : find_symbol ge i = Some b') (H1 : Mem.store Mptr m b p (Vptr b' i0) = Some m') : Plt b' thr.","proofString":"eauto."},{"statement":"(m : mem) (b : positive) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (b' : block) (E : find_symbol ge i = Some b') (H1 : Mem.store Mptr m b p (Vptr b' i0) = Some m') : i0 = i0.","proofString":"auto."},{"statement":"(b : positive) (m : mem) (p : Z) (m' : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (H1 : Some m = Some m') : Mem.inject_neutral thr m'.","proofString":"congruence."},{"statement":"(b : positive) (a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nMem.inject_neutral thr m0 ->\nPlt b thr ->\nstore_init_data_list ge m0 b p0 idl = Some m'0 -> Mem.inject_neutral thr m'0) (m : mem) (p : Z) (m' : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (H1 : match store_init_data ge m b p a with\n| Some m'0 => store_init_data_list ge m'0 b (p + init_data_size a) idl\n| None => None\nend = Some m') : Mem.inject_neutral thr m'.","proofString":"destruct (store_init_data ge m b p a) as [m1|] eqn:E; try discriminate.\neapply IHidl.\neapply store_init_data_neutral; eauto.\nauto.\neauto."},{"statement":"(b : positive) (a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nMem.inject_neutral thr m0 ->\nPlt b thr ->\nstore_init_data_list ge m0 b p0 idl = Some m'0 -> Mem.inject_neutral thr m'0) (m : mem) (p : Z) (m' : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (m1 : mem) (E : store_init_data ge m b p a = Some m1) (H1 : store_init_data_list ge m1 b (p + init_data_size a) idl = Some m') : Mem.inject_neutral thr m'.","proofString":"eapply IHidl.\neapply store_init_data_neutral; eauto.\nauto.\neauto."},{"statement":"(b : positive) (a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nMem.inject_neutral thr m0 ->\nPlt b thr ->\nstore_init_data_list ge m0 b p0 idl = Some m'0 -> Mem.inject_neutral thr m'0) (m : mem) (p : Z) (m' : mem) (H : Mem.inject_neutral thr m) (H0 : Plt b thr) (m1 : mem) (E : store_init_data ge m b p a = Some m1) (H1 : store_init_data_list ge m1 b (p + init_data_size a) idl = Some m') : Plt b thr.","proofString":"auto."},{"statement":"(idg : ident * globdef F V) (m m' : mem) (H : alloc_global ge m idg = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) : Mem.inject_neutral thr m'.","proofString":"destruct idg as [id [f|v]]; simpl in H.\ndestruct (Mem.alloc m 0 1) as [m1 b] eqn:?.\nassert (Plt b thr).\nrewrite (Mem.alloc_result _ _ _ _ _ Heqp).\nauto.\neapply Mem.drop_inject_neutral; eauto.\neapply Mem.alloc_inject_neutral; eauto.\nset (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 init) as [m3|] eqn:?; try discriminate.\nassert (Plt b thr).\nrewrite (Mem.alloc_result _ _ _ _ _ Heqp).\nauto.\neapply Mem.drop_inject_neutral; eauto.\neapply store_init_data_list_neutral with (m := m2) (b := b); eauto.\neapply store_zeros_neutral with (m := m1); eauto.\neapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (f : F) (m m' : mem) (H : (let (m1, b) := Mem.alloc m 0 1 in Mem.drop_perm m1 b 0 1 Nonempty) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) : Mem.inject_neutral thr m'.","proofString":"destruct (Mem.alloc m 0 1) as [m1 b] eqn:?.\nassert (Plt b thr).\nrewrite (Mem.alloc_result _ _ _ _ _ Heqp).\nauto.\neapply Mem.drop_inject_neutral; eauto.\neapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) : Mem.inject_neutral thr m'.","proofString":"assert (Plt b thr).\nrewrite (Mem.alloc_result _ _ _ _ _ Heqp).\nauto.\neapply Mem.drop_inject_neutral; eauto.\neapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) : Plt b thr.","proofString":"rewrite (Mem.alloc_result _ _ _ _ _ Heqp).\nauto."},{"statement":"(id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) : Plt (Mem.nextblock m) thr.","proofString":"auto."},{"statement":"(id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) (H2 : Plt b thr) : Mem.inject_neutral thr m'.","proofString":"eapply Mem.drop_inject_neutral; eauto.\neapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (f : F) (m m' : mem) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 1 = (m1, b)) (H : Mem.drop_perm m1 b 0 1 Nonempty = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) (H2 : Plt b thr) : Mem.inject_neutral thr m1.","proofString":"eapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (H : (let (m1, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n match store_zeros m1 b 0 (init_data_list_size (gvar_init v)) with\n | Some m2 =>\n     match store_init_data_list ge m2 b 0 (gvar_init v) with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n           (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) : Mem.inject_neutral thr m'.","proofString":"set (init := gvar_init v) in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 init) as [m3|] eqn:?; try discriminate.\nassert (Plt b thr).\nrewrite (Mem.alloc_result _ _ _ _ _ Heqp).\nauto.\neapply Mem.drop_inject_neutral; eauto.\neapply store_init_data_list_neutral with (m := m2) (b := b); eauto.\neapply store_zeros_neutral with (m := m1); eauto.\neapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (H : (let (m1, b) := Mem.alloc m 0 (init_data_list_size init) in\n match store_zeros m1 b 0 (init_data_list_size init) with\n | Some m2 =>\n     match store_init_data_list ge m2 b 0 init with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size init) (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) : Mem.inject_neutral thr m'.","proofString":"set (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 init) as [m3|] eqn:?; try discriminate.\nassert (Plt b thr).\nrewrite (Mem.alloc_result _ _ _ _ _ Heqp).\nauto.\neapply Mem.drop_inject_neutral; eauto.\neapply store_init_data_list_neutral with (m := m2) (b := b); eauto.\neapply store_zeros_neutral with (m := m1); eauto.\neapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (H : (let (m1, b) := Mem.alloc m 0 sz in\n match store_zeros m1 b 0 sz with\n | Some m2 =>\n     match store_init_data_list ge m2 b 0 init with\n     | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) : Mem.inject_neutral thr m'.","proofString":"destruct (Mem.alloc m 0 sz) as [m1 b] eqn:?.\ndestruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 init) as [m3|] eqn:?; try discriminate.\nassert (Plt b thr).\nrewrite (Mem.alloc_result _ _ _ _ _ Heqp).\nauto.\neapply Mem.drop_inject_neutral; eauto.\neapply store_init_data_list_neutral with (m := m2) (b := b); eauto.\neapply store_zeros_neutral with (m := m1); eauto.\neapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (H : match store_zeros m1 b 0 sz with\n| Some m2 =>\n    match store_init_data_list ge m2 b 0 init with\n    | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n    | None => None\n    end\n| None => None\nend = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) : Mem.inject_neutral thr m'.","proofString":"destruct (store_zeros m1 b 0 sz) as [m2|] eqn:?; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 init) as [m3|] eqn:?; try discriminate.\nassert (Plt b thr).\nrewrite (Mem.alloc_result _ _ _ _ _ Heqp).\nauto.\neapply Mem.drop_inject_neutral; eauto.\neapply store_init_data_list_neutral with (m := m2) (b := b); eauto.\neapply store_zeros_neutral with (m := m1); eauto.\neapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (H : match store_init_data_list ge m2 b 0 init with\n| Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n| None => None\nend = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) : Mem.inject_neutral thr m'.","proofString":"destruct (store_init_data_list ge m2 b 0 init) as [m3|] eqn:?; try discriminate.\nassert (Plt b thr).\nrewrite (Mem.alloc_result _ _ _ _ _ Heqp).\nauto.\neapply Mem.drop_inject_neutral; eauto.\neapply store_init_data_list_neutral with (m := m2) (b := b); eauto.\neapply store_zeros_neutral with (m := m1); eauto.\neapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list ge m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) : Mem.inject_neutral thr m'.","proofString":"assert (Plt b thr).\nrewrite (Mem.alloc_result _ _ _ _ _ Heqp).\nauto.\neapply Mem.drop_inject_neutral; eauto.\neapply store_init_data_list_neutral with (m := m2) (b := b); eauto.\neapply store_zeros_neutral with (m := m1); eauto.\neapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list ge m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) : Plt b thr.","proofString":"rewrite (Mem.alloc_result _ _ _ _ _ Heqp).\nauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list ge m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) : Plt (Mem.nextblock m) thr.","proofString":"auto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list ge m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) (H2 : Plt b thr) : Mem.inject_neutral thr m'.","proofString":"eapply Mem.drop_inject_neutral; eauto.\neapply store_init_data_list_neutral with (m := m2) (b := b); eauto.\neapply store_zeros_neutral with (m := m1); eauto.\neapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list ge m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) (H2 : Plt b thr) : Mem.inject_neutral thr m3.","proofString":"eapply store_init_data_list_neutral with (m := m2) (b := b); eauto.\neapply store_zeros_neutral with (m := m1); eauto.\neapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list ge m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) (H2 : Plt b thr) : Mem.inject_neutral thr m2.","proofString":"eapply store_zeros_neutral with (m := m1); eauto.\neapply Mem.alloc_inject_neutral; eauto."},{"statement":"(id : ident) (v : globvar V) (m m' : mem) (init : list init_data) (sz : Z) (m1 : Mem.mem') (b : block) (Heqp : Mem.alloc m 0 sz = (m1, b)) (m2 : mem) (Heqo : store_zeros m1 b 0 sz = Some m2) (m3 : mem) (Heqo0 : store_init_data_list ge m2 b 0 init = Some m3) (H : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Plt (Mem.nextblock m) thr) (H2 : Plt b thr) : Mem.inject_neutral thr m1.","proofString":"eapply Mem.alloc_inject_neutral; eauto."},{"statement":"(x : positive) : Ple x x.","proofString":"apply Ple_refl."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall x0 : positive, Ple x0 (advance_next gl x0)) (x : positive) : Ple x (advance_next gl (Pos.succ x)).","proofString":"apply Ple_trans with (Pos.succ x).\napply Ple_succ.\neauto."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall x0 : positive, Ple x0 (advance_next gl x0)) (x : positive) : Ple x (Pos.succ x).","proofString":"apply Ple_succ."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall x0 : positive, Ple x0 (advance_next gl x0)) (x : positive) : Ple (Pos.succ x) (advance_next gl (Pos.succ x)).","proofString":"eauto."},{"statement":"(m m' : mem) (H : alloc_globals ge m nil = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Ple (Mem.nextblock m') thr) : Mem.inject_neutral thr m'.","proofString":"simpl in *.\ncongruence."},{"statement":"(m m' : mem) (H : Some m = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Ple (Mem.nextblock m') thr) : Mem.inject_neutral thr m'.","proofString":"congruence."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals ge m0 gl = Some m'0 ->\nMem.inject_neutral thr m0 ->\nPle (Mem.nextblock m'0) thr -> Mem.inject_neutral thr m'0) (m m' : mem) (H : alloc_globals ge m (a :: gl) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Ple (Mem.nextblock m') thr) : Mem.inject_neutral thr m'.","proofString":"exploit alloc_globals_nextblock; eauto.\nintros EQ.\nsimpl in *.\ndestruct (alloc_global ge m a) as [m1|] eqn:E; try discriminate.\nexploit alloc_global_neutral; eauto.\nassert (Ple (Pos.succ (Mem.nextblock m)) (Mem.nextblock m')).\nrewrite EQ.\napply advance_next_le.\nunfold Plt, Ple in *; zify; lia."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals ge m0 gl = Some m'0 ->\nMem.inject_neutral thr m0 ->\nPle (Mem.nextblock m'0) thr -> Mem.inject_neutral thr m'0) (m m' : mem) (H : alloc_globals ge m (a :: gl) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Ple (Mem.nextblock m') thr) : Mem.nextblock m' = advance_next (a :: gl) (Mem.nextblock m) ->\nMem.inject_neutral thr m'.","proofString":"intros EQ.\nsimpl in *.\ndestruct (alloc_global ge m a) as [m1|] eqn:E; try discriminate.\nexploit alloc_global_neutral; eauto.\nassert (Ple (Pos.succ (Mem.nextblock m)) (Mem.nextblock m')).\nrewrite EQ.\napply advance_next_le.\nunfold Plt, Ple in *; zify; lia."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals ge m0 gl = Some m'0 ->\nMem.inject_neutral thr m0 ->\nPle (Mem.nextblock m'0) thr -> Mem.inject_neutral thr m'0) (m m' : mem) (H : alloc_globals ge m (a :: gl) = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Ple (Mem.nextblock m') thr) (EQ : Mem.nextblock m' = advance_next (a :: gl) (Mem.nextblock m)) : Mem.inject_neutral thr m'.","proofString":"simpl in *.\ndestruct (alloc_global ge m a) as [m1|] eqn:E; try discriminate.\nexploit alloc_global_neutral; eauto.\nassert (Ple (Pos.succ (Mem.nextblock m)) (Mem.nextblock m')).\nrewrite EQ.\napply advance_next_le.\nunfold Plt, Ple in *; zify; lia."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals ge m0 gl = Some m'0 ->\nMem.inject_neutral thr m0 ->\nPle (Mem.nextblock m'0) thr -> Mem.inject_neutral thr m'0) (m m' : mem) (H : match alloc_global ge m a with\n| Some m'0 => alloc_globals ge m'0 gl\n| None => None\nend = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Ple (Mem.nextblock m') thr) (EQ : Mem.nextblock m' = advance_next gl (Pos.succ (Mem.nextblock m))) : Mem.inject_neutral thr m'.","proofString":"destruct (alloc_global ge m a) as [m1|] eqn:E; try discriminate.\nexploit alloc_global_neutral; eauto.\nassert (Ple (Pos.succ (Mem.nextblock m)) (Mem.nextblock m')).\nrewrite EQ.\napply advance_next_le.\nunfold Plt, Ple in *; zify; lia."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals ge m0 gl = Some m'0 ->\nMem.inject_neutral thr m0 ->\nPle (Mem.nextblock m'0) thr -> Mem.inject_neutral thr m'0) (m m' m1 : mem) (E : alloc_global ge m a = Some m1) (H : alloc_globals ge m1 gl = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Ple (Mem.nextblock m') thr) (EQ : Mem.nextblock m' = advance_next gl (Pos.succ (Mem.nextblock m))) : Mem.inject_neutral thr m'.","proofString":"exploit alloc_global_neutral; eauto.\nassert (Ple (Pos.succ (Mem.nextblock m)) (Mem.nextblock m')).\nrewrite EQ.\napply advance_next_le.\nunfold Plt, Ple in *; zify; lia."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals ge m0 gl = Some m'0 ->\nMem.inject_neutral thr m0 ->\nPle (Mem.nextblock m'0) thr -> Mem.inject_neutral thr m'0) (m m' m1 : mem) (E : alloc_global ge m a = Some m1) (H : alloc_globals ge m1 gl = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Ple (Mem.nextblock m') thr) (EQ : Mem.nextblock m' = advance_next gl (Pos.succ (Mem.nextblock m))) : Plt (Mem.nextblock m) thr.","proofString":"assert (Ple (Pos.succ (Mem.nextblock m)) (Mem.nextblock m')).\nrewrite EQ.\napply advance_next_le.\nunfold Plt, Ple in *; zify; lia."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals ge m0 gl = Some m'0 ->\nMem.inject_neutral thr m0 ->\nPle (Mem.nextblock m'0) thr -> Mem.inject_neutral thr m'0) (m m' m1 : mem) (E : alloc_global ge m a = Some m1) (H : alloc_globals ge m1 gl = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Ple (Mem.nextblock m') thr) (EQ : Mem.nextblock m' = advance_next gl (Pos.succ (Mem.nextblock m))) : Ple (Pos.succ (Mem.nextblock m)) (Mem.nextblock m').","proofString":"rewrite EQ.\napply advance_next_le."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals ge m0 gl = Some m'0 ->\nMem.inject_neutral thr m0 ->\nPle (Mem.nextblock m'0) thr -> Mem.inject_neutral thr m'0) (m m' m1 : mem) (E : alloc_global ge m a = Some m1) (H : alloc_globals ge m1 gl = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Ple (Mem.nextblock m') thr) (EQ : Mem.nextblock m' = advance_next gl (Pos.succ (Mem.nextblock m))) : Ple (Pos.succ (Mem.nextblock m))\n  (advance_next gl (Pos.succ (Mem.nextblock m))).","proofString":"apply advance_next_le."},{"statement":"(a : ident * globdef F V) (gl : list (ident * globdef F V)) (IHgl : forall m0 m'0 : mem,\nalloc_globals ge m0 gl = Some m'0 ->\nMem.inject_neutral thr m0 ->\nPle (Mem.nextblock m'0) thr -> Mem.inject_neutral thr m'0) (m m' m1 : mem) (E : alloc_global ge m a = Some m1) (H : alloc_globals ge m1 gl = Some m') (H0 : Mem.inject_neutral thr m) (H1 : Ple (Mem.nextblock m') thr) (EQ : Mem.nextblock m' = advance_next gl (Pos.succ (Mem.nextblock m))) (H2 : Ple (Pos.succ (Mem.nextblock m)) (Mem.nextblock m')) : Plt (Mem.nextblock m) thr.","proofString":"unfold Plt, Ple in *; zify; lia."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) : Mem.inject (Mem.flat_inj (Mem.nextblock m)) m m.","proofString":"apply Mem.neutral_inject.\neapply alloc_globals_neutral; eauto.\nintros.\nexploit find_symbol_not_fresh; eauto.\napply Mem.empty_inject_neutral.\napply Ple_refl."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) : Mem.inject_neutral (Mem.nextblock m) m.","proofString":"eapply alloc_globals_neutral; eauto.\nintros.\nexploit find_symbol_not_fresh; eauto.\napply Mem.empty_inject_neutral.\napply Ple_refl."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) : forall (id : ident) (b : block),\nfind_symbol (globalenv p) id = Some b -> Plt b (Mem.nextblock m).","proofString":"intros.\nexploit find_symbol_not_fresh; eauto."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) (id : ident) (b : block) (H0 : find_symbol (globalenv p) id = Some b) : Plt b (Mem.nextblock m).","proofString":"exploit find_symbol_not_fresh; eauto."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) : Mem.inject_neutral (Mem.nextblock m) Mem.empty.","proofString":"apply Mem.empty_inject_neutral."},{"statement":"(p : program F V) (m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) : Ple (Mem.nextblock m) (Mem.nextblock m).","proofString":"apply Ple_refl."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (m' : mem) (H : store_init_data ge m b p i = Some m') : (init_data_alignment i | p).","proofString":"assert (DFL: forall chunk v,    Mem.store chunk m b p v = Some m' ->    align_chunk chunk = init_data_alignment i ->    (init_data_alignment i | p)).\nintros.\napply Mem.store_valid_access_3 in H0.\ndestruct H0.\ncongruence.\ndestruct i; simpl in H; eauto.\nsimpl.\napply Z.divide_1_l.\ndestruct (find_symbol ge i); try discriminate.\neapply DFL.\neassumption.\nunfold Mptr, init_data_alignment; destruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (m' : mem) (H : store_init_data ge m b p i = Some m') : forall (chunk : memory_chunk) (v : val),\nMem.store chunk m b p v = Some m' ->\nalign_chunk chunk = init_data_alignment i -> (init_data_alignment i | p).","proofString":"intros.\napply Mem.store_valid_access_3 in H0.\ndestruct H0.\ncongruence."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (m' : mem) (H : store_init_data ge m b p i = Some m') (chunk : memory_chunk) (v : val) (H0 : Mem.store chunk m b p v = Some m') (H1 : align_chunk chunk = init_data_alignment i) : (init_data_alignment i | p).","proofString":"apply Mem.store_valid_access_3 in H0.\ndestruct H0.\ncongruence."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (m' : mem) (H : store_init_data ge m b p i = Some m') (chunk : memory_chunk) (v : val) (H0 : Mem.valid_access m chunk b p Writable) (H1 : align_chunk chunk = init_data_alignment i) : (init_data_alignment i | p).","proofString":"destruct H0.\ncongruence."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (m' : mem) (H : store_init_data ge m b p i = Some m') (chunk : memory_chunk) (v : val) (H0 : Mem.range_perm m b p (p + size_chunk chunk) Cur Writable) (H2 : (align_chunk chunk | p)) (H1 : align_chunk chunk = init_data_alignment i) : (init_data_alignment i | p).","proofString":"congruence."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (m' : mem) (H : store_init_data ge m b p i = Some m') (DFL : forall (chunk : memory_chunk) (v : val),\nMem.store chunk m b p v = Some m' ->\nalign_chunk chunk = init_data_alignment i -> (init_data_alignment i | p)) : (init_data_alignment i | p).","proofString":"destruct i; simpl in H; eauto.\nsimpl.\napply Z.divide_1_l.\ndestruct (find_symbol ge i); try discriminate.\neapply DFL.\neassumption.\nunfold Mptr, init_data_alignment; destruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p z : Z) (m' : mem) (H : Some m = Some m') (DFL : forall (chunk : memory_chunk) (v : val),\nMem.store chunk m b p v = Some m' ->\nalign_chunk chunk = init_data_alignment (Init_space z) ->\n(init_data_alignment (Init_space z) | p)) : (init_data_alignment (Init_space z) | p).","proofString":"simpl.\napply Z.divide_1_l."},{"statement":"(m : mem) (b : block) (p z : Z) (m' : mem) (H : Some m = Some m') (DFL : forall (chunk : memory_chunk) (v : val),\nMem.store chunk m b p v = Some m' ->\nalign_chunk chunk = init_data_alignment (Init_space z) ->\n(init_data_alignment (Init_space z) | p)) : (1 | p).","proofString":"apply Z.divide_1_l."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (H : match find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' i0)\n| None => None\nend = Some m') (DFL : forall (chunk : memory_chunk) (v : val),\nMem.store chunk m b p v = Some m' ->\nalign_chunk chunk = init_data_alignment (Init_addrof i i0) ->\n(init_data_alignment (Init_addrof i i0) | p)) : (init_data_alignment (Init_addrof i i0) | p).","proofString":"destruct (find_symbol ge i); try discriminate.\neapply DFL.\neassumption.\nunfold Mptr, init_data_alignment; destruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (m' : mem) (b0 : block) (H : Mem.store Mptr m b p (Vptr b0 i0) = Some m') (DFL : forall (chunk : memory_chunk) (v : val),\nMem.store chunk m b p v = Some m' ->\nalign_chunk chunk = init_data_alignment (Init_addrof i i0) ->\n(init_data_alignment (Init_addrof i i0) | p)) : (init_data_alignment (Init_addrof i i0) | p).","proofString":"eapply DFL.\neassumption.\nunfold Mptr, init_data_alignment; destruct Archi.ptr64; auto."},{"statement":"(b : block) (m : mem) (p : Z) (m' : mem) (H : Some m = Some m') : True.","proofString":"auto."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list ge m0 b p0 il = Some m'0 -> init_data_list_aligned p0 il) (m : mem) (p : Z) (m' : mem) (H : match store_init_data ge m b p i1 with\n| Some m'0 => store_init_data_list ge m'0 b (p + init_data_size i1) il\n| None => None\nend = Some m') : (init_data_alignment i1 | p) /\\\ninit_data_list_aligned (p + init_data_size i1) il.","proofString":"destruct (store_init_data ge m b p i1) as [m1|] eqn:S1; try discriminate.\nsplit; eauto.\neapply store_init_data_aligned; eauto."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list ge m0 b p0 il = Some m'0 -> init_data_list_aligned p0 il) (m : mem) (p : Z) (m' m1 : mem) (S1 : store_init_data ge m b p i1 = Some m1) (H : store_init_data_list ge m1 b (p + init_data_size i1) il = Some m') : (init_data_alignment i1 | p) /\\\ninit_data_list_aligned (p + init_data_size i1) il.","proofString":"split; eauto.\neapply store_init_data_aligned; eauto."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list ge m0 b p0 il = Some m'0 -> init_data_list_aligned p0 il) (m : mem) (p : Z) (m' m1 : mem) (S1 : store_init_data ge m b p i1 = Some m1) (H : store_init_data_list ge m1 b (p + init_data_size i1) il = Some m') : (init_data_alignment i1 | p).","proofString":"eapply store_init_data_aligned; eauto."},{"statement":"(b : block) (i : ident) (o : ptrofs) (m : mem) (p : Z) (m' : mem) (H : Some m = Some m') (H0 : False) : exists b' : block, find_symbol ge i = Some b'.","proofString":"contradiction."},{"statement":"(b : block) (i : ident) (o : ptrofs) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list ge m0 b p0 il = Some m'0 ->\nIn (Init_addrof i o) il -> exists b' : block, find_symbol ge i = Some b') (m : mem) (p : Z) (m' : mem) (H : match store_init_data ge m b p i1 with\n| Some m'0 => store_init_data_list ge m'0 b (p + init_data_size i1) il\n| None => None\nend = Some m') (H0 : i1 = Init_addrof i o \\/ In (Init_addrof i o) il) : exists b' : block, find_symbol ge i = Some b'.","proofString":"destruct (store_init_data ge m b p i1) as [m1|] eqn:S1; try discriminate.\ndestruct H0.\nsubst i1.\nsimpl in S1.\ndestruct (find_symbol ge i) as [b'|].\nexists b'; auto.\ndiscriminate.\neapply IHil; eauto."},{"statement":"(b : block) (i : ident) (o : ptrofs) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list ge m0 b p0 il = Some m'0 ->\nIn (Init_addrof i o) il -> exists b' : block, find_symbol ge i = Some b') (m : mem) (p : Z) (m' m1 : mem) (S1 : store_init_data ge m b p i1 = Some m1) (H : store_init_data_list ge m1 b (p + init_data_size i1) il = Some m') (H0 : i1 = Init_addrof i o \\/ In (Init_addrof i o) il) : exists b' : block, find_symbol ge i = Some b'.","proofString":"destruct H0.\nsubst i1.\nsimpl in S1.\ndestruct (find_symbol ge i) as [b'|].\nexists b'; auto.\ndiscriminate.\neapply IHil; eauto."},{"statement":"(b : block) (i : ident) (o : ptrofs) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list ge m0 b p0 il = Some m'0 ->\nIn (Init_addrof i o) il -> exists b' : block, find_symbol ge i = Some b') (m : mem) (p : Z) (m' m1 : mem) (S1 : store_init_data ge m b p i1 = Some m1) (H : store_init_data_list ge m1 b (p + init_data_size i1) il = Some m') (H0 : i1 = Init_addrof i o) : exists b' : block, find_symbol ge i = Some b'.","proofString":"subst i1.\nsimpl in S1.\ndestruct (find_symbol ge i) as [b'|].\nexists b'; auto.\ndiscriminate."},{"statement":"(b : block) (i : ident) (o : ptrofs) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list ge m0 b p0 il = Some m'0 ->\nIn (Init_addrof i o) il -> exists b' : block, find_symbol ge i = Some b') (m : mem) (p : Z) (m' m1 : mem) (H : store_init_data_list ge m1 b (p + init_data_size (Init_addrof i o)) il =\nSome m') (S1 : store_init_data ge m b p (Init_addrof i o) = Some m1) : exists b' : block, find_symbol ge i = Some b'.","proofString":"simpl in S1.\ndestruct (find_symbol ge i) as [b'|].\nexists b'; auto.\ndiscriminate."},{"statement":"(b : block) (i : ident) (o : ptrofs) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list ge m0 b p0 il = Some m'0 ->\nIn (Init_addrof i o) il -> exists b' : block, find_symbol ge i = Some b') (m : mem) (p : Z) (m' m1 : mem) (H : store_init_data_list ge m1 b (p + init_data_size (Init_addrof i o)) il =\nSome m') (S1 : match find_symbol ge i with\n| Some b' => Mem.store Mptr m b p (Vptr b' o)\n| None => None\nend = Some m1) : exists b' : block, find_symbol ge i = Some b'.","proofString":"destruct (find_symbol ge i) as [b'|].\nexists b'; auto.\ndiscriminate."},{"statement":"(b : block) (i : ident) (o : ptrofs) (il : list init_data) (b' : block) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list ge m0 b p0 il = Some m'0 ->\nIn (Init_addrof i o) il -> exists b'0 : block, Some b' = Some b'0) (m : mem) (p : Z) (m' m1 : mem) (H : store_init_data_list ge m1 b (p + init_data_size (Init_addrof i o)) il =\nSome m') (S1 : Mem.store Mptr m b p (Vptr b' o) = Some m1) : exists b'0 : block, Some b' = Some b'0.","proofString":"exists b'; auto."},{"statement":"(b : block) (i : ident) (o : ptrofs) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list ge m0 b p0 il = Some m'0 ->\nIn (Init_addrof i o) il -> exists b' : block, None = Some b') (m : mem) (p : Z) (m' m1 : mem) (H : store_init_data_list ge m1 b (p + init_data_size (Init_addrof i o)) il =\nSome m') (S1 : None = Some m1) : exists b' : block, None = Some b'.","proofString":"discriminate."},{"statement":"(b : block) (i : ident) (o : ptrofs) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z) (m'0 : mem),\nstore_init_data_list ge m0 b p0 il = Some m'0 ->\nIn (Init_addrof i o) il -> exists b' : block, find_symbol ge i = Some b') (m : mem) (p : Z) (m' m1 : mem) (S1 : store_init_data ge m b p i1 = Some m1) (H : store_init_data_list ge m1 b (p + init_data_size i1) il = Some m') (H0 : In (Init_addrof i o) il) : exists b' : block, find_symbol ge i = Some b'.","proofString":"eapply IHil; eauto."},{"statement":"(p : program F V) (m : mem) (id : ident) (v : globvar V) : init_mem p = Some m ->\nIn (id, Gvar v) (prog_defs p) ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol (globalenv p) i = Some b).","proofString":"unfold init_mem.\nset (ge := globalenv p).\nrevert m.\ngeneralize Mem.empty.\ngeneralize (prog_defs p).\ninduction l as [ | idg1 defs ]; simpl; intros m m'; intros.\ncontradiction.\ndestruct (alloc_global ge m idg1) as [m''|] eqn:A; try discriminate.\ndestruct H0.\nsubst idg1; simpl in A.\nset (il := gvar_init v) in *.\nset (sz := init_data_list_size il) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b].\ndestruct (store_zeros m1 b 0 sz) as [m2|]; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto.\neapply IHdefs; eauto."},{"statement":"(p : program F V) (m : mem) (id : ident) (v : globvar V) : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m ->\nIn (id, Gvar v) (prog_defs p) ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol (globalenv p) i = Some b).","proofString":"set (ge := globalenv p).\nrevert m.\ngeneralize Mem.empty.\ngeneralize (prog_defs p).\ninduction l as [ | idg1 defs ]; simpl; intros m m'; intros.\ncontradiction.\ndestruct (alloc_global ge m idg1) as [m''|] eqn:A; try discriminate.\ndestruct H0.\nsubst idg1; simpl in A.\nset (il := gvar_init v) in *.\nset (sz := init_data_list_size il) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b].\ndestruct (store_zeros m1 b 0 sz) as [m2|]; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto.\neapply IHdefs; eauto."},{"statement":"(p : program F V) (m : mem) (id : ident) (v : globvar V) (ge : t) : alloc_globals ge Mem.empty (prog_defs p) = Some m ->\nIn (id, Gvar v) (prog_defs p) ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b).","proofString":"revert m.\ngeneralize Mem.empty.\ngeneralize (prog_defs p).\ninduction l as [ | idg1 defs ]; simpl; intros m m'; intros.\ncontradiction.\ndestruct (alloc_global ge m idg1) as [m''|] eqn:A; try discriminate.\ndestruct H0.\nsubst idg1; simpl in A.\nset (il := gvar_init v) in *.\nset (sz := init_data_list_size il) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b].\ndestruct (store_zeros m1 b 0 sz) as [m2|]; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto.\neapply IHdefs; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) : forall m : mem,\nalloc_globals ge Mem.empty (prog_defs p) = Some m ->\nIn (id, Gvar v) (prog_defs p) ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b).","proofString":"generalize Mem.empty.\ngeneralize (prog_defs p).\ninduction l as [ | idg1 defs ]; simpl; intros m m'; intros.\ncontradiction.\ndestruct (alloc_global ge m idg1) as [m''|] eqn:A; try discriminate.\ndestruct H0.\nsubst idg1; simpl in A.\nset (il := gvar_init v) in *.\nset (sz := init_data_list_size il) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b].\ndestruct (store_zeros m1 b 0 sz) as [m2|]; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto.\neapply IHdefs; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) : forall m m0 : mem,\nalloc_globals ge m (prog_defs p) = Some m0 ->\nIn (id, Gvar v) (prog_defs p) ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b).","proofString":"generalize (prog_defs p).\ninduction l as [ | idg1 defs ]; simpl; intros m m'; intros.\ncontradiction.\ndestruct (alloc_global ge m idg1) as [m''|] eqn:A; try discriminate.\ndestruct H0.\nsubst idg1; simpl in A.\nset (il := gvar_init v) in *.\nset (sz := init_data_list_size il) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b].\ndestruct (store_zeros m1 b 0 sz) as [m2|]; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto.\neapply IHdefs; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) : forall (l : list (ident * globdef F V)) (m m0 : mem),\nalloc_globals ge m l = Some m0 ->\nIn (id, Gvar v) l ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b).","proofString":"induction l as [ | idg1 defs ]; simpl; intros m m'; intros.\ncontradiction.\ndestruct (alloc_global ge m idg1) as [m''|] eqn:A; try discriminate.\ndestruct H0.\nsubst idg1; simpl in A.\nset (il := gvar_init v) in *.\nset (sz := init_data_list_size il) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b].\ndestruct (store_zeros m1 b 0 sz) as [m2|]; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto.\neapply IHdefs; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) (m m' : mem) (H : Some m = Some m') (H0 : False) : init_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b).","proofString":"contradiction."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) (idg1 : ident * globdef F V) (defs : list (ident * globdef F V)) (IHdefs : forall m0 m1 : mem,\nalloc_globals ge m0 defs = Some m1 ->\nIn (id, Gvar v) defs ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b)) (m m' : mem) (H : match alloc_global ge m idg1 with\n| Some m'0 => alloc_globals ge m'0 defs\n| None => None\nend = Some m') (H0 : idg1 = (id, Gvar v) \\/ In (id, Gvar v) defs) : init_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b).","proofString":"destruct (alloc_global ge m idg1) as [m''|] eqn:A; try discriminate.\ndestruct H0.\nsubst idg1; simpl in A.\nset (il := gvar_init v) in *.\nset (sz := init_data_list_size il) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b].\ndestruct (store_zeros m1 b 0 sz) as [m2|]; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto.\neapply IHdefs; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) (idg1 : ident * globdef F V) (defs : list (ident * globdef F V)) (IHdefs : forall m0 m1 : mem,\nalloc_globals ge m0 defs = Some m1 ->\nIn (id, Gvar v) defs ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b)) (m m' m'' : mem) (A : alloc_global ge m idg1 = Some m'') (H : alloc_globals ge m'' defs = Some m') (H0 : idg1 = (id, Gvar v) \\/ In (id, Gvar v) defs) : init_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b).","proofString":"destruct H0.\nsubst idg1; simpl in A.\nset (il := gvar_init v) in *.\nset (sz := init_data_list_size il) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b].\ndestruct (store_zeros m1 b 0 sz) as [m2|]; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto.\neapply IHdefs; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) (idg1 : ident * globdef F V) (defs : list (ident * globdef F V)) (IHdefs : forall m0 m1 : mem,\nalloc_globals ge m0 defs = Some m1 ->\nIn (id, Gvar v) defs ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b)) (m m' m'' : mem) (A : alloc_global ge m idg1 = Some m'') (H : alloc_globals ge m'' defs = Some m') (H0 : idg1 = (id, Gvar v)) : init_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b).","proofString":"subst idg1; simpl in A.\nset (il := gvar_init v) in *.\nset (sz := init_data_list_size il) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b].\ndestruct (store_zeros m1 b 0 sz) as [m2|]; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) (defs : list (ident * globdef F V)) (IHdefs : forall m0 m1 : mem,\nalloc_globals ge m0 defs = Some m1 ->\nIn (id, Gvar v) defs ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b)) (m m' m'' : mem) (A : (let (m1, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n match store_zeros m1 b 0 (init_data_list_size (gvar_init v)) with\n | Some m2 =>\n     match store_init_data_list ge m2 b 0 (gvar_init v) with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n           (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m'') (H : alloc_globals ge m'' defs = Some m') : init_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b).","proofString":"set (il := gvar_init v) in *.\nset (sz := init_data_list_size il) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b].\ndestruct (store_zeros m1 b 0 sz) as [m2|]; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) (defs : list (ident * globdef F V)) (il : list init_data) (IHdefs : forall m0 m1 : mem,\nalloc_globals ge m0 defs = Some m1 ->\nIn (id, Gvar v) defs ->\ninit_data_list_aligned 0 il /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) il -> exists b : block, find_symbol ge i = Some b)) (m m' m'' : mem) (A : (let (m1, b) := Mem.alloc m 0 (init_data_list_size il) in\n match store_zeros m1 b 0 (init_data_list_size il) with\n | Some m2 =>\n     match store_init_data_list ge m2 b 0 il with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size il) (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m'') (H : alloc_globals ge m'' defs = Some m') : init_data_list_aligned 0 il /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) il -> exists b : block, find_symbol ge i = Some b).","proofString":"set (sz := init_data_list_size il) in *.\ndestruct (Mem.alloc m 0 sz) as [m1 b].\ndestruct (store_zeros m1 b 0 sz) as [m2|]; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) (defs : list (ident * globdef F V)) (il : list init_data) (IHdefs : forall m0 m1 : mem,\nalloc_globals ge m0 defs = Some m1 ->\nIn (id, Gvar v) defs ->\ninit_data_list_aligned 0 il /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) il -> exists b : block, find_symbol ge i = Some b)) (m m' m'' : mem) (sz : Z) (A : (let (m1, b) := Mem.alloc m 0 sz in\n match store_zeros m1 b 0 sz with\n | Some m2 =>\n     match store_init_data_list ge m2 b 0 il with\n     | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n     | None => None\n     end\n | None => None\n end) = Some m'') (H : alloc_globals ge m'' defs = Some m') : init_data_list_aligned 0 il /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) il -> exists b : block, find_symbol ge i = Some b).","proofString":"destruct (Mem.alloc m 0 sz) as [m1 b].\ndestruct (store_zeros m1 b 0 sz) as [m2|]; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) (defs : list (ident * globdef F V)) (il : list init_data) (IHdefs : forall m0 m2 : mem,\nalloc_globals ge m0 defs = Some m2 ->\nIn (id, Gvar v) defs ->\ninit_data_list_aligned 0 il /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) il -> exists b0 : block, find_symbol ge i = Some b0)) (m m' m'' : mem) (sz : Z) (m1 : Mem.mem') (b : block) (A : match store_zeros m1 b 0 sz with\n| Some m2 =>\n    match store_init_data_list ge m2 b 0 il with\n    | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n    | None => None\n    end\n| None => None\nend = Some m'') (H : alloc_globals ge m'' defs = Some m') : init_data_list_aligned 0 il /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) il -> exists b0 : block, find_symbol ge i = Some b0).","proofString":"destruct (store_zeros m1 b 0 sz) as [m2|]; try discriminate.\ndestruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) (defs : list (ident * globdef F V)) (il : list init_data) (IHdefs : forall m0 m3 : mem,\nalloc_globals ge m0 defs = Some m3 ->\nIn (id, Gvar v) defs ->\ninit_data_list_aligned 0 il /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) il -> exists b0 : block, find_symbol ge i = Some b0)) (m m' m'' : mem) (sz : Z) (m1 : Mem.mem') (b : block) (m2 : mem) (A : match store_init_data_list ge m2 b 0 il with\n| Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)\n| None => None\nend = Some m'') (H : alloc_globals ge m'' defs = Some m') : init_data_list_aligned 0 il /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) il -> exists b0 : block, find_symbol ge i = Some b0).","proofString":"destruct (store_init_data_list ge m2 b 0 il) as [m3|] eqn:B; try discriminate.\nsplit.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) (defs : list (ident * globdef F V)) (il : list init_data) (IHdefs : forall m0 m4 : mem,\nalloc_globals ge m0 defs = Some m4 ->\nIn (id, Gvar v) defs ->\ninit_data_list_aligned 0 il /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) il -> exists b0 : block, find_symbol ge i = Some b0)) (m m' m'' : mem) (sz : Z) (m1 : Mem.mem') (b : block) (m2 m3 : mem) (B : store_init_data_list ge m2 b 0 il = Some m3) (A : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m'') (H : alloc_globals ge m'' defs = Some m') : init_data_list_aligned 0 il /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) il -> exists b0 : block, find_symbol ge i = Some b0).","proofString":"split.\neapply store_init_data_list_aligned; eauto.\nintros; eapply store_init_data_list_free_idents; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) (defs : list (ident * globdef F V)) (il : list init_data) (IHdefs : forall m0 m4 : mem,\nalloc_globals ge m0 defs = Some m4 ->\nIn (id, Gvar v) defs ->\ninit_data_list_aligned 0 il /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) il -> exists b0 : block, find_symbol ge i = Some b0)) (m m' m'' : mem) (sz : Z) (m1 : Mem.mem') (b : block) (m2 m3 : mem) (B : store_init_data_list ge m2 b 0 il = Some m3) (A : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m'') (H : alloc_globals ge m'' defs = Some m') : init_data_list_aligned 0 il.","proofString":"eapply store_init_data_list_aligned; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) (defs : list (ident * globdef F V)) (il : list init_data) (IHdefs : forall m0 m4 : mem,\nalloc_globals ge m0 defs = Some m4 ->\nIn (id, Gvar v) defs ->\ninit_data_list_aligned 0 il /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) il -> exists b0 : block, find_symbol ge i = Some b0)) (m m' m'' : mem) (sz : Z) (m1 : Mem.mem') (b : block) (m2 m3 : mem) (B : store_init_data_list ge m2 b 0 il = Some m3) (A : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m'') (H : alloc_globals ge m'' defs = Some m') : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) il -> exists b0 : block, find_symbol ge i = Some b0.","proofString":"intros; eapply store_init_data_list_free_idents; eauto."},{"statement":"(p : program F V) (id : ident) (v : globvar V) (ge : t) (idg1 : ident * globdef F V) (defs : list (ident * globdef F V)) (IHdefs : forall m0 m1 : mem,\nalloc_globals ge m0 defs = Some m1 ->\nIn (id, Gvar v) defs ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b)) (m m' m'' : mem) (A : alloc_global ge m idg1 = Some m'') (H : alloc_globals ge m'' defs = Some m') (H0 : In (id, Gvar v) defs) : init_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b).","proofString":"eapply IHdefs; eauto."},{"statement":"(m : mem) (b : block) (p n : Z) : Mem.range_perm m b p (p + n) Cur Writable ->\nexists m' : mem, store_zeros m b p n = Some m'.","proofString":"functional induction (store_zeros m b p n); intros PERM.\nexists m; auto.\napply IHo.\nred; intros.\neapply Mem.perm_store_1; eauto.\napply PERM.\nlia.\ndestruct (Mem.valid_access_store m Mint8unsigned b p Vzero) as (m' & STORE).\nsplit.\nred; intros.\napply Mem.perm_cur.\napply PERM.\nsimpl in H.\nlia.\nsimpl.\napply Z.divide_1_l.\ncongruence."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n <= 0) (e : zle n 0 = left _x) (PERM : Mem.range_perm m b p (p + n) Cur Writable) : exists m' : mem, Some m = Some m'.","proofString":"exists m; auto."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : Mem.range_perm m' b (p + 1) (p + 1 + (n - 1)) Cur Writable ->\nexists m'0 : mem, store_zeros m' b (p + 1) (n - 1) = Some m'0) (PERM : Mem.range_perm m b p (p + n) Cur Writable) : exists m'0 : mem, store_zeros m' b (p + 1) (n - 1) = Some m'0.","proofString":"apply IHo.\nred; intros.\neapply Mem.perm_store_1; eauto.\napply PERM.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : Mem.range_perm m' b (p + 1) (p + 1 + (n - 1)) Cur Writable ->\nexists m'0 : mem, store_zeros m' b (p + 1) (n - 1) = Some m'0) (PERM : Mem.range_perm m b p (p + n) Cur Writable) : Mem.range_perm m' b (p + 1) (p + 1 + (n - 1)) Cur Writable.","proofString":"red; intros.\neapply Mem.perm_store_1; eauto.\napply PERM.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : Mem.range_perm m' b (p + 1) (p + 1 + (n - 1)) Cur Writable ->\nexists m'0 : mem, store_zeros m' b (p + 1) (n - 1) = Some m'0) (PERM : Mem.range_perm m b p (p + n) Cur Writable) (ofs : Z) (H : p + 1 <= ofs < p + 1 + (n - 1)) : Mem.perm m' b ofs Cur Writable.","proofString":"eapply Mem.perm_store_1; eauto.\napply PERM.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : Mem.range_perm m' b (p + 1) (p + 1 + (n - 1)) Cur Writable ->\nexists m'0 : mem, store_zeros m' b (p + 1) (n - 1) = Some m'0) (PERM : Mem.range_perm m b p (p + n) Cur Writable) (ofs : Z) (H : p + 1 <= ofs < p + 1 + (n - 1)) : Mem.perm m b ofs Cur Writable.","proofString":"apply PERM.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (m' : mem) (e0 : Mem.store Mint8unsigned m b p Vzero = Some m') (IHo : Mem.range_perm m' b (p + 1) (p + 1 + (n - 1)) Cur Writable ->\nexists m'0 : mem, store_zeros m' b (p + 1) (n - 1) = Some m'0) (PERM : Mem.range_perm m b p (p + n) Cur Writable) (ofs : Z) (H : p + 1 <= ofs < p + 1 + (n - 1)) : p <= ofs < p + n.","proofString":"lia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (PERM : Mem.range_perm m b p (p + n) Cur Writable) : exists m' : mem, None = Some m'.","proofString":"destruct (Mem.valid_access_store m Mint8unsigned b p Vzero) as (m' & STORE).\nsplit.\nred; intros.\napply Mem.perm_cur.\napply PERM.\nsimpl in H.\nlia.\nsimpl.\napply Z.divide_1_l.\ncongruence."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (PERM : Mem.range_perm m b p (p + n) Cur Writable) : Mem.valid_access m Mint8unsigned b p Writable.","proofString":"split.\nred; intros.\napply Mem.perm_cur.\napply PERM.\nsimpl in H.\nlia.\nsimpl.\napply Z.divide_1_l."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (PERM : Mem.range_perm m b p (p + n) Cur Writable) : Mem.range_perm m b p (p + size_chunk Mint8unsigned) Cur Writable.","proofString":"red; intros.\napply Mem.perm_cur.\napply PERM.\nsimpl in H.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (PERM : Mem.range_perm m b p (p + n) Cur Writable) (ofs : Z) (H : p <= ofs < p + size_chunk Mint8unsigned) : Mem.perm m b ofs Cur Writable.","proofString":"apply Mem.perm_cur.\napply PERM.\nsimpl in H.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (PERM : Mem.range_perm m b p (p + n) Cur Writable) (ofs : Z) (H : p <= ofs < p + size_chunk Mint8unsigned) : Mem.perm m b ofs Cur Writable.","proofString":"apply PERM.\nsimpl in H.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (PERM : Mem.range_perm m b p (p + n) Cur Writable) (ofs : Z) (H : p <= ofs < p + size_chunk Mint8unsigned) : p <= ofs < p + n.","proofString":"simpl in H.\nlia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (PERM : Mem.range_perm m b p (p + n) Cur Writable) (ofs : Z) (H : p <= ofs < p + 1) : p <= ofs < p + n.","proofString":"lia."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (PERM : Mem.range_perm m b p (p + n) Cur Writable) : (align_chunk Mint8unsigned | p).","proofString":"simpl.\napply Z.divide_1_l."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (PERM : Mem.range_perm m b p (p + n) Cur Writable) : (1 | p).","proofString":"apply Z.divide_1_l."},{"statement":"(m : mem) (b : block) (p n : Z) (_x : n > 0) (e : zle n 0 = right _x) (e0 : Mem.store Mint8unsigned m b p Vzero = None) (PERM : Mem.range_perm m b p (p + n) Cur Writable) (m' : mem) (STORE : Mem.store Mint8unsigned m b p Vzero = Some m') : exists m'0 : mem, None = Some m'0.","proofString":"congruence."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (H : Mem.range_perm m b p (p + init_data_size i) Cur Writable) (H0 : (init_data_alignment i | p)) (H1 : forall (id : ident) (ofs : ptrofs),\ni = Init_addrof id ofs -> exists b0 : block, find_symbol ge id = Some b0) : exists m' : mem, store_init_data ge m b p i = Some m'.","proofString":"assert (DFL: forall chunk v,          init_data_size i = size_chunk chunk ->          init_data_alignment i = align_chunk chunk ->          exists m', Mem.store chunk m b p v = Some m').\nintros.\ndestruct (Mem.valid_access_store m chunk b p v) as (m' & STORE).\nsplit.\nrewrite <- H2; auto.\nrewrite <- H3; auto.\nexists m'; auto.\ndestruct i; eauto.\nsimpl.\nexists m; auto.\nsimpl.\nexploit H1; eauto.\nintros (b1 & FS).\nrewrite FS.\neapply DFL.\nunfold init_data_size, Mptr.\ndestruct Archi.ptr64; auto.\nunfold init_data_alignment, Mptr.\ndestruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (H : Mem.range_perm m b p (p + init_data_size i) Cur Writable) (H0 : (init_data_alignment i | p)) (H1 : forall (id : ident) (ofs : ptrofs),\ni = Init_addrof id ofs -> exists b0 : block, find_symbol ge id = Some b0) : forall (chunk : memory_chunk) (v : val),\ninit_data_size i = size_chunk chunk ->\ninit_data_alignment i = align_chunk chunk ->\nexists m' : mem, Mem.store chunk m b p v = Some m'.","proofString":"intros.\ndestruct (Mem.valid_access_store m chunk b p v) as (m' & STORE).\nsplit.\nrewrite <- H2; auto.\nrewrite <- H3; auto.\nexists m'; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (H : Mem.range_perm m b p (p + init_data_size i) Cur Writable) (H0 : (init_data_alignment i | p)) (H1 : forall (id : ident) (ofs : ptrofs),\ni = Init_addrof id ofs -> exists b0 : block, find_symbol ge id = Some b0) (chunk : memory_chunk) (v : val) (H2 : init_data_size i = size_chunk chunk) (H3 : init_data_alignment i = align_chunk chunk) : exists m' : mem, Mem.store chunk m b p v = Some m'.","proofString":"destruct (Mem.valid_access_store m chunk b p v) as (m' & STORE).\nsplit.\nrewrite <- H2; auto.\nrewrite <- H3; auto.\nexists m'; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (H : Mem.range_perm m b p (p + init_data_size i) Cur Writable) (H0 : (init_data_alignment i | p)) (H1 : forall (id : ident) (ofs : ptrofs),\ni = Init_addrof id ofs -> exists b0 : block, find_symbol ge id = Some b0) (chunk : memory_chunk) (v : val) (H2 : init_data_size i = size_chunk chunk) (H3 : init_data_alignment i = align_chunk chunk) : Mem.valid_access m chunk b p Writable.","proofString":"split.\nrewrite <- H2; auto.\nrewrite <- H3; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (H : Mem.range_perm m b p (p + init_data_size i) Cur Writable) (H0 : (init_data_alignment i | p)) (H1 : forall (id : ident) (ofs : ptrofs),\ni = Init_addrof id ofs -> exists b0 : block, find_symbol ge id = Some b0) (chunk : memory_chunk) (v : val) (H2 : init_data_size i = size_chunk chunk) (H3 : init_data_alignment i = align_chunk chunk) : Mem.range_perm m b p (p + size_chunk chunk) Cur Writable.","proofString":"rewrite <- H2; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (H : Mem.range_perm m b p (p + init_data_size i) Cur Writable) (H0 : (init_data_alignment i | p)) (H1 : forall (id : ident) (ofs : ptrofs),\ni = Init_addrof id ofs -> exists b0 : block, find_symbol ge id = Some b0) (chunk : memory_chunk) (v : val) (H2 : init_data_size i = size_chunk chunk) (H3 : init_data_alignment i = align_chunk chunk) : (align_chunk chunk | p).","proofString":"rewrite <- H3; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (H : Mem.range_perm m b p (p + init_data_size i) Cur Writable) (H0 : (init_data_alignment i | p)) (H1 : forall (id : ident) (ofs : ptrofs),\ni = Init_addrof id ofs -> exists b0 : block, find_symbol ge id = Some b0) (chunk : memory_chunk) (v : val) (H2 : init_data_size i = size_chunk chunk) (H3 : init_data_alignment i = align_chunk chunk) (m' : mem) (STORE : Mem.store chunk m b p v = Some m') : exists m'0 : mem, Mem.store chunk m b p v = Some m'0.","proofString":"exists m'; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : init_data) (H : Mem.range_perm m b p (p + init_data_size i) Cur Writable) (H0 : (init_data_alignment i | p)) (H1 : forall (id : ident) (ofs : ptrofs),\ni = Init_addrof id ofs -> exists b0 : block, find_symbol ge id = Some b0) (DFL : forall (chunk : memory_chunk) (v : val),\ninit_data_size i = size_chunk chunk ->\ninit_data_alignment i = align_chunk chunk ->\nexists m' : mem, Mem.store chunk m b p v = Some m') : exists m' : mem, store_init_data ge m b p i = Some m'.","proofString":"destruct i; eauto.\nsimpl.\nexists m; auto.\nsimpl.\nexploit H1; eauto.\nintros (b1 & FS).\nrewrite FS.\neapply DFL.\nunfold init_data_size, Mptr.\ndestruct Archi.ptr64; auto.\nunfold init_data_alignment, Mptr.\ndestruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p z : Z) (H : Mem.range_perm m b p (p + init_data_size (Init_space z)) Cur Writable) (H0 : (init_data_alignment (Init_space z) | p)) (H1 : forall (id : ident) (ofs : ptrofs),\nInit_space z = Init_addrof id ofs ->\nexists b0 : block, find_symbol ge id = Some b0) (DFL : forall (chunk : memory_chunk) (v : val),\ninit_data_size (Init_space z) = size_chunk chunk ->\ninit_data_alignment (Init_space z) = align_chunk chunk ->\nexists m' : mem, Mem.store chunk m b p v = Some m') : exists m' : mem, store_init_data ge m b p (Init_space z) = Some m'.","proofString":"simpl.\nexists m; auto."},{"statement":"(m : mem) (b : block) (p z : Z) (H : Mem.range_perm m b p (p + init_data_size (Init_space z)) Cur Writable) (H0 : (init_data_alignment (Init_space z) | p)) (H1 : forall (id : ident) (ofs : ptrofs),\nInit_space z = Init_addrof id ofs ->\nexists b0 : block, find_symbol ge id = Some b0) (DFL : forall (chunk : memory_chunk) (v : val),\ninit_data_size (Init_space z) = size_chunk chunk ->\ninit_data_alignment (Init_space z) = align_chunk chunk ->\nexists m' : mem, Mem.store chunk m b p v = Some m') : exists m' : mem, Some m = Some m'.","proofString":"exists m; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (H : Mem.range_perm m b p (p + init_data_size (Init_addrof i i0)) Cur Writable) (H0 : (init_data_alignment (Init_addrof i i0) | p)) (H1 : forall (id : ident) (ofs : ptrofs),\nInit_addrof i i0 = Init_addrof id ofs ->\nexists b0 : block, find_symbol ge id = Some b0) (DFL : forall (chunk : memory_chunk) (v : val),\ninit_data_size (Init_addrof i i0) = size_chunk chunk ->\ninit_data_alignment (Init_addrof i i0) = align_chunk chunk ->\nexists m' : mem, Mem.store chunk m b p v = Some m') : exists m' : mem, store_init_data ge m b p (Init_addrof i i0) = Some m'.","proofString":"simpl.\nexploit H1; eauto.\nintros (b1 & FS).\nrewrite FS.\neapply DFL.\nunfold init_data_size, Mptr.\ndestruct Archi.ptr64; auto.\nunfold init_data_alignment, Mptr.\ndestruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (H : Mem.range_perm m b p (p + init_data_size (Init_addrof i i0)) Cur Writable) (H0 : (init_data_alignment (Init_addrof i i0) | p)) (H1 : forall (id : ident) (ofs : ptrofs),\nInit_addrof i i0 = Init_addrof id ofs ->\nexists b0 : block, find_symbol ge id = Some b0) (DFL : forall (chunk : memory_chunk) (v : val),\ninit_data_size (Init_addrof i i0) = size_chunk chunk ->\ninit_data_alignment (Init_addrof i i0) = align_chunk chunk ->\nexists m' : mem, Mem.store chunk m b p v = Some m') : exists m' : mem,\n  match find_symbol ge i with\n  | Some b' => Mem.store Mptr m b p (Vptr b' i0)\n  | None => None\n  end = Some m'.","proofString":"exploit H1; eauto.\nintros (b1 & FS).\nrewrite FS.\neapply DFL.\nunfold init_data_size, Mptr.\ndestruct Archi.ptr64; auto.\nunfold init_data_alignment, Mptr.\ndestruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (H : Mem.range_perm m b p (p + init_data_size (Init_addrof i i0)) Cur Writable) (H0 : (init_data_alignment (Init_addrof i i0) | p)) (H1 : forall (id : ident) (ofs : ptrofs),\nInit_addrof i i0 = Init_addrof id ofs ->\nexists b0 : block, find_symbol ge id = Some b0) (DFL : forall (chunk : memory_chunk) (v : val),\ninit_data_size (Init_addrof i i0) = size_chunk chunk ->\ninit_data_alignment (Init_addrof i i0) = align_chunk chunk ->\nexists m' : mem, Mem.store chunk m b p v = Some m') : (exists b0 : block, find_symbol ge i = Some b0) ->\nexists m' : mem,\n  match find_symbol ge i with\n  | Some b' => Mem.store Mptr m b p (Vptr b' i0)\n  | None => None\n  end = Some m'.","proofString":"intros (b1 & FS).\nrewrite FS.\neapply DFL.\nunfold init_data_size, Mptr.\ndestruct Archi.ptr64; auto.\nunfold init_data_alignment, Mptr.\ndestruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (H : Mem.range_perm m b p (p + init_data_size (Init_addrof i i0)) Cur Writable) (H0 : (init_data_alignment (Init_addrof i i0) | p)) (H1 : forall (id : ident) (ofs : ptrofs),\nInit_addrof i i0 = Init_addrof id ofs ->\nexists b0 : block, find_symbol ge id = Some b0) (DFL : forall (chunk : memory_chunk) (v : val),\ninit_data_size (Init_addrof i i0) = size_chunk chunk ->\ninit_data_alignment (Init_addrof i i0) = align_chunk chunk ->\nexists m' : mem, Mem.store chunk m b p v = Some m') (b1 : block) (FS : find_symbol ge i = Some b1) : exists m' : mem,\n  match find_symbol ge i with\n  | Some b' => Mem.store Mptr m b p (Vptr b' i0)\n  | None => None\n  end = Some m'.","proofString":"rewrite FS.\neapply DFL.\nunfold init_data_size, Mptr.\ndestruct Archi.ptr64; auto.\nunfold init_data_alignment, Mptr.\ndestruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (H : Mem.range_perm m b p (p + init_data_size (Init_addrof i i0)) Cur Writable) (H0 : (init_data_alignment (Init_addrof i i0) | p)) (H1 : forall (id : ident) (ofs : ptrofs),\nInit_addrof i i0 = Init_addrof id ofs ->\nexists b0 : block, find_symbol ge id = Some b0) (DFL : forall (chunk : memory_chunk) (v : val),\ninit_data_size (Init_addrof i i0) = size_chunk chunk ->\ninit_data_alignment (Init_addrof i i0) = align_chunk chunk ->\nexists m' : mem, Mem.store chunk m b p v = Some m') (b1 : block) (FS : find_symbol ge i = Some b1) : exists m' : mem, Mem.store Mptr m b p (Vptr b1 i0) = Some m'.","proofString":"eapply DFL.\nunfold init_data_size, Mptr.\ndestruct Archi.ptr64; auto.\nunfold init_data_alignment, Mptr.\ndestruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (H : Mem.range_perm m b p (p + init_data_size (Init_addrof i i0)) Cur Writable) (H0 : (init_data_alignment (Init_addrof i i0) | p)) (H1 : forall (id : ident) (ofs : ptrofs),\nInit_addrof i i0 = Init_addrof id ofs ->\nexists b0 : block, find_symbol ge id = Some b0) (DFL : forall (chunk : memory_chunk) (v : val),\ninit_data_size (Init_addrof i i0) = size_chunk chunk ->\ninit_data_alignment (Init_addrof i i0) = align_chunk chunk ->\nexists m' : mem, Mem.store chunk m b p v = Some m') (b1 : block) (FS : find_symbol ge i = Some b1) : init_data_size (Init_addrof i i0) = size_chunk Mptr.","proofString":"unfold init_data_size, Mptr.\ndestruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (H : Mem.range_perm m b p (p + init_data_size (Init_addrof i i0)) Cur Writable) (H0 : (init_data_alignment (Init_addrof i i0) | p)) (H1 : forall (id : ident) (ofs : ptrofs),\nInit_addrof i i0 = Init_addrof id ofs ->\nexists b0 : block, find_symbol ge id = Some b0) (DFL : forall (chunk : memory_chunk) (v : val),\ninit_data_size (Init_addrof i i0) = size_chunk chunk ->\ninit_data_alignment (Init_addrof i i0) = align_chunk chunk ->\nexists m' : mem, Mem.store chunk m b p v = Some m') (b1 : block) (FS : find_symbol ge i = Some b1) : (if Archi.ptr64 then 8 else 4) =\nsize_chunk (if Archi.ptr64 then Mint64 else Mint32).","proofString":"destruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (H : Mem.range_perm m b p (p + init_data_size (Init_addrof i i0)) Cur Writable) (H0 : (init_data_alignment (Init_addrof i i0) | p)) (H1 : forall (id : ident) (ofs : ptrofs),\nInit_addrof i i0 = Init_addrof id ofs ->\nexists b0 : block, find_symbol ge id = Some b0) (DFL : forall (chunk : memory_chunk) (v : val),\ninit_data_size (Init_addrof i i0) = size_chunk chunk ->\ninit_data_alignment (Init_addrof i i0) = align_chunk chunk ->\nexists m' : mem, Mem.store chunk m b p v = Some m') (b1 : block) (FS : find_symbol ge i = Some b1) : init_data_alignment (Init_addrof i i0) = align_chunk Mptr.","proofString":"unfold init_data_alignment, Mptr.\ndestruct Archi.ptr64; auto."},{"statement":"(m : mem) (b : block) (p : Z) (i : ident) (i0 : ptrofs) (H : Mem.range_perm m b p (p + init_data_size (Init_addrof i i0)) Cur Writable) (H0 : (init_data_alignment (Init_addrof i i0) | p)) (H1 : forall (id : ident) (ofs : ptrofs),\nInit_addrof i i0 = Init_addrof id ofs ->\nexists b0 : block, find_symbol ge id = Some b0) (DFL : forall (chunk : memory_chunk) (v : val),\ninit_data_size (Init_addrof i i0) = size_chunk chunk ->\ninit_data_alignment (Init_addrof i i0) = align_chunk chunk ->\nexists m' : mem, Mem.store chunk m b p v = Some m') (b1 : block) (FS : find_symbol ge i = Some b1) : (if Archi.ptr64 then 8 else 4) =\nalign_chunk (if Archi.ptr64 then Mint64 else Mint32).","proofString":"destruct Archi.ptr64; auto."},{"statement":"(b : block) (m : mem) (p : Z) (H : Mem.range_perm m b p (p + 0) Cur Writable) (H0 : True) (H1 : forall id : ident,\nptrofs -> False -> exists b0 : block, find_symbol ge id = Some b0) : exists m' : mem, Some m = Some m'.","proofString":"exists m; auto."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z),\nMem.range_perm m0 b p0 (p0 + init_data_list_size il) Cur Writable ->\ninit_data_list_aligned p0 il ->\n(forall (id : ident) (ofs : ptrofs),\n In (Init_addrof id ofs) il -> exists b0 : block, find_symbol ge id = Some b0) ->\nexists m' : mem, store_init_data_list ge m0 b p0 il = Some m') (m : mem) (p : Z) (H : Mem.range_perm m b p (p + (init_data_size i1 + init_data_list_size il)) Cur\n  Writable) (H0 : (init_data_alignment i1 | p) /\\\ninit_data_list_aligned (p + init_data_size i1) il) (H1 : forall (id : ident) (ofs : ptrofs),\ni1 = Init_addrof id ofs \\/ In (Init_addrof id ofs) il ->\nexists b0 : block, find_symbol ge id = Some b0) : exists m' : mem,\n  match store_init_data ge m b p i1 with\n  | Some m'0 => store_init_data_list ge m'0 b (p + init_data_size i1) il\n  | None => None\n  end = Some m'.","proofString":"destruct H0.\ndestruct (@store_init_data_exists m b p i1) as (m1 & S1); eauto.\nred; intros.\napply H.\ngeneralize (init_data_list_size_pos il); lia.\nrewrite S1.\napply IHil; eauto.\nred; intros.\nerewrite <- store_init_data_perm by eauto.\napply H.\ngeneralize (init_data_size_pos i1); lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z),\nMem.range_perm m0 b p0 (p0 + init_data_list_size il) Cur Writable ->\ninit_data_list_aligned p0 il ->\n(forall (id : ident) (ofs : ptrofs),\n In (Init_addrof id ofs) il -> exists b0 : block, find_symbol ge id = Some b0) ->\nexists m' : mem, store_init_data_list ge m0 b p0 il = Some m') (m : mem) (p : Z) (H : Mem.range_perm m b p (p + (init_data_size i1 + init_data_list_size il)) Cur\n  Writable) (H0 : (init_data_alignment i1 | p)) (H2 : init_data_list_aligned (p + init_data_size i1) il) (H1 : forall (id : ident) (ofs : ptrofs),\ni1 = Init_addrof id ofs \\/ In (Init_addrof id ofs) il ->\nexists b0 : block, find_symbol ge id = Some b0) : exists m' : mem,\n  match store_init_data ge m b p i1 with\n  | Some m'0 => store_init_data_list ge m'0 b (p + init_data_size i1) il\n  | None => None\n  end = Some m'.","proofString":"destruct (@store_init_data_exists m b p i1) as (m1 & S1); eauto.\nred; intros.\napply H.\ngeneralize (init_data_list_size_pos il); lia.\nrewrite S1.\napply IHil; eauto.\nred; intros.\nerewrite <- store_init_data_perm by eauto.\napply H.\ngeneralize (init_data_size_pos i1); lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z),\nMem.range_perm m0 b p0 (p0 + init_data_list_size il) Cur Writable ->\ninit_data_list_aligned p0 il ->\n(forall (id : ident) (ofs : ptrofs),\n In (Init_addrof id ofs) il -> exists b0 : block, find_symbol ge id = Some b0) ->\nexists m' : mem, store_init_data_list ge m0 b p0 il = Some m') (m : mem) (p : Z) (H : Mem.range_perm m b p (p + (init_data_size i1 + init_data_list_size il)) Cur\n  Writable) (H0 : (init_data_alignment i1 | p)) (H2 : init_data_list_aligned (p + init_data_size i1) il) (H1 : forall (id : ident) (ofs : ptrofs),\ni1 = Init_addrof id ofs \\/ In (Init_addrof id ofs) il ->\nexists b0 : block, find_symbol ge id = Some b0) : Mem.range_perm m b p (p + init_data_size i1) Cur Writable.","proofString":"red; intros.\napply H.\ngeneralize (init_data_list_size_pos il); lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z),\nMem.range_perm m0 b p0 (p0 + init_data_list_size il) Cur Writable ->\ninit_data_list_aligned p0 il ->\n(forall (id : ident) (ofs0 : ptrofs),\n In (Init_addrof id ofs0) il ->\n exists b0 : block, find_symbol ge id = Some b0) ->\nexists m' : mem, store_init_data_list ge m0 b p0 il = Some m') (m : mem) (p : Z) (H : Mem.range_perm m b p (p + (init_data_size i1 + init_data_list_size il)) Cur\n  Writable) (H0 : (init_data_alignment i1 | p)) (H2 : init_data_list_aligned (p + init_data_size i1) il) (H1 : forall (id : ident) (ofs0 : ptrofs),\ni1 = Init_addrof id ofs0 \\/ In (Init_addrof id ofs0) il ->\nexists b0 : block, find_symbol ge id = Some b0) (ofs : Z) (H3 : p <= ofs < p + init_data_size i1) : Mem.perm m b ofs Cur Writable.","proofString":"apply H.\ngeneralize (init_data_list_size_pos il); lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z),\nMem.range_perm m0 b p0 (p0 + init_data_list_size il) Cur Writable ->\ninit_data_list_aligned p0 il ->\n(forall (id : ident) (ofs0 : ptrofs),\n In (Init_addrof id ofs0) il ->\n exists b0 : block, find_symbol ge id = Some b0) ->\nexists m' : mem, store_init_data_list ge m0 b p0 il = Some m') (m : mem) (p : Z) (H : Mem.range_perm m b p (p + (init_data_size i1 + init_data_list_size il)) Cur\n  Writable) (H0 : (init_data_alignment i1 | p)) (H2 : init_data_list_aligned (p + init_data_size i1) il) (H1 : forall (id : ident) (ofs0 : ptrofs),\ni1 = Init_addrof id ofs0 \\/ In (Init_addrof id ofs0) il ->\nexists b0 : block, find_symbol ge id = Some b0) (ofs : Z) (H3 : p <= ofs < p + init_data_size i1) : p <= ofs < p + (init_data_size i1 + init_data_list_size il).","proofString":"generalize (init_data_list_size_pos il); lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z),\nMem.range_perm m0 b p0 (p0 + init_data_list_size il) Cur Writable ->\ninit_data_list_aligned p0 il ->\n(forall (id : ident) (ofs : ptrofs),\n In (Init_addrof id ofs) il -> exists b0 : block, find_symbol ge id = Some b0) ->\nexists m' : mem, store_init_data_list ge m0 b p0 il = Some m') (m : mem) (p : Z) (H : Mem.range_perm m b p (p + (init_data_size i1 + init_data_list_size il)) Cur\n  Writable) (H0 : (init_data_alignment i1 | p)) (H2 : init_data_list_aligned (p + init_data_size i1) il) (H1 : forall (id : ident) (ofs : ptrofs),\ni1 = Init_addrof id ofs \\/ In (Init_addrof id ofs) il ->\nexists b0 : block, find_symbol ge id = Some b0) (m1 : mem) (S1 : store_init_data ge m b p i1 = Some m1) : exists m' : mem,\n  match store_init_data ge m b p i1 with\n  | Some m'0 => store_init_data_list ge m'0 b (p + init_data_size i1) il\n  | None => None\n  end = Some m'.","proofString":"rewrite S1.\napply IHil; eauto.\nred; intros.\nerewrite <- store_init_data_perm by eauto.\napply H.\ngeneralize (init_data_size_pos i1); lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z),\nMem.range_perm m0 b p0 (p0 + init_data_list_size il) Cur Writable ->\ninit_data_list_aligned p0 il ->\n(forall (id : ident) (ofs : ptrofs),\n In (Init_addrof id ofs) il -> exists b0 : block, find_symbol ge id = Some b0) ->\nexists m' : mem, store_init_data_list ge m0 b p0 il = Some m') (m : mem) (p : Z) (H : Mem.range_perm m b p (p + (init_data_size i1 + init_data_list_size il)) Cur\n  Writable) (H0 : (init_data_alignment i1 | p)) (H2 : init_data_list_aligned (p + init_data_size i1) il) (H1 : forall (id : ident) (ofs : ptrofs),\ni1 = Init_addrof id ofs \\/ In (Init_addrof id ofs) il ->\nexists b0 : block, find_symbol ge id = Some b0) (m1 : mem) (S1 : store_init_data ge m b p i1 = Some m1) : exists m' : mem,\n  store_init_data_list ge m1 b (p + init_data_size i1) il = Some m'.","proofString":"apply IHil; eauto.\nred; intros.\nerewrite <- store_init_data_perm by eauto.\napply H.\ngeneralize (init_data_size_pos i1); lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z),\nMem.range_perm m0 b p0 (p0 + init_data_list_size il) Cur Writable ->\ninit_data_list_aligned p0 il ->\n(forall (id : ident) (ofs : ptrofs),\n In (Init_addrof id ofs) il -> exists b0 : block, find_symbol ge id = Some b0) ->\nexists m' : mem, store_init_data_list ge m0 b p0 il = Some m') (m : mem) (p : Z) (H : Mem.range_perm m b p (p + (init_data_size i1 + init_data_list_size il)) Cur\n  Writable) (H0 : (init_data_alignment i1 | p)) (H2 : init_data_list_aligned (p + init_data_size i1) il) (H1 : forall (id : ident) (ofs : ptrofs),\ni1 = Init_addrof id ofs \\/ In (Init_addrof id ofs) il ->\nexists b0 : block, find_symbol ge id = Some b0) (m1 : mem) (S1 : store_init_data ge m b p i1 = Some m1) : Mem.range_perm m1 b (p + init_data_size i1)\n  (p + init_data_size i1 + init_data_list_size il) Cur Writable.","proofString":"red; intros.\nerewrite <- store_init_data_perm by eauto.\napply H.\ngeneralize (init_data_size_pos i1); lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z),\nMem.range_perm m0 b p0 (p0 + init_data_list_size il) Cur Writable ->\ninit_data_list_aligned p0 il ->\n(forall (id : ident) (ofs0 : ptrofs),\n In (Init_addrof id ofs0) il ->\n exists b0 : block, find_symbol ge id = Some b0) ->\nexists m' : mem, store_init_data_list ge m0 b p0 il = Some m') (m : mem) (p : Z) (H : Mem.range_perm m b p (p + (init_data_size i1 + init_data_list_size il)) Cur\n  Writable) (H0 : (init_data_alignment i1 | p)) (H2 : init_data_list_aligned (p + init_data_size i1) il) (H1 : forall (id : ident) (ofs0 : ptrofs),\ni1 = Init_addrof id ofs0 \\/ In (Init_addrof id ofs0) il ->\nexists b0 : block, find_symbol ge id = Some b0) (m1 : mem) (S1 : store_init_data ge m b p i1 = Some m1) (ofs : Z) (H3 : p + init_data_size i1 <= ofs < p + init_data_size i1 + init_data_list_size il) : Mem.perm m1 b ofs Cur Writable.","proofString":"erewrite <- store_init_data_perm by eauto.\napply H.\ngeneralize (init_data_size_pos i1); lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z),\nMem.range_perm m0 b p0 (p0 + init_data_list_size il) Cur Writable ->\ninit_data_list_aligned p0 il ->\n(forall (id : ident) (ofs0 : ptrofs),\n In (Init_addrof id ofs0) il ->\n exists b0 : block, find_symbol ge id = Some b0) ->\nexists m' : mem, store_init_data_list ge m0 b p0 il = Some m') (m : mem) (p : Z) (H : Mem.range_perm m b p (p + (init_data_size i1 + init_data_list_size il)) Cur\n  Writable) (H0 : (init_data_alignment i1 | p)) (H2 : init_data_list_aligned (p + init_data_size i1) il) (H1 : forall (id : ident) (ofs0 : ptrofs),\ni1 = Init_addrof id ofs0 \\/ In (Init_addrof id ofs0) il ->\nexists b0 : block, find_symbol ge id = Some b0) (m1 : mem) (S1 : store_init_data ge m b p i1 = Some m1) (ofs : Z) (H3 : p + init_data_size i1 <= ofs < p + init_data_size i1 + init_data_list_size il) : Mem.perm m b ofs Cur Writable.","proofString":"apply H.\ngeneralize (init_data_size_pos i1); lia."},{"statement":"(b : block) (i1 : init_data) (il : list init_data) (IHil : forall (m0 : mem) (p0 : Z),\nMem.range_perm m0 b p0 (p0 + init_data_list_size il) Cur Writable ->\ninit_data_list_aligned p0 il ->\n(forall (id : ident) (ofs0 : ptrofs),\n In (Init_addrof id ofs0) il ->\n exists b0 : block, find_symbol ge id = Some b0) ->\nexists m' : mem, store_init_data_list ge m0 b p0 il = Some m') (m : mem) (p : Z) (H : Mem.range_perm m b p (p + (init_data_size i1 + init_data_list_size il)) Cur\n  Writable) (H0 : (init_data_alignment i1 | p)) (H2 : init_data_list_aligned (p + init_data_size i1) il) (H1 : forall (id : ident) (ofs0 : ptrofs),\ni1 = Init_addrof id ofs0 \\/ In (Init_addrof id ofs0) il ->\nexists b0 : block, find_symbol ge id = Some b0) (m1 : mem) (S1 : store_init_data ge m b p i1 = Some m1) (ofs : Z) (H3 : p + init_data_size i1 <= ofs < p + init_data_size i1 + init_data_list_size il) : p <= ofs < p + (init_data_size i1 + init_data_list_size il).","proofString":"generalize (init_data_size_pos i1); lia."},{"statement":"(m : mem) (id : ident) (f : F) (H : True) : exists m' : mem,\n  (let (m1, b) := Mem.alloc m 0 1 in Mem.drop_perm m1 b 0 1 Nonempty) =\n  Some m'.","proofString":"destruct (Mem.alloc m 0 1) as [m1 b] eqn:ALLOC.\ndestruct (Mem.range_perm_drop_2 m1 b 0 1 Nonempty) as [m2 DROP].\nred; intros; eapply Mem.perm_alloc_2; eauto.\nexists m2; auto."},{"statement":"(m : mem) (id : ident) (f : F) (H : True) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) : exists m' : mem, Mem.drop_perm m1 b 0 1 Nonempty = Some m'.","proofString":"destruct (Mem.range_perm_drop_2 m1 b 0 1 Nonempty) as [m2 DROP].\nred; intros; eapply Mem.perm_alloc_2; eauto.\nexists m2; auto."},{"statement":"(m : mem) (id : ident) (f : F) (H : True) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) : Mem.range_perm m1 b 0 1 Cur Freeable.","proofString":"red; intros; eapply Mem.perm_alloc_2; eauto."},{"statement":"(m : mem) (id : ident) (f : F) (H : True) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 1 = (m1, b)) (m2 : mem) (DROP : Mem.drop_perm m1 b 0 1 Nonempty = Some m2) : exists m' : mem, Mem.drop_perm m1 b 0 1 Nonempty = Some m'.","proofString":"exists m2; auto."},{"statement":"(m : mem) (id : ident) (v : globvar V) (H : init_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b)) : exists m' : mem,\n  (let (m1, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n   match store_zeros m1 b 0 (init_data_list_size (gvar_init v)) with\n   | Some m2 =>\n       match store_init_data_list ge m2 b 0 (gvar_init v) with\n       | Some m3 =>\n           Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n             (perm_globvar v)\n       | None => None\n       end\n   | None => None\n   end) = Some m'.","proofString":"destruct H as [P Q].\nset (sz := init_data_list_size (gvar_init v)).\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:ALLOC.\nassert (P1: Mem.range_perm m1 b 0 sz Cur Freeable) by (red; intros; eapply Mem.perm_alloc_2; eauto).\ndestruct (@store_zeros_exists m1 b 0 sz) as [m2 ZEROS].\nred; intros.\napply Mem.perm_implies with Freeable; auto with mem.\nrewrite ZEROS.\nassert (P2: Mem.range_perm m2 b 0 sz Cur Freeable).\nred; intros.\nerewrite <- store_zeros_perm by eauto.\neauto.\ndestruct (@store_init_data_list_exists b (gvar_init v) m2 0) as [m3 STORE]; auto.\nred; intros.\napply Mem.perm_implies with Freeable; auto with mem.\nrewrite STORE.\nassert (P3: Mem.range_perm m3 b 0 sz Cur Freeable).\nred; intros.\nerewrite <- store_init_data_list_perm by eauto.\neauto.\ndestruct (Mem.range_perm_drop_2 m3 b 0 sz (perm_globvar v)) as [m4 DROP]; auto.\nexists m4; auto."},{"statement":"(m : mem) (id : ident) (v : globvar V) (P : init_data_list_aligned 0 (gvar_init v)) (Q : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b : block, find_symbol ge i = Some b) : exists m' : mem,\n  (let (m1, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n   match store_zeros m1 b 0 (init_data_list_size (gvar_init v)) with\n   | Some m2 =>\n       match store_init_data_list ge m2 b 0 (gvar_init v) with\n       | Some m3 =>\n           Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n             (perm_globvar v)\n       | None => None\n       end\n   | None => None\n   end) = Some m'.","proofString":"set (sz := init_data_list_size (gvar_init v)).\ndestruct (Mem.alloc m 0 sz) as [m1 b] eqn:ALLOC.\nassert (P1: Mem.range_perm m1 b 0 sz Cur Freeable) by (red; intros; eapply Mem.perm_alloc_2; eauto).\ndestruct (@store_zeros_exists m1 b 0 sz) as [m2 ZEROS].\nred; intros.\napply Mem.perm_implies with Freeable; auto with mem.\nrewrite ZEROS.\nassert (P2: Mem.range_perm m2 b 0 sz Cur Freeable).\nred; intros.\nerewrite <- store_zeros_perm by eauto.\neauto.\ndestruct (@store_init_data_list_exists b (gvar_init v) m2 0) as [m3 STORE]; auto.\nred; intros.\napply Mem.perm_implies with Freeable; auto with mem.\nrewrite STORE.\nassert (P3: Mem.range_perm m3 b 0 sz Cur Freeable).\nred; intros.\nerewrite <- store_init_data_list_perm by eauto.\neauto.\ndestruct (Mem.range_perm_drop_2 m3 b 0 sz (perm_globvar v)) as [m4 DROP]; auto.\nexists m4; auto."},{"statement":"(m : mem) (id : ident) (v : globvar V) (P : init_data_list_aligned 0 (gvar_init v)) (Q : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b0 : block, find_symbol ge i = Some b0) (sz : Z) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 sz = (m1, b)) (P1 : Mem.range_perm m1 b 0 sz Cur Freeable) : Mem.range_perm m1 b 0 (0 + sz) Cur Writable.","proofString":"red; intros.\napply Mem.perm_implies with Freeable; auto with mem."},{"statement":"(m : mem) (id : ident) (v : globvar V) (P : init_data_list_aligned 0 (gvar_init v)) (Q : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b0 : block, find_symbol ge i = Some b0) (sz : Z) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 sz = (m1, b)) (P1 : Mem.range_perm m1 b 0 sz Cur Freeable) (ofs : Z) (H : 0 <= ofs < 0 + sz) : Mem.perm m1 b ofs Cur Writable.","proofString":"apply Mem.perm_implies with Freeable; auto with mem."},{"statement":"(m : mem) (id : ident) (v : globvar V) (P : init_data_list_aligned 0 (gvar_init v)) (Q : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b0 : block, find_symbol ge i = Some b0) (sz : Z) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 sz = (m1, b)) (P1 : Mem.range_perm m1 b 0 sz Cur Freeable) (m2 : mem) (ZEROS : store_zeros m1 b 0 sz = Some m2) : Mem.range_perm m2 b 0 sz Cur Freeable.","proofString":"red; intros.\nerewrite <- store_zeros_perm by eauto.\neauto."},{"statement":"(m : mem) (id : ident) (v : globvar V) (P : init_data_list_aligned 0 (gvar_init v)) (Q : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b0 : block, find_symbol ge i = Some b0) (sz : Z) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 sz = (m1, b)) (P1 : Mem.range_perm m1 b 0 sz Cur Freeable) (m2 : mem) (ZEROS : store_zeros m1 b 0 sz = Some m2) (ofs : Z) (H : 0 <= ofs < sz) : Mem.perm m2 b ofs Cur Freeable.","proofString":"erewrite <- store_zeros_perm by eauto.\neauto."},{"statement":"(m : mem) (id : ident) (v : globvar V) (P : init_data_list_aligned 0 (gvar_init v)) (Q : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b0 : block, find_symbol ge i = Some b0) (sz : Z) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 sz = (m1, b)) (P1 : Mem.range_perm m1 b 0 sz Cur Freeable) (m2 : mem) (ZEROS : store_zeros m1 b 0 sz = Some m2) (ofs : Z) (H : 0 <= ofs < sz) : Mem.perm m1 b ofs Cur Freeable.","proofString":"eauto."},{"statement":"(m : mem) (id : ident) (v : globvar V) (P : init_data_list_aligned 0 (gvar_init v)) (Q : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b0 : block, find_symbol ge i = Some b0) (sz : Z) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 sz = (m1, b)) (P1 : Mem.range_perm m1 b 0 sz Cur Freeable) (m2 : mem) (ZEROS : store_zeros m1 b 0 sz = Some m2) (P2 : Mem.range_perm m2 b 0 sz Cur Freeable) (m3 : mem) (STORE : store_init_data_list ge m2 b 0 (gvar_init v) = Some m3) : exists m' : mem,\n  match store_init_data_list ge m2 b 0 (gvar_init v) with\n  | Some m0 => Mem.drop_perm m0 b 0 sz (perm_globvar v)\n  | None => None\n  end = Some m'.","proofString":"rewrite STORE.\nassert (P3: Mem.range_perm m3 b 0 sz Cur Freeable).\nred; intros.\nerewrite <- store_init_data_list_perm by eauto.\neauto.\ndestruct (Mem.range_perm_drop_2 m3 b 0 sz (perm_globvar v)) as [m4 DROP]; auto.\nexists m4; auto."},{"statement":"(m : mem) (id : ident) (v : globvar V) (P : init_data_list_aligned 0 (gvar_init v)) (Q : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b0 : block, find_symbol ge i = Some b0) (sz : Z) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 sz = (m1, b)) (P1 : Mem.range_perm m1 b 0 sz Cur Freeable) (m2 : mem) (ZEROS : store_zeros m1 b 0 sz = Some m2) (P2 : Mem.range_perm m2 b 0 sz Cur Freeable) (m3 : mem) (STORE : store_init_data_list ge m2 b 0 (gvar_init v) = Some m3) : exists m' : mem, Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m'.","proofString":"assert (P3: Mem.range_perm m3 b 0 sz Cur Freeable).\nred; intros.\nerewrite <- store_init_data_list_perm by eauto.\neauto.\ndestruct (Mem.range_perm_drop_2 m3 b 0 sz (perm_globvar v)) as [m4 DROP]; auto.\nexists m4; auto."},{"statement":"(m : mem) (id : ident) (v : globvar V) (P : init_data_list_aligned 0 (gvar_init v)) (Q : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b0 : block, find_symbol ge i = Some b0) (sz : Z) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 sz = (m1, b)) (P1 : Mem.range_perm m1 b 0 sz Cur Freeable) (m2 : mem) (ZEROS : store_zeros m1 b 0 sz = Some m2) (P2 : Mem.range_perm m2 b 0 sz Cur Freeable) (m3 : mem) (STORE : store_init_data_list ge m2 b 0 (gvar_init v) = Some m3) : Mem.range_perm m3 b 0 sz Cur Freeable.","proofString":"red; intros.\nerewrite <- store_init_data_list_perm by eauto.\neauto."},{"statement":"(m : mem) (id : ident) (v : globvar V) (P : init_data_list_aligned 0 (gvar_init v)) (Q : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b0 : block, find_symbol ge i = Some b0) (sz : Z) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 sz = (m1, b)) (P1 : Mem.range_perm m1 b 0 sz Cur Freeable) (m2 : mem) (ZEROS : store_zeros m1 b 0 sz = Some m2) (P2 : Mem.range_perm m2 b 0 sz Cur Freeable) (m3 : mem) (STORE : store_init_data_list ge m2 b 0 (gvar_init v) = Some m3) (ofs : Z) (H : 0 <= ofs < sz) : Mem.perm m3 b ofs Cur Freeable.","proofString":"erewrite <- store_init_data_list_perm by eauto.\neauto."},{"statement":"(m : mem) (id : ident) (v : globvar V) (P : init_data_list_aligned 0 (gvar_init v)) (Q : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b0 : block, find_symbol ge i = Some b0) (sz : Z) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 sz = (m1, b)) (P1 : Mem.range_perm m1 b 0 sz Cur Freeable) (m2 : mem) (ZEROS : store_zeros m1 b 0 sz = Some m2) (P2 : Mem.range_perm m2 b 0 sz Cur Freeable) (m3 : mem) (STORE : store_init_data_list ge m2 b 0 (gvar_init v) = Some m3) (ofs : Z) (H : 0 <= ofs < sz) : Mem.perm m2 b ofs Cur Freeable.","proofString":"eauto."},{"statement":"(m : mem) (id : ident) (v : globvar V) (P : init_data_list_aligned 0 (gvar_init v)) (Q : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b0 : block, find_symbol ge i = Some b0) (sz : Z) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 sz = (m1, b)) (P1 : Mem.range_perm m1 b 0 sz Cur Freeable) (m2 : mem) (ZEROS : store_zeros m1 b 0 sz = Some m2) (P2 : Mem.range_perm m2 b 0 sz Cur Freeable) (m3 : mem) (STORE : store_init_data_list ge m2 b 0 (gvar_init v) = Some m3) (P3 : Mem.range_perm m3 b 0 sz Cur Freeable) : exists m' : mem, Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m'.","proofString":"destruct (Mem.range_perm_drop_2 m3 b 0 sz (perm_globvar v)) as [m4 DROP]; auto.\nexists m4; auto."},{"statement":"(m : mem) (id : ident) (v : globvar V) (P : init_data_list_aligned 0 (gvar_init v)) (Q : forall (i : ident) (o : ptrofs),\nIn (Init_addrof i o) (gvar_init v) ->\nexists b0 : block, find_symbol ge i = Some b0) (sz : Z) (m1 : Mem.mem') (b : block) (ALLOC : Mem.alloc m 0 sz = (m1, b)) (P1 : Mem.range_perm m1 b 0 sz Cur Freeable) (m2 : mem) (ZEROS : store_zeros m1 b 0 sz = Some m2) (P2 : Mem.range_perm m2 b 0 sz Cur Freeable) (m3 : mem) (STORE : store_init_data_list ge m2 b 0 (gvar_init v) = Some m3) (P3 : Mem.range_perm m3 b 0 sz Cur Freeable) (m4 : mem) (DROP : Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m4) : exists m' : mem, Mem.drop_perm m3 b 0 sz (perm_globvar v) = Some m'.","proofString":"exists m4; auto."},{"statement":"(p : program F V) (H : forall (id : ident) (v : globvar V),\nIn (id, Gvar v) (prog_defs p) ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol (globalenv p) i = Some b)) : exists m : mem, init_mem p = Some m.","proofString":"set (ge := globalenv p) in *.\nunfold init_mem.\nrevert H.\ngeneralize (prog_defs p) Mem.empty.\ninduction l as [ | idg l]; simpl; intros.\nexists m; auto.\ndestruct (@alloc_global_exists ge m idg) as [m1 A1].\ndestruct idg as [id [f|v]]; eauto.\nfold ge.\nrewrite A1.\neapply IHl; eauto."},{"statement":"(p : program F V) (ge : t) (m : mem) (H : ident ->\nforall v : globvar V,\nFalse ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b)) : exists m0 : mem, Some m = Some m0.","proofString":"exists m; auto."},{"statement":"(p : program F V) (ge : t) (idg : ident * globdef F V) (l : list (ident * globdef F V)) (IHl : forall m0 : mem,\n(forall (id : ident) (v : globvar V),\n In (id, Gvar v) l ->\n init_data_list_aligned 0 (gvar_init v) /\\\n (forall (i : ident) (o : ptrofs),\n  In (Init_addrof i o) (gvar_init v) ->\n  exists b : block, find_symbol ge i = Some b)) ->\nexists m1 : mem, alloc_globals (globalenv p) m0 l = Some m1) (m : mem) (H : forall (id : ident) (v : globvar V),\nidg = (id, Gvar v) \\/ In (id, Gvar v) l ->\ninit_data_list_aligned 0 (gvar_init v) /\\\n(forall (i : ident) (o : ptrofs),\n In (Init_addrof i o) (gvar_init v) ->\n exists b : block, find_symbol ge i = Some b)) : let (_, y) := idg in\nmatch y with\n| Gfun _ => True\n| Gvar v =>\n    init_data_list_aligned 0 (gvar_init v) /\\\n    (forall (i : ident) (o : ptrofs),\n     In (Init_addrof i o) (gvar_init v) ->\n     exists b : block, find_symbol ge i = Some b)\nend.","proofString":"destruct idg as [id [f|v]]; eauto."},{"statement":"(ge1 : t A V) (ge2 : t B W) (id : ident) (g1 : globdef A V) (g2 : globdef B W) (H : match_genvs ge1 ge2) (H0 : R g1 g2) : match_genvs (add_global ge1 (id, g1)) (add_global ge2 (id, g2)).","proofString":"destruct H.\nconstructor; simpl; intros.\ncongruence.\nrewrite mge_next0, ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nrewrite mge_next0, ! PTree.gsspec.\ndestruct (peq b (genv_next ge1)).\nconstructor; auto.\nauto."},{"statement":"(ge1 : t A V) (ge2 : t B W) (id : ident) (g1 : globdef A V) (g2 : globdef B W) (mge_next0 : genv_next ge2 = genv_next ge1) (mge_symb0 : forall id0 : positive, (genv_symb ge2) ! id0 = (genv_symb ge1) ! id0) (mge_defs0 : forall b : positive, option_rel R (genv_defs ge1) ! b (genv_defs ge2) ! b) (H0 : R g1 g2) : match_genvs (add_global ge1 (id, g1)) (add_global ge2 (id, g2)).","proofString":"constructor; simpl; intros.\ncongruence.\nrewrite mge_next0, ! PTree.gsspec.\ndestruct (peq id0 id); auto.\nrewrite mge_next0, ! PTree.gsspec.\ndestruct (peq b (genv_next ge1)).\nconstructor; auto.\nauto."},{"statement":"(ge1 : t A V) (ge2 : t B W) (id : ident) (g1 : globdef A V) (g2 : globdef B W) (mge_next0 : genv_next ge2 = genv_next ge1) (mge_symb0 : forall id0 : positive, (genv_symb ge2) ! id0 = (genv_symb ge1) ! id0) (mge_defs0 : forall b : positive, option_rel R (genv_defs ge1) ! b (genv_defs ge2) ! b) (H0 : R g1 g2) : Pos.succ (genv_next ge2) = Pos.succ (genv_next ge1).","proofString":"congruence."},{"statement":"(ge1 : t A V) (ge2 : t B W) (id : ident) (g1 : globdef A V) (g2 : globdef B W) (mge_next0 : genv_next ge2 = genv_next ge1) (mge_symb0 : forall id1 : positive, (genv_symb ge2) ! id1 = (genv_symb ge1) ! id1) (mge_defs0 : forall b : positive, option_rel R (genv_defs ge1) ! b (genv_defs ge2) ! b) (H0 : R g1 g2) (id0 : positive) : (PTree.set id (genv_next ge2) (genv_symb ge2)) ! id0 =\n(PTree.set id (genv_next ge1) (genv_symb ge1)) ! id0.","proofString":"rewrite mge_next0, ! PTree.gsspec.\ndestruct (peq id0 id); auto."},{"statement":"(ge1 : t A V) (ge2 : t B W) (id : ident) (g1 : globdef A V) (g2 : globdef B W) (mge_next0 : genv_next ge2 = genv_next ge1) (mge_symb0 : forall id1 : positive, (genv_symb ge2) ! id1 = (genv_symb ge1) ! id1) (mge_defs0 : forall b : positive, option_rel R (genv_defs ge1) ! b (genv_defs ge2) ! b) (H0 : R g1 g2) (id0 : positive) : (if peq id0 id then Some (genv_next ge1) else (genv_symb ge2) ! id0) =\n(if peq id0 id then Some (genv_next ge1) else (genv_symb ge1) ! id0).","proofString":"destruct (peq id0 id); auto."},{"statement":"(ge1 : t A V) (ge2 : t B W) (id : ident) (g1 : globdef A V) (g2 : globdef B W) (mge_next0 : genv_next ge2 = genv_next ge1) (mge_symb0 : forall id0 : positive, (genv_symb ge2) ! id0 = (genv_symb ge1) ! id0) (mge_defs0 : forall b0 : positive, option_rel R (genv_defs ge1) ! b0 (genv_defs ge2) ! b0) (H0 : R g1 g2) (b : positive) : option_rel R (PTree.set (genv_next ge1) g1 (genv_defs ge1)) ! b\n  (PTree.set (genv_next ge2) g2 (genv_defs ge2)) ! b.","proofString":"rewrite mge_next0, ! PTree.gsspec.\ndestruct (peq b (genv_next ge1)).\nconstructor; auto.\nauto."},{"statement":"(ge1 : t A V) (ge2 : t B W) (id : ident) (g1 : globdef A V) (g2 : globdef B W) (mge_next0 : genv_next ge2 = genv_next ge1) (mge_symb0 : forall id0 : positive, (genv_symb ge2) ! id0 = (genv_symb ge1) ! id0) (mge_defs0 : forall b0 : positive, option_rel R (genv_defs ge1) ! b0 (genv_defs ge2) ! b0) (H0 : R g1 g2) (b : positive) : option_rel R (if peq b (genv_next ge1) then Some g1 else (genv_defs ge1) ! b)\n  (if peq b (genv_next ge1) then Some g2 else (genv_defs ge2) ! b).","proofString":"destruct (peq b (genv_next ge1)).\nconstructor; auto.\nauto."},{"statement":"(ge1 : t A V) (ge2 : t B W) (id : ident) (g1 : globdef A V) (g2 : globdef B W) (mge_next0 : genv_next ge2 = genv_next ge1) (mge_symb0 : forall id0 : positive, (genv_symb ge2) ! id0 = (genv_symb ge1) ! id0) (mge_defs0 : forall b0 : positive, option_rel R (genv_defs ge1) ! b0 (genv_defs ge2) ! b0) (H0 : R g1 g2) (b : positive) (e : b = genv_next ge1) : option_rel R (Some g1) (Some g2).","proofString":"constructor; auto."},{"statement":"(ge1 : t A V) (ge2 : t B W) (id : ident) (g1 : globdef A V) (g2 : globdef B W) (mge_next0 : genv_next ge2 = genv_next ge1) (mge_symb0 : forall id0 : positive, (genv_symb ge2) ! id0 = (genv_symb ge1) ! id0) (mge_defs0 : forall b0 : positive, option_rel R (genv_defs ge1) ! b0 (genv_defs ge2) ! b0) (H0 : R g1 g2) (b : positive) (n : b <> genv_next ge1) : option_rel R (genv_defs ge1) ! b (genv_defs ge2) ! b.","proofString":"auto."},{"statement":"(ge1 : t A V) (ge2 : t B W) (H : match_genvs ge1 ge2) : match_genvs ge1 ge2.","proofString":"auto."},{"statement":"(a1 : ident * globdef A V) (al : list (ident * globdef A V)) (b1 : ident * globdef B W) (bl : list (ident * globdef B W)) (H : a1#1 = b1#1 /\\ R a1#2 b1#2) (H0 : list_forall2\n  (fun (idg1 : ident * globdef A V) (idg2 : ident * globdef B W) =>\n   idg1#1 = idg2#1 /\\ R idg1#2 idg2#2) al bl) (IHlist_forall2 : forall (ge0 : t A V) (ge3 : t B W),\nmatch_genvs ge0 ge3 -> match_genvs (add_globals ge0 al) (add_globals ge3 bl)) (ge1 : t A V) (ge2 : t B W) (H1 : match_genvs ge1 ge2) : match_genvs (add_globals (add_global ge1 a1) al)\n  (add_globals (add_global ge2 b1) bl).","proofString":"destruct a1 as [id1 g1]; destruct b1 as [id2 g2]; simpl in *; destruct H; subst id2.\napply IHlist_forall2.\napply add_global_match; auto."},{"statement":"(id1 : ident) (g1 : globdef A V) (al : list (ident * globdef A V)) (g2 : globdef B W) (bl : list (ident * globdef B W)) (H2 : R g1 g2) (H0 : list_forall2\n  (fun (idg1 : ident * globdef A V) (idg2 : ident * globdef B W) =>\n   idg1#1 = idg2#1 /\\ R idg1#2 idg2#2) al bl) (IHlist_forall2 : forall (ge0 : t A V) (ge3 : t B W),\nmatch_genvs ge0 ge3 -> match_genvs (add_globals ge0 al) (add_globals ge3 bl)) (ge1 : t A V) (ge2 : t B W) (H1 : match_genvs ge1 ge2) : match_genvs (add_globals (add_global ge1 (id1, g1)) al)\n  (add_globals (add_global ge2 (id1, g2)) bl).","proofString":"apply IHlist_forall2.\napply add_global_match; auto."},{"statement":"(id1 : ident) (g1 : globdef A V) (al : list (ident * globdef A V)) (g2 : globdef B W) (bl : list (ident * globdef B W)) (H2 : R g1 g2) (H0 : list_forall2\n  (fun (idg1 : ident * globdef A V) (idg2 : ident * globdef B W) =>\n   idg1#1 = idg2#1 /\\ R idg1#2 idg2#2) al bl) (IHlist_forall2 : forall (ge0 : t A V) (ge3 : t B W),\nmatch_genvs ge0 ge3 -> match_genvs (add_globals ge0 al) (add_globals ge3 bl)) (ge1 : t A V) (ge2 : t B W) (H1 : match_genvs ge1 ge2) : match_genvs (add_global ge1 (id1, g1)) (add_global ge2 (id1, g2)).","proofString":"apply add_global_match; auto."},{"statement":"match_genvs (match_globdef match_fundef match_varinfo ctx) \n  (globalenv p) (globalenv tp).","proofString":"apply add_globals_match.\napply progmatch.\nconstructor; simpl; intros; auto.\nrewrite ! PTree.gempty.\nconstructor."},{"statement":"list_forall2\n  (fun (idg1 : ident * globdef F1 V1) (idg2 : ident * globdef F2 V2) =>\n   idg1#1 = idg2#1 /\\\n   match_globdef match_fundef match_varinfo ctx idg1#2 idg2#2) \n  (prog_defs p) (prog_defs tp).","proofString":"apply progmatch."},{"statement":"match_genvs (match_globdef match_fundef match_varinfo ctx)\n  (empty_genv F1 V1 (prog_public p)) (empty_genv F2 V2 (prog_public tp)).","proofString":"constructor; simpl; intros; auto.\nrewrite ! PTree.gempty.\nconstructor."},{"statement":"(b : positive) : option_rel (match_globdef match_fundef match_varinfo ctx)\n  (PTree.empty (globdef F1 V1)) ! b (PTree.empty (globdef F2 V2)) ! b.","proofString":"rewrite ! PTree.gempty.\nconstructor."},{"statement":"(b : positive) : option_rel (match_globdef match_fundef match_varinfo ctx) None None.","proofString":"constructor."},{"statement":"(b : block) (g : globdef F1 V1) (H : find_def (globalenv p) b = Some g) : exists tg : globdef F2 V2,\n  find_def (globalenv tp) b = Some tg /\\\n  match_globdef match_fundef match_varinfo ctx g tg.","proofString":"generalize (find_def_match_2 b).\nrewrite H; intros R; inv R.\nexists y; auto."},{"statement":"(b : block) (g : globdef F1 V1) (H : find_def (globalenv p) b = Some g) : option_rel (match_globdef match_fundef match_varinfo ctx)\n  (find_def (globalenv p) b) (find_def (globalenv tp) b) ->\nexists tg : globdef F2 V2,\n  find_def (globalenv tp) b = Some tg /\\\n  match_globdef match_fundef match_varinfo ctx g tg.","proofString":"rewrite H; intros R; inv R.\nexists y; auto."},{"statement":"(b : block) (g : globdef F1 V1) (H : find_def (globalenv p) b = Some g) (y : globdef F2 V2) (H2 : match_globdef match_fundef match_varinfo ctx g y) (H1 : Some y = find_def (globalenv tp) b) : exists tg : globdef F2 V2,\n  Some y = Some tg /\\ match_globdef match_fundef match_varinfo ctx g tg.","proofString":"exists y; auto."},{"statement":"(b : block) (f : F1) (H : find_funct_ptr (globalenv p) b = Some f) : exists (cunit : C) (tf : F2),\n  find_funct_ptr (globalenv tp) b = Some tf /\\\n  match_fundef cunit f tf /\\ linkorder cunit ctx.","proofString":"rewrite find_funct_ptr_iff in *.\napply find_def_match in H.\ndestruct H as (tg & P & Q).\ninv Q.\nexists ctx', f2; intuition auto.\napply find_funct_ptr_iff; auto."},{"statement":"(b : block) (f : F1) (H : find_def (globalenv p) b = Some (Gfun f)) : exists (cunit : C) (tf : F2),\n  find_funct_ptr (globalenv tp) b = Some tf /\\\n  match_fundef cunit f tf /\\ linkorder cunit ctx.","proofString":"apply find_def_match in H.\ndestruct H as (tg & P & Q).\ninv Q.\nexists ctx', f2; intuition auto.\napply find_funct_ptr_iff; auto."},{"statement":"(b : block) (f : F1) (H : exists tg : globdef F2 V2,\n  find_def (globalenv tp) b = Some tg /\\\n  match_globdef match_fundef match_varinfo ctx (Gfun f) tg) : exists (cunit : C) (tf : F2),\n  find_funct_ptr (globalenv tp) b = Some tf /\\\n  match_fundef cunit f tf /\\ linkorder cunit ctx.","proofString":"destruct H as (tg & P & Q).\ninv Q.\nexists ctx', f2; intuition auto.\napply find_funct_ptr_iff; auto."},{"statement":"(b : block) (f : F1) (tg : globdef F2 V2) (P : find_def (globalenv tp) b = Some tg) (Q : match_globdef match_fundef match_varinfo ctx (Gfun f) tg) : exists (cunit : C) (tf : F2),\n  find_funct_ptr (globalenv tp) b = Some tf /\\\n  match_fundef cunit f tf /\\ linkorder cunit ctx.","proofString":"inv Q.\nexists ctx', f2; intuition auto.\napply find_funct_ptr_iff; auto."},{"statement":"(b : block) (f : F1) (f2 : F2) (P : find_def (globalenv tp) b = Some (Gfun f2)) (ctx' : C) (H0 : linkorder ctx' ctx) (H1 : match_fundef ctx' f f2) : exists (cunit : C) (tf : F2),\n  find_funct_ptr (globalenv tp) b = Some tf /\\\n  match_fundef cunit f tf /\\ linkorder cunit ctx.","proofString":"exists ctx', f2; intuition auto.\napply find_funct_ptr_iff; auto."},{"statement":"(b : block) (f : F1) (f2 : F2) (P : find_def (globalenv tp) b = Some (Gfun f2)) (ctx' : C) (H0 : linkorder ctx' ctx) (H1 : match_fundef ctx' f f2) : find_funct_ptr (globalenv tp) b = Some f2.","proofString":"apply find_funct_ptr_iff; auto."},{"statement":"(v : val) (f : F1) (H : find_funct (globalenv p) v = Some f) : exists (cunit : C) (tf : F2),\n  find_funct (globalenv tp) v = Some tf /\\\n  match_fundef cunit f tf /\\ linkorder cunit ctx.","proofString":"exploit find_funct_inv; eauto.\nintros [b EQ].\nsubst v.\nrewrite find_funct_find_funct_ptr in H.\nrewrite find_funct_find_funct_ptr.\napply find_funct_ptr_match.\nauto."},{"statement":"(v : val) (f : F1) (H : find_funct (globalenv p) v = Some f) : (exists b : block, v = Vptr b Ptrofs.zero) ->\nexists (cunit : C) (tf : F2),\n  find_funct (globalenv tp) v = Some tf /\\\n  match_fundef cunit f tf /\\ linkorder cunit ctx.","proofString":"intros [b EQ].\nsubst v.\nrewrite find_funct_find_funct_ptr in H.\nrewrite find_funct_find_funct_ptr.\napply find_funct_ptr_match.\nauto."},{"statement":"(v : val) (f : F1) (H : find_funct (globalenv p) v = Some f) (b : block) (EQ : v = Vptr b Ptrofs.zero) : exists (cunit : C) (tf : F2),\n  find_funct (globalenv tp) v = Some tf /\\\n  match_fundef cunit f tf /\\ linkorder cunit ctx.","proofString":"subst v.\nrewrite find_funct_find_funct_ptr in H.\nrewrite find_funct_find_funct_ptr.\napply find_funct_ptr_match.\nauto."},{"statement":"(f : F1) (b : block) (H : find_funct (globalenv p) (Vptr b Ptrofs.zero) = Some f) : exists (cunit : C) (tf : F2),\n  find_funct (globalenv tp) (Vptr b Ptrofs.zero) = Some tf /\\\n  match_fundef cunit f tf /\\ linkorder cunit ctx.","proofString":"rewrite find_funct_find_funct_ptr in H.\nrewrite find_funct_find_funct_ptr.\napply find_funct_ptr_match.\nauto."},{"statement":"(f : F1) (b : block) (H : find_funct_ptr (globalenv p) b = Some f) : exists (cunit : C) (tf : F2),\n  find_funct (globalenv tp) (Vptr b Ptrofs.zero) = Some tf /\\\n  match_fundef cunit f tf /\\ linkorder cunit ctx.","proofString":"rewrite find_funct_find_funct_ptr.\napply find_funct_ptr_match.\nauto."},{"statement":"(f : F1) (b : block) (H : find_funct_ptr (globalenv p) b = Some f) : exists (cunit : C) (tf : F2),\n  find_funct_ptr (globalenv tp) b = Some tf /\\\n  match_fundef cunit f tf /\\ linkorder cunit ctx.","proofString":"apply find_funct_ptr_match.\nauto."},{"statement":"(f : F1) (b : block) (H : find_funct_ptr (globalenv p) b = Some f) : find_funct_ptr (globalenv p) b = Some f.","proofString":"auto."},{"statement":"(b : block) (v : globvar V1) (H : find_var_info (globalenv p) b = Some v) : exists tv : globvar V2,\n  find_var_info (globalenv tp) b = Some tv /\\\n  match_globvar match_varinfo v tv.","proofString":"rewrite find_var_info_iff in *.\napply find_def_match in H.\ndestruct H as (tg & P & Q).\ninv Q.\nexists v2; split; auto.\napply find_var_info_iff; auto."},{"statement":"(b : block) (v : globvar V1) (H : find_def (globalenv p) b = Some (Gvar v)) : exists tv : globvar V2,\n  find_var_info (globalenv tp) b = Some tv /\\\n  match_globvar match_varinfo v tv.","proofString":"apply find_def_match in H.\ndestruct H as (tg & P & Q).\ninv Q.\nexists v2; split; auto.\napply find_var_info_iff; auto."},{"statement":"(b : block) (v : globvar V1) (H : exists tg : globdef F2 V2,\n  find_def (globalenv tp) b = Some tg /\\\n  match_globdef match_fundef match_varinfo ctx (Gvar v) tg) : exists tv : globvar V2,\n  find_var_info (globalenv tp) b = Some tv /\\\n  match_globvar match_varinfo v tv.","proofString":"destruct H as (tg & P & Q).\ninv Q.\nexists v2; split; auto.\napply find_var_info_iff; auto."},{"statement":"(b : block) (v : globvar V1) (tg : globdef F2 V2) (P : find_def (globalenv tp) b = Some tg) (Q : match_globdef match_fundef match_varinfo ctx (Gvar v) tg) : exists tv : globvar V2,\n  find_var_info (globalenv tp) b = Some tv /\\\n  match_globvar match_varinfo v tv.","proofString":"inv Q.\nexists v2; split; auto.\napply find_var_info_iff; auto."},{"statement":"(b : block) (v : globvar V1) (v2 : globvar V2) (P : find_def (globalenv tp) b = Some (Gvar v2)) (H0 : match_globvar match_varinfo v v2) : exists tv : globvar V2,\n  find_var_info (globalenv tp) b = Some tv /\\\n  match_globvar match_varinfo v tv.","proofString":"exists v2; split; auto.\napply find_var_info_iff; auto."},{"statement":"(b : block) (v : globvar V1) (v2 : globvar V2) (P : find_def (globalenv tp) b = Some (Gvar v2)) (H0 : match_globvar match_varinfo v v2) : find_var_info (globalenv tp) b = Some v2.","proofString":"apply find_var_info_iff; auto."},{"statement":"(s : ident) : find_symbol (globalenv tp) s = find_symbol (globalenv p) s.","proofString":"destruct globalenvs_match.\napply mge_symb0."},{"statement":"(s : ident) (mge_next0 : genv_next (globalenv tp) = genv_next (globalenv p)) (mge_symb0 : forall id : positive,\n(genv_symb (globalenv tp)) ! id = (genv_symb (globalenv p)) ! id) (mge_defs0 : forall b : positive,\noption_rel (match_globdef match_fundef match_varinfo ctx)\n  (genv_defs (globalenv p)) ! b (genv_defs (globalenv tp)) ! b) : find_symbol (globalenv tp) s = find_symbol (globalenv p) s.","proofString":"apply mge_symb0."},{"statement":"(forall id : ident,\n find_symbol (globalenv tp) id = find_symbol (globalenv p) id) /\\\n(forall id : ident,\n public_symbol (globalenv tp) id = public_symbol (globalenv p) id) /\\\n(forall b : block,\n block_is_volatile (globalenv tp) b = block_is_volatile (globalenv p) b).","proofString":"repeat split.\napply find_symbol_match.\nintros.\nunfold public_symbol.\nrewrite find_symbol_match.\nrewrite ! globalenv_public.\ndestruct progmatch as (P & Q & R).\nrewrite R.\nauto.\nintros.\nunfold block_is_volatile.\ndestruct globalenvs_match as [P Q R].\nspecialize (R b).\nunfold find_var_info, find_def.\ninv R; auto.\ninv H1; auto.\ninv H2; auto."},{"statement":"forall id : ident,\nfind_symbol (globalenv tp) id = find_symbol (globalenv p) id.","proofString":"apply find_symbol_match."},{"statement":"forall id : ident,\npublic_symbol (globalenv tp) id = public_symbol (globalenv p) id.","proofString":"intros.\nunfold public_symbol.\nrewrite find_symbol_match.\nrewrite ! globalenv_public.\ndestruct progmatch as (P & Q & R).\nrewrite R.\nauto."},{"statement":"(id : ident) : public_symbol (globalenv tp) id = public_symbol (globalenv p) id.","proofString":"unfold public_symbol.\nrewrite find_symbol_match.\nrewrite ! globalenv_public.\ndestruct progmatch as (P & Q & R).\nrewrite R.\nauto."},{"statement":"forall b : block,\nblock_is_volatile (globalenv tp) b = block_is_volatile (globalenv p) b.","proofString":"intros.\nunfold block_is_volatile.\ndestruct globalenvs_match as [P Q R].\nspecialize (R b).\nunfold find_var_info, find_def.\ninv R; auto.\ninv H1; auto.\ninv H2; auto."},{"statement":"(b : block) : block_is_volatile (globalenv tp) b = block_is_volatile (globalenv p) b.","proofString":"unfold block_is_volatile.\ndestruct globalenvs_match as [P Q R].\nspecialize (R b).\nunfold find_var_info, find_def.\ninv R; auto.\ninv H1; auto.\ninv H2; auto."},{"statement":"(b : block) : match find_var_info (globalenv tp) b with\n| Some gv => gvar_volatile gv\n| None => false\nend =\nmatch find_var_info (globalenv p) b with\n| Some gv => gvar_volatile gv\n| None => false\nend.","proofString":"destruct globalenvs_match as [P Q R].\nspecialize (R b).\nunfold find_var_info, find_def.\ninv R; auto.\ninv H1; auto.\ninv H2; auto."},{"statement":"(b : block) (P : genv_next (globalenv tp) = genv_next (globalenv p)) (Q : forall id : positive,\n(genv_symb (globalenv tp)) ! id = (genv_symb (globalenv p)) ! id) (R : forall b0 : positive,\noption_rel (match_globdef match_fundef match_varinfo ctx)\n  (genv_defs (globalenv p)) ! b0 (genv_defs (globalenv tp)) ! b0) : match find_var_info (globalenv tp) b with\n| Some gv => gvar_volatile gv\n| None => false\nend =\nmatch find_var_info (globalenv p) b with\n| Some gv => gvar_volatile gv\n| None => false\nend.","proofString":"specialize (R b).\nunfold find_var_info, find_def.\ninv R; auto.\ninv H1; auto.\ninv H2; auto."},{"statement":"(b : block) (P : genv_next (globalenv tp) = genv_next (globalenv p)) (Q : forall id : positive,\n(genv_symb (globalenv tp)) ! id = (genv_symb (globalenv p)) ! id) (R : option_rel (match_globdef match_fundef match_varinfo ctx)\n  (genv_defs (globalenv p)) ! b (genv_defs (globalenv tp)) ! b) : match find_var_info (globalenv tp) b with\n| Some gv => gvar_volatile gv\n| None => false\nend =\nmatch find_var_info (globalenv p) b with\n| Some gv => gvar_volatile gv\n| None => false\nend.","proofString":"unfold find_var_info, find_def.\ninv R; auto.\ninv H1; auto.\ninv H2; auto."},{"statement":"(b : block) (P : genv_next (globalenv tp) = genv_next (globalenv p)) (Q : forall id : positive,\n(genv_symb (globalenv tp)) ! id = (genv_symb (globalenv p)) ! id) (R : option_rel (match_globdef match_fundef match_varinfo ctx)\n  (genv_defs (globalenv p)) ! b (genv_defs (globalenv tp)) ! b) : match\n  match (genv_defs (globalenv tp)) ! b with\n  | Some (Gvar v) => Some v\n  | _ => None\n  end\nwith\n| Some gv => gvar_volatile gv\n| None => false\nend =\nmatch\n  match (genv_defs (globalenv p)) ! b with\n  | Some (Gvar v) => Some v\n  | _ => None\n  end\nwith\n| Some gv => gvar_volatile gv\n| None => false\nend.","proofString":"inv R; auto.\ninv H1; auto.\ninv H2; auto."},{"statement":"(b : block) (P : genv_next (globalenv tp) = genv_next (globalenv p)) (Q : forall id : positive,\n(genv_symb (globalenv tp)) ! id = (genv_symb (globalenv p)) ! id) (x : globdef F1 V1) (y : globdef F2 V2) (H1 : match_globdef match_fundef match_varinfo ctx x y) (H : Some x = (genv_defs (globalenv p)) ! b) (H0 : Some y = (genv_defs (globalenv tp)) ! b) : match match y with\n      | Gfun _ => None\n      | Gvar v => Some v\n      end with\n| Some gv => gvar_volatile gv\n| None => false\nend =\nmatch match x with\n      | Gfun _ => None\n      | Gvar v => Some v\n      end with\n| Some gv => gvar_volatile gv\n| None => false\nend.","proofString":"inv H1; auto.\ninv H2; auto."},{"statement":"(b : block) (P : genv_next (globalenv tp) = genv_next (globalenv p)) (Q : forall id : positive,\n(genv_symb (globalenv tp)) ! id = (genv_symb (globalenv p)) ! id) (v1 : globvar V1) (H : Some (Gvar v1) = (genv_defs (globalenv p)) ! b) (v2 : globvar V2) (H0 : Some (Gvar v2) = (genv_defs (globalenv tp)) ! b) (H2 : match_globvar match_varinfo v1 v2) : gvar_volatile v2 = gvar_volatile v1.","proofString":"inv H2; auto."},{"statement":"(m : mem) (b : block) (ofs : Z) (m' : mem) (H : Some m = Some m') : Some m = Some m'.","proofString":"auto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\nstore_init_data_list (globalenv p) m0 b0 ofs0 idl = Some m'0 ->\nstore_init_data_list (globalenv tp) m0 b0 ofs0 idl = Some m'0) (m : mem) (b : block) (ofs : Z) (m' : mem) (H : match store_init_data (globalenv p) m b ofs a with\n| Some m'0 =>\n    store_init_data_list (globalenv p) m'0 b (ofs + init_data_size a) idl\n| None => None\nend = Some m') : match store_init_data (globalenv tp) m b ofs a with\n| Some m'0 =>\n    store_init_data_list (globalenv tp) m'0 b (ofs + init_data_size a) idl\n| None => None\nend = Some m'.","proofString":"destruct (store_init_data (globalenv p) m b ofs a) as [m1|] eqn:S; try discriminate.\nassert (X: store_init_data (globalenv tp) m b ofs a = Some m1).\ndestruct a; auto.\nsimpl; rewrite find_symbol_match; auto.\nrewrite X.\nauto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\nstore_init_data_list (globalenv p) m0 b0 ofs0 idl = Some m'0 ->\nstore_init_data_list (globalenv tp) m0 b0 ofs0 idl = Some m'0) (m : mem) (b : block) (ofs : Z) (m' m1 : mem) (S : store_init_data (globalenv p) m b ofs a = Some m1) (H : store_init_data_list (globalenv p) m1 b (ofs + init_data_size a) idl =\nSome m') : match store_init_data (globalenv tp) m b ofs a with\n| Some m'0 =>\n    store_init_data_list (globalenv tp) m'0 b (ofs + init_data_size a) idl\n| None => None\nend = Some m'.","proofString":"assert (X: store_init_data (globalenv tp) m b ofs a = Some m1).\ndestruct a; auto.\nsimpl; rewrite find_symbol_match; auto.\nrewrite X.\nauto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\nstore_init_data_list (globalenv p) m0 b0 ofs0 idl = Some m'0 ->\nstore_init_data_list (globalenv tp) m0 b0 ofs0 idl = Some m'0) (m : mem) (b : block) (ofs : Z) (m' m1 : mem) (S : store_init_data (globalenv p) m b ofs a = Some m1) (H : store_init_data_list (globalenv p) m1 b (ofs + init_data_size a) idl =\nSome m') : store_init_data (globalenv tp) m b ofs a = Some m1.","proofString":"destruct a; auto.\nsimpl; rewrite find_symbol_match; auto."},{"statement":"(i : ident) (i0 : ptrofs) (idl : list init_data) (IHidl : forall (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\nstore_init_data_list (globalenv p) m0 b0 ofs0 idl = Some m'0 ->\nstore_init_data_list (globalenv tp) m0 b0 ofs0 idl = Some m'0) (m : mem) (b : block) (ofs : Z) (m' m1 : mem) (S : store_init_data (globalenv p) m b ofs (Init_addrof i i0) = Some m1) (H : store_init_data_list (globalenv p) m1 b\n  (ofs + init_data_size (Init_addrof i i0)) idl = \nSome m') : store_init_data (globalenv tp) m b ofs (Init_addrof i i0) = Some m1.","proofString":"simpl; rewrite find_symbol_match; auto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\nstore_init_data_list (globalenv p) m0 b0 ofs0 idl = Some m'0 ->\nstore_init_data_list (globalenv tp) m0 b0 ofs0 idl = Some m'0) (m : mem) (b : block) (ofs : Z) (m' m1 : mem) (S : store_init_data (globalenv p) m b ofs a = Some m1) (H : store_init_data_list (globalenv p) m1 b (ofs + init_data_size a) idl =\nSome m') (X : store_init_data (globalenv tp) m b ofs a = Some m1) : match store_init_data (globalenv tp) m b ofs a with\n| Some m'0 =>\n    store_init_data_list (globalenv tp) m'0 b (ofs + init_data_size a) idl\n| None => None\nend = Some m'.","proofString":"rewrite X.\nauto."},{"statement":"(a : init_data) (idl : list init_data) (IHidl : forall (m0 : mem) (b0 : block) (ofs0 : Z) (m'0 : mem),\nstore_init_data_list (globalenv p) m0 b0 ofs0 idl = Some m'0 ->\nstore_init_data_list (globalenv tp) m0 b0 ofs0 idl = Some m'0) (m : mem) (b : block) (ofs : Z) (m' m1 : mem) (S : store_init_data (globalenv p) m b ofs a = Some m1) (H : store_init_data_list (globalenv p) m1 b (ofs + init_data_size a) idl =\nSome m') (X : store_init_data (globalenv tp) m b ofs a = Some m1) : store_init_data_list (globalenv tp) m1 b (ofs + init_data_size a) idl =\nSome m'.","proofString":"auto."},{"statement":"(m m' : mem) (H : Some m = Some m') : Some m = Some m'.","proofString":"auto."},{"statement":"(a1 : ident * globdef F1 V1) (al : list (ident * globdef F1 V1)) (b1 : ident * globdef F2 V2) (bl : list (ident * globdef F2 V2)) (H : match_ident_globdef match_fundef match_varinfo ctx a1 b1) (H0 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) al bl) (IHlist_forall2 : forall m0 m'0 : mem,\nalloc_globals (globalenv p) m0 al = Some m'0 ->\nalloc_globals (globalenv tp) m0 bl = Some m'0) (m m' : mem) (H1 : match alloc_global (globalenv p) m a1 with\n| Some m'0 => alloc_globals (globalenv p) m'0 al\n| None => None\nend = Some m') : match alloc_global (globalenv tp) m b1 with\n| Some m'0 => alloc_globals (globalenv tp) m'0 bl\n| None => None\nend = Some m'.","proofString":"destruct (alloc_global (globalenv p) m a1) as [m1|] eqn:?; try discriminate.\nassert (X: alloc_global (globalenv tp) m b1 = Some m1).\ndestruct a1 as [id1 g1]; destruct b1 as [id2 g2]; destruct H; simpl in *.\nsubst id2.\ninv H2.\nauto.\ninv H; simpl in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m2 b] eqn:?.\ndestruct (store_zeros m2 b 0 sz) as [m3|] eqn:?; try discriminate.\ndestruct (store_init_data_list (globalenv p) m3 b 0 init) as [m4|] eqn:?; try discriminate.\nerewrite store_init_data_list_match; eauto.\nrewrite X; eauto."},{"statement":"(a1 : ident * globdef F1 V1) (al : list (ident * globdef F1 V1)) (b1 : ident * globdef F2 V2) (bl : list (ident * globdef F2 V2)) (H : match_ident_globdef match_fundef match_varinfo ctx a1 b1) (H0 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) al bl) (IHlist_forall2 : forall m0 m'0 : mem,\nalloc_globals (globalenv p) m0 al = Some m'0 ->\nalloc_globals (globalenv tp) m0 bl = Some m'0) (m m' m1 : mem) (Heqo : alloc_global (globalenv p) m a1 = Some m1) (H1 : alloc_globals (globalenv p) m1 al = Some m') : match alloc_global (globalenv tp) m b1 with\n| Some m'0 => alloc_globals (globalenv tp) m'0 bl\n| None => None\nend = Some m'.","proofString":"assert (X: alloc_global (globalenv tp) m b1 = Some m1).\ndestruct a1 as [id1 g1]; destruct b1 as [id2 g2]; destruct H; simpl in *.\nsubst id2.\ninv H2.\nauto.\ninv H; simpl in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m2 b] eqn:?.\ndestruct (store_zeros m2 b 0 sz) as [m3|] eqn:?; try discriminate.\ndestruct (store_init_data_list (globalenv p) m3 b 0 init) as [m4|] eqn:?; try discriminate.\nerewrite store_init_data_list_match; eauto.\nrewrite X; eauto."},{"statement":"(a1 : ident * globdef F1 V1) (al : list (ident * globdef F1 V1)) (b1 : ident * globdef F2 V2) (bl : list (ident * globdef F2 V2)) (H : match_ident_globdef match_fundef match_varinfo ctx a1 b1) (H0 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) al bl) (IHlist_forall2 : forall m0 m'0 : mem,\nalloc_globals (globalenv p) m0 al = Some m'0 ->\nalloc_globals (globalenv tp) m0 bl = Some m'0) (m m' m1 : mem) (Heqo : alloc_global (globalenv p) m a1 = Some m1) (H1 : alloc_globals (globalenv p) m1 al = Some m') : alloc_global (globalenv tp) m b1 = Some m1.","proofString":"destruct a1 as [id1 g1]; destruct b1 as [id2 g2]; destruct H; simpl in *.\nsubst id2.\ninv H2.\nauto.\ninv H; simpl in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m2 b] eqn:?.\ndestruct (store_zeros m2 b 0 sz) as [m3|] eqn:?; try discriminate.\ndestruct (store_init_data_list (globalenv p) m3 b 0 init) as [m4|] eqn:?; try discriminate.\nerewrite store_init_data_list_match; eauto."},{"statement":"(id1 : ident) (g1 : globdef F1 V1) (al : list (ident * globdef F1 V1)) (id2 : ident) (g2 : globdef F2 V2) (bl : list (ident * globdef F2 V2)) (H : id1 = id2) (H2 : match_globdef match_fundef match_varinfo ctx g1 g2) (H0 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) al bl) (IHlist_forall2 : forall m0 m'0 : mem,\nalloc_globals (globalenv p) m0 al = Some m'0 ->\nalloc_globals (globalenv tp) m0 bl = Some m'0) (m m' m1 : mem) (Heqo : match g1 with\n| Gfun _ => let (m0, b) := Mem.alloc m 0 1 in Mem.drop_perm m0 b 0 1 Nonempty\n| Gvar v =>\n    let (m0, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n    match store_zeros m0 b 0 (init_data_list_size (gvar_init v)) with\n    | Some m2 =>\n        match store_init_data_list (globalenv p) m2 b 0 (gvar_init v) with\n        | Some m3 =>\n            Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n              (perm_globvar v)\n        | None => None\n        end\n    | None => None\n    end\nend = Some m1) (H1 : alloc_globals (globalenv p) m1 al = Some m') : match g2 with\n| Gfun _ => let (m0, b) := Mem.alloc m 0 1 in Mem.drop_perm m0 b 0 1 Nonempty\n| Gvar v =>\n    let (m0, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n    match store_zeros m0 b 0 (init_data_list_size (gvar_init v)) with\n    | Some m2 =>\n        match store_init_data_list (globalenv tp) m2 b 0 (gvar_init v) with\n        | Some m3 =>\n            Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n              (perm_globvar v)\n        | None => None\n        end\n    | None => None\n    end\nend = Some m1.","proofString":"subst id2.\ninv H2.\nauto.\ninv H; simpl in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m2 b] eqn:?.\ndestruct (store_zeros m2 b 0 sz) as [m3|] eqn:?; try discriminate.\ndestruct (store_init_data_list (globalenv p) m3 b 0 init) as [m4|] eqn:?; try discriminate.\nerewrite store_init_data_list_match; eauto."},{"statement":"(id1 : ident) (g1 : globdef F1 V1) (al : list (ident * globdef F1 V1)) (g2 : globdef F2 V2) (bl : list (ident * globdef F2 V2)) (H2 : match_globdef match_fundef match_varinfo ctx g1 g2) (H0 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) al bl) (IHlist_forall2 : forall m0 m'0 : mem,\nalloc_globals (globalenv p) m0 al = Some m'0 ->\nalloc_globals (globalenv tp) m0 bl = Some m'0) (m m' m1 : mem) (Heqo : match g1 with\n| Gfun _ => let (m0, b) := Mem.alloc m 0 1 in Mem.drop_perm m0 b 0 1 Nonempty\n| Gvar v =>\n    let (m0, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n    match store_zeros m0 b 0 (init_data_list_size (gvar_init v)) with\n    | Some m2 =>\n        match store_init_data_list (globalenv p) m2 b 0 (gvar_init v) with\n        | Some m3 =>\n            Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n              (perm_globvar v)\n        | None => None\n        end\n    | None => None\n    end\nend = Some m1) (H1 : alloc_globals (globalenv p) m1 al = Some m') : match g2 with\n| Gfun _ => let (m0, b) := Mem.alloc m 0 1 in Mem.drop_perm m0 b 0 1 Nonempty\n| Gvar v =>\n    let (m0, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v)) in\n    match store_zeros m0 b 0 (init_data_list_size (gvar_init v)) with\n    | Some m2 =>\n        match store_init_data_list (globalenv tp) m2 b 0 (gvar_init v) with\n        | Some m3 =>\n            Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v))\n              (perm_globvar v)\n        | None => None\n        end\n    | None => None\n    end\nend = Some m1.","proofString":"inv H2.\nauto.\ninv H; simpl in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m2 b] eqn:?.\ndestruct (store_zeros m2 b 0 sz) as [m3|] eqn:?; try discriminate.\ndestruct (store_init_data_list (globalenv p) m3 b 0 init) as [m4|] eqn:?; try discriminate.\nerewrite store_init_data_list_match; eauto."},{"statement":"(id1 : ident) (al : list (ident * globdef F1 V1)) (bl : list (ident * globdef F2 V2)) (H0 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) al bl) (IHlist_forall2 : forall m0 m'0 : mem,\nalloc_globals (globalenv p) m0 al = Some m'0 ->\nalloc_globals (globalenv tp) m0 bl = Some m'0) (m m' m1 : mem) (Heqo : (let (m0, b) := Mem.alloc m 0 1 in Mem.drop_perm m0 b 0 1 Nonempty) = Some m1) (H1 : alloc_globals (globalenv p) m1 al = Some m') (ctx' : C) (f1 : F1) (f2 : F2) (H : linkorder ctx' ctx) (H3 : match_fundef ctx' f1 f2) : (let (m0, b) := Mem.alloc m 0 1 in Mem.drop_perm m0 b 0 1 Nonempty) = Some m1.","proofString":"auto."},{"statement":"(id1 : ident) (al : list (ident * globdef F1 V1)) (bl : list (ident * globdef F2 V2)) (H0 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) al bl) (IHlist_forall2 : forall m0 m'0 : mem,\nalloc_globals (globalenv p) m0 al = Some m'0 ->\nalloc_globals (globalenv tp) m0 bl = Some m'0) (m m' m1 : mem) (v1 : globvar V1) (Heqo : (let (m0, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v1)) in\n match store_zeros m0 b 0 (init_data_list_size (gvar_init v1)) with\n | Some m2 =>\n     match store_init_data_list (globalenv p) m2 b 0 (gvar_init v1) with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v1))\n           (perm_globvar v1)\n     | None => None\n     end\n | None => None\n end) = Some m1) (H1 : alloc_globals (globalenv p) m1 al = Some m') (v2 : globvar V2) (H : match_globvar match_varinfo v1 v2) : (let (m0, b) := Mem.alloc m 0 (init_data_list_size (gvar_init v2)) in\n match store_zeros m0 b 0 (init_data_list_size (gvar_init v2)) with\n | Some m2 =>\n     match store_init_data_list (globalenv tp) m2 b 0 (gvar_init v2) with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size (gvar_init v2))\n           (perm_globvar v2)\n     | None => None\n     end\n | None => None\n end) = Some m1.","proofString":"inv H; simpl in *.\nset (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m2 b] eqn:?.\ndestruct (store_zeros m2 b 0 sz) as [m3|] eqn:?; try discriminate.\ndestruct (store_init_data_list (globalenv p) m3 b 0 init) as [m4|] eqn:?; try discriminate.\nerewrite store_init_data_list_match; eauto."},{"statement":"(id1 : ident) (al : list (ident * globdef F1 V1)) (bl : list (ident * globdef F2 V2)) (H0 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) al bl) (IHlist_forall2 : forall m0 m'0 : mem,\nalloc_globals (globalenv p) m0 al = Some m'0 ->\nalloc_globals (globalenv tp) m0 bl = Some m'0) (m m' m1 : mem) (i1 : V1) (init : list init_data) (ro vo : bool) (Heqo : (let (m0, b) := Mem.alloc m 0 (init_data_list_size init) in\n match store_zeros m0 b 0 (init_data_list_size init) with\n | Some m2 =>\n     match store_init_data_list (globalenv p) m2 b 0 init with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size init)\n           (perm_globvar\n              {|\n                gvar_info := i1;\n                gvar_init := init;\n                gvar_readonly := ro;\n                gvar_volatile := vo\n              |})\n     | None => None\n     end\n | None => None\n end) = Some m1) (H1 : alloc_globals (globalenv p) m1 al = Some m') (i2 : V2) (H2 : match_varinfo i1 i2) : (let (m0, b) := Mem.alloc m 0 (init_data_list_size init) in\n match store_zeros m0 b 0 (init_data_list_size init) with\n | Some m2 =>\n     match store_init_data_list (globalenv tp) m2 b 0 init with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 (init_data_list_size init)\n           (perm_globvar\n              {|\n                gvar_info := i2;\n                gvar_init := init;\n                gvar_readonly := ro;\n                gvar_volatile := vo\n              |})\n     | None => None\n     end\n | None => None\n end) = Some m1.","proofString":"set (sz := init_data_list_size init) in *.\ndestruct (Mem.alloc m 0 sz) as [m2 b] eqn:?.\ndestruct (store_zeros m2 b 0 sz) as [m3|] eqn:?; try discriminate.\ndestruct (store_init_data_list (globalenv p) m3 b 0 init) as [m4|] eqn:?; try discriminate.\nerewrite store_init_data_list_match; eauto."},{"statement":"(id1 : ident) (al : list (ident * globdef F1 V1)) (bl : list (ident * globdef F2 V2)) (H0 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) al bl) (IHlist_forall2 : forall m0 m'0 : mem,\nalloc_globals (globalenv p) m0 al = Some m'0 ->\nalloc_globals (globalenv tp) m0 bl = Some m'0) (m m' m1 : mem) (i1 : V1) (init : list init_data) (ro vo : bool) (sz : Z) (Heqo : (let (m0, b) := Mem.alloc m 0 sz in\n match store_zeros m0 b 0 sz with\n | Some m2 =>\n     match store_init_data_list (globalenv p) m2 b 0 init with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 sz\n           (perm_globvar\n              {|\n                gvar_info := i1;\n                gvar_init := init;\n                gvar_readonly := ro;\n                gvar_volatile := vo\n              |})\n     | None => None\n     end\n | None => None\n end) = Some m1) (H1 : alloc_globals (globalenv p) m1 al = Some m') (i2 : V2) (H2 : match_varinfo i1 i2) : (let (m0, b) := Mem.alloc m 0 sz in\n match store_zeros m0 b 0 sz with\n | Some m2 =>\n     match store_init_data_list (globalenv tp) m2 b 0 init with\n     | Some m3 =>\n         Mem.drop_perm m3 b 0 sz\n           (perm_globvar\n              {|\n                gvar_info := i2;\n                gvar_init := init;\n                gvar_readonly := ro;\n                gvar_volatile := vo\n              |})\n     | None => None\n     end\n | None => None\n end) = Some m1.","proofString":"destruct (Mem.alloc m 0 sz) as [m2 b] eqn:?.\ndestruct (store_zeros m2 b 0 sz) as [m3|] eqn:?; try discriminate.\ndestruct (store_init_data_list (globalenv p) m3 b 0 init) as [m4|] eqn:?; try discriminate.\nerewrite store_init_data_list_match; eauto."},{"statement":"(id1 : ident) (al : list (ident * globdef F1 V1)) (bl : list (ident * globdef F2 V2)) (H0 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) al bl) (IHlist_forall2 : forall m0 m'0 : mem,\nalloc_globals (globalenv p) m0 al = Some m'0 ->\nalloc_globals (globalenv tp) m0 bl = Some m'0) (m m' m1 : mem) (i1 : V1) (init : list init_data) (ro vo : bool) (sz : Z) (m2 : Mem.mem') (b : block) (Heqp0 : Mem.alloc m 0 sz = (m2, b)) (Heqo : match store_zeros m2 b 0 sz with\n| Some m0 =>\n    match store_init_data_list (globalenv p) m0 b 0 init with\n    | Some m3 =>\n        Mem.drop_perm m3 b 0 sz\n          (perm_globvar\n             {|\n               gvar_info := i1;\n               gvar_init := init;\n               gvar_readonly := ro;\n               gvar_volatile := vo\n             |})\n    | None => None\n    end\n| None => None\nend = Some m1) (H1 : alloc_globals (globalenv p) m1 al = Some m') (i2 : V2) (H2 : match_varinfo i1 i2) : match store_zeros m2 b 0 sz with\n| Some m0 =>\n    match store_init_data_list (globalenv tp) m0 b 0 init with\n    | Some m3 =>\n        Mem.drop_perm m3 b 0 sz\n          (perm_globvar\n             {|\n               gvar_info := i2;\n               gvar_init := init;\n               gvar_readonly := ro;\n               gvar_volatile := vo\n             |})\n    | None => None\n    end\n| None => None\nend = Some m1.","proofString":"destruct (store_zeros m2 b 0 sz) as [m3|] eqn:?; try discriminate.\ndestruct (store_init_data_list (globalenv p) m3 b 0 init) as [m4|] eqn:?; try discriminate.\nerewrite store_init_data_list_match; eauto."},{"statement":"(id1 : ident) (al : list (ident * globdef F1 V1)) (bl : list (ident * globdef F2 V2)) (H0 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) al bl) (IHlist_forall2 : forall m0 m'0 : mem,\nalloc_globals (globalenv p) m0 al = Some m'0 ->\nalloc_globals (globalenv tp) m0 bl = Some m'0) (m m' m1 : mem) (i1 : V1) (init : list init_data) (ro vo : bool) (sz : Z) (m2 : Mem.mem') (b : block) (Heqp0 : Mem.alloc m 0 sz = (m2, b)) (m3 : mem) (Heqo0 : store_zeros m2 b 0 sz = Some m3) (Heqo : match store_init_data_list (globalenv p) m3 b 0 init with\n| Some m0 =>\n    Mem.drop_perm m0 b 0 sz\n      (perm_globvar\n         {|\n           gvar_info := i1;\n           gvar_init := init;\n           gvar_readonly := ro;\n           gvar_volatile := vo\n         |})\n| None => None\nend = Some m1) (H1 : alloc_globals (globalenv p) m1 al = Some m') (i2 : V2) (H2 : match_varinfo i1 i2) : match store_init_data_list (globalenv tp) m3 b 0 init with\n| Some m0 =>\n    Mem.drop_perm m0 b 0 sz\n      (perm_globvar\n         {|\n           gvar_info := i2;\n           gvar_init := init;\n           gvar_readonly := ro;\n           gvar_volatile := vo\n         |})\n| None => None\nend = Some m1.","proofString":"destruct (store_init_data_list (globalenv p) m3 b 0 init) as [m4|] eqn:?; try discriminate.\nerewrite store_init_data_list_match; eauto."},{"statement":"(id1 : ident) (al : list (ident * globdef F1 V1)) (bl : list (ident * globdef F2 V2)) (H0 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) al bl) (IHlist_forall2 : forall m0 m'0 : mem,\nalloc_globals (globalenv p) m0 al = Some m'0 ->\nalloc_globals (globalenv tp) m0 bl = Some m'0) (m m' m1 : mem) (i1 : V1) (init : list init_data) (ro vo : bool) (sz : Z) (m2 : Mem.mem') (b : block) (Heqp0 : Mem.alloc m 0 sz = (m2, b)) (m3 : mem) (Heqo0 : store_zeros m2 b 0 sz = Some m3) (m4 : mem) (Heqo1 : store_init_data_list (globalenv p) m3 b 0 init = Some m4) (Heqo : Mem.drop_perm m4 b 0 sz\n  (perm_globvar\n     {|\n       gvar_info := i1;\n       gvar_init := init;\n       gvar_readonly := ro;\n       gvar_volatile := vo\n     |}) = Some m1) (H1 : alloc_globals (globalenv p) m1 al = Some m') (i2 : V2) (H2 : match_varinfo i1 i2) : match store_init_data_list (globalenv tp) m3 b 0 init with\n| Some m0 =>\n    Mem.drop_perm m0 b 0 sz\n      (perm_globvar\n         {|\n           gvar_info := i2;\n           gvar_init := init;\n           gvar_readonly := ro;\n           gvar_volatile := vo\n         |})\n| None => None\nend = Some m1.","proofString":"erewrite store_init_data_list_match; eauto."},{"statement":"(a1 : ident * globdef F1 V1) (al : list (ident * globdef F1 V1)) (b1 : ident * globdef F2 V2) (bl : list (ident * globdef F2 V2)) (H : match_ident_globdef match_fundef match_varinfo ctx a1 b1) (H0 : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) al bl) (IHlist_forall2 : forall m0 m'0 : mem,\nalloc_globals (globalenv p) m0 al = Some m'0 ->\nalloc_globals (globalenv tp) m0 bl = Some m'0) (m m' m1 : mem) (Heqo : alloc_global (globalenv p) m a1 = Some m1) (H1 : alloc_globals (globalenv p) m1 al = Some m') (X : alloc_global (globalenv tp) m b1 = Some m1) : match alloc_global (globalenv tp) m b1 with\n| Some m'0 => alloc_globals (globalenv tp) m'0 bl\n| None => None\nend = Some m'.","proofString":"rewrite X; eauto."},{"statement":"(m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) : alloc_globals (globalenv tp) Mem.empty (prog_defs tp) = Some m.","proofString":"eapply alloc_globals_match; eauto.\napply progmatch."},{"statement":"(m : mem) (H : alloc_globals (globalenv p) Mem.empty (prog_defs p) = Some m) : list_forall2 (match_ident_globdef match_fundef match_varinfo ctx)\n  (prog_defs p) (prog_defs tp).","proofString":"apply progmatch."},{"statement":"(b : block) (f : A) (H : find_funct_ptr (globalenv p) b = Some f) : exists tf : B, find_funct_ptr (globalenv tp) b = Some tf /\\ transf f = OK tf.","proofString":"exploit (find_funct_ptr_match progmatch); eauto.\nintros (cu & tf & P & Q & R); exists tf; auto."},{"statement":"(b : block) (f : A) (H : find_funct_ptr (globalenv p) b = Some f) : (exists (cunit : program A V) (tf : B),\n   find_funct_ptr (globalenv tp) b = Some tf /\\\n   transf f = OK tf /\\ linkorder cunit p) ->\nexists tf : B, find_funct_ptr (globalenv tp) b = Some tf /\\ transf f = OK tf.","proofString":"intros (cu & tf & P & Q & R); exists tf; auto."},{"statement":"(v : val) (f : A) (H : find_funct (globalenv p) v = Some f) : exists tf : B, find_funct (globalenv tp) v = Some tf /\\ transf f = OK tf.","proofString":"exploit (find_funct_match progmatch); eauto.\nintros (cu & tf & P & Q & R); exists tf; auto."},{"statement":"(v : val) (f : A) (H : find_funct (globalenv p) v = Some f) : (exists (cunit : program A V) (tf : B),\n   find_funct (globalenv tp) v = Some tf /\\\n   transf f = OK tf /\\ linkorder cunit p) ->\nexists tf : B, find_funct (globalenv tp) v = Some tf /\\ transf f = OK tf.","proofString":"intros (cu & tf & P & Q & R); exists tf; auto."},{"statement":"(s : ident) : find_symbol (globalenv tp) s = find_symbol (globalenv p) s.","proofString":"eapply (find_symbol_match progmatch)."},{"statement":"Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).","proofString":"eapply (senv_match progmatch)."},{"statement":"(b : block) (f : A) (H : find_funct_ptr (globalenv p) b = Some f) : find_funct_ptr (globalenv tp) b = Some (transf f).","proofString":"exploit (find_funct_ptr_match progmatch); eauto.\nintros (cu & tf & P & Q & R).\ncongruence."},{"statement":"(b : block) (f : A) (H : find_funct_ptr (globalenv p) b = Some f) : (exists (cunit : program A V) (tf : B),\n   find_funct_ptr (globalenv tp) b = Some tf /\\\n   tf = transf f /\\ linkorder cunit p) ->\nfind_funct_ptr (globalenv tp) b = Some (transf f).","proofString":"intros (cu & tf & P & Q & R).\ncongruence."},{"statement":"(b : block) (f : A) (H : find_funct_ptr (globalenv p) b = Some f) (cu : program A V) (tf : B) (P : find_funct_ptr (globalenv tp) b = Some tf) (Q : tf = transf f) (R : linkorder cu p) : find_funct_ptr (globalenv tp) b = Some (transf f).","proofString":"congruence."},{"statement":"(v : val) (f : A) (H : find_funct (globalenv p) v = Some f) : find_funct (globalenv tp) v = Some (transf f).","proofString":"exploit (find_funct_match progmatch); eauto.\nintros (cu & tf & P & Q & R).\ncongruence."},{"statement":"(v : val) (f : A) (H : find_funct (globalenv p) v = Some f) : (exists (cunit : program A V) (tf : B),\n   find_funct (globalenv tp) v = Some tf /\\\n   tf = transf f /\\ linkorder cunit p) ->\nfind_funct (globalenv tp) v = Some (transf f).","proofString":"intros (cu & tf & P & Q & R).\ncongruence."},{"statement":"(v : val) (f : A) (H : find_funct (globalenv p) v = Some f) (cu : program A V) (tf : B) (P : find_funct (globalenv tp) v = Some tf) (Q : tf = transf f) (R : linkorder cu p) : find_funct (globalenv tp) v = Some (transf f).","proofString":"congruence."},{"statement":"(s : ident) : find_symbol (globalenv tp) s = find_symbol (globalenv p) s.","proofString":"eapply (find_symbol_match progmatch)."},{"statement":"Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).","proofString":"eapply (senv_match progmatch)."}]}