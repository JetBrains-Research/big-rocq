{"filePath":"/Users/andrei/MCS_Projects/coqPilotOther/CompCert/aarch64/Asmgenproof.v","fileSamples":[{"statement":"(p : Mach.program) (tp : program) (H : transf_program p = OK tp) : match_prog p tp.","proofString":"eapply match_transform_partial_program; eauto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"exploit functions_translated; eauto.\nintros [tf' [A B]].\nmonadInv B.\nrewrite H0 in EQ; inv EQ; auto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) : (exists tf0 : fundef,\n   Genv.find_funct_ptr tge fb = Some tf0 /\\\n   transf_fundef (Internal f) = OK tf0) ->\nGenv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"intros [tf' [A B]].\nmonadInv B.\nrewrite H0 in EQ; inv EQ; auto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) (tf' : fundef) (A : Genv.find_funct_ptr tge fb = Some tf') (B : transf_fundef (Internal f) = OK tf') : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"monadInv B.\nrewrite H0 in EQ; inv EQ; auto."},{"statement":"(fb : block) (f : Mach.function) (tf : function) (H : Genv.find_funct_ptr ge fb = Some (Internal f)) (H0 : transf_function f = OK tf) (x : function) (A : Genv.find_funct_ptr tge fb = Some (Internal x)) (EQ : transf_function f = OK x) : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"rewrite H0 in EQ; inv EQ; auto."},{"statement":"(f : Mach.function) (tf : function) (H : transf_function f = OK tf) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"monadInv H.\ndestruct (zlt Ptrofs.max_unsigned (list_length_z x.(fn_code))); inv EQ0.\nlia."},{"statement":"(f : Mach.function) (tf x : function) (EQ : transl_function f = OK x) (EQ0 : (if zlt Ptrofs.max_unsigned (list_length_z (fn_code x))\n then Error (msg \"code size exceeded\")\n else OK x) = OK tf) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"destruct (zlt Ptrofs.max_unsigned (list_length_z x.(fn_code))); inv EQ0.\nlia."},{"statement":"(f : Mach.function) (tf : function) (g : Ptrofs.max_unsigned >= list_length_z (fn_code tf)) (EQ : transl_function f = OK tf) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H : transl_code_at_pc ge (rs PC) fb f c ep tf tc) (H0 : exec_straight tge tf tc rs m c' rs' m') : plus step tge (State rs m) E0 (State rs' m').","proofString":"inv H.\neapply exec_straight_steps_1; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC) : plus step tge (State rs m) E0 (State rs' m').","proofString":"eapply exec_straight_steps_1; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"eapply transf_function_no_overflow; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc c' : code) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : exec_straight tge tf tc rs m c' rs' m') (ofs : ptrofs) (H2 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H3 : transf_function f = OK tf) (H4 : transl_code f c ep = OK tc) (H5 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H1 : Vptr fb ofs = rs PC) : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"eapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H : transl_code_at_pc ge (rs PC) fb f c ep tf tc) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') : transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","proofString":"inv H.\nexploit exec_straight_steps_2; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto.\nintros [ofs' [PC' CT']].\nrewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","proofString":"exploit exec_straight_steps_2; eauto.\neapply transf_function_no_overflow; eauto.\neapply functions_transl; eauto.\nintros [ofs' [PC' CT']].\nrewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned.","proofString":"eapply transf_function_no_overflow; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : Genv.find_funct_ptr tge fb = Some (Internal tf).","proofString":"eapply functions_transl; eauto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) : (exists ofs' : ptrofs,\n   rs' PC = Vptr fb ofs' /\\ code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc') ->\ntransl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","proofString":"intros [ofs' [PC' CT']].\nrewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) (ofs' : ptrofs) (PC' : rs' PC = Vptr fb ofs') (CT' : code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc') : transl_code_at_pc ge (rs' PC) fb f c' ep' tf tc'.","proofString":"rewrite PC'.\nconstructor; auto."},{"statement":"(fb : block) (f : Mach.function) (c : Mach.code) (ep : bool) (tf : function) (tc : code) (c' : list Mach.instruction) (ep' : bool) (tc' : list instruction) (rs : preg -> val) (m : mem) (rs' : regset) (m' : mem) (H0 : transl_code f c' ep' = OK tc') (H1 : exec_straight tge tf tc rs m tc' rs' m') (ofs : ptrofs) (H3 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H4 : transf_function f = OK tf) (H5 : transl_code f c ep = OK tc) (H6 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H2 : Vptr fb ofs = rs PC) (ofs' : ptrofs) (PC' : rs' PC = Vptr fb ofs') (CT' : code_tail (Ptrofs.unsigned ofs') (fn_code tf) tc') : transl_code_at_pc ge (Vptr fb ofs') fb f c' ep' tf tc'.","proofString":"constructor; auto."},{"statement":"(sz : isize) (rd : ireg) (n1 p1 : Z) (l : list (Z * Z)) (k : code) : tail_nolabel k (loadimm_k sz rd l k).","proofString":"induction l as [ | [n p] l]; simpl; TailNoLabel."},{"statement":"(sz : isize) (rd : ireg) (n1 p1 : Z) (l : list (Z * Z)) (k : code) : tail_nolabel k (loadimm_k sz rd (negate_decomposition l) k).","proofString":"induction l as [ | [n p] l]; simpl; TailNoLabel."},{"statement":"(sz : isize) (rd : ireg) (n : Z) (k : code) : tail_nolabel k\n  (if\n    (Datatypes.length (decompose_int match sz with\n                                     | W => 2\n                                     | X => 4\n                                     end n 0) <=?\n     Datatypes.length\n       (decompose_int match sz with\n                      | W => 2\n                      | X => 4\n                      end (Z.lnot n) 0))%nat\n   then\n    loadimm_z sz rd (decompose_int match sz with\n                                   | W => 2\n                                   | X => 4\n                                   end n 0) k\n   else\n    loadimm_n sz rd\n      (decompose_int match sz with\n                     | W => 2\n                     | X => 4\n                     end (Z.lnot n) 0) k).","proofString":"destruct Nat.leb; [apply loadimm_z_label|apply loadimm_n_label]."},{"statement":"(r : ireg) (n : int) (k : code) : tail_nolabel k\n  (if is_logical_imm32 n\n   then Porrimm W r XZR (Int.unsigned n) :: k\n   else loadimm W r (Int.unsigned n) k).","proofString":"destruct (is_logical_imm32 n); TailNoLabel."},{"statement":"(r : ireg) (n : int64) (k : code) : tail_nolabel k\n  (if is_logical_imm64 n\n   then Porrimm X r XZR (Int64.unsigned n) :: k\n   else loadimm X r (Int64.unsigned n) k).","proofString":"destruct (is_logical_imm64 n); TailNoLabel."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (rd r1 : iregsp) (n : Z) (k : code) (H : forall (rd0 r0 : iregsp) (n0 : Z), nolabel (insn rd0 r0 n0)) : tail_nolabel k\n  (if n - Zbits.Zzero_ext 12 n =? 0\n   then insn rd r1 (Zbits.Zzero_ext 12 n) :: k\n   else\n    if Zbits.Zzero_ext 12 n =? 0\n    then insn rd r1 (n - Zbits.Zzero_ext 12 n) :: k\n    else\n     insn rd r1 (n - Zbits.Zzero_ext 12 n)\n     :: insn rd rd (Zbits.Zzero_ext 12 n) :: k).","proofString":"destruct Z.eqb.\nTailNoLabel.\ndestruct Z.eqb; TailNoLabel."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (rd r1 : iregsp) (n : Z) (k : code) (H : forall (rd0 r0 : iregsp) (n0 : Z), nolabel (insn rd0 r0 n0)) : tail_nolabel k (insn rd r1 (Zbits.Zzero_ext 12 n) :: k).","proofString":"TailNoLabel."},{"statement":"(insn : iregsp -> iregsp -> Z -> instruction) (rd r1 : iregsp) (n : Z) (k : code) (H : forall (rd0 r0 : iregsp) (n0 : Z), nolabel (insn rd0 r0 n0)) : tail_nolabel k\n  (if Zbits.Zzero_ext 12 n =? 0\n   then insn rd r1 (n - Zbits.Zzero_ext 12 n) :: k\n   else\n    insn rd r1 (n - Zbits.Zzero_ext 12 n)\n    :: insn rd rd (Zbits.Zzero_ext 12 n) :: k).","proofString":"destruct Z.eqb; TailNoLabel."},{"statement":"(rd r1 : ireg) (n : int) (k : code) : tail_nolabel k\n  (if Int.eq n (Int.zero_ext 24 n)\n   then Asmgen.addimm_aux (Paddimm W) rd r1 (Int.unsigned n) k\n   else\n    if Int.eq (Int.neg n) (Int.zero_ext 24 (Int.neg n))\n    then Asmgen.addimm_aux (Psubimm W) rd r1 (Int.unsigned (Int.neg n)) k\n    else\n     if Int.lt n Int.zero\n     then loadimm32 X16 (Int.neg n) (Psub W rd r1 X16 SOnone :: k)\n     else loadimm32 X16 n (Padd W rd r1 X16 SOnone :: k)).","proofString":"destruct Int.eq.\napply addimm_aux; intros; red; auto.\ndestruct Int.eq.\napply addimm_aux; intros; red; auto.\ndestruct Int.lt; eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(rd r1 : ireg) (n : int) (k : code) : tail_nolabel k (Asmgen.addimm_aux (Paddimm W) rd r1 (Int.unsigned n) k).","proofString":"apply addimm_aux; intros; red; auto."},{"statement":"(rd r1 : ireg) (n : int) (k : code) : tail_nolabel k\n  (if Int.eq (Int.neg n) (Int.zero_ext 24 (Int.neg n))\n   then Asmgen.addimm_aux (Psubimm W) rd r1 (Int.unsigned (Int.neg n)) k\n   else\n    if Int.lt n Int.zero\n    then loadimm32 X16 (Int.neg n) (Psub W rd r1 X16 SOnone :: k)\n    else loadimm32 X16 n (Padd W rd r1 X16 SOnone :: k)).","proofString":"destruct Int.eq.\napply addimm_aux; intros; red; auto.\ndestruct Int.lt; eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(rd r1 : ireg) (n : int) (k : code) : tail_nolabel k\n  (Asmgen.addimm_aux (Psubimm W) rd r1 (Int.unsigned (Int.neg n)) k).","proofString":"apply addimm_aux; intros; red; auto."},{"statement":"(rd r1 : ireg) (n : int) (k : code) : tail_nolabel k\n  (if Int.lt n Int.zero\n   then loadimm32 X16 (Int.neg n) (Psub W rd r1 X16 SOnone :: k)\n   else loadimm32 X16 n (Padd W rd r1 X16 SOnone :: k)).","proofString":"destruct Int.lt; eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) : tail_nolabel k\n  (if Int64.eq n (Int64.zero_ext 24 n)\n   then Asmgen.addimm_aux (Paddimm X) rd r1 (Int64.unsigned n) k\n   else\n    if Int64.eq (Int64.neg n) (Int64.zero_ext 24 (Int64.neg n))\n    then Asmgen.addimm_aux (Psubimm X) rd r1 (Int64.unsigned (Int64.neg n)) k\n    else\n     if Int64.lt n Int64.zero\n     then\n      loadimm64 X16 (Int64.neg n) (Psubext rd r1 X16 (EOuxtx Int.zero) :: k)\n     else loadimm64 X16 n (Paddext rd r1 X16 (EOuxtx Int.zero) :: k)).","proofString":"destruct Int64.eq.\napply addimm_aux; intros; red; auto.\ndestruct Int64.eq.\napply addimm_aux; intros; red; auto.\ndestruct Int64.lt; eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) : tail_nolabel k (Asmgen.addimm_aux (Paddimm X) rd r1 (Int64.unsigned n) k).","proofString":"apply addimm_aux; intros; red; auto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) : tail_nolabel k\n  (if Int64.eq (Int64.neg n) (Int64.zero_ext 24 (Int64.neg n))\n   then Asmgen.addimm_aux (Psubimm X) rd r1 (Int64.unsigned (Int64.neg n)) k\n   else\n    if Int64.lt n Int64.zero\n    then\n     loadimm64 X16 (Int64.neg n) (Psubext rd r1 X16 (EOuxtx Int.zero) :: k)\n    else loadimm64 X16 n (Paddext rd r1 X16 (EOuxtx Int.zero) :: k)).","proofString":"destruct Int64.eq.\napply addimm_aux; intros; red; auto.\ndestruct Int64.lt; eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) : tail_nolabel k\n  (Asmgen.addimm_aux (Psubimm X) rd r1 (Int64.unsigned (Int64.neg n)) k).","proofString":"apply addimm_aux; intros; red; auto."},{"statement":"(rd r1 : iregsp) (n : int64) (k : code) : tail_nolabel k\n  (if Int64.lt n Int64.zero\n   then\n    loadimm64 X16 (Int64.neg n) (Psubext rd r1 X16 (EOuxtx Int.zero) :: k)\n   else loadimm64 X16 n (Paddext rd r1 X16 (EOuxtx Int.zero) :: k)).","proofString":"destruct Int64.lt; eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (rd r1 : ireg) (n : int) (k : code) (H : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z), nolabel (insn1 rd0 r0 n0)) (H0 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op),\nnolabel (insn2 rd0 r0 r2 s)) : tail_nolabel k\n  (if is_logical_imm32 n\n   then insn1 rd r1 (Int.unsigned n) :: k\n   else loadimm32 X16 n (insn2 rd r1 X16 SOnone :: k)).","proofString":"destruct (is_logical_imm32 n).\nTailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (rd r1 : ireg) (n : int) (k : code) (H : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z), nolabel (insn1 rd0 r0 n0)) (H0 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op),\nnolabel (insn2 rd0 r0 r2 s)) : tail_nolabel k (insn1 rd r1 (Int.unsigned n) :: k).","proofString":"TailNoLabel."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (rd r1 : ireg) (n : int) (k : code) (H : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z), nolabel (insn1 rd0 r0 n0)) (H0 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op),\nnolabel (insn2 rd0 r0 r2 s)) : tail_nolabel k (loadimm32 X16 n (insn2 rd r1 X16 SOnone :: k)).","proofString":"eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (rd r1 : ireg) (n : int64) (k : code) (H : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z), nolabel (insn1 rd0 r0 n0)) (H0 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op),\nnolabel (insn2 rd0 r0 r2 s)) : tail_nolabel k\n  (if is_logical_imm64 n\n   then insn1 rd r1 (Int64.unsigned n) :: k\n   else loadimm64 X16 n (insn2 rd r1 X16 SOnone :: k)).","proofString":"destruct (is_logical_imm64 n).\nTailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (rd r1 : ireg) (n : int64) (k : code) (H : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z), nolabel (insn1 rd0 r0 n0)) (H0 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op),\nnolabel (insn2 rd0 r0 r2 s)) : tail_nolabel k (insn1 rd r1 (Int64.unsigned n) :: k).","proofString":"TailNoLabel."},{"statement":"(insn1 : ireg -> ireg0 -> Z -> instruction) (insn2 : ireg -> ireg0 -> ireg -> shift_op -> instruction) (rd r1 : ireg) (n : int64) (k : code) (H : forall (rd0 : ireg) (r0 : ireg0) (n0 : Z), nolabel (insn1 rd0 r0 n0)) (H0 : forall (rd0 : ireg) (r0 : ireg0) (r2 : ireg) (s : shift_op),\nnolabel (insn2 rd0 r0 r2 s)) : tail_nolabel k (loadimm64 X16 n (insn2 rd r1 X16 SOnone :: k)).","proofString":"eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(rd r1 : ireg) (ex : extension) (a : int) (k : code) : tail_nolabel k\n  (if Int.eq a Int.zero\n   then\n    match ex with\n    | Xsgn32 => Pcvtsw2x rd r1 :: k\n    | Xuns32 => Pcvtuw2x rd r1 :: k\n    end\n   else\n    match ex with\n    | Xsgn32 => Pcvtsw2x rd r1 :: Padd X rd XZR rd (SOlsl a) :: k\n    | Xuns32 => Pcvtuw2x rd r1 :: Padd X rd XZR rd (SOlsl a) :: k\n    end).","proofString":"destruct Int.eq, ex; TailNoLabel."},{"statement":"(insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (rd r1 r2 : ireg) (ex : extension) (a : int) (k : code) (H : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op),\nnolabel (insnX rd0 r0 r3 x)) (H0 : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op),\nnolabel (insnS rd0 r0 r3 s)) : tail_nolabel k\n  (if Int.ltu a (Int.repr 5)\n   then insnX rd r1 r2 (transl_extension ex a) :: k\n   else move_extended_base X16 r2 ex (insnS rd r1 X16 (SOlsl a) :: k)).","proofString":"destruct Int.ltu.\nTailNoLabel.\ndestruct ex; simpl; TailNoLabel."},{"statement":"(insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (rd r1 r2 : ireg) (ex : extension) (a : int) (k : code) (H : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op),\nnolabel (insnX rd0 r0 r3 x)) (H0 : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op),\nnolabel (insnS rd0 r0 r3 s)) : tail_nolabel k (insnX rd r1 r2 (transl_extension ex a) :: k).","proofString":"TailNoLabel."},{"statement":"(insnX : iregsp -> iregsp -> ireg -> extend_op -> instruction) (insnS : ireg -> ireg0 -> ireg -> shift_op -> instruction) (rd r1 r2 : ireg) (ex : extension) (a : int) (k : code) (H : forall (rd0 r0 : iregsp) (r3 : ireg) (x : extend_op),\nnolabel (insnX rd0 r0 r3 x)) (H0 : forall (rd0 : ireg) (r0 : ireg0) (r3 : ireg) (s : shift_op),\nnolabel (insnS rd0 r0 r3 s)) : tail_nolabel k\n  (move_extended_base X16 r2 ex (insnS rd r1 X16 (SOlsl a) :: k)).","proofString":"destruct ex; simpl; TailNoLabel."},{"statement":"(r : ireg) (id : ident) (ofs : ptrofs) (k : code) : tail_nolabel k\n  (if SelectOp.symbol_is_relocatable id\n   then\n    if Ptrofs.eq ofs Ptrofs.zero\n    then Ploadsymbol r id :: k\n    else Ploadsymbol r id :: addimm64 r r (Ptrofs.to_int64 ofs) k\n   else Padrp r id ofs :: Paddadr r r id ofs :: k).","proofString":"destruct (SelectOp.symbol_is_relocatable id); TailNoLabel.\ndestruct Ptrofs.eq; TailNoLabel."},{"statement":"(r : ireg) (id : ident) (ofs : ptrofs) (k : code) : tail_nolabel k\n  (if Ptrofs.eq ofs Ptrofs.zero\n   then Ploadsymbol r id :: k\n   else Ploadsymbol r id :: addimm64 r r (Ptrofs.to_int64 ofs) k).","proofString":"destruct Ptrofs.eq; TailNoLabel."},{"statement":"(c0 : comparison) (n : int) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k\n  (if is_arith_imm32 n\n   then Pcmpimm W x (Int.unsigned n) :: k\n   else\n    if is_arith_imm32 (Int.neg n)\n    then Pcmnimm W x (Int.unsigned (Int.neg n)) :: k\n    else loadimm32 X16 n (Pcmp W x X16 SOnone :: k)).","proofString":"destruct is_arith_imm32; TailNoLabel.\ndestruct is_arith_imm32; TailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(c0 : comparison) (n : int) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k\n  (if is_arith_imm32 (Int.neg n)\n   then Pcmnimm W x (Int.unsigned (Int.neg n)) :: k\n   else loadimm32 X16 n (Pcmp W x X16 SOnone :: k)).","proofString":"destruct is_arith_imm32; TailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(c0 : comparison) (n : int) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k (loadimm32 X16 n (Pcmp W x X16 SOnone :: k)).","proofString":"eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(c0 : comparison) (n : int) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k\n  (if is_arith_imm32 n\n   then Pcmpimm W x (Int.unsigned n) :: k\n   else\n    if is_arith_imm32 (Int.neg n)\n    then Pcmnimm W x (Int.unsigned (Int.neg n)) :: k\n    else loadimm32 X16 n (Pcmp W x X16 SOnone :: k)).","proofString":"destruct is_arith_imm32; TailNoLabel.\ndestruct is_arith_imm32; TailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(c0 : comparison) (n : int) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k\n  (if is_arith_imm32 (Int.neg n)\n   then Pcmnimm W x (Int.unsigned (Int.neg n)) :: k\n   else loadimm32 X16 n (Pcmp W x X16 SOnone :: k)).","proofString":"destruct is_arith_imm32; TailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(c0 : comparison) (n : int) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k (loadimm32 X16 n (Pcmp W x X16 SOnone :: k)).","proofString":"eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(n : int) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k\n  (if is_logical_imm32 n\n   then Ptstimm W x (Int.unsigned n) :: k\n   else loadimm32 X16 n (Ptst W x X16 SOnone :: k)).","proofString":"destruct is_logical_imm32; TailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(n : int) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k (loadimm32 X16 n (Ptst W x X16 SOnone :: k)).","proofString":"eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(n : int) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k\n  (if is_logical_imm32 n\n   then Ptstimm W x (Int.unsigned n) :: k\n   else loadimm32 X16 n (Ptst W x X16 SOnone :: k)).","proofString":"destruct is_logical_imm32; TailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(n : int) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k (loadimm32 X16 n (Ptst W x X16 SOnone :: k)).","proofString":"eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(c0 : comparison) (n : int64) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k\n  (if is_arith_imm64 n\n   then Pcmpimm X x (Int64.unsigned n) :: k\n   else\n    if is_arith_imm64 (Int64.neg n)\n    then Pcmnimm X x (Int64.unsigned (Int64.neg n)) :: k\n    else loadimm64 X16 n (Pcmp X x X16 SOnone :: k)).","proofString":"destruct is_arith_imm64; TailNoLabel.\ndestruct is_arith_imm64; TailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(c0 : comparison) (n : int64) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k\n  (if is_arith_imm64 (Int64.neg n)\n   then Pcmnimm X x (Int64.unsigned (Int64.neg n)) :: k\n   else loadimm64 X16 n (Pcmp X x X16 SOnone :: k)).","proofString":"destruct is_arith_imm64; TailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(c0 : comparison) (n : int64) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k (loadimm64 X16 n (Pcmp X x X16 SOnone :: k)).","proofString":"eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(c0 : comparison) (n : int64) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k\n  (if is_arith_imm64 n\n   then Pcmpimm X x (Int64.unsigned n) :: k\n   else\n    if is_arith_imm64 (Int64.neg n)\n    then Pcmnimm X x (Int64.unsigned (Int64.neg n)) :: k\n    else loadimm64 X16 n (Pcmp X x X16 SOnone :: k)).","proofString":"destruct is_arith_imm64; TailNoLabel.\ndestruct is_arith_imm64; TailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(c0 : comparison) (n : int64) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k\n  (if is_arith_imm64 (Int64.neg n)\n   then Pcmnimm X x (Int64.unsigned (Int64.neg n)) :: k\n   else loadimm64 X16 n (Pcmp X x X16 SOnone :: k)).","proofString":"destruct is_arith_imm64; TailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(c0 : comparison) (n : int64) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k (loadimm64 X16 n (Pcmp X x X16 SOnone :: k)).","proofString":"eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(n : int64) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k\n  (if is_logical_imm64 n\n   then Ptstimm X x (Int64.unsigned n) :: k\n   else loadimm64 X16 n (Ptst X x X16 SOnone :: k)).","proofString":"destruct is_logical_imm64; TailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(n : int64) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k (loadimm64 X16 n (Ptst X x X16 SOnone :: k)).","proofString":"eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(n : int64) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k\n  (if is_logical_imm64 n\n   then Ptstimm X x (Int64.unsigned n) :: k\n   else loadimm64 X16 n (Ptst X x X16 SOnone :: k)).","proofString":"destruct is_logical_imm64; TailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(n : int64) (m : mreg) (k : code) (x : ireg) (EQ : ireg_of m = OK x) : tail_nolabel k (loadimm64 X16 n (Ptst X x X16 SOnone :: k)).","proofString":"eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(cond : condition) (args : list mreg) (lbl : label) (k : code) (c : list instruction) (H : transl_cond cond args (Pbc (cond_for_cond cond) lbl :: k) = OK c) : tail_nolabel k c.","proofString":"eapply tail_nolabel_trans; [eapply transl_cond_label;eauto|TailNoLabel]."},{"statement":"(c0 : comparison) (n : int) (m : mreg) (lbl : label) (k : code) (c : list instruction) (H : match c0 with\n| Ceq =>\n    if Int.eq n Int.zero\n    then bind (ireg_of m) (fun r1 : ireg => OK (Pcbz W r1 lbl :: k))\n    else transl_cond_branch_default (Ccompimm c0 n) (m :: nil) lbl k\n| Cne =>\n    if Int.eq n Int.zero\n    then bind (ireg_of m) (fun r1 : ireg => OK (Pcbnz W r1 lbl :: k))\n    else transl_cond_branch_default (Ccompimm c0 n) (m :: nil) lbl k\n| _ => transl_cond_branch_default (Ccompimm c0 n) (m :: nil) lbl k\nend = OK c) : tail_nolabel k c.","proofString":"destruct c0; TailNoLabel."},{"statement":"(c0 : comparison) (n : int) (m : mreg) (lbl : label) (k : code) (c : list instruction) (H : match c0 with\n| Ceq =>\n    if Int.eq n Int.zero\n    then bind (ireg_of m) (fun r1 : ireg => OK (Pcbz W r1 lbl :: k))\n    else transl_cond_branch_default (Ccompuimm c0 n) (m :: nil) lbl k\n| Cne =>\n    if Int.eq n Int.zero\n    then bind (ireg_of m) (fun r1 : ireg => OK (Pcbnz W r1 lbl :: k))\n    else transl_cond_branch_default (Ccompuimm c0 n) (m :: nil) lbl k\n| _ => transl_cond_branch_default (Ccompuimm c0 n) (m :: nil) lbl k\nend = OK c) : tail_nolabel k c.","proofString":"destruct c0; TailNoLabel."},{"statement":"(n : int) (m : mreg) (lbl : label) (k : code) (c : list instruction) (H : match Int.is_power2 n with\n| Some bit => bind (ireg_of m) (fun r1 : ireg => OK (Ptbz W r1 bit lbl :: k))\n| None => transl_cond_branch_default (Cmaskzero n) (m :: nil) lbl k\nend = OK c) : tail_nolabel k c.","proofString":"destruct (Int.is_power2 n); TailNoLabel."},{"statement":"(n : int) (m : mreg) (lbl : label) (k : code) (c : list instruction) (H : match Int.is_power2 n with\n| Some bit =>\n    bind (ireg_of m) (fun r1 : ireg => OK (Ptbnz W r1 bit lbl :: k))\n| None => transl_cond_branch_default (Cmasknotzero n) (m :: nil) lbl k\nend = OK c) : tail_nolabel k c.","proofString":"destruct (Int.is_power2 n); TailNoLabel."},{"statement":"(c0 : comparison) (n : int64) (m : mreg) (lbl : label) (k : code) (c : list instruction) (H : match c0 with\n| Ceq =>\n    if Int64.eq n Int64.zero\n    then bind (ireg_of m) (fun r1 : ireg => OK (Pcbz X r1 lbl :: k))\n    else transl_cond_branch_default (Ccomplimm c0 n) (m :: nil) lbl k\n| Cne =>\n    if Int64.eq n Int64.zero\n    then bind (ireg_of m) (fun r1 : ireg => OK (Pcbnz X r1 lbl :: k))\n    else transl_cond_branch_default (Ccomplimm c0 n) (m :: nil) lbl k\n| _ => transl_cond_branch_default (Ccomplimm c0 n) (m :: nil) lbl k\nend = OK c) : tail_nolabel k c.","proofString":"destruct c0; TailNoLabel."},{"statement":"(c0 : comparison) (n : int64) (m : mreg) (lbl : label) (k : code) (c : list instruction) (H : match c0 with\n| Ceq =>\n    if Int64.eq n Int64.zero\n    then bind (ireg_of m) (fun r1 : ireg => OK (Pcbz X r1 lbl :: k))\n    else transl_cond_branch_default (Ccompluimm c0 n) (m :: nil) lbl k\n| Cne =>\n    if Int64.eq n Int64.zero\n    then bind (ireg_of m) (fun r1 : ireg => OK (Pcbnz X r1 lbl :: k))\n    else transl_cond_branch_default (Ccompluimm c0 n) (m :: nil) lbl k\n| _ => transl_cond_branch_default (Ccompluimm c0 n) (m :: nil) lbl k\nend = OK c) : tail_nolabel k c.","proofString":"destruct c0; TailNoLabel."},{"statement":"(n : int64) (m : mreg) (lbl : label) (k : code) (c : list instruction) (H : match Int64.is_power2' n with\n| Some bit => bind (ireg_of m) (fun r1 : ireg => OK (Ptbz X r1 bit lbl :: k))\n| None => transl_cond_branch_default (Cmasklzero n) (m :: nil) lbl k\nend = OK c) : tail_nolabel k c.","proofString":"destruct (Int64.is_power2' n); TailNoLabel."},{"statement":"(n : int64) (m : mreg) (lbl : label) (k : code) (c : list instruction) (H : match Int64.is_power2' n with\n| Some bit =>\n    bind (ireg_of m) (fun r1 : ireg => OK (Ptbnz X r1 bit lbl :: k))\n| None => transl_cond_branch_default (Cmasklnotzero n) (m :: nil) lbl k\nend = OK c) : tail_nolabel k c.","proofString":"destruct (Int64.is_power2' n); TailNoLabel."},{"statement":"(m r : mreg) (k : code) (c : list instruction) (H : match preg_of r with\n| IR r0 =>\n    match preg_of m with\n    | IR a => OK (Pmov r0 a :: k)\n    | _ => Error (msg \"Asmgen.Omove\")\n    end\n| FR r0 =>\n    match preg_of m with\n    | FR a => OK (Pfmov r0 a :: k)\n    | _ => Error (msg \"Asmgen.Omove\")\n    end\n| _ => Error (msg \"Asmgen.Omove\")\nend = OK c) : tail_nolabel k c.","proofString":"destruct (preg_of r); try discriminate; destruct (preg_of m); inv H; TailNoLabel."},{"statement":"(n : float) (r : mreg) (k : code) (x : freg) (EQ : freg_of r = OK x) : tail_nolabel k\n  (if Float.eq_dec n Float.zero\n   then Pfmovi D x XZR :: k\n   else Pfmovimmd x n :: k).","proofString":"destruct (Float.eq_dec n Float.zero); TailNoLabel."},{"statement":"(n : float32) (r : mreg) (k : code) (x : freg) (EQ : freg_of r = OK x) : tail_nolabel k\n  (if Float32.eq_dec n Float32.zero\n   then Pfmovi S x XZR :: k\n   else Pfmovimms x n :: k).","proofString":"destruct (Float32.eq_dec n Float32.zero); TailNoLabel."},{"statement":"(n : int) (m r : mreg) (k : code) (x : ireg) (EQ : ireg_of r = OK x) (x0 : ireg) (EQ1 : ireg_of m = OK x0) : tail_nolabel k (logicalimm32 (Pandimm W) (Pand W) x x0 n k).","proofString":"apply logicalimm32_label; unfold nolabel; auto."},{"statement":"(n : int) (m r : mreg) (k : code) (x : ireg) (EQ : ireg_of r = OK x) (x0 : ireg) (EQ1 : ireg_of m = OK x0) : tail_nolabel k (logicalimm32 (Porrimm W) (Porr W) x x0 n k).","proofString":"apply logicalimm32_label; unfold nolabel; auto."},{"statement":"(n : int) (m r : mreg) (k : code) (x : ireg) (EQ : ireg_of r = OK x) (x0 : ireg) (EQ1 : ireg_of m = OK x0) : tail_nolabel k (logicalimm32 (Peorimm W) (Peor W) x x0 n k).","proofString":"apply logicalimm32_label; unfold nolabel; auto."},{"statement":"(n : int) (m r : mreg) (k : code) (x : ireg) (EQ : ireg_of r = OK x) (x0 : ireg) (EQ1 : ireg_of m = OK x0) : tail_nolabel k (shrx32 x x0 n k).","proofString":"unfold shrx32.\ndestruct Int.eq; TailNoLabel."},{"statement":"(n : int) (m r : mreg) (k : code) (x : ireg) (EQ : ireg_of r = OK x) (x0 : ireg) (EQ1 : ireg_of m = OK x0) : tail_nolabel k\n  (if Int.eq n Int.zero\n   then Pmov x x0 :: k\n   else\n    Porr W X16 XZR x0 (SOasr (Int.repr 31))\n    :: Padd W X16 x0 X16 (SOlsr (Int.sub Int.iwordsize n))\n       :: Porr W x XZR X16 (SOasr n) :: k).","proofString":"destruct Int.eq; TailNoLabel."},{"statement":"(x : extension) (a : amount64) (m m0 r : mreg) (k : code) (x0 : ireg) (EQ : ireg_of r = OK x0) (x1 : ireg) (EQ1 : ireg_of m = OK x1) (x2 : ireg) (EQ0 : ireg_of m0 = OK x2) : tail_nolabel k (arith_extended Paddext (Padd X) x0 x1 x2 x a k).","proofString":"apply arith_extended_label; unfold nolabel; auto."},{"statement":"(x : extension) (a : amount64) (m m0 r : mreg) (k : code) (x0 : ireg) (EQ : ireg_of r = OK x0) (x1 : ireg) (EQ1 : ireg_of m = OK x1) (x2 : ireg) (EQ0 : ireg_of m0 = OK x2) : tail_nolabel k (arith_extended Psubext (Psub X) x0 x1 x2 x a k).","proofString":"apply arith_extended_label; unfold nolabel; auto."},{"statement":"(n : int64) (m r : mreg) (k : code) (x : ireg) (EQ : ireg_of r = OK x) (x0 : ireg) (EQ1 : ireg_of m = OK x0) : tail_nolabel k (logicalimm64 (Pandimm X) (Pand X) x x0 n k).","proofString":"apply logicalimm64_label; unfold nolabel; auto."},{"statement":"(n : int64) (m r : mreg) (k : code) (x : ireg) (EQ : ireg_of r = OK x) (x0 : ireg) (EQ1 : ireg_of m = OK x0) : tail_nolabel k (logicalimm64 (Porrimm X) (Porr X) x x0 n k).","proofString":"apply logicalimm64_label; unfold nolabel; auto."},{"statement":"(n : int64) (m r : mreg) (k : code) (x : ireg) (EQ : ireg_of r = OK x) (x0 : ireg) (EQ1 : ireg_of m = OK x0) : tail_nolabel k (logicalimm64 (Peorimm X) (Peor X) x x0 n k).","proofString":"apply logicalimm64_label; unfold nolabel; auto."},{"statement":"(n : int) (m r : mreg) (k : code) (x : ireg) (EQ : ireg_of r = OK x) (x0 : ireg) (EQ1 : ireg_of m = OK x0) : tail_nolabel k (shrx64 x x0 n k).","proofString":"unfold shrx64.\ndestruct Int.eq; TailNoLabel."},{"statement":"(n : int) (m r : mreg) (k : code) (x : ireg) (EQ : ireg_of r = OK x) (x0 : ireg) (EQ1 : ireg_of m = OK x0) : tail_nolabel k\n  (if Int.eq n Int.zero\n   then Pmov x x0 :: k\n   else\n    Porr X X16 XZR x0 (SOasr (Int.repr 63))\n    :: Padd X X16 x0 X16 (SOlsr (Int.sub Int64.iwordsize' n))\n       :: Porr X x XZR X16 (SOasr n) :: k).","proofString":"destruct Int.eq; TailNoLabel."},{"statement":"(cond : condition) (args : list mreg) (r : mreg) (k : code) (c : list instruction) (x : ireg) (EQ : ireg_of r = OK x) (EQ0 : transl_cond cond args (Pcset x (cond_for_cond cond) :: k) = OK c) : tail_nolabel k c.","proofString":"eapply tail_nolabel_trans.\neapply transl_cond_label; eauto.\nTailNoLabel."},{"statement":"(cond : condition) (ty : typ) (m m0 : mreg) (args : list mreg) (r : mreg) (k : code) (c : list instruction) (H : match preg_of r with\n| IR r0 =>\n    bind (ireg_of m)\n      (fun r1 : ireg =>\n       bind (ireg_of m0)\n         (fun r2 : ireg =>\n          if ireg_eq r1 r2\n          then OK (Pmov r0 r1 :: k)\n          else\n           transl_cond cond args (Pcsel r0 r1 r2 (cond_for_cond cond) :: k)))\n| FR r0 =>\n    bind (freg_of m)\n      (fun r1 : freg =>\n       bind (freg_of m0)\n         (fun r2 : freg =>\n          if freg_eq r1 r2\n          then OK (Pfmov r0 r1 :: k)\n          else\n           transl_cond cond args (Pfsel r0 r1 r2 (cond_for_cond cond) :: k)))\n| _ => Error (msg \"Asmgen.Osel\")\nend = OK c) : tail_nolabel k c.","proofString":"destruct (preg_of r); try discriminate; TailNoLabel;  (eapply tail_nolabel_trans; [eapply transl_cond_label; eauto | TailNoLabel])."},{"statement":"(sz : Z) (x : extension) (a : amount64) (m m0 : mreg) (insn : addressing -> instruction) (k : code) (H0 : forall ad : addressing, nolabel (insn ad)) (x0 : ireg) (EQ : ireg_of m = OK x0) (x1 : ireg) (EQ1 : ireg_of m0 = OK x1) : tail_nolabel k\n  (arith_extended Paddext (Padd X) X16 x0 x1 x a\n     (insn (ADimm X16 Int64.zero) :: k)).","proofString":"eapply tail_nolabel_trans.\napply arith_extended_label; unfold nolabel; auto.\nTailNoLabel."},{"statement":"(insn : addressing -> instruction) (sz : Z) (base : iregsp) (ofs : ptrofs) (k : code) (H : forall ad : addressing, nolabel (insn ad)) : tail_nolabel k\n  (if offset_representable sz (Ptrofs.to_int64 ofs)\n   then insn (ADimm base (Ptrofs.to_int64 ofs)) :: k\n   else loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg base X16) :: k)).","proofString":"destruct offset_representable.\nTailNoLabel.\neapply tail_nolabel_trans; TailNoLabel."},{"statement":"(insn : addressing -> instruction) (sz : Z) (base : iregsp) (ofs : ptrofs) (k : code) (H : forall ad : addressing, nolabel (insn ad)) : tail_nolabel k (insn (ADimm base (Ptrofs.to_int64 ofs)) :: k).","proofString":"TailNoLabel."},{"statement":"(insn : addressing -> instruction) (sz : Z) (base : iregsp) (ofs : ptrofs) (k : code) (H : forall ad : addressing, nolabel (insn ad)) : tail_nolabel k\n  (loadimm64 X16 (Ptrofs.to_int64 ofs) (insn (ADreg base X16) :: k)).","proofString":"eapply tail_nolabel_trans; TailNoLabel."},{"statement":"(base : iregsp) (ofs : ptrofs) (ty : typ) (dst : mreg) (k : code) (c : list instruction) (H : match ty with\n| Tint =>\n    match preg_of dst with\n    | IR rd => OK (indexed_memory_access (Pldrw rd) 4 base ofs k)\n    | _ => Error (msg \"Asmgen.loadind\")\n    end\n| Tfloat =>\n    match preg_of dst with\n    | FR rd => OK (indexed_memory_access (Pldrd rd) 8 base ofs k)\n    | _ => Error (msg \"Asmgen.loadind\")\n    end\n| Tlong =>\n    match preg_of dst with\n    | IR rd => OK (indexed_memory_access (Pldrx rd) 8 base ofs k)\n    | _ => Error (msg \"Asmgen.loadind\")\n    end\n| Tsingle =>\n    match preg_of dst with\n    | FR rd => OK (indexed_memory_access (Pldrs rd) 4 base ofs k)\n    | _ => Error (msg \"Asmgen.loadind\")\n    end\n| Tany32 =>\n    match preg_of dst with\n    | IR rd => OK (indexed_memory_access (Pldrw_a rd) 4 base ofs k)\n    | _ => Error (msg \"Asmgen.loadind\")\n    end\n| Tany64 =>\n    match preg_of dst with\n    | IR rd => OK (indexed_memory_access (Pldrx_a rd) 8 base ofs k)\n    | FR rd => OK (indexed_memory_access (Pldrd_a rd) 8 base ofs k)\n    | _ => Error (msg \"Asmgen.loadind\")\n    end\nend = OK c) : tail_nolabel k c.","proofString":"destruct ty, (preg_of dst); inv H; apply indexed_memory_access_label; intros; exact I."},{"statement":"(src : mreg) (base : iregsp) (ofs : ptrofs) (ty : typ) (k : code) (c : list instruction) (H : match ty with\n| Tint =>\n    match preg_of src with\n    | IR rd => OK (indexed_memory_access (Pstrw rd) 4 base ofs k)\n    | _ => Error (msg \"Asmgen.storeind\")\n    end\n| Tfloat =>\n    match preg_of src with\n    | FR rd => OK (indexed_memory_access (Pstrd rd) 8 base ofs k)\n    | _ => Error (msg \"Asmgen.storeind\")\n    end\n| Tlong =>\n    match preg_of src with\n    | IR rd => OK (indexed_memory_access (Pstrx rd) 8 base ofs k)\n    | _ => Error (msg \"Asmgen.storeind\")\n    end\n| Tsingle =>\n    match preg_of src with\n    | FR rd => OK (indexed_memory_access (Pstrs rd) 4 base ofs k)\n    | _ => Error (msg \"Asmgen.storeind\")\n    end\n| Tany32 =>\n    match preg_of src with\n    | IR rd => OK (indexed_memory_access (Pstrw_a rd) 4 base ofs k)\n    | _ => Error (msg \"Asmgen.storeind\")\n    end\n| Tany64 =>\n    match preg_of src with\n    | IR rd => OK (indexed_memory_access (Pstrx_a rd) 8 base ofs k)\n    | FR rd => OK (indexed_memory_access (Pstrd_a rd) 8 base ofs k)\n    | _ => Error (msg \"Asmgen.storeind\")\n    end\nend = OK c) : tail_nolabel k c.","proofString":"destruct ty, (preg_of src); inv H; apply indexed_memory_access_label; intros; exact I."},{"statement":"(base : iregsp) (ofs : ptrofs) (dst : ireg) (k : code) : tail_nolabel k (loadptr base ofs dst k).","proofString":"apply indexed_memory_access_label.\nunfold nolabel; auto."},{"statement":"(base : iregsp) (ofs : ptrofs) (dst : ireg) (k : code) : forall ad : addressing, nolabel (Pldrx dst ad).","proofString":"unfold nolabel; auto."},{"statement":"(src : ireg) (base : iregsp) (ofs : ptrofs) (k : code) : tail_nolabel k (storeptr src base ofs k).","proofString":"apply indexed_memory_access_label.\nunfold nolabel; auto."},{"statement":"(src : ireg) (base : iregsp) (ofs : ptrofs) (k : code) : forall ad : addressing, nolabel (Pstrx src ad).","proofString":"unfold nolabel; auto."},{"statement":"(f : Mach.function) (k : code) : tail_nolabel k\n  (loadptr XSP (fn_retaddr_ofs f) X30\n     (Pfreeframe (fn_stacksize f) (fn_link_ofs f) :: k)).","proofString":"eapply tail_nolabel_trans.\napply loadptr_label.\nTailNoLabel."},{"statement":"(f : Mach.function) (i : ptrofs) (t : typ) (m : mreg) (ep : bool) (k c : code) (H : loadind XSP i t m k = OK c) : tail_nolabel k c.","proofString":"eapply loadind_label; eauto."},{"statement":"(f : Mach.function) (m : mreg) (i : ptrofs) (t : typ) (ep : bool) (k c : code) (H : storeind m XSP i t k = OK c) : tail_nolabel k c.","proofString":"eapply storeind_label; eauto."},{"statement":"(f : Mach.function) (i : ptrofs) (t : typ) (m : mreg) (ep : bool) (k : code) (x : list instruction) (EQ : loadind X15 i t m k = OK x) : tail_nolabel k (if ep then x else loadptr XSP (fn_link_ofs f) X15 x).","proofString":"destruct ep.\neapply loadind_label; eauto.\neapply tail_nolabel_trans.\napply loadptr_label.\neapply loadind_label; eauto."},{"statement":"(f : Mach.function) (i : ptrofs) (t : typ) (m : mreg) (k : code) (x : list instruction) (EQ : loadind X15 i t m k = OK x) : tail_nolabel k x.","proofString":"eapply loadind_label; eauto."},{"statement":"(f : Mach.function) (i : ptrofs) (t : typ) (m : mreg) (k : code) (x : list instruction) (EQ : loadind X15 i t m k = OK x) : tail_nolabel k (loadptr XSP (fn_link_ofs f) X15 x).","proofString":"eapply tail_nolabel_trans.\napply loadptr_label.\neapply loadind_label; eauto."},{"statement":"(f : Mach.function) (o : operation) (l : list mreg) (m : mreg) (ep : bool) (k c : code) (H : transl_op o l m k = OK c) : tail_nolabel k c.","proofString":"eapply transl_op_label; eauto."},{"statement":"(f : Mach.function) (m : memory_chunk) (a : Op.addressing) (l : list mreg) (m0 : mreg) (ep : bool) (k c : code) (H : transl_load m a l m0 k = OK c) : tail_nolabel k c.","proofString":"eapply transl_load_label; eauto."},{"statement":"(f : Mach.function) (m : memory_chunk) (a : Op.addressing) (l : list mreg) (m0 : mreg) (ep : bool) (k c : code) (H : transl_store m a l m0 k = OK c) : tail_nolabel k c.","proofString":"eapply transl_store_label; eauto."},{"statement":"(f : Mach.function) (s : signature) (s0 : mreg + ident) (ep : bool) (k c : code) (H : match s0 with\n| inl r => bind (ireg_of r) (fun r1 : ireg => OK (Pblr r1 s :: k))\n| inr symb => OK (Pbl symb s :: k)\nend = OK c) : tail_nolabel k c.","proofString":"destruct s0; monadInv H; TailNoLabel."},{"statement":"(f : Mach.function) (s : signature) (s0 : mreg + ident) (ep : bool) (k c : code) (H : match s0 with\n| inl r =>\n    bind (ireg_of r) (fun r1 : ireg => OK (make_epilogue f (Pbr r1 s :: k)))\n| inr symb => OK (make_epilogue f (Pbs symb s :: k))\nend = OK c) : tail_nolabel k c.","proofString":"destruct s0; monadInv H; (eapply tail_nolabel_trans; [eapply make_epilogue_label|TailNoLabel])."},{"statement":"(f : Mach.function) (c0 : condition) (l : list mreg) (l0 : Mach.label) (ep : bool) (k c : code) (H : transl_cond_branch c0 l l0 k = OK c) : tail_nolabel k c.","proofString":"eapply transl_cond_branch_label; eauto."},{"statement":"(f : Mach.function) (ep : bool) (k : code) : tail_nolabel k (make_epilogue f (Pret X30 :: k)).","proofString":"eapply tail_nolabel_trans; [eapply make_epilogue_label|TailNoLabel]."},{"statement":"(lbl : label) (f : Mach.function) (i : Mach.instruction) (ep : bool) (k c : code) (H : transl_instr f i ep k = OK c) : find_label lbl c = (if Mach.is_label lbl i then Some k else find_label lbl k).","proofString":"exploit transl_instr_label; eauto.\ndestruct i; try (intros [A B]; apply B).\nintros.\nsubst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (i : Mach.instruction) (ep : bool) (k c : code) (H : transl_instr f i ep k = OK c) : match i with\n| Mlabel lbl0 => c = Plabel lbl0 :: k\n| _ => tail_nolabel k c\nend ->\nfind_label lbl c = (if Mach.is_label lbl i then Some k else find_label lbl k).","proofString":"destruct i; try (intros [A B]; apply B).\nintros.\nsubst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k c : code) (H : transl_instr f (Mlabel l) ep k = OK c) : c = Plabel l :: k ->\nfind_label lbl c =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k).","proofString":"intros.\nsubst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k c : code) (H : transl_instr f (Mlabel l) ep k = OK c) (H0 : c = Plabel l :: k) : find_label lbl c =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k).","proofString":"subst c.\nsimpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k : code) (H : transl_instr f (Mlabel l) ep k = OK (Plabel l :: k)) : find_label lbl (Plabel l :: k) =\n(if Mach.is_label lbl (Mlabel l) then Some k else find_label lbl k).","proofString":"simpl.\nauto."},{"statement":"(lbl : label) (f : Mach.function) (l : Mach.label) (ep : bool) (k : code) (H : transl_instr f (Mlabel l) ep k = OK (Plabel l :: k)) : (if if peq lbl l then true else false then Some k else find_label lbl k) =\n(if if peq lbl l then true else false then Some k else find_label lbl k).","proofString":"auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (ep : bool) (tc : list instruction) (H : OK nil = OK tc) : find_label lbl tc = None.","proofString":"inv H.\nauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (ep : bool) : find_label lbl nil = None.","proofString":"auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc : list instruction) (H : bind (transl_code f c (it1_is_parent ep a))\n  (fun k : list instruction => transl_instr f a ep k) = \nOK tc) : match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc = None\nend.","proofString":"monadInv H.\nrewrite (transl_instr_label' lbl _ _ _ _ _ EQ0).\ngeneralize (Mach.is_label_correct lbl a).\ndestruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) : match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc = None\nend.","proofString":"rewrite (transl_instr_label' lbl _ _ _ _ _ EQ0).\ngeneralize (Mach.is_label_correct lbl a).\ndestruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) : match (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      (if Mach.is_label lbl a then Some x else find_label lbl x) = Some tc' /\\\n      transl_code f c' false = OK tc'\n| None => (if Mach.is_label lbl a then Some x else find_label lbl x) = None\nend.","proofString":"generalize (Mach.is_label_correct lbl a).\ndestruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) : (if Mach.is_label lbl a then a = Mlabel lbl else a <> Mlabel lbl) ->\nmatch (if Mach.is_label lbl a then Some c else Mach.find_label lbl c) with\n| Some c' =>\n    exists tc' : code,\n      (if Mach.is_label lbl a then Some x else find_label lbl x) = Some tc' /\\\n      transl_code f c' false = OK tc'\n| None => (if Mach.is_label lbl a then Some x else find_label lbl x) = None\nend.","proofString":"destruct (Mach.is_label lbl a); intros.\nsubst a.\nsimpl in EQ.\nexists x; auto.\neapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) (H : a = Mlabel lbl) : exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'.","proofString":"subst a.\nsimpl in EQ.\nexists x; auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ0 : transl_instr f (Mlabel lbl) ep x = OK tc) (EQ : transl_code f c (it1_is_parent ep (Mlabel lbl)) = OK x) : exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'.","proofString":"simpl in EQ.\nexists x; auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ0 : transl_instr f (Mlabel lbl) ep x = OK tc) (EQ : transl_code f c false = OK x) : exists tc' : code, Some x = Some tc' /\\ transl_code f c false = OK tc'.","proofString":"exists x; auto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (a : Mach.instruction) (c : list Mach.instruction) (IHc : forall (ep0 : bool) (tc0 : list instruction),\ntransl_code f c ep0 = OK tc0 ->\nmatch Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl tc0 = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl tc0 = None\nend) (ep : bool) (tc x : list instruction) (EQ : transl_code f c (it1_is_parent ep a) = OK x) (EQ0 : transl_instr f a ep x = OK tc) (H : a <> Mlabel lbl) : match Mach.find_label lbl c with\n| Some c' =>\n    exists tc' : code,\n      find_label lbl x = Some tc' /\\ transl_code f c' false = OK tc'\n| None => find_label lbl x = None\nend.","proofString":"eapply IHc; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (tf : function) (H : transf_function f = OK tf) : match Mach.find_label lbl (Mach.fn_code f) with\n| Some c =>\n    exists tc : code,\n      find_label lbl (fn_code tf) = Some tc /\\ transl_code f c false = OK tc\n| None => find_label lbl (fn_code tf) = None\nend.","proofString":"monadInv H.\ndestruct (zlt Ptrofs.max_unsigned (list_length_z x.(fn_code))); inv EQ0.\nmonadInv EQ.\nsimpl.\nrewrite transl_code'_transl_code in EQ0.\nerewrite tail_nolabel_find_label by (apply storeptr_label).\nsimpl.\neapply transl_code_label; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (tf x : function) (EQ : transl_function f = OK x) (EQ0 : (if zlt Ptrofs.max_unsigned (list_length_z (fn_code x))\n then Error (msg \"code size exceeded\")\n else OK x) = OK tf) : match Mach.find_label lbl (Mach.fn_code f) with\n| Some c =>\n    exists tc : code,\n      find_label lbl (fn_code tf) = Some tc /\\ transl_code f c false = OK tc\n| None => find_label lbl (fn_code tf) = None\nend.","proofString":"destruct (zlt Ptrofs.max_unsigned (list_length_z x.(fn_code))); inv EQ0.\nmonadInv EQ.\nsimpl.\nrewrite transl_code'_transl_code in EQ0.\nerewrite tail_nolabel_find_label by (apply storeptr_label).\nsimpl.\neapply transl_code_label; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (tf : function) (g : Ptrofs.max_unsigned >= list_length_z (fn_code tf)) (EQ : transl_function f = OK tf) : match Mach.find_label lbl (Mach.fn_code f) with\n| Some c =>\n    exists tc : code,\n      find_label lbl (fn_code tf) = Some tc /\\ transl_code f c false = OK tc\n| None => find_label lbl (fn_code tf) = None\nend.","proofString":"monadInv EQ.\nsimpl.\nrewrite transl_code'_transl_code in EQ0.\nerewrite tail_nolabel_find_label by (apply storeptr_label).\nsimpl.\neapply transl_code_label; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (x : code) (g : Ptrofs.max_unsigned >=\nlist_length_z\n  (fn_code\n     {|\n       fn_sig := Mach.fn_sig f;\n       fn_code :=\n         Pallocframe (fn_stacksize f) (fn_link_ofs f)\n         :: storeptr X30 XSP (fn_retaddr_ofs f)\n              (Pcfi_rel_offset (Ptrofs.to_int (fn_retaddr_ofs f)) :: x)\n     |})) (EQ0 : transl_code' f (Mach.fn_code f) true = OK x) : match Mach.find_label lbl (Mach.fn_code f) with\n| Some c =>\n    exists tc : code,\n      find_label lbl\n        (fn_code\n           {|\n             fn_sig := Mach.fn_sig f;\n             fn_code :=\n               Pallocframe (fn_stacksize f) (fn_link_ofs f)\n               :: storeptr X30 XSP (fn_retaddr_ofs f)\n                    (Pcfi_rel_offset (Ptrofs.to_int (fn_retaddr_ofs f)) :: x)\n           |}) = Some tc /\\ transl_code f c false = OK tc\n| None =>\n    find_label lbl\n      (fn_code\n         {|\n           fn_sig := Mach.fn_sig f;\n           fn_code :=\n             Pallocframe (fn_stacksize f) (fn_link_ofs f)\n             :: storeptr X30 XSP (fn_retaddr_ofs f)\n                  (Pcfi_rel_offset (Ptrofs.to_int (fn_retaddr_ofs f)) :: x)\n         |}) = None\nend.","proofString":"simpl.\nrewrite transl_code'_transl_code in EQ0.\nerewrite tail_nolabel_find_label by (apply storeptr_label).\nsimpl.\neapply transl_code_label; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (x : code) (g : Ptrofs.max_unsigned >=\nlist_length_z\n  (fn_code\n     {|\n       fn_sig := Mach.fn_sig f;\n       fn_code :=\n         Pallocframe (fn_stacksize f) (fn_link_ofs f)\n         :: storeptr X30 XSP (fn_retaddr_ofs f)\n              (Pcfi_rel_offset (Ptrofs.to_int (fn_retaddr_ofs f)) :: x)\n     |})) (EQ0 : transl_code' f (Mach.fn_code f) true = OK x) : match Mach.find_label lbl (Mach.fn_code f) with\n| Some c =>\n    exists tc : code,\n      find_label lbl\n        (storeptr X30 XSP (fn_retaddr_ofs f)\n           (Pcfi_rel_offset (Ptrofs.to_int (fn_retaddr_ofs f)) :: x)) =\n      Some tc /\\ transl_code f c false = OK tc\n| None =>\n    find_label lbl\n      (storeptr X30 XSP (fn_retaddr_ofs f)\n         (Pcfi_rel_offset (Ptrofs.to_int (fn_retaddr_ofs f)) :: x)) = None\nend.","proofString":"rewrite transl_code'_transl_code in EQ0.\nerewrite tail_nolabel_find_label by (apply storeptr_label).\nsimpl.\neapply transl_code_label; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (x : code) (g : Ptrofs.max_unsigned >=\nlist_length_z\n  (fn_code\n     {|\n       fn_sig := Mach.fn_sig f;\n       fn_code :=\n         Pallocframe (fn_stacksize f) (fn_link_ofs f)\n         :: storeptr X30 XSP (fn_retaddr_ofs f)\n              (Pcfi_rel_offset (Ptrofs.to_int (fn_retaddr_ofs f)) :: x)\n     |})) (EQ0 : transl_code f (Mach.fn_code f) true = OK x) : match Mach.find_label lbl (Mach.fn_code f) with\n| Some c =>\n    exists tc : code,\n      find_label lbl\n        (storeptr X30 XSP (fn_retaddr_ofs f)\n           (Pcfi_rel_offset (Ptrofs.to_int (fn_retaddr_ofs f)) :: x)) =\n      Some tc /\\ transl_code f c false = OK tc\n| None =>\n    find_label lbl\n      (storeptr X30 XSP (fn_retaddr_ofs f)\n         (Pcfi_rel_offset (Ptrofs.to_int (fn_retaddr_ofs f)) :: x)) = None\nend.","proofString":"erewrite tail_nolabel_find_label by (apply storeptr_label).\nsimpl.\neapply transl_code_label; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (x : code) (g : Ptrofs.max_unsigned >=\nlist_length_z\n  (fn_code\n     {|\n       fn_sig := Mach.fn_sig f;\n       fn_code :=\n         Pallocframe (fn_stacksize f) (fn_link_ofs f)\n         :: storeptr X30 XSP (fn_retaddr_ofs f)\n              (Pcfi_rel_offset (Ptrofs.to_int (fn_retaddr_ofs f)) :: x)\n     |})) (EQ0 : transl_code f (Mach.fn_code f) true = OK x) : match Mach.find_label lbl (Mach.fn_code f) with\n| Some c =>\n    exists tc : code,\n      find_label lbl\n        (Pcfi_rel_offset (Ptrofs.to_int (fn_retaddr_ofs f)) :: x) = \n      Some tc /\\ transl_code f c false = OK tc\n| None =>\n    find_label lbl (Pcfi_rel_offset (Ptrofs.to_int (fn_retaddr_ofs f)) :: x) =\n    None\nend.","proofString":"simpl.\neapply transl_code_label; eauto."},{"statement":"(lbl : Mach.label) (f : Mach.function) (x : code) (g : Ptrofs.max_unsigned >=\nlist_length_z\n  (fn_code\n     {|\n       fn_sig := Mach.fn_sig f;\n       fn_code :=\n         Pallocframe (fn_stacksize f) (fn_link_ofs f)\n         :: storeptr X30 XSP (fn_retaddr_ofs f)\n              (Pcfi_rel_offset (Ptrofs.to_int (fn_retaddr_ofs f)) :: x)\n     |})) (EQ0 : transl_code f (Mach.fn_code f) true = OK x) : match Mach.find_label lbl (Mach.fn_code f) with\n| Some c =>\n    exists tc : code,\n      find_label lbl x = Some tc /\\ transl_code f c false = OK tc\n| None => find_label lbl x = None\nend.","proofString":"eapply transl_code_label; eauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') : exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"exploit (transl_find_label lbl f tf); eauto.\nrewrite H2.\nintros [tc [A B]].\nexploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') : match Mach.find_label lbl (Mach.fn_code f) with\n| Some c =>\n    exists tc : code,\n      find_label lbl (fn_code tf) = Some tc /\\ transl_code f c false = OK tc\n| None => find_label lbl (fn_code tf) = None\nend ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"rewrite H2.\nintros [tc [A B]].\nexploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') : (exists tc : code,\n   find_label lbl (fn_code tf) = Some tc /\\ transl_code f c' false = OK tc) ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"intros [tc [A B]].\nexploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) : exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"exploit label_pos_code_tail; eauto.\ninstantiate (1 := 0).\nintros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) : (exists pos' : Z,\n   label_pos lbl 0 (fn_code tf) = Some pos' /\\\n   code_tail (pos' - 0) (fn_code tf) tc /\\\n   0 < pos' <= 0 + list_length_z (fn_code tf)) ->\nexists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"intros [pos' [P [Q R]]].\nexists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : exists (tc' : code) (rs' : regset),\n  goto_label tf lbl rs m = Next rs' m /\\\n  transl_code_at_pc ge (rs' PC) b f c' false tf tc' /\\\n  (forall r : preg, r <> PC -> rs' r = rs r).","proofString":"exists tc; exists (rs#PC <- (Vptr b (Ptrofs.repr pos'))).\nsplit.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : goto_label tf lbl rs m = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m /\\\ntransl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc /\\\n(forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r).","proofString":"split.\nunfold goto_label.\nrewrite P.\nrewrite H1.\nauto.\nsplit.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : goto_label tf lbl rs m = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","proofString":"unfold goto_label.\nrewrite P.\nrewrite H1.\nauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : match label_pos lbl 0 (fn_code tf) with\n| Some pos =>\n    match rs PC with\n    | Vptr b0 _ => Next rs # PC <- (Vptr b0 (Ptrofs.repr pos)) m\n    | _ => Stuck\n    end\n| None => Stuck\nend = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","proofString":"rewrite P.\nrewrite H1.\nauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : match rs PC with\n| Vptr b0 _ => Next rs # PC <- (Vptr b0 (Ptrofs.repr pos')) m\n| _ => Stuck\nend = Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","proofString":"rewrite H1.\nauto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : Next rs # PC <- (Vptr b (Ptrofs.repr pos')) m =\nNext rs # PC <- (Vptr b (Ptrofs.repr pos')) m.","proofString":"auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : transl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc /\\\n(forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r).","proofString":"split.\nrewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia.\nintros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : transl_code_at_pc ge (rs # PC <- (Vptr b (Ptrofs.repr pos')) PC) b f c' false\n  tf tc.","proofString":"rewrite Pregmap.gss.\nconstructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : transl_code_at_pc ge (Vptr b (Ptrofs.repr pos')) b f c' false tf tc.","proofString":"constructor; auto.\nrewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : code_tail (Ptrofs.unsigned (Ptrofs.repr pos')) (fn_code tf) tc.","proofString":"rewrite Ptrofs.unsigned_repr.\nreplace (pos' - 0) with pos' in Q.\nauto.\nlia.\ngeneralize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : code_tail pos' (fn_code tf) tc.","proofString":"replace (pos' - 0) with pos' in Q.\nauto.\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail pos' (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : code_tail pos' (fn_code tf) tc.","proofString":"auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : pos' = pos' - 0.","proofString":"lia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : 0 <= pos' <= Ptrofs.max_unsigned.","proofString":"generalize (transf_function_no_overflow _ _ H0).\nlia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : list_length_z (fn_code tf) <= Ptrofs.max_unsigned ->\n0 <= pos' <= Ptrofs.max_unsigned.","proofString":"lia."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) : forall r : preg, r <> PC -> rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r.","proofString":"intros.\napply Pregmap.gso; auto."},{"statement":"(f : Mach.function) (tf : function) (lbl : Mach.label) (rs : preg -> val) (m : mem) (c' : Mach.code) (b : block) (ofs : ptrofs) (H : Genv.find_funct_ptr ge b = Some (Internal f)) (H0 : transf_function f = OK tf) (H1 : rs PC = Vptr b ofs) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (tc : code) (A : find_label lbl (fn_code tf) = Some tc) (B : transl_code f c' false = OK tc) (pos' : Z) (P : label_pos lbl 0 (fn_code tf) = Some pos') (Q : code_tail (pos' - 0) (fn_code tf) tc) (R : 0 < pos' <= 0 + list_length_z (fn_code tf)) (r : preg) (H3 : r <> PC) : rs # PC <- (Vptr b (Ptrofs.repr pos')) r = rs r.","proofString":"apply Pregmap.gso; auto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs2 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs2 m2' /\\\n  agree ms2 sp rs2 /\\ (it1_is_parent ep i = true -> rs2 X15 = parent_sp s)) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c ms2 m2) st'.","proofString":"inversion H2.\nsubst.\nmonadInv H7.\nexploit H3; eauto.\nintros [rs2 [A [B C]]].\nexists (State rs2 m2'); split.\neapply exec_straight_exec; eauto.\neconstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c1 : code,\ntransl_instr f i ep k = OK c1 ->\nexists rs2 : regset,\n  exec_straight tge tf c1 rs1 m1' k rs2 m2' /\\\n  agree ms2 sp rs2 /\\ (it1_is_parent ep i = true -> rs2 X15 = parent_sp s)) (b : block) (ofs : ptrofs) (f0 : Mach.function) (c0 : list Mach.instruction) (ep0 : bool) (tf0 : function) (tc0 : list instruction) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H7 : transl_code f (i :: c) ep = OK tc) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr b ofs = rs1 PC) (H9 : b = fb) (H10 : f0 = f) (H11 : c0 = i :: c) (H12 : ep0 = ep) (H13 : tf0 = tf) (H14 : tc0 = tc) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c ms2 m2) st'.","proofString":"subst.\nmonadInv H7.\nexploit H3; eauto.\nintros [rs2 [A [B C]]].\nexists (State rs2 m2'); split.\neapply exec_straight_exec; eauto.\neconstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs2 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs2 m2' /\\\n  agree ms2 sp rs2 /\\ (it1_is_parent ep i = true -> rs2 X15 = parent_sp s)) (ofs : ptrofs) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H7 : transl_code f (i :: c) ep = OK tc) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr fb ofs = rs1 PC) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c ms2 m2) st'.","proofString":"monadInv H7.\nexploit H3; eauto.\nintros [rs2 [A [B C]]].\nexists (State rs2 m2'); split.\neapply exec_straight_exec; eauto.\neconstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs2 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs2 m2' /\\\n  agree ms2 sp rs2 /\\ (it1_is_parent ep i = true -> rs2 X15 = parent_sp s)) (ofs : ptrofs) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c ms2 m2) st'.","proofString":"exploit H3; eauto.\nintros [rs2 [A [B C]]].\nexists (State rs2 m2'); split.\neapply exec_straight_exec; eauto.\neconstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs2 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs2 m2' /\\\n  agree ms2 sp rs2 /\\ (it1_is_parent ep i = true -> rs2 X15 = parent_sp s)) (ofs : ptrofs) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) : (exists rs2 : regset,\n   exec_straight tge tf tc rs1 m1' x rs2 m2' /\\\n   agree ms2 sp rs2 /\\ (it1_is_parent ep i = true -> rs2 X15 = parent_sp s)) ->\nexists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c ms2 m2) st'.","proofString":"intros [rs2 [A [B C]]].\nexists (State rs2 m2'); split.\neapply exec_straight_exec; eauto.\neconstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs0 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs0 m2' /\\\n  agree ms2 sp rs0 /\\ (it1_is_parent ep i = true -> rs0 X15 = parent_sp s)) (ofs : ptrofs) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' x rs2 m2') (B : agree ms2 sp rs2) (C : it1_is_parent ep i = true -> rs2 X15 = parent_sp s) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c ms2 m2) st'.","proofString":"exists (State rs2 m2'); split.\neapply exec_straight_exec; eauto.\neconstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs0 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs0 m2' /\\\n  agree ms2 sp rs0 /\\ (it1_is_parent ep i = true -> rs0 X15 = parent_sp s)) (ofs : ptrofs) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' x rs2 m2') (B : agree ms2 sp rs2) (C : it1_is_parent ep i = true -> rs2 X15 = parent_sp s) : plus step tge (State rs1 m1') E0 (State rs2 m2').","proofString":"eapply exec_straight_exec; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H3 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists rs0 : regset,\n  exec_straight tge tf c0 rs1 m1' k rs0 m2' /\\\n  agree ms2 sp rs0 /\\ (it1_is_parent ep i = true -> rs0 X15 = parent_sp s)) (ofs : ptrofs) (H5 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H6 : transf_function f = OK tf) (H8 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H4 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' x rs2 m2') (B : agree ms2 sp rs2) (C : it1_is_parent ep i = true -> rs2 X15 = parent_sp s) : match_states (Mach.State s fb sp c ms2 m2) (State rs2 m2').","proofString":"econstructor; eauto.\neapply exec_straight_at; eauto."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"inversion H3.\nsubst.\nmonadInv H9.\nexploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c1 : code,\ntransl_instr f i ep k = OK c1 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight tge tf c1 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (b : block) (ofs : ptrofs) (f0 : Mach.function) (c0 : list Mach.instruction) (ep0 : bool) (tf0 : function) (tc0 : list instruction) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H9 : transl_code f (i :: c) ep = OK tc) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr b ofs = rs1 PC) (H11 : b = fb) (H12 : f0 = f) (H13 : c0 = i :: c) (H14 : ep0 = ep) (H15 : tf0 = tf) (H16 : tc0 = tc) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"subst.\nmonadInv H9.\nexploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H9 : transl_code f (i :: c) ep = OK tc) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"monadInv H9.\nexploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) : (exists (jmp : instruction) (k' : list instruction) \n (rs2 : regset),\n   exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2' /\\\n   agree ms2 sp rs2 /\\\n   exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') ->\nexists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"intros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"generalize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"generalize (transf_function_no_overflow _ _ H8); intro NOOV.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) : (exists ofs' : ptrofs,\n   rs2 PC = Vptr fb ofs' /\\\n   code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) ->\nexists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"intros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (ofs' : ptrofs) (PC2 : rs2 PC = Vptr fb ofs') (CT2 : code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (ofs' : ptrofs) (PC2 : rs2 PC = Vptr fb ofs') (CT2 : code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) (tc' : code) (rs3 : regset) (GOTO : goto_label tf lbl rs2 m2' = Next rs3 m2') (AT' : transl_code_at_pc ge (rs3 PC) fb f c' false tf tc') (OTH : forall r : preg, r <> PC -> rs3 r = rs2 r) : agree ms2 sp rs3.","proofString":"apply agree_exten with rs2; auto with asmgen."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (ofs' : ptrofs) (PC2 : rs2 PC = Vptr fb ofs') (CT2 : code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) (tc' : code) (rs3 : regset) (GOTO : goto_label tf lbl rs2 m2' = Next rs3 m2') (AT' : transl_code_at_pc ge (rs3 PC) fb f c' false tf tc') (OTH : forall r : preg, r <> PC -> rs3 r = rs2 r) : false = true -> rs3 X15 = parent_sp s.","proofString":"congruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"inversion H3.\nsubst.\nmonadInv H9.\nexploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c1 : code,\ntransl_instr f i ep k = OK c1 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight_opt tge tf c1 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (b : block) (ofs : ptrofs) (f0 : Mach.function) (c0 : list Mach.instruction) (ep0 : bool) (tf0 : function) (tc0 : list instruction) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H9 : transl_code f (i :: c) ep = OK tc) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr b ofs = rs1 PC) (H11 : b = fb) (H12 : f0 = f) (H13 : c0 = i :: c) (H14 : ep0 = ep) (H15 : tf0 = tf) (H16 : tc0 = tc) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"subst.\nmonadInv H9.\nexploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H9 : transl_code f (i :: c) ep = OK tc) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"monadInv H9.\nexploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit H5; eauto.\nintros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp : instruction) (k' : list instruction) \n(rs2 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp :: k') rs2 m2' /\\\n  agree ms2 sp rs2 /\\\n  exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) : (exists (jmp : instruction) (k' : list instruction) \n (rs2 : regset),\n   exec_straight_opt tge tf tc rs1 m1' (jmp :: k') rs2 m2' /\\\n   agree ms2 sp rs2 /\\\n   exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') ->\nexists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"intros [jmp [k' [rs2 [A [B C]]]]].\ngeneralize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight_opt tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"generalize (functions_transl _ _ _ H7 H8); intro FN.\ngeneralize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight_opt tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"generalize (transf_function_no_overflow _ _ H8); intro NOOV.\ninv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (A : exec_straight_opt tge tf tc rs1 m1' (jmp :: k') rs2 m2') (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"inv A.\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence.\nexploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (jmp : instruction) (k' : list instruction) (rs2 : regset) (H3 : transl_code_at_pc ge (rs2 PC) fb f (i :: c) ep tf (jmp :: k')) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs2 m2' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) (jmp :: k')) (H6 : Vptr fb ofs = rs2 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK (jmp :: k')) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) : exists st' : state,\n  plus step tge (State rs2 m2') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\napply plus_one.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (jmp : instruction) (k' : list instruction) (rs2 : regset) (H3 : transl_code_at_pc ge (rs2 PC) fb f (i :: c) ep tf (jmp :: k')) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs2 m2' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) (jmp :: k')) (H6 : Vptr fb ofs = rs2 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK (jmp :: k')) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (tc' : code) (rs3 : regset) (GOTO : goto_label tf lbl rs2 m2' = Next rs3 m2') (AT' : transl_code_at_pc ge (rs3 PC) fb f c' false tf tc') (OTH : forall r : preg, r <> PC -> rs3 r = rs2 r) : agree ms2 sp rs3.","proofString":"apply agree_exten with rs2; auto with asmgen."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (jmp : instruction) (k' : list instruction) (rs2 : regset) (H3 : transl_code_at_pc ge (rs2 PC) fb f (i :: c) ep tf (jmp :: k')) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs2 m2' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) (jmp :: k')) (H6 : Vptr fb ofs = rs2 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK (jmp :: k')) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (tc' : code) (rs3 : regset) (GOTO : goto_label tf lbl rs2 m2' = Next rs3 m2') (AT' : transl_code_at_pc ge (rs3 PC) fb f c' false tf tc') (OTH : forall r : preg, r <> PC -> rs3 r = rs2 r) : false = true -> rs3 X15 = parent_sp s.","proofString":"congruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (H9 : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit exec_straight_steps_2; eauto.\nintros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (H9 : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') : (exists ofs' : ptrofs,\n   rs2 PC = Vptr fb ofs' /\\\n   code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) ->\nexists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"intros [ofs' [PC2 CT2]].\nexploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (H9 : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (ofs' : ptrofs) (PC2 : rs2 PC = Vptr fb ofs') (CT2 : code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) : exists st' : state,\n  plus step tge (State rs1 m1') E0 st' /\\\n  match_states (Mach.State s fb sp c' ms2 m2) st'.","proofString":"exploit find_label_goto_label; eauto.\nintros [tc' [rs3 [GOTO [AT' OTH]]]].\nexists (State rs3 m2'); split.\neapply plus_right'.\neapply exec_straight_steps_1; eauto.\neconstructor; eauto.\neapply find_instr_tail.\neauto.\nrewrite C.\neexact GOTO.\ntraceEq.\neconstructor; eauto.\napply agree_exten with rs2; auto with asmgen.\ncongruence."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (H9 : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (ofs' : ptrofs) (PC2 : rs2 PC = Vptr fb ofs') (CT2 : code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) (tc' : code) (rs3 : regset) (GOTO : goto_label tf lbl rs2 m2' = Next rs3 m2') (AT' : transl_code_at_pc ge (rs3 PC) fb f c' false tf tc') (OTH : forall r : preg, r <> PC -> rs3 r = rs2 r) : agree ms2 sp rs3.","proofString":"apply agree_exten with rs2; auto with asmgen."},{"statement":"(s : list stackframe) (fb : block) (f : Mach.function) (rs1 : preg -> val) (i : Mach.instruction) (c : list Mach.instruction) (ep : bool) (tf : function) (tc : code) (m1' m2 m2' : mem) (sp : val) (ms2 : Mach.regset) (lbl : Mach.label) (c' : Mach.code) (H : match_stack ge s) (H0 : Mem.extends m2 m2') (H1 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H2 : Mach.find_label lbl (Mach.fn_code f) = Some c') (H3 : transl_code_at_pc ge (rs1 PC) fb f (i :: c) ep tf tc) (H4 : it1_is_parent ep i = false) (H5 : forall k c0 : code,\ntransl_instr f i ep k = OK c0 ->\nexists (jmp0 : instruction) (k'0 : list instruction) \n(rs0 : regset),\n  exec_straight_opt tge tf c0 rs1 m1' (jmp0 :: k'0) rs0 m2' /\\\n  agree ms2 sp rs0 /\\\n  exec_instr tge tf jmp0 rs0 m2' = goto_label tf lbl rs0 m2') (ofs : ptrofs) (H7 : Genv.find_funct_ptr ge fb = Some (Internal f)) (H8 : transf_function f = OK tf) (H10 : code_tail (Ptrofs.unsigned ofs) (fn_code tf) tc) (H6 : Vptr fb ofs = rs1 PC) (x : list instruction) (EQ : transl_code f c (it1_is_parent ep i) = OK x) (EQ0 : transl_instr f i ep x = OK tc) (jmp : instruction) (k' : list instruction) (rs2 : regset) (B : agree ms2 sp rs2) (C : exec_instr tge tf jmp rs2 m2' = goto_label tf lbl rs2 m2') (FN : Genv.find_funct_ptr tge fb = Some (Internal tf)) (NOOV : list_length_z (fn_code tf) <= Ptrofs.max_unsigned) (H9 : exec_straight tge tf tc rs1 m1' (jmp :: k') rs2 m2') (ofs' : ptrofs) (PC2 : rs2 PC = Vptr fb ofs') (CT2 : code_tail (Ptrofs.unsigned ofs') (fn_code tf) (jmp :: k')) (tc' : code) (rs3 : regset) (GOTO : goto_label tf lbl rs2 m2' = Next rs3 m2') (AT' : transl_code_at_pc ge (rs3 PC) fb f c' false tf tc') (OTH : forall r : preg, r <> PC -> rs3 r = rs2 r) : false = true -> rs3 X15 = parent_sp s.","proofString":"congruence."},{"statement":"(r : mreg) (H : negb (mreg_eq r R15) = true) : preg_of R15 <> preg_of r.","proofString":"red; intros.\nexploit preg_of_injective; eauto.\nintros; subst r; discriminate."},{"statement":"(r : mreg) (H : negb (mreg_eq r R15) = true) (H0 : preg_of R15 = preg_of r) : False.","proofString":"exploit preg_of_injective; eauto.\nintros; subst r; discriminate."},{"statement":"(r : mreg) (H : negb (mreg_eq r R15) = true) (H0 : preg_of R15 = preg_of r) : R15 = r -> False.","proofString":"intros; subst r; discriminate."},{"statement":"(ms : Mach.regset) (sp : val) (rs : regset) (H : agree ms sp rs) : sp = rs XSP.","proofString":"eapply sp_val; eauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) : exists st2 : state, initial_state tprog st2 /\\ match_states st1 st2.","proofString":"inversion H.\nunfold ge0 in *.\neconstructor; split.\neconstructor.\neapply (Genv.init_mem_transf_partial TRANSF); eauto.\nreplace (Genv.symbol_address (Genv.globalenv tprog) (prog_main tprog) Ptrofs.zero)     with (Vptr fb Ptrofs.zero).\neconstructor; eauto.\nconstructor.\napply Mem.extends_refl.\nsplit.\nauto.\nsimpl.\nunfold Vnullptr; destruct Archi.ptr64; congruence.\nintros.\nrewrite Regmap.gi.\nauto.\nunfold Genv.symbol_address.\nrewrite (match_program_main TRANSF).\nrewrite symbols_preserved.\nunfold ge; rewrite H1.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : exists st2 : state,\n  initial_state tprog st2 /\\\n  match_states (Callstate nil fb (Regmap.init Vundef) m0) st2.","proofString":"econstructor; split.\neconstructor.\neapply (Genv.init_mem_transf_partial TRANSF); eauto.\nreplace (Genv.symbol_address (Genv.globalenv tprog) (prog_main tprog) Ptrofs.zero)     with (Vptr fb Ptrofs.zero).\neconstructor; eauto.\nconstructor.\napply Mem.extends_refl.\nsplit.\nauto.\nsimpl.\nunfold Vnullptr; destruct Archi.ptr64; congruence.\nintros.\nrewrite Regmap.gi.\nauto.\nunfold Genv.symbol_address.\nrewrite (match_program_main TRANSF).\nrewrite symbols_preserved.\nunfold ge; rewrite H1.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : match_states (Callstate nil fb (Regmap.init Vundef) m0)\n  (State\n     (((Pregmap.init Vundef) # PC <- (Vptr fb Ptrofs.zero)) # X30 <- Vnullptr)\n     # SP <- Vnullptr m0).","proofString":"econstructor; eauto.\nconstructor.\napply Mem.extends_refl.\nsplit.\nauto.\nsimpl.\nunfold Vnullptr; destruct Archi.ptr64; congruence.\nintros.\nrewrite Regmap.gi.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : match_stack ge nil.","proofString":"constructor."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Mem.extends m0 m0.","proofString":"apply Mem.extends_refl."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : agree (Regmap.init Vundef) (parent_sp nil)\n  (((Pregmap.init Vundef) # PC <- (Vptr fb Ptrofs.zero)) # X30 <- Vnullptr)\n  # SP <- Vnullptr.","proofString":"split.\nauto.\nsimpl.\nunfold Vnullptr; destruct Archi.ptr64; congruence.\nintros.\nrewrite Regmap.gi.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : (((Pregmap.init Vundef) # PC <- (Vptr fb Ptrofs.zero)) # X30 <- Vnullptr)\n# SP <- Vnullptr SP = parent_sp nil.","proofString":"auto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : parent_sp nil <> Vundef.","proofString":"simpl.\nunfold Vnullptr; destruct Archi.ptr64; congruence."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Vnullptr <> Vundef.","proofString":"unfold Vnullptr; destruct Archi.ptr64; congruence."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : forall r : mreg,\nVal.lessdef (Regmap.init Vundef r)\n  ((((Pregmap.init Vundef) # PC <- (Vptr fb Ptrofs.zero)) # X30 <- Vnullptr)\n   # SP <- Vnullptr (preg_of r)).","proofString":"intros.\nrewrite Regmap.gi.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) (r : mreg) : Val.lessdef (Regmap.init Vundef r)\n  ((((Pregmap.init Vundef) # PC <- (Vptr fb Ptrofs.zero)) # X30 <- Vnullptr)\n   # SP <- Vnullptr (preg_of r)).","proofString":"rewrite Regmap.gi.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) (r : mreg) : Val.lessdef Vundef\n  ((((Pregmap.init Vundef) # PC <- (Vptr fb Ptrofs.zero)) # X30 <- Vnullptr)\n   # SP <- Vnullptr (preg_of r)).","proofString":"auto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Vptr fb Ptrofs.zero =\nGenv.symbol_address (Genv.globalenv tprog) (prog_main tprog) Ptrofs.zero.","proofString":"unfold Genv.symbol_address.\nrewrite (match_program_main TRANSF).\nrewrite symbols_preserved.\nunfold ge; rewrite H1.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Vptr fb Ptrofs.zero =\nmatch Genv.find_symbol (Genv.globalenv tprog) (prog_main tprog) with\n| Some b => Vptr b Ptrofs.zero\n| None => Vundef\nend.","proofString":"rewrite (match_program_main TRANSF).\nrewrite symbols_preserved.\nunfold ge; rewrite H1.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Vptr fb Ptrofs.zero =\nmatch Genv.find_symbol (Genv.globalenv tprog) (prog_main prog) with\n| Some b => Vptr b Ptrofs.zero\n| None => Vundef\nend.","proofString":"rewrite symbols_preserved.\nunfold ge; rewrite H1.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Vptr fb Ptrofs.zero =\nmatch Genv.find_symbol ge (prog_main prog) with\n| Some b => Vptr b Ptrofs.zero\n| None => Vundef\nend.","proofString":"unfold ge; rewrite H1.\nauto."},{"statement":"(st1 : Mach.state) (H : Mach.initial_state prog st1) (fb : block) (m0 : mem) (ge0 : Genv.t Mach.fundef unit) (H0 : Genv.init_mem prog = Some m0) (H1 : Genv.find_symbol (Genv.globalenv prog) (prog_main prog) = Some fb) (H2 : Callstate nil fb (Regmap.init Vundef) m0 = st1) : Vptr fb Ptrofs.zero = Vptr fb Ptrofs.zero.","proofString":"auto."},{"statement":"(st1 : Mach.state) (st2 : state) (r : int) (H : match_states st1 st2) (H0 : Mach.final_state st1 r) : final_state st2 r.","proofString":"inv H0.\ninv H.\nconstructor.\nassumption.\ncompute in H1.\ninv H1.\ngeneralize (preg_val _ _ _ R0 AG).\nrewrite H2.\nintros LD; inv LD.\nauto."},{"statement":"(st2 : state) (r : int) (rs : mreg -> val) (m : mem) (H : match_states (Returnstate nil rs m) st2) (r0 : mreg) (H1 : loc_result signature_main = One r0) (H2 : rs r0 = Vint r) : final_state st2 r.","proofString":"inv H.\nconstructor.\nassumption.\ncompute in H1.\ninv H1.\ngeneralize (preg_val _ _ _ R0 AG).\nrewrite H2.\nintros LD; inv LD.\nauto."},{"statement":"(r : int) (rs : mreg -> val) (m : mem) (r0 : mreg) (H1 : loc_result signature_main = One r0) (H2 : rs r0 = Vint r) (m' : mem) (rs0 : regset) (STACKS : match_stack ge nil) (MEXT : Mem.extends m m') (AG : agree rs (parent_sp nil) rs0) (ATPC : rs0 PC = parent_ra nil) : final_state (State rs0 m') r.","proofString":"constructor.\nassumption.\ncompute in H1.\ninv H1.\ngeneralize (preg_val _ _ _ R0 AG).\nrewrite H2.\nintros LD; inv LD.\nauto."},{"statement":"(r : int) (rs : mreg -> val) (m : mem) (r0 : mreg) (H1 : loc_result signature_main = One r0) (H2 : rs r0 = Vint r) (m' : mem) (rs0 : regset) (STACKS : match_stack ge nil) (MEXT : Mem.extends m m') (AG : agree rs (parent_sp nil) rs0) (ATPC : rs0 PC = parent_ra nil) : rs0 PC = Vnullptr.","proofString":"assumption."},{"statement":"(r : int) (rs : mreg -> val) (m : mem) (r0 : mreg) (H1 : loc_result signature_main = One r0) (H2 : rs r0 = Vint r) (m' : mem) (rs0 : regset) (STACKS : match_stack ge nil) (MEXT : Mem.extends m m') (AG : agree rs (parent_sp nil) rs0) (ATPC : rs0 PC = parent_ra nil) : rs0 X0 = Vint r.","proofString":"compute in H1.\ninv H1.\ngeneralize (preg_val _ _ _ R0 AG).\nrewrite H2.\nintros LD; inv LD.\nauto."},{"statement":"(r : int) (rs : mreg -> val) (m : mem) (r0 : mreg) (H1 : One R0 = One r0) (H2 : rs r0 = Vint r) (m' : mem) (rs0 : regset) (STACKS : match_stack ge nil) (MEXT : Mem.extends m m') (AG : agree rs (parent_sp nil) rs0) (ATPC : rs0 PC = parent_ra nil) : rs0 X0 = Vint r.","proofString":"inv H1.\ngeneralize (preg_val _ _ _ R0 AG).\nrewrite H2.\nintros LD; inv LD.\nauto."},{"statement":"(r : int) (rs : mreg -> val) (m : mem) (H2 : rs R0 = Vint r) (m' : mem) (rs0 : regset) (STACKS : match_stack ge nil) (MEXT : Mem.extends m m') (AG : agree rs (parent_sp nil) rs0) (ATPC : rs0 PC = parent_ra nil) : rs0 X0 = Vint r.","proofString":"generalize (preg_val _ _ _ R0 AG).\nrewrite H2.\nintros LD; inv LD.\nauto."},{"statement":"(r : int) (rs : mreg -> val) (m : mem) (H2 : rs R0 = Vint r) (m' : mem) (rs0 : regset) (STACKS : match_stack ge nil) (MEXT : Mem.extends m m') (AG : agree rs (parent_sp nil) rs0) (ATPC : rs0 PC = parent_ra nil) : Val.lessdef (rs R0) (rs0 (preg_of R0)) -> rs0 X0 = Vint r.","proofString":"rewrite H2.\nintros LD; inv LD.\nauto."},{"statement":"(r : int) (rs : mreg -> val) (m : mem) (H2 : rs R0 = Vint r) (m' : mem) (rs0 : regset) (STACKS : match_stack ge nil) (MEXT : Mem.extends m m') (AG : agree rs (parent_sp nil) rs0) (ATPC : rs0 PC = parent_ra nil) : Val.lessdef (Vint r) (rs0 (preg_of R0)) -> rs0 X0 = Vint r.","proofString":"intros LD; inv LD.\nauto."},{"statement":"(r : int) (rs : mreg -> val) (m : mem) (H2 : rs R0 = Vint r) (m' : mem) (rs0 : regset) (STACKS : match_stack ge nil) (MEXT : Mem.extends m m') (AG : agree rs (parent_sp nil) rs0) (ATPC : rs0 PC = parent_ra nil) (H1 : Vint r = rs0 X0) : Vint r = Vint r.","proofString":"auto."},{"statement":"forall id : ident,\nSenv.public_symbol (symbolenv (semantics tprog)) id =\nSenv.public_symbol (symbolenv (Mach.semantics return_address_offset prog)) id.","proofString":"apply senv_preserved."}]}